- en: Chapter 8. Introducing Device Drivers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kernel device drivers are the mechanism through which the underlying hardware
    is exposed to the rest of the system. As a developer of embedded systems, you
    need to know how device drivers fit into the overall architecture and how to access
    them from user space programs. Your system will probably have some novel pieces
    of hardware and you will have to work out a way of accessing them. In many cases,
    you will find that there are device drivers provided for you and you can achieve
    everything you want without writing any kernel code. For example, you can manipulate
    GPIO pins and LEDs using files in `sysfs`, and there are libraries to access serial
    buses, including SPI and I2C.
  prefs: []
  type: TYPE_NORMAL
- en: There are many places to find out how to write a device driver, but few to tell
    you why you would want to and the choices you have in doing so. That is what I
    want to cover here. However, remember that this is not a book dedicated to writing
    kernel device drivers and that the information given here is to help you navigate
    the territory but not necessarily to set up home there. There are many good books
    and articles that will help you to write device drivers, some of which are listed
    at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The role of device drivers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned in [Chapter 4](ch04.html "Chapter 4. Porting and Configuring the
    Kernel"), *Porting and Configuring the Kernel*, one of the functions of the kernel
    is to encapsulate the many hardware interfaces of a computer system and present
    them in a consistent manner to user-space programs. There are frameworks designed
    to make it easy to write the interface logic for a device in the kernel and you
    can integrate it with the kernel: this is a device driver, the piece of code that
    mediates between the kernel above it and the hardware below. A device driver is
    a piece of software that controls physical devices such as a UART or an MMC controller,
    or virtual devices such as the null device (`/dev/null`) or a ramdisk. One driver
    may control multiple devices of the same kind.'
  prefs: []
  type: TYPE_NORMAL
- en: Kernel device driver code runs at a high privilege level, as does the rest of
    the kernel. It has full access to the processor address space and hardware registers.
    It can handle interrupts and DMA transfers. It can make use of the sophisticated
    kernel infrastructure for synchronization and memory management. There is a downside
    to this, which is that if something goes wrong in a buggy driver, it can go really
    wrong and bring the system down. Consequently, there is a principle that device
    drivers should be as simple as possible, just providing information to applications
    where the real decisions are made. You often hear this being expressed as *no
    policy in the kernel*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Linux, there are three main types of device driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '**character**: This is for unbuffered I/O with a rich range of functions and
    a thin layer between the application code and the driver. It is the first choice
    when implementing custom device drivers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**block**: This has an interface tailored for block I/O to and from mass storage
    devices. There is a thick layer of buffering designed to make disk reads and writes
    as fast as possible, which makes it unsuitable for anything else.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**network**: This is similar to a block device but is used for transmitting
    and receiving network packets rather than disk blocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also a fourth type that presents itself as a group of files in one
    of the pseudo filesystems. For example, you might access the GPIO driver through
    a group of files in `/sys/class/gpio`, as I will describe later on in this chapter.
    Let's begin by looking in more detail at the three basic device types.
  prefs: []
  type: TYPE_NORMAL
- en: Character devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These devices are identified in user space by a filename: if you want to read
    from a UART, you open the device node, for example, the first serial port on the
    ARM Versatile Express would be `/dev/ttyAMA0`. The driver is identified differently
    in the kernel, using the major number which, in the example given, is `204`. Since
    the UART driver can handle more than one UART, there is a second number, called
    the minor number, which identifies a specific interface, 64, in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The list of standard major and minor numbers can be found in the kernel documentation,
    in `Documentation/devices.txt`. The list does not get updated very often and does
    not include the `ttyAMA` device described in the preceding paragraph. Nevertheless,
    if you look at the source code in `drivers/tty/serial/amba-pl011.c`, you will
    see that the major and minor numbers are declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Where there is more than one instance of a device, the naming convention for
    the device nodes is `<base name><interface number>`, for example, `ttyAMA0`, `ttyAMA1`,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'As I mentioned in [Chapter 5](ch05.html "Chapter 5. Building a Root Filesystem"),
    *Building a Root Filesystem*, the device nodes can be created in several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '`devtmpfs`: The node that is created when the device driver registers a new
    device interface using a base name supplied by the driver (`ttyAMA`) and an instance
    number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`udev` or `mdev` (without `devtmpfs`): Essentially the same as with `devtmpfs`,
    except that a user-space daemon program has to extract the device name from `sysfs`
    and create the node. I will talk about `sysfs` later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mknod`: If you are using static device nodes, they are created manually using
    `mknod`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may have the impression from the numbers I have used above that both major
    and minor numbers are 8-bit numbers in the range 0 to 255\. In fact, from Linux
    2.6 onwards, the major number is 12 bits long, which gives valid numbers from
    1 to 4,095, and the minor number is 20 bits, from 0 to 1,048,575.
  prefs: []
  type: TYPE_NORMAL
- en: When you open a device node, the kernel checks to see whether the major and
    minor numbers fall into a range registered by a device driver of that type (a
    character or block). If so, it passes the call to the driver, otherwise the open
    call fails. The device driver can extract the minor number to find out which hardware
    interface to use. If the minor number is out of range, it returns an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write a program that accesses a device driver, you have to have some knowledge
    of how it works. In other words, a device driver is not the same as a file: the
    things you do with it change the state of the device. A simple example is the
    pseudo random number generator, `urandom`, which returns bytes of random data
    every time you read it. Here is a program that does just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The nice thing about the Unix driver model is that, once we know that there
    is a device named `urandom` and that every time we read from it, it returns a
    fresh set of pseudo random data, we don't need to know anything else about it.
    We can just use normal functions such as `open(2)`, `read(2)`, and `close(2)`.
  prefs: []
  type: TYPE_NORMAL
- en: We could use the stream I/O functions `fopen(3)`, `fread(3)`, and `fclose(3)`
    instead, but the buffering implicit in these functions often causes unexpected
    behavior. For example, `fwrite(3)` usually only writes to the user-space buffer,
    not to the device. We would need to call `fflush(3)` to force the buffer to be
    written out.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't use stream I/O functions such as `fread(3)` and `fwrite(3)` when calling
    device drivers.
  prefs: []
  type: TYPE_NORMAL
- en: Block devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Block devices are also associated with a device node, which also has major and
    minor numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although character and block devices are identified using major and minor numbers,
    they are in different namespaces. A character driver with a major number 4 is
    in no way related to a block driver with a major number 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'With block devices, the major number is used to identify the device driver
    and the minor number is used to identify the partition. Let''s look at the MMC
    driver as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The major number is 179 (look it up in `devices.txt`!). The minor numbers are
    used in ranges to identify different `mmc` devices and the partitions of the storage
    medium on that device. In the case of the mmcblk driver, the ranges are eight
    minor numbers per device: the minor numbers from 0 to 7 are for the first device,
    the numbers from 8 to 15 are for the second, and so on. Within each range, the
    first minor number represents the entire device as raw sectors, and the others
    represent up to seven partitions.'
  prefs: []
  type: TYPE_NORMAL
- en: You are probably aware of the SCSI disk driver, known as sd, which is used to
    control a range of disks that use the SCSI command set, which includes SCSI, SATA,
    USB mass storage, and **UFS** (**universal flash storage**). It has the major
    number eight and ranges of 16 minor numbers per interface (or disk). The minor
    numbers from 0 to 15 are for the first interface, with device nodes named `sda`
    up to `sda15`, the numbers from 16 to 31 are for the second disk with device nodes
    `sdb` up to `sdb15`, and so on. This continues up to the sixteenth disk from 240
    to 255, with the node name `sdp`. There are other major numbers reserved for them
    because SCSI disks are so popular, but we needn't worry about that here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The partitions are created using utilities such as `fdisk`, `sfidsk`, or `parted`.
    An exception is raw flash memory: the partition information for the MTD driver
    is part of the kernel command line or in the device tree, or one of the other
    methods described in [Chapter 7](ch07.html "Chapter 7. Creating a Storage Strategy"),
    *Creating a Storage Strategy*.'
  prefs: []
  type: TYPE_NORMAL
- en: A user-space program can open and interact directly with a block device through
    the device node. This is not a common thing to do, and is usually for performing
    administrative operations such as partitioning, formatting with a filesystem,
    and mounting. Once the filesystem is mounted, you interact with the block device
    indirectly through the files in that filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Network devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Network devices are not accessed through device nodes and they do not have
    major and minor numbers. Instead, a network device is allocated a name by the
    kernel, based on a string and an instance number. Here is an example of the way
    a network driver registers an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This creates a network device named `net0` the first time it is called, `net1`
    the second, and so on. More common names are `lo`, `eth0`, and `wlan0`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this is the name it starts off with; device managers, such as `udev`,
    may change to something different later on.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, the network interface name is only used when configuring the network
    using utilities such as `ip` and `ifconfig` to establish a network address and
    route. Thereafter, you interact with the network driver indirectly by opening
    sockets, and let the network layer decide how to route them to the right interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it is possible to access network devices directly from user space
    by creating a socket and using the `ioctl` commands listed in `include/linux/sockios.h`.
    For example, this program uses `SIOCGIFHWADDR` to query the driver for the hardware
    (MAC) address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is a standard device, `ioctl`, which is handled by the network layer on
    the driver's behalf, but it is possible to define your own `ioctl` numbers and
    handle them in a custom network driver.
  prefs: []
  type: TYPE_NORMAL
- en: Finding out about drivers at runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have a running Linux system, it is useful to know which device drivers
    are loaded and what state they are in. You can find out a lot by reading the files
    in `/proc` and `/sys`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, you can list the character and block device drivers currently
    loaded and active by reading `/proc/devices`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: For each driver, you can see the major number and the base name. However, this
    does not tell you how many devices each driver is attached to. It only shows `ttyAMA`
    but gives you no clue that it is attached to four real UARTS. I will come back
    to that later when I look at `sysfs`. If you are using a device manager such as
    `mdev`, `udev`, or `devtmpfs`, you can list the character and block device interfaces
    by looking in `/dev`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also list network interfaces using `ifconfig` or `ip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can also find out about devices attached to USB or PCI buses using the well-known
    commands `lsusb` and `lspci`. There is information about them in the respective
    manuals and plenty of online guides, so I will not describe them any further here.
  prefs: []
  type: TYPE_NORMAL
- en: The really interesting information is in `sysfs`, which is the next topic.
  prefs: []
  type: TYPE_NORMAL
- en: Getting information from sysfs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can define `sysfs` in a pedantic way as a representation of kernel objects,
    attributes and relationships. A kernel object is a directory, an attribute is
    a file, and a relationship is a symbolic link from one object to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a more practical point of view, since the Linux device driver model, which
    was introduced in version 2.6, represents all devices and drivers as kernel objects.
    You can see the kernel''s view of the system laid out before you by looking in
    `/sys`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the context of discovering information about devices and drivers, I will
    look at three of the directories: `devices`, `class`, and `block`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The devices: /sys/devices'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the kernel''s view of the devices discovered since boot and how they
    are connected to each other. It is organized at the top level by the system bus,
    so what you see varies from one system to another. This is the QEMU emulation
    of the Versatile Express:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three directories that are present on all systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '`system`: This contains devices at the heart of the system, including CPUs
    and clocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`virtual`: This contains devices that are memory-based. You will find the memory
    devices that appear as `/dev/null`, `/dev/random`, and `/dev/zero` in `virtual/mem`.
    You will find the loopback device, `lo`, in `virtual/net`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`platform`: This is a catch-all for devices that are not connected via a conventional
    hardware bus. This may be almost everything on an embedded device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other devices appear in directories that correspond to actual system buses.
    For example, the PCI root bus, if there is one, appears as `pci0000:00`.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating this hierarchy is quite hard because it requires some knowledge of
    the topology of your system and the pathnames become quite long and hard to remember.
    To make life easier, `/sys/class` and `/sys/block` offer two different views of
    the devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The drivers: /sys/class'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a view of the device drivers presented by their type, in other words,
    it is a software view rather than a hardware view. Each of the subdirectories
    represents a class of driver and is implemented by a component of the driver framework.
    For example, UART devices are managed by the `tty` layer and you will find them
    in `/sys/class/tty`. Likewise, you will find network devices in `/sys/class/net`,
    input devices such as the keyboard, the touchscreen, and the mouse in `/sys/class/input`,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: There is a symbolic link in each subdirectory for each instance of that type
    of device pointing to its representation in `/sys/device`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To take a concrete example, let''s look at `/sys/class/tty/ttyAMA0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The link `device` references the hardware node for the device and `subsystem`
    points back to `/sys/class/tty`. The others are attributes of the device. Some
    are specific to a UART, such as `xmit_fifo_size` and others apply to many types
    of device such as the interrupt number, `irq`, and the device number `dev`. Some
    attribute files are writable and allow you to tune parameters in the driver at
    runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `dev` attribute is particularly interesting. If you look at its value,
    you will find the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: These are the major and minor numbers of this device. This attribute is created
    when the driver registered this interface and it is from this file that `udev`
    and `mdev` read that information if they are being used without the help of `devtmpfs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The block drivers: /sys/block'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is one more view of the device model that is important: the block driver
    view that you will find in `/sys/block`. There is a subdirectory for each block
    device. This example is taken from a BeagleBone Black:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look into `mmcblk1`, which is the eMMC chip on this board, you can see
    the attributes of the interface and the partitions within it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The conclusion, then, is that you can learn a lot about the devices (the hardware)
    and the drivers (the software) that are present on a system by reading `sysfs`.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the right device driver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A typical embedded board is based on a reference design from the manufacturer
    with changes to make it suitable for a particular application. It may have a temperature
    sensor attached via I2C, lights and buttons connected via GPIO pins, an external
    Ethernet MAC, a display panel via a MIPI interface, or many other things. Your
    job is to create a custom kernel to control all of that, so where do you start?
  prefs: []
  type: TYPE_NORMAL
- en: Some things are so simple that you can write user space code to handle them.
    GPIOs and simple peripherals connected via I2C or SPI are easy to control from
    user space, as I will explain later.
  prefs: []
  type: TYPE_NORMAL
- en: Other things need a kernel driver so you need to know how to find one and incorporate
    it into your build. There is no simple answer, but here are some places to look.
  prefs: []
  type: TYPE_NORMAL
- en: The most obvious place to look is the driver support page on the manufacturer's
    website, or you could ask them directly. In my experience, this seldom gets the
    result you want; hardware manufacturers are not are not particularly Linux-savvy
    and they often give you misleading information. They may have proprietary drivers
    as binary blobs or they may have source code, but for a different version of the
    kernel than the one you have. So, by all means try this route. I will always try
    to find an open source driver for the task in hand.
  prefs: []
  type: TYPE_NORMAL
- en: 'There may be support in your kernel already: there are many thousands of drivers
    in mainline Linux and there are many vendor-specific drivers in the vendor kernels.
    Begin by running `make menuconfig` (or `xconfig`) and search for the product name
    or number. If you do not find an exact match, try more generic searches, allowing
    for the fact that most drivers handle a range of products from the same family.
    Next, try searching through the code in the drivers directory (`grep` is you friend
    here). Always make sure you are running the latest kernel for your board: later
    kernels generally have more device drivers.'
  prefs: []
  type: TYPE_NORMAL
- en: If you still don't have a driver, you can try searching online and asking in
    the relevant forums to see if there is a driver for a different version of Linux.
    If you find one, you will have to backport it to your kernel. If the kernel versions
    are similar, it may be easy, but if they are more than 12 to 18 months apart,
    the chances are that the interfaces will have changed to the extent that you will
    have to rewrite a chunk of the driver to integrate it with your kernel. You may
    want to outsource this work. If all of the above fails, you will have to find
    a solution yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Device drivers in user-space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you start writing a device driver, pause for a moment to consider whether
    it is really necessary. There are generic device drivers for many common types
    of device that allow you to interact with hardware directly from user space without
    having to write a line of kernel code. User space code is certainly easier to
    write and debug. It is also not covered by the GPL, although I don't feel that
    is a good reason in itself to do it this way.
  prefs: []
  type: TYPE_NORMAL
- en: 'They fall into two broad categories: those that you control through files in
    `sysfs`, including GPIO and LEDs, and serial buses that expose a generic interface
    through a device node, such as I2C.'
  prefs: []
  type: TYPE_NORMAL
- en: GPIO
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**General Purpose Input/Output** (**GPIO**) is the simplest form of digital
    interface since it gives you direct access to individual hardware pins, each of
    which can be configured as input or output. GPIO can even be used to create higher
    level interfaces such as I2C or SPI by manipulating each bit in the software,
    a technique that is called bit banging. The main limitation is the speed and accuracy
    of the software loops and the number of CPU cycles you want to dedicate to them.
    Generally speaking, it is hard to achieve timer accuracy better than a millisecond
    with kernels compiled with `CONFIG_PREEMPT`, and 100 microseconds with `RT_PREEMPT`,
    as we shall see in [Chapter 14](ch14.html "Chapter 14. Real-time Programming"),
    *Real-time Programming*. More common use cases for GPIO are for reading push buttons
    and digital sensors and controlling LEDs, motors, and relays.'
  prefs: []
  type: TYPE_NORMAL
- en: Most SoCs have a lot of GPIO bits which are grouped together in GPIO registers,
    usually 32 bits per register. On-chip GPIO bits are routed through to GPIO pins
    on the chip package via a multiplexer, known as a pin mux, which I will describe
    later. There may be additional GPIO bits available off-chip in the power management
    chip, and in dedicated GPIO extenders, connected through I2C or SPI buses. All
    this diversity is handled by a kernel subsystem known as `gpiolib`, which is not
    actually a library but the infrastructure GPIO drivers use to expose IO in a consistent
    way.
  prefs: []
  type: TYPE_NORMAL
- en: There are details about the implementation of `gpiolib` in the kernel source
    in `Documentation/gpio` and the drivers themselves are in `drivers/gpio`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Applications can interact with `gpiolib` through files in the `/sys/class/gpio`
    directory. Here is an example of what you will see in there on a typical embedded
    board (a BeagleBone Black):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `gpiochip0` to `gpiochip96` directories represent four GPIO registers,
    each with 32 GPIO bits. If you look in one of the `gpiochip` directories, you
    will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The file `base` contains the number of the first GPIO pin in the register and
    `ngpio` contains the number of bits in the register. In this case, `gpiochip96/base`
    is 96 and `gpiochip96/ngpio` is 32, which tells you that it contains GPIO bits
    96 to 127\. It is possible for there to be a gap between the last GPIO in one
    register and the first GPIO in the next.
  prefs: []
  type: TYPE_NORMAL
- en: 'To control a GPIO bit from user space, you first have to export it from kernel
    space, which you do by writing the GPIO number to `/sys/class/gpio/export`. This
    example shows the process for GPIO 48:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now there is a new directory, `gpio48`, which contains the files you need to
    control the pin. Note that if the GPIO bit is already claimed by the kernel, you
    will not be able to export it in this way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The directory `gpio48` contains these files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The pin begins as an input. To change it to an output, write `out` to the `direction`
    file. The file `value` contains the current state of the pin, which is 0 for low
    and 1 for high. If it is an output, you can change the state by writing 0 or 1
    to `value`. Sometimes, the meaning of low and high is reversed in hardware (hardware
    engineers enjoy doing that sort of thing), so writing 1 to `active_low` inverts
    the meaning so that a low voltage is reported as 1 in `value` and a high voltage
    as 0.
  prefs: []
  type: TYPE_NORMAL
- en: You can remove a GPIO from user space control by writing the GPIO number to
    `/sys/class/gpio/unexport`.
  prefs: []
  type: TYPE_NORMAL
- en: Handling interrupts from GPIO
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In many cases, a GPIO input can be configured to generate an interrupt when
    it changes state, which allows you to wait for the interrupt rather than polling
    in an inefficient software loop. If the GPIO bit can generate interrupts, the
    file `edge` exists. Initially, it has the value `none`, meaning that it does not
    generate interrupts. To enable interrupts, you can set it to one of these values:'
  prefs: []
  type: TYPE_NORMAL
- en: '**rising**: Interrupt on rising edge'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**falling**: Interrupt on falling edge'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**both**: Interrupt on both rising and falling edges'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**none**: No interrupts (default)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can wait for an interrupt using the `poll()` function with `POLLPRI` as
    the event. If you want to wait for a rising edge on GPIO 48, you first enable
    interrupts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you use `poll()` to wait for the change, as shown in this code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: LEDs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LEDs are often controlled though a GPIO pin, but there is another kernel subsystem
    that offers more specialized control specific to the purpose. The `leds` kernel
    subsystem adds the ability to set brightness, should the LED have that ability,
    and can handle LEDs connected in other ways than a simple GPIO pin. It can be
    configured to trigger the LED on an event such as block device access or just
    a heartbeat to show that the device is working. There is more information in `Documentation/leds/`
    and the drivers are in `drivers/leds/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with GPIOs, LEDs are controlled through an interface in `sysfs`, in `/sys/class/leds`.
    The LEDs have names in the form `devicename:colour:function`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows one individual LED:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `brightness` file controls the brightness of the LED and can be a number
    between 0 (off) and `max_brightness` (fully on). If the LED doesn''t support intermediate
    brightness, any non-zero value turns it on and zero turns it off. The file `trigger`
    lists the events that trigger the LED to turn on. The list of triggers is implementation-dependent.
    Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The trigger currently selected is shown in square brackets. You can change
    it by writing one of the other triggers to the file. If you want to control the
    LED entirely through `brightness`, select `none`. If you set the trigger to `timer`,
    two extra files appear that allow you to set the on and off times in milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If the LED has on-chip timer hardware, the blinking takes place without interrupting
    the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: I2C
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I2C is a simple low speed 2-wire bus that is common on embedded boards, typically
    used to access peripherals which are not on the SoC board such as display controllers,
    camera sensors, GPIO extenders, and the like. There is a related standard known
    as SMBus (system management bus) that is found on PCs, that is used to access
    temperature and voltage sensors. SMBus is a subset of I2C.
  prefs: []
  type: TYPE_NORMAL
- en: I2C is a master-slave protocol, with the master being one or more host controllers
    on the SoC. Slaves have a 7-bit address assigned by the manufacturer – read the
    data sheet – allowing up to 128 nodes per bus, but 16 are reserved, so only 112
    nodes are allowed in practice. The bus speed is 100 KHz in standard mode, or up
    to 400 KHz in fast mode. The protocol allows read and write transactions between
    the master and slave of up to 32 bytes. Frequently, the first byte is used to
    specify a register on the peripheral and the remaining bytes are the data read
    from or written to that register.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one device node for each host controller, for example, this SoC has
    four:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The device interface provides a series of `ioctl` commands that query the host
    controller and send `read` and `write` commands to I2C slaves. There is a package
    named `i2c-tools` which uses this interface to provide basic command-line tools
    to interact with I2C devices. The tools are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`i2cdetect`: This lists the I2C adapters and probes the bus'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i2cdump`: This dumps data from all the registers of an I2C peripheral'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i2cget`: This reads data from an I2C slave'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i2cset`: This writes data to an I2C slave'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `i2c-tools` package is available in Buildroot and the Yocto Project, as
    well as most mainstream distributions. So long as you know the address and protocol
    of the slave, writing a user space program to talk to the device is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note that the header `i2c-dev.h` is the one from the `i2c-tools` package, not
    the one from the Linux kernel headers. The `i2c_smbus_read_word_data()` function
    is written inline in `i2c-dev.h`.
  prefs: []
  type: TYPE_NORMAL
- en: There is more information about the Linux implementation of I2C in `Documentation/i2c/dev-interface`.
    The host controller drivers are in `drivers/i2c/busses`.
  prefs: []
  type: TYPE_NORMAL
- en: SPI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The serial peripheral interface bus is similar to I2C, but is a lot faster,
    up to the low MHz. The interface uses four wires with separate send and receive
    lines which allows it to operate in full duplex. Each chip on the bus is selected
    with a dedicated chip select line. It is commonly used to connect to touchscreen
    sensors, display controllers, and serial NOR flash devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with I2C, it is a master-slave protocol, with most SoCs implementing one
    or more master host controllers. There is a generic SPI device driver which you
    can enable through the kernel configuration `CONFIG_SPI_SPIDEV`. It creates a
    device node for each SPI controller which allows you to access SPI chips from
    user space. The device nodes are named `spidev[bus].[chip select]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: For examples of using the `spidev` interface, refer to the example code in `Documentation/spi`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a kernel device driver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Eventually, when you have exhausted all the user-space options above, you will
    find yourself having to write a device driver to access a piece of hardware attached
    to your device. While this is not the time or place to delve into details, it
    is worth considering the options. Character drivers are the most flexible and
    should cover 90% of all your needs; network devices apply if you are working with
    a network interface, and block devices are for mass storage. The task of writing
    a kernel driver is complex and beyond the scope of this book. There are some references
    at the end that will help you on your way. In this section, I want to outline
    the options available for interacting with a driver—a topic not normally covered—and
    show you the basic bones of a driver.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a character device interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main character device interface is based on a stream of bytes, as you would
    have with a serial port. However, many devices don''t fit this description: a
    controller for a robot arm needs functions to move and rotate each joint, for
    example. Luckily, there are other ways to communicate with device drivers that
    just `read(2)` and `write(2)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ioctl`: The `ioctl` function allows you to pass two arguments to your driver
    which can have any meaning you like. By convention, the first argument is a command
    which selects one of several functions in your driver, and the second is a pointer
    to a structure which serves as a container for the input and output parameters.
    This is a blank canvas that allows you to design any program interface you like
    and it is pretty common when the driver and application are closely linked and
    written by the same team. However, `ioctl` is deprecated in the kernel and you
    will find it hard to get any drivers with new uses of `ioctl` accepted upstream.
    The kernel maintainers dislike `ioctl` because it makes kernel code and application
    code too interdependent, and it is hard to keep both of them in step across kernel
    versions and architectures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sysfs`: This is the preferred way now, a good example being the GPIO interface
    described earlier. The advantages are that it is self-documenting, so long as
    you choose descriptive names for the files. It is also scriptable because the
    file contents are ASCII strings. On the other hand, the requirement for each file
    to contain a single value makes it hard to achieve atomicity if you need to change
    more than one value at a time. For example, if you want to set two values and
    then initiate an action, you would need to write to three files: two for the inputs
    and a third to trigger the action. Even then, there is no guarantee that the other
    two files have not been changed by someone else. Conversely, `ioctl` passes all
    its arguments in a structure in a single function call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mmap`: You can get direct access to kernel buffers and hardware registers
    by mapping kernel memory into user-space, bypassing the kernel. You may still
    need some kernel code to handle interrupts and DMA. There is a subsystem that
    encapsulates this idea, known as `uio`, short for user I/O. There is more documentation
    in `Documentation/DocBook/uio-howto`, and there are example drivers in `drivers/uio`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sigio`: You can send a signal from a driver using the kernel function `kill_fasync()`
    to notify applications of an event such as input becoming ready or an interrupt
    being received. By convention, signal SIGIO is used, but it could be anyone. You
    can see some examples in the UIO driver, `drivers/uio/uio.c`, and in the RTC driver,
    `drivers/char/rtc.c`. The main problem is that it is difficult to write reliable
    signal handlers and so it remains a little-used facility.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`debugfs`: This is another pseudo filesystem that represents kernel data as
    files and directories, similar to `proc` and `sysfs`. The main distinction is
    that `debugfs` must not contain information that is needed for the normal operation
    of the system; it is for debug and trace information only. It is mounted as `mount
    -t debugfs debug /sys/kernel/debug`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a good description of `debugfs` in the kernel documentation, `Documentation/filesystems/debugfs.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: '`proc`: The `proc` filesystem is deprecated for all new code unless it relates
    to processes, which was the original intended purpose for the filesystem. However,
    the you can use `proc` to publish any information you choose. And, unlike `sysfs`
    and `debugfs`, it is available to non-GPL modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`netlink`: This is a socket protocol family. `AF_NETLINK` creates a socket
    that links kernel space to user-space. It was originally created so that network
    tools could communicate with the Linux network code to access the routing tables
    and other details. It is also used by udev to pass events from the kernel to the
    udev daemon. It is very rarely used in general device drivers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many examples of all of the preceding filesystem in the kernel source
    code and you can design really interesting interfaces to your driver code. The
    only universal rule is the *principle of least astonishment*. In other words,
    application writers using your driver should find that everything works in a logical
    way with no quirks or oddities.
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of a device driver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's time to draw some threads together by looking at the code for a simple
    device driver.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code is provided for a device driver named `dummy` which creates
    four devices that are accessed through `/dev/dummy0` to `/dev/dummy3`. This is
    the complete code for the driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: At the end of the code, the macros `module_init` and `module_exit` specify the
    functions to be called when the module is loaded and unloaded. The other three
    add some basic information about the module which can be retrieved from the compiled
    kernel module using the `modinfo` command.
  prefs: []
  type: TYPE_NORMAL
- en: When the module is loaded, the `dummy_init()` function is called.
  prefs: []
  type: TYPE_NORMAL
- en: You can see the point at which it becomes a character device by calling `register_chrdev`,
    passing a pointer to `struct file_operations` containing pointers to the four
    functions that the driver implements. While `register_chrdev` tells the kernel
    that there is a driver with a major number of 42, it doesn't say anything about
    the type of driver, and so it will not create an entry in `/sys/class`. Without
    an entry in `/sys/class`, the device manager cannot create device nodes. So, the
    next few lines of code create a device class, `dummy`, and four devices of that
    class called `dummy0` to `dummy3`. The result is the `/sys/class/dummy` directory,
    containing the `dummy0` to `dummy3` subdirectories, each containing a file, `dev`,
    with the major and minor numbers of the device. This is all that a device manager
    needs to create device nodes, `/dev/dummy0` to `/dev/dummy3`.
  prefs: []
  type: TYPE_NORMAL
- en: The `exit` function has to release the resources claimed by the `init` function
    which, here, means freeing up the device class and major number.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file operation for this driver are implemented by `dummy_open()`, `dummy_read()`,
    `dummy_write()`, and `dummy_release()`, and are called when a user space program
    calls `open(2)`, `read(2)`, `write(2)`, and `close(2)`. They just print a kernel
    message so that you can see that they were called. You can demonstrate this from
    the command line using the `echo` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the messages appear because I was logged on to the console, and
    kernel messages are printed to the console by default.
  prefs: []
  type: TYPE_NORMAL
- en: The full source code for this driver is less than 100 lines, but it is enough
    to illustrate how the linkage between a device node and driver code works, how
    the device class is created, allowing a device manager to create device nodes
    automatically when the driver is loaded, and how data is moved between user and
    kernel spaces. Next, you need to build it.
  prefs: []
  type: TYPE_NORMAL
- en: Compile and load
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point you have some driver code that you want to compile and test on
    your target system. You can copy it into the kernel source tree and modify makefiles
    to build it, or you can compile it as a module out of tree. Let's start by building
    out of tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need a simple makefile which uses the kernel build system to do the hard
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Set `LINUXDIR` to the directory of the kernel for your target device that you
    will be running the module on. The code `obj-m := dummy.o` will invoke the kernel
    build rule to take the source file, `dummy.c` and create kernel module, `dummy.ko`.
    Note that kernel modules are not binary compatible between kernel releases and
    configurations, the module will only load on the kernel it was compiled with.
  prefs: []
  type: TYPE_NORMAL
- en: The end result of the build is the kernel `dummy.ko` which you can copy to the
    target and load as shown in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to build a driver in the kernel source tree, the procedure is quite
    simple. Choose a directory appropriate to the type of driver you have. The driver
    is a basic character device, so I would put `dummy.c` in `drivers/char`. Then,
    edit the makefile in that directory and add a line to build the driver unconditionally
    as a module, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Or add the following line this to build it unconditionally as a built-in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If you want to make the driver optional, you can add a menu option to the `Kconfig`
    file and make the compilation conditional on the configuration option, as I described
    in [Chapter 4](ch04.html "Chapter 4. Porting and Configuring the Kernel"), *Porting
    and Configuring the Kernel*, when describing the kernel configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Loading kernel modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can load, unload and list modules using the simple `insmod`, `lsmod`, and
    `rmmod` commands. Here they are shown loading the dummy driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If the module is placed in a subdirectory in `/lib/modules/<kernel release>`,
    as in the example, you can create a modules dependency database using the command
    `depmod`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The information in the `module.*` files is used by the command `modprobe` to
    locate a module by name rather than the full path. `modprobe` has many other features
    which are described in the manual.
  prefs: []
  type: TYPE_NORMAL
- en: The module dependency information is also used by device managers, `udev` in
    particular. When new hardware is detected, for example a new USB device, the `udevd`
    daemon is alerted and passed the vendor, and product IDs are read from the hardware.
    `udevd` scans the module dependency files looking for a module that has registered
    those IDs. If one is found, it is loaded using `modprobe`.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering hardware configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The dummy driver demonstrates the structure of a device driver, but it lacks
    interaction with real hardware since it only manipulates memory structures. Device
    drivers are usually written to interact with hardware and part of that is being
    able to discover the hardware in the first place, bearing in mind that it may
    be at different addresses in different configurations.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, the hardware provides the information itself. Devices on a discoverable
    bus such as PCI or USB have a query mode which returns resource requirements and
    a unique identifier. The kernel matches the identifier and possibly other characteristics
    with the device drivers, and marries them up.
  prefs: []
  type: TYPE_NORMAL
- en: However, most of the hardware blocks on an SoC do not have such identifiers.
    You have to provide the information yourself in the form of a device tree or as
    C structures known as platform data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the standard driver model for Linux, device drivers register themselves
    with the appropriate subsystem: PCI, USB, open firmware (device tree), platform
    device, and so on. The registration includes an identifier and a callback function
    called a probe function that is called if there is a match between the ID of the
    hardware and the ID of the driver. For PCI and USB, the ID is based on the vendor
    and the product IDs of the devices, for device tree and platform devices, it is
    a name (an ASCII string).'
  prefs: []
  type: TYPE_NORMAL
- en: Device trees
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I gave you an introduction to device trees in [Chapter 3](ch03.html "Chapter 3. All
    About Bootloaders"), *All About Bootloaders*. Here, I want to show you how the
    Linux device drivers hook up with that information.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, I will use the ARM Versatile board, `arch/arm/boot/dts/versatile-ab.dts`,
    for which the Ethernet adapter is defined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Platform data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the absence of device tree support, there is a fallback method of describing
    hardware using C structures, known as platform data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each piece of hardware is described by `struct platform_device`, which has
    a name and a pointer to an array of resources. The type of the resource is determined
    by flags, which include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IORESOURCE_MEM`: The physical address of a region of memory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IORESOURCE_IO`: The physical address or port number of IO registers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IORESOURCE_IRQ`: The interrupt number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of the platform data for an Ethernet controller taken from
    `arch/arm/mach-versatile/core.c`, which has been edited for clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'It has a memory area of 64 KiB and an interrupt. The platform data has to be
    registered with the kernel, usually when the board is initialized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Linking hardware with device drivers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You have seen in the preceding section how an Ethernet adapter is described
    using a device tree and using platform data. The corresponding driver code is
    in `drivers/net/ethernet/smsc/smc91x.c` and it works with both the device tree
    and platform data. Here is the initialization code, once again edited for clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: When the driver is initialized, it calls `platform_driver_register()`, pointing
    to `struct platform_driver`, in which there is a callback to a probe function,
    a driver name, `smc91x,` and a pointer to `struct of_device_id`.
  prefs: []
  type: TYPE_NORMAL
- en: If this driver has been configured by the device tree, the kernel will look
    for a match between the `compatible` property in the device tree node and the
    string pointed to by the compatible structure element. For each match, it calls
    the `probe` function.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if it was configured through platform data, the `probe` function
    will be called for each match on the string pointed to by `driver.name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `probe` function extracts information about the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The calls t`o platform_get_resource()` extract the memory and `irq` information
    from either the device tree or the platform data. It is up to the driver to map
    the memory and install the interrupt handler. The third parameter, which is zero
    in both of the previous cases, comes into play if there is more than one resource
    of that particular type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Device trees allow you to configure more than just basic memory ranges and
    interrupts, however. There is a section of code in the `probe` function that extracts
    optional parameters from the device tree. In this snippet, it gets the `register-io-width`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: For most drivers, specific bindings are documented in `Documentation/devicetree/bindings`.
    For this particular driver, the information is in `Documentation/devicetree/bindings/net/smsc911x.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: The main thing to remember here is that drivers should register a `probe` function
    and enough information for the kernel to call the `probe` as it finds matches
    with the hardware it knows about. The linkage between the hardware described by
    the device tree and the device driver is through the `compatible` property. The
    linkage between platform data and a driver is through the name.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following resources have further information about the topics introduced
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Linux Device Drivers, 4th edition*, by *Jessica McKellar*, *Alessandro Rubini*,
    *Jonathan Corbet*, and *Greg Kroah-Hartman*. This is not published at the time
    of writing, but if it is as good as the predecessor, it will be a good choice.
    However, the 3rd edition is too out of date to recommend.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Linux Kernel Development, 3rd edition* by *Robert Love*, *Addison-Wesley*
    Professional; (July 2, 2010) ISBN-10: 0672329468'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Linux Weekly News*, [www.lwn.net](https://www.lwn.net).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Device drivers have the job of handling devices, usually physical hardware
    but sometimes virtual interfaces, and presenting it to higher levels in a consistent
    and useful way. Linux device drivers fall into three broad categories: the character,
    the block, and the network. Of the three, the character driver interface is the
    most flexible and therefore, the most common. Linux drivers fit into a framework
    known as the driver model, which is exposed through `sysfs`. Pretty much the entire
    state of the devices and drivers is visible in `/sys`.'
  prefs: []
  type: TYPE_NORMAL
- en: Each embedded system has its own unique set of hardware interfaces and requirements.
    Linux provides drivers for most standard interfaces, and by selecting the right
    kernel configuration, you can get the device operational very quickly. That leaves
    you with the non-standard components for which you will have to add your own device
    support.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, you can sidestep the issue by using generic drivers for GPIO,
    I2C, and so on, and write user space code to do the work. I recommend this as
    a starting point as it gives you the chance to get familiar with the hardware
    without writing kernel code. Writing kernel drivers is not particularly difficult
    but, if you do, you need to code carefully so as to not compromise the stability
    of the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'I have talked about writing kernel driver code: if you go down that route,
    you will inevitably want to know how to check whether or not it is working correctly
    and detect any bugs. I will cover that topic in [Chapter 12](ch12.html "Chapter 12. Debugging
    with GDB"), *Debugging with GDB*.'
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is all about user space initialization and the different options
    you have for the `init` program, from the simple BusyBox to the complex systemd.
  prefs: []
  type: TYPE_NORMAL
