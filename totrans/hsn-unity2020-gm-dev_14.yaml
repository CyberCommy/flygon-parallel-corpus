- en: '*Chapter 14*: Implementing Movement and Spawning'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have prepared our project to start coding, let's create our first
    behavior. We will see the basics of how to move objects through scripting using
    the `Transform` component, which will be applied for the movement of our Player
    with the Keys, the constant movement of bullets, and other objects' movement.
    Also, we will see how to create and destroy objects during the game, such as bullets
    our Player and Enemy shoot and the Enemy Wave Spawners. These actions can be used
    in several other scenarios, so we will explore a few to reinforce the idea.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will examine the following scripting concepts:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Implementing movement
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing spawning
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start scripting components to do the previously mentioned movement behavior,
    and then we will continue with object creation and destruction.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Implementing movement
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost every object in the game moves one way or another, the Player character
    with the keyboard, the Enemies through AI, the bullets simply move forward, and
    so on. There are several ways of moving objects in Unity, so we will start with
    the simplest one, that is, through the `Transform` component.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will examine the following movement concepts:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Moving objects through Transform
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Input
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Delta Time
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, we will explore how to access the Transform component in our script to
    drive the Player movement, to later apply movement based on the Player's keyboard
    Input. Finally, we are going to explore the concept of Delta Time to make sure
    the movement speeds are consistent in every computer. We are going to start learning
    about the Transform API to master simple movement.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Moving objects through Transform
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Transform` is the component that holds the Translation, Rotation, and Scale
    of an object, so every movement system such as Physics or Pathfinding will affect
    this component. Anyway, sometimes we want to move an object in a specific way
    according to our game by creating our own script, which will handle the movement
    calculations we need and modify Transform to apply them.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'One concept implied here is that components alter other components. The main
    way of coding in Unity is to create components that interact with other components.
    Here, the idea is to create one that accesses another and tells it to do something,
    in this case, to move. To create a script that tells `Transform` to move, do the
    following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Create and add a script called `Player Movement` to our character. In this case,
    it would be the animated robot object we created previously. Remember to move
    the script to the `Scripts` folder after creation:![Figure 14.1 – Creating a Player
    Movement script for the character
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_14.01_B14199.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.1 – Creating a Player Movement script for the character
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Double-click the created script asset to open an IDE to edit the code.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are moving, and the movement is applied every frame, so this script will
    use only the `update` function or method, and we can remove `Start` (it is a good
    practice to remove unused functions):![Figure 14.2 – A component with just the
    update event function
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_14.02_B14199.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.2 – A component with just the update event function
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: To move our object along its forward axis (Z-axis), add the `transform.Translate(0,0,1);`
    line to the `update` function as shown in the following image.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important Note
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'Every component inherits a `transform` field (to be specific, a getter) that
    is a reference to the Transform of the GameObject the component is placed, it
    represents the sibling Transform of our component. Through this field, we can
    access the `Translate` function of the Transform, which will receive the offset
    to apply in X, Y, Z local coordinates:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.3 – A simple Move Forward script'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.03_B14199.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.3 – A simple Move Forward script
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Save the file and play the game to see the movement.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.4 – Temporarily disabling the Director and increasing the Player
    Camera priority'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.04_B14199.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.4 – Temporarily disabling the Director and increasing the Player Camera
    priority
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: I recommend you temporarily disable the Playable Director object and increase
    the priority of CM vcam1, which will disable the introduction cutScene and make
    the Character Following Camera activated by default, reducing the time needed
    to test the game. Another option is to create a secondary Scene just to test the
    Player Movement, something that is actually done in real projects, but for now,
    let's keep things simple.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice that the Player is moving too fast and that''s because we are
    using a fixed speed of 1 meter, and because `update` is executing all frames,
    we are moving 1 meter per frame. In a standard 30 FPS game, the Player will move
    30 meters per second, which is too much. We can control the Player speed by adding
    a `speed` field and using the value set in the editor instead of the fixed value
    of 1\. You can see one way to do this in the next screenshot, but remember the
    other options we discussed in the previous chapter (using the Serialize Field
    attribute):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.5 – Creating a speed field and using it as the Z speed of the movement
    script'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.05_B14199.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.5 – Creating a speed field and using it as the Z speed of the movement
    script
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'Now if you save the script to apply the changes and set the `0.1`, but you
    might need another value (more on this later):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.6 – Setting a speed of 0.1 meters per frame'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.06_B14199.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.6 – Setting a speed of 0.1 meters per frame
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that the Player will move automatically. Now let's see how to
    **execute** the movement based on Player Input such as keyboard and mouse input.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Using Input
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike NPCs, we want the Player movement to be driven by the Player''s Input,
    based on which keys they press, the mouse movement, and so on. We can recall the
    original key mapping we designed in [*Chapter 1*](B14199_01_Final_SK_ePub.xhtml#_idTextAnchor015)*,
    Designing a Game from Scratch*, from the next two tables:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 14.1 – Keyboard mapping'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_14.01_B14199.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Table 14.1 – Keyboard mapping
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the mouse mapping in the following table:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 14.2 – Mouse mapping'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_14.02_B14199.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Table 14.2 – Mouse mapping
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: The latest Unity version has a new Input system, but requires some settings
    before using it. For now we will use the default Input system to simplify our
    scripts
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: To know whether a certain key is pressed, such as the Up arrow, we can use the
    `Input.GetKey(KeyCode.W)` line, which will return a Boolean, indicating whether
    the key specified in the `KeyCode` enum is pressed. We can change the key to check
    the changing of the `KeyCode` enum value and combine the `GetKey` function with
    an `If` statement to make the translation execute only when that condition is
    met (the key is currently.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: The latest Unity version has a new Input system, but requires some settings
    before using it. For now we will use the default Input system to simplify our
    scripts.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start implementing the keyboard movement by doing the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Make the forward movement execute only when the *W* key is pressed, as shown
    in the next screenshot:![Figure 14.7 – Conditioning the movement until the W key
    is pressed
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_14.07_B14199.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.7 – Conditioning the movement until the W key is pressed
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: We can add other movement directions with more `If` statements. We can use *S*
    to move backward and *A* and *D* to move left and right, as shown in the following
    screenshot. Notice how we used the minus sign to invert the speed when we needed
    to move in the opposite axis direction:![Figure 14.8 – Checking the W, A, S, and
    D keys' pressure
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_14.08_B14199.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.8 – Checking the W, A, S, and D keys' pressure
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Remember that using `If` without brackets means that only the line inside the
    `if` statement is going to be the one right next to the `if` statement, in this
    case, the `transform.Translate` calls. Anyway, in the final code, I recommend
    keeping the brackets.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果不使用括号的`if`语句，意味着只有`if`语句内部的一行将紧跟在`if`语句后面，也就是说，`transform.Translate`的调用。无论如何，在最终的代码中，我建议保留括号。
- en: If you also want to consider the arrow keys, you can use an OR inside `if`,
    as shown in the following screenshot:![Figure 14.9 – Checking the W, A, S, D,
    and arrow keys' pressure
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还想考虑箭头键，可以在`if`语句中使用OR，如下面的截图所示：![图14.9 - 检查W、A、S、D和箭头键的压力
- en: '](img/Figure_14.09_B14199.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.09_B14199.jpg)'
- en: Figure 14.9 – Checking the W, A, S, D, and arrow keys' pressure
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.9 - 检查W、A、S、D和箭头键的压力
- en: Save the changes and test the movement in Play Mode.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存更改并在播放模式下测试移动。
- en: Something to take into account is that, first, we have another way to map several
    keys to a single action by configuring the Input Manager, a place where action
    mappings can be created, and second, at the time of writing this, Unity released
    an experimental new Input system that will replace this. For now, we will use
    this one because it is simple enough to start a basic game and because experimental
    Unity packages can have bugs or changes in the way they work. In games with complex
    input, controls are recommended to look for more advanced tools.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的一点是，首先，我们可以通过配置输入管理器来将多个键映射到单个操作的另一种方式，输入管理器是可以创建动作映射的地方；其次，在撰写本文时，Unity发布了一个实验性的新输入系统，将取代这个输入管理器。目前，我们将使用这个输入管理器，因为它足够简单，可以启动一个基本的游戏，而且实验性的Unity软件包可能存在错误或工作方式的变化。在复杂输入的游戏中，建议使用更高级的工具来进行控制。
- en: Now, let's implement the mouse controls. In this section, we will only cover
    rotation with mouse movement; we will shoot bullets in the next section. In the
    case of mouse movement, we can get a value by saying how much the mouse has moved
    both horizontally or vertically. This value isn't a Boolean but a number, a type
    of input usually known as Axis, a number that will indicate the intensity of the
    movement with bigger values, and the direction with the sign of the number. For
    example, if Unity's `"Mouse X"` axis says 0.5, it means that the mouse moved to
    the right with a moderate speed, but if it says -1, it moved quickly to the left,
    and if there is no movement, it will say 0\. The same goes for sticks in gamepads;
    the **Horizontal** axis represents the horizontal movement of the left stick in
    common joysticks, so if the Player pulls the stick fully to the left, it will
    say -1.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现鼠标控制。在这一部分，我们只会涵盖鼠标移动的旋转；下一部分我们会讨论射击子弹。在鼠标移动的情况下，我们可以得到一个值，表示鼠标水平或垂直移动的程度。这个值不是布尔值，而是一个数字，通常被称为轴的输入类型，这个数字将表示移动的强度和数字的符号表示方向。例如，如果Unity的`"Mouse
    X"`轴的值为0.5，意味着鼠标以适度的速度向右移动，但如果值为-1，表示鼠标向左快速移动，如果没有移动，值为0。游戏手柄的摇杆也是一样；**Horizontal**轴表示常见游戏手柄左摇杆的水平移动，所以如果玩家将摇杆完全向左拉，值将为-1。
- en: 'We can create our own axes to map other common joysticks'' pressure-based controls,
    but for our game, the default ones are enough. To detect mouse movement, do the
    following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建自己的轴来映射其他常见游戏手柄的压力控制，但对于我们的游戏来说，默认的足够了。要检测鼠标移动，做如下操作：
- en: Use the `Input.GetAxis` function inside `update`, next to the movement `if`
    statements, as shown in the following screenshot, to store the value of this frame's
    mouse movement into a variable:![Figure 14.10 Getting the horizontal movement
    of the mouse
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`update`中使用`Input.GetAxis`函数，紧挨着移动的`if`语句，如下面的截图所示，将这一帧的鼠标移动值存储到一个变量中：![图14.10
    获取鼠标的水平移动
- en: '](img/Figure_14.10_B14199.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.10_B14199.jpg)'
- en: Figure 14.10 Getting the horizontal movement of the mouse
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.10 获取鼠标的水平移动
- en: Use the `transform.Rotate` function to rotate the character. This function receives
    the degrees to rotate in the X-, Y-, Z-axis order. In this case, we need to rotate
    horizontally, so we will use the mouse movement value as the Y-axis rotation,
    as shown in the next screenshot:![Figure 14.11 – Rotating the object horizontally
    based on mouse movement
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`transform.Rotate`函数来旋转角色。这个函数按X、Y、Z轴的顺序接收旋转的度数。在这种情况下，我们需要水平旋转，所以我们将使用鼠标移动值作为Y轴的旋转，如下面的截图所示：![图14.11
    - 根据鼠标移动水平旋转对象
- en: '](img/Figure_14.11_B14199.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.11_B14199.jpg)'
- en: Figure 14.11 – Rotating the object horizontally based on mouse movement
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.11 - 根据鼠标移动水平旋转对象
- en: If you save and test this, you will notice that the Player will rotate but very
    quickly or slowly, depending on your computer. Remember, this kind of value needs
    to be configurable, so let's create a `rotationSpeed` field to configure the speed
    of the Player in the Editor:![Figure 14.12 – Speed and rotation speed fields
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你保存并测试这个，你会注意到玩家会旋转，但速度很快或很慢，这取决于你的电脑。记住，这种值需要可配置，所以让我们在编辑器中创建一个`rotationSpeed`字段来配置玩家的速度：![图14.12
    - 速度和旋转速度字段
- en: '](img/Figure_14.12_B14199.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.12_B14199.jpg)'
- en: Figure 14.12 – Speed and rotation speed fields
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.12 - 速度和旋转速度字段
- en: Now we need to multiply the mouse movement value by the speed, so, depending
    on `rotationSpeed`, we can increase or reduce the rotation amount. As an example,
    if we set a value of 0.5 in the rotation speed, multiplying that value by the
    mouse movement will make the object rotate at half the previous speed, as shown
    in the following screenshot:![Figure 14.13 – Multiplying the mouse movement by
    the rotation speed
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要将鼠标移动值乘以速度，这样，根据`rotationSpeed`，我们可以增加或减少旋转的量。例如，如果我们将旋转速度设置为0.5，将这个值乘以鼠标移动值将使对象以之前速度的一半旋转，如下面的截图所示：![图14.13
    - 将鼠标移动乘以旋转速度
- en: '](img/Figure_14.13_B14199.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.13_B14199.jpg)'
- en: Figure 14.13 – Multiplying the mouse movement by the rotation speed
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.13 - 将鼠标移动乘以旋转速度
- en: Save the code and go back to the Editor to set the rotation speed value. If
    you don't do this, the object won't rotate because the default value of the float
    type fields is 0:![Figure 14.14 – Setting the rotation speed
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存代码，回到编辑器设置旋转速度值。如果不这样做，对象就不会旋转，因为浮点类型字段的默认值是 0：![图14.14 – 设置旋转速度
- en: '](img/Figure_14.14_B14199.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.14_B14199.jpg)'
- en: Figure 14.14 – Setting the rotation speed
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.14 – 设置旋转速度
- en: 'You might also notice that the camera controlled by Cinemachine might have
    a delay to adapt to the new Player position. You can adjust the interpolation
    speed as I did in the next screenshot to have more responsive behavior:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可能还注意到，由 Cinemachine 控制的摄像机可能需要延迟来适应新的玩家位置。您可以像我在下一个截图中所做的那样调整插值速度，以获得更灵敏的行为：
- en: '![Figure 14.15 – Reduced damping of body and aim sections of the character
    virtual camera'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.15 – 减少角色虚拟摄像机身体和瞄准部分的阻尼'
- en: '](img/Figure_14.15_B14199.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.15_B14199.jpg)'
- en: Figure 14.15 – Reduced damping of body and aim sections of the character virtual
    camera
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.15 – 减少角色虚拟摄像机身体和瞄准部分的阻尼
- en: Now that we have completed our movement script, we need to refine it to work
    in every machine by exploring the concept of Delta Time.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了我们的移动脚本，我们需要通过探索 Delta Time 的概念来完善它，使其在每台机器上都能工作。
- en: Understanding Delta Time
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 Delta Time
- en: Unity's update loop executes as fast as the computer can. You can specify in
    Unity the desired frame rate but achieving that depends exclusively on whether
    your computer can reach that, which depends on lots of factors, not only hardware,
    so you cannot expect to always have consistent FPS. You must code your scripts
    to handle every possible scenario. Our current script is moving at a certain speed
    per frame, and the *per frame* part is important here.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 的更新循环以计算机的速度执行。您可以在 Unity 中指定所需的帧率，但实现这一点完全取决于您的计算机是否能达到这一点，这取决于许多因素，不仅仅是硬件，因此您不能期望始终具有一致的
    FPS。您必须编写脚本来处理每种可能的情况。我们当前的脚本是以每帧一定的速度移动的，这里的“每帧”部分很重要。
- en: We have set the movement speed to 0.1, so if my computer runs the game at 120
    FPS, the Player will move 12 meters per second. Now, what happens in a computer
    where the game runs at 60 FPS? As you may guess, it will move only 6 meters per
    second, making our game to have inconsistent behavior across different computers.
    And here is where Delta Time saves the day.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将移动速度设置为0.1，所以如果我的计算机以 120 FPS 运行游戏，玩家将每秒移动 12 米。那么在游戏以 60 FPS 运行的计算机上会发生什么呢？您可能会猜到，它只会每秒移动
    6 米，使我们的游戏在不同的计算机上具有不一致的行为。这就是 Delta Time 拯救了我们的地方。
- en: 'Delta Time is a value that tells us how much time has passed since the previous
    frame. This time depends a lot on our game''s graphics, amount of entities, physics
    bodies, audio, and countless aspects that will dictate how fast your computer
    can process a frame. As an example, if your game runs at 10 FPS, it means that,
    in a second, your computer can process the update loop 10 times, meaning that
    each loop takes approximately 0.1 seconds; in that frame, Delta Time will provide
    that value. In the next diagram, you can see an example of 4 frames taking different
    times to process, which can happen in real-life cases:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Delta Time 是一个告诉我们自上一帧以来经过了多少时间的值。这个时间很大程度上取决于我们游戏的图形、实体数量、物理体、音频和无数方面，这些将决定您的计算机可以处理一帧的速度有多快。例如，如果您的游戏以10
    FPS运行，这意味着在一秒内，您的计算机可以处理更新循环10次，这意味着每个循环大约需要0.1秒；在那一帧中，Delta Time 将提供该值。在下一个图表中，您可以看到
    4 帧需要不同的时间来处理的示例，这在现实情况下可能会发生：
- en: '![Figure 14.16 – Delta Time value varying on different frames of the game'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.16 – 游戏不同帧的 Delta Time 值变化'
- en: '](img/Figure_14.16_B14199.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.16_B14199.jpg)'
- en: Figure 14.16 – Delta Time value varying on different frames of the game
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.16 – 游戏不同帧的 Delta Time 值变化
- en: 'Here, we need to code in such a way to change the *per frame* part of the movement
    to *per second*; we need to have consistent movement per second across different
    computers. A way to do that is to move proportionally to Delta Time: the higher
    the Delta Time value, the longer that frame is, and the greater the movement should
    be to match the real time that has passed since the last update. We can think
    about our speed field''s current value in terms of 0.1 meters per second; our
    Delta Time saying 0.5 means that half a second has passed, so we should move half
    the speed, 0.05\. After two frames, a second has passed, and the sum of the movements
    of the frames (2 x 0.05) matches the target speed, 0.1\. Delta Time can be interpreted
    as the percentage of a second that has passed.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要以一种方式编码，将移动的“每帧”部分改为“每秒”; 我们需要在不同的计算机上每秒有一致的移动。一种方法是与 Delta Time 成比例地移动：Delta
    Time 值越高，那一帧就越长，移动量应该越大，以匹配自上次更新以来经过的真实时间。我们可以根据每秒0.1米的速度字段当前值来思考；我们的 Delta Time
    为0.5，意味着已经过去了半秒，所以我们应该移动一半的速度，0.05。两帧后，一秒已经过去，帧的移动总和（2 x 0.05）与目标速度0.1相匹配。Delta
    Time 可以被解释为已经过去的秒数的百分比。
- en: 'To make Delta Time affect our movement, we should simply multiply our speed
    by Delta Time every frame because Delta Time can be different every frame, so
    let''s do that:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 Delta Time 影响我们的移动，我们应该在每一帧简单地将我们的速度乘以 Delta Time，因为 Delta Time 每一帧都可能不同，所以让我们这样做：
- en: We access Delta Time using `Time.deltaTime`. We can start affecting the movement
    by multiplying Delta Time in every Translate:![Figure 14.17 – Multiplying speed
    by Delta Time
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `Time.deltaTime` 访问 Delta Time。我们可以通过在每个 Translate 中乘以 Delta Time 来开始影响移动：![图14.17
    – 通过 Delta Time 乘以速度
- en: '](img/Figure_14.17_B14199.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.17_B14199.jpg)'
- en: Figure 14.17 – Multiplying speed by Delta Time
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.17 – 通过 Delta Time 乘以速度
- en: We can do the same with the rotation speed, chaining the mouse and speed multiplications:![Figure
    14.18 – Applying Delta Time to rotation code
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以对旋转速度做同样的操作，将鼠标和速度相乘：![图14.18 – 将 Delta Time 应用于旋转代码
- en: '](img/Figure_14.18_B14199.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.18_B14199.jpg)'
- en: Figure 14.18 – Applying Delta Time to rotation code
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.18 – 将 Delta Time 应用于旋转代码
- en: If you save and play the game, you will notice that the movement will be slower
    than before and that's because now 0.1 is the movement per second, meaning 10
    centimeters per second, which is pretty slow; try raising those values. In my
    case, 10 for speed and 180 for rotation speed was enough, but the rotation speed
    depends on the Player's preferred sensitivity, which can be configurable, but
    let's keep that for another time.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你保存并播放游戏，你会注意到移动速度比以前慢了，这是因为现在每秒移动0.1，意味着每秒10厘米，这相当慢；尝试提高这些值。在我的情况下，速度为10，旋转速度为180就足够了，但旋转速度取决于玩家的首选灵敏度，这是可以配置的，但让我们留到另一个时间。
- en: We just learned how to mix the Input system of Unity, which tells us about the
    state of the keyboard, mouse, and other input devices, with the basic Transform
    movement functions. This way, we can start making our game feel more dynamic.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚学会了如何将Unity的输入系统（告诉我们键盘、鼠标和其他输入设备的状态）与基本的变换移动函数相结合。这样，我们可以开始让我们的游戏感觉更加动态。
- en: Now that we have finished the Player's movement, let's discuss how to make the
    Player shoot bullets using Instantiate functions.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了玩家的移动，让我们讨论如何使用Instantiate函数让玩家发射子弹。
- en: Implementing spawning
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现生成
- en: We have created lots of objects in the Editor that define our level, but once
    the game begins, and according to the Player actions, new objects must be created
    to better fit the scenarios generated by Player interaction. Enemies might need
    to appear after a while, or bullets must be created according to the Player input;
    even when enemies die there's a chance of spawning some power-up. This means that
    we cannot create all the necessary objects beforehand but should create them dynamically,
    and that's done through scripting.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在编辑器中创建了许多定义我们级别的对象，但一旦游戏开始，并根据玩家的操作，必须创建新的对象以更好地适应玩家交互生成的场景。敌人可能需要在一段时间后出现，或者根据玩家的输入创建子弹；即使敌人死亡，也有可能生成一些增益道具。这意味着我们不能预先创建所有必要的对象，而应该动态创建它们，这是通过脚本完成的。
- en: 'In this section, we will examine the following spawning concepts:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究以下生成概念：
- en: Spawning objects
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成对象
- en: Timing actions
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计时动作
- en: Destroying objects
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁对象
- en: We will start seeing the Unity `Instantiate` function, which allows us to create
    instances of Prefabs on runtime, such as when pressing a key, or in a time-based
    fashion, such as making our enemy spawn bullets every certain amount of time.
    Also, we will learn how to destroy these objects to prevent our Scene from starting
    to perform badly due to too many objects being processed.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始看到Unity的`Instantiate`函数，它允许我们在运行时创建预制体的实例，例如按下键时，或者按时间安排，例如使我们的敌人每隔一段时间生成子弹。此外，我们将学习如何销毁这些对象，以防止场景由于处理太多对象而开始表现不佳。
- en: Let's start with how to shoot bullets according to the Player's Input.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从如何根据玩家的输入射击子弹开始。
- en: Spawning objects
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成对象
- en: To spawn an Object in runtime or Play Mode, we need a description of the Object,
    which components it has, and its settings and possible sub-objects. You might
    be thinking about Prefabs here, and you are right, we will use an instruction
    that will tell Unity to create an instance of a Prefab via scripting. Remember
    that an instance of a Prefab is an Object created based on the Prefab, basically
    a clone of the original one.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要在运行时或播放模式下生成一个对象，我们需要一个对象的描述，它有哪些组件，它的设置以及可能的子对象。你可能会在这里考虑到预制体，你是对的，我们将使用一条指令告诉Unity通过脚本创建一个预制体的实例。记住，预制体的实例是基于预制体创建的对象，基本上是原始对象的克隆。
- en: 'We will start shooting the Player''s bullets, so first let''s create the bullet
    Prefab by doing the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始射击玩家的子弹，所以首先让我们通过以下步骤创建子弹预制：
- en: Create a sphere in **GameObject** | **3D Object** | **Sphere**. You can replace
    the sphere mesh with another bullet model if you want, but we will keep the sphere
    in this example for now.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**GameObject** | **3D Object** | **Sphere**中创建一个球体。如果你愿意，你可以用另一个子弹模型替换球体网格，但在这个例子中我们暂时保留球体。
- en: Rename the sphere `Bullet`.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将球体重命名为`Bullet`。
- en: Create a material by clicking on the `Bullet`. Remember to place it inside the
    `Materials` folder.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击`Bullet`来创建一个材质。记得将它放在`Materials`文件夹中。
- en: Check the **Emission** checkbox in the material and set the **emission Map**
    and **Base Map** colors to red. Remember, the Emission color will make the bullet
    shine, especially with the bloom effect in our post-processing volume:![Figure
    14.19 – Creating a red bullet material with emission color
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在材质中勾选**Emission**复选框，并将**emission Map**和**Base Map**颜色设置为红色。记住，发射颜色会使子弹发光，特别是在我们的后期处理体积中的泛光效果下：![图14.19
    – 创建一个带发光颜色的红色子弹材质
- en: '](img/Figure_14.19_B14199.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.19_B14199.jpg)'
- en: Figure 14.19 – Creating a red bullet material with emission color
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.19 – 创建一个带发光颜色的红色子弹材质
- en: Apply the Material to the Sphere by dragging the material to it.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将材质拖放到球体上，将材质应用到球体上。
- en: Set the Scale to a smaller value—(0.3, 0.3, 0.3) worked in my case:![Figure
    14.20 – Small red-colored bullet
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将比例设置为较小的值—（0.3, 0.3, 0.3）在我的情况下有效：![图14.20 – 小红色子弹
- en: '](img/Figure_14.20_B14199.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.20_B14199.jpg)'
- en: Figure 14.20 – Small red-colored bullet
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.20 – 小红色子弹
- en: Create a script called `ForwardMovement` to make the bullet constantly move
    forward at a fixed speed.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ForwardMovement`的脚本，以使子弹以固定速度不断向前移动。
- en: I suggest you try to solve this by yourself first and look at the screenshot
    in the next step with the solution later as a little challenge to recap the movement
    concepts we saw previously. If you don't recall how to create a script, please
    read [*Chapter 13*](B14199_13_Final_SK_ePub.xhtml#_idTextAnchor172)*, Introduction
    to Unity Scripting with C#*, and check the previous section to see how to move
    objects.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你先自己尝试解决这个问题，然后在下一步中查看屏幕截图以获取解决方案，这是一个小挑战，可以回顾我们之前看到的运动概念。如果你不记得如何创建脚本，请阅读[*第13章*](B14199_13_Final_SK_ePub.xhtml#_idTextAnchor172)*，使用C#介绍Unity脚本编写*，并检查前一节以了解如何移动对象。
- en: The next screenshot shows you what the script should look like:![Figure 14.21
    – A simple Move Forward script
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_14.21_B14199.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.21 – A simple Move Forward script
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Add the script (if not already there) to the bullet, and set the speed to a
    value you see fit. Usually, bullets are faster than the Player, but that depends
    on the Player experience you want to get (remember the questions in [*Chapter
    1*](B14199_01_Final_SK_ePub.xhtml#_idTextAnchor015)*, Designing a Game from Scratch*).
    In my case, 20 worked fine. Test it by placing the bullet near the Player and
    playing the game:![Figure 14.22 – Forward Movement script in the bullet
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_14.22_B14199.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.22 – Forward Movement script in the bullet
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Drag the bullet `GameObject` instance to the `Prefabs` folder to create a **Bullet**
    Prefab. Remember that the Prefab is an asset that has a description of the created
    bullet, like a blueprint of how to create a bullet:![Figure 14.23 – Creating a
    Prefab
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_14.23_B14199.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.23 – Creating a Prefab
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Remove the original bullet from the Scene; we will use the Prefab to create
    bullets when the Player presses a key (if ever).
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have our bullet Prefab, it is time to instantiate it (clone it)
    when the Player presses a key. To do that, do the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Create and add a script to the Player's `GameObject` (the Robot) called `PlayerShooting`
    and open it.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need a way for the script to have access to the Prefab to know which Prefab
    to use from the probably dozens that we will have in our project. All of the data
    our script needs that depends on the desired game experience is in the form of
    a field, such as the speed field used so far, so in this case, we need a field
    of the `GameObject` type, a field that can reference or point to a specific Prefab,
    which can be set using the Editor.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Adding the field code would look like this:![Figure 14.24 – The Prefab reference
    field
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_14.24_B14199.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.24 – The Prefab reference field
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: As you might guess, we can use the `GameObject` type to not only reference Prefabs
    but also other objects. Imagine an Enemy AI needing a reference to the Player
    object to get its position, using a GameObject to link the two objects. The trick
    here is considering that Prefabs are just regular Gameobjects that live outside
    the Scene; you cannot see them but they are in memory, ready to be copied or instantiated.
    You will only see them through copies or instances that are placed in the Scene
    with scripting or via the Editor as we have done so far.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Editor, click on the circle to the right of the property and select
    the `Bullet` Prefab. Another option is to just drag the `Bullet` Prefab to the
    property:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.25 – Setting the Prefab reference to point the bullet'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.25_B14199.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.25 – Setting the Prefab reference to point the bullet
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: This way, we tell our script that the bullet to shoot will be that one. Remember
    to drag the Prefab and not the bullet in the Scene (that should be deleted by
    now).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'We will shoot the bullet when the Player presses the left mouse button as specified
    in the design document, so let''s place the proper `if` statement to handle that
    in the `update` event function, like the one shown in the next screenshot:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.26 – Detecting the pressure of the left mouse button'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.26_B14199.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.26 – Detecting the pressure of the left mouse button
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that this time, we used `GetKeyDown` instead of `GetKey`, the
    former being a way to detect the exact frame the pressing of the key started;
    this `if` statement will execute its code only in that frame, and until the key
    is released and re-pressed, it won't enter again. This is one way to prevent bullets
    from spawning in every frame, but just for fun, you can try using `GetKey` instead
    to see how it would behave. Also, zero is the mouse button number that belongs
    to left-click, one being right-click and two middle-click.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这次我们使用了`GetKeyDown`而不是`GetKey`，前者是一种检测按键开始的确切帧的方法；这个`if`语句只会在那一帧执行它的代码，并且直到按键释放并重新按下，它才会再次进入。这是防止子弹在每一帧生成的一种方法，但只是为了好玩，你可以尝试使用`GetKey`来看看它会如何表现。另外，零是属于左键点击的鼠标按钮编号，一是右键点击，二是中键点击。
- en: 'We can use the `Instantiate` function to clone the Prefab, passing the reference
    to it as the first parameter. This will create a clone of the mentioned Prefab
    that will be placed in the Scene:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Instantiate`函数来克隆预制品，将其引用作为第一个参数传递。这将在场景中创建一个所述预制品的克隆：
- en: '![Figure 14.27 – Instantiating the Prefab'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.27 – 实例化预制品
- en: '](img/Figure_14.27_B14199.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.27_B14199.jpg)'
- en: Figure 14.27 – Instantiating the Prefab
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.27 – 实例化预制品
- en: If you save the script and play the game, you will notice that when you press
    the mouse, a bullet spawn, but probably not in the place you are expecting, and
    if you don't see it, try to check the Hierarchy for new objects; it will be there.
    The problem here is that we didn't specify the desired spawn position, and we
    have two ways of settings that, which we will see in the next steps.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你保存脚本并播放游戏，你会注意到当你按鼠标时，子弹会生成，但可能不是在你期望的位置，如果你没有看到它，尝试在层次结构中查找新对象；它会在那里。问题在于我们没有指定期望的生成位置，我们有两种设置的方法，我们将在接下来的步骤中看到。
- en: 'The first way is to use the `transform.position` and `transform.rotation` inherited
    fields from MonoBehaviour, which will tell us our current position and rotation.
    We can pass them as the second and third parameters of the `Instantiate` function,
    which will understand that this is the place we want our bullet to appear. Remember
    that it is important to set the rotation to make the bullet face the same direction
    as the Player, so it will move that way:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是使用从MonoBehaviour继承的`transform.position`和`transform.rotation`字段，它们会告诉我们当前的位置和旋转。我们可以将它们作为`Instantiate`函数的第二个和第三个参数传递，函数会理解这是我们希望子弹出现的地方。记住，设置旋转是很重要的，让子弹面向与玩家相同的方向，这样它就会朝着那个方向移动：
- en: '![Figure 14.28 – Instantiating the Prefab in our position and rotation'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.28 – 在我们的位置和旋转实例化预制品
- en: '](img/Figure_14.28_B14199.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.28_B14199.jpg)'
- en: Figure 14.28 – Instantiating the Prefab in our position and rotation
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.28 – 在我们的位置和旋转实例化预制品
- en: 'The second way, which will be longer but will give us more flexibility to change
    other aspects of the object, is by using the previous version of Instantiate,
    but saving the reference returned by the function, which will be pointing to the
    clone of the Prefab. Having a reference to the instantiated bullet allows us to
    change whatever we want from it, not only position but also rotation, but for
    now, let''s limit ourselves to position and rotation. In this case, we will need
    the following three lines; the first will instantiate and capture the clone reference,
    the second will set the position of the clone, and the third will set the rotation.
    You will notice we will also use the `transform.position` field of the clone,
    but this time to change its value by using the `=` (assignment) operator:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方式会更长，但会让我们有更多的灵活性来改变对象的其他方面，就是使用之前版本的Instantiate，但保存函数返回的引用，这个引用将指向预制品的克隆。拥有实例化子弹的引用允许我们改变任何我们想要的东西，不仅仅是位置，还有旋转，但现在，让我们限制在位置和旋转上。在这种情况下，我们将需要以下三行；第一行将实例化并捕获克隆引用，第二行将设置克隆的位置，第三行将设置旋转。你会注意到我们还将使用克隆的`transform.position`字段，但这次是通过使用`=`（赋值）运算符来改变它的值：
- en: '![Figure 14.29 – The longer version of instantiating a Prefab in a specific
    position'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.29 – 在特定位置实例化预制品的较长版本
- en: '](img/Figure_14.29_B14199.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.29_B14199.jpg)'
- en: Figure 14.29 – The longer version of instantiating a Prefab in a specific position
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.29 – 在特定位置实例化预制品的较长版本
- en: Use the version you like the most—both do the same. Remember that you can check
    the project repository to see the full script finished. Now you can save the file
    with one of the versions and try to shoot.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你喜欢的版本——两者都是一样的。记住，你可以检查项目存储库以查看完整的脚本。现在你可以用其中一个版本保存文件并尝试射击。
- en: 'If you try the script so far, you should see the bullet spawn in the Player''s
    position, but in our case, it will probably be the floor. The problem here is
    that the robot pivot is there, and usually, every humanoid character has the pivot
    there. We have several ways to fix that, the most flexible one being to create
    a shoot point, an empty Player''s child Object placed in the position we want
    the bullet to spawn. We can use the position of that Object instead of the Player''s
    position by doing the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试到目前为止的脚本，你应该会看到子弹在玩家的位置生成，但在我们的情况下，它可能是在地板上。问题在于机器人的枢轴在那里，通常每个人形角色的枢轴都在那里。我们有几种方法来解决这个问题，最灵活的方法是创建一个射击点，一个空的玩家子对象，放在我们希望子弹生成的位置。我们可以使用该对象的位置而不是玩家的位置，方法如下：
- en: Create an empty `GameObject` in `ShootPoint`.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ShootPoint`中创建一个空的`GameObject`。
- en: Make it a child of the Player's Robot Character Object, and place it where you
    want the bullet to appear, probably a little higher and further forward than the
    original spawn position:![Figure 14.30 – An empty ShootPoint object placed inside
    the character
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其作为玩家机器人角色对象的子对象，并将其放在你希望子弹出现的位置，可能比原始生成位置稍高和稍向前：![图14.30 – 放置在角色内部的空ShootPoint对象
- en: '](img/Figure_14.30_B14199.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.30_B14199.jpg)'
- en: Figure 14.30 – An empty ShootPoint object placed inside the character
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.30 – 放置在角色内部的空ShootPoint对象
- en: As usual, to access the data of another Object, we need a reference to it, such
    as the Prefab reference, but this time that one needs to point to our `ShootPoint`.
    We can create another `GameObject` type field, but this time drag `ShootPoint`
    instead of the Prefab. The script and the Object set would look as shown in the
    following screenshot:![Figure 14.31 – The Prefab and Shoot Point fields and how
    they are set in the Editor
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_14.31_B14199.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.31 – The Prefab and Shoot Point fields and how they are set in the
    Editor
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'We can access the position of `shootPoint` by using the `transform.position`
    field of it again, as shown in the following screenshot:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.32 – The Prefab and ShootPoint fields and how they are set in the
    Editor'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.32_B14199.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.32 – The Prefab and ShootPoint fields and how they are set in the
    Editor
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice that now shooting and rotating with the mouse has a problem;
    when moving the mouse to rotate, the pointer will fall outside the Game View,
    and when clicking, you will accidentally click the Editor, losing the focus on
    the Game View, so you will need to click the Game View again to regain focus and
    use Input again. A way to prevent this is to disable the cursor while playing.
    To do this, follow these steps:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Add a `Start` event function to our Player Movement Script.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the two lines you can see in the following screenshot to your script. The
    first one will make the cursor visible, and the second one will lock it in the
    middle of the screen, so it will never abandon the Game View. Consider that latter;
    you will need to reenable the cursor when you switch back to the main menu or
    the pause menu, to allow the mouse to click the UI buttons:![Figure 14.33 – Disabling
    the mouse cursor
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_14.33_B14199.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.33 – Disabling the mouse cursor
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Save and test this. If you want to stop the game, you could either press *Ctrl*
    + *Shift* + *P* (*command* + *Shift* + *P* on Mac) or press the *Esc* key to reenable
    the mouse. Both only work in the Editor; in the real game, you will need to reenable
    manually.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we've covered the basics of object spawning, let's see an advanced
    example by combining it with timers.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Timing actions
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not entirely related to spawning, but usually used together, timing actions
    is a common task in videogames. The idea is to schedule something to happen later;
    maybe we want the bullet to be destroyed after a while to prevent memory overflow,
    or we want to control the spawn rate of enemies or when they should spawn, and
    that's exactly what we are going to do in this section, starting with the second,
    the Enemy waves.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: The idea is that we want to spawn enemies at a certain rate at different moments
    of the game; maybe we want to spawn enemies from seconds 1 to 5 at a rate of 2
    per second, getting 10 enemies, before giving the Player up to 20 seconds to finish
    them and programming another wave to start at second 25\. Of course, this depends
    a lot on the exact game you want, and you can start with an idea like this one
    and modify it after some testing to find the exact way you want the wave system
    to work. In our case, we will exemplify timing with the previously mentioned logic.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need an Enemy, and for now, we will simply use the same robot
    character as the Player, but adding a Forward Movement script to simply make it
    move forward; later in this book, we will add AI behavior to our enemies. I suggest
    you try to create this Prefab by yourself and look at the next steps once you
    have tried, to see the correct answer:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Drag the Robot FBX model to the Scene to create another Robot character, but
    rename it `Enemy` this time.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `ForwardMovement` script created for the bullets but this time to `Enemy`
    and set it at a speed of 10 for now.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `Enemy` GameObject to the Project to create a Prefab based on that
    one; we will need to spawn it later. Remember to choose Prefab Variant, which
    will keep the Prefab linked with the original model to make the changes applied
    to the model automatically apply to the Prefab. Remember also to destroy the original
    Enemy from the Scene.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, to schedule actions, we will use the `Invoke` functions suite, a set of
    functions to create timers that are basic but enough for our requirements. Let''s
    use it by doing the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Create an Empty GameObject at one end of the Base and call it `Wave1a`.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create and add a script called `WaveSpawner` to it.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our spawner will need four fields: the Enemy Prefab to spawn, the game time
    to start the wave, the `endTime` to end the wave spawning, and the spawn rate
    of the enemies—basically, how much time there should be between each spawn during
    the given spawning period. The script and the settings will look like the following
    screenshot:![Figure 14.34 – The fields of the wave spawner script'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_14.34_B14199.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.34 – The fields of the wave spawner script
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the `InvokeRepeating` function to schedule a custom function to
    repeat periodically. You will need to schedule the repetition just once; Unity
    will remember that, so don''t do it every frame. This is a good case to use the
    `Start` event function instead. The first argument of the function is a string
    (text between quotation marks) with the name of the other function to execute
    periodically, and unlike Start or update, you can name the function whatever you
    want. The second argument is the time to start repeating, our `startTime` field,
    in this case. Finally, the third argument is the repetition rate of the function,
    how much time needs to happen between each repetition, this being the `spawnRate`
    field. You can find how to call that function in the next screenshot, along with
    the custom `Spawn` function:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.35 – Scheduling a Spawn function to repeat'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.35_B14199.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.35 – Scheduling a Spawn function to repeat
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `Spawn` function, we can put the spawning code as we know, using
    the `Instantiate` function. The idea is to call this function at a certain rate
    to spawn one Enemy per call. This time, the spawn position will be in the same
    position as the spawner, so place it carefully:![Figure 14.36 – Instantiating
    in the Spawn function
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_14.36_B14199.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.36 – Instantiating in the Spawn function
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'If you test this script setting the Prefab `startTime` and `spawnRate` fields
    to some test values, you will notice that the enemies will start spawning but
    never stop, and you can see that we haven''t used the `endTime` field so far.
    The idea is to call the `CancelInvoke` function, one function that will cancel
    all `InvokeRepeating` calls we made, but after a while to then use the `Invoke`
    function, which works similarly to `InvokeRepeating`, but this one executes just
    once. In the next screenshot, you can see how we added an `Invoke` call to the
    `CancelInvoke` function in `Start`, using the `endTime` field as the time to execute
    `CancelInvoke`. This will execute `CancelInvoke` after a while, canceling the
    first `InvokeRepeating` call that spawns the prefab:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.37 – Scheduling a Spawn repetition but canceling after a while
    with CancelInvoke'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.37_B14199.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.37 – Scheduling a Spawn repetition but canceling after a while with
    CancelInvoke
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: This time, we used `CancelInvoke`. We didn't use a custom function because `CancelInvoke`
    doesn't receive arguments. If you need to schedule a function with arguments,
    you will need to create a parameterless wrapper function that calls the one desired
    and schedule that one, as we did with `Spawn`, where the only intention is to
    call Instantiate with specific arguments.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can save and set some real values to our spawner. In my case, I used
    the ones shown in the following screenshot:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.38 – Spawning enemies from seconds 1 to 5 of gameplay every 0.5
    seconds, 2 per second'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.38_B14199.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.38 – Spawning enemies from seconds 1 to 5 of gameplay every 0.5 seconds,
    2 per second
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see the enemies being spawned one next to the other, and because
    they move forward, they will form a row of enemies. This behavior will change
    later with AI:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.39 – Spawning enemies'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.39_B14199.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.39 – Spawning enemies
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: If you want, you can create several Wave Spawner objects, scheduling waves for
    the later stages of the game. Remember the difficulty balance we discussed in
    [*Chapter 1*](B14199_01_Final_SK_ePub.xhtml#_idTextAnchor015)*, Designing a Game
    from Scratch*; you will need to try this with the final AI for the enemies, but
    the number of waves, times, and spawn rates will determine the difficulty of the
    game, and that's why it is important to set those values properly. Also, there
    are plenty of methods to create waves of enemies; this is just the simplest one
    I could find. You may need to change it according to your game.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have discussed timing and spawning, let's discuss timing and destroying
    objects to prevent our bullets from living forever in memory.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Destroying objects
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is going to be super short but is a widely used function, so it deserves
    its own section. We can use the `Destroy` function to destroy Object instances.
    The idea is to make the bullets have a script that schedules their own auto-destruction
    after a while to prevent them from living forever. We will create the script by
    doing the following:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Select the Prefab of `Bullet` and add a script called `Autodestroy` to it as
    you did with other objects using the **Add Component** | **New Script** option.
    This time, the script will be added to the Prefab, and each instance of the Prefab
    you spawn will have it.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can use the `Destroy` function as shown in the next screenshot to destroy
    the Object just once in `Start`.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `Destroy` function expects the object to destroy as the first argument,
    and here, we are using the `gameObject` reference, a way to point to our GameObject
    to destroy it. If you use the `this` pointer instead, we will be destroying only
    the `Autodestroy` component; remember that in Unity, you never create Gameobjects
    but components to add to them:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.40 – Destroying an Object when it starts'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.40_B14199.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.40 – Destroying an Object when it starts
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we don't want the bullet to be destroyed as soon as it is spawned,
    so we need to delay the destruction. You may be thinking about using `Invoke`,
    but unlike most functions in Unity, `Destroy` can receive a second argument, which
    is the time to wait until destruction.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Create a `delay` field to use as the second argument of `Destroy`, as shown
    in the next screenshot:![Figure 14.41 – Using a field to configure the delay to
    destroy the Object
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_14.41_B14199.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.41 – Using a field to configure the delay to destroy the Object
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Set the `delay` field to a proper value; in my case, 5 was enough. Now check
    how the bullets despawn after a while by looking at them being removed from the
    Hierarchy.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we can create and destroy objects at will, which is something very common
    in Unity scripting.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Look into the concept of object pooling; you will learn that sometimes creating
    and destroying objects is not that performant.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have created our first real scripts, which provide useful behavior. We discussed
    how to instantiate Prefabs via scripting, to create objects at will according
    to the game situation. Also, we saw how to schedule actions, in this case, spawning,
    but this can be used to schedule anything. Finally, we saw how to destroy created
    objects, to prevent increasing the number of objects to an unmanageable level.
    We will be using these actions to create other kinds of objects, such as sounds
    and effects, later in this book.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Now you are able to create any type of movement or spawning logic your objects
    will need and make sure those objects are destroyed when needed. You might think
    that all games move and create shooting systems the same way, and while they are
    similar, being able to create your own movement and shooting scripts allows you
    to customize those aspects of the game to behave as intended and create the exact
    experience you are looking for.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be discussing how to detect collisions to prevent
    the Player and bullets from passing through walls and much more.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
