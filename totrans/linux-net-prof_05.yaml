- en: '*Chapter 3*: Using Linux and Linux Tools for Network Diagnostics'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll cover some "how it works" networking basics, as well
    as how to use our Linux workstation in network troubleshooting. When you're done
    with this chapter, you should have tools to troubleshoot local and remote network
    services, as well as to "inventory" your network and its services.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Networking basics – the OSI model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layer 2 – relating IP and MAC addresses using ARP, with some more detail on
    MAC addresses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layer 4 – how TCP and UDP ports work, including the TCP "three-way handshake"
    and how this appears in Linux commands.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local TCP and UDP port enumeration, and how these relate to running services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remote port enumeration using both native tools.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remote port enumeration using installed scanners (netcat and nmap in particular).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we'll cover some of the basics of wireless operations and troubleshooting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the examples in this section, we'll use our existing Ubuntu host or
    **Virtual Machine** (**VM**). We'll be touching on some wireless topics in this
    chapter, so if you don't have a wireless card in your host or VM, you'll want
    a Wi-Fi adapter to work through those examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we work through the various troubleshooting methods, we''ll use a variety
    of tools, starting with some native Linux commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16336_Table_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ll also use some installed applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16336_Table_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For the packages that aren't included in Ubuntu, be sure that you have a working
    internet connection so you can use the `apt` commands for installation.
  prefs: []
  type: TYPE_NORMAL
- en: Network basics – the OSI model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s convenient to discuss network and application concepts in terms of layers,
    with each layer being roughly responsible for higher and more abstract functions
    at upper levels, and more *nuts and bolts* primitives as you travel *down the
    stack*. The following diagram describes the OSI model in broad terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – The OSI model for network communication, with some descriptions
    and examples'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_03_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – The OSI model for network communication, with some descriptions
    and examples
  prefs: []
  type: TYPE_NORMAL
- en: In regular usage, the layers are often referenced by number, counting from the
    bottom. So, a Layer 2 problem will usually involve MAC addresses and switches,
    and will be confined to the VLAN that the station is in (which usually means the
    local subnet). Layer 3 issues will involve IP addressing, routing, or packets
    (and so will involve routers and adjacent subnets of more distant networks).
  prefs: []
  type: TYPE_NORMAL
- en: As with any model, there's always room for confusion. For instance, there's
    some longstanding *fuzziness* between Layers 6 and 7\. Between layers 5 and 6,
    while IPSEC is definitely encryption and so belongs in layer 6, it can also be
    considered a tunneling protocol (depending on your point of view and implementation).
    Even at layer 4, TCP has the concept of a session, so would seem to perhaps have
    one foot in the layer 5 side – though the concept of *ports* keeps it firmly in
    layer 4.
  prefs: []
  type: TYPE_NORMAL
- en: And of course, there's always room for humor – the common wisdom/joke is that
    *people* form Layer 8 in this model. So, a Layer 8 problem might involve a helpdesk
    call, budget discussions, or a meeting with your organization's management to
    resolve it!
  prefs: []
  type: TYPE_NORMAL
- en: What we see in this next diagram illustrates the most important concept to keep
    in mind with this model. As data is received, it travels up the stack, from the
    most primitive constructs it encapsulates to more and more abstract/high-level
    constructs (from bits to frames to packets to APIs to applications, for instance).
    Sending data moves it from the application layer toward the binary representation
    on the wire (from the upper layers to the lower ones).
  prefs: []
  type: TYPE_NORMAL
- en: 'Layers 1-3 are often referred to as the **media** or **network** layers, whereas
    layers 4-7 are generally called the **host or application** layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Traveling up and down the OSI stack, encapsulating and decapsulating
    as we go'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_03_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – Traveling up and down the OSI stack, encapsulating and decapsulating
    as we go
  prefs: []
  type: TYPE_NORMAL
- en: This concept is what makes it possible for a vendor to manufacture a switch
    that will interact with a network card from another vendor for instance, or for
    switches to work with routers. This is also what powers our application ecosystem
    – for the most part application developers do not have to worry about IP addresses,
    routing, or the differences between wireless and wired networks, all that is just
    taken care of – the network can be treated as a black box, where you send data
    in one end, and you can be certain that it will come out at the other end in the
    right place and format.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have established the basics of the OSI model, let's learn in detail
    about the data link layer by exploring the `arp` command and the local ARP table.
  prefs: []
  type: TYPE_NORMAL
- en: Layer 2 – relating IP and MAC addresses using ARP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the OSI model firmly in place, we can see that our discussion so far around
    IP addresses has been clustered around Layer 3\. This is where regular people,
    and even many IT and networking people, tend to consider the network path to *stop*
    in their understanding – they can follow the path down that far and consider the
    rest to be a black box. But as a networking professional, Layers 1 and 2 are extremely
    important – let's start with Layer 2.
  prefs: []
  type: TYPE_NORMAL
- en: Theoretically, MAC addresses are the addresses that are *burned into* each network
    interface. While this is normally true, it's also an easy thing to change. What
    is the MAC address though? It's a 12-digit (6-byte/48-bit) address, normally shown
    in hexadecimal. When displayed, each byte or double-byte is usually separated
    by `.` or `-`. So typical MAC addresses might be `00-0c-29-3b-73-cb` or `9a93.5d84.5a69`
    (showing both common representations).
  prefs: []
  type: TYPE_NORMAL
- en: In practice, these addresses are used to communicate between hosts in the same
    VLAN or subnet. If you look at a packet capture (we'll get on to this later in
    the book, in [*Chapter 11*](B16336_11_Final_NM_ePub.xhtml#_idTextAnchor192), *Packet
    Capture and Analysis in Linux*), at the start of a TCP conversation you'll see
    the sending station send a broadcast (a request sent to all stations in the subnet)
    `who has IP address x.x.x.x`. The `That's me, and my MAC address is aaaa.bbbb.cccc`.
    If the target IP address is on a different subnet, the sender will "ARP for" the
    gateway for that subnet (which will usually be the default gateway, unless there
    are local routes defined).
  prefs: []
  type: TYPE_NORMAL
- en: Going forward, the sender and receiver then communicate using MAC addresses.
    The switch infrastructure that the two hosts are connected to uses MAC addresses
    only within each VLAN, which is one reason why switches are so much faster than
    routers. When we look at the actual packets (in the chapter on *Packet Capture*),
    you'll see both the sending and receiving MAC address as well as the IP addresses
    in each packet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ARP request is cached on each host in an `arp` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see this is pretty simple. It just relates the Layer 3 IP address to
    the Layer 2 MAC address to the Layer 1 `/proc` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that there is both a default value (in seconds), and a value for each network
    adapter (these usually match). This may seem short to you – the matching MAC address
    table on switches (commonly called the CAM table) is normally at 5 minutes, and
    the ARP table on routers is normally 14,400 seconds (4 hours). These values are
    all about resources. In aggregate, workstations have the resources to frequently
    send ARP packets. The switches *learn* MAC addresses from traffic (including ARP
    requests and replies), so having that timer be slightly longer than the workstation
    timer makes sense. Similarly, having a lengthy ARP cache timer on routers conserves
    its CPU and NIC resources. That timer is so long on routers because in years past,
    routers were constrained by bandwidth and CPU, compared to just about everything
    else on the network. While that has changed in modern times, the lengthy default
    value for ARP cache timeout on routers remains. This is an easy thing to forget
    during router or firewall migrations – I've been involved in many maintenance
    windows of that type where a `clear arp` command on the right router magically
    "fixed everything" after the migration.
  prefs: []
  type: TYPE_NORMAL
- en: 'We haven''t talked about the `/proc` directory in Linux yet – this is a "virtual"
    directory of files that contain the current settings and statuses of various things
    on your Linux host. These are not "real" files, but they are represented as files
    so we can use the same commands that we use for files: `cat`, `grep`, `cut`, `sort`,
    `awk`, and so on. You can look at network interface errors and values, such as
    in /`proc/net/dev`, for instance (note how things don''t quite line up correctly
    in this listing):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even look in the memory stats (note that `meminfo` contains **lots**
    more info):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Back to ARP and MAC addresses. You can add a static MAC address – one that won't
    expire and might be different from the real MAC of the host you want to connect
    to. This is often done for troubleshooting purposes. Or you can clear an ARP entry,
    which you might often want to do if a router has been swapped out (for instance
    if your default gateway router has the same IP but now has a different MAC). Note
    that you don't need special rights to view the ARP table, but you sure do to modify
    it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a static entry, do the following (note the `PERM` status when we display
    it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To delete an ARP entry, do the following (note that the `-i interfacename`
    parameter is routinely skipped for this command):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To masquerade as a given IP address – for instance, to answer ARP requests
    for IP `10.0.0.1` – do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Finally, you can also easily change an interface's MAC address. You might think
    that this would be done to deal with duplicated addresses, but that situation
    is exceedingly rare.
  prefs: []
  type: TYPE_NORMAL
- en: 'Legitimate reasons to change a MAC address might include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You have migrated a firewall and the ISP has your MAC hardcoded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have migrated a host or host NIC, and the upstream router isn't accessible
    to you, but you can't wait 4 hours for the ARP cache to expire on that router.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have migrated a host, and there is a DHCP reservation for the old MAC address
    that you need to use, but you don't have access to "fix" that DHCP entry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apple devices will change their wireless MAC addresses for privacy reasons.
    Given how many other (and easier) methods there are to track a person's identity,
    this protection isn't usually that effective.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Malicious reasons to change a MAC address include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You are attacking a wireless network, and have figured out that once authenticated,
    the only checks that the access point does are against the client MAC addresses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same as the previous point, but against an Ethernet network that's secured
    with `802.1x` authentication, but with an insecure or incomplete configuration
    (we'll get into this in more detail in a later chapter).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You are attacking a wireless network that has MAC address permissions on it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hopefully this illustrates that using MAC addresses for security purposes isn't
    usually a wise decision.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find your MAC addresses, we have four different methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To change a Linux host''s MAC address, we have several options:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Linux GUI, you could start by clicking the network icon on the top panel,
    then select **Settings** for your interface. For instance, for a host with one
    Ethernet card, choose "**Wired Connection**", then **Wired Settings**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Changing the MAC address from the GUI, step 1'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_03_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – Changing the MAC address from the GUI, step 1
  prefs: []
  type: TYPE_NORMAL
- en: 'From the interface that pops up, open the **New Profile** dialog box by clicking
    the **+** icon, then simply add the MAC in the **Cloned Address** field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Changing the MAC address from the GUI, step 2'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_03_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – Changing the MAC address from the GUI, step 2
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, from the command line or using a script, you can do the following (use
    your own interface names and target MAC address, of course):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: There is also the `macchanger` package with which you can change your interface's
    MAC address to a target value or to a pseudo-random value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a permanent MAC address change, you can use `netplan` and its associated
    configuration files. First, make a backup of the configuration file, `/etc/netplan./01-network-manager-all.yaml`,
    then edit it. Note that to change the MAC, you need a `match` statement for the
    hardware **Burned-In Address** (**BIA**) MAC address value, then the line after
    sets the new MAC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can test your new configuration with `sudo netplan try`, and apply it with
    `sudo netplan apply`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can create or edit the `/etc/udev/rules.d/75-mac-spoof.rules`
    file, which will execute on every startup. Add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: With the basics of MAC address usage in ARP mastered, let's dig a bit deeper
    into MAC addresses and their relationship to the manufacturers of the various
    network adapters.
  prefs: []
  type: TYPE_NORMAL
- en: MAC address OUI values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So now that we've covered timeouts and ARP, do we know everything we need to
    about Layer 2 and MAC addresses? Not quite yet – let's talk about **Organizationally
    Unique Identifier** (**OUI**) values. If you remember our discussion about how
    IP addresses are split into network and host sections using the subnet mask, you'll
    be surprised to know that there's a similar dividing line in MAC addresses!
  prefs: []
  type: TYPE_NORMAL
- en: The leading bits of each MAC address are supposed to identify the manufacturer
    – this value is called the OUI. OUIs are registered with the formal registry maintained
    by the IEEE and posted at [http://standards-oui.ieee.org/oui.txt](http://standards-oui.ieee.org/oui.txt).
  prefs: []
  type: TYPE_NORMAL
- en: However, the Wireshark project maintains a more complete listing, located at
    [https://gitlab.com/wireshark/wireshark/-/raw/master/manuf](https://gitlab.com/wireshark/wireshark/-/raw/master/manuf).
  prefs: []
  type: TYPE_NORMAL
- en: Wireshark also offer a lookup web application for this listing at [https://www.wireshark.org/tools/oui-lookup.html](https://www.wireshark.org/tools/oui-lookup.html).
  prefs: []
  type: TYPE_NORMAL
- en: Normally a MAC address is split equally, with the first 3 bytes (6 characters)
    being allocated to the OUI, and the last 3 bytes being allocated to uniquely identify
    the device. However, organizations are able to purchase longer OUIs (for a lower
    fee), which give them fewer device addresses to allocate.
  prefs: []
  type: TYPE_NORMAL
- en: OUIs are valuable tools in network troubleshooting – when problems arise or
    unknown stations appear on the network, the OUI values can help in identifying
    these culprits. We'll see OUIs crop up later in this chapter, when we discuss
    network scanners (Nmap in particular).
  prefs: []
  type: TYPE_NORMAL
- en: If you need a command-line OUI parser for Linux or Windows, I have one posted
    at [https://github.com/robvandenbrink/ouilookup](https://github.com/robvandenbrink/ouilookup).
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our first adventures in Layer 2 of the OSI model and our examination
    of its relationship to Layer 3, so let's venture higher into the stack into layer
    4, by looking at the TCP and UDP protocols and their associated services.
  prefs: []
  type: TYPE_NORMAL
- en: Layer 4 – how TCP and UDP ports work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Transmission Control Protocol** (**TCP**) and **User Datagram Protocol**
    (**UDP**) are normally what is meant when we discuss Layer 4 communications, in
    particular how they use the concept of *ports*.'
  prefs: []
  type: TYPE_NORMAL
- en: When a station wants to *talk* to another station in the same subnet using its
    IP address (the IP usually gets determined in the application or presentation
    layers), it will check its ARP cache to see whether there's a MAC address that
    matches that IP. If there's no entry for that IP address, it will send an ARP
    request to the local broadcast address (as we discussed in the last section).
  prefs: []
  type: TYPE_NORMAL
- en: The next step is for the protocol (TCP or UDP) to establish port-to-port communications.
    The station picks an available port, above `1024` and below `65535` (the maximum
    port value), called the **ephemeral port**. It then uses that port to connect
    to the fixed server port on the server. The combination of these ports, combined
    with the IP addresses at each end and the protocol in use (either TCP or UDP),
    will always be unique (because of the way the source port is chosen), and is called
    a **tuple**. This tuple concept is expandable, notably in NetFlow configurations,
    where other values can be "bolted on," such as **Quality of Service** (**QOS**),
    **Differentiated Services Code Point** (**DSCP**) or **Type of Service** (**TOS**)
    values, application names, interface names, and routing information such as **Autonomous
    System Numbers** (**ASNs**), MPLS, or VLAN information and bytes of traffic sent
    and received. Because of this flexibility, the basic 5-value tuple that all others
    are built on is often referred to as the **5-tuple**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first 1,024 ports (numbered `0-1023`) are almost never used as source ports
    – these are designated specifically as server ports, and need root privileges
    to work with. Ports in the range of `1024`-`49151` are designated "user ports"
    and `49152`-`65535` are dynamic or private ports. Servers are not however forced
    to use ports numbered below `1024` though (almost every database server for instance
    uses port numbers above `1024`), and this is just a historical convention that
    dates back to when TCP and UDP were being developed and all server ports were
    below `1024`. If you look at many of the servers that date back that far, you''ll
    see the following pattern, for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16336_Table_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A full listing of the ports that are formally assigned is maintained by the
    IANA, and is posted at [https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml](https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Documentation for this is in *RFC6335*.
  prefs: []
  type: TYPE_NORMAL
- en: In practice though, *assignment* is a strong word for this list. While it would
    be foolish to put a web server on TCP port `53`, or a DNS server on UDP port `80`,
    many applications are not on this list at all, so simply choose a port that is
    normally free and use that. It's not unusual to see vendors select a port that
    is actually assigned to someone else on this list, but assigned to a more obscure
    or less used service. So for the most part, this list is a set of strong suggestions,
    with the unspoken implication that we'll consider any vendor who selects a well-known
    port for their own use to be... let's say, "foolish."
  prefs: []
  type: TYPE_NORMAL
- en: Layer 4 – TCP and the three-way handshake
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: UDP simply picks up from working out the 5-tuple and starts sending data. It's
    up to the receiving application to take care of receiving that data, or to check
    the application's packets to verify that things arrive in order and to do any
    error checking. In fact, it's because of this lack of overhead that UDP is used
    so often for time-critical applications such as **VoIP** (**Voice over IP**) and
    video streaming. If a packet is missed in those types of applications, normally
    backtracking to retry it will interrupt the stream of data and be noticed by the
    end user, so errors are to some extent simply ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'TCP however negotiates a sequence number, and maintains a sequence count as
    the conversation progresses. This allows TCP-based applications to keep track
    of dropped or corrupted packets, and retry those in parallel with more data from
    the application being sent and received. The initial negotiation of this is usually
    called the **three-way-handshake** – graphically it looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – The TCP three-way handshake, with a TCP session established'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_03_005.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – The TCP three-way handshake, with a TCP session established
  prefs: []
  type: TYPE_NORMAL
- en: 'This works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first packet comes from the client from an ephemeral port, to the server's
    (usually) fixed port. It is has the **SYN** (synchronize) bit set, and has a randomly
    assigned **SEQ** (initial sequence) number, in this case **5432**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The reply packet from the server has the **ACK** (acknowledge) bit set, with
    a number of **5433**, and also has the **SYN** bit set with its own random **SYN**
    value, in this case **6543**. This packet may already contain data in addition
    to the handshake information (all subsequent packets may contain data).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The third packet is the **ACK** to the server's first **SYN**, with the number
    **6544**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Going forward, all packets are **ACK** packets sent to the other party so that
    every packet has a unique sequence number and a direction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Technically packet number **2** could be two separate packets, but normally
    they're combined into a single packet.
  prefs: []
  type: TYPE_NORMAL
- en: The graceful end of a conversation works exactly the same way. The party that's
    ending the conversation sends a **FIN**, the other replies with a **FIN-ACK**,
    which gets an **ACK** from the first party, and they're done.
  prefs: []
  type: TYPE_NORMAL
- en: An ungraceful end to the conversation is often initiated with a **RST** (reset)
    packet – once a **RST** is sent, things are over, and the other party shouldn't
    send a reply to that.
  prefs: []
  type: TYPE_NORMAL
- en: We'll use these topics later in this chapter, and also throughout the book.
    So if you're still fuzzy on this, have another read, especially of the preceding
    diagram, until this looks right to you.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have some idea of how TCP and UDP ports connect to each other and
    why your application might use one over the other, let's look at how your host's
    applications "listen" on various ports.
  prefs: []
  type: TYPE_NORMAL
- en: Local port enumeration – what am I connected to? What am I listening for?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many fundamental troubleshooting steps in networking are at one end or the other
    of a communication link – namely on the client or server host. For instance, if
    a web server isn't reachable, it's of course useful to see whether the web server
    process is running and is "listening" on the appropriate ports for client requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `netstat` command is the traditional method to assess the state of network
    conversations and services on the local host. To list all listening ports and
    connections, use the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16336_Table_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'All five parameters are illustrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the varying states (you can review all of these in the `man` page for
    `netstat`, using the `man netstat` command). The most common states that you will
    see are listed in the following table. If the descriptions for either seem confusing,
    you can skip forward to the next couple of pages to work this through using the
    diagrams (*Figures 3.6* and *3.7*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16336_Table_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The less commonly seen states (mostly because these usually only last for a
    short time) are shown in the following table. If you consistently see any of these
    states you may have a problem to troubleshoot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16336_Table_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'How do these states relate to the handshake we just discussed? Let''s put them
    in a diagram – note again that in most cases the intermediate steps should only
    exist for a very short time. If you see a `SYN_SENT` or `SYN_RECVD` state for
    more than a few milliseconds you likely have some troubleshooting to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – TCP session status at various points as the session is established'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_03_006.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6 – TCP session status at various points as the session is established
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll see similar states as a TCP session is torn down. Note again that many
    of the intermediate states should only last a short time. Poorly written applications
    often don''t do session teardown correctly, so you may see states such as `CLOSE
    WAIT` in those situations. Another case where session teardown isn''t done well
    is when an in-path firewall has a maximum TCP session length defined. This setting
    is usually in place to handle poorly written applications that don''t close out
    correctly, or perhaps never close out at all. A maximum session timer however
    can also interfere with long-running sessions such as older-style backup jobs.
    If you have such a situation and the long-running session doesn''t recover well
    (for instance a backup job that errors out instead of resuming the session), you
    may need to work with the firewall administrator to increase this timer, or work
    with the backup administrator to look at more modern backup software (with multiple
    parallel TCP sessions and better error recovery for instance):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – TCP session status at various points as the session is "torn
    down"'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_03_007.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.7 – TCP session status at various points as the session is "torn down"
  prefs: []
  type: TYPE_NORMAL
- en: Notice that on the session initiation, we don't have two states that separate
    the `SYN` and `ACK` back from the server – there are a lot more states involved
    in shutting down a session than in standing one up. Also note that packets turn
    around in fractions of a second, so if you see any TCP sessions in a `netstat`
    display that are anything other than `ESTABLISHED`, `LISTENING`, `TIME-WAIT`,
    or (less frequently) `CLOSED`, then something is unusual.
  prefs: []
  type: TYPE_NORMAL
- en: 'To relate the listening ports back to the services that are behind them, we''ll
    use `l` (for listening) instead of `a`, and add the `p` option for program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Are there alternatives to `netstat`? Definitely, there are many.
  prefs: []
  type: TYPE_NORMAL
- en: '`ss` for instance has almost the same functions. In the following table, you
    can see what we''ve asked for:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16336_Table_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s add the process information by adding the `p` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Notice how that last column was wrapped onto the next line? Let's use the `cut`
    command to only select some fields in this text display. Let's ask for columns
    1, 2, 4, 5, and 6 (we'll remove the `Recv-Q` and `Send-Q` fields). We'll do this
    using the concept of *piping* the output of one command to the next command.
  prefs: []
  type: TYPE_NORMAL
- en: The `cut` command has only a few options, and normally you'll use either `d`
    (delimiter) or `f` (field number).
  prefs: []
  type: TYPE_NORMAL
- en: In our case, our delimiter is a *space* character, and we want fields 1, 2,
    5, and 6\. Unfortunately, we have multiple spaces between our fields. How can
    we fix that? Let's use the `tr` (translate) command. Normally `tr` will translate
    one single character to a single different character, for instance `tr 'a' 'b'`
    will replace all occurrences of `a` with `b`. In our case though, we'll use the
    `s` option of `tr`, which will reduce multiple occurrences of the target character
    down to one.
  prefs: []
  type: TYPE_NORMAL
- en: 'What will our final set of commands look like? Look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The first command is the same `ss` command we used last time. We send that
    on to `tr`, which replaces all repeated space characters with a single space.
    `cut` gets the output of this and executes the following: "Using the space character
    delimiter, give me only fields 1, 2, 5, and 6, using a *T**ab* character between
    my resulting columns."'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our final result? Let''s see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Using the tab for a delimiter gives us a better chance of the resulting columns
    lining up. If this were a larger listing, we might send the whole output to a
    `.tsv` (short for **tab-separated variables**) file, which can be read directly
    by most spreadsheet applications. This would be done using a variant of piping,
    called **redirection**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we''ll send the whole output to a file called `ports.csv`
    using the `>` operator, then type the file using the `cat` (concatenate) command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, there''s a special command called `tee` that will send the output
    to two different locations. In this case, we''ll send it to the `ports.out` file,
    and the special `STDOUT` (standard output) file, which essentially means "type
    it back into my terminal session." For fun, let''s use the `grep` command to select
    only established sessions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Want to see some more detailed statistics on the TCP conversations? Use `t`
    for TCP, and `o` for options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This TCP options display can be useful in troubleshooting long-lived TCP sessions
    that might run through a firewall. Because of memory constraints, firewalls will
    periodically clear TCP sessions that have not terminated correctly. Since they
    haven't terminated, in most cases the firewall will look for sessions that have
    run longer than *x* minutes (where *x* is some number that has a default value
    and can be configured). A classic way that this can go sideways is if a client
    is running a backup or transferring a large file through the firewall, perhaps
    backing up to a cloud service or transferring a large file in or out of the network.
    If these sessions exceed that timeout value, they'll of course just get closed
    at the firewall.
  prefs: []
  type: TYPE_NORMAL
- en: In cases like this, it's important to see how long individual TCP sessions might
    last in a long transfer. A backup or a file transfer might be composed using several
    shorter sessions, running in parallel and in sequence to maximize performance.
    Or they might be a single transfer that runs as long as the process. This set
    of `ss` options can help you gauge how your process behaves under the hood, without
    having to resort to a packet capture (never fear, we will get to packet captures
    later in this book).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take one more crack at this, looking at the listening ports and relating
    the display back to the listening service on the host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Another classic way to collect this information is to use the `lsof` (list
    of open files) command. Wait a minute though, we want to get network information,
    not a list of who has what file open! The missing information behind this question
    is that in Linux, `lsof` to enumerate connections on TCP ports `80` and `22`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You can see the same information, represented in slightly different ways. This
    is also handy in that the `lsof` command explicitly shows the direction of each
    conversation, which it gets from the initial `SYN` packet in the conversation
    (whoever sent the first `SYN` packet is the client in any TCP conversation).
  prefs: []
  type: TYPE_NORMAL
- en: Why are we so focused on listening ports and processes? One answer was actually
    touched on earlier in this chapter – you can only have one service listening on
    a particular port. The classic example of this is trying to start a new website
    on TCP port `80`, not being aware that there's already a service listening on
    that port. In that case, the second service or process will simply fail to start.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've explored local listening ports, along with their associated processes,
    let's turn our attention to remote listening ports – services listening on other
    hosts.
  prefs: []
  type: TYPE_NORMAL
- en: Remote port enumeration using native tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So now we know how to work out our local services and some traffic diagnostics,
    how can we enumerate listening ports and services on remote hosts?
  prefs: []
  type: TYPE_NORMAL
- en: 'The easy way is to use native tools – for instance `scp` for SFTP servers,
    or `ftp` for FTP servers. But what if it''s some different service that we don''t
    have an installed client for. Simple enough, the `telnet` command can be used
    in a pinch for this – for instance, we can telnet to a printer''s admin port,
    running `http` (`tcp/80`), and make a `GET` request for the header of the first
    page. Notice the garbage characters at the bottom of the listing – that''s how
    graphics are represented on this page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Even if you don't know what to type, usually if you can connect at all with
    telnet, that means that the port you are trying is open.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few problems with this method though – if you don't know what to
    type, this isn't a foolproof way of determining whether that port is open or not.
    Also, quite often, exiting out of that session can be a problem – often `BYE`,
    `QUIT`, or `EXIT` will work, sometimes pressing *^c* (*Ctrl* + *C*) or *^z* will
    work, but neither of those methods is 100% guaranteed. Finally, it's likely you
    are either looking at multiple hosts or multiple ports, or this might be just
    the first step in your troubleshooting. All of these factors combined make this
    method both clumsy and time consuming.
  prefs: []
  type: TYPE_NORMAL
- en: In answer to this, we have dedicated *port scanner* tools that are purpose-built
    for this – `nmap` (which we'll cover in the next section) is the most popular
    of these. However, if you don't happen to have one of those installed, the `nc`
    (netcat) command is your friend!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s scan our example HP printer with netcat:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Or how about we test the first `1024` ports? Say we use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We get pages and pages of errors such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, let''s try to filter those down with our friend `grep`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: That still doesn't work – why not? The key is the word "error," Netcat sends
    errors to the special `STDERR` (standard error) file, which is normal in Linux
    (we'll see why successful connections count as errors for this tool later in this
    section). That file echoes to the console, but it's not `STDOUT`, so our `grep`
    filter misses it entirely. How do we fix this?
  prefs: []
  type: TYPE_NORMAL
- en: 'A bit of background on the three `STD` files or *streams* – they each have
    a file number associated with them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16336_Table_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'By playing some games with these file numbers, we can redirect `STDERR` to
    `STDOUT` (so `grep` will now work for us):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s `0` (which is seen on real networks), but netcat fails on that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can duplicate this for UDP as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we scan a UDP range this can take a `port unreachable` error, which
    isn''t always supported if you have any firewalls in the path. Let''s see how
    long that "first `1024`" scan takes when targeting a UDP port (note how we''re
    stringing commands together using the semicolon):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Yes, a solid 18 minutes – this method is not a speed demon!
  prefs: []
  type: TYPE_NORMAL
- en: 'Using netcat, you can also interact directly with a service, the same as in
    our telnet example, but without the "terminal/cursor control" type overhead that
    telnet brings. For instance, to connect to a web server, the syntax would be as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Of more interest though, we can stand up a fake service, telling netcat to listen
    on a given port. This can be extremely handy if you need to test connectivity,
    in particular if you want to test a firewall rule, but don't have the destination
    host or service built yet.
  prefs: []
  type: TYPE_NORMAL
- en: This syntax tells the host to listen on port `80`. Using the `l` parameter tells
    netcat to listen, but when your remote tester or scanner connects and disconnects,
    the netcat listener exits. Using the `l` parameter is the "listen harder" option,
    which properly handles TCP connections and disconnections, leaving the listener
    in place. Unfortunately, the `l` parameter and the `–e` (execute) parameter are
    both missing in the Ubuntu implementation of netcat. We can fake this out though
    – read on!
  prefs: []
  type: TYPE_NORMAL
- en: 'Expanding on this, let''s stand up a simple website using netcat! First, create
    a simple text file. We''ll make our `index.html` something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16336_Table_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, to stand up the website, let''s add a timeout of 1 second to our netcat
    statement, and put the whole thing into a loop so that when we exit a connection,
    netcat gets restarted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how listening on port `80` fails – we had to hit *Ctrl* + *C* to exit
    from the loop. Why is that? (Hint: go back to how ports are defined in Linux,
    earlier in this chapter.) Let''s try again with port `1500`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Browsing to our new website (note that it''s HTTP, and note the `:1500` used
    to set the destination port), we now see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – A Netcat simple website'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_03_008.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.8 – A Netcat simple website
  prefs: []
  type: TYPE_NORMAL
- en: 'Back on the Linux console, you''ll see that netcat echoes the client `GET`
    request and the browser''s `User-Agent` string. You''ll see the entire HTTP exchange
    (from the server''s perspective):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Making this a bit more active, let''s make this a website that tells us the
    date and time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Browsing to that site now gives us the current date and time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – A more complex Netcat website – adding time and date'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_03_009.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.9 – A more complex Netcat website – adding time and date
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, using `apt-get` to install the `fortune` package, we can now add a proverb
    to give us some *timely* wisdom:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Adding a fortune to the Netcat website'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_03_010.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.10 – Adding a fortune to the Netcat website
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also transfer a file using netcat. At the receiving end, we''ll listen
    on port `1234`, and send our output to `out.file`, again using redirection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'At the sending end, we''ll connect to that service for 3 seconds, and send
    it `sent-file.txt`. We''ll get our input by using redirection in the opposite
    direction, using the `<` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, back at the receiver, we can `cat` the resulting file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This illustrates that netcat can be a valuable troubleshooting tool, but it
    can be complex to use depending on what you are trying to accomplish. We can use
    netcat to be a simple proxy, as a simple chat application, or to present a complete
    Linux shell – all kinds of things that are handy to a network administrator (or
    a penetration tester for that matter).
  prefs: []
  type: TYPE_NORMAL
- en: That wraps up the basics of netcat. We've used netcat to enumerate local ports,
    connect to and interact with remote ports, stand up some fairly complex local
    services, and even transfer files. Now let's look at Nmap, a much faster and more
    elegant method of enumerating remote ports and services.
  prefs: []
  type: TYPE_NORMAL
- en: Remote port and service enumeration – nmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The tool that is most widely used to scan network resources is **NMAP** (short
    for **Network Mapper**). NMAP started as a simple port scanner tool, but is well
    past that set of simple functions now, with a long list of functions.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, nmap is not installed by default on a basic Ubuntu workstation
    (though it is included by default in many other distros). To install it, run `sudo
    apt-get install nmap`.
  prefs: []
  type: TYPE_NORMAL
- en: As we go forward working with nmap, please try the various commands we're using
    in our examples. You'll likely see similar results, and will learn about this
    valuable tool along the way. You may learn lots about your network along the way
    too!
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: One very important caveat on the advice of "try this out yourself." NMAP is
    a pretty innocuous tool, it almost never causes network problems. However, if
    you are running this against a production network, you will want to get a feel
    for that network first. There are several classes of gear that have particularly
    "rickety" network stacks – older medical devices for instance, as well as older
    **Industrial Control Systems** (**ICS**) or **Supervisory Control and Data Acquisition**
    (**SCADA**) gear.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, if you in are a hospital, a factory, or a utility, take care!
    Running any network mapping against your production networks can cause issues.
  prefs: []
  type: TYPE_NORMAL
- en: You likely do still want to do this, but test against known "idle" gear first
    so you know that when you scan the "real" network, you have some assurance that
    you aren't going to cause a problem. And please (**please**), if you are on a
    healthcare network, **don't ever** scan anything that's attached to a person!
  prefs: []
  type: TYPE_NORMAL
- en: A second (legal) caveat – don't scan things without permission. If you are on
    your home or lab network, that's a great place to play with assessment tools such
    as nmap or more aggressive security assessment tools. However, if you are at work,
    even if you're sure that you're not going to cause problems, you'll want to get
    permission in writing first.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning internet hosts that you don't own or don't have written permission
    to scan is very much illegal. Many would consider it pretty innocuous, and in
    most cases scanning is simply considered "internet white noise" by most companies
    (most organizations are scanned dozens or hundreds of times per hour). Always
    keep in mind that the proverb "the difference between a criminal and an information
    security professional is a signed contract" is repeated so often because it is
    100% true.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all that behind us, let''s get more familiar with this great tool! Try
    running `man nmap` (remember the `manual` command?) – there''s lots of good information
    in the man pages for nmap, including full documentation. Once we get more familiar
    with the tool though, you may find the help text quicker to use. Normally you
    know (more or less) what you are looking for, so you can search for it using the
    `grep` command, for instance: `nmap - -help | grep <my_search_string>`. In the
    case of nmap, you can dispense with the standard `- - help` option, as the default
    output of nmap with no arguments is the help page.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to find out how to do a ping scan – that is, to ping everything in the
    range (which I always forget the syntax for) – you would search as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'How do we proceed? NMAP wants to know what you want mapped – in this case I''ll
    map the `192.168.122.0/24` subnet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: So that's a quick scan that tells us every IP that is currently active on our
    subnet.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look for services. Let's start by looking for anything running `tcp/443`
    (which you may recognize as HTTPS). We'll use the `nmap –p 443 –open 192.168.122.0/24`
    command. There are two things to note in this command. First of all, we specified
    the port with the `-p` option.
  prefs: []
  type: TYPE_NORMAL
- en: By default NMAP scans for TCP ports using a `SYN` scan. nmap sends a `SYN` packet,
    and waits to get back a `SYN-ACK` packet. If it sees that, the port is open. If
    it gets a `port unreachable` response, then the port is considered closed.
  prefs: []
  type: TYPE_NORMAL
- en: If we wanted a full `connect` scan (where the entire three-way handshake completes),
    we could have specified `-sT`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we see a `--open` option. This indicates "only show me open ports." Without
    this we would see closed ports as well as "filtered" ports (which typically means
    nothing came back from the initial packet).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted more detail on why a port might be considered open, closed, or
    filtered, we would remove the `--open` option, and add `--reason`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'To scan UDP ports, we would use the same syntax, but add the `sU` option. Notice
    at this point that we''re starting to see MAC addresses of the hosts that are
    up. This is because the scanned hosts are in the same subnet as the scanner, so
    that information is available. NMAP uses the MAC addresses'' OUI section to identify
    the vendor of each network card:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Oops – because we''re scanning for UDP ports, Nmap needs to run with root privileges
    (using `sudo`). This is because it needs to put the sending interface into *promiscuous
    mode* so that it can capture any packets that might be returned. This is because
    there is no Layer 5 concept of a *session* in UDP like we have in TCP, so there
    is no layer 5 connection between the sent and received packets. Depending on what
    command-line arguments are used (not just for UDP scans), Nmap may need elevated
    rights. In most cases if you are using Nmap or a similar tool, you''ll find yourself
    using `sudo` a fair bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'A few more things to note about this scan:'
  prefs: []
  type: TYPE_NORMAL
- en: The initial scan attempt failed – note that you need root rights to do most
    scans within NMAP. To get the results it does, in many cases the tool crafts packets
    itself rather than using the standard OS services to do that, and it also usually
    needs rights to capture packets that are returned by your target hosts – so nmap
    needs elevated privileges for both of those operations.
  prefs: []
  type: TYPE_NORMAL
- en: We see lots more statuses indicating `open|filtered` ports. UDP is particularly
    prone to this – since there's no `SYN`/`SYN-ACK` type of handshake, you send a
    `UDP` packet, and you may not get anything back – this doesn't necessarily mean
    the port is down, it might mean that your packet was processed by the remote service,
    and no acknowledgment was sent (some protocols are like that). Or in many cases
    it might mean that the port is not up, and the host does not properly return an
    ICMP `Port Unreachable` error message (ICMP Type 1, Code 3).
  prefs: []
  type: TYPE_NORMAL
- en: 'To get more detail, let''s use the `sV` option, which will probe the ports
    in question and get more information on the service itself. In this case, we''ll
    see that `192.168.122.1` is identified positively as open, running the `domain`
    service, with a service version listed as `generic dns response: NOTIMP` (this
    indicates that the server does not support the DNS `UPDATE` function, described
    in *RFC 2136*). The *service fingerprint* signature following the service information
    can be helpful in further identifying the service if the NMAP identification isn''t
    conclusive.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice also that for other hosts, the reason is listed as `no-response`. If
    you know the protocol, you can usually make good inferences in those situations.
    In the case of scanning for DNS, `no-response` means that there's no DNS server
    there or the port is closed. (or possibly it's open with some oddball service
    other than DNS running on it, which is highly unlikely). (This is to the one DNS
    server at `192`.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Also note that this scan took a solid 100 seconds, roughly 50 times our original
    scan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try an `sV` verbose service scan of just `192.168.122.1`, port `tcp/443`
    – we''ll see that NMAP does a pretty good job of identifying the web server running
    on that host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Trying the same against `192.168.122.51`, we see that the service is properly
    identified as the VMware ESXi 7.0 management interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Now that we're experts at scanning ports with various options, let's expand
    on this. NMAP allows us to run scripts against any open ports it finds – this
    can be a great time saver!
  prefs: []
  type: TYPE_NORMAL
- en: NMAP scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far we've just looked at port scanning – NMAP is much more than that though.
    A fully featured scripting engine is available to process the packets or the output
    of NMAP, based on Lua (a text-based interpreted language). We won't dig into LUA
    in this book to any great extent, but NMAP does come with several pre-written
    scripts, some of which are invaluable to a network administrator.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, consider the SMB version information. Microsoft has been strongly
    recommending that SMBv1 be retired for years now, peaking just before the EternalBlue
    and EternalRomance vulnerabilities in SMBv1 were used by the WannaCry/Petya/NotPetya
    families of malware in 2017\. While SMBv1 has been effectively retired by making
    it hard to even enable in newer Windows versions, we still see SMBv1 in corporate
    networks – whether on older server platforms or on older Linux-based appliances
    that implement SMBv1 in their SAMBA service. Scanning for this couldn''t be easier
    using the `smb-protocols` script. Before you use any script, it''s handy to open
    the script to see exactly what it does, and how it needs to be called by NMAP
    (what ports or arguments it might need). In this case, the `smb-protocols` text
    gives us the usage, as well as what to expect in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s scan some specific hosts in a target network to see more. We''ll just
    show the output from one example host that has the SMBv1 protocol running. Note
    that from the hostname it seems to be a **Network-Attached Storage** (**NAS**)
    device, so is likely Linux- or BSD-based under the hood. From the OUI we can see
    the brand name of the host, which gives us even more specific information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Or you can scan for the `Eternal*` vulnerabilities directly using the `smb-vuln-ms17-010.nse`
    script (showing just one host as an example). Scanning that same host, we see
    that even though SMBv1 is enabled, that specific vulnerability is not in play.
    It's still strongly recommended that SMBv1 be disabled though, as there's a whole
    list of vulnerabilities that SMBv1 is susceptible to, not just `ms17-010`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scrolling down a bit further in the list, our second example host does have
    that vulnerability. From the hostname, we see that this is likely a business-critical
    host (running BAAN), so we''d much rather have this server fixed than ransomware.
    Looking at the production application on that host, there''s really no reason
    for SMB to be exposed at all to most users – really only system or application
    administrators should be mapping a drive to this host, and users would connect
    to it through its application port. The recommendation for this is clearly to
    patch the vulnerability (this likely hasn''t been done in several years), but
    also to firewall that service away from most users (or disable that service if
    it isn''t used by the administrators):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Nmap installs with hundreds of scripts. If you are looking for something specific,
    especially if you can't determine it from just a port scan, then using one or
    more nmap scripts is often the easiest way to go. Just keep in mind that if you
    are looking for a "rogue" host, say a DHCP server, you'll find your production
    host as well as any unwanted instances.
  prefs: []
  type: TYPE_NORMAL
- en: Note that many of these rely on you to include the right port numbers in the
    scan. The "broadcast" style scripts will usually only scan the subnet that your
    scanner is on, so scanning a remote subnet likely means "borrowing" or placing
    a host on that subnet. Many of the core network services discussed in this list
    are covered in later chapters in this book, including DNS, DHCP, and the like.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind (again) that scanning without authorization is never in your best
    interest – get written permission first!
  prefs: []
  type: TYPE_NORMAL
- en: 'There are definitely hundreds of scripts that come with nmap, and hundreds
    more available with a quick internet search. Some of the pre-packaged nmap scripts
    I find handiest on a production network include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16336_Table_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Unexpected, malicious, or misconfigured network infrastructure**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16336_Table_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Server problems and malicious services**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16336_Table_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Pirated, "shadow IT," malicious, or otherwise unexpected servers**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16336_Table_13a.jpg)![](img/B16336_Table_13b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Workstation issues**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16336_Table_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Network perimeter problems**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16336_Table_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Miscellaneous server or workstation issues**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16336_Table_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This summarizes the various uses of Nmap. Where Nmap doesn't do so well is in
    larger networks – for instance, in `/8` or `/16` networks, or some of the really
    large IPv6 networks. For these networks, a faster tool is needed. Let's explore
    the MASSCAN tool for these uses.
  prefs: []
  type: TYPE_NORMAL
- en: Are there limits to Nmap?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The primary limit to Nmap is performance. As the network size grows, Nmap will
    (of course) take longer and longer to complete any scan you are running. This
    is often not an issue, but in a production network, if your scan starts at 8 A.M.
    and ends sometime the next day, there's likely a sizable amount of time where
    devices are mostly powered off or are disconnected, so the scan's usefulness will
    suffer. This gets especially pronounced when you are on very large networks –
    for instance, as your subnet mask shrinks or your network count grows, scan times
    for Nmap can grow to hours, days, or weeks. Equally, on IPv6 networks it's common
    to see thousands, hundreds of thousands, or even millions of addresses, which
    can translate to Nmap scan times of years or decades.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways to help resolve this.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, if you read the NMAP `man` page, there are some parameters to speed
    things up – you can adjust parallelism (how many operations can run at once),
    host timeouts, round trip timeouts, and the delay wait between operations. These
    are fully explained on the `man` page, and are discussed in more depth here: [https://nmap.org/book/man-performance.html](https://nmap.org/book/man-performance.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, you can look at a different tool. Rob Graham maintains the MASSCAN tool,
    which is specifically built for high-performance scanning. With enough bandwidth
    and horsepower, it can scan the entire IPv4 internet in under 10 minutes. Version
    1.3 of this tool adds IPv6 support. The MASSCAN syntax is similar to Nmap''s,
    but there are some things to watch out for when using this faster tool. The tool,
    as well as its documentation and "gotchas," is posted here: [https://github.com/robertdavidgraham/masscan](https://github.com/robertdavidgraham/masscan).'
  prefs: []
  type: TYPE_NORMAL
- en: For very large networks, a common approach would be to use MASSCAN (or Nmap
    tuned for faster scans) for an initial set of scans. The output from that cursory
    scan can then be used to "feed" the next tool, whether that is Nmap or possibly
    some other tool, perhaps a security scanner such as Nessus or OpenVAS. "Chaining"
    tools together like this maximizes the strengths of each to deliver the best outcomes
    in the shortest time.
  prefs: []
  type: TYPE_NORMAL
- en: All tools have their limits though, and IPv6 networks remain a challenge for
    scanning tools. Unless you can limit the scope somehow, IPv6 will quickly reach
    the limits of network bandwidth, time, and memory on the scanning host. Tools
    such as DNS harvesting can help here – if you can identify which hosts are actually
    active before scanning for services, that can reduce the target addresses significantly
    back down to manageable volumes.
  prefs: []
  type: TYPE_NORMAL
- en: With port scanning behind us, let's leave the wired world and explore troubleshooting
    with Linux on wireless networks.
  prefs: []
  type: TYPE_NORMAL
- en: Wireless diagnostic operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Diagnostic tools in wireless networks are generally concerned with finding areas
    of low signal strength and interference – things that cause problems for the folks
    using your wireless network.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few excellent wireless tools that are Linux-based, but we'll discuss
    Kismet, Wavemon, and LinSSID. All three tools are free, and all can be installed
    with the standard `apt-get install <package name>` command. If you expand your
    tool search to include attack-type tools or commercial products, that list obviously
    grows much bigger.
  prefs: []
  type: TYPE_NORMAL
- en: Kismet is one of the older wireless tools available for Linux. My first exposure
    to it was as an information security tool, highlighting that "hidden" wireless
    SSIDs were in fact not hidden at all!
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the tool, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if you have a fully working configuration and don''t need the actual server
    window, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in another window (or in the same place if you ran Kismet in the background),
    run the Kismet client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In the display that appears, you'll see the various SSIDs, and the BSSIDs of
    the access points that are transmitting them. As you scroll through this list,
    you'll see the channel and encryption types used for each SSID, the speed that
    your laptop understands that it can negotiate on that SSID, and also all of the
    client stations on that SSID. Each client will have its MAC address, frequency,
    and packet count shown. This information is all sent in cleartext as part of each
    client's association process and continued connection "handshaking."
  prefs: []
  type: TYPE_NORMAL
- en: Since your wireless adapter can only be on one SSID/BSSID combination at once,
    the information presented is collected by hopping between channels.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we show a hidden SSID, with the BSSID of the access
    point shown, as well as the eight clients associated with that SSID on that access
    point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – Typical Kismet output on the main screen'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_03_011.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.11 – Typical Kismet output on the main screen
  prefs: []
  type: TYPE_NORMAL
- en: 'Pressing *Enter* on a network gives you more information on the SSID being
    broadcast from that access point. Note we''re seeing a **hidden SSID** in this
    display:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – Kismet output, access point/SSID detail'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_03_012.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.12 – Kismet output, access point/SSID detail
  prefs: []
  type: TYPE_NORMAL
- en: 'Drilling down further, you can get details on client activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – Kismet output, client detail'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_03_013.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.13 – Kismet output, client detail
  prefs: []
  type: TYPE_NORMAL
- en: While Kismet is a great tool for reconnaissance and demonstrations, the menu
    is fairly easy to get lost in, and it isn't easy to focus on tracking the things
    we really care about when troubleshooting signal strength.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wavemon is a very different tool. It monitors your connection only, so you
    have to associate it with an SSID. It''ll give you your current access point,
    speed, channel, and so on, as shown in the following screenshot. This can be useful,
    but it''s a narrow view of the information that''s normally required for troubleshooting
    – note in the following screenshot that the values reported are mostly about data
    throughput and signal as seen from the network that the adapter is associated
    to. For this reason, the Wavemon tool is mostly useful for troubleshooting uplink
    issues, and isn''t used so much in troubleshooting, assessing, or viewing information
    on an overall wireless infrastructure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – Wavemon display'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_03_014.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.14 – Wavemon display
  prefs: []
  type: TYPE_NORMAL
- en: Of more use is **LinSSID**, a fairly close port of inSSIDer, the Windows application
    from MetaGeek. On running the application, the screen is fairly empty. Select
    the wireless adapter that you want to use to "sniff" the local wireless networks,
    and press the **Run** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'The display shows the channels available on both spectrums (2.4 and 5 GHz),
    with each SSID represented in the top window. Each SSID/BSSID combination that
    is checked in the list is shown in the bottom window. This makes it very easy
    to see the signal strength of each AP in the list, along with the relative strengths
    in the graphical display. SSIDs that interfere with each other are obvious in
    their overlapping graphical displays. The following screenshot of the display
    shows the 5 GHz spectrum situation – notice how the APs seem to all be clustered
    around two channels. Any one of them could improve their performance by changing
    channels, and in our display there''s plenty of channels to spare – in fact, this
    is what''s pushing the migration to 5 GHz. Yes, that band is faster, but more
    importantly it''s much easier to solve any interference problems from neighboring
    access points. Note also that each channel is shown on the graph as taking roughly
    20 GHz (more on this later):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15 – LinSSID output – the main screen showing channel allocation
    and strength, both in text and graphically'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_03_015.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.15 – LinSSID output – the main screen showing channel allocation and
    strength, both in text and graphically
  prefs: []
  type: TYPE_NORMAL
- en: 'The 2.4 GHz channel is no better. Since there are only 11 channels available
    in North America, you normally see people select channels 1, 6, or 11 - the 3
    channels that do not interfere with each other. In almost any environment that
    isn''t rural, you''ll see several neighbors using those same 3 channels that you
    thought were free! In the following screenshot, we see that everyone picked channel
    11 for some reason:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.16 – Interference from wireless neighbors – multiple wireless BSSIDs
    using the same channel'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_03_016.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.16 – Interference from wireless neighbors – multiple wireless BSSIDs
    using the same channel
  prefs: []
  type: TYPE_NORMAL
- en: In this second example (also from the 2.4 GHz spectrum), we see the result of
    people choosing a wider "footprint" for their signal. In `802.11` wireless, you
    have the option of expanding your default 20 GHz channel to 40 of 80 GHz. The
    benefit to this is that – in the absence of any neighbors – this will certainly
    improve throughput, especially for a lightly utilized channel (one or two clients
    for instance). However, in an environment where adjacent access points have overlapping
    signals, you can see that increasing channel width (on the 2.4 GHz band) leaves
    everyone with more interference – neighboring access points can find themselves
    with no good channel choices. This situation will typically impact the signal
    quality (and throughput) for everyone, including the one "bad neighbor" that chose
    to increase their channel width.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the 5 GHz band, there are significantly more channels, so increasing your
    channel width can usually be done more safely. It''s always wise to see what''s
    happening in your spectrum first though, before either selecting or widening the
    channels on your access points:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.17 – Using wider channel widths in the 2.4 GHz spectrum, with resulting
    interference'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_03_017.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.17 – Using wider channel widths in the 2.4 GHz spectrum, with resulting
    interference
  prefs: []
  type: TYPE_NORMAL
- en: Of the tools we've discussed, LinSSID in particular is very useful in doing
    wireless site surveys where you need to see which channels are available, and
    more importantly, track signal strength and find "dead spots" to maximize wireless
    coverage throughout a building or area. LinSSID is also the most helpful of the
    tools we've discussed in finding situations of channel interference, or troubleshooting
    situations where a poor choice was made in channel width.
  prefs: []
  type: TYPE_NORMAL
- en: With what we've discussed and the tools we've explored, you should now be well
    equipped to troubleshoot issues around wireless signal strength and interference
    on both the 2.4 GHz and 5 GHz bands. You should be able to use tools such as Kismet
    to find hidden SSIDs, tools such as Wavemon to troubleshoot networks you are associated
    with, and tools including LinSSID to view the wireless spectrum holistically,
    looking for interference and signal strength, as well as issues with channel width
    and channel overlap.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this chapter behind us, you should have a good understanding of the hierarchal
    organization of the various networking and application protocols, as described
    in the OSI model. You should have a solid understanding of TCP and UDP, in particular
    how both protocols use ports, and how TCP sessions are set up and torn down. Using
    `netstat` or `ss` to see how your host is connecting to various remote services,
    or what services your host is listening for, is a skill you can use going forward.
    Expanding on this, using port scanners to see what hosts and network services
    are running in your organization should be a skill that you should find useful.
    Finally, our discussion of Linux wireless tools should help in troubleshooting,
    configuration, and wireless site surveys. All of these skills will be things we
    build on as we move forward in our journey in this book, but more importantly,
    they'll be useful in troubleshooting application and networking problems in your
    organization.
  prefs: []
  type: TYPE_NORMAL
- en: This wraps up our discussion of network troubleshooting using Linux. We'll revisit
    troubleshooting in most chapters though – as we move forward and build each part
    of our infrastructure, we'll find new potential problems and troubleshooting approaches.
    In this section, we discussed in detail how communications occur from a network
    and host point of view. In the next chapter, we'll discuss Linux firewalls, a
    good way to limit and control those communications.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material. You will find the answers in the *Assessments*
    section of the *Appendix*:'
  prefs: []
  type: TYPE_NORMAL
- en: When you assess your local ports using `netstat`, `ss`, or another command,
    will you ever see a UDP session in the `ESTABLISHED` state?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it important to be able to determine which processes listen on which
    ports?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it important to determine which remote ports you connect to from any
    particular application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why would you scan for expired or soon-to-expire certificates on ports other
    than `tcp/443`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why would netcat need `sudo` rights in order to start a listener on port `80`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the 2.4 GHz band, which three channels make the best selection to reduce
    interference?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When would you use a Wi-Fi channel width other than 20 GHz?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The OSI model (*ISO/IED 7498-1*): [https://standards.iso.org/ittf/PubliclyAvailableStandards/s020269_ISO_IEC_7498-1_1994(E).zip](https://standards.iso.org/ittf/PubliclyAvailableStandards/s020269_ISO_IEC_7498-1_1994(E).zip)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Nmap: [https://nmap.org/](https://nmap.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Nmap reference guide: [https://nmap.org/book/man.html](https://nmap.org/book/man.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.amazon.com/Nmap-Network-Scanning-Official-Discovery/dp/0979958717](https://www.amazon.com/Nmap-Network-Scanning-Official-Discovery/dp/0979958717)'
  prefs: []
  type: TYPE_NORMAL
- en: 'MASSCAN: [https://github.com/robertdavidgraham/masscan](https://github.com/robertdavidgraham/masscan)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
