- en: Implementing a Decentralized Application Using IPFS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to combine a smart contract with the **InterPlanetary
    File System** (**IPFS**) to build a decentralized video-sharing application (similar
    to YouTube but decentralized). We will use a web application as the frontend for
    the blockchain and IPFS. As stated previously, IPFS is not a blockchain technology.
    IPFS is a decentralized technology. However, in a blockchain forum, meetup, or
    tutorial, you may hear IPFS being mentioned quite often. One of the main reasons
    for this is that IPFS overcomes the weakness of blockchain, which is that its
    storage is very expensive.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Architecture of the decentralized video-sharing application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing the video-sharing smart contract
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the video-sharing web application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architecture of the decentralized video-sharing application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is how our application will look after it is finished—first, you go to
    a website, where you will see a list of videos (just like YouTube). Here, you
    can play videos in your browser, upload videos to your browser so that people
    can watch your cute cat video, and like other people's videos.
  prefs: []
  type: TYPE_NORMAL
- en: On the surface, this is like a normal application. You build it with your favorite
    Python web framework, such as Django, Flask, or Pyramid. Then you use MySQL or
    PostgreSQL as the database. You could choose NGINX or Apache as the web server
    in front of the Gunicorn web server. For caching, you can use Varnish for full
    page caching and Redis for template caching. You will also host the web application
    and videos on the cloud, such as **Amazon Web Service** (**AWS**) or **Google
    Cloud Platform** (**GCP**), Azure. Then you will use a content delivery network
    to make it scalable worldwide. For the frontend side, you could use the JavaScript
    framework, with React.js, Angular.js, Vue.js, or Ember. If you are an advanced
    user, you could use machine learning for video recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: However, the key point here is that what we want to build is a decentralized
    video sharing application with blockchain technology, not a centralized application.
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss what we mean by building a decentralized video-sharing application
    with blockchain technology.
  prefs: []
  type: TYPE_NORMAL
- en: 'We cannot store video files on the Ethereum blockchain as it is very expensive;
    even storing a picture file costs an arm and a leg on the Ethereum blockchain.
    Someone has done the math on this for us at the following link: [https://ethereum.stackexchange.com/questions/872/what-is-the-cost-to-store-1kb-10kb-100kb-worth-of-data-into-the-ethereum-block](https://ethereum.stackexchange.com/questions/872/what-is-the-cost-to-store-1kb-10kb-100kb-worth-of-data-into-the-ethereum-block).'
  prefs: []
  type: TYPE_NORMAL
- en: The cost of storing 1 KB is roughly 0.032 ETH. A decent image file is about
    2 MB. 1 MB is 1,000 KB if you ask hard drive manufacturers, or 1,024 KB if you
    ask an operating system. We simply round this to 1,000 because it does not make
    any difference to our calculation. Consequently, the cost of storing a 2 MB file
    on Ethereum is around 2,000 multiplied by 0.032 ETH, which is equal to 64 ETH.
    The price of ETH is always changing. At the time of writing, the cost of 1 ETH
    is around 120 US dollars. This means that to store a 2 MB picture file (a normal
    size stock picture file on the Unsplash website) you need to spend 7,680 US dollars.
    A one-and-a-half-minute video file in MP4 format is roughly 46 MB. Consequently,
    you need to spend 176,640 US dollars to store this video file on Ethereum.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of paying this, blockchain developers will usually store the reference
    of a video file on the blockchain and store the video file itself on normal storage,
    such as on AWS. In a Vyper smart contract, you can use the `bytes` data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you could store the link of the video that you store in AWS S3 ([https://aws.amazon.com/s3/](https://aws.amazon.com/s3/))
    in the smart contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This approach is all fine and dandy, but the problem is that you are dependent
    on AWS. If the company does not like your cute panda video, they could delete
    it, and the URL that is present in the smart contract becomes invalid. You could
    of course change the value of the `cute_panda_video` variable on the smart contract
    (unless you forbid it from doing so). However, this situation causes inconveniences
    in our application. If you use the service from a centralized company, your faith
    is dependent on the whim of that company.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can mitigate this problem by using decentralized storage, such as IPFS.
    Instead of an URL, we could store the IPFS path (or IPFS hash) as the value of
    the `cute_panda_video` variable, similar to the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Then, we can launch our IPFS daemon on AWS and other places, such as GCP. Consequently,
    if AWS censors our cute panda video, the IPFS path of our cute panda video is
    still valid. We could serve the video from other places, such as GCP. You could
    even host the video on the computer at your grandma's house. People who are addicted
    to cute panda videos could even pin the video, and help us serve the cute panda
    video.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other than hosting a cute panda video in a decentralized fashion, there are
    other values of the decentralized video sharing application. This value relates
    to blockchain technology. Suppose we want to build a **like** (thumbs up) video
    feature. We could store the like value on the blockchain. This prevents corruption.
    Imagine we want to build a voting contest for the cutest panda video with a prize
    of 10 BTC. If our contest application is done in a centralized fashion (using
    a table to keep the like value on a SQL database such as MySQL or PostgreSQL),
    we, as a centralized admin, could hijack the winner using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Of course, it is not this easy to cheat. You need to cover your tracks with
    database logs by ensuring that the aggregate counts match individual counts. This
    needs to be done subtly. Instead of adding a whopping number of votes, such as
    1 million at once, you could add the aggregate count to a random number between
    100 and 1,000 in an hour. This is not to suggest that you cheat the users, I am
    merely getting my point across.
  prefs: []
  type: TYPE_NORMAL
- en: With blockchain, we can prevent the corruption of the integrity of data via
    the centralized admin. The like value is kept in the smart contract, and you let
    people audit the smart contract's source code. Our like feature on the decentralized
    video sharing application increases the number of likes on a video through an
    honest process.
  prefs: []
  type: TYPE_NORMAL
- en: Other than the integrity of data, we could build a crypto economy. What I mean
    is, we could have economic activities (such as selling, buying, bidding, and so
    on) in our smart contract. We could build tokens in the same smart contract. The
    coin of this token could be spent on liking the video, so that liking videos is
    no longer free. The owner of the video could cash this out like money into their
    pocket. This dynamic could incentivize people to upload better videos.
  prefs: []
  type: TYPE_NORMAL
- en: On top of that, a decentralized application guarantees the independence of APIs.
    The nature of the decentralization of the application prevents APIs from being
    disturbed or harassed in a similar way to the Twitter API fiasco. A long time
    ago, developers could develop an interesting application on top of the Twitter
    API with a lot of freedom, but then Twitter imposed heavy restrictions on how
    developers could use their API. One such example is that Twitter once shut down
    API access to Politwoops, which preserved politicians' deleted tweets. Access
    has been reactivated, though. By making our application decentralized, we could
    increase the democratic nature of the API.
  prefs: []
  type: TYPE_NORMAL
- en: For educational purposes, our application has two main features. Firstly, you
    can see a list of videos, play videos, and upload videos. These are normal things
    that you do on YouTube. Secondly, you can like a video, but only with a coin or
    token.
  prefs: []
  type: TYPE_NORMAL
- en: Before we jump into building the application, let's design the architecture
    of the smart contract and the architecture of the web application.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture of a video-sharing smart contract
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our application starts with the smart contract. There are a few things that
    our smart contract needs to do here, and these are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Keep track of videos that have been uploaded by a user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilize a token and its standard operation (ERC20)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide a way for a user to like a video using a coin or token
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The coin used for liking a video will be transferred to the video owner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's it. We always strive to keep the smart contract as short as possible.
    The more the lines of code, the bigger the chances of a bug showing up. And a
    bug in the smart contract can't be fixed.
  prefs: []
  type: TYPE_NORMAL
- en: Before writing this smart contract, let's think about how we want to structure
    our smart contract. The structure of the smart contract includes the data structure.
    Let's look at an example of what data structure we want to use to track a user's
    videos.
  prefs: []
  type: TYPE_NORMAL
- en: We definitely want to use a mapping variable with an address data type as the
    key. The difficult part here is choosing what data type we want to use as the
    value for this mapping data type. As we learned in [Chapter 3](9505075a-72c4-4fbe-ad17-564e599c3193.xhtml), *Implementing
    Smart Contracts Using Vyper*, there is no infinite size array in Vyper. If we
    use a `bytes32` array, we are limited to a certain size of array as the value
    for this mapping. This means a user can have a maximum size of videos. We can
    use a `bytes32` array to hold a list of videos that is very large in size, such
    as 1 million videos. What is the chance someone will upload more than 1 million
    videos? If you upload one video per day, you will only upload 3,650 videos in
    ten years. However, the problem with the `bytes32` array is, that it cannot accept data
    more than 32 bytes in size. The IPFS path, such as `QmWgMcTdPY9Rv7SCBusK1gWBRJcBi2MxNkC1yC6uvLYPwK`,
    has a length of 44 characters. Consequently, you must use at least a `bytes[44]`
    data type, but we round this up to `bytes[50]`.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we want to have another mapping data type variable (let's call this
    mapping z) as the value of this mapping data type variable, which has been described
    in the previous paragraph. Mapping z has an integer as the key and a struct that
    contains a `bytes[50]` data type variable to keep the IPFS path and the `bytes[20]`
    data type variable to keep the video title as the value. There is an integer tracker
    to initiate the value of the key in mapping z. This integer tracker is initialized
    with the value 0\. Every time we add a video (IPFS path and video title) to mapping
    z, we increase this integer tracker by one. So the next time we add another video,
    the key of mapping z is not 0 anymore, but 1\. This integer tracker is unique
    for each account. We could create another mapping of the account to this integer
    tracker.
  prefs: []
  type: TYPE_NORMAL
- en: After taking care of videos, we focus on likes. How do we store the fact that
    user A likes video Z? We need to make sure that a user cannot like the same video
    more than once. The easiest way to do this is to create a mapping with a `bytes[100]`
    data type as the key and a `boolean` data type as the value. The `bytes[100]`
    data type variable is a combination of using the video liker's address, the video
    uploader's address, and the index of videos. The `boolean` data type variable
    is used to indicate whether the user has already liked the video or not.
  prefs: []
  type: TYPE_NORMAL
- en: On top of that, we need an integer data type to keep the aggregate count of
    the number of likes a video has. The aggregate likes is a mapping with a `bytes[100]`
    data type as the key and an `integer` data type as the value. The `bytes[100]`
    data type variable is a combination of the video uploader's address and the index
    of the videos.
  prefs: []
  type: TYPE_NORMAL
- en: The downside of this approach is that it is very hard to keep track of which
    users have liked particular videos in the smart contract. We could create another
    mapping to keep track of which users have liked a certain video. However, that
    would complicate our smart contract. Previously, we went the extra mile to create
    a mapping dedicated to keeping track of all videos that a user has uploaded. That
    is necessary because we want to get a list of a user's videos. This is what we
    call a core feature. However, keeping track of which users have liked a video
    is not what I call a core feature.
  prefs: []
  type: TYPE_NORMAL
- en: As long as we can make the video-liking process honest, we don't need to keep
    track of which users have liked a video. If we are really itching to keep track
    of these users, we can use events in a smart contract. Every time a user likes
    a video, it triggers an event. Then, on the client side with the `web3.py` library,
    we could filter these events to get all users who like a particular video. This
    will be an expensive process and should be done separately to the main application.
    We can use background jobs using Celery, at which point the result can be stored
    on a database such as SQlite, PostgreSQL, or MySQL. Building a decentralized application
    does not mean completely negating a centralized approach.
  prefs: []
  type: TYPE_NORMAL
- en: The topic of tokens has been discussed thoroughly in [Chapter 8](a4f3e7c5-3229-44cf-83d1-62c660fb04f2.xhtml), *Creating
    Token in Ethereum*.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture of a video-sharing web application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will develop a Python web application to use as the frontend for our smart
    contract. This means we need a proper server to become the host for the Python
    web application. For this, we at least need a Gunicorn web server. In other words,
    we need to host our Python web application in a centralized server, such as in
    AWS, GCP, or Azure. This is actually fine for viewing videos, but the problem
    arises when a user wants to upload a video because that requires accessing a private
    key. Users may become concerned that our Python web application on a centralized
    server would steal their private keys.
  prefs: []
  type: TYPE_NORMAL
- en: So, the solution is to post the source code of our Python web application on
    GitHub or GitLab, then tell a user to download it, install it, and run it on their
    computer. They can audit our Python web application's source code to make sure
    there is no pesky code trying to steal their private keys. However, if they need
    to audit the source code every time, then we add another commit on our Git repository.
  prefs: []
  type: TYPE_NORMAL
- en: Or better still, we could store our Python web application's source code on
    IPFS. They can download this from IPFS and be sure that our application's source
    code could not be tampered with. They only need to audit the source code once
    before using it.
  prefs: []
  type: TYPE_NORMAL
- en: However, while we could host a static website on IPFS, we could not do the same
    with dynamic web pages such as Python, PHP, Ruby, or Perl web applications. Such
    dynamic websites need a proper web server. Consequently, anyone who downloads
    our Python web application's source code needs to install the right software before
    executing our application. They need to install the Python interpreter, the web
    server (Gunicorn, Apache, or NGINX), and all of the necessary libraries.
  prefs: []
  type: TYPE_NORMAL
- en: However, only desktop users can do that. Mobile users cannot execute our application
    because there are no proper Python interpreters or web servers on the Android
    or iOS platforms.
  prefs: []
  type: TYPE_NORMAL
- en: This is where JavaScript shines. You could create a static website that is dynamic
    so that you can have interactivity in the web pages. You could also create a complex
    JavaScript web application using React.js, Angular.js, Ember.js, or Vue.js and
    deploy it on IPFS. A desktop user and a mobile user could execute the JavaScript
    web application. Because this is a book about Python, we will still look at creating
    a Python web application. However, you should keep the advantages of JavaScript
    compared to Python in mind.
  prefs: []
  type: TYPE_NORMAL
- en: No matter how good JavaScript is, it still cannot save the plight of mobile
    users. Computing power on the mobile platform is still less powerful than computing
    power on the desktop platform. You still cannot run a full Ethereum node on a
    mobile platform in the same way that you cannot run IPFS software on a mobile
    platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s design our web application. This has a few utilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Playing a video
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uploading a video
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Liking a video
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing recent videos from many users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing videos from one specific user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing all videos from a user is moderately easy because we have an unlimited
    size array (which is basically a mapping with integer as key and another integer
    tracker) of videos that we can get based on a user in the smart contract. The
    controller of the page accepts a user (or basically an address in the smart contract)
    as parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Playing a video accepts the video uploader's address and the index of the videos
    as parameters. If the video does not yet exist on our storage, we download it
    from IPFS. Then we serve the video to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading a video requires interacting with an Ethereum node. This method or
    functionality to upload a video accepts an argument of the account's address to
    be used, an argument of a password for the encrypted private key, an argument
    of the video file, and an argument of the video title. We store the video file
    first on IPFS. Then if it succeeds, we can store the information about this video
    on the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Liking a video also requires interacting with an Ethereum node. This method
    or functionality to like a video accepts an argument of the video liker's address
    to be used, an argument of a password for the encrypted private key, an argument
    of the video uploader's address, and an argument of the videos index. After making
    sure that the user has not liked the video previously, we store the information
    on the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Listing recent videos from many users is a bit tricky. The effort involved is
    quite tremendous. In a smart contract, we don't have a variable to track all participating
    users. We also don't have a variable to track all videos from different users.
    However, we can create an event through the method of storing video information
    on the blockchain. After doing so, we can find all recent videos from this event.
  prefs: []
  type: TYPE_NORMAL
- en: Now it's time to build the decentralized video-sharing application.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the video-sharing smart contract
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Without further ado, let''s set up our smart contract development platform:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First things first, we set up our virtual environment as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we install Web3, Populus, and Vyper:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The latest version of Vyper is 0.1.0b6, which breaks Populus. The developer
    needs some time to fix this. If the bug has not been fixed by the time you are
    reading this book, you could patch Populus yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check whether this library has fixed the bug or not using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In our case, the bug has not been fixed.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s patch Populus to fix the bug. Make sure you are still in the same
    directory (`videos-venv/src/populus`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After patching Populus, we will create our smart contract project directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will initialize the directory as a Populus project directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will download the Populus configuration file inside the Populus project
    directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now open the `project.json` configuration file for Populus and override
    the value of the `compilation` key, as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we write our smart contract code in `videos-sharing-smart-contract/contracts/VideosSharing.vy` as
    shown in the following code block (refer to the code file at the following GitLab
    link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/videos_sharing_smart_contract/contracts/VideosSharing.vy](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/videos_sharing_smart_contract/contracts/VideosSharing.vy)):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s discuss our smart contract bit by bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is a struct of video information that we want to keep on the blockchain.
    The `path` of the `Video` struct stores the IPFS path, which has a length of 44\.
    The IPFS path will be a different length if we use another hashing function. Remember
    that IPFS uses multihash when hashing objects. If you use the more expensive hashing
    function, such as SHA512, in your IPFS configuration, then you need to double
    the size of the  `bytes[]` array data type. For example, `bytes[100]` should be
    sufficient. The `title` of the `Video` struct stores the video title. Here, I
    use `bytes[20]` because I want to keep the title short. You could use lengthier
    bytes such as `bytes[100]` if you want to store a lengthier title. However, remember
    that the more bytes you store on the blockchain, the more gas (money!) you have
    to spend. Of course, you could add more information in this struct, such as a
    video description or video tags, as long as you know the consequences, which is
    more gas needed to execute the method to store the video information.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now moving to the list of events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`Transfer` and `Approval` are part of ERC20 standard events. You can read more
    about ERC20 in [Chapter 8](a4f3e7c5-3229-44cf-83d1-62c660fb04f2.xhtml), *Creating
    Token in Ethereum*. The `UploadVideo` event is triggered when we upload video
    information in our smart contract. We save the video uploader''s address and the
    index of videos. The `LikeVideo` event is triggered when we like a video in our
    smart contract.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We save the video liker''s address, the video uploader''s address, and the
    index of videos:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is the integer tracker for our unlimited array. So if `user_videos_index[address
    of user A] = 5`, it means user A has uploaded four videos already.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is part of the ERC20 standard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Refer to [Chapter 8](a4f3e7c5-3229-44cf-83d1-62c660fb04f2.xhtml), *Creating
    Token in Ethereum* for more information about ERC20.
  prefs: []
  type: TYPE_NORMAL
- en: 'We move on to the next line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is the core variable to keep all videos from all users. The `address` data
    type key is used to hold a user's address. The `map(uint256, Video)` data type
    value is our infinite array. The `uint256` key in `map(uint256, Video)` starts
    from 0 and then is tracked by the `user_videos_index` variable. `Video` struct
    is our video information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next two lines of code are used for the likes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `likes_videos` variable is a variable that's used to check whether a certain
    user has liked a particular video or not. The `aggregate_likes` variable is a
    variable used to show how many likes this particular video has got already.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now done with defining variables and will move on to the code shown
    in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This is standard ERC20 code that you can learn about in [Chapter 8](a4f3e7c5-3229-44cf-83d1-62c660fb04f2.xhtml), *Creating
    Token in Ethereum*. However, I made a small adjustment to the code, as shown in
    the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In this smart contract, I extracted the inner code of the `transfer` method
    to the dedicated private method. The reason for this is that the transferring
    coins functionality would be used in the method to like a video. Remember, when
    we like a video, we must pay coins to the video uploader. We cannot call public
    function inside another public function. The rest of the code is the same (other
    than the name of the token):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This is the method used to store video information on the blockchain. We call
    this method after we upload the video to IPFS. `_video_path` is the IPFS path,
    and `_video_title` is the video title. We get the latest index from the video
    uploader (`msg.sender`). Then we set the value of the `Video` struct to `all_videos`
    based on video uploader's address and the latest index.
  prefs: []
  type: TYPE_NORMAL
- en: We then increase the integer tracker (`user_videos_index`). Don't forget to
    log this event.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The methods in the preceding code block are convenient ways to get the latest
    video index, the video IPFS path, and the video title for clients using web3\.
    Without these methods, you could still get the information about the video, but
    accessing a struct variable inside a nested mapping data type variable with web3
    is not straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the method used to like a video. It accepts the video
    uploader''s address and the videos index. Here, you create two keys—one for `likes_videos` and
    the other for `aggregate_likes`. The key for `likes_videos` is a combination of
    the video liker''s address, the video uploader''s address, and the videos index.
    The key for `aggregate_likes` is a combination of the video uploader''s address
    and the video''s index. After creating keys, then we make sure the video liker
    cannot like the same video in the future and the video liker has not liked this
    particular video before. Liking a video merely sets a `True` value to `likes_videos` variable
    with the key that we have created. Then we increase the value of `aggregate_likes` with
    the key that we have created by one. Finally, we transfer one coin of the token
    from the video liker to the video uploader. Don''t forget to log this event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines of code are convenience methods used to check whether a
    video has been liked by a particular user and how many likes this particular video
    has already:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write a test in `videos_sharing_smart_contract/tests/test_video_sharing.py`.
    Refer to the code file at the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/videos_sharing_smart_contract/tests/test_videos_sharing.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/videos_sharing_smart_contract/tests/test_videos_sharing.py).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s discuss the test script in detail, bit by bit. In the following code
    block, after importing necessary libraries, we created three convenient functions—a
    function to upload video, a function to transfer coins, and a function to like
    a video:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As the following code block shows, before uploading a video, we make sure that
    the latest videos index is 0\. Then, after we upload one video, we should check
    the latest video''s index, which should have increased by one. Of course, we check
    the video path and the video title as well. Then we upload one video again and
    check the latest video''s index, which should be 2 by now. We also check the video
    path and the video title. Finally, we check the events and make sure they have
    been created correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the next part of the test script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: First, we transfer some coins from the manager account (the one that launched
    the smart contract) to different accounts, then we upload a video. Before liking
    a video, we should ensure that accounts' token balances are what they should be,
    the testing accounts have not liked this video, and the aggregate likes number
    is still 0.
  prefs: []
  type: TYPE_NORMAL
- en: After doing this, we like a video from a particular account. The balance of
    a token for the video liker should be decreased by one and the balance of a token
    for the video uploader should be increased by one. This means that the smart contract
    has recorded that this account has liked the video and the aggregate likes of
    this video should be increased by 1.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we like a video from another account. The balance of the token for the
    video liker should be decreased by one and the balance of token for the video
    uploader should be increased by one again. The smart contract has recorded that
    this other account has liked this video, at which point the aggregate likes of
    this video should be increased by 1 again, making it 2.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we make sure the events of liking a video are triggered.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we make sure the video liker cannot like the same video more than once.
  prefs: []
  type: TYPE_NORMAL
- en: We will not discuss the testing of ERC20 part of this smart contract. Refer
    to [Chapter 8](a4f3e7c5-3229-44cf-83d1-62c660fb04f2.xhtml), *Creating Token in
    Ethereum,* to learn how to test the ERC20 token smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute the test, run the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Launching a private Ethereum blockchain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s launch our private Ethereum blockchain using geth. We will not use Ganache
    here, because events are not supported in the stable version of Ganache yet (however,
    the beta version of Ganache (v 2.0.0 beta 2) already supports events):'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the following code block to launch the block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now edit `chains/localblock/run_chain.sh`. Find `--ipcpath`, then change the
    value (the word after `--ipcpath`) to `/tmp/geth.ipc`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then edit the `project.json` file. The `chains` object points to four keys:
    `tester`, `temp`, `ropsten`, and `mainnet`. Add another key, `localblock`, in
    the `chains` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the blockchain using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile our smart contract using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, deploy our smart contract to our private blockchain using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Write down the address in which our smart contract is deployed in `address.txt`.
    This file must be adjacent to `videos_sharing_smart_contract` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a bootstrap script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This script is used to load data to make the development of our application
    easier. We can download free videos from [https://videos.pexels.com/](https://videos.pexels.com/).
    Create a `stock_videos` directory adjacent to the `videos_sharing_smart_contract`
    directory and download some MP4 files to that `stock_videos` directory. In my
    case, I downloaded more than 20 videos.
  prefs: []
  type: TYPE_NORMAL
- en: 'After downloading some data, we will create a script called `bootstrap_videos.py`.
    Refer to the code file at the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/bootstrap_videos.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/bootstrap_videos.py):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s discuss the script in detail, bit by bit. In the following code block,
    after importing the necessary libraries, we create an object named `w3`, which
    is a connection object to our private blockchain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following lines of code, we create new accounts with the `w3.personal.newAccount()` method.
    Then we put the new account''s address in the `accounts.txt` file and the `accounts` variable.
    All accounts use `''bitcoin123''` as their password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember: we save our smart contract''s address in the `address.txt` file after
    deploying it on our private blockchain. Now it''s time to load the content of
    the file to the `address` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Then we load the `abi` or the interface of our smart contract that we can get
    from `contracts.json` in the `build` directory of our Populus project directory: `videos_sharing_smart_contract`.
    We load the JSON to the `contract` variable with the `json.load()` method. The
    `abi` is from the `'abi'` key of the `'VideosSharing'` key from the `json` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we initialize the smart contract object with the address and the interface
    with `w3.eth.contract()` method. Then we get the IPFS connection object with the `ipfsapi.connect()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we want to transfer ether to our new accounts. By default, the first
    account (`w3.eth.accounts[0]`) gets all the rewards from the mining, so it has
    plenty of ether to share. The default password is `''this-is-not-a-secure-password''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Sending ether is done via the `w3.personal.sendTransaction()` method, which
    accepts a dictionary containing the sender (`'from'`), destination (`'to'`), amount
    of ether (`'value'`), gas, price of gas (`'gasPrice'`), `nonce` as the first argument,
    and a password as the second argument. Then we wait for the transaction to be
    confirmed with the `wait_for_transaction_receipt()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'After transferring ether, we transfer some ERC20 coins of our token to new
    accounts. This is necessary because, to like a video, we need coins of our ERC20
    token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We build a transaction object, `txn`, for transferring token methods (`VideosSharing.functions.transfer`),
    which accepts the destination account and the amount of coins with the `buildTransaction`
    method. This accepts a dictionary of the sender (`'from'`), gas, the price of
    gas (`'gasPrice'`), and nonce. We create a transaction using the `w3.personal.sendTransaction()`
    method then wait for the transaction to be confirmed with the `wait_for_transaction_receipt()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We list all files from the `stock_videos` directory with the `os.listdir()` method.
    You have downloaded some MP4 files to this directory. After doing this, we iterate
    over these files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We want every account to upload seven videos (`account = accounts [index//7]`).
    Consequently, the first seven videos will be uploaded by the first account, while
    the second batch of seven videos will be uploaded by the second account. Then
    we add the MP4 file to IPFS (`ipfs_add = c.add(directory + '/' + movie)`). We
    get the IPFS path and convert it to a bytes object (`ipfs_path = ipfs_add['Hash'].encode('utf-8')`),
    strip the MP4 filename to 20 characters and convert it to a bytes object because
    the title in the smart contract has a data type of `bytes[20]`.
  prefs: []
  type: TYPE_NORMAL
- en: Then we call the `upload_video` method of our smart contract (`VideosSharing.functions.upload_video`).
    We have to build the transaction object before sending it as argument to the `w3.personal.sendTransaction()`
    method. We wait for the transaction to be confirmed as usual with the `wait_for_transaction_receipt()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: However, you must be careful with the `upload_video` method because it saves
    the video path, which has a `bytes[50]` data type, and video title, which has
    a `bytes[20]` data type on the blockchain. It also increases the video's index
    and logs the event. The gas and gas price needed is much more than the transferring
    coins or token method. To transfer token coins, you can get away with a gas price
    of 1 gwei and 70,000 gas. However, this would fail for our `upload_video` method.
    For this method, I use gas price of 30 gwei and 200,000 gas. Remember, storage
    is expensive in blockchains. Even some strings could raise the gas and gas price
    needed for the operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you have launched your private blockchain, then launch the IPFS `daemon`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Refer to [Chapter 11](e90593ae-aa5a-4c74-b6b9-5793cb32afdd.xhtml), *Using ipfsapi
    to Interact with IPFS*, if you don't know how to install and launch IPFS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to install the IPFS Python library in our virtual environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we run our bootstrap script using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: It will take some time. You could test whether your bootstrap script succeeds
    or not by accessing the smart contract and checking whether the videos have been
    uploaded or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a script named `check_bootstrap.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Run the script. If you get `0` as the output, your bootstrap script failed.
    If you get some output other than `0`, then your video information has been uploaded
    into the blockchain successfully.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Building the video-sharing web application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s time to build the frontend of our smart contract. Previously, in [Chapter
    7](0a33cede-7868-4a41-97ce-50a6c741486e.xhtml), *Frontend Decentralized Application*,
    and [Chapter 9](e0b7a349-cbc8-4733-8fbe-6bd97b303a7d.xhtml), *Cryptocurrency Wallet*,
    we have created a desktop application using Qt for Python or the `Pyside2` library.
    This time we are going to build a web application using the Django library:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Without further ado, let''s install Django:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need the OpenCV Python library to get the thumbnail of our videos:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s create our Django project directory. This will create a skeleton
    Django project with its settings files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside this new directory, create a `static media` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Still in the same directory, create a Django application named `videos`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Then update our Django project settings file. The file is located in `decentralized_videos/settings.py`.
    Add our new application, `videos`, to `INSTALLED_APPS` variable. Make sure there
    is a comma between the `''videos''` and `''django.contrib.staticfiles''` strings.
    We need to add every Django application to this variable in order for the Django
    project to recognize it. A Django project can be composed of many Django applications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the same file, add the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `STATIC_URL` variable defines how we access a static URL. With this value,
    we can access static files with this URL: `http://localhost:8000/static/our_static_file`. The `STATICFILES_DIRS`
    variable refers to where we keep our static files in the filesystem. We simply
    store the videos in the `static` directory inside our Django project directory.
    `MEDIA_URL` has the same purpose as `STATIC_URL`, but for media files. Media files
    are what users upload into the Django project, while static files are what we
    as developers put into the Django project.'
  prefs: []
  type: TYPE_NORMAL
- en: Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s create the view file of the `videos` application. A view is a controller
    that is like an API endpoint. The file is located in `decentralized_videos/videos/views.py`.
    Refer to the code file at the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/decentralized_videos/videos/views.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/decentralized_videos/videos/views.py):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s discuss the code bit by bit. First, we import all the required libraries
    using the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `render` and `redirect` methods are convenience functions from Django library
    that render templates (such as HTML files) and redirect them from a view to another
    view. `videos_sharing` is a custom instance that we will create soon in our `models`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will create the method that will be the view for our homepage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We retrieve recent videos from our model instance. We will build this class
    and its methods. We render the `'videos/index.html'` template, which we will create
    later with a context containing a `videos` object. The `request` parameter is
    the representation of POST parameters and GET parameters, among other things.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we have the following lines of code for the page, which lists all the
    videos from a specific video uploader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This method accepts a `video_user` parameter, which represents the address of
    the video uploader. We get the videos from the `videos_sharing.get_videos` method,
    which accepts the address of the video uploader. Then we render the `'videos/channel.html'`
    template file with a context containing the videos and the address of the video
    uploader.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following method, we have the view for the page on which a video will
    be played:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This method accepts the `video_user` parameter, which represents the address
    of the video uploader, and the `index` parameter, which represents the video's
    index. We get a specific video from the `videos_sharing.get_video` method, which
    accepts the `video_user` and `index` parameters. Following this, we render `'videos/video.html'`
    with a contract containing this video.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we have the view that we call when we upload a video file, its title,
    the address of the video uploader, and the password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: To retrieve the POST parameter, we can use `request.POST` property. However,
    to access the file we are uploading, we use the `request.FILES` property. This
    view is used for the page to upload the file and to process the file itself. We
    store video information to the blockchain with the `videos_sharing.upload_video`
    method. At the end of this method, we render `'videos/upload.html'` with `context`
    containing a success notification if we have uploaded a video successfully.
  prefs: []
  type: TYPE_NORMAL
- en: For educational purposes, I made the uploading code simpler without validating
    it. On top of that, this web application is used by one person. However, if you
    intend to build a web application that serves many strangers, you need to validate
    uploaded files. You should also use the Django form to handle POST parameters
    instead of doing it manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the following method, we have the view to like the video:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: When we want to like a video, we retrieve all the necessary information, such
    as the address of the video liker, the address of the video uploader, the video's
    index, and the password, so we can get the specific video. Then we use the `videos_sharing.like_video`
    method to do the job. After liking a video, we redirect to the `video` view.
  prefs: []
  type: TYPE_NORMAL
- en: Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create our models file in `decentralized_videos/videos/models.py`. Most
    logic and heavy operations happen here. Calling a smart contract''s methods and
    storing files into IPFS also happen here. Refer to the code file at the following
    GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/decentralized_videos/videos/models.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/decentralized_videos/videos/models.py):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s discuss the core functionalities of our Django project bit by bit. First,
    we import convenience methods from the Python standard library, the IPFS Python
    library, OpenCV Python library, the web3 library, the Populus library, and some
    variables from the Django settings file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we start with the initialization code of the `VideosSharing` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: We initialize this instance by creating a web3 connection object, which is `w3`,
    create a smart contract object by providing the address of the smart contract
    and the interface, which is `SmartContract`, and lastly create an IPFS connection
    object, which is `ipfs_con`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we have the method that is used in the `index` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Recent videos can be retrieved from events. If you recall when we uploaded a
    video in our smart contract, you will remember that we logged an event here. Our
    event is `UploadVideo`. Because this Django project is a toy application, we get
    all the events from the starting block. In the real world, you will want to limit
    it (maybe the last 100 blocks). Furthermore, you probably want to store events
    to a database in background jobs (such as cron) for easy retrieval. This event
    object contains the video uploader and the video's index. Based on this information
    we can get the video path, the video title, and the video thumbnail. We accumulate
    videos in the `videos` object, reverse it (because we want to get recent videos),
    and return this object to the caller of the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we have the method to get the videos from a specific video uploader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This is used in the `channel` view. First, we get the latest videos index of
    this video uploader. Based on this information, we can find out how many videos
    the video uploader has uploaded. Then, we retrieve the videos one by one from
    the highest index to the lowest index until the number of videos reaches the number
    we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the methods for getting the video path and the video title based
    on the address of the video uploader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'And the videos index is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: We use the `videos_path` and `videos_title` methods from our smart contract.
    Don't forget to decode the result because the `bytes` object forms our smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is the method that gets the video thumbnail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: When we view a video in the video-playing page, we check whether there is a
    certain filename with a `.png` file extension. We find this filename pattern inside
    the `static files` directory. If we can't find the file, we just use a placeholder
    picture file from the internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is the method to retrieve a specific video:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This is used in the `video` view. We need the video path, the video title, the
    video file, the video thumbnail, and the aggregate likes of this video (which
    we can get with `video_aggregate_likes` method from our smart contract). We check
    whether this MP4 file exists or not in our static files directory. If not, we
    retrieve it from IPFS with the `ipfs_con.get` method. Then we move the file to
    the static files directory and create a thumbnail image if one does not exist
    yet.
  prefs: []
  type: TYPE_NORMAL
- en: In the real world, you will want to retrieve the file from IPFS in a background
    job using Celery and RabbitMQ, for example. For this toy application, we just
    download a video in a blocking fashion. However, installing and configuring Celery
    and RabbitMQ is not for the faint of heart, and I think it will be a distraction
    from our educational purpose here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following method demonstrates what happens when we upload a video:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: We save the file in the media directory from our file in memory, and then add
    the file to IPFS with the `ipfs_con.add` method. We get the IPFS path and prepare
    the title of the video. Then, we call `upload_video` method from our smart contract.
    Remember to set enough gas and gas price for this. This is quite an expensive
    smart contract method. We wait for the transaction to be confirmed. In the real
    world, you'll want to do all of these steps using a background job.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block shows how to generate a thumbnail from a video:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: After ensuring no such file exists, we get the video object. We read the first
    frame of the object and save this to an image file. This video functionality is
    from the OpenCV Python library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we have the method for liking a video:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: We make sure this video has not been liked by calling the `video_has_been_liked`
    method from our smart contract. Then we call the `like_video` method with the
    required parameters from our smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: 'And, finally, we create an instance of the `VideosSharing` class so we can
    import this instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Instead of importing a class, I prefer to import an instance of a class. Consequently,
    we initialize a class instance here.
  prefs: []
  type: TYPE_NORMAL
- en: Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s time to write our templates. First, let''s create a template directory
    using the following command lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create our base layout first using the following lines of HTML. This
    is the layout that will be used by all our templates. The file is located in `videos/templates/videos/base.html`.
    You can refer to the code file at the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/decentralized_videos/videos/templates/videos/base.html](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/decentralized_videos/videos/templates/videos/base.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: In the header, we import the Bulma CSS framework and the Font Awesome JavaScript
    file. In this base layout, we set up our navigation, which holds the home page
    link and the video upload link. The section between `{% block content %}` and
    `{% endblock %}` will be filled by our template's content.
  prefs: []
  type: TYPE_NORMAL
- en: While this book focuses on teaching Python only, avoiding other technologies
    such as CSS and JavaScript as much as possible, some CSS is necessary to make
    our web application look decent. You can go to [https://bulma.io](https://bulma.io)
    to learn about this CSS framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, let''s create our first template file in `videos/templates/videos/index.html`.
    Use the following code block to create the template file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: First things first; we make sure this template extends our base layout. Then
    we display our video in this template. We use the `card` class div to display
    the video. The `cycle` method is used to generate the `columns` class div to contain
    four `column` class divs. The second `cycle` method is used to close this div.
    In the footer of this `card`, we create a link to the page to play this video.
    The `url` method accepts the URL name (which we will discuss soon) and its parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we will create our template file to play the video in `videos/templates/videos/video.html`.
    You can refer to the code file at the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/decentralized_videos/videos/templates/videos/video.html](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/decentralized_videos/videos/templates/videos/video.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: After extending base layout, we create a `breadcrumb` so a user can go to the
    video uploader's channel page. Then we display the video with a `video` HTML tag.
    Below the video, we display the aggregate likes number. At the bottom of the page,
    we create a form to like the video. This accepts the video liker's address and
    the password input by the user. There are hidden inputs to send the video uploader's
    address and the videos index. Note that there is a CSRF token named `{% csrf_token
    %}` inside this form. This is necessary for avoiding CSRF vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then let''s create our template file to list all videos from a specific video
    uploader in `videos/templates/videos/channel.html`. You can refer to the code
    file at the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/decentralized_videos/videos/templates/videos/channel.html](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/decentralized_videos/videos/templates/videos/channel.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: This template file is the same as the index template, except we have a `breadcrumb`
    at the top of the list of videos.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the last template file for uploading videos in `videos/templates/videos/upload.html`.
    You can refer to the code file at the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/decentralized_videos/videos/templates/videos/upload.html](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/decentralized_videos/videos/templates/videos/upload.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: In this template, after extending the base layout, we create the `breadcrumb`.
    Then, we create a form to upload the video.
  prefs: []
  type: TYPE_NORMAL
- en: This has four inputs—the video title, the video file, the video uploader's address,
    and the password. The JavaScript code at the bottom of the template is used to
    set the filename on the label of the file upload field after we have selected
    a file. Because we are uploading a file, we need to have the `enctype` attribute
    of the form set to `"multipart/form-data"`.
  prefs: []
  type: TYPE_NORMAL
- en: Urls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `urls` file is a routing mechanism in Django. Open `decentralized_videos/videos/urls.py`,
    delete the content, and replace it with the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Remember the views file we created previously? Here, we map the views into routing.
    We access the video-playing page by using `http://localhost:8000/video/0x0000000000000000000000000000000000000000/1`.
    The parameters will be mapped into the `video_user` variable and the `index` variable.
    The first parameter of the `path` method is the way we call it in the browser.
    The second method is the view we use, and the third parameter is the name of the
    routing that is used in templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we need to register these `urls` to the project `urls` file. Edit `decentralized_videos/decentralized_videos/urls.py` and
    add our `videos.urls` path so our web application knows how to route our URL to
    our `videos` views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Demo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s time to enjoy the fruits of your labor. Make sure you are inside the `decentralized_videos`
    directory before running the server. Don''t forget to run the private blockchain
    and IPFS daemon first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Then open `http://localhost:8000`. Here, you will be greeted with recent videos,
    as shown in the following screenshot. If you are confused about why I have a thumbnail
    for some videos, you need to go to the video-playing page to generate the thumbnail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8c447427-ed43-4be1-b6a3-524884e054c8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s click on one of the videos:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9a27e163-7202-4317-9acc-857a99952a2b.png)'
  prefs: []
  type: TYPE_IMG
- en: You can play the video here.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play HTML5 video on the web, we can use Chrome browser. You can also use
    Firefox browser, but you need to do additional steps to enable playing video on
    browser, by following the steps on this following website: [https://stackoverflow.com/questions/40760864/how-to-play-mp4-video-in-firefox](https://stackoverflow.com/questions/40760864/how-to-play-mp4-video-in-firefox).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also like the video with the form. Let''s click on the Channel link
    in the breadcrumb:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7bd25a63-5dbb-4734-9ce1-7e0527bfe0bb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the list of videos from a specific video uploader. Finally, let''s
    go to the uploading video page. Click the Upload link in the navigation menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7cbb792f-3b18-4a53-99b1-1128f9a93019.png)'
  prefs: []
  type: TYPE_IMG
- en: You can upload a video here, as shown in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make this application perform better in the real world, there are a lot of
    things that need to be done. You need to add testing, you need to test the model,
    the views, the templates, and, finally, you need to carry out solid integration
    tests. You also need to put heavy and long operations (such as calling operations
    on the smart contract, adding and getting files with IPFS) in the background jobs
    using Celery and RabbitMQ or Redis. In addition to this, you need to add some
    JavaScript files in order to notice whether the background jobs have finished
    or not using a pooling mechanism. You could also use the Django channel to do
    the job.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of accessing methods of the smart contract in the model, perhaps it
    is better to put all information from the blockchain in the database in the background
    task using cron. Then the model can access the database to get necessary information.
    To upload and like a video, we need to send our address and its password every
    time. Perhaps, for convenience, we could offer a way to save the address and the
    password temporarily for the user. We can save this in the session, in cookies,
    or even in a web3 object.
  prefs: []
  type: TYPE_NORMAL
- en: In our toy application, we assume everyone uploads a valid video file. If someone
    uploads an invalid video file, we need to handle that situation. Furthermore,
    if someone uploads an invalid IPFS path of a video, this should also be dealt
    with accordingly. Should we validate on the smart contract (using more gas)? Should
    we validate it in the frontend? There are many corner cases we need to take care
    of. We also need to add pagination. What about searching? We need to crawl the
    events on the blockchain. Should we only care about the video title, or should
    we extract the information from the video file itself? These are the questions
    you need to contemplate if you want to build a decentralized video-sharing application
    in the real world.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we combined IPFS technology and smart contract technology.
    We built a decentralized video-sharing application. First, we wrote a smart contract
    to store video information and the video titles. We also built in the crypto economics
    by making the act of liking videos require coins from the ERC20 token. In addition
    to this, we learned that even storing video information such as a bytes string
    of the IPFS path and the title requires more gas than usual. After writing a smart
    contract, we built a web application using the Django library. We created a project,
    followed by building an application inside this project. Moving forward, we built
    views, models, templates, and URLs. In the models, we stored the video file in
    IPFS and then stored the IPFS path on the blockchain. We made the templates more
    beautiful using the Bulma CSS framework, and then launched the application by
    executing the functionalities of this web application.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we have learned what blockchain is and what a smart contract is.
    We used the Vyper programming language to build many interesting smart contracts,
    such as a voting smart contract, a Twitter-like application smart contract, an
    ERC20 token smart contract, and a video-sharing smart contract. We also utilized
    the web3 library to interact with these smart contracts and built decentralized
    applications. On top of that, we built our GUI frontend for our decentralized
    applications using the PySide2 library and the web frontend for our decentralized
    applications using the Django library. One of the GUI frontend applications is
    a cryptocurrency wallet that can handle ether and ERC20 tokens. Finally, we also
    learned about a complementary decentralized technology, IPFS, that can be the
    storage solution for blockchain applications.
  prefs: []
  type: TYPE_NORMAL
- en: After mastering all of these skills, you are equipped to build many interesting
    applications on top of the Ethereum platform. But Ethereum is still a nascent
    technology. Technologies such as sharding, Proof of Stake, and privacy are still
    being researched and developed in Ethereum. These new technologies may affect
    the technologies that you have learned, such as Vyper and web3\. So you need to
    be aware of new updates on the Ethereum platform.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can learn more about upcoming changes on Ethereum on the following website: 
    [https://github.com/ethereum/eth2.0-specs](https://github.com/ethereum/eth2.0-specs).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
