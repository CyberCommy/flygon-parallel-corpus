- en: Linux System Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter informs the reader about the system architecture of the Linux ecosystem.
    It first conveys the elegant Unix philosophy and design fundamentals, then delves
    into the details of the Linux system architecture. The importance of the ABI,
    CPU privilege levels, and how modern **operating systems** (**OSes**) exploit
    them, along with the Linux system architecture's layering, and how Linux is a
    monolithic architecture, will be covered. The (simplified) flow of a system call
    API, as well as kernel-code execution contexts, are key points.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, the reader will be taken through the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The Unix philosophy in a nutshell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architecture preliminaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux architecture layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux—a monolithic OS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kernel execution contexts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Along the way, we'll use simple examples to make the key philosophical and architectural
    points clear.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A modern desktop PC or laptop is required; Ubuntu Desktop specifies the following
    as recommended system requirements for installation and usage of the distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: 2 GHz dual core processor or better
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RAM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Running on a physical host**: 2 GB or more system memory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Running as a guest**: The host system should have at least 4 GB RAM (the
    more, the better and smoother the experience)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 25 GB of free hard drive space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Either a DVD drive or a USB port for the installer media
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internet access is definitely helpful
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We recommend the reader use one of the following Linux distributions (can be
    installed as a guest OSon a Windows or Linux host system, as mentioned):'
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu 18.04 LTS Desktop (Ubuntu 16.04 LTS Desktop is a good choice too as it
    has long term support as well, and pretty much everything should work)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ubuntu Desktop download link: [https://www.ubuntu.com/download/desktop](https://www.ubuntu.com/download/desktop)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fedora 27 (Workstation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Download link: [https://getfedora.org/en_GB/workstation/download/](https://getfedora.org/en_GB/workstation/download/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that these distributions are, in their default form, OSS and non-proprietary,
    and free to use as an end user.
  prefs: []
  type: TYPE_NORMAL
- en: There are instances where the entire code snippet isn't included in the book
    . Thus the GitHub URL to refer the codes: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux).
  prefs: []
  type: TYPE_NORMAL
- en: Also, for the *Further reading* section, refer to the preceding GitHub link.
  prefs: []
  type: TYPE_NORMAL
- en: Linux and the Unix operating system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Moore's law famously states that the number of transistors in an IC will double
    (approximately) every two years (with an addendum that the cost would halve at
    pretty much the same rate). This law, which remained quite accurate for many years,
    is one of the things that clearly underscored what people came to realize, and
    even celebrate, about the electronics and the **Information Technology** (**IT**)
    industry; the sheer speed with which innovation and paradigm shifts in technology
    occur here is unparalleled. So much so that we now hardly raise an eyebrow when,
    every year, even every few months in some cases, new innovations and technology
    appear, challenge, and ultimately discard the old with little ceremony.
  prefs: []
  type: TYPE_NORMAL
- en: 'Against this backdrop of rapid all-consuming change, there lives an engaging
    anomaly: an OS whose essential design, philosophy, and architecture have changed
    hardly at all in close to five decades. Yes, we are referring to the venerable
    Unix operating system.'
  prefs: []
  type: TYPE_NORMAL
- en: Organically emerging from a doomed project at AT&T's Bell Labs (Multics) in
    around 1969, Unix took the world by storm. Well, for a while at least.
  prefs: []
  type: TYPE_NORMAL
- en: But, you say, this is a book about Linux; why all this information about Unix?
    Simply because, at heart, Linux is the latest avatar of the venerable Unix OS.
    Linux is a Unix-like operating system (among several others). The code, by legal
    necessity, is unique; however, the design, philosophy, and architecture of Linux
    are pretty much identical to those of Unix.
  prefs: []
  type: TYPE_NORMAL
- en: The Unix philosophy in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand anyone (or anything), one must strive to first understand their
    (or its) underlying philosophy; to begin to understand Linux is to begin to understand
    the Unix philosophy. Here, we shall not attempt to delve into every minute detail;
    rather, an overall understanding of the essentials of the Unix philosophy is our
    goal.  Also, when we use the term Unix, we very much also mean Linux!
  prefs: []
  type: TYPE_NORMAL
- en: 'The way that software (particularly, tools) is designed, built, and maintained
    on Unix slowly evolved into what might even be called a pattern that stuck: the
    Unix design philosophy. At its heart, here are the pillars of the Unix philosophy,
    design, and architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: Everything is a process; if it's not a process, it's a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One tool to do one task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three standard I/O channel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combine tools seamlessly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plain text preferred
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CLI, not GUI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modular, designed to be repurposed by others
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide the mechanism, not the policy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's examine these pillars a little more closely, shall we?
  prefs: []
  type: TYPE_NORMAL
- en: Everything is a process – if it's not a process, it's a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A process is an instance of a program in execution. A file is an object on the
    filesystem; beside regular file with plain text or binary content; it could also
    be a directory, a symbolic link, a device-special file, a named pipe, or a (Unix-domain)
    socket.
  prefs: []
  type: TYPE_NORMAL
- en: The Unix design philosophy abstracts peripheral devices (such as the keyboard,
    monitor, mouse, a sensor, and touchscreen) as files – what it calls device files.
    By doing this, Unix allows the application programmer to conveniently ignore the
    details and just treat (peripheral) devices as though they are ordinary disk files.
  prefs: []
  type: TYPE_NORMAL
- en: The kernel provides a layer to handle this very abstraction – it's called the
    **Virtual Filesystem Switch** (**VFS**). So, with this in place, the application
    developer can open a device file and perform I/O (reads and writes) upon it, all
    using the usual API interfaces provided (relax, these APIs will be covered in
    a subsequent chapter).
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, every process inherits three files on creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Standard input** (`stdin`**: fd** **0**): The keyboard device, by default'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Standard output** (`stdout`**: fd 1***)*: The monitor (or terminal) device,
    by default'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Standard error** (`stderr`**: ****fd 2**): The monitor (or terminal) device,
    by default'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**fd** is the common abbreviation, especially in code, for **file descriptor**;
    it''s an integer value that refers to the open file in question.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, note that we mention it''s a certain device by default – this implies
    the defaults can be changed. Indeed, this is a key part of the design: changing
    standard input, output, or error channels is called **redirection**, and by using
    the familiar <, > and 2> shell operators, these file channels are redirected to
    other files or devices.'
  prefs: []
  type: TYPE_NORMAL
- en: On Unix, there exists a class of programs called filters.
  prefs: []
  type: TYPE_NORMAL
- en: A filter is a program that reads from its standard input, possibly modifies
    the input, and writes the filtered result to its standard output.
  prefs: []
  type: TYPE_NORMAL
- en: Filters on Unix are very common utilities, such as `cat`, `wc`, `sort`, `grep`,
    `perl`, `head`, and `tail`.
  prefs: []
  type: TYPE_NORMAL
- en: Filters allow Unix to easily sidestep design and code complexity. How?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take the `sort` filter as a quick example. Okay, we''ll need some data
    to sort. Let''s say we run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now we consider four scenarios of using `sort`; based on the parameter(s) we
    pass, we are actually performing explicit or implicit input-, output-, and/or
    error-redirection!
  prefs: []
  type: TYPE_NORMAL
- en: '**Scenario 1**: Sort a file alphabetically (one parameter, input implicitly
    redirected to file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: All right!
  prefs: []
  type: TYPE_NORMAL
- en: Hang on a second, though. If `sort` is a filter (and it is), it should read
    from its `stdin` (the keyboard) and write to its `stdout` (the terminal). It is
    indeed writing to the terminal device, but it's reading from a file, `fruit.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: This is deliberate; if a parameter is provided, the sort program treats it as
    standard input, as clearly seen.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that `sort fruit.txt ` is identical to `sort < fruit.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scenario 2**: Sort any given input alphabetically (no parameters, input and
    output from and to stdin/stdout):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Once you type `sort` and press the *Enter* key, and the sort process comes alive
    and just waits. Why? It's waiting for you, the user, to type something. Why? Recall,
    every process by default reads its input from standard input or stdin – the keyboard
    device!  So, we type in some fruit names. When we're done, press *Ctrl* + *D*.
    This is the default character sequence that signifies **end-of-file** (**EOF**),
    or in cases such as this, end-of-input. Voila! The input is sorted and written.
    To where? To the `sort` process's stdout – the terminal device, hence we see it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scenario 3**: Sort any given input alphabetically and save the output to
    a file (explicit output redirection):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Similar to Scenario 2, we type in some fruit names and then *Ctrl* + *D* to
    tell sort we're done. This time, though, note that the output is redirected (via
    the `>` meta-character) to the `sorted.fruits.txt` file!
  prefs: []
  type: TYPE_NORMAL
- en: 'So, as expected is the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Scenario 4**: Sort a file alphabetically and save the output and errors to
    a file (explicit input-, output-, and error-redirection):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Interestingly, the end result is the same as in the preceding scenario, with
    the added advantage of redirecting any error output to the error channel. Here,
    we redirect the error output (recall that file descriptor 2 always refers to `stderr`)
    to the `/dev/null` special device file; `/dev/null` is a device file whose job
    is to act as a sink (a black hole). Anything written to the null device just disappears
    forever! (Who said there isn't magic on Unix?)  Also, its complement is `/dev/zero`*; *the
    zero device is a source – an infinite source of zeros. Reading from it returns
    zeroes (the first ASCII character, not numeric 0); it has no end-of-file!
  prefs: []
  type: TYPE_NORMAL
- en: One tool to do one task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the Unix design, one tries to avoid creating a Swiss Army knife; instead,
    one creates a tool for a very specific, designated purpose and for that one purpose
    only. No ifs, no buts; no cruft, no clutter. This is design simplicity at its
    best.
  prefs: []
  type: TYPE_NORMAL
- en: '"Simplicity is the ultimate sophistication."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Leonardo da Vinci'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a common example: when working on the Linux **CLI** (**command-line interface**),
    you would like to figure out which of your locally mounted filesystems has the
    most available (disk) space.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get the list of locally mounted filesystems by an appropriate switch
    (just `df` would do as well):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To sort the output, one would need to first save it to a file; one could use
    a temporary file for this purpose, tmp, and then sort it, using the `sort` utility,
    of course. Finally, we delete the offending temporary file. (Yes, there's a better
    way, piping; refer to the, *Combine tools seamlessly *section)
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the available space is the fourth column, so we sort accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Whoops! The output includes the heading line. Let''s first use the versatile
    `sed` utility – a powerful non-interactive editor tool – to eliminate the first
    line, the header, from the output of `df`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: So what? The point is, on Unix, there is no one utility to list mounted filesystems
    and sort them by available space simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, there is a utility to list mounted filesystems: `df`. It does a great
    job of it, with option switches to choose from. (How does one know which options?
    Learn to use the man pages, they''re extremely useful.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a utility to sort text: `sort`. Again, it''s the last word in sorting
    text, with plenty of option switches to choose from for pretty much every conceivable
    sort one might require.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Linux man pages: **man** is short for **manual**; on a Terminal window,
    type `man man` to get help on using man. Notice the manual is divided into 9 sections.
    For example, to get the manual page on the stat system call, type `man 2 stat`
    as all system calls are in section 2 of the manual. The convention used is cmd
    or API; thus, we refer to it as `stat(2)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As expected, we obtain the results. So what exactly is the point? It''s this:
    we used three utilities*,* not one. `df `, to list the mounted filesystems (and
    their related metadata), `sed`, to eliminate the header line, and `sort`, to sort
    whatever input its given (in any conceivable manner).'
  prefs: []
  type: TYPE_NORMAL
- en: '`df` can query and list mounted filesystems, but it cannot sort them. `sort`
    can sort text; it cannot list mounted filesystems.'
  prefs: []
  type: TYPE_NORMAL
- en: Think about that for a moment.
  prefs: []
  type: TYPE_NORMAL
- en: Combine them all, and you get more than the sum of its parts! Unix tools typically
    do one task and they do it to its logical conclusion; no one does it better!
  prefs: []
  type: TYPE_NORMAL
- en: Having said this, I would like to point out – a tiny bit sheepishly – the highly
    renowned tool Busybox. Busybox (`http://busybox.net`) is billed as The Swiss Army
    Knife of Embedded Linux. It is indeed a very versatile tool; it has its place
    in the embedded Linux ecosystem – precisely because it would be too expensive
    on an embedded box to have separate binary executables for each and every utility
    (and it would consume more RAM). Busybox solves this problem by having a single
    binary executable (along with symbolic links to it from each of its applets, such
    as ls, ps, df, and sort).
  prefs: []
  type: TYPE_NORMAL
- en: So, nevertheless, besides the embedded scenario and all the resource limitations
    it implies, do follow the *One tool to do one task* rule!
  prefs: []
  type: TYPE_NORMAL
- en: Three standard I/O channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Several popular Unix tools (technically, filters) are, again, deliberately designed
    to read their input from a standard file descriptor called **standard input** (**stdin**)
    – possibly modify it, and write their resultant output to a standard file descriptor **standard
    output** (**stdout**). Any error output can be written to a separate error channel
    called **standard error** (**stderr**).
  prefs: []
  type: TYPE_NORMAL
- en: In conjunction with the shell's redirection operators (`>` for output-redirection
    and `<` for input-redirection, `2>` for stderr redirection), and even more importantly
    with piping (refer section, *Combine tools seamlessly*), this enables a program
    designer to highly simplify. There's no need to hardcode (or even softcode, for
    that matter) input and output sources or sinks. It just works, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Let's review a couple of quick examples to illustrate this important point.
  prefs: []
  type: TYPE_NORMAL
- en: Word count
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How many lines of source code are there in the C `netcat.c` source file I downloaded?
    (Here, we use a small part of the popular open source `netcat` utility code base.) We
    use the `wc` utility. Before we go further, what''s wc? **word count** (**wc**)
    is a filter: it reads input from stdin, counts the number of lines, words, and
    characters in the input stream, and writes this result to its stdout. Further,
    as a convenience, one can pass filenames as parameters to it; passing the `-l`
    option switch has wc only print the number of lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, the input is a filename passed as a parameter to `wc`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, we should by now realize that if we do not pass it any parameters,
    `wc` would read its input from stdin, which by default is the keyboard device.
    For example is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Yes, we typed in `4` lines to stdin; thus the result is 4, written to stdout
    – the terminal device by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the beauty of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, wc is a great example of a Unix filter.
  prefs: []
  type: TYPE_NORMAL
- en: cat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unix, and of course Linux, users learn to quickly get familiar with the daily-use `cat`
    utility. At first glance, all cat does is spit out the contents of a file to the
    terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say we have two plain text files, `myfile1.txt` and `myfile2.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay. Now check this out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Instead of needing to run `cat` twice, we ran it just once, by passing the two
    filenames to it as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In theory, one can pass any number of parameters to cat: it will use them all,
    one by one!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Not just that, one can use shell wildcards too (`*` and `?`; in reality, the
    shell will first expand the wildcards, and pass on the resultant path names to
    the program being invoked as parameters):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This, in fact, illustrates another key point: any number of parameters or none
    is considered the right way to design a program. Of course, there are exceptions
    to every rule: some programs demand mandatory parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Wait, there''s more. `cat` too, is an excellent example of a Unix filter (recall:
    a filter is a program that reads from its standard input, modifies its input in
    some manner, and writes the result to its standard output).'
  prefs: []
  type: TYPE_NORMAL
- en: So, quick quiz, if we just run `cat` with no parameters, what would happen?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, let''s try it out and see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Wow, look at that: `cat` blocks (waits) at its stdin, the user types in a string
    and presses the Enter key, `cat` responds by copying its stdin to its stdout –
    no surprise there, as that''s the job of cat in a nutshell!'
  prefs: []
  type: TYPE_NORMAL
- en: 'One realizes the commands shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cat fname` is the same as `cat < fname`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cat > fname` creates or overwrites the `fname` file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There''s no reason we can''t use cat to append several files together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: There's no reason this must be done with only plain text files; one can join
    together binary files too.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, that's what the utility does – it concatenates files. Thus its name;
    as is the norm on Unix, is highly abbreviated – from concatenate to just cat.
    Again, clean and elegant – the Unix way.
  prefs: []
  type: TYPE_NORMAL
- en: cat shunts out file contents to stdout, in order. What if one wants to display
    a file's contents in reverse order (last line first)? Use the Unix `tac` utility – yes,
    that's cat spelled backward!
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, FYI, we saw that cat can be used to efficiently join files. Guess what:
    the `split (1)` utility can be used to break a file up into pieces.'
  prefs: []
  type: TYPE_NORMAL
- en: Combine tools seamlessly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We just saw that common Unix utilities are often designed as filters, giving
    them the ability to read from their standard input and write to their standard
    output. This concept is elegantly extended to seamlessly combine together multiple
    utilities, using an IPC mechanism called a **pipe**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we recall that the Unix philosophy embraces the do one task only design.
    What if we have one program that does task A and another that does task B and
    we want to combine them? Ah, that''s exactly what pipes do! Refer to the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`prg_does_taskA | prg_does_taskB`'
  prefs: []
  type: TYPE_NORMAL
- en: 'A pipe essentially is redirection performed twice: the output of the left-hand
    program becomes the input to the right-hand program. Of course, this implies that
    the program on the left must write to stdout, and the program on the read must
    read from stdin.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example: sort the list of mounted filesystems by space available (in reverse
    order).'
  prefs: []
  type: TYPE_NORMAL
- en: As we have already discussed this example in the *One tool to do one task* section,
    we shall not repeat the same information.
  prefs: []
  type: TYPE_NORMAL
- en: '**Option 1**: Perform the following code using a temporary file (refer section,
    *One tool to do one task*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**Option 2** : Using pipes—clean and elegant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Not only is this elegant, it is also far superior performance-wise, as writing
    to memory (the pipe is a memory object) is much faster than writing to disk.
  prefs: []
  type: TYPE_NORMAL
- en: One can extend this notion and combine multiple tools over multiple pipes; in
    effect, one can build a super tool from several regular tools by combining them.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example: display the three processes taking the most (physical) memory;
    only display their PID, **virtual size** (**VSZ**), **resident set size **(**RSS**)
    (RSS is a fairly accurate measure of physical memory usage), and the name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've combined five utilities, `ps`*,* `sed`,  `awk`*,* `sort`, and `tail`, over
    four pipes. Nice!
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example: display the process, not including daemons*, taking up the
    most memory (RSS):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: A daemon is a system background process; we'll cover this concept in *Daemon
    Process* here: [https://www.packtpub.com/sites/default/files/downloads/Daemon_Processes.pdf](https://www.packtpub.com/sites/default/files/downloads/Daemon_Processes.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: Plain text preferred
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unix programs are generally designed to work with text as it''s a universal
    interface. Of course, there are several utilities that do indeed operate on binary
    objects (such as object and executable files); we aren''t referring to them here.
    The point is this: Unix programs are designed to work on text as it simplifies
    the design and architecture of the program.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A common example: an application, on startup, parses a configuration file.
    The configuration file could be formatted as a binary blob. On the other hand,
    having it as a plain text file renders it easily readable (invaluable!) and therefore
    easier to understand and maintain. One might argue that parsing binary would be
    faster. Perhaps to some extent this is so, but consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: With modern hardware, the difference is probably not significant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A standardized plain text format (such as XML) would have optimized code to
    parse it, yielding both benefits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember, simplicity is key!
  prefs: []
  type: TYPE_NORMAL
- en: CLI, not GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Unix OS, and all its applications, utilities, and tools, were always built
    to be used from a **command-line-interface** (**CLI**), typically, the shell.
    From the 1980s onward, the need for a **Graphical User Interface** (**GUI**) became
    apparent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Robert Scheifler of MIT, considered the chief design architect behind the X
    Window System, built an exceedingly clean and elegant architecture, a key component
    of which is this: the GUI forms a layer (well, actually, several layers) above
    the OS, providing libraries for GUI clients, that is, applications.'
  prefs: []
  type: TYPE_NORMAL
- en: The GUI was never designed to be intrinsic to applications or the OS—it's always
    optional.
  prefs: []
  type: TYPE_NORMAL
- en: This architecture still holds up today. Having said that, especially on embedded
    Linux, performance reasons are seeing the advent of newer architectures, such
    as the frame buffer and Wayland. Also, though Android, which uses the Linux kernel,
    necessitates a GUI for the end user, the system developer's interface to Android,
    ADB, is a CLI.
  prefs: []
  type: TYPE_NORMAL
- en: A huge number of production-embedded and server Linux systems run purely on
    CLI interfaces. The GUI is almost like an add-on feature, for the end user's ease
    of operation.
  prefs: []
  type: TYPE_NORMAL
- en: Wherever appropriate, design your tools to work in the CLI environment; adapting
    it into a GUI at a later point is then straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Cleanly and carefully separating the business logic of the project or product
    from its GUI is a key to good design.
  prefs: []
  type: TYPE_NORMAL
- en: Modular, designed to be repurposed by others
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From its very early days, the Unix OS was deliberately designed and coded with
    the tacit assumption that multiple programmers would work on the system. Thus,
    the culture of writing clean, elegant, and understandable code, to be read and
    worked upon by other competent programmers, was ingrained.
  prefs: []
  type: TYPE_NORMAL
- en: Later, with the advent of the Unix wars, proprietary and legal concerns overrode
    this sharing model. Interestingly, history shows that the Unix's were fading in
    relevance and industry use, until the timely advent of none other than the Linux
    OS – an open source ecosystem at its very best! Today, the Linux OS is widely
    acknowledged as the most successful GNU project. Ironic indeed!
  prefs: []
  type: TYPE_NORMAL
- en: Provide mechanisms, not policies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's understand this principle with a simple example.
  prefs: []
  type: TYPE_NORMAL
- en: 'When designing an application, you need to have the user enter a login `name`
    and `password`. The function that performs the work of getting and checking the
    password is called, let''s say, `mygetpass()`. It''s invoked by the `mylogin()` function:
    `mylogin() → mygetpass()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the protocol to be followed is this: if the user gets the password wrong
    three times in a row, the program should not allow access (and should log the
    case). Fine, but where do we check this?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Unix philosophy: do not implement the logic, if the password is specified
    wrongly three times, abort in the `mygetpass()` function. Instead, just have `mygetpass()`
    return a Boolean (true when the password is right, false when the password is
    wrong), and have the `mylogin()` calling function implement whatever logic is
    required.'
  prefs: []
  type: TYPE_NORMAL
- en: Pseudocode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is the wrong approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s take a look at the right approach: the Unix way! Refer to the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The job of `mygetpass()` is to get a password from the user and check whether
    it's correct; it returns success or failure to the caller – that's it. That's
    the mechanism. It is not its job to decide what to do if the password is wrong
    – that's the policy, and left to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've covered the Unix philosophy in a nutshell, what are the important
    takeaways for you, the system developer on Linux?
  prefs: []
  type: TYPE_NORMAL
- en: 'Learning from, and following, the Unix philosophy when designing and implementing
    your applications on the Linux OS will provide a huge payoff. Your application
    will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Be a natural fit on the system; this is very important
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have greatly reduced complexity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have a modular design that is clean and elegant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be far more maintainable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux system architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to clearly understand the Linux system architecture, one needs to
    first understand a few important concepts: the processor **Application Binary
    Interface** (**ABI**), CPU privilege levels, and how these affect the code we
    write. Accordingly, and with a few code examples, we''ll delve into these here,
    before diving into the details of the system architecture itself.'
  prefs: []
  type: TYPE_NORMAL
- en: Preliminaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If one is posed the question, "what is the CPU for?", the answer is pretty
    obvious: the CPU is the heart of the machine – it reads in, decodes, and executes
    machine instructions, working on memory and peripherals. It does this by incorporating
    various stages.'
  prefs: []
  type: TYPE_NORMAL
- en: Very simplistically, in the Instruction Fetch stage, it reads in machine instructions
    (which we represent in various human-readable ways – in hexadecimal, assembly,
    and high-level languages) from memory (RAM) or CPU cache. Then, in the Instruction
    Decode phase, it proceeds to decipher the instruction. Along the way, it makes
    use of the control unit, its register set, ALU, and memory/peripheral interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: The ABI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's imagine that we write a C program, and run it on the machine.
  prefs: []
  type: TYPE_NORMAL
- en: Well, hang on a second. C code cannot possibly be directly deciphered by the
    CPU; it must be converted into machine language. So, we understand that on modern
    systems we will have a toolchain installed – this includes the compiler, linker,
    library objects, and various other tools. We compile and link the C source code,
    converting it into an executable format that can be run on the system.
  prefs: []
  type: TYPE_NORMAL
- en: The processor **Instruction Set Architecture** (**ISA**) – documents the machine's
    instruction formats, the addressing schemes it supports, and its register model.
    In fact, CPU **Original Equipment Manufacturers** (**OEMs**) release a document
    that describes how the machine works; this document is generally called the ABI. The
    ABI describes more than just the ISA; it describes the machine instruction formats,
    the register set details, the calling convention, the linking semantics, and the
    executable file format, such as ELF. Try out a quick Google for x86 ABI – it should
    reveal interesting results.
  prefs: []
  type: TYPE_NORMAL
- en: The publisher makes the full source code for this book available on their website;
    we urge the reader to perform a quick Git clone on the following URL. Build and
    try it: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try this out. First, we write a simple `Hello, World` type of C program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We build the application via the `Makefile`, with `make`. Ideally, the code must compile
    with no warnings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Important! Do not ignore compiler warnings with production code. Strive to get
    rid of all warnings, even the seemingly trivial ones; this will help a great deal
    with correctness, stability, and security.
  prefs: []
  type: TYPE_NORMAL
- en: In this trivial example code, we understand and anticipate the unused variable warning
    that `gcc` emits, and just ignore it for the purpose of this demo.
  prefs: []
  type: TYPE_NORMAL
- en: The exact warning and/or error messages you see on your system could differ
    from what you see here. This is because my Linux distribution (and version), compiler/linker,
    library versions, and perhaps even CPU, may differ from yours. I built this on
    a x86_64 box running the Fedora 27/28 Linux distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we build the debug version of the `hello` program (again, ignoring
    the warning for now), and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We use the powerful **`objdump`** utility to see the intermixed source-assembly-machine
    language of our program (`objdump's --source option switch`
  prefs: []
  type: TYPE_NORMAL
- en: '` -S, --source Intermix source code with disassembly`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The exact assembly and machine code you see on your system will, in all likelihood,
    differ from what you see here; this is because my Linux distribution (and version),
    compiler/linker, library versions, and perhaps even CPU, may differ from yours.
    I built this on a x86_64 box running Fedora Core 27.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alright. Let''s take the line of source code `a = 5;` where, `objdump` reveals
    the corresponding machine and assembly language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now clearly see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **C source** | **Assembly language** | **Machine instructions** |'
  prefs: []
  type: TYPE_TB
- en: '| **`a = 5;`** | **`movl $0x5,-0x4(%rbp)`** | `c7 45 fc 05 00 00 00` |'
  prefs: []
  type: TYPE_TB
- en: So, when the process runs, at some point it will fetch and execute the machine
    instructions, producing the desired result. Indeed, that's exactly what a programmable
    computer is designed to do!
  prefs: []
  type: TYPE_NORMAL
- en: Though we have shown examples of displaying (and even writing a bit of) assembly
    and machine code for the Intel CPU, the concepts and principles behind this discussion
    hold up for other CPU architectures, such as ARM, PPC, and MIPS. Covering similar
    examples for all these CPUs goes beyond the scope of this book; however, we urge
    the interested reader to study the processor datasheet and ABI, and try it out.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing a register's content via inline assembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve written a simple C program and seen its assembly and machine
    code, let''s move on to something a little more challenging: a C program with
    inline assembly to access the contents of a CPU register.'
  prefs: []
  type: TYPE_NORMAL
- en: Details on assembly-language programming are outside the scope of this book;
    refer to the *Further reading* section on the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'x86_64 has several registers; let''s just go with the ordinary RCX register
    for this example. We do make use of an interesting trick: the x86 ABI calling
    convention states that the return value of a function will be the value placed
    in the accumulator, that is, RAX for the x86_64\. Using this knowledge, we write
    a function that uses inline assembly to place the content of the register we want
    into RAX. This ensures that this is what it will return to the caller!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assembly micro-basics includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`at&t syntax:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`       movq <src_reg>, <dest_reg>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Register        : prefix name with %`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Immediate value : prefix with $`'
  prefs: []
  type: TYPE_NORMAL
- en: For more, see the *Further reading* section on the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: There; it works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing a control register's content via inline assembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Among the many fascinating registers on the x86_64 processor, there happen to
    be six control registers, named CR0 through CR4, and CR8\. There's really no need
    to delve into detail regarding them; suffice it to say that they are crucial to
    system control.
  prefs: []
  type: TYPE_NORMAL
- en: For the purpose of an illustrative example, let's consider the CR0 register
    for a moment. Intel's manual states: CR0—contains system control flags that control
    operating mode and states of the processor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Intel''s manuals can be downloaded conveniently as PDF documents from here
    (includes the Intel® 64 and IA-32 Architectures Software Developer''s Manual,
    Volume 3 (3A, 3B and 3C): System Programming Guide):'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://software.intel.com/en-us/articles/intel-sdm](https://software.intel.com/en-us/articles/intel-sdm)'
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, CR0 is an important register!
  prefs: []
  type: TYPE_NORMAL
- en: 'We modify our previous program to access and display its content (instead of
    the ordinary `RCX` register). The only relevant code (which has changed from the
    previous program) is the function that queries the `CR0` register value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Build and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: It crashes!
  prefs: []
  type: TYPE_NORMAL
- en: Well, what happened here? Read on.
  prefs: []
  type: TYPE_NORMAL
- en: CPU privilege levels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned earlier in this chapter, the essential job of the CPU is to read
    in machine instructions from memory, decipher, and execute them. In the early
    days of computing, this is pretty much all the processor did. But then, engineers,
    thinking deeper on it, realized that there is a critical issue with this: if a
    programmer can feed an arbitrary stream of machine instructions to the processor,
    which it, in turn, blindly and obediently executes, herein lies scope to do damage,
    to hack the machine!'
  prefs: []
  type: TYPE_NORMAL
- en: 'How? Recall from the previous section the Intel processor''s CR0 control register: Contains
    system control flags that control operating mode and states of the processor. If
    one has unlimited (read/write) access to the CR0 register, one could toggle bits
    that could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Turn hardware paging on or off
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disable the CPU cache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change caching and alignment attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disable WP (write protect) on memory (technically, pages) marked as read-only
    by the OS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wow, a hacker could indeed wreak havoc. At the very least, only the OS should
    be allowed this kind of access.
  prefs: []
  type: TYPE_NORMAL
- en: Precisely for reasons such as the security, robustness, and correctness of the
    OS and the hardware resources it controls, all modern CPUs include the notion
    of privilege levels.
  prefs: []
  type: TYPE_NORMAL
- en: 'The modern CPU will support at least two privilege levels, or modes, which
    are generically called the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Supervisor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You need to understand that code, that is, machine instructions, runs on the
    CPU at a given privilege level or mode. A person designing and implementing an
    OS is free to exploit the processor privilege levels. This is exactly how modern
    OSes are designed. Take a look at the following table Generic CPU Privilege Levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Privilege level or mode name** | **Privilege level** | **Purpose** | **Terminology**
    |'
  prefs: []
  type: TYPE_TB
- en: '| Supervisor | High | OS code runs here | kernel-space |'
  prefs: []
  type: TYPE_TB
- en: '| User | Low | Application code runs here | user-space (or userland) |'
  prefs: []
  type: TYPE_TB
- en: Table 1: Generic CPU Privilege Levels
  prefs: []
  type: TYPE_NORMAL
- en: Privilege levels or rings on the x86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To understand this important concept better, let''s take the popular x86 architecture
    as a real example. Right from the i386 onward, the Intel processor supports four
    privilege levels or rings: Ring 0, Ring 1, Ring 2, and Ring 3\. On the Intel CPU''s,
    this is how the levels work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2294bba-9ac8-444b-9ed8-18f3223ddc66.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1: CPU ring levels and privilege'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s visualize this *Figure 1* in the form of a *Table 2: x86 privilege or
    ring levels*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Privilege or ring level** | **Privilege** | **Purpose** |'
  prefs: []
  type: TYPE_TB
- en: '| Ring 0 | Highest | OS code runs here |'
  prefs: []
  type: TYPE_TB
- en: '| Ring 1 | < ring 0 | <Unused> |'
  prefs: []
  type: TYPE_TB
- en: '| Ring 2 | < ring 1 | <Unused> |'
  prefs: []
  type: TYPE_TB
- en: '| Ring 3 | Lowest | Application code runs here (userland) |'
  prefs: []
  type: TYPE_TB
- en: Table 2: x86 privilege or ring levels
  prefs: []
  type: TYPE_NORMAL
- en: Originally, ring levels 1 and 2 were intended for device drivers, but modern
    OSes typically run driver code at ring 0 itself. Some hypervisors (VirtualBox
    being one) used to use Ring 1 to run the guest kernel code; this was the case
    earlier when no hardware virtualization support was available (Intel VT-x, AMD
    SV).
  prefs: []
  type: TYPE_NORMAL
- en: The ARM (32-bit) processor has seven modes of execution; of these, six are privileged,
    and only one is the non-privileged mode. On ARM, generically, the equivalent to
    Intel's Ring 0 is Supervisor (SVC) mode, and the equivalent to Intel's Ring 3 is User
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: For interested readers, there are more links in the *Further reading *section
    on the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram clearly shows of all modern OSes (Linux, Unix, Windows,
    and macOS) running on an x86 processor exploit processor-privilege levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb4667c1-4b63-41c1-bc9b-6f2649caf32a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2: User-Kernel separation'
  prefs: []
  type: TYPE_NORMAL
- en: Importantly, the processor ISA assigns every machine instruction with a privilege
    level or levels at which they are allowed to be executed. A machine instruction
    that is allowed to execute at the user privilege level automatically implies it
    can also be executed at the Supervisor privilege level. This distinguishing between
    what can and cannot be done at what mode also applies to register access.
  prefs: []
  type: TYPE_NORMAL
- en: To use the Intel terminology, the **Current Privilege Level** (**CPL**) is the
    privilege level at which the processor is currently executing code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, that on a given processor shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The foo1 machine instruction has an allowed privilege level of Supervisor (or
    Ring 0 for x86)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The foo2 machine instruction has an allowed privilege level of User (or Ring
    3 for x86)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, for a running application that executes these machine instructions, the
    following table emerges:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Machine instruction** | **Allowed-at mode** | **CPL (current privilege
    level)** | **Works?** |'
  prefs: []
  type: TYPE_TB
- en: '| foo1 | Supervisor (0) | 0 | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | No |'
  prefs: []
  type: TYPE_TB
- en: '| foo2 | User (3) | 0 | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Yes |'
  prefs: []
  type: TYPE_TB
- en: 'Table 3: Privilege levels – an example'
  prefs: []
  type: TYPE_NORMAL
- en: So, thinking about it, foo2 being allowed at User mode would also be allowed
    to execute with any CPL. In other words, if the CPL <= allowed privilege level,
    it works, otherwise it does not.
  prefs: []
  type: TYPE_NORMAL
- en: 'When one runs an application on, say, Linux, the application runs as a process
    (more on this later). But what privilege (or mode or ring) level does the application
    code run at? Refer to the preceding table: User Mode (Ring 3 on x86).'
  prefs: []
  type: TYPE_NORMAL
- en: Aha! So now we see. The preceding code example, `getreg_rcx.c`, worked because
    it attempted to access the content of the general-purpose `RCX` register, which
    is allowed in User Mode (Ring 3, as well as at the other levels, of course)!
  prefs: []
  type: TYPE_NORMAL
- en: But the code of `getreg_cr0.c` failed; it crashed, because it attempted to access
    the content of the `CR0` control register, which is disallowed in User Mode (Ring
    3), and allowed only at the Ring 0 privilege! Only OS or kernel code can access
    the control registers. This holds true for several other sensitive assembly-language
    instructions as well. This approach makes a lot of sense.
  prefs: []
  type: TYPE_NORMAL
- en: Technically, it crashed because the processor raised a **General Protection
    Fault** (**GPF**).
  prefs: []
  type: TYPE_NORMAL
- en: Linux architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Linux system architecture is a layered one. In a very simplistic way, but
    ideal to start on our path to understanding these details, the following diagram
    illustrates the Linux system architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/96584a09-5291-4921-9468-fcf30591d495.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3: Linux – Simplified layered architecture'
  prefs: []
  type: TYPE_NORMAL
- en: 'Layers help, because each layer need only be concerned with the layer directly
    above and below it. This leads to many advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Clean design, reduces complexity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standardization, interoperability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to swap layers in and out of the stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to easily introduce new layers as required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the last point, there exists the FTSE. To quote directly from Wikipedia:'
  prefs: []
  type: TYPE_NORMAL
- en: The "**fundamental theorem of software engineering** (**FTSE**)" is a term originated
    by Andrew Koenig to describe a remark by Butler Lampson attributed to the late
    David J. Wheeler
  prefs: []
  type: TYPE_NORMAL
- en: We can solve any problem by introducing an extra level of indirection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we understand the concept of CPU modes or privilege levels, and how
    modern OSes exploit them, a better diagram (expanding on the previous one) of
    the Linux system architecture would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1d28e82-acf9-4791-ad82-ae2e2f135916.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4: Linux system architecture
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, P1, P2, …, Pn are nothing but userland processes (Process
    1, Process 2) or in other words, running applications. For example, on a Linux
    laptop, we might have the vim editor, a web browser, and terminal windows (gnome-terminal)
    running.
  prefs: []
  type: TYPE_NORMAL
- en: Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Libraries, of course, are archives (collections) of code; as we well know, using
    libraries helps tremendously with code modularity, standardization, preventing
    the reinvent-the-wheel syndrome, and so on. A Linux desktop system might have
    libraries numbering in the hundreds, and possibly even a few thousand!
  prefs: []
  type: TYPE_NORMAL
- en: 'The classic K&R `hello, world` C program uses the `printf` API to write the
    string to the display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, the code of `printf` is not part of the `hello, world` source. So
    where does it come from? It's part of the standard C library; on Linux, due to
    its GNU origins, this library is commonly called **GNU libc** (**glibc**).
  prefs: []
  type: TYPE_NORMAL
- en: Glibc is a critical and required component on a Linux box. It not only contains
    the usual standard C library routines (APIs), it is, in fact, the programming
    interface to the operating system! How? Via its lower layer, the system calls.
  prefs: []
  type: TYPE_NORMAL
- en: System calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: System calls are actually kernel functionality  that can be invoked from userspace
    via glibc stub routines. They serve a critical function; they connect userspace
    to kernel-space. If a user program wants to request something of the kernel (read
    from a file, write to the network, change a file's permissions), it does so by
    issuing a system call. Therefore, system calls are the only legal entry point
    to the kernel. There is no other way for a user-space process to invoke the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a list of all the available Linux system calls, see section 2 of the man
    pages ([https://linux.die.net/man/2/](https://linux.die.net/man/2/)). One can
    also do: man 2 syscalls to see the man page on all supported system calls'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to think of this: the Linux kernel internally has literally thousands
    of APIs (or functions). Of these, only a small fraction are made visible or available,
    that is, exposed, to userspace; these exposed kernel APIs are system calls! Again,
    as an approximation, modern Linux glibc has around 300 system calls.'
  prefs: []
  type: TYPE_NORMAL
- en: On an x86_64 Fedora 27 box running the 4.13.16-302.fc27.x86_64 kernel, there
    are close to 53,000 kernel APIs!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the key thing to understand: system calls are very different from all
    other (typically library) APIs. As they ultimately invoke kernel (OS) code, they
    have the ability to cross the user-kernel boundary; in effect, they have the ability
    to switch from normal unprivileged User mode to completely privileged Supervisor
    or kernel mode!'
  prefs: []
  type: TYPE_NORMAL
- en: How? Without delving into the gory details, system calls essentially work by
    invoking special machine instructions that have the built-in ability to switch
    the processor mode from User to Supervisor. All modern CPU ABIs will provide at
    least one such machine instruction; on the x86 processor, the traditional way
    to implement system calls is to use the special int 0x80 machine instruction.
    Yes, it is indeed a software interrupt (or trap). From Pentium Pro and Linux 2.6
    onward, the sysenter/syscall machine instructions are used. See the *Further reading*
    section on the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the viewpoint of the application developer, a key point regarding system
    calls is that system calls appear to be regular functions (APIs) that can be invoked
    by the developer; this design is deliberate. The reality: the system call APIs
    that one invokes – such as `open()`, `read()`, `chmod()`, `dup()`, and `write()`
    – are merely stubs. They are a neat mechanism to get at the actual code that is
    in the kernel (getting there involves populating a register the accumulator on
    x86 – with the system call number, and passing parameters via other general-purpose
    registers) to execute that kernel code path, and return back to user mode when
    done. Refer to the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| CPU | Machine instruction(s) used to trap to Supervisor (kernel) Mode from
    User Mode | Allocated Register for system call number |'
  prefs: []
  type: TYPE_TB
- en: '| `x86[_64]` | `int 0x80 or syscall` | `EAX / RAX` |'
  prefs: []
  type: TYPE_TB
- en: '| `ARM` | `swi / svc` | R0 to R7 |'
  prefs: []
  type: TYPE_TB
- en: '| `Aarch64` | `svc` | `X8` |'
  prefs: []
  type: TYPE_TB
- en: '| `MIPS` | `syscall` | `$v0` |'
  prefs: []
  type: TYPE_TB
- en: Table 4:  System calls on various CPU Architectures for better understanding
  prefs: []
  type: TYPE_NORMAL
- en: Linux – a monolithic OS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Operating systems are generally considered to adhere to one of two major architectural
    styles: monolithic or microkernel.'
  prefs: []
  type: TYPE_NORMAL
- en: Linux is decidedly a monolithic OS.
  prefs: []
  type: TYPE_NORMAL
- en: What does that mean?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The English word monolith literally means a large single upright block of stone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6cbdd14a-b484-42d8-af5f-909fa6fdb60a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5: Corinthian columns – they''re monolithic!'
  prefs: []
  type: TYPE_NORMAL
- en: On the Linux OS, applications run as independent entities called **processes**.
    A process may be single-threaded (original Unix) or multithreaded. Regardless,
    for now, we will consider the process as the unit of execution on Linux; a process
    is defined as an instance of a program in execution.
  prefs: []
  type: TYPE_NORMAL
- en: When a user-space process issues a library call, the library API, in turn, may
    or may not issue a system call. For example, issuing the `atoi(3)` API does not
    cause glibc to issue a system call as it does not require kernel support to implement
    the conversion of a string into an integer. `<api-name>(n)` *;* n is the man page
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help clarify these important concepts, let''s check out the famous and classic
    K&R `Hello, World` C program again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Okay, that should work. Indeed it does.
  prefs: []
  type: TYPE_NORMAL
- en: But, the question is, how exactly does the `printf(3)` API write to the monitor
    device?
  prefs: []
  type: TYPE_NORMAL
- en: 'The short answer: it does not.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The reality is that `printf(3)` only has the intelligence to format a string
    as specified; that''s it. Once done, `printf` actually invokes the `write(2)`
    API – a system call. The write system call does have the ability to write the
    buffer content to a special device file – the monitor device, seen by write as
    stdout. Go back to our discussion regarding *The Unix philosophy in a nutshell*
    : if it''s not a process, it''s a file! Of course, it gets really complex under
    the hood in the kernel; to cut a long story short, the kernel code of write ultimately
    switches to the correct driver code; the device driver is the only component that
    can directly work with peripheral hardware. It performs the actual write to the
    monitor, and return values propagate all the way back to the application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, **P** is the `hello, world` process at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e279435-c3f2-42d6-872b-5bfc9e75783a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig 6: Code flow: printf-to-kernel'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, from the diagram, we can see that glibc is considered to consist of two
    parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arch-independent glibc**: The regular libc APIs (such as [s|sn|v]printf,
    memcpy, memcmp, atoi)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Arch-dependent glibc**: The system call stubs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, by arch, we mean CPU.
  prefs: []
  type: TYPE_NORMAL
- en: Also the ellipses (...) represent additional logic and processing within kernel-space
    that we do not show or delve into here.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the code flow path of `hello, world` is clearer, let's get back to
    the monolithic stuff!
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s easy to assume that it works this way:'
  prefs: []
  type: TYPE_NORMAL
- en: The `hello, world` app (process) issues the `printf(3)` library call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`printf` issues the `write(2)` system call.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We switch from User to Supervisor (kernel) Mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The kernel takes over – it writes `hello, world` onto the monitor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch back to non-privileged User Mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Actually, that's NOT the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reality is, in the monolithic design, there is no kernel; to word it another
    way, the kernel is actually part of the process itself. It works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `hello, world` app (process) issues the `printf(3)` library call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: printf issues the `write(2)` system call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The process invoking the system call now switches from User to Supervisor (kernel)
    Mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The process runs the underlying kernel code, the underlying device driver code,
    and thus, writes `hello, world` onto the monitor!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The process is then switched back to non-privileged User Mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To summarize, in a monolithic kernel, when a process (or thread) issues a system
    call, it switches to privileged Supervisor or kernel mode and runs the kernel
    code of the system call (working on kernel data). When done, it switches back
    to unprivileged User mode and continues executing userspace code (working on user
    data).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is very important to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1a9482d-6e8f-43db-89cc-b6f42feec640.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig 7: Life of a process in terms of privilege modes'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding diagram attempts to illustrate that the X axis is the timeline,
    and the Y axis represents User Mode (at the top) and Supervisor (kernel) Mode
    (at the bottom):'
  prefs: []
  type: TYPE_NORMAL
- en: '**time t[0]**: A process is born in kernel mode (the code to create a process
    is within the kernel of course). Once fully born, it is switched to User (non-privileged)
    Mode and it runs its userspace code (working on its userspace data items as well).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**time t[1]**: The process, directly or indirectly (perhaps via a library API),
    invokes a system call. It now traps into kernel mode (refer the table *System
    Calls on CPU Architectures* shows the machine instructions depending on the CPU
    to do so) and executes kernel code in privileged Supervisor Mode (working on kernel
    data items as well).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**time t[2]**: The system call is done; the process switches back to non-privileged
    User Mode and continues to execute its userspace code. This process continues,
    until some point in the future.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**time t[n]**: The process dies, either deliberately by invoking the exit API,
    or it is killed by a signal. It now switches back to Supervisor Mode (as the exit(3)
    library API invokes the _exit(2) system call), executes the kernel code of _exit(), and
    terminates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In fact, most modern operating systems are monolithic (especially the Unix-like
    ones).
  prefs: []
  type: TYPE_NORMAL
- en: Technically, Linux is not considered 100 percent monolithic. It's considered
    to be mostly monolithic, but also modular, due to the fact that the Linux kernel
    supports modularization (the plugging in and out of kernel code and data, via
    a technology called **Loadable Kernel Modules** (**LKMs**)).
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, MS Windows (specifically, from the NT kernel onward) follows
    a hybrid architecture that is both monolithic and microkernel.
  prefs: []
  type: TYPE_NORMAL
- en: Execution contexts within the kernel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kernel code always executes in one of two contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: Process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interrupt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's easy to get confused here. Remember, this discussion applies to the context
    in which kernel code executes, not userspace code.
  prefs: []
  type: TYPE_NORMAL
- en: Process context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we understand that one can invoke kernel services by issuing a system call.
    When this occurs, the calling process runs the kernel code of the system call
    in kernel mode. This is termed **process context** – kernel code is now running
    in the context of the process that invoked the system call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Process context code has the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: Always triggered by a process (or thread) issuing a system call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Top-down approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronous execution of kernel code by a process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interrupt context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At first glance, there appears to be no other way that kernel code executes.
    Well, think about this scenario: the network receive path. A network packet destined
    for your Ethernet MAC address arrives at the hardware adapter, the hardware detects
    that it''s meant for it, collects it, and buffers it. It now must let the OS know;
    more technically, it must let the **Network Interface Card** (**NIC**) device
    driver know, so that it can fetch and process packets as they arrive. It kicks
    the NIC driver into action by asserting a hardware interrupt.'
  prefs: []
  type: TYPE_NORMAL
- en: Recall that device drivers reside in kernel-space, and therefore their code
    runs in Supervisor or kernel Mode. The (kernel privilege) driver code **Interrupt
    service routine** (**ISR**) now executes, fetches the packet, and sends it up
    the OS network protocol stack for processing.
  prefs: []
  type: TYPE_NORMAL
- en: The NIC driver's ISR code is kernel code, and it is has run but in what context?
    It's obviously not in the context of any particular process. In fact, the hardware
    interrupt probably interrupted some process. Thus, we just call this *interrupt
    context*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interrupt context code has the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: Always triggered by a hardware interrupt (not a software interrupt, fault or
    exception; that's still process context)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bottom-up approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous execution of kernel code by an interrupt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If, at some point, you do report a kernel bug, it helps if you point out the
    execution context.
  prefs: []
  type: TYPE_NORMAL
- en: Technically, within interrupt context, we have further distinctions, such as
    hard-IRQs and softirqs, bottom halves, and tasklets. However, this discussion
    goes beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter started by explaining the Unix design philosophy, including the
    central principles or pillars of the Unix philosophy, design, and architecture.
    We then described the Linux system architecture, where we covered the meaning
    of CPU-ABI (Application Binary Interface), ISA, and toolchain (using `objdump`
    to disassemble a simple program, and accessing CPU registers with inline assembly).
    CPU privilege levels and their importance in the modern OS were discussed, leading
    in to the Linux system architecture layers – application, libraries, system calls,
    and the kernel. The chapter finished with a discussion on how Linux is a monolithic
    OS and then explored kernel execution contexts.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, the reader will delve into the mysteries of, and get a
    solid grasp of, virtual memory – what exactly it means, why it's in all modern
    OSes, and the key benefits it provides. We will discuss relevant details of the
    making of process virtual address space.
  prefs: []
  type: TYPE_NORMAL
