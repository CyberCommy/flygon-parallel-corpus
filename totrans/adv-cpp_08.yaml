- en: 7\. Everybody Falls, It's How You Get Back Up â€“ Testing and Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Describe different types of assertions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement compile-time and runtime assertions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement exception handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describe and implement unit testing and mock testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debug C++ code using breakpoints and watchpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspect data variables and C++ objects in the debugger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, you'll learn how to add assertions appropriately, add unit
    test cases so that code behaves as per the requirements, and learn about debugging
    techniques so that you can find bugs in the code and trace the root cause of them.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During the **Software Development Life Cycle** (**SDLC**), once the requirement
    gathering phase is complete, then generally comes the Design and Architecture
    phase, wherein the high-level flow of the project is defined and broken down into
    smaller components of modules. When there are many team members in a project,
    it is necessary that each team member is clearly assigned a specific part of the
    module and that they are aware of their requirements. This way, they can independently
    write their part of the code in an isolated environment and make sure it works
    fine. Once their part of the work is complete, they can integrate their module
    with the other developer's modules and make sure the overall project is executing
    as per the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: This concept can be applied to small projects too, where the developer is completely
    working on a requirement, breaking it down into smaller components, developing
    components in an isolated environment, making sure it executes as per the plan,
    integrating all the small modules to complete the project, and finally testing
    it to ensure that the overall project is working fine.
  prefs: []
  type: TYPE_NORMAL
- en: There is a good amount of testing required when the whole project is integrated
    and executed. There may be a separate team (known as `IP address` as a `string`,
    then the developer needs to ensure it is in the format `XXX.XXX.XXX.XXX`, where
    `X` is a digit from `0`-`9`. The length of the string must be of limited size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the developer can create a test program that executes their part of the
    code: parsing the file, extracting the `IP address` as a string, and testing if
    it is in the correct format. Similarly, if the configuration has other parameters
    to be parsed and they need to be in a specific format such as `userid` / `password`,
    file location for the log or mount point, and so on, then all these will be part
    of the unit testing for that module. In this chapter, we''ll explain techniques
    such as `assertions`, `safety nesting` (`exception handling`), `unit testing`,
    `mocking`, `breakpoints`, `watchpoints`, and `data visualization` to pinpoint
    the source of errors and limit their growth. In the next section, we''ll explore
    the assertion technique.'
  prefs: []
  type: TYPE_NORMAL
- en: Assertions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using testing condition for the aforementioned scenario will help the project
    develop in a better way as the flaws will be caught at a base level rather than
    at the later QA level. There may be scenarios wherein even after writing the unit
    test cases and successful execution of the code, issues may be found sch as the
    application crashing, the program exiting unexpectedly, or the behavior is not
    as expected. To overcome such scenarios, generally, a developer uses a debug mode
    binary to recreate the problem. `Asserts` are used to ensure that the conditions
    are checked, otherwise the program's execution is terminated.
  prefs: []
  type: TYPE_NORMAL
- en: This way, the problem can be traced fast. Also, in `Debug Mode`, the developer
    can traverse the actual execution of the program line by line and check if the
    flow of code is as expected or if the variables are set as expected and accessed
    correctly. Sometimes, accessing pointer variables causes unexpected behaviors
    if they are not pointing to a valid memory location.
  prefs: []
  type: TYPE_NORMAL
- en: When writing code, we can check if the necessary condition is satisfied. If
    not, then the programmer may not want to execute the code further. This can be
    easily done using an assertion. An `assertion` is a macro where the specific condition
    is checked and if it doesn't meet the criteria, abort is called (program execution
    is stopped) and an error message is printed as a `standard error`. This is generally
    a **runtime assertion**. There can also be an assertion done at compile time.
    We will talk about this later. In the next section, we'll solve an exercise wherein
    we'll be writing and testing our first assertion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1: Writing and Testing Our First Assertion'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll write a function to parse an `IP address` and check
    if it''s valid. As part of our requirements, the `IP address` will be passed as
    a string literal in the `XXX.XXX.XXX.XXX` format. In this format, `X` represents
    a digit from `0`-`9`. So, as part of testing to check whether the `string` being
    parsed is correct or not, we need to ensure that the `string` is `not null` and
    has a `length` that''s less than `16`. Follow these steps to implement this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file named **AssertSample.cpp**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the file and write the following code to include the header files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `#include<cassert>` shows that we need to include the
    `cassert` file where assert is defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a function named `checkValidIp()` that will take the `IP address` as
    input and return a `true` value if the `IP address` meets our requirements. Write
    the following code to define the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, `assert(ip != NULL)` shows that the assert macro is used to check condition
    if the "`ip`" variable that was passed is not `NULL`. If it's `NULL`, then it
    will abort with an error message. Also, `assert(strlen(ip) < 16)` shows that the
    assert is used to check if "`ip`" is `16` character or less. If not, then it aborts
    with `error message`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a `main` function that passes a different string literal to our
    `checkValidIp()` function and makes sure it can be tested appropriately. Write
    the following code for the `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we've deliberately passed `NULL` to the `ip` variable
    to make sure `assert` is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Command Prompt` and go to the location where the `g++` compiler by
    typing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With this command, the `a.out` binary file is generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `a.out` binary file by typing the following command in the compiler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1: Running the Assertion binary on the Command Prompt](img/C14583_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: Running the Assertion binary on the Command Prompt'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding screenshot, you can see three pieces of code circled in red.
    The first highlighted portion shows the compilation of the **.cpp** file. The
    second highlighted portion shows the **a.out** binary that that was generated
    by the preceding compilation. The third highlighted part shows assertion throwing
    an error for the **NULL** value being passed. It indicates the line number and
    function name where the assertion is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, inside the `main` function, we will pass `ip` with a length greater than
    `16` and check if the `assert` is called here too. Write the following code to
    implement this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Again, open the compiler, compile the `ip` length that was passed is greater
    than `16`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to satisfy the `assert` condition so that the binary runs fine, we need
    to update the value of `ip` inside the `main` function. Write the following code
    to do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Again, open the compiler, compile the `assert` here, we haven't added any extra
    functionality to our `checkValidIP()` function. However, we'll use the same example
    in the *Exception Handling* and *Unit Testing* sections wherein we'll add more
    functionality to our function.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we don''t want the executable to abort due to assert in production or the
    release environment, remove the `assert` macro call from the code. First, we''ll
    update the value of `ip` whose length is greater than `16`. Add the following
    code to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, during compilation, pass the `-DNDEBUG` macro. This will make sure that
    the assert is not called in the binary. Write the following command to compile
    our `.cpp` file in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, when we execute the binary file, the following output is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/C14583_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: Running the Assertion binary on the Command Prompt'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding screenshot, since `assert` is not called, it will show the
    string length as **17** and the **true** value as the IP address will be validated.
    In this exercise, we saw that the assertion was called when the binary was executed.
    We can also have an assertion during the compilation of the code. This was introduced
    in C++ 11\. It is called a **static assertion** and we'll explore it in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Static Assertions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, we can do condition checks at compilation time to avoid any future
    errors. For example, in a project, we may use a third-party library that has some
    data structure declared in it. This structure information, such as its `size`
    and `member variables`, are known to us from its header file. Using this information,
    we can allocate or deallocate memory correctly, as well as work on its member
    variable. This structure property may change in a third-party library with a different
    version. However, if our project code is still using the structure of the earlier
    version, then it will create a problem when we use it. We may get an error at
    a later stage when running the binary. We can catch this error at compile time
    itself using `static assertion`. We can make a comparison of static data such
    as the version number of libraries, thus making sure our code will not have to
    face any problems. In the next section, we'll solve an exercise based on this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2: Testing Static Assertions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll be comparing the version numbers of two header files
    by doing a `static assertion`. If the `version number` is less than `1`, then
    the static assert error will be thrown. Perform the following steps to implement
    this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a header file named `name`, `age`, and `address`. It also has the version
    number `1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create another header file named `struct person` is defined and consists of
    the following attributes: `name`, `age`, `address`, and `Mobile_No`. It also has
    the `version number 2`. Now, `version 1` is the old version and `version 2` is
    the new one. The following is a screenshot of the two header files side by side:![Figure
    7.5: Library file with a different version](img/C14583_07_05.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 7.5: Library file with a different version'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Create a file named `doSanityCheck()` that performs a version check for the
    library. It is done using static assertion and it is performed at compile time.
    The second line of the code shows that the `doSanityCheck()` function, the `static_assert()`
    function checks if this version of the library is greater than 1\.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If your project needs a struct of person defined in `version 2` or higher of
    the library to execute it correctly, we need files that match `version 2`, that
    is, `PERSON_LIB_VERSION` should be set to `2` at least. If a developer gets `version
    1` of the library and tries to create a binary for the project, it may create
    a problem in execution. To avoid this scenario, in the main code of the project,
    we do a sanity check for the project before it builds and executes.
  prefs: []
  type: TYPE_NORMAL
- en: To include `version 1` of the library in our `version 1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile our `static_assert` error that was thrown since the version of the library
    is not matching.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, to compile the program correctly, remove the soft link of `ProgramLibrary`
    and create a new one pointing to `version2` and compile it again. This time, it
    will compile fine. Type the following commands into the terminal to remove a soft
    link:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a screenshot of the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7: Static assertion compilation file](img/C14583_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.7: Static assertion compilation file'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you can see, a region marked in red shows that the correct version of `PersonLibrary`
    is used and compilation goes ahead with no problem. After the compilation, a binary
    file called "**a.exe**" is created. In this exercise, we performed static assertion
    by comparing the version numbers of two header files. In the next section, we'll
    explore the concept of exception handling.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Exception Handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we saw earlier in the debug mode binary, we can use runtime assert to abort
    the program when a certain condition is not satisfied. But in a release mode binary
    or production environment, when the client is using this product, it will not
    be a good idea to abort the program abruptly. It would be better to handle such
    error conditions and proceed with the next part of the execution of the binary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The worst case occurs when the binary needs to exit. It''ll do so gracefully
    by adding the correct log messages and cleaning all the allocated memory for this
    process. For such a scenario, exception handling is used. Here, when an error
    condition is hit, execution is transferred to a special block of code. The exception
    consists of three sections, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**try block**: Here, we check if the criteria match the necessary condition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**throw block**: It throws an exception if the criteria do not match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**catch block**: It catches the exception and performs the necessary execution
    for that error condition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we'll solve an exercise wherein we'll perform exception
    handling on our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3: Performing Exception Handling'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll be performing exception handling on our **AssertSample.cpp**
    code. We''ll replace the assert condition with our exception. Perform the following
    steps to implement this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `ExceptionSample.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following codes to add header files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `checkValidIp()` function wherein we have a try-catch block. If the
    condition present in the try block is not satisfied, an exception will be thrown
    and the message in the catch block will be printed. Add the following code to
    accomplish this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, you can see the try block where the condition is checked.
    Inside the try block, if `ip` is `NULL`, then it will throw an exception of the
    (`const char *`) type. In the next condition, if `ip` is `greater than 15`, then
    it will throw an exception with the int parameter type. This throw is caught by
    a correct catch with matching parameters (`int` or `const char *`). Both exceptions
    return `false` with some error message. Alternatively, in the `catch` block, you
    can perform extra steps if any cleaning is needed or use the default values for
    variables that were used for comparison in the exception.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There is a default exception; for example, if there's a nested function that
    throws an error with a different parameter, it can be caught as a higher-level
    function with a parameter such as catch(â€¦). Again, in the generic catch, you can
    create a default behavior for exception handling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `main()` function and write the following code inside it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the terminal, compile our file, and run the binary. You will see the following
    output:![Figure 7.8: Example execute code with exception handling](img/C14583_07_08.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 7.8: Example execute code with exception handling'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The preceding example throws an exception for `ip` being `NULL` and exits gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, modify the value of `ip` in the `main` function by providing more than
    `15` characters. Write the following code to do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the terminal, compile our file, and run the binary. You will see the following
    output:![Figure 7.9: Another example of exception handling](img/C14583_07_09.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 7.9: Another example of exception handling'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It throws an error with a `length mismatch` for the `ip string`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, modify the value of `ip` in the `main` function by providing less than
    `15` characters. Write the following code to do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the terminal, compile our file, and run the binary. You will see the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.10: The binary runs fine without throwing an exception](img/C14583_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.10: The binary runs fine without throwing an exception'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you can see from the preceding screenshot, the binary file executes properly
    without any exceptions. Now that you've understood how to handle exceptions, in
    the next section, we'll explore the concepts of `unit testing` and `mock testing`.
  prefs: []
  type: TYPE_NORMAL
- en: Unit Testing and Mock Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a developer starts writing code, they need to ensure it is tested correctly
    at the unit level. It may happen that the boundary conditions are missed, and
    the code may break when it runs on the client's site. To avoid this situation,
    generally, it is a good idea to do `unit testing` for the code. `Unit testing`
    is testing that's performed at the unit level or the base level of the code where
    a developer can test their code in an isolated environment, assuming the required
    setup has been fulfilled to run a feature of the code. Generally, it is good practice
    to break down modules into small functions and test each function separately.
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose part of the functionality is to read the configuration
    file and get the environment set up with the parameters from the configuration
    file. We can create a dedicated function to write this functionality. So, to test
    this function, we can create a set of unit test cases that will check various
    combinations that may fail or behave incorrectly. Once these test cases have been
    identified, the developer can write code to cover the functionality and make sure
    it passes all the unit test cases. This is good practice as part of development
    where you keep on adding test cases first and add code accordingly, and then run
    all the test cases for that function and make sure they behave appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: There are a good number of tools available for writing and integrating unit
    test cases for a project. A few of them are `Google Test framework`. It is freely
    available and can be integrated with the project. It uses the **xUnit test framework**
    and has a collection of asserts that can be used to test the condition for test
    cases. In the next section, we'll solve an exercise wherein we'll be creating
    our first unit test case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4: Creating Our First Unit Test Case'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll work on the same scenario we discussed in the previous
    section wherein the developer is tasked with writing a function to parse the `configuration
    file`. Different valid parameters are passed in the configuration file, for example,
    `product executable name`, `version number`, `database connectivity information`,
    `IP address` to connect to the server, and so on. Assume that the developer will
    break down all this functionality of parsing the file and setting and testing
    the parameters for individual properties in a separate function. In our case,
    we assume that the developer is writing functionality where they have parsed the
    `IP address` as a `string` and wants to deduce if the `string` is the valid `IP
    address`. For now, the criteria to match the `IP address` to be valid needs to
    satisfy the following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: The `string` should not be null.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `string` should contain no more than `16` characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `string` should be in the `XXX.XXX.XXX.XXX` format, where `X` must be a
    digit from `0`-`9`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Perform the following steps to implement this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the `checkValidIp()` to check if the `IP address` is valid. Again, just
    to understand the `Google unit test`, we will write minimal code to understand
    the feature.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `ip` is `not NULL` and that the length is less than `16`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, if both conditions fail, the function returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Call the `checkValidIp()` function to create a new file named `checkValidIP()`
    function. Add the following code inside it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To create test code, we''ll create our first `checkValidIp` function. Write
    the following code inside it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second line of the preceding code, we''re including the `TEST` function,
    which takes two parameters: the first is the `testsuite` name and the second is
    the `testcase` name. For our case, we have created `TestSuite` `CheckIp`. In the
    `TEST` block, you will see that we have the `Google test` define an `assert` called
    `ASSERT_FALSE` that will check if the condition is `false`. If it''s not, it will
    fail the test case and show the same in the results.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Generally, for a `Google test` case and test suite, you can group them in a
    common namespace and call the `RUN_ALL_TESTS` macro, which runs all the test cases
    attached to test binary. For each test case, it calls the `SetUp` function to
    initialize (like constructor in class), then it calls the actual test case, and
    finally, it calls the `TearDown` function (like destructor in class). It is not
    necessary to write the `SetUp` and `TearDown` functions unless you have to initialize
    something for the test cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to run the test cases, we will create the main `RUN_ALL_TESTS` macro.
    Alternatively, we can create an executable by linking the `Google Test library`
    that invokes `RUN_ALL_TESTS`. For our case, we will do the latter. Open the terminal
    and run the following command to create a test run binary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This will include the object file of `CheckValidIp` function is defined in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, type the following command to add the necessary libraries that will be
    linked for creating a binary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the binary with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows two test cases that were passed for the `CheckIp` `testsuite`. The
    first test case, `CheckIp.testNull`, is called and it passes. The second testcase,
    `CheckIp.BadLength`, is called and it passes too. This result is visible in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11: Compiling and executing test cases](img/C14583_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.11: Compiling and executing test cases'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In `Google Test`, we can also use other asserts, but for our test cases, we
    are fine with `ASSERT_FALSE` since we are only checking the false condition for
    the IP address that we pass.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will add more test cases to make our code robust. This is generally
    good practice for writing code. First, create the test cases and make sure the
    code runs fine for new test cases and old test cases along with the correct functionality
    of the code. To add more test cases, add the following code to the `IP` starts
    with ".". The fourth case should fail if the `IP` ends with ".". The fifth case
    should fail if `IP` has space in-between. The sixth case should fail if the `IP`
    contains any non-digit characters. The seventh case should fail if `IP` has a
    token value less than `0` and greater than `255`. The last case should fail if
    `IP` has wrong token counts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, add the following code inside the `CheckValidIp()` function of the **CheckIp.cpp**
    file. This code is required to handle new test cases:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the terminal and write the following command to run the binary file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'All the test cases have been executed, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12: Output of test cases run](img/C14583_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.12: Output of test cases run'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The preceding screenshot shows that there are `10` test cases in the `CheckIp`
    test suite and that all the test cases ran fine. In the next section, we'll learn
    about unit testing using mock objects.
  prefs: []
  type: TYPE_NORMAL
- en: Unit Testing Using Mock Objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a developer works on unit testing, there may be scenarios wherein certain
    interfaces are called after concrete actions have taken place. For example, as
    we discussed in the preceding scenarios, let's assume that the project is designed
    in such a way that, before its execution, it takes all the configuration information
    from the database. It queries the database to get specific parameters, for example,
    the web server's `IP address`, `user`, and `password`. It then tries to connect
    to a web server (maybe there is another module that handles network-related tasks)
    or starts acting on the items that are needed for an actual project. Previously,
    we worked on testing the validity of the IP address. Now, we'll go a step further.
    Let's assume that the IP address is fetched from the database and that we have
    a utility class that handles connecting to `DB` and querying `IP addresses`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, to test the IP address' validity, we need to assume the database connectivity
    has been set up. This means that the application can query the database correctly
    and get the results of the query, one of which is an `IP address`. Only then can
    we test the IP address' validity. Now, in order to perform such testing, we must
    assume that all the necessary activities have been completed and that we've got
    an `IP address` to test. Here comes the mock object, which behaves like the real
    object. It provides the facility for unit testing so that the application is under
    the impression that the IP address has already been fetched from the database,
    but in reality, we have imitated it. To create a mock object, we need to inherit
    it from the class that it needs to imitate. In the next section, we'll walk through
    an exercise to get a better understanding of the mock object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5: Creating Mock Objects'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll create mock objects by assuming that all the interfaces
    are working as expected. Using these objects, we''ll test a few functionalities
    such as validating the `IP address`, checking DB connectivity, and checking whether
    the `username` and `password` are in correct format. Once all the tests have passed,
    we''ll confirm the application and make it ready for `QA`. Perform the following
    steps to implement this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a header file named **Misc.h** and include the necessary libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `ConnectDatabase` that will connect to the database and
    return the result of the query. Within the class, declare the `Dbname`, user,
    and passwd variables. Also, declare a constructor and two virtual functions. Out
    of these two virtual functions, the first one must be a destructor, and the second
    one must be the `getResult()` function, which returns the query result from the
    database. Add the following code to implement this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Create another class named `WebServerConnect`. Declare three `string` variables
    inside the `class`, namely `Webserver`, `uname`, and `passwd`. Create constructor
    and two virtual functions. Out of these two virtual functions, the first one must
    be a destructor, and the second one must be the `getRequest()` function. Add the
    following code to implement this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`Virtual functions` are required since we are going to create a `Mock class`
    from the preceding class and call these functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `App`. Create the constructors, and destructors and call
    all the functions. Add the following code to implement this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the app will first query the database and get the `IP
    address`. It then connects to the web server with the necessary information and
    query it to get the required information.
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `gmock` header file, which is needed to create a mock class.
    Also, the `MockDB` class is inherited from the `ConnectDatabase` class. The `MOCK_METHOD1(getResult,
    string(string));` line states that we are going to mock the `getResult` interface.
    So, during unit testing, we can call the `getResult` function directly with the
    desired result without creating the `ConnectDatabase` class and running a real
    query to the database. One important point that needs to be noted here is that
    the function we need to mock must be defined with the `MOCK_METHOD[N] macro`,
    where N is the number of parameters the interface will take. In our case, the
    `getResult` interface takes one parameter. Thus, it is mocked with the `MOCK_METHOD1`
    macro.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a file named `getResult()` and `getRequest()` functions, where the DB
    query and `WebServer` query return a default string. Here, the `App::run()` function
    assumes that both DB connectivity and web server connectivity has been executed
    and now it can execute web queries at regular intervals. At the end of each query,
    it will return the "`Webserver returned success`" string by default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, create a file named `dbname`, `dbuser`, and `dbpasswd`. Then, we query
    to the database to get the IP address and other config parameters. We've commented
    the `app.checkValidIp(ip)` line as we're assuming that the IP address that we've
    fetched from the DB needs to be validated. Also, this function needs to be unit
    tested. Using the `connectWeb()` function, we can connect to the web server by
    passing dummy parameters such as `webname`, `user`, and `passwd`. Finally, we
    call the `run()` function, which will run in iteration, thereby querying the web
    server and giving the default output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Save all the files and open the terminal. In order to get the basic functionality
    required to execute the project, we''ll build the binary file and execute it to
    see the result. Run the following command in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will create binary file called `RunApp` in the current folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, write the following command to run the executable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command generates the following output in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13: Running the app](img/C14583_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.13: Running the app'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you can see in the preceding screenshot, the binary displays the output "`Webserver
    returned success`" in a timely fashion. So far, our application is running fine
    as it is assuming that all the interfaces are working as expected. But we still
    have to test a few functionalities such as validating the `IP address`, `DB connectivity`,
    checking whether the `username` and `password` are in the correct format if any,
    and more before making it ready for `QA`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the same infrastructure, start unit testing each functionality. For our
    exercise, we''ll assume that the `DB connectivity` has already been done and has
    been queried to get the `IP address`. After that, we can start unit testing the
    validity of the `IP address`. So, in our test case, the Database class needs to
    be mocked and the `getDBResult` function must return the `IP address`. This `IP
    address` will be passed to the `checkValidIP` function later, wherein we''ll test
    it. To implement this, create a class named `checkValidIP` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have used the testing and `testing::Return` namespaces to call mock
    class interfaces and return the user-defined values that are meant for test cases.
    Within the `TEST_F` function, we used the `EXPECT_CALL` function, wherein we pass
    the instance of a mock object as the first parameter and pass the `getResult()`
    function as the second parameter. The `WillOnce(Return(""))` line states that
    the interface needs to be called once and will return "" and an empty string.
    This is the value that needs to be passed to the `checkValidIP` function to test
    for the empty string. This is checked with the `ASSERT_FALSE` macro. Similarly,
    other test cases can be created using the mocked object of DB and passing the
    IP address to the `checkValidIP` function. To create various test cases, the `TestApp`
    class is inherited from the `testing::Test` class, which contains the App instance
    and Mocked object of Database. Within the `TestApp` class, we have defined two
    functions, namely `SetUp()` and `TearDown()`. Inside the `SetUp()` function, we
    created a `MockDB` instance and tagged it to the testApp instance. Since nothing
    needs to be done for the `TearDown()` function, we've kept it empty. Its destructor
    is called in the destructor of the `App` class. Also, we passed two parameters
    inside the `TEST_F` function. The first parameter is the Test class while the
    second parameter is the test case's name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save all the files and open the terminal. Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding command, we have also linked the `gmock library`. Now, type
    the following command to run the test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.14: Running the Gmock test](img/C14583_07_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.14: Running the Gmock test'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: From the preceding command, we can see that all the test cases executed and
    passed successfully. In the next section, we'll discuss `breakpoints`, `watchpoints`,
    and `data visualization`.
  prefs: []
  type: TYPE_NORMAL
- en: Breakpoints, Watchpoints, and Data Visualization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, we discussed that unit testing needs to be done before
    a developer checks code into the repository branch and can be seen by other team
    members so that they can integrate it with other modules. Although unit testing
    is done well and the developer checks the code in, there may be a chance that
    whenever the code is integrated and the QA team starts testing, they may find
    a bug in the code. Generally, in such a scenario, an error may be thrown in a
    module that was caused due to changes in the other module. It may become difficult
    for the team to crack down on the real reason for such issues. In such cases,
    **debugging** comes into the picture. It tells us exactly how the code is behaving,
    and the developer can get granular information of the code's execution. A developer
    can see what parameters the function is getting and what value it is returning.
    It can tell exactly what value is assigned to a variable or a pointer or what
    the content in memory is. This becomes very helpful for the developer to identify
    in which part of the code the issue is. In the next section, we'll implement a
    stack and perform a few operations on it.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the Stack Data Structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider a scenario wherein a developer has been asked to develop his/her own
    stack structure that can take in any parameter. Here, the requirement is that
    the stack structure must follow the **Last In First Out** (**LIFO**) principle,
    where elements are placed on top of each other and when they''re removed from
    the stack, the last element should be removed first. It should have the following
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**push()** to place a new element on top of the stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**top()** to display the top element of the stack, if any'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pop()** to remove the last inserted element from the stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**is_empty()** to check if the stack is empty'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**size()** to display the number of elements present in the stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**clean()** to empty the stack if it has any elements in it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following lines of code show how to include the necessary libraries within
    the **Stack.h** header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As we already know, the stack consists of various operations. To define each
    of these functions, we''ll write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: So far, we've seen how to implement a stack using a `Single Linked List`. Every
    time `push` is called in Stack, a new element of a given value will be created
    and attached to the beginning of the stack. We call this a head member variable
    and is where the head will point to the next element in the stack and so on. When
    `pop` is called, the head will be removed from the stack and will point to the
    next element of the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write the implementation of the previously created Stack in the `22`,
    `426`, and `57`. When the `displayStackStats()` function is called, it should
    state the size of the stack to be `3`. Then, we pop out `57` from the stack and
    the top element must display `426`. We''ll do the same operation for the stack
    of `char`. Here is the complete implementation of the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'When we compile the `-g` option is being used). Thus, you can debug the binary
    if needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll write the following command to execute the binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.15: Main function using the Stack class](img/C14583_07_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.15: Main function using the Stack class'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In the preceding output, the red ink in the second call to the statistics function
    shows the correct information of showing three elements in a stack of int. However,
    the red ink calls to the top of the int stack show random or garbage values. If
    the program is run again, it will show some other random numbers and not the expected
    values of `57` and `426`. Similarly, for the stack of char, the section highlighted
    in the red ink, that is, top of `char`, shows a garbage value instead of the expected
    value, that is, "l". Later, the execution shows the error of double free or corruption,
    which means free was called to the same memory location again. Finally, the executable
    gave core dump. The program didn''t execute as expected and it may not be clear
    from the display where the actual error lies. To debug `Main`, we''ll write the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.16: Debugger display â€“ I](img/C14583_07_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.16: Debugger display â€“ I'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, the marks highlighted in blue show how the debugger
    is used and what it displays. The first mark shows the debugger being called using
    the `gdb` command. After entering the `gdb` command, the user goes to the command
    mode of the debugger. Here is some brief information about the commands being
    used in the command mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '**b main**: This tells the debugger to break at the main function call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**r**: It is the short form that''s used to run the executable. It can be run
    by passing parameters too.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**n**: It is a short form for the next command, which tells us to execute the
    next statement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`si` variable when it is called in the code and its value is changed. The debugger
    will display the content of the code where this variable is being used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`step in`" command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next statement that will be executed is `si.push(22)`. Since `si` has been
    updated, the watchpoint invokes and displays the old value of `si` and a new value
    of `si` wherein it shows that the old value of `si` was head with NULL and `sz`
    was 0\. After `si.push`, the head is updated with the new value and its execution
    comes to line 75 of the `Stack.h` file, which is where the `sz` variable is incremented.
    If the *Enter* key is pressed again, it will execute it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the execution has automatically moved from the main function to the
    `Stack::push` function. The following is a screenshot of the continued commands
    on the debugger:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/C14583_07_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.17: Debugger display â€“ II'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The next command shows that `sz` has been updated with a new value of `1`.
    After pressing *Enter*, the execution of code moves back from `Stack::push` on
    the `line 76` back to the main function at line 8\. This is highlighted in the
    following screenshot. It shows that the execution stopped at the `si.push(426)`
    call. Once we step in, `Stack::push` will be called. The execution moves to `line
    71` of the `Stack.h` program, as shown in the red ink. Once execution comes to
    `line 74`, as shown in the red ink, the watch is called which displays that `si`
    was updated with the new value. You can see that after the completion of the `Stack::push`
    function, the flow went back to the Main code. The following is a screenshot of
    the steps that were executed in the debugger:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/C14583_07_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.18: Debugger display â€“ III'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: After pressing *Enter*, you will see that `displayStackStats` is called at `line
    11`. In the `line 12`. However, the display shows the value as `0` instead of
    the expected value of `57`. This is an error that we are still unable to figure
    out â€“ why was the value changed? However, it is clear that the value may have
    changed somewhere in the preceding calls to the main function. So, this may not
    make us interested in continuing with the debugging ahead of us. However, we need
    to proceed and debug from the beginning again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the commands that will be used to debug the
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/C14583_07_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.19: Debugger display â€“ IV'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To rerun the program from the start, we must press *r*, and for confirmation
    and continuation, we need to press *y*, which means we rerun the program from
    the start. It will ask for confirmation; press *y* to continue. All of these commands
    are highlighted in blue in the preceding screenshot. During execution at line
    7, we need to run the '`display *si.head`' command, which will continuously display
    the contents of the `si.head` memory location after every statement that's executed.
    As shown in the red ink, after `22` is pushed onto the stack, the head is updated
    with the correct values. Similarly, for values `426` and `57`, when inserted into
    the stack using push, the call to head is updated correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Later, when `displayStackStats` is called, it shows the correct `size` of `3`.
    But when the top command is called, there is the wrong value shown in the head.
    This is highlighted in red ink. Now, the code for the top command doesn't alter
    the value of head, so it is clear that an error occurred in the previous statement
    of execution, that is, at `displayStackStats`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we have narrowed down the code where there may be an issue. We can run
    the debugger to point `displayStackStats` and move inside `displayStackStats`
    to find the reasons that caused the values to be altered inside the Stack. The
    following is a screenshot of the same wherein the user needs to start the debugger
    from the beginning:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.20: Debugger display â€“ IV](img/C14583_07_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.20: Debugger display â€“ IV'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: After restarting the debugger from the beginning and coming to the execution
    point at line 11 where `displayStackStats` is called, we need to step in. The
    flow is to go to the start of the `displayStackStats` function. Also, we need
    to execute the next statement. Since the initial checks in the function are clear,
    they don't alter the value of the head and we can press *Enter* to execute the
    next steps. When we suspect that the next steps can alter the value of the variable
    that we're looking for, we need to step in. This is done in the preceding snapshot,
    highlighted in red. The latter execution comes to `line 97`, that is, the last
    line for the `displayStackStats` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'After typing in *s*, the execution moves to the destructor stack and calls
    the clean function at line 81\. This clean command deletes the `tmp` variable,
    which has the same value as that of the head. The function empties the stack,
    which was not expected to run. It was only the `displayStackStats` function that
    was supposed to be called and executed to finally return to the main function.
    But the destructor may be called due to the local variable in the function that
    goes out of scope after the function is completed. Here, the local variable was
    the variable that was declared as a parameter to the `displayStackStats` function
    at `line 92`. So, a local copy of the `si` variable from the main function was
    created when the `displayStackStats` function was called. This variable called
    the destructor of Stack when it went out of scope. Now, the pointers from the
    `si` variable have been copied to the temporary variable and deleted the pointer
    at the end by mistake. This was not intended by the developer. Thus, at the end
    of the execution of the code, a double free error was stated. The `si` variable
    must call the Stack destructor when it goes out of scope as it will try to free
    the same memory again. To resolve this issue, it is clear that the `displayStackStats`
    function must be called with the passing parameter as a reference. For that, we
    must update the code of the `displayStackStats` function in the `Stack.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we save and compile the **Main.cpp** file, the binary will be generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command generates the following output in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.21: Debugger display â€“ IV](img/C14583_07_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.21: Debugger display â€“ IV'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: From the preceding screenshot, we can see that the expected values of `57` and
    `426` are shown at the top of the stack. The `displayStackStats` function also
    displays the correct information for int and the char Stack. Finally, we located
    the error using the debugger and fixed it. In the next section, we'll solve an
    activity wherein we'll be developing functions for parsing files and writing test
    cases to check the accuracy of the functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 1: Checking the Accuracy of the Functions Using Test Cases and Understanding
    Test-Driven Development (TDD)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this activity, we'll be developing functions so that we can parse files and
    then write test cases to check the correctness of the functions we've developed.
  prefs: []
  type: TYPE_NORMAL
- en: An IT team in a big retail organization wants to keep track of product sales
    by storing Product details and Customer details in its database as part of its
    reconciliation. On a periodic basis, the sales department will provide this data
    to the IT team in a simple text format. As the developer, you need to ensure that
    the basic sanity checking of data is done and that all the records are parsed
    correctly before the company stores records in the database. The sales department
    will provide two text files that hold Customer information and Currency information
    for all the sales transactions. You need to write parsing functions to process
    these files. The two files are `Currency` and `ConversionRatio`.
  prefs: []
  type: TYPE_NORMAL
- en: All the necessary information for the environment's setup for this project is
    kept in the Configuration file. This will also hold filenames, along with other
    parameters (such as `DB`, `RESTAPI`, and so on) and variable values in a file
    called `recordFile` and similarly for the Currency file, the variable name is
    `currencyFile`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the test conditions we''ll be writing to check the accuracy
    of the function that''s used to parse the **CurrencyConversion.txt** file:'
  prefs: []
  type: TYPE_NORMAL
- en: The first line should be the header line and its first field should contain
    the "`Currency`" string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Currency` field should be made up of three characters. For example: "`USD`",
    "`GBP`" is valid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ConversionRatio` field should be made of floating-point numbers. For example,
    `1.2`, `0.06` is valid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There should be exactly two fields for each line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The delimiter that's used for the record is "|".
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are test conditions we''ll be writing to check the accuracy of
    the function that''s used to parse the **RecordFile.txt** file:'
  prefs: []
  type: TYPE_NORMAL
- en: The first line should contain the header line and its first field should contain
    the "`Customer Id`" string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Customer Id`, `Order Id`, `Product Id`, and `Quantity` should all be integer
    values. For example, `12312`, `4531134` is valid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TotalPrice (Regional Currency)` and `TotalPrice (USD)` should be floating-point
    values. For example, `2433.34`, `3434.11` is valid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `RegionalCurrency` field should have its value present in the `std::map`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There should be exactly nine fields in each line, as defined in the `HEADER`
    information of the file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The delimiter for the record is "|".
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Follow these steps to implement this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Parse the **parse.conf** configuration file, which includes the environment
    variables for the project to run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `recordFile` and `currencyFile` variables correctly from Step 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using these variables we retrieved from the Config file, parse the Currency
    file with all conditions met. If the condition is not met, return the appropriate
    error message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parse the Record file with all the conditions we've met. If not, then return
    an error message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a header file named `CommonHeader.h` and declare all the utility functions,
    that is, `isAllNumbers()`, `isDigit()`, `parseLine()`, `checkFile()`, `parseConfig()`,
    `parseCurrencyParameters()`, `fillCurrencyMap()`, `parseRecordFile()`, `checkRecord()`,
    `displayCurrencyMap()`, and `displayRecords()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a file named `Util.cpp` and define all the utility functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a file named `ParseFiles.cpp` and call the `parseConfig()`, `fillCurrencyMap()`,
    and `parseRecordFile()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile and execute the `Util.cpp` and `ParseFiles.cpp` files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a file named `ParseFileTestCases.cpp` and write test cases for the functions,
    that is, `trim()`, `isAllNumbers()`, `isDigit()`, `parseCurrencyParameters()`,
    `checkFile()`, `parseConfig()`, `fillCurrencyMap()`, and `parseRecordFile()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile and execute the `Util.cpp` and `ParseFileTestCases.cpp` files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the flow diagram for parsing different files and displaying
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/C14583_07_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.22: Flow diagram'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: From above flowchart we have rough idea of executing the flow. To have a clear
    understanding before writing the code, let's look at the finer details. It'll
    help define test cases for each execution block.
  prefs: []
  type: TYPE_NORMAL
- en: 'For parsing Config File block, we can break down steps into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Check if config file exists and has read permission.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check if it has appropriate header.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parse whole file line by line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each line, parse fields with '=' as delimiter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there are 2 fields from above step , process to see if it is `Currency file`
    or `Record file` variables and store appropriately.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there are no 2 fields from step 4 go to next line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After completely parsing file, check if both variables from above step are not
    empty.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If empty, return with error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For parsing `Currency File` block, we can break down steps into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Read variable for `CurrencyFile` and see if the file exists and has read permission.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check if it has appropriate header.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parse whole file line by line, with '|' as delimiter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there are exactly 2 fields found for each line, consider first as `Currency
    field` and second as `conversion field`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there are no 2 fields found from step 3, return with appropriate error message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From step 4, do all checks for `Currency field` (it should be of 3 characters)
    and `Conversion Field` ( should be digit).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If passed from step 6, store the `currency`/`conversion` value as pair on map
    with key as `Currency` and value as digit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If not passed from step 6, return error stating for that `currency`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After complete parsing of the `Currency` file, there will be map created that
    will have conversion values for all the currencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For parsing `Record File` block, we can break down steps into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Read variable for `RecordFile` and see if the file exists and has read permission.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check if it has appropriate header.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parse whole file line by line, with '|' as delimiter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there no 9 fields found from above step return with appropriate error message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there are 9 fields found, do corresponding checks for all fields listed in
    start of activity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If step 5 does not pass, return with appropriate error message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If step 5 is passed, store the record in vector of records.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After completely parsing Record file, all the records will be stored in vector
    of records.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'While creating flow for parsing all the three files, we see few steps repeating
    for all 3 files such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Checking if file exists and is readable
  prefs: []
  type: TYPE_NORMAL
- en: Checking if file has a correct header information
  prefs: []
  type: TYPE_NORMAL
- en: Parsing the records with delimiter
  prefs: []
  type: TYPE_NORMAL
- en: Checking if field is `Digit` is common in `Currency` and `Record file`
  prefs: []
  type: TYPE_NORMAL
- en: Checking if field is `Numeric` is common in `Currency` and `Record file`
  prefs: []
  type: TYPE_NORMAL
- en: The above points will help in refactoring the code. Also, there will be one
    common function for parsing the fields with delimiter, that is `trim function`.
    So, when we parse records with delimiter we can get value with space or tab at
    begin or end and that may not be needed , so we need to trim it once when parse
    the record.
  prefs: []
  type: TYPE_NORMAL
- en: Now we know we have above steps that are common we can write individual function
    for them. To start with TDD, we first understand requirement for function and
    start writing unit test cases first to test these functionalities. Then we write
    function such that it will pass the unit test cases. If few test cases fail we
    iterate the steps of updating function and executing test cases, until all of
    them pass.
  prefs: []
  type: TYPE_NORMAL
- en: For our example, above we can write `trim` function,
  prefs: []
  type: TYPE_NORMAL
- en: Now we know in trim function we need to remove first and last extra spaces/tab.
    For example, if string contains " AA " , the trim should return "AA" remove all
    the spaces.
  prefs: []
  type: TYPE_NORMAL
- en: The trim function can return new string with expected value or it can update
    the same string which was passed to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'So now we can write signature of the trim function : `string trim ( string
    &) ;`'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write the following test cases for it:'
  prefs: []
  type: TYPE_NORMAL
- en: With only extra characters (" ") , returns empty string ().
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With only empty characters in beginning(" AA") return string with end characters
    ("AA")
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With only empty characters at end("AA ") , should return string with begin characters("AA")
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With characters in middle (" AA ") return string with characters ("AA")
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With empty space in middle ("AA BB") , return the same string ("AA BB")
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All steps 3,4,5 with single character. Should return string with single character.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To create test cases , please check file `trim` function are written in test
    suite `trim`. Now write `trim` function with signature shown above in file. Execute
    test cases of `trim` function and check if it passes. It doesn't change the function
    appropriately and test it again. Repeat till all test cases pass.
  prefs: []
  type: TYPE_NORMAL
- en: Now we are confident to use `trim` function in the project. Repeat similar steps
    for the rest of the common functions (`isDigit`, `isNumeric`, `parseHeader` and
    so on). Please refer the **Util.cpp** file and **ParseFiletestCases.cpp** for
    the same and test all the common functions.
  prefs: []
  type: TYPE_NORMAL
- en: After completing common functions, we can write parse each file function separately.
    Main thing to understand and learn here is how to break down module to small functions.
    Find small repetitive tasks and create small functions for each so it is refactored.
    Understand the detail functionality of these small functions and create appropriate
    unit test cases.
  prefs: []
  type: TYPE_NORMAL
- en: Complete single function and thoroughly test it, if it fails, then update the
    function till it passes all test cases. Similarly, complete other functions. Then
    write and execute test cases for bigger functions, that should be relatively easy
    since we are calling small functions tested above in these bigger functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'After implementing the preceding steps, we''ll get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.23: All tests running properly](img/C14583_07_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.23: All tests running properly'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Below is the screenshot of the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.24: All tests running properly](img/C14583_07_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.24: All tests running properly'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 706.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we looked at various ways in which errors that are thrown by
    executables can be grabbed at compile time and runtime using asserts. We also
    learned about static assertion. We understood how exceptions are generated and
    how to handle them in the code. We also saw how unit testing can act as a savior
    to developers as they'll be able to identify any issues in the code at the beginning.
    We utilized mock objects for the classes that needed to be used in the test cases.
    We then learned about the debugger, breakpoints, watchpoints, and visualizing
    the data. We were able to locate the issues in the code using the debugger and
    fix them. We also solved an activity wherein we wrote the necessary test cases
    to check the accuracy of the functions that were used for parsing the files.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll learn how to optimize our code. We'll review how
    the processors execute the code and access the memory. We'll also learn how to
    determine the excess time that will be taken by the software to execute. Finally,
    we'll learn about memory alignment and cache access.
  prefs: []
  type: TYPE_NORMAL
