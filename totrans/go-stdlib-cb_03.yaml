- en: Dealing with Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The recipes in this chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: Converting strings to numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing floating-point numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rounding floating-point numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Floating-point arithmetics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatting numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting between binary, octal, decimal, and hexadecimal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatting with the correct plurals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating random numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operating complex numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting between degrees and radians
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking logarithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating checksums
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The numbers are generally the inevitable part of each application—printing the
    formatted numbers, converting base representations, and so on. This chapter presents
    a lot of operations that you can commonly deal with.
  prefs: []
  type: TYPE_NORMAL
- en: Check if Go is properly installed. The *Getting ready* section from the *Retrieving
    Golang version* recipe of [Chapter 1](acf67248-0aa9-4150-a43b-d13eb9de89f2.xhtml), *Interacting
    With Environment,* will help you.
  prefs: []
  type: TYPE_NORMAL
- en: Converting strings to numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to convert the strings containing numbers to a
    numeric type (integer or floating-point value).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter03/recipe01`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `main.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Execute the command `go run main.go` in the Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4697cb54-bfb3-4630-8572-03032913534e.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The dominant function in the preceding sample code is the `ParseInt` function
    of package `strconv`. The function is called with three arguments: input, the
    base of input, and bit size. The base determines how the number is parsed. Note
    that the hexadecimal has the base (second argument) of 16 and the binary has the
    base of 2\. The function `Atoi` of package `strconv` is, in fact, the `ParseInt`
    function with the base of 10.'
  prefs: []
  type: TYPE_NORMAL
- en: The  `ParseFloat` function converts the string to a floating-point number. The
    second argument is the precision of `bitSize`. `bitSize = 64` will result in `float64`. `bitSize
    = 32` will result in `float64`, but it is convertible to `float32` without changing
    its value.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing floating-point numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because of how floating-point numbers are represented, there can be inconsistencies
    while comparing two numbers that appear to be identical. Unlike integers, IEEE
    floating-point numbers are only approximated. The need to convert the numbers
    to a form the computer can store in binary leads to minor precision or round-off
    deviations. For example, a value of 1.3 could be represented as 1.29999999999\.
    The comparison could be done with some tolerance. To compare numbers with arbitrary
    precision, the `big` package is here.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter03/recipe02`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `tolerance.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Execute the command `go run tolerance.go` in the Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ffd1275f-99b9-48e6-bafa-7c159fc14936.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create the file `big.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by running `go run big.go` in the Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0136243d-dd1c-46a6-8960-ab6da27dec7b.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first approach for the floating-point numbers comparison without the use
    of any built-in package (steps **1-5**) requires the use of a so-called `EPSILON`
    constant. This is the value chosen to be a sufficient small delta (difference)
    between two numbers to consider the values as equal. The delta constant could
    be on the order of 1e-8, which is usually sufficient precision.
  prefs: []
  type: TYPE_NORMAL
- en: The second option is more complex, but also more useful for further work with
    floating-point numbers. The package `math/big` offers the `Float` type that could
    be configured for a given precision. The advantage of this package is that the
    precision could be much higher than the precision of the `float64` type. For illustrative
    purposes, the small precision values were used to show the rounding and comparison
    in the given precision.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `da` and `db` numbers are equal when using the precision of 16-bits
    and not equal when using the precision of 32-bits. The maximal configurable precision
    can be obtained from the `big.MaxPrec` constant.
  prefs: []
  type: TYPE_NORMAL
- en: Rounding floating-point numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The rounding of a floating-point number to an integer or to a particular precision
    has to be done properly. The most common error is to cast the floating-point type
    `float64` to an integer type and consider it as well-handled.
  prefs: []
  type: TYPE_NORMAL
- en: An example could be casting the number 3.9999 to an integer and expect it to
    become an integer of value 4\. The real result would be 3\. At the time of writing
    this book, the current version of Go (1.9.2) does not contain the `Round` function.
    However, in version 1.10, the `Round` function was already implemented in the `math` package.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter03/recipe03`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `round.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by running `go run round.go` in the Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a221961c-c58e-4d32-b204-067f02439de8.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Casting the float to integer actually just truncates the float value. Let's
    say the value 2 is represented as 1.999999; in this case, the output would be
    1, which is not what you expected.
  prefs: []
  type: TYPE_NORMAL
- en: The proper way of rounding the float number is to use the function that would
    also consider the decimal part. The commonly used method of rounding is to half
    away from zero (also known as commercial rounding).Put simply, if the number contains
    the absolute value of the decimal part which is greater or equal to 0.5, the number
    is rounded up, otherwise, it is rounded down.
  prefs: []
  type: TYPE_NORMAL
- en: In the function `Round`, the function `Trunc` of package `math` truncates the
    decimal part of the number. Then, the decimal part of the number is extracted.
    If the value exceeds the limit of 0.5 than the value of 1 with the same sign as
    the integer value is added.
  prefs: []
  type: TYPE_NORMAL
- en: Go version 1.10 uses a faster implementation of the function mentioned in the
    example. In version 1.10, you can just call the `math.Round` function to get the
    rounded number.
  prefs: []
  type: TYPE_NORMAL
- en: Floating-point arithmetics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As described in previous recipes, the representation of the floating-point numbers
    also complicates the arithmetic. For general purposes, the operations on the built-in
    `float64` are sufficient. In case more precision is needed, the `math/big` package
    comes into play. This recipe will show you how to handle this.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter03/recipe04`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `main.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by running `go run main.go` in the Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3194fc9d-7405-422a-b8e4-02876be60b4a.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `big` package provides support for the arithmetic of floating-point numbers
    with high precision. The previous example illustrates the basic operations over
    the numbers. Note that the code compares the operation with the `float64` type
    and the `big.Float` type.
  prefs: []
  type: TYPE_NORMAL
- en: By working with numbers with a high precision, it is crucial to use the `big.Float` type.
    When `big.Float` is converted back to the built-in `float64` type, high precision
    is lost.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The big package contains more operations of the `Float` type. See the documentation
    ([https://golang.org/pkg/math/big/#Float](https://golang.org/pkg/math/big/#Float)) of
    this package for more details.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The comparison and rounding of floating-point numbers is mentioned in the *Comparing
    floating-point numbers* and *Rounding floating-point numbers* recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the numbers are converted to the string, they usually need to be reasonably
    formatted. The formatting of a number means the number is printed with a given
    number, made up of digits and decimals. The representation of a value can also
    be chosen. A closely related problem with this, however, is the localization of
    number formatting. For example, some languages use comma-separated zeros.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter03/recipe05`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `format.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by running `go run format.go` in the main Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cb4d778a-300d-4f9c-ad11-af183f0a73f9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create the file `localized.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by running `go run localized.go` in the main Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a019fad9-c657-4ab9-a5a7-ed653a3cb8e4.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code example shows the most commonly used options for integers and floating-point
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: The formatting in Go is derived from C's `printf` function. The so-called `verbs` are
    used to define the formatting of a number. The verb, for example, could be `%X`,
    which in fact is a placeholder for the value.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the basic formatting, there are also rules in formatting that are related
    to the local manners. With formatting, according to the locale, the package `golang.org/x/text/message`
    could help. See the second code example in this recipe. This way, it is possible
    to localize the number formatting.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For all formatting options, see the `fmt` package. The `strconv` package could
    also be useful in case you are looking to format numbers in a different base. The
    following recipe describes the possibility of number conversion, but as a side
    effect, the options of how to format numbers in a different base are presented.
  prefs: []
  type: TYPE_NORMAL
- en: Converting between binary, octal, decimal, and hexadecimal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some cases, the integer values can be represented by other than decimal representations.
    The conversion between these representations is easily done with the use of the `strconv`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter03/recipe06`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `convert.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by running `go run convert.go` in the main Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/79ef55f3-a6aa-4f4c-afc3-1cfc94405bd9.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `strconv` package provides the functions `ParseInt` and `FormatInt` which
    are the, let's say, complementary functions. The function `ParseInt` is able to
    parse the integer number in any base representation. The function `FormatInt`,
    on the other hand, can format the integer into any given base.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it is possible to parse the string representation of the integer to
    the built-in `int64` type and subsequently, format the string of the parsed integer
    into the given base representation.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting with the correct plurals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When displaying messages for the user, the interaction is more pleasant if the
    sentences feel more human. The Go package `golang.org/x/text`, which is the extension
    package, contains this feature for formatting plurals in the correct way.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Execute `go get -x golang.org/x/text` to obtain the extension package in case
    you don't have it already.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter03/recipe07`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `plurals.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by running `go run plurals.go` in the main Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/75073d10-7a06-4434-a380-68ebb5aca0ed.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The package `golang.org/x/text/message` contains the function `NewPrinter` which
    accepts the language identification and creates the formatted I/O, the same as
    the `fmt` package does, but with the ability to translate messages based on gender
    and plural forms.
  prefs: []
  type: TYPE_NORMAL
- en: The `Set` function of the `message` package adds the translation and plurals
    selection. The plural form itself is selected based on rules set via the `Selectf` function.
    The `Selectf` function produces the `catalog.Message` type with rules based on
    the `plural.Form` or selector.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding sample code uses `plural.One` and `plural.Other` forms, and `=x,
    <x` selectors. These are matched against the formatting verb `%d` (other verbs
    can also be used). The first matching case is chosen.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information about the selectors and forms, see the documentation for
    the `golang.org/x/text/message` package.
  prefs: []
  type: TYPE_NORMAL
- en: Generating random numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows how to generate random numbers. This functionality is provided
    by the `math/rand` package. The random numbers generated by `math/rand` are considered
    cryptographically insecure because the sequences are repeatable with given seed.
  prefs: []
  type: TYPE_NORMAL
- en: To generate cryptographically secure numbers, the `crypto/rand` package should
    be used. These sequences are not repeatable.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter03/recipe08`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `rand.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by running `go run rand.go` in the main Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e1ee4c40-cc18-430c-afa5-df69330e3611.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous code presents two possibilities on how to generate random numbers.
    The first option uses the `math/rand` package, which is cryptographically insecure,
    and allows us to generate the same sequence with the use of `Source` with the
    same seed number. This approach is usually used in tests. The reason for doing
    so is for the reproducibility of the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: The second option, the cryptographically secure one, is the use of the `crypto/rand`
    package. The API uses the `Reader` to provide the instance of a cryptographically
    strong pseudo-random generator. The package itself has the default `Reader` which
    is usually based on the system-based random number generator.
  prefs: []
  type: TYPE_NORMAL
- en: Operating complex numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Complex numbers are usually used for scientific applications and calculations.
    Go implements complex numbers as the primitive type. The specific operations on
    complex numbers are part of the `math/cmplx` package.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter03/recipe09`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `complex.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by running `go run complex.go` in the main Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8449d9d2-92ea-4486-bb15-1a3b0817cd1b.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basic operators are implemented for the primitive type `complex`. The other
    operations on complex numbers are provided by the `math/cmplx` package. In case
    high precision operations are needed, there is no `big` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the complex number could be implemented as real, and the
    imaginary part expressed by the `big.Float` type.
  prefs: []
  type: TYPE_NORMAL
- en: Converting between degrees and radians
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The trigonometric operations and geometric manipulation are usually done in
    radians; it is always useful to be able to convert these into degrees and vice
    versa. This recipe will show you some tips on how to handle the conversion between
    these units.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter03/recipe10`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `radians.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by running `go run radians.go` in the main Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/62ee5c8a-9b69-4fa2-bcea-affcc05b99b6.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Go standard library does not contain any package with a function converting
    radians to degrees and vice versa. But at least the Pi constant is a part of the `math`
    package, so the conversion could be done as shown in the sample code.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code also presents the approach of defining the custom type with
    additional methods. These are simplifying the conversion of values by handy API.
  prefs: []
  type: TYPE_NORMAL
- en: Taking logarithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logarithms are used in scientific applications as well as in data visualizations
    and measurements. The built-in `math` package contains the commonly used bases
    of the logarithm. Using these, you are able to get all bases.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter03/recipe11`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `log.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by running `go run log.go` in the main Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c9934563-74ce-4201-8e54-e604592356fd.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The standard package, `math`, contains functions for all commonly used logarithms,
    and so you can easily get binary, decimal, and natural logarithms. See the *Log* function
    which counts any logarithm of *y* with base *x* through the helper-defined formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e8c5979-71d4-41ab-986f-0fbe73a8998f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The internal implementation of the logarithm in standard lib is naturally based
    on approximation. This function can be seen in the `$GOROOT/src/math/log.go` file.
  prefs: []
  type: TYPE_NORMAL
- en: Generating checksums
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The hash, or so-called checksum, is the easiest way to quickly compare any content.
    This recipe demonstrates how to create the checksum of the file content. For demonstration
    purposes, the MD5 hash function will be used.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter03/recipe12`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `content.dat` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `checksum.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by running `go run checksum.go` in the main Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2cb3110e-966d-41d5-9e99-8d526fd63d71.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create the `sha_panic.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by running `go run sha_panic.go` in the main Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ae1c2f79-fe03-4ae9-aef3-7eabc74ae3d8.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `crypto` package contains implementations of well-known hash functions.
    The `MD5` hash function is located in the `crypto/md5` package. Each hash function
    in the `crypto` package implements the `Hash` interface.  Note that `Hash` contains
    the `Write`  method. With the `Write` method, it can be utilized as a `Writer`.
    This can be seen in the `FileMD5` function. The `Sum` method of `Hash` accepts
    the argument of byte slice, where the resulting hash should be placed.
  prefs: []
  type: TYPE_NORMAL
- en: Beware of this. The `Sum` method does not compute the hash of the argument,
    but computes the hash into an argument.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, `md5.Sum`, the package function, can be used to produce the
    hash directly. In this case, the argument of the `Sum` function is the one from
    the hash values computed.
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, the `crypto` package implements the `SHA` variants and other hash
    functions as well. These are usually used in the same way. The hash functions
    can be accessed through the `crypto` package constant `crypto.Hash` (for example, `crypto.MD5.New()`),
    but this way, the package with the given function must be linked to a built binary
    as well (the blank import could be used, `import _ "crypto/md5"`), otherwise the
    call for `New` will panic.
  prefs: []
  type: TYPE_NORMAL
- en: The `hash` package itself contains the CRC checksums and more.
  prefs: []
  type: TYPE_NORMAL
