- en: '[*Chapter 6*](B17385_06_PreFinal_PD_ePub.xhtml#_idTextAnchor074): Working with
    Skaffold Container Image Builders and Deployers'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we took a deep dive into the Skaffold CLI and its pipeline
    stages. We also looked at the Skaffold configuration. In this chapter, we will
    introduce you to reactive programming by creating a Reactive Spring Boot CRUD
    application. We will then learn about Skaffold's pluggable architecture, which
    supports different methods of building and deploying container images to a Kubernetes
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Reactive Spring Boot CRUD application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Skaffold container image builders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring Skaffold container image deployers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have gained a solid understanding of Skaffold's
    supported container image builders, including Jib, Docker, and Buildpacks. You
    will also learn about Helm, kubectl, and Kustomize, which are supported by Skaffold
    to help deploy your containerized application to Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with the examples in this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Helm ([https://helm.sh/docs/intro/install/](https://helm.sh/docs/intro/install/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kustomize ([https://kubectl.docs.kubernetes.io/installation/kustomize/](https://kubectl.docs.kubernetes.io/installation/kustomize/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eclipse ([https://www.eclipse.org/downloads/](https://www.eclipse.org/downloads/))
    or the IntelliJ IDE ([https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git ([https://git-scm.com/downloads](https://git-scm.com/downloads))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skaffold ([https://skaffold.dev/docs/install/](https://skaffold.dev/docs/install/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot 2.5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenJDK 16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: minikube ([https://minikube.sigs.k8s.io/docs/](https://minikube.sigs.k8s.io/docs/))
    or Docker Desktop for macOS and Windows ([https://www.docker.com/products/dockerdesktop](https://www.docker.com/products/dockerdesktop))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can download the code examples for this chapter from this book's GitHub
    repository at [https://github.com/PacktPublishing/Effortless-Cloud-Native-App-Development-Using-Skaffold/tree/main/Chapter06](https://github.com/PacktPublishing/Effortless-Cloud-Native-App-Development-Using-Skaffold/tree/main/Chapter06).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Reactive Spring Boot CRUD application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To demonstrate working with various container image builders that Skaffold supports,
    we will create a simple Reactive Spring Boot `CRUD` REST application. We expose
    a REST endpoint called `/employee` when the app is accessed locally through curl
    or a REST client such as Postman, which will return with employee data.
  prefs: []
  type: TYPE_NORMAL
- en: First, to build some context, let's discuss the reactive way of building an
    application. Reactive programming (https://projectreactor.io/) is a new way of
    building non-blocking applications that are asynchronous, event-driven, and require
    a small number of threads to scale. What also keeps them separate from typical
    non-reactive applications is that they can provide the backpressure mechanism
    to ensure producers don't overwhelm consumers.
  prefs: []
  type: TYPE_NORMAL
- en: Spring WebFlux is a reactive web framework that was introduced with Spring 5\.
    Spring WebFlux doesn't require a servlet container and can be run on non-blocking
    containers such as Netty and Jetty. We would need to add the `spring-boot-starter-webflux`
    dependency to add support for Spring WebFlux. With Spring MVC, we have Tomcat
    as the default embedded server, while with WebFlux, we get Netty. Spring WebFlux
    controllers typically return reactive types; that is, Mono or Flux instead of
    collections or domain objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the Maven dependencies that will be used for this Spring
    Boot application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Maven dependencies'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.1_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.1 – Maven dependencies
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by walking through the code of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have an employee table with five columns: `id`, `first_name`, `last_name`,
    `age`, and `salary`. The `id` column is auto-incremented. The other columns follow
    the default snake case naming scheme. The following `schema.sql` SQL file is available
    from the `src/main/resources/schema.sql` path, in the source code directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Since the H2 driver is on the classpath and we don't have to specify a connection
    URL, Spring Boot automatically starts an embedded H2 database at application startup.
  prefs: []
  type: TYPE_NORMAL
- en: 'To initialize the database schema at application startup, we also need to register
    `ConnectionFactoryInitializer` to pick up the `schema.sql` file, as mentioned
    in the following main class for our application. Here, we are also saving a few
    `Employee` entities that we can use later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'With Spring Data R2DBC, you don''t have to write an implementation of the repository
    interface as it creates an implementation for you at runtime. `EmployeeRepository`
    extends `ReactiveCrudRepository` and inherits various methods for saving, deleting,
    and finding employee entities using reactive types. Following is the CRUD repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is the `EmployeeService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following REST controller class, you can see that all the endpoints
    either return Flux or Mono reactive types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the `Employee` domain class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run this application with the `mvn spring-boot:run` command. You will
    see the following logs once the application is up and running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output after accessing the `/employee` REST endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – REST endpoint response'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.2_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.2 – REST endpoint response
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about the reactive programming model and created
    a Reactive Spring Boot CRUD application. In the next section, we will look at
    the different ways of containerizing your Java application with Skaffold.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Skaffold container image builders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From [*Chapter 3*](B17385_03_Final_PD_ePub.xhtml#_idTextAnchor034), *Skaffold
    – Easy-Peasy Cloud-Native Kubernetes Application Development*, we know that Skaffold
    currently supports the following container image builders:'
  prefs: []
  type: TYPE_NORMAL
- en: Dockerfile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jib (Maven and Gradle)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bazel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud-native Buildpacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: kaniko
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google Cloud Build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we will cover these in detail by using them with the Spring
    Boot application we just built in the previous section. Let's talk about Dockerfile
    first.
  prefs: []
  type: TYPE_NORMAL
- en: Dockerfile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docker is the gold standard for creating containers for many years. Even though
    there are many alternatives to Docker today, but it is still alive and kicking.
    Docker architecture depends on a daemon process that must be running to service
    all of your Docker commands. Then there is a Docker CLI that sent the commands
    to the Docker daemon for execution. The daemon process does what is required to
    push, pull, run container images, and so on. Docker expects a file called Dockerfile,
    handwritten by you, containing steps and instructions that it understands. This
    Dockerfile is then used to create a container image of your application with a
    command such as `docker build`. The advantage here is that this allows for a different
    customization level while making a container image of your application, as per
    your needs.
  prefs: []
  type: TYPE_NORMAL
- en: To build an image with Docker, we need to add a few instructions to our Dockerfile.
    Those instructions act as input, and then the Docker daemon process creates an
    image with those instructions. Let's look at an example to understand the working
    of a typical Dockerfile for a Java application.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Docker build flow'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.3_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.3 – Docker build flow
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the following Dockerfile to containerize our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code block, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `FROM` instruction indicates the base image for our application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `COPY` instruction, as the name suggests, will copy the local .jar file
    that was built by Maven into our image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ENTRYPOINT` instruction acts as an executable for our container while it's
    starting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `skaffold.yaml` file, we have added a new profile named `docker`. The
    following are the relevant parts of the `docker` profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We can run the build with the `skaffold dev –profile=docker` command. The output
    should be similar to what we saw previously in *Figure 6.2*.
  prefs: []
  type: TYPE_NORMAL
- en: Jib
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Jib** (https://github.com/GoogleContainerTools/jib) stands for **Java Image
    Builder** and is purely written in Java. You already know that Jib allows Java
    developers to build containers using build tools such as Maven and Gradle. However,
    it has a CLI tool that can be used for non-Java applications such as Python on
    Node.js.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The significant advantage of using Jib is that you don''t need to know anything
    about installing Docker or maintaining a Dockerfile. To containerize your Java
    application, you don''t have to go through countless Docker tutorials. Jib is
    daemonless. Furthermore, as Java developers, we only care about the artifact (that
    is, jar file), and with Jib, we don''t have to deal with any of the Docker commands.
    Using Jib, a Java developer can add the plugin to the build tool of their choice
    (Maven/Gradle), and with minimum configuration, you have your application containerized.
    Jib takes your application source code as input and outputs the container image
    of your application. Following is the build flow of your Java application with
    Jib:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Jib build flow'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.4_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.4 – Jib build flow
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to build the application we created in the previous section with
    Jib:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create the `skaffold.yaml` file using the Skaffold `init` command,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'Jib cleverly split your application image layers into the following for faster
    rebuilds:'
  prefs: []
  type: TYPE_NORMAL
- en: -Classes
  prefs: []
  type: TYPE_NORMAL
- en: -Resources
  prefs: []
  type: TYPE_NORMAL
- en: -Project Dependencies
  prefs: []
  type: TYPE_NORMAL
- en: -Snapshot and all other dependencies
  prefs: []
  type: TYPE_NORMAL
- en: The goal is to separate files that often change as compared to the ones which
    are rarely changed. The immediate benefit is that you don't have to rebuild the
    entire application because Jib only rebuilds the layer containing the changed
    files and reuse cached layers for files that didn't change.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Jib, you might see the following warning in logs if you don''t specify
    the image digest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[WARNING] Base image `''adoptopenjdk/openjdk16''` does not use a specific image
    `digest - build` may not be reproducible.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can overcome this by using the proper image digest. For example, in `maven-jib-plugin`,
    you can make the following changes, while in the `skaffold.yaml` file, you can
    specify the image digest:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<plugin>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`   <groupId>com.google.cloud.tools</groupId>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`   <artifactId>jib-maven-plugin</artifactId>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`   <version>3.1.1</version>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`   <configuration>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`      <from>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`<image>adoptopenjdk/openjdk16@           sha256:b40f81a9f7e7e4533ed0c` `           6ac794ded9f653807f757e2b8b4e1
               fe729b6065f7f5</image>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`      </from>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`      <to>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`         <image>docker.io/hiashish/image</image>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`      </to>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`   </configuration>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`</plugin>`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the Kubernetes service manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is the Kubernetes deployment manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we must run the `skaffold dev` command. The following is the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'With minikube, we can use the `minikube service reactive-web-app` command to
    open the exposed service. We will use the URL mentioned in the following screenshot
    to access our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Exposed service URL'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.5_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.5 – Exposed service URL
  prefs: []
  type: TYPE_NORMAL
- en: After accessing the `http://127.0.0.1:55174/employee` URL, we should get an
    output similar to *Figure 6.2*.
  prefs: []
  type: TYPE_NORMAL
- en: Bazel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Bazel is an open source, multilanguage, fast, and scalable build tool similar
    to Maven and Gradle. Skaffold provides support for Bazel and it can load images
    to the local Docker daemon. Bazel requires two files: `WORKSPACE` and `BUILD`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `WORKSPACE` file is typically available at the root directory of your project.
    This file indicates the Bazel workspace. It looks for build inputs and stores
    the build output in the directory where the `WORKSPACE` file was created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `BUILD` file instructs Bazel on what to build and how to build different
    parts of your project. The following is an example of a `BUILD` file for a Java
    application. In this example, we are instructing Bazel to use the `java_binary`
    rule to create a `.jar` file for our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To build your project, you can run commands such as `build //: ReactiveWebApp`.
    The following is the `skaffold.yaml` file, which contains a `bazel` profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Next we have Buildpacks.
  prefs: []
  type: TYPE_NORMAL
- en: Buildpacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Heroku first created Buildpacks ([https://buildpacks.io/](https://buildpacks.io/))
    in 2011\. It is now part of the CNCF foundation. Just like Jib, Buildpacks can
    also work without the need for a Dockerfile. However, you will need a Docker daemon
    process up and running for it to work. With Buildpacks, the input is your application
    source code, and the output is the container image. It's pretty similar to Jib
    in this respect, though Jib can work without a Docker daemon.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the background, Buildpacks does a lot of work, including retrieving dependencies,
    processing assets, handling caching, and compiling code for whatever language
    your app has been built in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Buildpacks build flow'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.6_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.6 – Buildpacks build flow
  prefs: []
  type: TYPE_NORMAL
- en: As explained earlier, Skaffold requires a local Docker daemon to build an image
    with Buildpacks. Skaffold will execute the build inside a container using the
    builder specified in the Buildpacks configuration of your `skaffold.yaml` file.
    Also, you don't have to install the pack CLI as the Google Cloud Buildpacks project
    ([https://github.com/GoogleCloudPlatform/buildpacks](https://github.com/GoogleCloudPlatform/buildpacks))
    provides builder images for tools such as Skaffold. You can choose to skip this,
    but upon successfully building it, Skaffold will push the image to the remote
    registry.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with Spring Boot version 2.3, Spring Boot includes direct Buildpacks
    support for both Maven and Gradle projects. With the `mvn spring-boot:build-image`
    command, you can create an image of your application that''s loaded to your locally
    running Docker daemon. Although you are not required to maintain a Dockerfile,
    Buildpacks depends on the Docker daemon process. If you don''t have the Docker
    daemon running locally, you will get the following error while executing the Maven
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Failed to execute goal org.springframework.boot:spring-boot-maven-plugin:2.4.2:build-image
    (default-cli) on project imagebuilder: Execution default-cli of goal org.springframework.boot:spring-boot-maven-plugin:2.4.2:build-image
    failed: Connection to the Docker daemon at ''localhost'' failed with error "[61]
    Connection refused"; ensure the Docker daemon is running and accessible`'
  prefs: []
  type: TYPE_NORMAL
- en: 'To build our application with Buildpacks, we have added a new profile `name`
    of `pack` and used that to add a new `build` section to the `skaffold.yaml` configuration
    file. In the `builder` field, we are instructing Skaffold to use the `gcr.io/buildpacks/builder:v1`  builder
    image. The following are the relevant parts of the configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We can run the build with the `skaffold dev –profile=pack` command. The output
    should be similar to what we saw in *Figure 6.2*.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Boot Buildpacks integration can be used to push an image to a remote
    container registry. We would need to make the following changes in `pom.xml` to
    do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Custom script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use the custom script option if none of the supported container image
    builders work for your use case. With this option, you can write custom scripts
    or choose a build tool of your liking. You can configure a custom script by adding
    a custom field to each corresponding artifact in the build section of the `skaffold.yaml`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example `skaffold.yaml` file, we have created a new profile
    named `custom`. In the `buildCommand` field, we have used the `build.sh` script
    to containerize our Spring Boot application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `build.sh` script file contains the following content. It uses the `docker
    build` command to create an image of our application. Skaffold will supply `$IMAGE`
    (that is, the fully qualified image name environment variable) to the custom build
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Next we move to kaniko.
  prefs: []
  type: TYPE_NORMAL
- en: kaniko
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**kaniko** is an open source tool that''s used to build container images from
    a Dockerfile inside a container or Kubernetes cluster. kaniko doesn''t require
    privileged root access to build container images.'
  prefs: []
  type: TYPE_NORMAL
- en: kaniko has no dependency on a Docker daemon and executes each command within
    a Dockerfile entirely in the user space. With kaniko, you can start building container
    images in environments that can't securely run a Docker daemon, such as a standard
    Kubernetes cluster. So, how does kaniko work? Well, kaniko uses an executor image
    called `gcr.io/kaniko-project/executor`, and this image runs inside a container.
    It is not recommended to run the kaniko executor binary in another image as it
    might not work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the following Dockerfile with kaniko to build the container image
    of our application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the relevant part of `skaffold.yaml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have added a new profile called `kaniko` to build our container images
    inside the Google Kubernetes cluster. You will learn more about GKE in [*Chapter
    8*](B17385_08_Final_PD_ePub.xhtml#_idTextAnchor099), *Deploying a Spring Boot
    Application to Google Kubernetes Engine Using Skaffold*.
  prefs: []
  type: TYPE_NORMAL
- en: 'An important point to highlight in this `skaffold.yaml` file is that we would
    need a credential from the active Kubernetes cluster to build our image inside
    the cluster. For that, a GCP service account is required. This account has a storage
    admin role so that images can be pulled and pushed. We can use the following command
    to build and deploy our application to GKE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be using a remote Kubernetes cluster hosted on GCP for this demo. Let''s
    get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create a service account for kaniko with permissions to pull
    and push images from/to `gcr.io`. Then, we need to download the JSON service account
    file and rename the file `kaniko-secret`. Also, make sure that you do not append
    `.json` to the filename; create a Kubernetes secret using the following command.
    You need to make sure that the Kubernetes context is set to a remote Kubernetes
    cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we are going to push the image to **Google Container Registry** (**GCR**),
    we have mentioned the `–default-repo` flag so that it always points to GCR. The
    following are the logs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following logs, you can see that kaniko started building images inside
    the container by downloading base images for different stages of the build. kaniko
    started packaging and downloading the dependencies for our Spring Boot application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following logs, you can see that the build was successful and that kaniko
    was able to push the image to GCR. Then, we deployed the image to the Google Kubernetes
    cluster using `kubectl`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following screenshot, we can see that after the deployment, a pod is
    running and that the service that''s been exposed is of the **Load balancer**
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – Pod running and the service exposed for external access'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.7_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.7 – Pod running and the service exposed for external access
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the output after accessing the `/employee` REST endpoint of
    our Spring Boot application using the endpoints exposed by GKE:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – REST application response'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.8_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.8 – REST application response
  prefs: []
  type: TYPE_NORMAL
- en: Google Cloud Build
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cloud Build is a service that runs your build using GCP infrastructure. Cloud
    Build works by importing source code from various repositories or Google Cloud
    Storage spaces, executing a build, and producing artifacts such as container images.
  prefs: []
  type: TYPE_NORMAL
- en: 'We created a new profile named `gcb` in `skaffold.yaml` to trigger the remote
    build of our application using Google Cloud Build. The following is the relevant
    part of the `skaffold.yaml` profile section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run the following command to start the remote build of our application
    with Google Cloud Build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If this is your first time doing this, make sure that you have enabled the
    Cloud Build API, either from the **Cloud Console** dashboard or through the gcloud
    CLI. Otherwise, you may get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You can enable the Cloud Build API via the **Cloud Console** dashboard by visiting
    the URL mentioned in the error logs and clicking on the **ENABLE** button, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9 – Enabling the Cloud Build API'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.9_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.9 – Enabling the Cloud Build API
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to make sure that, in your `kubeconfig` file, the GKE remote cluster
    is the active cluster for this deployment before running the actual command to
    start the build and deployment process. The following is the output of the `skaffold
    run` command. In the following logs, you can see that our entire source code is
    packaged as a `tar.gz` file and sent to the Google Cloud Storage location. From
    there, Cloud Build picks it and starts building our image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following logs, you can see that the image has been built, tagged, and
    pushed to GCR. Then, using `kubectl`, the application is deployed to GKE, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the **Workload** section of GKE, you can see that **reactive-web-app** has
    been deployed and that its status is OK, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10 – Application deployed successfully on GKE'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.10_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.10 – Application deployed successfully on GKE
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about the different ways we can containerize our
    Reactive Spring Boot CRUD application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore different ways to deploy an application
    to Kubernetes with Skaffold.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Skaffold container image deployers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will look at the container image deployment methods supported
    by Skaffold. With Skaffold, you can deploy your application to Kubernetes using
    the following three tools:'
  prefs: []
  type: TYPE_NORMAL
- en: Helm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: kubectl
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kustomize
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's discuss them in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Helm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Helm** is the package manager, and **charts** are the packages for your Kubernetes
    applications. It allows you to define, install, and update your Kubernetes application
    easily. You can write charts for your applications or use production-ready, pre-packaged
    charts for popular software such as MySQL and MongoDB from a stable chart repository.'
  prefs: []
  type: TYPE_NORMAL
- en: Until Helm 2, Helm followed a client-server architecture. However, due to significant
    changes being made to the architecture with Helm 3, it is a client-only architecture.
    Therefore, there is no need to have a server-side component such as **Tiller**
    installed on your Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s learn more about Helm:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Skaffold will not install Helm for us, so we must install it using the Homebrew
    package manager for macOS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'For Windows, you can download it using chocolatey:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also download Helm using an installer script, which will download the
    latest version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will create a Helm chart skeleton using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We will create a new Skaffold profile called `jibWithHelm` to build an image
    with Jib and then deploy it using Helm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here, the image name under the `build` section should match the image name given
    under the `artifactOverrides` section of the `skaffold.yaml` file. Otherwise,
    you will get an error.
  prefs: []
  type: TYPE_NORMAL
- en: We have also provided the path to the `values.yaml` file under the `valuesFiles`
    section of the `skaffold.yaml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The typical convention for defining image references with Helm is through the
    `values.yaml` file. The following is the content of the `values.yaml` file that
    will be referenced by Helm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The values in the `values.yaml` file will be referenced inside a templated
    resource file, as shown in the following code snippet. This templated file is
    located inside `reactive-web-app-helm/templates/**.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'After running `skaffold run --profile=jibWithHelm`, Skaffold will build the
    image using Jib and deploy it to GKE using Helm charts. This will result in the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can verify whether the pods are running by going to the **Workloads** section
    of GKE. In the following screenshot, we can see that we have a pod running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11 – Helm Charts deployed successfully on GKE'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.11_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.11 – Helm Charts deployed successfully on GKE
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, under the **Services & Ingress** section, we can see that an **External
    load balancer** type of service has been exposed for external access:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12 – LoadBalancer service type exposed on GKE'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.12_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.12 – LoadBalancer service type exposed on GKE
  prefs: []
  type: TYPE_NORMAL
- en: After accessing the application using the URL mentioned in the **Endpoints**
    column, the output should be similar to what we saw in *Figure 6.2*.
  prefs: []
  type: TYPE_NORMAL
- en: kubectl
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: kubectl is a command-line tool that's used to run commands on your Kubernetes
    cluster. It interacts with the Kubernetes API Server to run those commands. You
    can use it to accomplish various tasks, such as viewing logs of a pod, create
    Kubernetes
  prefs: []
  type: TYPE_NORMAL
- en: 'resources such as deployments, find out about the state of your cluster, and
    pods among others. In the following code snippet, you can see that we are using
    kubectl for deployment purposes. The Kubernetes manifests are under the `k8s`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Kustomize
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kustomize, as its name suggests, is a template-free declarative approach to
    Kubernetes configuration, management, and customization options. With Kustomize,
    we provide a base skeleton and patches. In this approach, compared to Helm, we
    provide a base deployment and then describe the differences for different environments.
    For example, we can have different numbers of replicas and health checks for production
    as compared to staging. Kustomize can installed separately and since version 1.14
    of kubectl, we can use the `-k` command. Follow the instructions mentioned at
    [https://kubectl.docs.kubernetes.io/installation/kustomize/](https://kubectl.docs.kubernetes.io/installation/kustomize/)
    to install it on your supported OS.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we have a profile called `kustomizeProd` and are
    using Kustomize as the deployment strategy for our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We must have the following directory structure for Kustomize to work properly.
    In the following directory, you can see that under the `kustomization/base` directory,
    we have our original YAML files describing the resources we want to deploy in
    the GKE cluster. We will never touch these files; instead, we will just apply
    customization above them to create new resources definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a file named `kustomization.yaml` inside this `base` folder. It describes
    the resources you use. The resources are the paths to the Kubernetes manifests
    files relative to the current file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have the `kustomization/overlays/prod` folder, which has a `kustomization.yaml`
    file inside it. It contains the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: If you can see, in `base`, we didn't define any environment variables, a replicas
    count, or resource constraints. But for production scenarios, we must add those
    things above our base. To do so, we just have to create the chunk of YAML we would
    like to apply above our base and reference it inside the `kustomization.yaml`
    file. We have already added this YAML to the list of `patchesStrategicMerge` in
    the `kustomization.yaml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `increase_replica.yaml` file contains two replicas and looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `resources_constraint.yaml` file contains the resource request and limit
    and looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can run the `skaffold run --profile=kustomizeProd --default-repo=gcr.io/basic-curve-316617`
    command. This will deploy the application to GKE using Kustomize. The output we
    get should be similar to what we saw previously in *Figure 6.2*.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we looked at the tools we can use with Skaffold to deploy applications
    to a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started by introducing ourselves to reactive programming
    and built a Spring Boot CRUD application. We were also introduced to Skaffold's
    supported container image builders, including Docker, kaniko, Jib, and Buildpacks.
    We covered them by looking at their practical implementations. We also discussed
    the different ways we can deploy images to a Kubernetes cluster using tools such
    as kubectl, Helm, and Kustomize.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we gained a solid understanding of tools such as Jib, kaniko,
    Helm, and Kustomize, to name a few. You can apply your knowledge of these tools
    to build and deploy your containers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will build and deploy a Spring Boot application to Kubernetes
    using Google's Cloud Code extension.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about Skaffold, take a look at the Skaffold documentation: [https://skaffold.dev/docs/](https://skaffold.dev/docs/).'
  prefs: []
  type: TYPE_NORMAL
