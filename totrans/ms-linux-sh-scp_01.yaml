- en: Chapter 1. What and Why of Scripting with Bash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Welcome to the what and why of bash scripting. My name is Andrew Mallett and
    I am a bash scripting junkie or perhaps more accurately: a scripting junkie. As
    an administrator, I fail to see the need to do repetitive tasks manually. We get
    time for more interesting things when we choose scripts to carry out the laborious
    tasks that we don''t like. In this chapter, we will introduce you to the what
    and why of bash scripting. If you are new, it will help you become familiar with
    scripts and also provide some great insights for those with more experience and
    who want to improve their skills. As we make our way through the chapter, each
    element is designed to be added to your knowledge to help you achieve your goals.
    While doing so, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Bash vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bash command hierarchy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing text editors for scripting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and executing scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging your scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bash vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this book, I will be working entirely on a Raspberry Pi 2 running Raspbian,
    a Linux distribution similar to Debian, and Ubuntu; although for you, the operating
    system you choose to work with is immaterial, in reality, as is the version of
    bash. The bash version I am using is 4.2.37(1). If you are using the OS X operating
    system, the default command line environment is **bash**.
  prefs: []
  type: TYPE_NORMAL
- en: 'To return the operating system being used, type the following command if it
    is installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from my system is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bash vulnerabilities](img/00002.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The easiest way to determine the version of bash that you are using is to print
    the value of a variable. The following command will display your bash version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot displays the output from my system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bash vulnerabilities](img/00003.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In 2014, there was a well-publicized bug within bash that had been there for
    many years—the shell-shock bug. If your system is kept up-to-date, then it is
    not likely to be an issue but it is worth checking. The bug allows malicious code
    to be executed from within a malformed function. As a standard user, you can run
    the following code to test for the vulnerabilities on your system. This code comes
    from Red Hat and is not malicious but if you are unsure then please seek advice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code from Red Hat to test for the vulnerability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If your system is free from this first vulnerability the output should be as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bash vulnerabilities](img/00004.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To test for the last vulnerability from this bug, we can use the following
    test, which is again from Red Hat:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from a patched version of bash should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bash vulnerabilities](img/00005.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If the output from either of these command lines is different, then your system
    may be vulnerable to shell-shock and I would update bash or at least take further
    advice from a security professional.
  prefs: []
  type: TYPE_NORMAL
- en: The bash command hierarchy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working on at the bash shell and when you are sitting comfortably at your
    prompt eagerly waiting to type a command, you will most likely feel that it is
    a simple matter of typing and hitting the *Enter* key. You should know better
    than to think that things are never quite as simple as we imagine.
  prefs: []
  type: TYPE_NORMAL
- en: Command type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For example, if we type and enter `ls` to list files, it will be reasonable
    to think that we were running the command. It is possible, but we will be running
    an alias often. Aliases exist in memory as a shortcut to commands or commands
    with options; these aliases are used before we even check for the file. The bash
    shell built-in command `type` can come to our aid here. The `type` command will
    display the type of command for a given word entered at the command line. The
    types of command is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Alias
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shell built in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This list is also a representative of the order in which they are searched.
    As we can see, it is not until the very end where we search for the executable
    file `ls`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command demonstrates the simple use type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can extend this further to display all the matches for the given command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need to just type in the output, we can use the `-t` option. This is
    useful when we need to test the command type from within a script and only need
    the type to be returned. This excludes the superfluous information; thus, making
    it easier for us humans to read. Consider the following command and output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The output is clear and simple and just what a computer or script requires.
  prefs: []
  type: TYPE_NORMAL
- en: 'The built-in `type` can also be used to identify shell keywords such as if,
    case, function, and so on. The following command shows type being used against
    multiple arguments and types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Command type](img/00006.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can also see that the function definition is printed when we stumble across
    a function when using `type`.
  prefs: []
  type: TYPE_NORMAL
- en: Command PATH
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Linux will check for executables in the `PATH` environment only when the full
    or relative path to the program is supplied. In general, the current directory
    is not searched unless it is in the `PATH`. It is possible to include our current
    directory within the `PATH` by adding the directory to the `PATH` variable. This
    is shown in the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This appends the current directory to the value of the `PATH` variable each
    item the `PATH` is separated using the colon. Now, your `PATH` is updated to include
    the current working directory and each time you change directories, the scripts
    can be executed easily. In general, organizing scripts into a structured directory
    hierarchy is probably a great idea. Consider creating a subdirectory called `bin`
    within your home directory and add the scripts into that folder. Adding `$HOME/bin`
    to your `PATH` variable will enable you to find the scripts by name and without
    the file path.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command-line list will only create the directory, if it does
    not already exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Although the above command-line list is not strictly necessary, it does show
    that scripting in bash is not limited to the actual script and we can use conditional
    statements and other syntax directly at the command line. From our viewpoint,
    we know that the preceding command will work whether you have the `bin` directory
    or not. The use of the `$HOME` variable ensures that the command will work without
    considering your current file system context.
  prefs: []
  type: TYPE_NORMAL
- en: As we work through the book, we will add scripts into the `$HOME/bin` directory
    so that they can be executed regardless of our working directory.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing text editors for scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the book, I will be working on the command line of Raspberry Pi and
    this will include the creation and editing of the scripts. You, of course, can
    choose the way you wish to edit your script and may prefer to make use of a graphical
    editor and I will show some settings in gedit. I will make one excursion to a
    Red Hat system to show screenshots of gedit in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: To help make the command line editor easier to use, we can enable options and
    we can persist with these options through hidden configuration files. The gedit
    and other GUI editors and their menus will provide similar functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring vim
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Editing the command line is often a must and is a part of my everyday life.
    Setting up common options that make life easier in the editor give us the reliability
    and consistency you need, a little like scripting itself. We will set some useful
    options in the vi or vim editor file, `$HOME/.vimrc`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The options we set are detailed in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**showmode**: Ensures we see when we are in insert mode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**nohlsearch**: Does not highlight the words that we have searched for'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**autoindent**: We indent our code often; this allows us to return to the last
    indent level rather than the start of a new line on each carriage return'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**tabstop=4**: Sets a tab to be four spaces'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**expandtab**: Converts tabs to spaces, which is useful when the file moves
    to other systems'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**syntax on**: Note that this does not use the set command and is used to turn
    on syntax highlighting'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When these options are set, the `$HOME/.vimrc` file should look similar to
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Configuring nano
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The nano text edit is increasing in importance and it is the default editor
    in many systems. Personally, I don''t like the navigation or the lack of navigation
    features that it has. It can be customized in the same way as vim. This time we
    will edit the `$HOME/.nanorc` file. Your edited file should look something like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The last line enables syntax highlighting for shell scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring gedit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Graphical editors, such as gedit, can be configured using the preferences menu
    and are pretty straight forward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enabling tab spacing to be set to **4** spaces and expanding tabs to spaces
    can be done using the **Preference** | **Editor** tab, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring gedit](img/00007.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another very useful feature is found on the **Preferences** | **Plugins** tab.
    Here, we can enable the **Snippets** plugin that can be used to insert code samples.
    This is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring gedit](img/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: For the rest of the book, we will be working on the command line in and in vim;
    feel free to use the editor that you work with best. We have now laid the foundations
    to create good scripts and although whitespace, tabs, and spaces in bash scripts
    are not significant; a well laid out file with consistent spacing is easy to read.
    When we look at Python later in the book, you will realize that in some languages
    the whitespace is significant to the language and it is better to adopt the good
    habits early.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and executing scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our editors primed and ready, we can now move quickly to creating and executing
    our scripts. If you are reading this book with some prior experience, I will warn
    you that we are going to start with the basics but we will also include looking
    at positional parameters; feel free to move on at your own pace.
  prefs: []
  type: TYPE_NORMAL
- en: Hello World!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you know, it is almost obligatory to begin with a `hello world` script and
    we will not disappoint as far as this is concerned. We will begin by creating
    a new script `$HOME/bin/hello1.sh`. The contents of the file should read as in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hello World!](img/00009.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: I am hoping that you haven't struggled with this too much; it is just three
    lines after all. I encourage you to run through the examples as you read to really
    help you instill the information with a good hands-on practice.
  prefs: []
  type: TYPE_NORMAL
- en: '`#!/bin/bash`: Normally, this is always the first line of the script and is
    known as the shebang. The shebang starts with a comment but the system still uses
    this line. A comment in a shell script has the `#` symbol. The shebang instructs
    the system to the interpreter to execute the script. We use bash for shell scripts
    and we may use PHP or Perl for other scripts, as required. If we do not add this
    line, then the commands will be run within the current shell; it may cause issues
    if we run another shell.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`echo "Hello World"`: The `echo` command will be picked up in a built-in shell
    and can be used to write a standard output, `STDOUT`, this defaults to the screen.
    The information to print is enclosed in double-quotes, there will be more on quotes
    later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exit 0`: The `exit` command is a built in shell and is used to leave or exit
    the script. The `exit` code is supplied as an integer argument. A value of anything
    other than `0` will indicate some type of error in the script''s execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing the script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the script saved in our `PATH` environment, it still will not execute
    as a standalone script. We will have to assign and execute permissions for the
    file, as needed. For a simple test, we can run the file directly with bash. The
    following command shows you how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We should be rewarded with the `Hello World` text being displayed back on our
    screens. This is not a long-term solution, as we need to have the script in the
    `$HOME/bin` directory, specifically, to make the running of the script easy from
    any location without typing the full path. We need to add in the execute permissions
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We should now be able to run the script simply, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Executing the script](img/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Checking the exit status
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This script is simple but we still have to know how to make use of the exit
    codes from scripts and other applications. The command-line list that we generated
    earlier while creating the `$HOME/bin` directory, is a good example of how we
    can use the exit code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, `command2` is executed only if `command1` fails in
    some way. To be specific, `command2` will run if `command1` exits with a status
    code other than `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, in the following extract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We will only execute `command2` if `command1` succeeds and issues an exit code
    of `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To read the exit code from our script explicitly, we can view the `$?`variable,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The expected output is `0`, as this is what we have added to the last line of
    the file and there is precious little else that can go wrong causing us to fail
    in reaching that line.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring a unique name
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can now create and execute a simple script but we need to consider the name
    a little. In this case, `hello1.sh` is going to be good enough and is unlikely
    to clash with anything else on the system. We should avoid using names that may
    clash with existing aliases, functions, keywords, and building commands, as well
    as, avoid names of programs already in use.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the `sh` suffix to the file does not guarantee the name to be unique
    but in Linux, where we do not file extensions, the suffix is a part of the file
    name. This helps you to provide a unique identity to your script. Additionally,
    the suffix is used by the editor to help you identify the file for syntax highlighting.
    If you recall, we specifically added the syntax highlighting file `sh.nanorc`
    to the nano text editor. Each of these files is specific to a suffix and subsequent
    language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Referring back to the command hierarchy within this chapter, we can use a type
    to determine the location and type of file `hello.sh` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'These commands and output can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ensuring a unique name](img/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Hello Dolly!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is possible that we might need a little more substance in the script than
    a simple fixed message. Static message content does have its place but we can
    make this script much more useful by building some flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at positional parameters or arguments that we
    can supply to the script and in the next chapter we will see how we can make the
    script interactive and also prompt the user for input at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Running the script with arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can run the script with arguments, after all it''s a free world and Linux
    promotes your freedom to do what you want to do with the code. However, if the
    script does not make use of the arguments, then they will be silently ignored.
    The following code shows the script running with a single argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The script will still run and will not produce an error. The output will not
    change either and will print hello world:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument Identifier | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `$0` | The name of the script itself and is often used in usage statements.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `$1` | Positional argument, the first argument passed to the script. |'
  prefs: []
  type: TYPE_TB
- en: '| `${10}` | Where two or more digits are needed to represent the argument position.
    Brace brackets are used to delimit the variable name from any other content. Single
    value digits are expected. |'
  prefs: []
  type: TYPE_TB
- en: '| `$#` | Argument count is especially useful when we need to set the amount
    of arguments needed for correct script execution. |'
  prefs: []
  type: TYPE_TB
- en: '| `$*` | Refers to all arguments. |'
  prefs: []
  type: TYPE_TB
- en: 'For the script to make use of the argument, we can change the script content
    a little. Let''s first copy the script, add in the execute permissions, and then
    edit the new `hello2.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We need to edit the `hello2.sh` file to make use of the argument as it is passed
    at the command line. The following screenshot shows the simplest use of command
    line arguments allowing us now to have a custom message.
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the script with arguments](img/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the script now, we can provide an argument as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should now say **Hello fred**. If we do not provide an argument
    then the variable will be empty and will just print **Hello**. You can refer to
    the following screenshot to see the execution argument and output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the script with arguments](img/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we adjust the script to use `$*`, all the arguments will print. We will
    see **Hello** and then a list of all the supplied arguments. If we edit the script
    and replace the `echo` line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the script with the following arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Will result in the output shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the script with arguments](img/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If we want to print `Hello <name>`, each on separate lines, we will need to
    wait a little until we cover the looping structures. A for loop will work well
    to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of correct quotes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, we have used a simple double quoting mechanism to encase the strings
    that we want to use with echo.
  prefs: []
  type: TYPE_NORMAL
- en: In the first script, it does not matter if we use single or double quotes. The
    `echo "Hello World"` will be exactly the same as `echo 'Hello World'`.
  prefs: []
  type: TYPE_NORMAL
- en: However, this will not be the case in the second script so it is very important
    to understand the quoting mechanisms available in bash.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, using the double quotes `echo "Hello $1"` will result in **Hello
    fred** or whatever the supplied value is. Whereas, if we use single quotes `echo
    'Hello $1'` the printed output on the screen will be **Hello $1**, where we see
    the variable name and not its value.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of the quotes is to protect the special character such as a space between
    the two words; both quotes protect the space from being interpreted. The space
    is normally read as a default field, separated by the shell. In other words, all
    characters are read by the shell as literals with no special meaning. This has
    the knock on effect of the `$` symbol printing its literal format rather than
    allowing bash to expand its value. The bash shell is prevented from expanding
    the variable's value, as it is protected by the single quotes.
  prefs: []
  type: TYPE_NORMAL
- en: This is where the double quote comes to our rescue. The double quote will protect
    all the characters except the `$`, allowing bash to expand the stored value.
  prefs: []
  type: TYPE_NORMAL
- en: If we ever need to use a literal `$` within the quoted string along with variables
    that need to be expanded; we can use double quotes but escape the desired `$`
    with the backslash (`\`). For example, `echo "$USER earns \$4"` would print as
    **Fred earns $4** if the current user was Fred.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try the following examples at the command line using all quoting mechanisms.
    Feel free to up your hourly rate as required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The importance of correct quotes](img/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Printing the script name
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `$0` variable represents the script name and this is often used in usage
    statements. As we are not yet looking at conditional statements, we will have
    the script name printed above the displayed name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit your script so that it reads as the following complete code block for
    `$HOME/bin/hello2.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from the command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Printing the script name](img/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we prefer not to print the path and only want the name of the script to
    show we can use the `basename` command, which extracts the name from the path.
    Adjusting the script so that the second line now reads is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `$(….)` syntax is used to evaluate the output of the inner command. We first
    run `basename $0` and feed the result into an unnamed variable represented by
    the `$`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new output will appear as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Printing the script name](img/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'It is possible to achieve the same results using back quotes, this is less
    easy to read but we have mentioned this as you might have to understand and modify
    the scripts that have been written by others. The alternative to the `$(….)` syntax
    is shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the characters used are back quotes and *NOT* single quotes.
    On UK and US keyboards, these are found in the top-left section next to the number
    *1* key.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging your scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the scripts as simple as we have seen so far, there is little that can
    go wrong or debug. As the script grows and decision paths are included with conditional
    statements, we may need to use some level of debugging to analyze the scripts
    progress better.
  prefs: []
  type: TYPE_NORMAL
- en: Bash provides two options for us, `-v` and `-x`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to look at the verbose output from our script and the detailed information
    about the way the script is evaluated line by line, we can use the `-v` option.
    This can be within the shebang but it is often easier to run the script directly
    with bash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This is especially useful in this example as we can see how each element of
    the embedded `basename` command is processed. The first step is removing the quotes
    and then the parentheses. Take a look at the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging your scripts](img/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'More commonly used is the `-x` option, which displays the commands as they
    get executed. Its useful to know the decision branch that has been chosen by the
    script. The following shows this in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We again see that the `basename` is evaluated first, but we do not see the
    more detailed steps involved in running that command. The screenshot that follows
    captures the command and output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging your scripts](img/00019.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This marks the end of the chapter and I am sure that you might have found this
    useful. Especially for those making a start with bash scripting, this chapter
    must have built a firm foundation on which you can build your knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: We began by ensuring that bash is secure and not susceptible to embedded functions
    shell-shock. With bash secured, we considered the execution hierarchy where aliases,
    functions, and so on are checked before the command; knowing this can help us
    plan a good naming structure and a path to locate the scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Soon we were writing simple scripts with static content but we saw how easy
    it was to add flexibility using arguments. The exit code from the script can be
    read with the `$?` variable and we can create a command line list using `||` and
    `&&`, which depends on the success or failure of the preceding command in the
    list.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we closed the chapter by looking at debugging the script. Its not really
    required when the script is trivial, but it will be useful later when complexity
    is added.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be creating interactive scripts that read the user's
    input during script execution.
  prefs: []
  type: TYPE_NORMAL
