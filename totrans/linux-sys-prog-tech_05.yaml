- en: '*Chapter 5*: Working with File I/O and Filesystem Operations'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第5章*：使用文件I/O和文件系统操作'
- en: File I/O is an important part of system programming since most programs must
    read or write data to and from files. Doing file I/O also requires the developer
    to know a thing or two about the filesystem.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 文件I/O是系统编程的重要部分，因为大多数程序必须从文件中读取或写入数据。进行文件I/O还要求开发人员对文件系统有所了解。
- en: Mastering file I/O and filesystem operations will make you not only a better
    programmer but also a better system administrator.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 精通文件I/O和文件系统操作不仅会使您成为更好的程序员，还会使您成为更好的系统管理员。
- en: In this chapter, we will learn about the Linux filesystem and inodes. We will
    also learn how to read and write files on the system, using both streams and file
    descriptors. We will also look at system calls to create and delete files and
    change file permissions and ownership. At the end of the chapter, we will learn
    how to fetch information about files.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习Linux文件系统和inode。我们还将学习如何使用流和文件描述符在系统上读取和写入文件。我们还将查看系统调用以创建和删除文件，并更改文件权限和所有权。在本章末尾，我们将学习如何获取有关文件的信息。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Reading inode information and learning the filesystem
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读inode信息并学习文件系统
- en: Creating soft links and hard links
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建软链接和硬链接
- en: Creating files and updating the timestamp
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建文件并更新时间戳
- en: Deleting files
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除文件
- en: Getting access rights and ownership
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取访问权限和所有权
- en: Setting access rights and ownership
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置访问权限和所有权
- en: Writing to files with file descriptors
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用文件描述符写入文件
- en: Reading from files with file descriptors
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用文件描述符从文件中读取
- en: Writing to files with streams
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用流写入文件
- en: Reading from files with streams
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用流从文件中读取
- en: Reading and writing binary data with streams
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用流读取和写入二进制数据
- en: Moving around inside a file with `lseek()`
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`lseek()`在文件内部移动
- en: Moving around inside a file with `fseek()`
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`fseek()`在文件内部移动
- en: Technical requirements
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you'll need the GCC compiler, the Make tool, and the generic
    Makefile we made in the *Writing a generic Makefile with GCC options* recipe in
    [*Chapter 3*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097), *Diving Deep into
    C in Linux*. [*Chapter 1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020), *Getting
    the Necessary Tools and Writing Our First Linux Programs*, covers installing the
    compiler and the Make tool.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您将需要GCC编译器、Make工具以及我们在[*第3章*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097)中的*使用GCC选项编写通用Makefile*食谱中制作的通用Makefile。[*第1章*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020)中有关安装编译器和Make工具的内容。
- en: 'The generic Makefile, along with all the source code examples for this chapter,
    can be downloaded from GitHub at this URL: [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch5](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch5).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通用的Makefile以及本章的所有源代码示例可以从GitHub的以下URL下载：[https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch5](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch5)。
- en: We are going to look up functions and header files in the built-in manual in
    Linux. If you are using Debian or Ubuntu, the Linux Programmer's Manual is installed
    as part of the *build-essentials* meta-package, covered in [*Chapter 1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020),
    *Getting the Necessary Tools and Writing Our First Linux Programs*. You'll also
    need to install the *POSIX Programmer's Manual*, covered in the *Getting information
    about Linux and Unix-specific header files* recipe in [*Chapter 3*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097),
    *Diving Deep into C in Linux*. If you are using CentOS or Fedora, these manuals
    are most likely already installed. Otherwise, check out the recipe in [*Chapter
    3*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097), *Diving Deep into C in Linux*,
    that I mentioned.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在Linux的内置手册中查找函数和头文件。如果您使用的是Debian或Ubuntu，Linux程序员手册将作为*build-essentials*元包的一部分安装，该元包在[*第1章*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020)中有所涵盖，*获取必要的工具并编写我们的第一个Linux程序*。您还需要安装*POSIX程序员手册*，该手册在[*第3章*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097)中的*获取有关Linux和Unix特定头文件的信息*食谱中有所涵盖，*深入研究Linux中的C语言*。如果您使用的是CentOS或Fedora，这些手册很可能已经安装。否则，请查看我提到的[*第3章*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097)中的食谱，*深入研究Linux中的C语言*。
- en: 'Check out the following link to see the Code in Action video: [https://bit.ly/3u4OuWz](https://bit.ly/3u4OuWz)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下链接以查看代码演示视频：[https://bit.ly/3u4OuWz](https://bit.ly/3u4OuWz)
- en: Reading inode information and learning the filesystem
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读inode信息并学习文件系统
- en: Understanding inodes is the key to understanding the filesystem in Linux at
    a deeper level. A filename isn't the actual file in a Linux or Unix system. It's
    just a **pointer** to an **inode**. The inode has information about where the
    actual data is stored and a lot of meta data about the file, such as the file
    mode, last modification date, and owner.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 理解inode是深入了解Linux文件系统的关键。在Linux或Unix系统中，文件名并不是实际的文件，它只是指向inode的指针。inode包含有关实际数据存储位置的信息，以及有关文件的大量元数据，例如文件模式、最后修改日期和所有者。
- en: In this recipe, we'll get a general understanding of the **filesystem** and
    how inodes fit into this. We will also view inode information and learn a few
    commands for that. We will also write a small C program that reads inode information
    from a filename.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将对**文件系统**有一个一般的了解，以及inode如何适应其中。我们还将查看inode信息，并学习一些相关命令。我们还将编写一个小的C程序，从文件名中读取inode信息。
- en: Getting ready
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we'll use both commands and C programs to explore the concepts
    of inodes. Everything you need for this recipe is covered in the *Technical requirements*
    section of this chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将使用命令和C程序来探索inode的概念。您需要的一切都在本章的*技术要求*部分中有所涵盖。
- en: How to do it…
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作方法…
- en: 'In this recipe, we''ll begin by exploring the commands that already exist on
    the system to view inode information. Then, we''ll create a small C program to
    print inode information:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将首先探索系统上已经存在的命令，以查看inode信息。然后，我们将创建一个小的C程序来打印inode信息：
- en: 'We''ll start by creating a small text file that we''ll use throughout this
    recipe:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先创建一个小的文本文件，我们将在整个配方中使用它：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let''s view the *inode number* for this file, along with its size, block
    count, and other information. The inode number will be different on every system
    and for every file:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们查看此文件的*inode编号*，以及其大小、块计数和其他信息。每个系统和每个文件的inode编号都是不同的：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The size is in bytes and is 36 bytes. Since no special characters are used
    in the text, this will be the same as the number of characters the file contains.
    We can count the number of characters with `wc`:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大小以字节为单位，为36字节。由于文本中未使用特殊字符，因此这与文件包含的字符数相同。我们可以使用`wc`来计算字符数：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let''s build a small program that extracts some of this information; the
    inode number, the file size, and the number of `my-stat-v1.c`. The name of the
    system call function that we''ll use to extract information has the same name
    as the command-line tool, `stat`. The system call function is highlighted in the
    code:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们构建一个小程序，提取其中一些信息；inode编号、文件大小和`my-stat-v1.c`的链接数。我们将用于提取信息的系统调用函数与命令行工具`stat`具有相同的名称。代码中突出显示了系统调用函数：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now compile this program using Make and the generic `Makefile`:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在使用Make和通用的`Makefile`编译此程序：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s try the program on `testfile1`. Compare the inode number, size, and
    number of links. These numbers should be the same as when we used the `stat` program:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`testfile1`上尝试这个程序。比较inode编号、大小和链接数。这些数字应该与我们使用`stat`程序时相同：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we don''t type an argument, we''ll get a usage message:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们不输入参数，将会得到一个使用消息：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And if we try it on a file that doesn''t exist, we''ll get an error message:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们尝试对一个不存在的文件进行操作，将会得到一个错误消息：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works…
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'The filename of a file isn''t the data or file. The filename is just a link
    to an inode. And that inode, in turn, contains information about where on the
    filesystem the actual data is stored. As we will see in the next recipe, an inode
    can have multiple names or *links*. A filename is also called a link sometimes.
    The following figure illustrates the concepts of filenames that point to the inode,
    and the inode contains information about where the **data blocks** are stored:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的文件名并不是数据或文件。文件名只是指向inode的链接。而该inode又包含有关实际数据存储在文件系统上的位置的信息。正如我们将在下一篇文章中看到的，一个inode可以有多个名称或*链接*。有时文件名也被称为链接。下图说明了指向inode的文件名和inode包含有关**数据块**存储位置的信息的概念：
- en: '![Figure 5.1 – Inodes and filenames'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.1 – Inodes和文件名'
- en: '](img/Figure_5.1_B13043.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.1_B13043.jpg)'
- en: Figure 5.1 – Inodes and filenames
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – Inodes和文件名
- en: An inode also contains `stat` command.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一个inode还包含`stat`命令。
- en: In *step 4*, we created a small C program that reads this metadata using a system
    call function with the same name as the command, `stat()`. The `stat()` system
    call extracts much more data than what we printed here. We will print more of
    this information throughout this chapter. All of this information is stored in
    a struct called `stat`. We find all the information we need about this struct
    in the `man 2 stat` manual page. In that manual page, we also see what data types
    the variables are (`ino_t`, `off_t`, and `nlink_t`). And then, in `man sys_types.h`,
    under **Additionally**, we find what types these are.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步中，我们创建了一个小的C程序，使用与命令相同名称的系统调用函数`stat()`读取此元数据。`stat()`系统调用提取的数据比我们在此处打印的要多得多。我们将在本章中打印更多此类信息。所有这些信息都存储在一个名为`stat`的结构体中。我们在`man
    2 stat`手册页中找到了关于此结构体的所有所需信息。在该手册页中，我们还看到了变量的数据类型（`ino_t`、`off_t`和`nlink_t`）。然后，在`man
    sys_types.h`中，我们在**另外**下找到了这些类型是什么类型。
- en: The fields we use here are `st_ino` for the inode number, `st_size` for the
    file size, and `st_nlink` for the number of links to the file.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的字段是`st_ino`表示inode编号，`st_size`表示文件大小，`st_nlink`表示文件的链接数。
- en: In *step 6*, we saw that the information we extracted using our C program was
    the same as the information from the `stat` command.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6步中，我们看到我们使用C程序提取的信息与`stat`命令的信息相同。
- en: We also implemented error handling in the program. The `stat()` function is
    wrapped in an `if` statement, checking its return value for -1\. And if an error
    does occur, we print an error message to *stderr* with the filename and the error
    message from `errno`. The program also returns the `errno` variable to the shell.
    We learned all about error handling and `errno` in [*Chapter 4*](B13043_04_Final_SK_ePub.xhtml#_idTextAnchor147)*,
    Handling Errors in Your Programs*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在程序中实现了错误处理。`stat()`函数包装在一个`if`语句中，检查其返回值是否为-1。如果发生错误，我们将使用`stderr`打印出带有文件名和`errno`的错误消息。程序还将`errno`变量返回给shell。我们在[*第4章*](B13043_04_Final_SK_ePub.xhtml#_idTextAnchor147)*中学习了有关错误处理和`errno`的所有内容，处理程序中的错误*。
- en: Creating soft links and hard links
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建软链接和硬链接
- en: In the previous recipe, we touched on the subject of links. In this recipe,
    we'll learn more about links and how they affect inodes. We'll also investigate
    the difference between **soft links** and **hard links**. In short, a hard link
    is a filename, and a soft link is like a shortcut to a filename.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一篇文章中，我们提到了链接的主题。在这篇文章中，我们将更多地了解链接以及它们对inode的影响。我们还将调查**软链接**和**硬链接**之间的区别。简而言之，硬链接是一个文件名，软链接就像是一个文件名的快捷方式。
- en: On top of that, we'll write two programs, one that creates a hard link and one
    that creates a soft link. We'll then use the program we created in the previous
    recipe to check the **link count**.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将编写两个程序，一个创建硬链接，一个创建软链接。然后，我们将使用前一篇文章中创建的程序来检查链接计数。
- en: Getting ready
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Except for the requirements listed at the beginning of this chapter, you'll
    also need the program we created in the previous recipe, `my-stat-v1.c`. You'll
    also need the test file we created in the previous recipe, named `testfile1`.
    If you haven't created those files yet, you can also download them from GitHub
    at [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch5](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch5).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 除了本章开头列出的要求，您还需要我们在上一个示例中创建的程序`my-stat-v1.c`。您还需要我们在上一个示例中创建的测试文件，名为`testfile1`。如果您还没有创建这些文件，也可以从GitHub上下载它们[https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch5](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch5)。
- en: You'll also need to compile the `my-stat-v1.c` program using Make so you'll
    be able to execute it, if you haven't done so already. You compile it with `make
    my-stat-v1`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要使用Make编译`my-stat-v1.c`程序，以便能够执行它，如果您还没有这样做的话。您可以使用`make my-stat-v1`来编译它。
- en: How to do it…
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We will create both soft links and hard links, using both the built-in commands
    and writing simple C programs to do so:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建软链接和硬链接，使用内置命令和编写简单的C程序来完成：
- en: 'We''ll start by creating a new hard link to our test file, `testfile1`. We''ll
    name the new hard link `my-file`:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先创建一个新的硬链接到我们的测试文件`testfile1`。我们将新的硬链接命名为`my-file`：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now let''s investigate this new filename. Note how the links have increased
    to `2`, but the rest is the same as for `testfile1`:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们调查这个新文件名。请注意链接已增加到`2`，但其余部分与`testfile1`相同：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now compare these numbers with the `testfile1` file. They should all be the
    same:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将这些数字与`testfile1`文件进行比较。它们应该都是相同的：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s create another hard link called `another-name`. We create this link
    using the name `my-file` as the target:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建另一个名为`another-name`的硬链接。我们使用名称`my-file`作为目标创建此链接：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We''ll investigate this file as well:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也将调查这个文件：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now let''s delete the `testfile1` filename:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们删除`testfile1`文件名：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now that we have deleted the first filename we created, we''ll investigate
    the other two names:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经删除了我们创建的第一个文件名，我们将调查另外两个名称：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It''s time to create a soft link. We create a soft link called `my-soft-link`
    to the name `another-name`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候创建一个软链接了。我们创建一个名为`my-soft-link`的软链接到名称`another-name`：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A soft link is a special file type, which we can see with the `ls` command.
    Note that we get a new timestamp here. Also, note that it''s a special file, which
    can be seen by the first letter in the file mode field, the letter `l` for a link:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 软链接是一种特殊的文件类型，可以使用`ls`命令查看。请注意，我们在这里得到了一个新的时间戳。还要注意，它是一个特殊文件，可以通过文件模式字段中的第一个字母`l`来看到：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now let''s check the link count of `another-name`. Note that the counter hasn''t
    increased with the soft link:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们检查`another-name`的链接计数。请注意，软链接的计数器没有增加：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It''s time to write our own program to create hard links. There exists an easy-to-use
    `link()` that we''ll use for this. Write the following code in a file and save
    it as `new-name.c`. The `link()` system call is highlighted in the code:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候编写我们自己的程序来创建硬链接了。存在一个易于使用的`link()`，我们将使用它。将以下代码写入文件并保存为`new-name.c`。代码中突出显示了`link()`系统调用：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Compile the program:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译程序：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create a new name to our previous `my-file` file. Name the new file `third-name`.
    We also try to generate some errors to see that the program prints the correct
    error messages. Note that the inode information for `third-name` is the same as
    for `my-file`:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们之前的`my-file`文件创建一个新名称。将新文件命名为`third-name`。我们还尝试生成一些错误，以查看程序是否打印了正确的错误消息。请注意，`third-name`的inode信息与`my-file`的相同：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now let''s create a program that creates a soft link. There''s an easy-to-use
    system call for this as well, called `symlink()`, for `new-symlink.c`. The `symlink()`
    system call is highlighted in the code. Notice how similar all of these system
    call functions are:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们创建一个创建软链接的程序。这也有一个易于使用的系统调用，称为`symlink()`，用于`new-symlink.c`。代码中突出显示了`symlink()`系统调用。注意所有这些系统调用函数有多么相似：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Compile it:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译它：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And let''s try it out, creating a new soft link called `new-soft-link` to `third-name`.
    Also, let''s try generating some errors so we can verify that the error handling
    is working:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们试一试，创建一个新的软链接，名为`new-soft-link`，指向`third-name`。此外，让我们尝试生成一些错误，以便我们可以验证错误处理是否正常工作：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works…
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: There's a lot going on here, so let's take it from the top.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了很多事情，所以让我们从头开始。
- en: In steps 1 to 7, we created two new hard links to the `testfile1` file. But
    as we noticed, there's nothing special about a hard link; it's just another name
    to an inode. All filenames are hard links. A filename is just a link to an inode.
    We saw that when we deleted the `testfile1` filename. The two remaining names
    link to the same inode, and it contains the same text. There is nothing special
    about the first filename or link. There's no way to tell which of the hard links
    was created first. They are equal; they even share the same date, even though
    the other links were made at a later time. The date is for the inode, not the
    filenames.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤1到7中，我们创建了两个新的硬链接到`testfile1`文件。但正如我们注意到的，硬链接没有什么特别之处；它只是inode的另一个名称。所有文件名都是硬链接。文件名只是inode的一个链接。当我们删除`testfile1`文件名时，我们看到了这一点。剩下的两个名称链接到相同的inode，并且包含相同的文本。第一个文件名或链接没有什么特别之处。无法告诉哪个硬链接是首先创建的。它们是相等的；它们甚至共享相同的日期，尽管其他链接是在稍后的时间创建的。日期是为了inode，而不是文件名。
- en: As we created and deleted hard links, we saw how the link count increased and
    decreased. This is the inode keeping count of how many links—or names—it has.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建和删除硬链接时，我们看到链接计数增加和减少。这是inode保持计算它有多少链接或名称的计数。
- en: The inode isn't deleted until the last name is deleted, that is, when the link
    counter reaches zero.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 直到最后一个名称被删除，即链接计数达到零时，inode才会被删除。
- en: In *steps 8 to 10*, we saw that a soft link, on the other hand, is a special
    file type. A soft link doesn't count toward the inode's link counter. The file
    is denoted by an `l` at the start of the `ls -l` output. We can also see what
    file the soft link points to in the `ls -l` output. Think of a soft link as a
    shortcut.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤8到10*中，我们看到软链接，另一方面，是一种特殊的文件类型。软链接不计入inode的链接计数。文件在`ls -l`输出的开头用`l`表示。我们还可以在`ls
    -l`输出中看到软链接指向的文件。把软链接想象成一个快捷方式。
- en: In *steps 11 to 13*, we wrote a C program that creates a hard link—a new name—to
    an existing filename. Here we learned that the system calls for creating new names
    is called `link()` and takes two arguments, the target and the new name.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤11到13*中，我们编写了一个创建硬链接（现有文件的新名称）的C程序。在这里，我们了解到创建新名称的系统调用称为`link()`，并且接受两个参数，目标和新名称。
- en: In *step 13*, we witnessed an interesting property for hard links. They cannot
    span across devices. When we think about it, it makes sense. The filename can't
    remain on a device separate from the inode. If the device is removed, there might
    not be any more names pointing to the inode, making it inaccessible.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤13*中，我们见证了硬链接的一个有趣特性。它们不能跨设备。当我们考虑这一点时，这是有道理的。文件名不能保留在与inode分开的设备上。如果设备被移除，可能就没有更多的名称指向inode，使其无法访问。
- en: For the remaining steps, we wrote a C program that creates soft links to existing
    files. This system call is similar to `link()` but is instead called `symlink()`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在剩下的步骤中，我们编写了一个C程序，用于创建指向现有文件的软链接。这个系统调用类似于`link()`，但是被称为`symlink()`。
- en: There's more…
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Please look at the manual pages for the system calls we covered in this recipe;
    they contain some great explanations of both hard links and soft links. The manual
    pages are `man 2 link` and `man 2 symlink`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看我们在本食谱中涵盖的系统调用的手册页面；它们包含了硬链接和软链接的一些很好的解释。手册页面是`man 2 link`和`man 2 symlink`。
- en: Creating files and updating the timestamp
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建文件和更新时间戳
- en: Now that we understand the filesystem, inodes, and hard links, we'll learn how
    to create files by writing our own version of `touch` in C. We have already started
    writing a version of `touch` in [*Chapter 4*](B13043_04_Final_SK_ePub.xhtml#_idTextAnchor147)*,
    Handling Errors in Your Programs,* where we learned about error handling. We will
    continue using the latest version of that program, which we named `simple-touch-v7.c`.
    The real version of `touch` updates the modification and access **timestamp**
    of a file if the file exists. In this recipe, we'll add that feature to our new
    version.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了文件系统、inode和硬链接，我们将学习如何通过在C中编写我们自己的`touch`版本来创建文件。我们已经开始在[*第4章*](B13043_04_Final_SK_ePub.xhtml#_idTextAnchor147)*，处理程序中的错误*中编写`touch`的一个版本，那里我们学习了错误处理。我们将继续使用该程序的最新版本，我们将其命名为`simple-touch-v7.c`。真正的`touch`版本会在文件存在时更新文件的修改和访问时间戳。在这个食谱中，我们将在我们的新版本中添加这个功能。
- en: Getting ready
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Everything you'll need for this recipe is listed in the *Technical requirements*
    section for this chapter. Although we will add on the latest version of `simple-touch`,
    we'll write the entire code in this recipe. But for complete comprehension of
    the program, it is wise to read through [*Chapter 4*](B13043_04_Final_SK_ePub.xhtml#_idTextAnchor147)*,
    Handling Errors in Your Programs,* first.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您在本章的*技术要求*部分中列出了此食谱所需的一切。虽然我们将添加`simple-touch`的最新版本，但我们将在本食谱中编写整个代码。但为了完全理解程序，最好先阅读[*第4章*](B13043_04_Final_SK_ePub.xhtml#_idTextAnchor147)*，处理程序中的错误*。
- en: How to do it…
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this eighth version of `simple-touch`, we will add the feature to update
    the access and modification date of a file:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`simple-touch`的第八个版本中，我们将添加更新文件的访问和修改日期的功能：
- en: 'Write the following code in a file and save it as `simple-touch-v8.c`. Here
    we will use the `utime()` system call to update a file''s access and modification
    timestamps. The changes from the previous version are highlighted in the code
    (except for the added comments). Also, note how the `creat()` system call has
    moved into an `if` statement. The `creat()` system call is only called if the
    file doesn''t already exist:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件中写入以下代码，并将其保存为`simple-touch-v8.c`。在这里，我们将使用`utime()`系统调用来更新文件的访问和修改时间戳。代码中突出显示了与上一个版本的更改（除了添加的注释）。还要注意`creat()`系统调用如何移入了一个`if`语句。只有在文件不存在时才会调用`creat()`系统调用：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Compile the program using Make:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Make编译程序：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s try it out and see how it works. We''ll try it on the filenames we created
    in the previous recipe and see how each filename gets the same timestamp since
    they all point to the same inode:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试一下，看看它是如何工作的。我们将在上一个食谱中创建的文件名上尝试，并看看每个文件名如何获得相同的时间戳，因为它们都指向相同的inode：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works…
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we added the feature to update the timestamp of a file—or inode,
    as we have learned that it is.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们添加了更新文件或inode的时间戳的功能。
- en: To update the access and modification time, we use the `utime()` system call.
    The `utime()` system call takes two arguments, a filename and a timestamp. But
    if we give the function `NULL` as the second argument, it will use the current
    time and date.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新访问和修改时间，我们使用`utime()`系统调用。`utime()`系统调用接受两个参数，一个文件名和一个时间戳。但是如果我们将`NULL`作为第二个参数传递给函数，它将使用当前的时间和日期。
- en: The call to `utime()` is wrapped in an `if` statement, which checks whether
    the return value is -1\. If it is, then something is wrong, and `errno` is set
    (see [*Chapter 4*](B13043_04_Final_SK_ePub.xhtml#_idTextAnchor147)*, Handling
    Errors in Your Programs*, for an in-depth explanation of `errno`). We then use
    `errno` to check whether it was a *File not found* error (`ENOTENT`). If the file
    doesn't exist, we create it using the `creat()` system call. The call to `creat()`
    is also wrapped in an `if` statement. If something goes wrong while creating a
    file, the program prints an error message and return the `errno` value. If the
    program managed to create the file, it continues down to `return 0`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: If the `errno` value from `utime()` wasn't `ENOENT`, it continues down to the
    `else` statement, prints an error message, and returns `errno`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: When we tried the program, we noticed that both `my-file` and `third-name` got
    an updated timestamp when we updated one of them. This is because the filenames
    are just links to the same inode. And the timestamp is metadata in the inode.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's a lot of useful information in `man 2 creat` and `man 2 utime`. If you
    are interested in learning more about time and dates in Linux, I recommend you
    read `man 2 time`, `man 3 asctime`, and `man time.h`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Deleting files
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we learn how to `unlink()`—comes from. This recipe will enhance
    your understanding of links and close the circle. This will improve your overall
    knowledge of Linux and its filesystem. Knowing how to delete files using the system
    call will enable you to remove files directly from within your programs.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Here we will write our own version of `rm`, which we will call `remove`. After
    this recipe, we know how to create and delete files and how to make links. These
    are some of the most common filesystem operations.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will use the `my-stat-v1` program, which we wrote in the
    *Reading inode information and learning the filesystem* recipe. We will also continue
    experimenting on the filenames we created in the previous recipes, `my-file`,
    `another-name`, and `third-name`. Except for that, you'll need what's listed under
    *Technical requirements* for this chapter, that is, the GCC compiler, the Make
    tool, and the generic Makefile.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow along here to write a simple version of `rm`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code in a file and save it as `remove.c`. This program
    uses the `unlink()` system call to remove a file. The system call is highlighted
    in the code:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Compile it using the **Make** tool:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And let''s try it out:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works…
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The system call to remove a file is called `unlink()`. The name comes from the
    fact that when we remove a filename, we only remove a hard link to that inode;
    hence we **unlink** a filename. If it happens to be the last filename to an inode,
    then the inode is also removed.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'The `unlink()` system calls only takes one argument: the filename that we want
    to remove.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Getting access rights and ownership
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll write a program that reads the access rights and ownership
    of a file using the `stat()` system call we have seen previously in this chapter.
    We will continue to build upon the `my-stat-v1` program that we built in the first
    recipe in this chapter. Here we will add the features to show ownership and access
    rights as well. Knowing how to get the owner and access rights programmatically
    is key to working with files and directories. It will enable you to check whether
    the user has the appropriate permissions and print an error message if they haven't.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: We will also learn how access rights are interpreted in Linux and how to convert
    between numerical representation and letter representation. Understanding access
    rights in Linux is key to being a Linux system programmer. Every file and directory
    on the entire system has access rights and an owner and a group assigned to them.
    It doesn't matter whether it's a log file, a system file, or just a text file
    that a user owns. Everything has access rights.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you'll only need what's listed in the *Technical requirements*
    section of this chapter.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will write a new version of `my-stat-v1` in this recipe. We will write the
    entire program here, though, so you don''t need the previous version:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code in a file and save it as `my-stat-v2.c`. In this version,
    we''ll pull information about the owner and the group of the file and the file
    mode. To translate the `getpwuid()`. To get the group name for a `getgrgid()`.
    The changes are highlighted in the code:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Compile the program:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Try out the program on some different files:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works…
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this version of `my-stat`, we have added features to retrieve the file access
    mode, or actually, the **file mode**. The file's complete file mode consists of
    six octal numbers. The first two (to the left) is the file type. In this case,
    it's a regular file (10 equals a regular file). The fourth octal digit is for
    the **set-user-ID bit**, the **set-group-ID bit**, and the **sticky bit**. The
    last three octal digits are for the **access mode**.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'In the output from `ls -l`, all these bits are instead represented as letters.
    But when we write programs, we must set and read these as numbers. Before we move
    on, let''s examine the letter-version of the file mode, so we truly understand
    it:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – File access mode'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.2_B13043.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – File access mode
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: The set-user-ID bit is a bit that allows a process to run as the owner of the
    binary file, even though it is executed as a different user. Setting the set-user-ID
    bit is potentially dangerous and *not* something we should set on our programs.
    One program that does use the set-user-ID bit is the `passwd` program. The `passwd`
    program must update the `/etc/passwd` and `/etc/shadow` files when a user changes
    his or her password, even though those files are owned by root. Under normal circumstances,
    we can't even read the `/etc/shadow` file as a regular user, but with the set-user-ID
    bit set on the `passwd` program, it can even write to it. If the set-user-ID bit
    is set, it's denoted by an `s` in the third place of the user's access mode.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: The set-group-ID has a similar effect. When a program is executed, and the set-group-ID
    bit is set, it is executed as that group. When the set-group-ID is set, it's denoted
    by an `s` in the third place of the group's access mode.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: The sticky bit was historically used to *stick* a program to the swap space
    for faster loading time. Nowadays, it's used entirely differently. Now, the name—as
    well as the meaning—has changed to *restricted deletion flag*. When a directory
    has the sticky bit set, only a file's owner, the directory owner, or the root
    user can remove a file, even if the directory is writeable by anybody. For example,
    the `/tmp` directory usually has the sticky bit set. A sticky bit is denoted by
    a `t` in the last position of the last group.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: File access mode
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we run `ls -l` on a file, we always see two names. The first name is the
    user (the owner), and the second name is the group that owns the file. Take this,
    for example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this case, `jake` is the user (owner), and `devops` is the group.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: The file access modes are easier to understand than the special flags we just
    covered. Take a look at *Figure 5.2*. The first three letters are the user's access
    mode (the owner of the file). This particular example has `rw-`, which means that
    the user can read and write the file but not execute it. If the user were to be
    able to execute it, that would be denoted by an `x` in the last place.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 文件访问模式比我们刚刚讨论的特殊标志更容易理解。看一下*图5.2*。前三个字母是用户的访问模式（文件的所有者）。这个特定的示例有`rw-`，这意味着用户可以读取和写入文件，但不能执行它。如果用户能够执行它，那将在最后一个位置上用`x`表示。
- en: The middle three letters are for the group access mode (the group that owns
    the file). In this case, the group can only read the file since the group is missing
    both the `w` for write and the `x` for execution.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 中间的三个字母是组访问模式（拥有文件的组）。在这种情况下，由于组缺少写入和执行的`w`和`x`，组只能读取文件。
- en: The last three letters are for all others (not the owner and not in the owner
    group). In this case, everybody else can just read the file.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的三个字母是所有其他人（不是所有者，也不在所有者组中）。在这种情况下，其他人只能读取文件。
- en: A full set of permissions would be `rwxrwxrwx`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的权限集将是`rwxrwxrwx`。
- en: Converting access modes between letters and numeric
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在字母和数字之间转换访问模式
- en: 'An **octal number** represents the file access mode. Until we get used to it,
    the easiest way to convert from letters to octal is to use a pen and paper. We
    add all the numbers together in each group where that access bit is set. If it
    is not set (a dash), then we don''t add that number. When we''re finished adding
    each group, we have the access mode:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**八进制数**表示文件访问模式。在我们习惯之前，从字母转换为八进制的最简单方法是使用纸和笔。我们在每个设置了访问位的组中将所有数字相加。如果没有设置（破折号），那么我们就不添加那个数字。当我们完成每个组的添加时，我们就得到了访问模式：'
- en: '[PRE35]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The preceding octal access mode is therefore 644\. Let''s do another example:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，前面的八进制访问模式是644。让我们再举一个例子：
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The preceding access mode turns out to be 775\. Let''s take one more example:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的访问模式结果是775。让我们再举一个例子：
- en: '[PRE41]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This access mode is 600.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个访问模式是600。
- en: 'The other way around can also be done by using a pen and paper. Let''s say
    we have the access mode 750, and we want to convert that into letters:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用纸和笔来做相反的事情。假设我们有访问模式750，我们想把它转换成字母：
- en: '[PRE44]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Hence, 750 becomes `rwxr-x---`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，750变成了`rwxr-x---`。
- en: When you have been doing it for a while, you learn the most commonly used access
    modes and don't need a pen and paper anymore.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当你做了一段时间后，你会学会最常用的访问模式，不再需要纸和笔。
- en: The file mode in octal
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 八进制文件模式
- en: 'The same principle applies here as with the file access mode. Remember that
    the set-user-ID is denoted by an `s` in the user''s execute position, and the
    set-group-ID is denoted by an `s` in the group''s execute bit. A `t` character
    denotes the sticky bit in the last execute bit position (the "others"). If we
    write it in a row, we get this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 与文件访问模式一样，这里也适用相同的原则。记住，用户ID由用户的执行位置上的`s`表示，组ID由组的执行位上的`s`表示。`t`字符表示最后一个执行位位置（“其他”）的粘性位。如果我们把它写在一行上，就会得到这样：
- en: '[PRE47]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: So if only the set-user-ID bit is set, we get a 4\. If both the set-user-ID
    and set-group-ID is set, we get *4+2=6*. If only the set-group-ID bit is set,
    we get a 2\. If only the sticky bit is set, we get a 1, and so forth. And if all
    the bits are set, we get a *7 (4+2+1)*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果只设置了用户ID位，我们得到4。如果同时设置了用户ID和组ID，我们得到*4+2=6*。如果只设置了组ID位，我们得到2。如果只设置了粘性位，我们得到1，依此类推。如果所有位都设置了，我们得到*7（4+2+1）*。
- en: These file modes are represented by a number before the file access mode. For
    example, the octal file mode `4755` has the set-user-ID bit set (the 4).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件模式由文件访问模式之前的数字表示。例如，八进制文件模式`4755`设置了用户ID位（4）。
- en: 'When we program under Linux, we can even encounter two more numbers, as we
    saw with the output from our `my-stat-v2` program. There, we had this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Linux下编程时，我们甚至可能会遇到另外两个数字，就像我们从`my-stat-v2`程序的输出中看到的那样。在那里，我们有这样的：
- en: '[PRE49]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The two first numbers, `10` in this example, are the file type. Exactly what
    these two first numbers mean is something we''ll have to look up in the `man 7
    inode` manual page. There we have a nice table telling us what it means. I have
    made a simplified list here, showing only the first two numbers we are interested
    in and what file type it represents:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个数字，在这个例子中是`10`，是文件类型。这两个数字的确切含义是我们需要在`man 7 inode`手册页中查找的。那里有一个很好的表告诉我们它的含义。我在这里列出了一个简化的列表，只显示我们感兴趣的前两个数字以及它代表的文件类型：
- en: '[PRE50]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: That means that our example file is a regular file (10).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的示例文件是一个普通文件（10）。
- en: 'If we add up everything we just learned and translate the file mode *100755*
    from the preceding example output from `my-stat-v2`, we get this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们把刚刚学到的所有东西加起来，并将前面示例输出的`my-stat-v2`中的文件模式*100755*转换成数字，我们得到这样：
- en: '[PRE57]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The file type is also denoted by a letter at the very first position (see *Figure
    5.2*). The letters are as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 文件类型也由第一个位置的字母表示（见*图5.2*）。这些字母如下：
- en: '[PRE60]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Setting access rights and ownership
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置访问权限和所有权
- en: In the previous recipe, we learned how to read the `chmod` command and the `chmod()`
    system call. We will also learn how to change the owner and group of a file, using
    both the `chown` command and the `chown()` system call.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个配方中，我们学习了如何读取`chmod`命令和`chmod()`系统调用。我们还将学习如何改变文件的所有者和组，使用`chown`命令和`chown()`系统调用。
- en: Knowing how to set access rights properly will help you keep your systems and
    files secure.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 知道如何正确设置访问权限将有助于保护您的系统和文件安全。
- en: Getting ready
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you'll only need what's listed in the *Technical requirements*
    section of this chapter. It's also a good idea to read the previous recipe to
    understand permissions in Linux. You will also need the `my-stat-v2` program from
    the previous recipe.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，你只需要本章*技术要求*部分列出的内容。阅读上一个配方以理解Linux中的权限也是一个好主意。你还需要上一个配方中的`my-stat-v2`程序。
- en: How to do it…
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: These steps will teach us how to change the access rights and ownership of files
    and directories.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将教会我们如何更改文件和目录的访问权限和所有权。
- en: Access rights
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问权限
- en: 'We will start by setting the access rights of a file by using the `chmod` command.
    We will then write a simple C version of the `chmod` command, using the `chmod()`
    system call:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用`chmod`命令设置文件的访问权限。然后，我们将编写`chmod`命令的简单C版本，使用`chmod()`系统调用：
- en: 'Let''s start by removing the execute permission from our `my-stat-v2` program,
    using the `chmod` command. The `-x` in the following command means *remove eXecute*:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先使用`chmod`命令从我们的`my-stat-v2`程序中删除执行权限。以下命令中的`-x`表示*删除执行*：
- en: '[PRE67]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now let''s try to execute the program. This should now fail with permission
    denied:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们尝试执行程序。这次应该因为权限被拒绝而失败：
- en: '[PRE68]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now we change it back again, but this time we set the *absolute* permission
    using octal numbers. Suitable permissions for executable files are 755, which
    translates to `rwxr-xr-x`. That, in turn, means that the user has full permissions
    and, the group can read and execute the file. The same goes for all others; they
    can read and execute it:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们再次改回来，但这次我们使用八进制数字设置*绝对*权限。可执行文件的适当权限是755，对应`rwxr-xr-x`。这意味着用户有完全权限，组可以读取和执行文件。其他所有人也一样；他们可以读取和执行它：
- en: '[PRE69]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'After this command, we can once again execute the program:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个命令之后，我们可以再次执行程序：
- en: '[PRE70]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now it''s time to write a simple version of the `chmod` command, using the
    `chmod()` system call. Write the following code in a file and save it as `my-chmod.c`.
    The `chmod()` system call takes two arguments, the path to the file or directory
    and the file permission expressed as an octal number. Before we get to the `chmod()`
    system call, we perform some checks to ensure that the permission seems reasonable
    (an octal number that is either three or four digits long). After the checks,
    we convert the number to an octal number with `strtol()`. The third argument to
    `strtol()` is the base, in this case, `8`:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候编写`chmod`命令的简单版本，使用`chmod()`系统调用。将以下代码写入文件并保存为`my-chmod.c`。`chmod()`系统调用接受两个参数，文件或目录的路径和以八进制数表示的文件权限。在进行`chmod()`系统调用之前，我们进行一些检查，以确保权限看起来合理（一个三位或四位数的八进制数）。检查后，我们使用`strtol()`将数字转换为八进制数。`strtol()`的第三个参数是基数，这里是`8`：
- en: '[PRE71]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now compile the program:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编译程序：
- en: '[PRE72]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Test the program using different permissions. Don''t forget to check the result
    using `ls -l`:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用不同的权限测试程序。不要忘记使用`ls -l`检查结果：
- en: '[PRE73]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Let''s also try to set the set-user-ID bit. This set-user-ID bit (and set-group-ID
    and sticky bit) is the fourth digit in front of the access mode. A `4` here sets
    the set-user-ID bit. Note the `s` (highlighted in the following code) in the user
    field:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也尝试设置设置用户ID位。这里的设置用户ID位（以及设置组ID位和粘性位）是访问模式前面的第四位数字。这里的`4`设置了设置用户ID位。请注意用户字段中的`s`（在下面的代码中突出显示）：
- en: '[PRE74]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Let''s try to set all bits (set-user-ID, set-group-ID, sticky bit, and all
    permissions):'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试设置所有位（设置用户ID、设置组ID、粘性位和所有权限）：
- en: '[PRE75]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'And finally, change it back to something more sensible:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将其改回更合理的东西：
- en: '[PRE76]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Ownership
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 所有权
- en: 'But we also need to know how to change the `chown` command or the `chown()`
    system call:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们也需要知道如何改变`chown`命令或`chown()`系统调用：
- en: 'To change the owner of a file, we must be root. Regular users cannot give away
    ownership of their files. Likewise, they cannot claim ownership of someone else''s
    files. Let''s try to change the owner of `my-stat-v2` to root using the `chown`
    command:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要改变文件的所有者，我们必须是root。普通用户不能放弃对他们的文件的所有权。同样，他们也不能声明对别人的文件的所有权。让我们尝试使用`chown`命令将`my-stat-v2`的所有者更改为root：
- en: '[PRE77]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'If we want to change both the owner and the group, we separate the user and
    the group using a colon. The first field is the owner, and the second field is
    the group:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想要改变所有者和组，我们使用冒号分隔用户和组。第一个字段是所有者，第二个字段是组：
- en: '[PRE78]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'And now it''s our turn to write a simplified version of `chown`, using the
    `chown()` system call. The `chown()` system call only takes user IDs as numerical
    values. To be able to use names instead, we must first look up the username using
    `getpwnam()`. This will give us the numerical value in the `passwd` struct, in
    the `pw_uid` field. The same goes for the group. We must get the numerical group-ID
    using its name, using the `getgrnam()`system call. Now that we know all the system
    calls, let''s write the program. Name it `my-chown.c`. This program is a bit longer,
    so I have split it up into several steps. Keep in mind that all steps should go
    into a single file (`my-chown.c`). You can also download the entire code from
    [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch5/my-chown.c](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch5/my-chown.c)
    if you wish. Let''s start with all the header files, the variables, and the arguments
    check:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在轮到我们编写一个简化版本的`chown`，使用`chown()`系统调用。`chown()`系统调用只接受用户ID作为数值。为了能够使用名称，我们必须首先使用`getpwnam()`查找用户名。这将在`passwd`结构中的`pw_uid`字段中给我们数值。对于组也是一样。我们必须使用`getgrnam()`系统调用使用其名称获取数值组ID。现在我们知道了所有的系统调用，让我们写程序。将其命名为`my-chown.c`。这个程序有点长，所以我把它分成了几个步骤。请记住，所有步骤都应该放在一个文件（`my-chown.c`）中。如果愿意，您也可以从[https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch5/my-chown.c](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch5/my-chown.c)下载整个代码。让我们从所有的头文件、变量和参数检查开始：
- en: '[PRE79]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Since we write the username and group as `username:group` in the argument,
    we need to extract the username part and the group part. We do this with a string
    function called `strtok()`. We only provide the first argument (the string) in
    the first call to `strtok()`. After this, we get the `user` struct and the `grp`
    struct. We also check whether the user and group exist:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将用户名和组写为`username:group`在参数中，我们需要提取用户名部分和组部分。我们使用一个名为`strtok()`的字符串函数来做到这一点。在第一次调用`strtok()`时，我们只提供第一个参数（字符串）。之后，我们得到`user`结构和`grp`结构。我们还检查用户和组是否存在：
- en: '[PRE80]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Finally, we update the user and group of the file using the `chown()` system
    call:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Let''s compile the program so that we can try it:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now we test the program on a file. Remember that we need to be root to change
    a file''s owner and group:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: How it works…
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every file and directory on the system has access rights and an owner/group
    pair. The access rights are changed with the `chmod` command or the `chmod()`
    system call. The name is short for *change mode bits*. In the previous recipe,
    we covered how to translate access rights between the more human-readable text
    format and the numerical octal form. In this recipe, we wrote a program that changed
    the mode bits using the `chmod()` system call using the numerical form.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: To convert the numerical form into an octal number, we used `strtol()` with
    `8` as the third argument, which is the numeral system base. Base 8 is octal;
    base 10 is the regular decimal system we use in everyday life; base 16 is hexadecimal,
    and so on.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: We wrote the program so that the user can choose whatever they want to set,
    whether that's only the access mode bits (three digits) or also the special bits
    such as set-user-ID, set-group-ID, and sticky bit (four digits). To determine
    the number of digits the user typed, we use `strlen()`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: In the next program we wrote, we used `chown()` to update the owner and group
    of a file or directory. Since we want to update the user and group using the names,
    not the numerical UID and GID, the program got more complex. The `chown()`system
    call only takes the UID and GID, not names. That means we need to look up the
    UID and GID before we can call `chown()`. To look up the UID and GID, we use `getpwnam()`
    and `getgrnam()`. Each of these functions gives us a `struct` containing all information
    available for the respective user or group. From those structs, we extract the
    UID and GID, which we then use in the call to `chown()`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: To separate the username and group part from the command line (the colon), we
    use the `strtok()` function. In the first call to the function, we specify the
    string as the first argument (in this case, `argv[1]`) and the separator (a colon).
    In the next call to `strtok()`, we leave out the string by setting it to `NULL`,
    but we still specify the separator. The first call gives us the username and the
    second call gives us the group name.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: After that, we check whether the username and group name exist when we call
    `getpwnam()` and `getgrnam()`. If the username or group name don't exist, the
    functions return `NULL`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several similar functions to `getpwnam()` and `getgrnam()`, depending
    on what information you have and what information you have. If you have the UID,
    you instead use `getpwuid()`. Likewise, if you have the GID, you use `getgrgid()`.
    There is more information—and more functions—if you read the `man 3 getpwnam`
    and `man 3 getgrnam` manual pages.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Writing to files with file descriptors
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen some uses of **file descriptors** in previous chapters,
    for example, 0, 1, and 2 (*stdin*, *stdout*, and *stderr*). But in this recipe,
    we will use file descriptors to write text to files from a program.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to use file descriptors to write to files both gives you a deeper
    understanding of the system and enables you to do some low-level stuff.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you only need what is listed under the *Technical requirements*
    section.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here we will write a small program that writes text to a file:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code in a file and save it as `fd-write.c`. The program
    takes two arguments: a string and a filename. To write to a file using file descriptors,
    we must first open the file with the `open()` system call. The `open()` system
    call returns a file descriptor, which is an integer. We then use that file descriptor
    (the integer) with the `write()` system call. We have already seen `write()` in
    [*Chapter 3*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097)*, Diving Deep into
    C in Linux*. In that chapter, we used `write()` to write a small text to stdout.
    This time, we use `write()` to write a text to a file. Notice that the `open()`
    system call takes three arguments: the path to the file, which mode the file shall
    open in (in this case, create the file if it doesn''t exist, and open it in read-write
    mode), and the `0644`):'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Let''s compile the program:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'And let''s try to write some text to a file. Remember that if the file already
    exists, the content will be overwritten! If the new text is smaller than the old
    content of the file, only the beginning will be overwritten. Also note that if
    the text doesn''t contain a new line, the text in the file won''t contain a new
    line either:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We can even give it input from another file if we use `xargs`, a program that
    allows us to take the output of a program and parse it as a command-line argument
    to another program. Notice that this time, `testfile1` will have a new line at
    the end. The `-0` option to `xargs` makes it ignore new lines and will instead
    use the null character to indicate the end of the argument:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: How it works…
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `open()` system call returns a file descriptor, which we save in the `fd`
    variable. A file descriptor is just an integer, just as 0, 1, and 3 are *stdin*,
    *stdout*, and *stderr*.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: The second argument we give to `open()` are macros with mode bits that are put
    together using *bitwise-or*. In our case, we use both `O_CREAT` and `O_RDWR`.
    The first one, `O_CREAT`, means that if the file doesn't exist, it is created.
    The second one, `O_RDWR`, means that the file should be open for both reading
    and writing.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: To write the string to the file, we pass the file descriptor to `write()` as
    the first argument. As the second argument, we give it `argv[2]`, which contains
    the string that we want to write to the file descriptor. The last argument is
    the size of what we want to write. In our case, we get the size of `argv[2]` with
    `strlen`, a function from `string.h` to get the length of strings.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Just as in the previous recipes, we check all the system calls for `-1`. If
    they return `-1`, something has gone wrong, and we use `perror()` to print an
    error message, and then we return `1`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a program returns normally, all open file descriptors are closed automatically.
    But if we want to close a file descriptor explicitly, we use the `close()` system
    call with the file descriptor as its argument. In our case, we could have added
    `close(fd)` just before the return.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a lot of good information about `open()`, `close()`, and `write()`
    in the manual pages. I suggest you read them for more in-depth information. You
    can read them with the following:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '`man 2 open`'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`man 2 close`'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`man 2 write`'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading from files with file descriptors
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we learned how to write to files using file descriptors.
    In this recipe, we will learn how to read from files using file descriptors. We
    will therefore write a small program that is similar to `cat`. It takes one argument—a
    filename—and prints its content to standard output.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to read—and use—file descriptors enables you to read not only files
    but all sorts of data that comes through a file descriptor. File descriptors are
    a universal way to read and write data in Unix and Linux.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The only things you'll need for this recipe are listed under the *Technical
    requirements* section of this chapter.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Reading a file using a file descriptor is similar to writing to one. Instead
    of using the `write()` system call, we will instead use the `read()` system call.
    Before we can read the content, we must figure out the size of the file first.
    We can use the `fstat()` system call for this, which gives us information about
    a file descriptor:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code in a file and name it `fd-read.c`. Notice how we get
    the file information using `fstat()` and then read the data with `read()`. We
    still use the `open()` system call, but this time we have removed `O_CREATE` and
    changed `O_RDRW` to `O_RDONLY` to only allow reads. We will use a buffer size
    of 4,096 here so that we will be able to read some bigger files. This program
    is a bit longer, so I have split it up into several steps. All of the code in
    all of the steps goes into one file, though. First, we start by writing all the
    `include` lines, the variables, and the argument check:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Now, we write the code that opens the file descriptor using the `open()` system
    call. We add some error handling to it as well by wrapping it in an `if` statement:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Now, we write the code that fetches the file''s size using the `fstat()` system
    call. Here we also check whether the file''s size is bigger than `MAXSIZE`, in
    which case we set `maxread` to `MAXSIZE-1`. Otherwise, we set it to the file''s
    size. Then, we read the file using the `read()` system call. And finally, we print
    the content using `printf()`:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Let''s compile the program:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Let''s try it on some files and see if we can read them:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: How it works…
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we read data from a file descriptor, we must specify how many characters
    should be read. Here we must be careful not to overflow the buffer. We also don't
    want to read any more than what the file actually contains. To solve all of this,
    we first find out the file's size by using `fstat()`. That function gives us the
    same information as we saw previously in the `my-stat-v2` program when we used
    `stat()`. These two functions, `stat()` and `fstat()`, do the same thing, but
    they operate on different things. The `stat()` function operates directly on a
    file, but `fstat()` operates on a file descriptor. Since we already have a file
    descriptor open to the correct file, it makes sense to use that instead. Both
    functions save their information to a struct called `stat`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: To not overflow the buffer, we check which is bigger, the file size or `MAXSIZE`.
    If the file size is bigger or equal to `MAXSIZE`, we use `MAXSIZE-1` as the maximum
    number of characters to read. Otherwise, we use the file's size as the maximum.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: The `read()` system call takes the same arguments as `write()`, namely a file
    descriptor, a buffer, and the size we want to read (or write in the case of `write()`).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Since what we read in from a file is a bunch of characters, we can print the
    entire buffer to stdout using the regular `printf()`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you look up `man 2 fstat`, you'll notice that it's the same manual page as
    `man 2 stat`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Writing to files with streams
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will write to files using **file streams** instead of file
    descriptors, as we did in earlier recipes.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: As with the previous recipes where we had already seen file descriptors 1, 2,
    and 3, and some of their system calls, we have already seen file streams too,
    such as some of the `printUsage()` functions we have created. Some of these functions
    we created took two arguments, the first one being declared as `FILE *stream`.
    The argument we provided was stderr or stdout.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: But we can also use file streams to write to files, which we will do in this
    recipe.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: As you probably have noticed by now, some things keep coming again and again,
    such as file descriptors and file streams.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Working with file streams instead of file descriptors has some advantages. For
    example, with file streams, we can use functions such as `fprintf()` to write
    to files. This means that there are more—and more powerful—functions to read and
    write data.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we only need what's listed under the *Technical requirements*
    section of this chapter.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here we write a program that writes text to a file. The program will be similar
    to what we wrote previously using file descriptors. But this time, we will read
    the text from stdin instead of from the command line. We will also write the text
    using a file stream instead of a file descriptor:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code in a file and name it `stream-write.c`. Notice how
    much smaller this program is even though we have added a `while` loop to read
    everything from stdin. Since we can use all functions in C that operate on streams,
    we don''t need to use any special system calls to read, write, and so on. We haven''t
    even included any special header files, except `stdio.h`, which we always include
    anyway. We write the text to the file with `fprintf()`, as we have already seen
    many times when we write to stdout or stderr:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Let''s compile the program:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Now let''s try the program, both by typing in data to it and by redirecting
    data to it using a pipe. After we have redirected the entire password file into
    a new file using our program, we check that they are the same using `diff`, which
    they should be. We also try to write to a new file in a directory, which we haven''t
    got permission to. When we press *Ctrl* + *D*, we send an **EOF** to the program,
    meaning **End Of File**, indicating no more data is to be received:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: How it works…
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you might have noticed, this program is much shorter and easier than the
    corresponding file descriptor version we wrote earlier in this chapter.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating a pointer to a file stream using `FILE *fp`. Then we create
    a buffer that we use for each line.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Then, we open the file stream using `fopen()`. That function takes two arguments,
    the filename and the mode. Here the mode is also easier to set, just a `"w"` for
    write.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: After that, we use a `while` loop to loop over each input line that comes into
    stdin. On each iteration, we write the current line to the file using `fprintf()`.
    As the first argument to `fprintf()` we use the file stream pointer, just as we
    did with stderr in the `if` statement at the top of the program.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Before the program returns, we close the file stream with `fclose()`. Closing
    the stream isn't strictly necessary, but it's a good thing to do, just in case.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's a lot of information in `man 3 fopen` if you want to dig deeper.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'For a more in-depth explanation of the difference between file descriptors
    and file streams, see the GNU libc manual: [https://www.gnu.org/software/libc/manual/html_node/Streams-and-File-Descriptors.html](https://www.gnu.org/software/libc/manual/html_node/Streams-and-File-Descriptors.html).'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important aspect of streams is that they are buffered. There is more
    information about streams buffering in the GNU libc manual at this URL: [https://www.gnu.org/software/libc/manual/html_node/Buffering-Concepts.html](https://www.gnu.org/software/libc/manual/html_node/Buffering-Concepts.html).'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Reading from files with streams
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how to write to a file using streams, we will learn how to
    read a file using streams. In this recipe, we will write a similar program to
    that of the previous recipe. But this time, we will read line by line from a file
    instead and print it to stdout.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: Mastering both the writing and reading of streams will enable you to do many
    things in Linux.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All you need for this recipe is listed under the *Technical requirements* section
    of this chapter.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here we will write a program that will be very similar to the previous recipe,
    but it will read text from a file instead. The principle of the program is the
    same as the previous recipe:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code in a file and save it as `stream-read.c`. Notice how
    similar this program is. We have changed write mode (`"w"`) to read mode (`"r"`)
    when opening the stream with `fopen()`. In the `while` loop, we read from the
    file pointer `fp` instead of stdin. Inside the `while` loop, we print what is
    in the buffer, which is the current line:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Compile the program:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'And now we can try the program on some files. Here I try it on the test file
    we created earlier and the Makefile:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: How it works…
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you might have noticed, this program is very similar to that of the previous
    recipe. But instead of opening the file for writing (`"w"`), we instead open it
    for reading (`"r"`). The file pointer looks the same, as well as the linebuffer
    and the error handling.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: To read each line, we loop over the file stream using `fgets()`. As you might
    have noticed in both this and the previous recipe, we don't use `sizeof(linebuf)-1`,
    only `sizeof(linebuf)`. That is because `fgets()` only reads *one less* than the
    size we give it.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a lot of similar functions as `fgets()`. You can find all of them
    by reading the manual page for it with `man 3 fgets`.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing binary data with streams
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There comes a time when we must save variables or arrays in a program to a file.
    For example, if we make a stock-keeping program for a warehouse, we don't want
    to re-write the entire warehouse stocks every time we start the program. That
    would defeat the purpose of the program. With streams, it's easy to save variables
    as binary data in files for later retrieval.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll write two small programs: one that asks the user for
    two floats, saves them in an array, and writes them to a file, and another program
    that re-reads that array.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You only need the GCC compiler, the Make tool, and the generic Makefile for
    this recipe.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll write two small programs: one that writes and one that
    reads binary data. The data is an array of floats:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code in a file and save it as `binary-write.c`. Notice
    that we open the file in *write* mode and *binary* mode, indicated by `"wb"` as
    the second argument to `fopen()`. In binary mode, we can write variables, arrays,
    and structures to a file. The array in this program will be written to a file
    called `my-binary-file` in the current working directory. When we write binary
    data with `fwrite()`, we must specify the size of a single element (a `float`
    in this case) and how many of those elements we want to write. The second argument
    to `fwrite()` is the size of a single element and the third argument is the number
    of elements:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Before moving on, let''s compile this program:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Let''s try out the program and verify that it writes the binary file. Since
    it''s a binary file, we can''t read it with programs such as `more`. But we can,
    however, look at it with a program called `hexdump`:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Now it''s time to write the program that reads the array back from the file.
    Write the following code in a file and save it as `binary-ready.c`. Notice that
    we use `"rb"` here, for *read* and *binary*. The arguments to `fread()` are the
    same as `fwrite()`. Also, note that we need to create an array of the same type
    and length here. We will read the data from the binary file into that array:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Now, let''s compile this program:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'And finally, let''s run the program. Notice that the numbers printed here are
    the same as those numbers we gave to `binary-write`:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: How it works…
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What''s important here is `fwrite()` and `fread()`, more specifically the sizes
    we specify:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: First off, we have the `x` array. Next, we specify the size of a single element
    or item. In this case, we get the size by using `sizeof(float)`. Then, as the
    third argument, we specify how many of those elements or items. Instead of just
    typing a literal `2` here, we calculate the number of items by taking the full
    size of the array and dividing it by the size of a float. This is done with `sizeof(x)
    / sizeof(float)`. This gives us, in this case, 2.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: The reason why it's better to calculate the items rather than just setting a
    number is to avoid errors when updating the code in the future. If we change the
    array to 6 items in a couple of months, chances are that we'll forget to update
    the arguments to `fread()` and `fwrite()`.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we didn''t know beforehand how many floats the array contained, we could
    have figured it out with the following lines of code. We will learn more about
    `fseek()` later in this chapter:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Moving around inside a file with lseek()
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll learn how to move around inside a file with `lseek()`.
    This function operates on `lseek()`, we can move around (or **seek**) freely inside
    a file descriptor. Doing so can be handy if we only want to read a specific part
    of a file or we want to go back and read some data twice and so on.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will modify our previous program, called `fd-read.c`, to
    specify where we want to start reading. We also make it so that the user can specify
    how many characters should be read from that position.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To easier understand this recipe, I encourage you to read the recipe named *Reading
    from files with file descriptors* in this chapter before reading this one.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The program we will write here will read a file using file descriptors. The
    user must also set a starting position where the read should start. The user can
    also—optionally—specify how many characters to read from that position:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code and save it in a file called `fd-seek.c`. Notice the
    added `lseek()` before we do `read()`. We have also added an extra check (`else
    if`) to check that the user doesn''t read more than what the buffer can hold.
    We have also added a newline character in `printf()` when we print the file to
    stdout. Otherwise, there won''t be a new line when we specify how many characters
    to read, and the prompt would end up on the same line. This program is also rather
    long, so I have split it up into several steps. Keep in mind that all steps go
    into the same file. Let''s begin with the variables and check the number of arguments:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Now we open the file using the `open()` system call. Just as before, we check
    the system call for errors by wrapping it in an `if` statement:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'And now, we get the file''s size using the `fstat()` system call. Here we also
    check whether the file is bigger than `MAXSIZE`, in which case we set `maxread`
    to `MAXSIZE-1`. In `else if`, we check whether the user has provided a third argument
    (how much to read), and set `maxread` to whatever the user typed:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'And finally, we write the code to move the read position with `lseek()`. After
    that, we read the content with `read()` and print it with `printf()`:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Now compile the program:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'And let''s try out the program. Here we read the password file and the generic
    Makefile in our current directory:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: How it works…
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `lseek()` function moves the *read head* (sometimes called a *cursor*) inside
    the file descriptor to the position we specify. The cursor then remains at that
    position until we start `read()`. To only read the number of characters that we
    specify as the third argument, we take that argument and assign the value to `maxread`.
    Since `read()` doesn't read any more than `maxread` (the third argument to `read()`),
    only those characters are read. If we don't give the program a third argument,
    `maxread` is set to the file's size or `MAXSIZE`, whichever is the smallest.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: The third argument to `lseek()`, `SEEK_SET`, is where the cursor should be located
    in relation to the value we give as the second argument. In this case, with `SEEK_SET`,
    it means that the position should be set to whatever we specify as the second
    argument. If we wanted to move the position relative to our current position,
    we would have used `SEEK_CUR` instead. And if we wanted to move the cursor relative
    to the end of the file, we would have used `SEEK_END`.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: Moving around inside a file with fseek()
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have seen how to `lseek()`, we can see how we can do so in file
    streams with `fseek()`. In this recipe, we will write a similar program to that
    of the previous recipe, but now we will use file streams instead. There will also
    be another difference here, namely, how we specify how long we want to read. In
    the previous recipe, we specified the third argument as the number of characters
    or bytes to read. But in this recipe, we will instead specify a position, that
    is, a *from position* and a *to position*.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I advise you to read the *Reading from files with streams* recipe earlier in
    this chapter before reading this one. That will give you a better understanding
    of what's going on here.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will write a program that reads a file from a given position and optionally
    to an end position. If no end position is given, the file is read to the end:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code in a file and save it as `stream-seek.c`. This program
    is similar to `stream-read.c`, but with the added ability to specify the start
    position and optionally the end position. Notice that we have added `fseek()`
    to set the start position. To abort the read, when we have reached the end position,
    we use `ftell()` to tell us the current position. If the end position is reached,
    we break out of the `while` loop. Also, we no longer read entire lines but individual
    characters. We do this with `fgetc()`. We also print individual characters instead
    of an entire string (line). We do this with `putchar()`. After the loop, we print
    a newline character so that the prompt won''t end up on the same line as the output:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Now let''s compile it:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'And let''s try it out on some files. We try with both possible combinations:
    only a starting position, and both start and end positions:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: How it works…
  id: totrans-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `fseek()` function works similarly to `lseek()`, as we saw in the previous
    recipe. We specify `SEEK_SET` to tell `fseek()` to seek an absolute position,
    and as the second argument, we specify the position.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: The program is similar to `stream-read.c`, but we have changed how the program
    reads. Instead of reading the entire lines, we read individual characters. This
    is so that we can stop reading at the exact position we specify as the end position.
    That wouldn't be possible if we read line by line. Because we changed the behavior
    to read the file character by character, we have also changed how we print the
    file. Now we print each character with `putchar()` instead.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: After each character, we check if we are on or above the specified end position.
    If we are, we `break` out of the loop and end the entire read.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There exists a whole family of functions related to `fseek()`. You can find
    them all by reading the `man 3 fseek` manual page.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
