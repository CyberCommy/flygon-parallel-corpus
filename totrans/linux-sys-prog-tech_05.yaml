- en: '*Chapter 5*: Working with File I/O and Filesystem Operations'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: File I/O is an important part of system programming since most programs must
    read or write data to and from files. Doing file I/O also requires the developer
    to know a thing or two about the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Mastering file I/O and filesystem operations will make you not only a better
    programmer but also a better system administrator.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn about the Linux filesystem and inodes. We will
    also learn how to read and write files on the system, using both streams and file
    descriptors. We will also look at system calls to create and delete files and
    change file permissions and ownership. At the end of the chapter, we will learn
    how to fetch information about files.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Reading inode information and learning the filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating soft links and hard links
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating files and updating the timestamp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting access rights and ownership
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting access rights and ownership
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing to files with file descriptors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading from files with file descriptors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing to files with streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading from files with streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading and writing binary data with streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving around inside a file with `lseek()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving around inside a file with `fseek()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you'll need the GCC compiler, the Make tool, and the generic
    Makefile we made in the *Writing a generic Makefile with GCC options* recipe in
    [*Chapter 3*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097), *Diving Deep into
    C in Linux*. [*Chapter 1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020), *Getting
    the Necessary Tools and Writing Our First Linux Programs*, covers installing the
    compiler and the Make tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'The generic Makefile, along with all the source code examples for this chapter,
    can be downloaded from GitHub at this URL: [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch5](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch5).'
  prefs: []
  type: TYPE_NORMAL
- en: We are going to look up functions and header files in the built-in manual in
    Linux. If you are using Debian or Ubuntu, the Linux Programmer's Manual is installed
    as part of the *build-essentials* meta-package, covered in [*Chapter 1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020),
    *Getting the Necessary Tools and Writing Our First Linux Programs*. You'll also
    need to install the *POSIX Programmer's Manual*, covered in the *Getting information
    about Linux and Unix-specific header files* recipe in [*Chapter 3*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097),
    *Diving Deep into C in Linux*. If you are using CentOS or Fedora, these manuals
    are most likely already installed. Otherwise, check out the recipe in [*Chapter
    3*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097), *Diving Deep into C in Linux*,
    that I mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following link to see the Code in Action video: [https://bit.ly/3u4OuWz](https://bit.ly/3u4OuWz)'
  prefs: []
  type: TYPE_NORMAL
- en: Reading inode information and learning the filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding inodes is the key to understanding the filesystem in Linux at
    a deeper level. A filename isn't the actual file in a Linux or Unix system. It's
    just a **pointer** to an **inode**. The inode has information about where the
    actual data is stored and a lot of meta data about the file, such as the file
    mode, last modification date, and owner.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll get a general understanding of the **filesystem** and
    how inodes fit into this. We will also view inode information and learn a few
    commands for that. We will also write a small C program that reads inode information
    from a filename.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we'll use both commands and C programs to explore the concepts
    of inodes. Everything you need for this recipe is covered in the *Technical requirements*
    section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll begin by exploring the commands that already exist on
    the system to view inode information. Then, we''ll create a small C program to
    print inode information:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by creating a small text file that we''ll use throughout this
    recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s view the *inode number* for this file, along with its size, block
    count, and other information. The inode number will be different on every system
    and for every file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The size is in bytes and is 36 bytes. Since no special characters are used
    in the text, this will be the same as the number of characters the file contains.
    We can count the number of characters with `wc`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s build a small program that extracts some of this information; the
    inode number, the file size, and the number of `my-stat-v1.c`. The name of the
    system call function that we''ll use to extract information has the same name
    as the command-line tool, `stat`. The system call function is highlighted in the
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now compile this program using Make and the generic `Makefile`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try the program on `testfile1`. Compare the inode number, size, and
    number of links. These numbers should be the same as when we used the `stat` program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we don''t type an argument, we''ll get a usage message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And if we try it on a file that doesn''t exist, we''ll get an error message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The filename of a file isn''t the data or file. The filename is just a link
    to an inode. And that inode, in turn, contains information about where on the
    filesystem the actual data is stored. As we will see in the next recipe, an inode
    can have multiple names or *links*. A filename is also called a link sometimes.
    The following figure illustrates the concepts of filenames that point to the inode,
    and the inode contains information about where the **data blocks** are stored:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Inodes and filenames'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.1_B13043.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – Inodes and filenames
  prefs: []
  type: TYPE_NORMAL
- en: An inode also contains `stat` command.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 4*, we created a small C program that reads this metadata using a system
    call function with the same name as the command, `stat()`. The `stat()` system
    call extracts much more data than what we printed here. We will print more of
    this information throughout this chapter. All of this information is stored in
    a struct called `stat`. We find all the information we need about this struct
    in the `man 2 stat` manual page. In that manual page, we also see what data types
    the variables are (`ino_t`, `off_t`, and `nlink_t`). And then, in `man sys_types.h`,
    under **Additionally**, we find what types these are.
  prefs: []
  type: TYPE_NORMAL
- en: The fields we use here are `st_ino` for the inode number, `st_size` for the
    file size, and `st_nlink` for the number of links to the file.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 6*, we saw that the information we extracted using our C program was
    the same as the information from the `stat` command.
  prefs: []
  type: TYPE_NORMAL
- en: We also implemented error handling in the program. The `stat()` function is
    wrapped in an `if` statement, checking its return value for -1\. And if an error
    does occur, we print an error message to *stderr* with the filename and the error
    message from `errno`. The program also returns the `errno` variable to the shell.
    We learned all about error handling and `errno` in [*Chapter 4*](B13043_04_Final_SK_ePub.xhtml#_idTextAnchor147)*,
    Handling Errors in Your Programs*.
  prefs: []
  type: TYPE_NORMAL
- en: Creating soft links and hard links
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we touched on the subject of links. In this recipe,
    we'll learn more about links and how they affect inodes. We'll also investigate
    the difference between **soft links** and **hard links**. In short, a hard link
    is a filename, and a soft link is like a shortcut to a filename.
  prefs: []
  type: TYPE_NORMAL
- en: On top of that, we'll write two programs, one that creates a hard link and one
    that creates a soft link. We'll then use the program we created in the previous
    recipe to check the **link count**.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Except for the requirements listed at the beginning of this chapter, you'll
    also need the program we created in the previous recipe, `my-stat-v1.c`. You'll
    also need the test file we created in the previous recipe, named `testfile1`.
    If you haven't created those files yet, you can also download them from GitHub
    at [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch5](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch5).
  prefs: []
  type: TYPE_NORMAL
- en: You'll also need to compile the `my-stat-v1.c` program using Make so you'll
    be able to execute it, if you haven't done so already. You compile it with `make
    my-stat-v1`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create both soft links and hard links, using both the built-in commands
    and writing simple C programs to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by creating a new hard link to our test file, `testfile1`. We''ll
    name the new hard link `my-file`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s investigate this new filename. Note how the links have increased
    to `2`, but the rest is the same as for `testfile1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now compare these numbers with the `testfile1` file. They should all be the
    same:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create another hard link called `another-name`. We create this link
    using the name `my-file` as the target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll investigate this file as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s delete the `testfile1` filename:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have deleted the first filename we created, we''ll investigate
    the other two names:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s time to create a soft link. We create a soft link called `my-soft-link`
    to the name `another-name`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'A soft link is a special file type, which we can see with the `ls` command.
    Note that we get a new timestamp here. Also, note that it''s a special file, which
    can be seen by the first letter in the file mode field, the letter `l` for a link:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s check the link count of `another-name`. Note that the counter hasn''t
    increased with the soft link:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s time to write our own program to create hard links. There exists an easy-to-use
    `link()` that we''ll use for this. Write the following code in a file and save
    it as `new-name.c`. The `link()` system call is highlighted in the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new name to our previous `my-file` file. Name the new file `third-name`.
    We also try to generate some errors to see that the program prints the correct
    error messages. Note that the inode information for `third-name` is the same as
    for `my-file`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s create a program that creates a soft link. There''s an easy-to-use
    system call for this as well, called `symlink()`, for `new-symlink.c`. The `symlink()`
    system call is highlighted in the code. Notice how similar all of these system
    call functions are:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'And let''s try it out, creating a new soft link called `new-soft-link` to `third-name`.
    Also, let''s try generating some errors so we can verify that the error handling
    is working:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's a lot going on here, so let's take it from the top.
  prefs: []
  type: TYPE_NORMAL
- en: In steps 1 to 7, we created two new hard links to the `testfile1` file. But
    as we noticed, there's nothing special about a hard link; it's just another name
    to an inode. All filenames are hard links. A filename is just a link to an inode.
    We saw that when we deleted the `testfile1` filename. The two remaining names
    link to the same inode, and it contains the same text. There is nothing special
    about the first filename or link. There's no way to tell which of the hard links
    was created first. They are equal; they even share the same date, even though
    the other links were made at a later time. The date is for the inode, not the
    filenames.
  prefs: []
  type: TYPE_NORMAL
- en: As we created and deleted hard links, we saw how the link count increased and
    decreased. This is the inode keeping count of how many links—or names—it has.
  prefs: []
  type: TYPE_NORMAL
- en: The inode isn't deleted until the last name is deleted, that is, when the link
    counter reaches zero.
  prefs: []
  type: TYPE_NORMAL
- en: In *steps 8 to 10*, we saw that a soft link, on the other hand, is a special
    file type. A soft link doesn't count toward the inode's link counter. The file
    is denoted by an `l` at the start of the `ls -l` output. We can also see what
    file the soft link points to in the `ls -l` output. Think of a soft link as a
    shortcut.
  prefs: []
  type: TYPE_NORMAL
- en: In *steps 11 to 13*, we wrote a C program that creates a hard link—a new name—to
    an existing filename. Here we learned that the system calls for creating new names
    is called `link()` and takes two arguments, the target and the new name.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 13*, we witnessed an interesting property for hard links. They cannot
    span across devices. When we think about it, it makes sense. The filename can't
    remain on a device separate from the inode. If the device is removed, there might
    not be any more names pointing to the inode, making it inaccessible.
  prefs: []
  type: TYPE_NORMAL
- en: For the remaining steps, we wrote a C program that creates soft links to existing
    files. This system call is similar to `link()` but is instead called `symlink()`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please look at the manual pages for the system calls we covered in this recipe;
    they contain some great explanations of both hard links and soft links. The manual
    pages are `man 2 link` and `man 2 symlink`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating files and updating the timestamp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we understand the filesystem, inodes, and hard links, we'll learn how
    to create files by writing our own version of `touch` in C. We have already started
    writing a version of `touch` in [*Chapter 4*](B13043_04_Final_SK_ePub.xhtml#_idTextAnchor147)*,
    Handling Errors in Your Programs,* where we learned about error handling. We will
    continue using the latest version of that program, which we named `simple-touch-v7.c`.
    The real version of `touch` updates the modification and access **timestamp**
    of a file if the file exists. In this recipe, we'll add that feature to our new
    version.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Everything you'll need for this recipe is listed in the *Technical requirements*
    section for this chapter. Although we will add on the latest version of `simple-touch`,
    we'll write the entire code in this recipe. But for complete comprehension of
    the program, it is wise to read through [*Chapter 4*](B13043_04_Final_SK_ePub.xhtml#_idTextAnchor147)*,
    Handling Errors in Your Programs,* first.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this eighth version of `simple-touch`, we will add the feature to update
    the access and modification date of a file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code in a file and save it as `simple-touch-v8.c`. Here
    we will use the `utime()` system call to update a file''s access and modification
    timestamps. The changes from the previous version are highlighted in the code
    (except for the added comments). Also, note how the `creat()` system call has
    moved into an `if` statement. The `creat()` system call is only called if the
    file doesn''t already exist:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the program using Make:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try it out and see how it works. We''ll try it on the filenames we created
    in the previous recipe and see how each filename gets the same timestamp since
    they all point to the same inode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we added the feature to update the timestamp of a file—or inode,
    as we have learned that it is.
  prefs: []
  type: TYPE_NORMAL
- en: To update the access and modification time, we use the `utime()` system call.
    The `utime()` system call takes two arguments, a filename and a timestamp. But
    if we give the function `NULL` as the second argument, it will use the current
    time and date.
  prefs: []
  type: TYPE_NORMAL
- en: The call to `utime()` is wrapped in an `if` statement, which checks whether
    the return value is -1\. If it is, then something is wrong, and `errno` is set
    (see [*Chapter 4*](B13043_04_Final_SK_ePub.xhtml#_idTextAnchor147)*, Handling
    Errors in Your Programs*, for an in-depth explanation of `errno`). We then use
    `errno` to check whether it was a *File not found* error (`ENOTENT`). If the file
    doesn't exist, we create it using the `creat()` system call. The call to `creat()`
    is also wrapped in an `if` statement. If something goes wrong while creating a
    file, the program prints an error message and return the `errno` value. If the
    program managed to create the file, it continues down to `return 0`.
  prefs: []
  type: TYPE_NORMAL
- en: If the `errno` value from `utime()` wasn't `ENOENT`, it continues down to the
    `else` statement, prints an error message, and returns `errno`.
  prefs: []
  type: TYPE_NORMAL
- en: When we tried the program, we noticed that both `my-file` and `third-name` got
    an updated timestamp when we updated one of them. This is because the filenames
    are just links to the same inode. And the timestamp is metadata in the inode.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's a lot of useful information in `man 2 creat` and `man 2 utime`. If you
    are interested in learning more about time and dates in Linux, I recommend you
    read `man 2 time`, `man 3 asctime`, and `man time.h`.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we learn how to `unlink()`—comes from. This recipe will enhance
    your understanding of links and close the circle. This will improve your overall
    knowledge of Linux and its filesystem. Knowing how to delete files using the system
    call will enable you to remove files directly from within your programs.
  prefs: []
  type: TYPE_NORMAL
- en: Here we will write our own version of `rm`, which we will call `remove`. After
    this recipe, we know how to create and delete files and how to make links. These
    are some of the most common filesystem operations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will use the `my-stat-v1` program, which we wrote in the
    *Reading inode information and learning the filesystem* recipe. We will also continue
    experimenting on the filenames we created in the previous recipes, `my-file`,
    `another-name`, and `third-name`. Except for that, you'll need what's listed under
    *Technical requirements* for this chapter, that is, the GCC compiler, the Make
    tool, and the generic Makefile.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow along here to write a simple version of `rm`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code in a file and save it as `remove.c`. This program
    uses the `unlink()` system call to remove a file. The system call is highlighted
    in the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile it using the **Make** tool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'And let''s try it out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The system call to remove a file is called `unlink()`. The name comes from the
    fact that when we remove a filename, we only remove a hard link to that inode;
    hence we **unlink** a filename. If it happens to be the last filename to an inode,
    then the inode is also removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `unlink()` system calls only takes one argument: the filename that we want
    to remove.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting access rights and ownership
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll write a program that reads the access rights and ownership
    of a file using the `stat()` system call we have seen previously in this chapter.
    We will continue to build upon the `my-stat-v1` program that we built in the first
    recipe in this chapter. Here we will add the features to show ownership and access
    rights as well. Knowing how to get the owner and access rights programmatically
    is key to working with files and directories. It will enable you to check whether
    the user has the appropriate permissions and print an error message if they haven't.
  prefs: []
  type: TYPE_NORMAL
- en: We will also learn how access rights are interpreted in Linux and how to convert
    between numerical representation and letter representation. Understanding access
    rights in Linux is key to being a Linux system programmer. Every file and directory
    on the entire system has access rights and an owner and a group assigned to them.
    It doesn't matter whether it's a log file, a system file, or just a text file
    that a user owns. Everything has access rights.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you'll only need what's listed in the *Technical requirements*
    section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will write a new version of `my-stat-v1` in this recipe. We will write the
    entire program here, though, so you don''t need the previous version:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code in a file and save it as `my-stat-v2.c`. In this version,
    we''ll pull information about the owner and the group of the file and the file
    mode. To translate the `getpwuid()`. To get the group name for a `getgrgid()`.
    The changes are highlighted in the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Try out the program on some different files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this version of `my-stat`, we have added features to retrieve the file access
    mode, or actually, the **file mode**. The file's complete file mode consists of
    six octal numbers. The first two (to the left) is the file type. In this case,
    it's a regular file (10 equals a regular file). The fourth octal digit is for
    the **set-user-ID bit**, the **set-group-ID bit**, and the **sticky bit**. The
    last three octal digits are for the **access mode**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the output from `ls -l`, all these bits are instead represented as letters.
    But when we write programs, we must set and read these as numbers. Before we move
    on, let''s examine the letter-version of the file mode, so we truly understand
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – File access mode'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.2_B13043.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – File access mode
  prefs: []
  type: TYPE_NORMAL
- en: The set-user-ID bit is a bit that allows a process to run as the owner of the
    binary file, even though it is executed as a different user. Setting the set-user-ID
    bit is potentially dangerous and *not* something we should set on our programs.
    One program that does use the set-user-ID bit is the `passwd` program. The `passwd`
    program must update the `/etc/passwd` and `/etc/shadow` files when a user changes
    his or her password, even though those files are owned by root. Under normal circumstances,
    we can't even read the `/etc/shadow` file as a regular user, but with the set-user-ID
    bit set on the `passwd` program, it can even write to it. If the set-user-ID bit
    is set, it's denoted by an `s` in the third place of the user's access mode.
  prefs: []
  type: TYPE_NORMAL
- en: The set-group-ID has a similar effect. When a program is executed, and the set-group-ID
    bit is set, it is executed as that group. When the set-group-ID is set, it's denoted
    by an `s` in the third place of the group's access mode.
  prefs: []
  type: TYPE_NORMAL
- en: The sticky bit was historically used to *stick* a program to the swap space
    for faster loading time. Nowadays, it's used entirely differently. Now, the name—as
    well as the meaning—has changed to *restricted deletion flag*. When a directory
    has the sticky bit set, only a file's owner, the directory owner, or the root
    user can remove a file, even if the directory is writeable by anybody. For example,
    the `/tmp` directory usually has the sticky bit set. A sticky bit is denoted by
    a `t` in the last position of the last group.
  prefs: []
  type: TYPE_NORMAL
- en: File access mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we run `ls -l` on a file, we always see two names. The first name is the
    user (the owner), and the second name is the group that owns the file. Take this,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `jake` is the user (owner), and `devops` is the group.
  prefs: []
  type: TYPE_NORMAL
- en: The file access modes are easier to understand than the special flags we just
    covered. Take a look at *Figure 5.2*. The first three letters are the user's access
    mode (the owner of the file). This particular example has `rw-`, which means that
    the user can read and write the file but not execute it. If the user were to be
    able to execute it, that would be denoted by an `x` in the last place.
  prefs: []
  type: TYPE_NORMAL
- en: The middle three letters are for the group access mode (the group that owns
    the file). In this case, the group can only read the file since the group is missing
    both the `w` for write and the `x` for execution.
  prefs: []
  type: TYPE_NORMAL
- en: The last three letters are for all others (not the owner and not in the owner
    group). In this case, everybody else can just read the file.
  prefs: []
  type: TYPE_NORMAL
- en: A full set of permissions would be `rwxrwxrwx`.
  prefs: []
  type: TYPE_NORMAL
- en: Converting access modes between letters and numeric
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An **octal number** represents the file access mode. Until we get used to it,
    the easiest way to convert from letters to octal is to use a pen and paper. We
    add all the numbers together in each group where that access bit is set. If it
    is not set (a dash), then we don''t add that number. When we''re finished adding
    each group, we have the access mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding octal access mode is therefore 644\. Let''s do another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding access mode turns out to be 775\. Let''s take one more example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This access mode is 600.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other way around can also be done by using a pen and paper. Let''s say
    we have the access mode 750, and we want to convert that into letters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Hence, 750 becomes `rwxr-x---`.
  prefs: []
  type: TYPE_NORMAL
- en: When you have been doing it for a while, you learn the most commonly used access
    modes and don't need a pen and paper anymore.
  prefs: []
  type: TYPE_NORMAL
- en: The file mode in octal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The same principle applies here as with the file access mode. Remember that
    the set-user-ID is denoted by an `s` in the user''s execute position, and the
    set-group-ID is denoted by an `s` in the group''s execute bit. A `t` character
    denotes the sticky bit in the last execute bit position (the "others"). If we
    write it in a row, we get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: So if only the set-user-ID bit is set, we get a 4\. If both the set-user-ID
    and set-group-ID is set, we get *4+2=6*. If only the set-group-ID bit is set,
    we get a 2\. If only the sticky bit is set, we get a 1, and so forth. And if all
    the bits are set, we get a *7 (4+2+1)*.
  prefs: []
  type: TYPE_NORMAL
- en: These file modes are represented by a number before the file access mode. For
    example, the octal file mode `4755` has the set-user-ID bit set (the 4).
  prefs: []
  type: TYPE_NORMAL
- en: 'When we program under Linux, we can even encounter two more numbers, as we
    saw with the output from our `my-stat-v2` program. There, we had this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The two first numbers, `10` in this example, are the file type. Exactly what
    these two first numbers mean is something we''ll have to look up in the `man 7
    inode` manual page. There we have a nice table telling us what it means. I have
    made a simplified list here, showing only the first two numbers we are interested
    in and what file type it represents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: That means that our example file is a regular file (10).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we add up everything we just learned and translate the file mode *100755*
    from the preceding example output from `my-stat-v2`, we get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The file type is also denoted by a letter at the very first position (see *Figure
    5.2*). The letters are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Setting access rights and ownership
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we learned how to read the `chmod` command and the `chmod()`
    system call. We will also learn how to change the owner and group of a file, using
    both the `chown` command and the `chown()` system call.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to set access rights properly will help you keep your systems and
    files secure.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you'll only need what's listed in the *Technical requirements*
    section of this chapter. It's also a good idea to read the previous recipe to
    understand permissions in Linux. You will also need the `my-stat-v2` program from
    the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These steps will teach us how to change the access rights and ownership of files
    and directories.
  prefs: []
  type: TYPE_NORMAL
- en: Access rights
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will start by setting the access rights of a file by using the `chmod` command.
    We will then write a simple C version of the `chmod` command, using the `chmod()`
    system call:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by removing the execute permission from our `my-stat-v2` program,
    using the `chmod` command. The `-x` in the following command means *remove eXecute*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s try to execute the program. This should now fail with permission
    denied:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we change it back again, but this time we set the *absolute* permission
    using octal numbers. Suitable permissions for executable files are 755, which
    translates to `rwxr-xr-x`. That, in turn, means that the user has full permissions
    and, the group can read and execute the file. The same goes for all others; they
    can read and execute it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'After this command, we can once again execute the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s time to write a simple version of the `chmod` command, using the
    `chmod()` system call. Write the following code in a file and save it as `my-chmod.c`.
    The `chmod()` system call takes two arguments, the path to the file or directory
    and the file permission expressed as an octal number. Before we get to the `chmod()`
    system call, we perform some checks to ensure that the permission seems reasonable
    (an octal number that is either three or four digits long). After the checks,
    we convert the number to an octal number with `strtol()`. The third argument to
    `strtol()` is the base, in this case, `8`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Now compile the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Test the program using different permissions. Don''t forget to check the result
    using `ls -l`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also try to set the set-user-ID bit. This set-user-ID bit (and set-group-ID
    and sticky bit) is the fourth digit in front of the access mode. A `4` here sets
    the set-user-ID bit. Note the `s` (highlighted in the following code) in the user
    field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try to set all bits (set-user-ID, set-group-ID, sticky bit, and all
    permissions):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, change it back to something more sensible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Ownership
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'But we also need to know how to change the `chown` command or the `chown()`
    system call:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To change the owner of a file, we must be root. Regular users cannot give away
    ownership of their files. Likewise, they cannot claim ownership of someone else''s
    files. Let''s try to change the owner of `my-stat-v2` to root using the `chown`
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to change both the owner and the group, we separate the user and
    the group using a colon. The first field is the owner, and the second field is
    the group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'And now it''s our turn to write a simplified version of `chown`, using the
    `chown()` system call. The `chown()` system call only takes user IDs as numerical
    values. To be able to use names instead, we must first look up the username using
    `getpwnam()`. This will give us the numerical value in the `passwd` struct, in
    the `pw_uid` field. The same goes for the group. We must get the numerical group-ID
    using its name, using the `getgrnam()`system call. Now that we know all the system
    calls, let''s write the program. Name it `my-chown.c`. This program is a bit longer,
    so I have split it up into several steps. Keep in mind that all steps should go
    into a single file (`my-chown.c`). You can also download the entire code from
    [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch5/my-chown.c](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch5/my-chown.c)
    if you wish. Let''s start with all the header files, the variables, and the arguments
    check:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we write the username and group as `username:group` in the argument,
    we need to extract the username part and the group part. We do this with a string
    function called `strtok()`. We only provide the first argument (the string) in
    the first call to `strtok()`. After this, we get the `user` struct and the `grp`
    struct. We also check whether the user and group exist:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we update the user and group of the file using the `chown()` system
    call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compile the program so that we can try it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we test the program on a file. Remember that we need to be root to change
    a file''s owner and group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every file and directory on the system has access rights and an owner/group
    pair. The access rights are changed with the `chmod` command or the `chmod()`
    system call. The name is short for *change mode bits*. In the previous recipe,
    we covered how to translate access rights between the more human-readable text
    format and the numerical octal form. In this recipe, we wrote a program that changed
    the mode bits using the `chmod()` system call using the numerical form.
  prefs: []
  type: TYPE_NORMAL
- en: To convert the numerical form into an octal number, we used `strtol()` with
    `8` as the third argument, which is the numeral system base. Base 8 is octal;
    base 10 is the regular decimal system we use in everyday life; base 16 is hexadecimal,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: We wrote the program so that the user can choose whatever they want to set,
    whether that's only the access mode bits (three digits) or also the special bits
    such as set-user-ID, set-group-ID, and sticky bit (four digits). To determine
    the number of digits the user typed, we use `strlen()`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next program we wrote, we used `chown()` to update the owner and group
    of a file or directory. Since we want to update the user and group using the names,
    not the numerical UID and GID, the program got more complex. The `chown()`system
    call only takes the UID and GID, not names. That means we need to look up the
    UID and GID before we can call `chown()`. To look up the UID and GID, we use `getpwnam()`
    and `getgrnam()`. Each of these functions gives us a `struct` containing all information
    available for the respective user or group. From those structs, we extract the
    UID and GID, which we then use in the call to `chown()`.
  prefs: []
  type: TYPE_NORMAL
- en: To separate the username and group part from the command line (the colon), we
    use the `strtok()` function. In the first call to the function, we specify the
    string as the first argument (in this case, `argv[1]`) and the separator (a colon).
    In the next call to `strtok()`, we leave out the string by setting it to `NULL`,
    but we still specify the separator. The first call gives us the username and the
    second call gives us the group name.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we check whether the username and group name exist when we call
    `getpwnam()` and `getgrnam()`. If the username or group name don't exist, the
    functions return `NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several similar functions to `getpwnam()` and `getgrnam()`, depending
    on what information you have and what information you have. If you have the UID,
    you instead use `getpwuid()`. Likewise, if you have the GID, you use `getgrgid()`.
    There is more information—and more functions—if you read the `man 3 getpwnam`
    and `man 3 getgrnam` manual pages.
  prefs: []
  type: TYPE_NORMAL
- en: Writing to files with file descriptors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen some uses of **file descriptors** in previous chapters,
    for example, 0, 1, and 2 (*stdin*, *stdout*, and *stderr*). But in this recipe,
    we will use file descriptors to write text to files from a program.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to use file descriptors to write to files both gives you a deeper
    understanding of the system and enables you to do some low-level stuff.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you only need what is listed under the *Technical requirements*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here we will write a small program that writes text to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code in a file and save it as `fd-write.c`. The program
    takes two arguments: a string and a filename. To write to a file using file descriptors,
    we must first open the file with the `open()` system call. The `open()` system
    call returns a file descriptor, which is an integer. We then use that file descriptor
    (the integer) with the `write()` system call. We have already seen `write()` in
    [*Chapter 3*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097)*, Diving Deep into
    C in Linux*. In that chapter, we used `write()` to write a small text to stdout.
    This time, we use `write()` to write a text to a file. Notice that the `open()`
    system call takes three arguments: the path to the file, which mode the file shall
    open in (in this case, create the file if it doesn''t exist, and open it in read-write
    mode), and the `0644`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compile the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'And let''s try to write some text to a file. Remember that if the file already
    exists, the content will be overwritten! If the new text is smaller than the old
    content of the file, only the beginning will be overwritten. Also note that if
    the text doesn''t contain a new line, the text in the file won''t contain a new
    line either:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even give it input from another file if we use `xargs`, a program that
    allows us to take the output of a program and parse it as a command-line argument
    to another program. Notice that this time, `testfile1` will have a new line at
    the end. The `-0` option to `xargs` makes it ignore new lines and will instead
    use the null character to indicate the end of the argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `open()` system call returns a file descriptor, which we save in the `fd`
    variable. A file descriptor is just an integer, just as 0, 1, and 3 are *stdin*,
    *stdout*, and *stderr*.
  prefs: []
  type: TYPE_NORMAL
- en: The second argument we give to `open()` are macros with mode bits that are put
    together using *bitwise-or*. In our case, we use both `O_CREAT` and `O_RDWR`.
    The first one, `O_CREAT`, means that if the file doesn't exist, it is created.
    The second one, `O_RDWR`, means that the file should be open for both reading
    and writing.
  prefs: []
  type: TYPE_NORMAL
- en: To write the string to the file, we pass the file descriptor to `write()` as
    the first argument. As the second argument, we give it `argv[2]`, which contains
    the string that we want to write to the file descriptor. The last argument is
    the size of what we want to write. In our case, we get the size of `argv[2]` with
    `strlen`, a function from `string.h` to get the length of strings.
  prefs: []
  type: TYPE_NORMAL
- en: Just as in the previous recipes, we check all the system calls for `-1`. If
    they return `-1`, something has gone wrong, and we use `perror()` to print an
    error message, and then we return `1`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a program returns normally, all open file descriptors are closed automatically.
    But if we want to close a file descriptor explicitly, we use the `close()` system
    call with the file descriptor as its argument. In our case, we could have added
    `close(fd)` just before the return.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a lot of good information about `open()`, `close()`, and `write()`
    in the manual pages. I suggest you read them for more in-depth information. You
    can read them with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`man 2 open`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`man 2 close`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`man 2 write`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading from files with file descriptors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we learned how to write to files using file descriptors.
    In this recipe, we will learn how to read from files using file descriptors. We
    will therefore write a small program that is similar to `cat`. It takes one argument—a
    filename—and prints its content to standard output.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to read—and use—file descriptors enables you to read not only files
    but all sorts of data that comes through a file descriptor. File descriptors are
    a universal way to read and write data in Unix and Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The only things you'll need for this recipe are listed under the *Technical
    requirements* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Reading a file using a file descriptor is similar to writing to one. Instead
    of using the `write()` system call, we will instead use the `read()` system call.
    Before we can read the content, we must figure out the size of the file first.
    We can use the `fstat()` system call for this, which gives us information about
    a file descriptor:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code in a file and name it `fd-read.c`. Notice how we get
    the file information using `fstat()` and then read the data with `read()`. We
    still use the `open()` system call, but this time we have removed `O_CREATE` and
    changed `O_RDRW` to `O_RDONLY` to only allow reads. We will use a buffer size
    of 4,096 here so that we will be able to read some bigger files. This program
    is a bit longer, so I have split it up into several steps. All of the code in
    all of the steps goes into one file, though. First, we start by writing all the
    `include` lines, the variables, and the argument check:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we write the code that opens the file descriptor using the `open()` system
    call. We add some error handling to it as well by wrapping it in an `if` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we write the code that fetches the file''s size using the `fstat()` system
    call. Here we also check whether the file''s size is bigger than `MAXSIZE`, in
    which case we set `maxread` to `MAXSIZE-1`. Otherwise, we set it to the file''s
    size. Then, we read the file using the `read()` system call. And finally, we print
    the content using `printf()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compile the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try it on some files and see if we can read them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we read data from a file descriptor, we must specify how many characters
    should be read. Here we must be careful not to overflow the buffer. We also don't
    want to read any more than what the file actually contains. To solve all of this,
    we first find out the file's size by using `fstat()`. That function gives us the
    same information as we saw previously in the `my-stat-v2` program when we used
    `stat()`. These two functions, `stat()` and `fstat()`, do the same thing, but
    they operate on different things. The `stat()` function operates directly on a
    file, but `fstat()` operates on a file descriptor. Since we already have a file
    descriptor open to the correct file, it makes sense to use that instead. Both
    functions save their information to a struct called `stat`.
  prefs: []
  type: TYPE_NORMAL
- en: To not overflow the buffer, we check which is bigger, the file size or `MAXSIZE`.
    If the file size is bigger or equal to `MAXSIZE`, we use `MAXSIZE-1` as the maximum
    number of characters to read. Otherwise, we use the file's size as the maximum.
  prefs: []
  type: TYPE_NORMAL
- en: The `read()` system call takes the same arguments as `write()`, namely a file
    descriptor, a buffer, and the size we want to read (or write in the case of `write()`).
  prefs: []
  type: TYPE_NORMAL
- en: Since what we read in from a file is a bunch of characters, we can print the
    entire buffer to stdout using the regular `printf()`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you look up `man 2 fstat`, you'll notice that it's the same manual page as
    `man 2 stat`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing to files with streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will write to files using **file streams** instead of file
    descriptors, as we did in earlier recipes.
  prefs: []
  type: TYPE_NORMAL
- en: As with the previous recipes where we had already seen file descriptors 1, 2,
    and 3, and some of their system calls, we have already seen file streams too,
    such as some of the `printUsage()` functions we have created. Some of these functions
    we created took two arguments, the first one being declared as `FILE *stream`.
    The argument we provided was stderr or stdout.
  prefs: []
  type: TYPE_NORMAL
- en: But we can also use file streams to write to files, which we will do in this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: As you probably have noticed by now, some things keep coming again and again,
    such as file descriptors and file streams.
  prefs: []
  type: TYPE_NORMAL
- en: Working with file streams instead of file descriptors has some advantages. For
    example, with file streams, we can use functions such as `fprintf()` to write
    to files. This means that there are more—and more powerful—functions to read and
    write data.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we only need what's listed under the *Technical requirements*
    section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here we write a program that writes text to a file. The program will be similar
    to what we wrote previously using file descriptors. But this time, we will read
    the text from stdin instead of from the command line. We will also write the text
    using a file stream instead of a file descriptor:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code in a file and name it `stream-write.c`. Notice how
    much smaller this program is even though we have added a `while` loop to read
    everything from stdin. Since we can use all functions in C that operate on streams,
    we don''t need to use any special system calls to read, write, and so on. We haven''t
    even included any special header files, except `stdio.h`, which we always include
    anyway. We write the text to the file with `fprintf()`, as we have already seen
    many times when we write to stdout or stderr:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compile the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s try the program, both by typing in data to it and by redirecting
    data to it using a pipe. After we have redirected the entire password file into
    a new file using our program, we check that they are the same using `diff`, which
    they should be. We also try to write to a new file in a directory, which we haven''t
    got permission to. When we press *Ctrl* + *D*, we send an **EOF** to the program,
    meaning **End Of File**, indicating no more data is to be received:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you might have noticed, this program is much shorter and easier than the
    corresponding file descriptor version we wrote earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating a pointer to a file stream using `FILE *fp`. Then we create
    a buffer that we use for each line.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we open the file stream using `fopen()`. That function takes two arguments,
    the filename and the mode. Here the mode is also easier to set, just a `"w"` for
    write.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we use a `while` loop to loop over each input line that comes into
    stdin. On each iteration, we write the current line to the file using `fprintf()`.
    As the first argument to `fprintf()` we use the file stream pointer, just as we
    did with stderr in the `if` statement at the top of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Before the program returns, we close the file stream with `fclose()`. Closing
    the stream isn't strictly necessary, but it's a good thing to do, just in case.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's a lot of information in `man 3 fopen` if you want to dig deeper.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a more in-depth explanation of the difference between file descriptors
    and file streams, see the GNU libc manual: [https://www.gnu.org/software/libc/manual/html_node/Streams-and-File-Descriptors.html](https://www.gnu.org/software/libc/manual/html_node/Streams-and-File-Descriptors.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important aspect of streams is that they are buffered. There is more
    information about streams buffering in the GNU libc manual at this URL: [https://www.gnu.org/software/libc/manual/html_node/Buffering-Concepts.html](https://www.gnu.org/software/libc/manual/html_node/Buffering-Concepts.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Reading from files with streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how to write to a file using streams, we will learn how to
    read a file using streams. In this recipe, we will write a similar program to
    that of the previous recipe. But this time, we will read line by line from a file
    instead and print it to stdout.
  prefs: []
  type: TYPE_NORMAL
- en: Mastering both the writing and reading of streams will enable you to do many
    things in Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All you need for this recipe is listed under the *Technical requirements* section
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here we will write a program that will be very similar to the previous recipe,
    but it will read text from a file instead. The principle of the program is the
    same as the previous recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code in a file and save it as `stream-read.c`. Notice how
    similar this program is. We have changed write mode (`"w"`) to read mode (`"r"`)
    when opening the stream with `fopen()`. In the `while` loop, we read from the
    file pointer `fp` instead of stdin. Inside the `while` loop, we print what is
    in the buffer, which is the current line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'And now we can try the program on some files. Here I try it on the test file
    we created earlier and the Makefile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you might have noticed, this program is very similar to that of the previous
    recipe. But instead of opening the file for writing (`"w"`), we instead open it
    for reading (`"r"`). The file pointer looks the same, as well as the linebuffer
    and the error handling.
  prefs: []
  type: TYPE_NORMAL
- en: To read each line, we loop over the file stream using `fgets()`. As you might
    have noticed in both this and the previous recipe, we don't use `sizeof(linebuf)-1`,
    only `sizeof(linebuf)`. That is because `fgets()` only reads *one less* than the
    size we give it.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a lot of similar functions as `fgets()`. You can find all of them
    by reading the manual page for it with `man 3 fgets`.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing binary data with streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There comes a time when we must save variables or arrays in a program to a file.
    For example, if we make a stock-keeping program for a warehouse, we don't want
    to re-write the entire warehouse stocks every time we start the program. That
    would defeat the purpose of the program. With streams, it's easy to save variables
    as binary data in files for later retrieval.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll write two small programs: one that asks the user for
    two floats, saves them in an array, and writes them to a file, and another program
    that re-reads that array.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You only need the GCC compiler, the Make tool, and the generic Makefile for
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll write two small programs: one that writes and one that
    reads binary data. The data is an array of floats:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code in a file and save it as `binary-write.c`. Notice
    that we open the file in *write* mode and *binary* mode, indicated by `"wb"` as
    the second argument to `fopen()`. In binary mode, we can write variables, arrays,
    and structures to a file. The array in this program will be written to a file
    called `my-binary-file` in the current working directory. When we write binary
    data with `fwrite()`, we must specify the size of a single element (a `float`
    in this case) and how many of those elements we want to write. The second argument
    to `fwrite()` is the size of a single element and the third argument is the number
    of elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Before moving on, let''s compile this program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try out the program and verify that it writes the binary file. Since
    it''s a binary file, we can''t read it with programs such as `more`. But we can,
    however, look at it with a program called `hexdump`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s time to write the program that reads the array back from the file.
    Write the following code in a file and save it as `binary-ready.c`. Notice that
    we use `"rb"` here, for *read* and *binary*. The arguments to `fread()` are the
    same as `fwrite()`. Also, note that we need to create an array of the same type
    and length here. We will read the data from the binary file into that array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s compile this program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, let''s run the program. Notice that the numbers printed here are
    the same as those numbers we gave to `binary-write`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What''s important here is `fwrite()` and `fread()`, more specifically the sizes
    we specify:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: First off, we have the `x` array. Next, we specify the size of a single element
    or item. In this case, we get the size by using `sizeof(float)`. Then, as the
    third argument, we specify how many of those elements or items. Instead of just
    typing a literal `2` here, we calculate the number of items by taking the full
    size of the array and dividing it by the size of a float. This is done with `sizeof(x)
    / sizeof(float)`. This gives us, in this case, 2.
  prefs: []
  type: TYPE_NORMAL
- en: The reason why it's better to calculate the items rather than just setting a
    number is to avoid errors when updating the code in the future. If we change the
    array to 6 items in a couple of months, chances are that we'll forget to update
    the arguments to `fread()` and `fwrite()`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we didn''t know beforehand how many floats the array contained, we could
    have figured it out with the following lines of code. We will learn more about
    `fseek()` later in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Moving around inside a file with lseek()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll learn how to move around inside a file with `lseek()`.
    This function operates on `lseek()`, we can move around (or **seek**) freely inside
    a file descriptor. Doing so can be handy if we only want to read a specific part
    of a file or we want to go back and read some data twice and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will modify our previous program, called `fd-read.c`, to
    specify where we want to start reading. We also make it so that the user can specify
    how many characters should be read from that position.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To easier understand this recipe, I encourage you to read the recipe named *Reading
    from files with file descriptors* in this chapter before reading this one.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The program we will write here will read a file using file descriptors. The
    user must also set a starting position where the read should start. The user can
    also—optionally—specify how many characters to read from that position:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code and save it in a file called `fd-seek.c`. Notice the
    added `lseek()` before we do `read()`. We have also added an extra check (`else
    if`) to check that the user doesn''t read more than what the buffer can hold.
    We have also added a newline character in `printf()` when we print the file to
    stdout. Otherwise, there won''t be a new line when we specify how many characters
    to read, and the prompt would end up on the same line. This program is also rather
    long, so I have split it up into several steps. Keep in mind that all steps go
    into the same file. Let''s begin with the variables and check the number of arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we open the file using the `open()` system call. Just as before, we check
    the system call for errors by wrapping it in an `if` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, we get the file''s size using the `fstat()` system call. Here we also
    check whether the file is bigger than `MAXSIZE`, in which case we set `maxread`
    to `MAXSIZE-1`. In `else if`, we check whether the user has provided a third argument
    (how much to read), and set `maxread` to whatever the user typed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we write the code to move the read position with `lseek()`. After
    that, we read the content with `read()` and print it with `printf()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Now compile the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'And let''s try out the program. Here we read the password file and the generic
    Makefile in our current directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `lseek()` function moves the *read head* (sometimes called a *cursor*) inside
    the file descriptor to the position we specify. The cursor then remains at that
    position until we start `read()`. To only read the number of characters that we
    specify as the third argument, we take that argument and assign the value to `maxread`.
    Since `read()` doesn't read any more than `maxread` (the third argument to `read()`),
    only those characters are read. If we don't give the program a third argument,
    `maxread` is set to the file's size or `MAXSIZE`, whichever is the smallest.
  prefs: []
  type: TYPE_NORMAL
- en: The third argument to `lseek()`, `SEEK_SET`, is where the cursor should be located
    in relation to the value we give as the second argument. In this case, with `SEEK_SET`,
    it means that the position should be set to whatever we specify as the second
    argument. If we wanted to move the position relative to our current position,
    we would have used `SEEK_CUR` instead. And if we wanted to move the cursor relative
    to the end of the file, we would have used `SEEK_END`.
  prefs: []
  type: TYPE_NORMAL
- en: Moving around inside a file with fseek()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have seen how to `lseek()`, we can see how we can do so in file
    streams with `fseek()`. In this recipe, we will write a similar program to that
    of the previous recipe, but now we will use file streams instead. There will also
    be another difference here, namely, how we specify how long we want to read. In
    the previous recipe, we specified the third argument as the number of characters
    or bytes to read. But in this recipe, we will instead specify a position, that
    is, a *from position* and a *to position*.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I advise you to read the *Reading from files with streams* recipe earlier in
    this chapter before reading this one. That will give you a better understanding
    of what's going on here.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will write a program that reads a file from a given position and optionally
    to an end position. If no end position is given, the file is read to the end:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code in a file and save it as `stream-seek.c`. This program
    is similar to `stream-read.c`, but with the added ability to specify the start
    position and optionally the end position. Notice that we have added `fseek()`
    to set the start position. To abort the read, when we have reached the end position,
    we use `ftell()` to tell us the current position. If the end position is reached,
    we break out of the `while` loop. Also, we no longer read entire lines but individual
    characters. We do this with `fgetc()`. We also print individual characters instead
    of an entire string (line). We do this with `putchar()`. After the loop, we print
    a newline character so that the prompt won''t end up on the same line as the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s compile it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'And let''s try it out on some files. We try with both possible combinations:
    only a starting position, and both start and end positions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `fseek()` function works similarly to `lseek()`, as we saw in the previous
    recipe. We specify `SEEK_SET` to tell `fseek()` to seek an absolute position,
    and as the second argument, we specify the position.
  prefs: []
  type: TYPE_NORMAL
- en: The program is similar to `stream-read.c`, but we have changed how the program
    reads. Instead of reading the entire lines, we read individual characters. This
    is so that we can stop reading at the exact position we specify as the end position.
    That wouldn't be possible if we read line by line. Because we changed the behavior
    to read the file character by character, we have also changed how we print the
    file. Now we print each character with `putchar()` instead.
  prefs: []
  type: TYPE_NORMAL
- en: After each character, we check if we are on or above the specified end position.
    If we are, we `break` out of the loop and end the entire read.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There exists a whole family of functions related to `fseek()`. You can find
    them all by reading the `man 3 fseek` manual page.
  prefs: []
  type: TYPE_NORMAL
