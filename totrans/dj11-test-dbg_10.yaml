- en: 'Chapter 10. When All Else Fails: Getting Outside Help'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes we run into problems that do not seem to be caused by our own code.
    Though following the documentation to the best of our understanding, the results
    we are getting don't match what we expect. One of the benefits of building on
    open source code such as Django is that we can delve into its code and figure
    out exactly where things are going wrong. However, that may not be the best use
    of our time.
  prefs: []
  type: TYPE_NORMAL
- en: Most often a better first step in tracking down such problems is to consult
    community resources. Perhaps someone else has already encountered the problem
    we are facing and found a fix or workaround. If so, we can likely save a lot of
    time by taking advantage of their experience rather than finding our own solution
    to the problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter describes the Django community resources and illustrates how to
    use them. Specifically, in this chapter we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Walk through the discovery of a bug that existed in the Django 1.1 release and
    caused a problem for some of the survey application code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See how the resources available on the Django website can be used to research
    the problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discuss the best way to proceed based on the results of the research, for both
    this problem specifically and problems in general
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn what other avenues for getting help exist, and how best to make use of
    them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracking down a problem in Django
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book has been written using the latest available Django release at the
    time of writing. Early on that was Django 1.1\. Then, during the course of writing,
    Django 1.1.1 was released and everything written after that release date used
    Django 1.1.1\. The three 1s in that release number are the major, minor, and micro
    release numbers. (A missing micro number, as in Django 1.1, is an implied 0.)
    Django 1.1.1, since it has an explicit micro number, is called a micro release.
    The only changes made in micro releases are bug fixes, thus micro releases are
    100 percent backwards compatible with the previous release. While a change in
    a major or minor version number may involve some backwards-incompatible changes
    that require code adjustments, the only difference you will see in updating to
    a new micro release is fewer bugs. Therefore, it is always recommended to run
    the latest micro release for the major.minor version you are using.
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite this advice and compatibility guarantee, it''s sometimes tempting to
    not upgrade to the latest available release. Upgrading requires some (likely small,
    but non-zero) amount of work. In addition, there''s always the common-sense axiom:
    if it isn''t broken, don''t fix it. If you''re not actually experiencing any problems,
    why upgrade?'
  prefs: []
  type: TYPE_NORMAL
- en: 'I had exactly these thoughts when Django 1.1.1 was released. That release happened
    to occur right during the middle of writing [Chapter 7](ch07.html "Chapter 7. When
    the Wheels Fall Off: Understanding a Django Debug Page"), *When the Wheels Fall
    Off: Understanding a Django Debug Page*, a chapter full of screenshots and console
    displays showing tracebacks that included Django code. If I changed the Django
    code base right in the middle of writing that chapter, even by just a micro release,
    who knew what subtle differences might be introduced in early compared to late-chapter
    tracebacks? Such differences could cause confusion for eagle-eyed readers.'
  prefs: []
  type: TYPE_NORMAL
- en: If I did upgrade mid-chapter, it would be safest to re-do all the examples from
    the beginning to ensure they were consistent. That was an unattractive option
    since it was both a fair amount of work and error-prone. Thus my initial inclination
    when Django 1.1.1 was released was to delay upgrading until at least the next
    chapter break.
  prefs: []
  type: TYPE_NORMAL
- en: However, in the end I found I did have to upgrade in the middle of the chapter,
    because I ran into a Django bug that was fixed by the 1.1.1 release. The following
    sections describe encountering the bug and show how it can be tracked down to
    a problem that had been fixed in Django 1.1.1.
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the Chapter 7 voting form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recall in [Chapter 7](ch07.html "Chapter 7. When the Wheels Fall Off: Understanding
    a Django Debug Page") we implemented the code to display an active survey. This
    includes a form to allow a user to choose answers for each question in the survey.
    One of the final changes made to the form code involved customizing the error
    format. The final code for the `QuestionVoteForm` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The inclusion of the `PlainErrorList` class, and setting the form instance''s
    `error_class` attribute to it during `__init__`, is intended to change the display
    of an error for a question from an HTML unordered list (the default behavior)
    to a simple string. However, when running this code under Django 1.1, and forcing
    an error situation by attempting to submit a survey with both questions unanswered,
    the result displayed is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Revisiting the Chapter 7 voting form](img/7566_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The inclusion of the bullets to the left of the two error messages shows that
    the error lists are still being formatted as HTML unordered lists. This can also
    be confirmed by checking the HTML source for the page, which includes the following
    snippet for each error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It seems that setting the `error_class` attribute is not having any effect.
    How can we best track down a problem like this?
  prefs: []
  type: TYPE_NORMAL
- en: Is the right code actually running?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we need to make sure the code that is running is actually the code we
    think is running. In this case, when I encountered the problem I could see that
    the development server had restarted after the code changes to add the `PlainErrorList`
    class and the setting of the `error_class` attribute, so I was pretty sure the
    right code was running. Still, inserting an `import pdb; pdb.set_trace()` right
    before the `error_class` assignment allowed me to confirm the code was there and
    doing what I expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here we can see that on entry to the debugger, before our assignment of `PlainErrorList`
    to `error_class`, this attribute had the value `django.forms.util.ErrorList`.
    Stepping through the assignment shows that the `__init__` method is then about
    to return, and checking the value of the `error_class` attribute again shows that
    indeed the value has been changed to our customized `PlainErrorList`. That all
    looks good. At the very end of the form creation code, the `error_class` attribute
    has been set to the customized class. Why isn't it being used?
  prefs: []
  type: TYPE_NORMAL
- en: Is the code correct as per the documentation?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next step (after removing the added breakpoint) is to double-check the
    documentation. Though it seems unlikely, perhaps there is something else required
    to use a custom error class? After rechecking the documentation, there doesn''t
    seem to be. The full documentation on customizing the error class is simply:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Is the code correct as per the documentation?](img/7566_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are a couple of slight differences between what the provided example does
    and what the `QuestionVoteForm` does. First, the provided example passes the error
    class as an argument on form creation, and thus it is passed to the form's superclass
    `__init__`. The `QuestionVoteForm`, on the other hand, manually sets `error_class`
    after the superclass `__init__` runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This seems unlikely to be the cause of the problem, since over-riding values
    in a subclass `__init__` routine, as we have done with `QuestoinVoteForm`, is
    a very common idiom. We can check, though, to see if this slight difference causes
    a problem by attempting the demonstration of use of the custom `error_class` setting,
    as shown in the documentation in a Python shell, for the `QuestionVoteForm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we have created a form instance, `qvf`, for the question with primary
    key `1` in the database. By passing in an empty `data` dictionary, we have forced
    the error condition of a form submitted with no `answer` value. The documentation
    shows that using the form''s `as_p` method to display this form should show the
    error formatted using the form''s custom error class. We can check whether that
    happens for the `QuestionVoteForm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'There we see that the `as_p` method does indeed use the custom error class:
    there is no HTML unordered list wrapped around the error message. So the error
    class is being set, and is used when the form is displayed using a routine like
    `as_p`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads to the second difference between what the documentation shows and
    what the survey application code actually does. The `survey/active_survey.html`
    template does not use `as_p` to display the form. Rather, it individually prints
    the label for the answer field, errors for the answer field, and then the answer
    field itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Should that cause the custom error class to not be used for display? You wouldn't
    think so. Though the documentation only shows the custom error class used with
    `as_p`, there is no mention there that the custom error class is only used by
    the convenience display methods such as `as_p`. Such a restriction would be very
    limiting, since the convenience form display methods are frequently not appropriate
    for a non-trivial form.
  prefs: []
  type: TYPE_NORMAL
- en: It seems clear that the intent of the `error_class` attribute is to override
    the error display regardless of the exact way in which a form is output, but it
    doesn't seem to be working. This is the point where we may begin to strongly suspect
    a bug in Django instead of some error or misunderstanding of usage in the application
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Searching for a matching problem report
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next step, then, is to visit the Django website to see if anyone has reported
    a problem using `error_class`. Choosing the **Code** link from the main Django
    project page (rightmost of the links across the top of the page) brings up the
    main page for Django''s code tracker:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Searching for a matching problem report](img/7566_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The Django project uses Trac, which provides an easy-to-use web-based interface
    for tracking bugs and feature requests. With Trac, bugs and feature requests are
    reported and tracked in tickets. Specifics of the way in which the Django project
    has configured Trac, and thus the meaning of the various ticket attribute values,
    can be found in the Django documentation page on contributing. Specifically, the
    diagram and descriptions found here: [http://docs.djangoproject.com/en/dev/internals/contributing/#ticket-triage](http://docs.djangoproject.com/en/dev/internals/contributing/#ticket-triage)
    are very helpful in understanding all of the information associated with a ticket.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What we want to do now is search the Django project tickets for reported problems
    with the use of `error_class`. One way to do that is to select the **View Tickets**
    tab and construct an appropriate search. When **View Tickets** is first selected,
    by default it will show a page listing all non-closed tickets. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Searching for a matching problem report](img/7566_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The criteria used to generate the report are shown in the box labeled **Filters**.
    Here we see that the report includes all tickets with any status that is not **closed**,
    since that is the only **Status** choice that is not checked. In order to get
    a report that is more useful for what we are trying to research, we need to modify
    the search criteria in the **Filters** box.
  prefs: []
  type: TYPE_NORMAL
- en: First, we can remove the constraint on the ticket status. We are interested
    in all reports related to `error_class`, regardless of ticket status. We can remove
    the existing constraint on status by clicking the box with a minus sign on the
    extreme right side of the line that contains the constraint.
  prefs: []
  type: TYPE_NORMAL
- en: Second, we need to add a filter for the search constraint we want to apply.
    To do this, we select an appropriate choice from the **Add filter** drop-down
    box. This drop-down box contains a full list of the ticket attributes we could
    search on, such as **Reporter**, **Owner**, **Status**, and **Component**. Most
    of these attributes are not relevant for the search we are currently interested
    in. The one in the list most likely to find what we are looking for is **Summary**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ticket summary is the brief description of the problem. We could hope that
    this summary would include the string `error_class` for any reports of the problem
    we have run into with using it. Adding a single filter on **Summary** with a specification
    that it contains the string `error_class` will thus hopefully find any relevant
    tickets. Clicking on the **Update** button to refresh the search results given
    the new criteria then shows the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Searching for a matching problem report](img/7566_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There have been three tickets opened that contain `error_class` (or `error class`)
    in the summary. Two have been closed, one is still open (status **new**). Of the
    three, based on the displayed summary, the top one sounds like it might be the
    problem we are seeing with `error_class`, while the other two do not sound particularly
    relevant.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get more details on a listed problem by clicking on the ticket number
    or summary, both of which are links to view the full ticket details. Looking at
    the full details will allow us to verify that it is really the same as what we
    are seeing, and find out more details on when and why it was closed. In this case,
    we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Searching for a matching problem report](img/7566_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This ticket has a fairly long history—two years between when it was opened
    and the last activity. The short guide for reproducing the problem does make it
    sound like exactly the same problem we are seeing with `error_class`. The resolution
    of **fixed** listed after the ticket number near the top sounds encouraging, but
    unfortunately this ticket has no details on what code change was made, and when,
    to fix the problem. Scrolling all the way down to the tail end of the various
    comments added to the ticket history, we see that the last few updates are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Searching for a matching problem report](img/7566_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In August of 2009 user **peter2108** was interested in helping move the ticket
    along by providing patches, including tests, to fix the problem (reading through
    the full history, the lack of tests in the originally-provided patches was one
    reason this ticket was open for a long time). Then, on October 16, 2009, **peter2108**
    closed the ticket with a resolution of **fixed**.
  prefs: []
  type: TYPE_NORMAL
- en: It may not be obvious at first, but this way of closing a ticket is not typical
    for a ticket that required a Django code change. Normally, when the code change
    is committed to the Django SVN repository, the ticket number is included in the
    commit message and the corresponding ticket is automatically updated with a comment
    including the commit message and a link to the changeset. This automatic process
    also closes the ticket with a resolution of fixed. This makes it very easy to
    see exactly what code was changed to fix the problem and when the code change
    was made.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes that automatic process fails to run properly, and usually someone
    will notice when that happens and manually close the ticket, noting which code
    update fixed the problem. But that's not what happened here either. Rather it
    looks like **peter2108**, who was interested in seeing the bug fixed, simply noticed
    that the problem had gone away at some point and closed the ticket as fixed.
  prefs: []
  type: TYPE_NORMAL
- en: We could guess, based on the fact that the same user who was interested in getting
    the problem fixed in August closed the ticket as fixed in October, that the fix
    went into the code base sometime between August 28 and October 16\. What we'd
    like, though, is to know for sure when exactly the fix was made, so we could know
    for sure whether we should already have it in the code we are running, or if updating
    to the latest release would fix the problem, or if the fix is available only in
    a version of code pulled directly from the SVN repository.
  prefs: []
  type: TYPE_NORMAL
- en: Looking back at the other two tickets that mention `error_class` in the summary,
    neither of them are helpful in determining when exactly this problem with `error_class`
    was fixed, since they describe different problems entirely. How, then, can we
    locate the information about when exactly the problem we are encountering was
    fixed? For this case, it turns out that the **View Tickets** type of search is
    not broad enough to get us the information we are looking for. Fortunately, there's
    an alternate way of searching the Django tracker that we can use to find the missing
    information.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to search for a matching problem report
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This alternative way of searching is found by clicking on the **Search** tab
    instead of the **View Tickets** tab. This brings up a page with a single text
    entry box and three check boxes to control where to search: **Tickets**, **Changesets**,
    and **Wiki**.'
  prefs: []
  type: TYPE_NORMAL
- en: This page provides a much broader and less targeted way of searching. In addition
    to searching ticket data, changesets and Wiki articles are searched by default
    as well. Even when those options are turned off, the ticket search alone is broader
    than what is possible under **View Tickets**. The ticket search from this page
    covers all of the ticket comments and updates, which cannot be searched under
    **View Tickets**.
  prefs: []
  type: TYPE_NORMAL
- en: A plus side of using this page to search is it may find relevant results that
    cannot be found using a **View Tickets** search. A downside of using this page
    to search is it may find an overwhelming number of irrelevant results, depending
    on exactly what search terms are entered in the textbox. If that happens you can
    further limit the results shown by entering more words that must be matched in
    the textbox, which can help. In this case, though, searching on a string as uncommon
    as `error_class` is not likely to produce an overwhelming number of results.
  prefs: []
  type: TYPE_NORMAL
- en: 'To proceed, then, entering `error_class` in the textbox and clicking on the
    **Search** button leads to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Another way to search for a matching problem report](img/7566_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This search does produce more results than the **View Tickets** search—twelve
    instead of three. The first result listed, ticket **#12001**, is the same as the
    still-open ticket found by the previous search. The other results from the previous
    search are also contained in the full list, only further down. But first we can
    see a result that is a changeset, **[11498]**, which mentions `error_class` in
    the commit message, and its associated ticket **#10968**. This ticket did not
    show up in the original search we tried because, though it includes reference
    to `error_class` in the full description, the string `error_class` is not in the
    ticket summary.
  prefs: []
  type: TYPE_NORMAL
- en: Clicking through to the details of ticket **#10968** shows that it is a duplicate
    report of the same problem we have encountered and that was reported in the other
    ticket we found, **#6138**. Ordinarily when duplicates like this are opened, they
    are quickly closed as duplicates with a reference to the existing ticket that
    describes the problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if nobody realizes a new ticket is a duplicate, then the duplicate
    ticket may turn out to be the one referenced when the fix is checked into the
    code base. That''s apparently what happened in this case. We can see in the last
    update to this new ticket the automatically-generated comment added when the fix
    was committed to the SVN repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Another way to search for a matching problem report](img/7566_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The changeset number in that comment is a link to a detailed description of
    the changeset. Clicking on it, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Another way to search for a matching problem report](img/7566_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here we can see all the detailed information related to this code change: when
    it was made, who made it, the commit message, the files that were changed (or
    added or deleted), the specific lines in the files that were changed, and what
    those changes were. Most of this information is more than we really need to know
    for the problem we are researching now, but it can come in handy at times. For
    this problem, what we''d like to know is: what released level of code contains
    this fix? We''ll consider that question next.'
  prefs: []
  type: TYPE_NORMAL
- en: Determining the release that contains a fix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the particular case we are looking at, we can tell, simply based on dates,
    that the first release containing the fix should be Django 1.1.1\. A quick check
    of the web log on the Django project home page shows that Django 1.1 was released
    on July 29, 2009 and Django 1.1.1 was released on October 9, 2009\. All bug fixes
    made between those dates should be included in the 1.1.1 release, thus a fix made
    on September 11, 2009 should be in Django 1.1.1.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes things may not be so clear. For example, we might be unsure if a code
    change made on the same day as a release was included in the release or happened
    just after the release. Alternatively, we might be unsure if a change was classified
    as a bug fix or a new feature. For such cases, we can check on the revision number
    of the release and compare it to the revision we are interested in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Django uses the standard subversion practice of tagging released versions;
    the tagged release versions can be found under `root/django/tags/releases`. We
    can navigate down this path by first selecting the **Browse Code** tab and then
    selecting each path component in turn. Navigating in this way to the 1.1.1 release
    and clicking on **Revision Log** in the upper-right corner brings up the following
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Determining the release that contains a fix](img/7566_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This shows that the 1.1.1 tagged release version was created by copying the
    1.1.X release branch. The changeset that created the tag is **[11612]**, higher
    than the changeset we are interested in (11498), so we'd expect the fix we are
    concerned with to be in the 1.1.X release.
  prefs: []
  type: TYPE_NORMAL
- en: But wait a minute. Looking at the details of changeset 11498, the files changed
    were on trunk (`django/trunk/django/forms/forms.py`, for example), not the 1.1.X
    release branch `django/branches/releases/1.1.X`. If the release was created by
    copying the 1.1.X branch but the fix was only made to trunk, is it really included
    in the 1.1.1 release?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is yes. Clicking through the link on this page to the 1.1.X release
    branch, selecting **Revision Log** for it, and scrolling down to the bottom shows
    that the 1.1.X release branch was created as a copy of trunk at revision 11500,
    two revisions past the revision 11498 we are interested in. Thus, when the 1.1.X
    branch was initially created, it contained the fix we are looking for.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might wonder why the 1.1.X branch was not created until sometime after
    September 11, 2009 when the 1.1 release went out in late July. The reason is because
    once the release branch is created, bug fixes have to be applied in two different
    places: trunk and the latest release branch. This is slightly more work than having
    to apply them in only one place (trunk). Creation of the release branch is thus
    generally delayed for some period of time after a release to allow bug fixes to
    be made more easily.'
  prefs: []
  type: TYPE_NORMAL
- en: This delayed creation of the release branch means that during the time it does
    not exist, no changes related to new features can be made to trunk, since the
    release branch must contain only bug fixes, and no new features. That's generally
    not a problem, though, since right after a release there is little feature work
    being done. Everyone involved usually needs some time to take a breather and first
    decide what features might go into the next release. Once some feature work for
    the next release gets close to needing to be checked in, then the release branch
    for the previous release is created. From then on, feature work gets checked into
    trunk while bug fixes get checked in to both trunk and the release branch.
  prefs: []
  type: TYPE_NORMAL
- en: What if a fix hasn't been released yet?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here we were lucky enough to run into a problem that had already been fixed,
    and the fix was already available in an officially released version. In any case
    of a problem like this that is encountered, it should be an easy choice to simply
    update to the latest micro release to get the fix. As mentioned earlier, it is
    always recommended to install the latest micro release for the particular major.minor
    version in use.
  prefs: []
  type: TYPE_NORMAL
- en: But what if the fix we wanted was made sometime after the latest available release?
    What should we do then? The easy technical answer is to simply check out the latest
    level of either trunk or the release branch that contains the fix, and run with
    that code. If the release branch, in particular, is used, there should be no concern
    about picking up any code instabilities, since the only changes that go into the
    release branch are bug fixes.
  prefs: []
  type: TYPE_NORMAL
- en: This easy technical answer may, however, run afoul of local policies regarding
    running only "release level" code. If you are working in an environment with such
    policies, you may have some additional hurdles to overcome in order to use fixes
    that have not yet been made available in an official version. The best course
    to take will likely be determined by factors such as the exact policies you are
    dealing with, the severity of the problem you have encountered, and the ability
    to find a workaround in your own code.
  prefs: []
  type: TYPE_NORMAL
- en: What if a fix hasn't been committed yet?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes when researching a problem the results will show that the problem
    has been reported, but not yet fixed. How best to proceed then will likely depend
    on how interested you are in getting involved and contributing to Django, and
    how close the matching problem report is to being fixed. Details of how to get
    involved in contributing to Django are beyond the scope of what is covered here,
    but this section provides some broad guidelines for how to proceed based on your
    level of interest. If you are interested in contributing, the Django website has
    details of how to contribute, available at: [http://docs.djangoproject.com/en/dev/internals/contributing/](http://docs.djangoproject.com/en/dev/internals/contributing/).'
  prefs: []
  type: TYPE_NORMAL
- en: If you are not interested in experimenting with code that has not yet been committed
    to the code base, there will likely not be much you can do besides wait for a
    fix to be committed. The exception to this would be for problems that are not
    well understood. In that case, you may be able to provide specific details of
    the case where you are running into the problem that can help others better understand
    the problem and develop a fix.
  prefs: []
  type: TYPE_NORMAL
- en: If you are willing to experiment with uncommitted code, you'll likely be able
    to find a workable solution to the problem you've encountered more quickly. In
    the best case, you may find that the ticket matching the problem you have encountered
    already has a working patch attached. It's possible and all you need to do is
    download it and apply it to your copy of the Django code to resolve the problem.
  prefs: []
  type: TYPE_NORMAL
- en: You'll then have to decide whether you are able to, and comfortable with, deploying
    your application with a version of Django that has some "custom" fixes applied.
    If not, you might like to help out in getting the working patch checked into the
    code base by seeing if there is anything missing (such as tests) that needs to
    be included before the fix is checked in and if so, supplying the missing bits.
    In some cases, though, there is nothing missing and all that is needed is time
    for the fix to make its way into the code base.
  prefs: []
  type: TYPE_NORMAL
- en: If you find a matching ticket with a patch that you try, but it doesn't fix
    the problem you are experiencing, that is valuable information that would be useful
    to post to the ticket. You might want to be sure first, though, that your problem
    is really the same as the one in the ticket you have found. If it's really a slightly
    different problem, then it might be more appropriate to open a new ticket for
    the somewhat different problem.
  prefs: []
  type: TYPE_NORMAL
- en: When in doubt, you can always post information in what you think is the matching
    ticket about the problem you are seeing and how the existing patch doesn't seem
    to fix it. Someone else following the ticket might then be able to provide feedback
    on whether your problem is the same and the existing patch is indeed not quite
    right or whether you are really dealing with a different problem.
  prefs: []
  type: TYPE_NORMAL
- en: In the worst case, you may find a ticket reporting the same problem as you are
    experiencing but no attached patch to try. That's not very helpful to you, but
    offers you the most opportunity to contribute. If you have the time and are so
    inclined, you can delve into the Django code and see if you can come up with a
    patch that you can post to the ticket to help get the problem fixed.
  prefs: []
  type: TYPE_NORMAL
- en: What if a ticket has been closed without a fix?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes when researching a problem the results will turn up with a matching
    report (or multiple reports) that have been closed without any fix being made.
    There are three different resolutions that might be used in cases like this: invalid,
    worksforme, and wontfix. How best to proceed will depend on the specifics of the
    problem report and the resolution used to close the matching problem ticket.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the invalid resolution is pretty broad. A ticket might be closed as
    invalid for many different reasons, including:'
  prefs: []
  type: TYPE_NORMAL
- en: The described problem is not a problem at all but rather some error in the reporter's
    code or misunderstanding about how some feature is supposed to work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The described problem is too vague. For example, if a ticket is opened that
    provides just an error traceback but no information on how to trigger the traceback,
    there is not much anyone can do to help track down and fix the problem, so it
    might well be closed as invalid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The described problem is indeed a problem, but the root cause is some code other
    than Django. If there is nothing that can be done in Django code to fix the problem,
    the ticket will likely be closed as invalid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In cases where you find a matching ticket that has been closed as invalid, you
    should read the comment that was made when the ticket was closed. In cases where
    the ticket was closed due to lack of information about the problem, and you can
    provide some of the missing data needed to make progress on fixing the problem,
    it may be appropriate to re-open the ticket. Otherwise, if you don't understand
    the explanation for closing, or don't agree with the reason for closing, it's
    best to start a discussion on one of the mailing lists (discussed in the next
    section) to get some more feedback on how best to proceed to fix the problem you
    are encountering.
  prefs: []
  type: TYPE_NORMAL
- en: The worksforme resolution is pretty straightforward; it indicates that the person
    who closed the ticket could not reproduce the reported problem. It, like invalid,
    may be used when the original problem report does not really contain enough information
    to recreate the problem. The missing information may be specifics of the code
    used to cause the problem, or specifics of the environment (operating system,
    Python version, deployment specifics) where the problem occurs. If you are able
    to recreate a problem that has been closed worksforme, and can supply the missing
    details that would allow someone else to do the same, you should feel free to
    re-open the ticket and provide that information.
  prefs: []
  type: TYPE_NORMAL
- en: The wontfix resolution is also straightforward. Usually only core committers
    will close tickets wontfix, and that indicates that a decision has been made by
    the core team to not fix that particular problem (which will usually be a feature
    request, not a bug). If you disagree with a wontfix decision or believe that not
    all of the appropriate information was considered in making the decision, you
    will not make any forward progress on changing anyone's mind by simply re-opening
    the ticket. Rather, you will need to bring the issue up on the django-developers
    mailing list and see if you can get enough consensus from the wider development
    community to get the wontfix decision reversed.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking down unreported problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes when researching a problem no matching reports will turn up. How best
    to proceed then likely depends on how sure you are that the problem you are encountering
    is a bug in Django. If you are really sure the problem lies in Django, you can
    proceed directly to opening a new ticket to report it. If you are not so sure,
    it is best to get some feedback from the community first. The following sections
    will describe where to ask questions, present some tips on asking good questions,
    and describe how to open a new ticket.
  prefs: []
  type: TYPE_NORMAL
- en: Where to ask questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Clicking on the **Community** link on any Django website page brings up the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wheunreported problems, trackingaboutre to ask questions](img/7566_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The left side of this page provides links to articles in blogs written by people
    who discuss Django. While reading such entries is a good way to learn about the
    community of people using Django, it is the right side of this page that we are
    interested in right now. Here we see links to ways to interact directly with other
    members of the Django community.
  prefs: []
  type: TYPE_NORMAL
- en: First in the list is a link to the **#django IRC channel**. (**IRC** stands
    for **Internet Relay Chat**.) This option provides a chat-type interface to talk
    to other Django users interactively. This is a good choice for times when you'd
    like very quick feedback on whatever you'd like to ask about or discuss. It can
    be difficult, though, to follow a detailed coding discussion in a chat interface.
    For cases like that, one of the mailing lists is likely a better alternative.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two mailing lists, shown next: **django-users** and **django-developers**.
    The first is for discussions about using Django, the second is for discussions
    about developing Django itself. If you have encountered a problem that you think,
    but are not sure, is a problem in Django, django-users is the correct place to
    post a question about the issue. Members of the Django core development team read
    and respond to questions on the user''s list and will provide feedback on whether
    the problem should be opened as a ticket or taken to the developer''s list for
    further discussion.'
  prefs: []
  type: TYPE_NORMAL
- en: Both of the mailing lists are hosted as Google groups. Each of the group names
    previously shown is actually a link that you can click to go directly to the Google
    groups page for the group. From there you can see the list of recent discussions
    in the group, and read any topics that might be of interest. Google groups also
    provide a search function, but unfortunately this function does not always work
    correctly, so searching in the group from the group's page may not produce helpful
    results.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you decide you want to post to one of the groups, you will first need to
    join it. This helps to cut down on spam posted to the groups, since would-be spammers
    must first join. There are, however, plenty of would-be spammers that do join
    and attempt to send spam to the lists. Thus, there is also an additional anti-spam
    measure in place: posts sent by new members are sent through moderation.'
  prefs: []
  type: TYPE_NORMAL
- en: This anti-spam measure means that the first post you send to either of these
    lists may take some time to appear, since it must be manually approved by one
    of the volunteer moderators. Usually this will not take very long, but it could
    take up to a few hours. Typically, once a first obviously legitimate post is received
    from a user, their status is updated to indicate their posts do not need to be
    moderated, so subsequent posts will appear in the group immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Tips on asking questions that will get good answers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you decide to post a question, the next task will be to compose a question
    in a way that will most likely produce some helpful answers. This section presents
    some guidance on how to do that.
  prefs: []
  type: TYPE_NORMAL
- en: First, be specific about what you are doing. If you have some code that isn't
    behaving as you expect, include the code verbatim rather than describing in prose
    what the code does. Often, it is the detailed specifics of the actual code in
    use that is key to understanding a problem, and those specifics are easily lost
    in a prose description of the code.
  prefs: []
  type: TYPE_NORMAL
- en: However, if the code is too lengthy or too wide to be read easily in an e-mail
    interface that will automatically wrap long lines, it's likely best not to include
    it in a post. Ideally in a situation like this you would be able to cut the code
    necessary to recreate the problem down to a manageable size that can be read easily
    in an e-mail, and post that.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you do this, it's a good idea to first verify that the cut-down
    version of the code is both correct (does not have any syntax errors, for example)
    and exhibits the problem you are asking about. Otherwise, the only responses you
    get may simply report that the posted code either doesn't work at all or doesn't
    show the behavior you describe.
  prefs: []
  type: TYPE_NORMAL
- en: If you cannot cut the necessary code down to a manageable size, either because
    you do not have the time or because cutting it down makes the problem go away,
    you might try posting the code on some place like dpaste.com and just including
    a link to it in your question. It is really in your best interest, though, to
    keep the code needed to demonstrate the problem as short as possible. As the code
    you post or point to gets longer and longer, fewer and fewer people on the mailing
    list will take the time to try to understand the problem and help guide you towards
    a solution.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to being specific about the code you are using, be specific about
    what you are doing to trigger the errant behavior. Are you observing a problem
    when you visit one of your own application URLs? When you do something in the
    admin application? When you try something from a `manage.py` shell? It may seem
    obvious to you, but it really helps others to recreate the problem if you spell
    out what you are doing.
  prefs: []
  type: TYPE_NORMAL
- en: Second, be specific about what happens and what you expected to happen instead.
    "It doesn't work" is not specific. Nor is "it dies", nor "it gives me an error
    message". Give specifics of what "doesn't work" looks like. A browser page that
    displays X when you expected Y? An error message that states XYZ? A traceback?
    In this last case, do include the full traceback in the question, since that provides
    valuable debugging clues for people who might try to help.
  prefs: []
  type: TYPE_NORMAL
- en: Third, if you mention in the question that your expected behavior is based on
    what the documentation says, be specific about what documentation, exactly, you
    are referring to. Django has extensive documentation, including both guide and
    reference information. Someone reading your question and searching the documentation
    for what you are referencing may easily find a completely different section and
    have a hard time following what you are saying. If you provide a specific link
    to the documentation in question, then misunderstandings are less likely to occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common theme running through all these tips, as you''ve likely noticed, is:
    be specific. Yes it takes more work to provide specifics. But a specific question
    is far more likely to get helpful answers than an imprecise and vague question.
    If you leave out the specifics, once in a blue moon someone may post an answer
    that guides you towards a solution. It''s far more likely, though, that a vague
    question will get either no responses, responses asking for specifics, or responses
    that send you down an entirely wrong path because the responder completely misunderstood
    the question.'
  prefs: []
  type: TYPE_NORMAL
- en: Opening a new ticket to report a problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you run into a problem that appears to be an unreported and unfixed bug
    in Django code, the next step is to open a ticket for it. The process for this
    is pretty self-explanatory when you select the **New Ticket** tab after clicking
    on **Code** from the Django home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Opening a new ticket to report a problem](img/7566_10_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Please do read through the **Read this first** list. Much of the information
    in that list has been covered earlier in this chapter, but not all. In particular,
    the last item notes how to mark up submitted code snippets or tracebacks so that
    they will be formatted properly. The note includes the one type of mark up most
    frequently left out and also points to the full documentation on how text can
    be specially formatted. Note that you can check how the formatting will look by
    selecting the **Preview** button at the bottom—it's always a good idea to try
    previewing a submission before pressing **Submit**.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the Django Trac installation does allow anonymous ticket submissions
    and updates. However, it also uses the Akismet spam-filtering service, and this
    service does sometimes reject non-spam submissions. As noted in the big yellow
    box, the easiest way to avoid this is to **register for an account** (that text
    on the page is a link to a page where you can register).
  prefs: []
  type: TYPE_NORMAL
- en: The two most important bits to fill out when opening a new ticket are the short
    summary and full description. In the short summary, try to include key terms that
    will make the new ticket show up in likely searches by people encountering the
    same problem. In the full description, all the advice from the previous section
    about being specific applies again. If you are opening a ticket after the discussion
    on one of the mailing lists came to the conclusion that a ticket is a good idea,
    it's helpful to include a link to that discussion in the problem. However, it
    is also good to include the basic information about the problem in the ticket
    description itself as well.
  prefs: []
  type: TYPE_NORMAL
- en: In the information in **Ticket Properties**, you likely don't need to change
    anything from the default values, excepting **Version** (if you are using a version
    other than the one displayed) and **Has patch** (if you are going to attach a
    patch that fixes the problem). You can try to guess the correct **Component**
    from the list and include some appropriate **Keywords**, but it's not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, you can set the **Milestone** to the next release, though that won't
    really make it any more likely that someone will tackle the problem sooner rather
    than later. That field is typically only closely watched towards the very tail
    end of a release to note which bugs absolutely must be fixed before release.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you submit a ticket, if you used a login that included an e-mail address,
    or specified an e-mail address in the field labeled **Your email or username**,
    updates to the ticket will automatically be e-mailed to the e-mail address specified.
    So if someone adds a comment to the ticket, you will be notified. An annoying
    exception to this is the automatically-generated update resulting from a commit
    to the code base: this does not generate e-mail to the ticket reporter. So, you
    won''t necessarily get notified when the ticket is closed as fixed, but rather
    will have to check back on its status from the website manually.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve now come to the end of discussion of what to do when none of the other
    debugging techniques covered previously have succeeded in solving some problem.
    In this chapter, we:'
  prefs: []
  type: TYPE_NORMAL
- en: Encountered a bug that existed in Django 1.1 and caused some of the survey application
    code to not behave as desired
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Walked through the verification process of tracking down the problem to Django
    instead of the survey code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saw how searching in the Django code tracker revealed the problem was a bug
    that had been fixed in Django 1.1.1, which provided an easy solution to the problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussed options for how to proceed when problems are tracked down to bugs
    with fixes that are either not yet available or not available in official releases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Described the various community resources that exist for asking questions about
    behavior that seems puzzling, but doesn't seem to have been reported as a bug
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussed tips for writing questions so that they get the desired helpful responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Described the process of opening a new ticket to report a problem in Django
    code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the next chapter, we will advance to the final stage in developing a Django
    application: moving to production.'
  prefs: []
  type: TYPE_NORMAL
