- en: Chapter 8. Let's Collaborate – Adding New Workouts Using Firebase Data Storage
    and Vue.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to add some basic navigation to the
    Vue application using both `vue-router` and `Nuxt.js`. We have redesigned our
    ProFitOro application, transforming it into a Nuxt-based application. Now our
    application is functional, it has an authentication mechanism, and it is navigable.
    However, it still lacks one of the most important features – workouts. In this
    chapter, we are going to implement the workout management page. Do you still remember
    its requirements from [Chapter 2](part0024_split_000.html#MSDG2-449ee41b57ea4c048225480b41c8dbe3
    "Chapter 2. Under the Hood – Tutorial Explained"), *Under the Hood – Tutorial
    Explained*?
  prefs: []
  type: TYPE_NORMAL
- en: 'This page should allow users to see the existing workouts in the database,
    select or deselect them to be shown up during the Pomodoro breaks, rate them,
    and even add new workouts. We are not going to implement all these features. However,
    we are going to implement enough for you to continue this application and finish
    its implementation with great success! So, in this chapter we are going to do
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a responsive layout for the workout management page, which will consist
    of two essential parts – a searchable list of all the workouts as well as the
    possibility of adding a new workout to the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store new workouts using the Firebase database and data storage mechanism to
    store workout images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a Bootstrap modal to display every individual workout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make our footer nicer using responsive layout and the fixed-bottom class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating layouts using Bootstrap classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start implementing a layout for our workouts page, let me remind
    you what the mockup looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating layouts using Bootstrap classes](../images/00124.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is how we have defined things initially in our mockups
  prefs: []
  type: TYPE_NORMAL
- en: We will do some things slightly differently - something similar to what we have
    done in the settings page. Let's create the two-column layout that will stack
    on mobile devices. So, this mockup will be valid for mobile screens but it will
    display two columns on desktop devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add two components – `WorkoutsComponent.vue` and `NewWorkoutComponent.vue`
    – inside the `components/workouts` folder. Add some dummy text to the templates
    of these new components and let''s define our two-column layout in the `workouts.vue`
    page. You certainly remember that in order to have stack columns on small devices
    and different-sized columns on other devices, we have to use the `col-*-<number>`
    notation, where `*` represents the size of the device (`sm` for small, `md` for
    medium, `lg` for large, and so on) and the number represents the size of the column,
    which might ranges from `1` to `12`. Since we want our layout to stack on small
    devices (this means that the size of the column should be `12`) and be two equal-sized
    columns on medium and large devices, I came up with the following layout definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t forget to import both the `WorkoutsComponent.vue` and `NewWorkoutComponent.vue`
    components to the `workouts.vue` page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have a two-column responsive layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating layouts using Bootstrap classes](../images/00125.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Two-column responsive layout for the workout management page
  prefs: []
  type: TYPE_NORMAL
- en: Check the code for this implementation in the `chapter8/1/profitoro` folder.
    In particular, pay attention to the content of `components/workouts` folder and
    to the `workouts.vue` page.
  prefs: []
  type: TYPE_NORMAL
- en: Making the footer nice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aren't you tired of this hardcoded word "**Footer**" always lying around beneath
    our content?
  prefs: []
  type: TYPE_NORMAL
- en: '![Making the footer nice](../images/00126.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The ugly flying hardcoded Footer always glued to our content
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do something with it! If you check our mockups, we have three columns
    there:'
  prefs: []
  type: TYPE_NORMAL
- en: One column for the copyright information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another one for the fact of the day
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And the last for the author information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You already know what to do, right? Again, we want these columns to be equally
    distributed on mediumand large-sized devices, and stack on mobile devices. Thus,
    our code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s keep the fact of the day section hardcoded for now. Well, now our footer
    looks a bit nicer. At least it''s not just the word "Footer" lying around:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making the footer nice](../images/00127.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Our footer is not just the word Footer anymore but it's still glued to the main
    content
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it''s still stuck to the main content, which is not really nice. It
    would be great if our footer was fixed to the viewport''s bottom. It''s a common
    problem, and you will find a lot of articles on the internet asking for this question
    and providing solutions: [https://stackoverflow.com/questions/18915550/fix-footer-to-bottom-of-page](https://stackoverflow.com/questions/18915550/fix-footer-to-bottom-of-page).
    Fortunately for us, we are using Bootstrap and it comes with a series of utility
    classes for sticky top, fixed bottom, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to make your footer fixed with Bootstrap, just add this class to it:
    `fixed-bottom`'
  prefs: []
  type: TYPE_NORMAL
- en: Once you add this class to your footer, you will see how it becomes stuck to
    the bottom of the viewport. Try to resize the viewport, moving the bottom of the
    page up and down, and you will see that our footer goes along the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: Check the code for this section in the `chapter8/2/profitoro` folder. The only
    change was in the `HeaderComponent.vue` component, which is located in the `components/common`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Storing new workouts using the Firebase real-time database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before starting this section, check the code in the `chapter8/3/profitoro` folder.
    Both the `Workouts` and `NewWorkout` components are filled with a markup.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't forget to run `npm install` and `npm run dev`!
  prefs: []
  type: TYPE_NORMAL
- en: 'It doesn''t work yet, but it displays something:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Storing new workouts using the Firebase real-time database](../images/00128.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Workout management page with some content
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to add workout objects to our workouts resource
    in the Firebase database. After that, we can finally learn how to store images
    using the Firebase data storage mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s add Firebase bindings just like we''ve done for statistics and
    configuration objects. Open the `action.js` file and find the `bindFirebaseReferences`
    method. Here, we should add the binding for the `workouts` resource. So, this
    method now contains three bindings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We should also unbind them once the application is unloaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also add `workoutsRef` and `workouts` attributes to our state. Last
    but not least, don''t forget to implement the mutation called `setWorkoutsRef`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, having the `workoutsRef` stored in our state, we can implement the action
    that will update it with newly created workouts. After this, we will be able to
    use this action inside the `NewWorkout` component and populate our workout database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the Firebase documentation regarding reading and writing into the real-time
    database: [https://firebase.google.com/docs/database/web/read-and-write](https://firebase.google.com/docs/database/web/read-and-write).
    Scroll down until you find the "*new post creation*" example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Storing new workouts using the Firebase real-time database](../images/00129.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: New post creation example in Firebase database documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t you find this case extremely similar to ours? Each workout added by
    the user has its name, description, and a picture (or maybe even more than one
    picture). Workouts also belong to the users that created them. So, maybe we can
    do something very similar to this. It will also be useful to have a resource for
    `user-workouts` that contains workouts for each user. It might come in handy if
    we decide to implement the possibility for each user to delete their workouts.
    Before copying this code, let''s just agree on the workout object data structure.
    What should it contain? Since it''s coming from the `NewWorkout` component, it
    will already bring the workout''s name, description, and image URLs. Should we
    enrich it with anything else inside the action? Probably, we should add the name
    and UID of the user who added it, the date when it was created, and the rating
    attribute. This should be more than enough for now. So, our workout data structure
    will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `name`, `description`, `username`, and `uid` attributes are strings. The
    `pictures` attribute should be an array of URL strings, `rating` should be a number
    and let's store our `date` attribute in the form of a timestamp.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's good that we are implementing both the frontend and the backend parts,
    so we agree on a data schema between ourselves. If you ever work in a team that
    has frontend and backend developers, don't forget to agree on a data schema before
    any implementation takes place!
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we know that the description, name, and picture URL should be populated
    inside the `NewWorkout` component. Thus, let''s populate everything else inside
    our `action` method. In the end, it will look really similar to the Firebase example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note again that we are introducing a new resource called `user-workouts`. We
    can bind this resource to our state the exact same way we have done with the statistics
    and configuration user data. If we decide to implement the deletion of user resources,
    it might become handy.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move to our `NewWorkout` component. Here, we just need to bind some
    Vue models to the corresponding inputs and the click event to the **Submit** button.
    The click event on the **Apply** button should be bound to the `createNewWorkout`
    action, invoking it along with the corresponding data. Don't worry about the `pictures`
    yet, we will deal with them in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we can replace the hardcoded array of workouts in the `Workouts`
    component with the state workouts object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Check how your newly created workouts immediately appear in the workouts section!
  prefs: []
  type: TYPE_NORMAL
- en: Check the final code for this section in the `chapter8/4/profitoro` folder.
    Pay attention to the store files (`actions.js`, `mutations.js`) and to the `NewWorkoutComponent`
    and `WorkoutsComponent` components inside the `components/workouts` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Storing images using the Firebase data storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Firebase cloud storage allows you to upload and retrieve different content (files,
    videos, images, and so on). In a very similar way, Firebase provides a way of
    accessing and managing your database, where you can access and manage your storage
    buckets. You can upload Blobs, strings in Base64, file objects, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, you should tell your Firebase application that you are going
    to use Google cloud storage. Thus, you need to add a `storageBucket` attribute
    to your application configuration object. Check your application''s settings on
    the Google Firebase console and copy the `storageBucket` reference to the `firebase/index.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now your firebase application knows what storage bucket to use. Let''s also
    open the data storage tab of the Firebase console and add a folder for our workout
    images. Let''s call it…workouts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Storing images using the Firebase data storage](../images/00130.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a folder called "workouts" in the Firebase data storage tab
  prefs: []
  type: TYPE_NORMAL
- en: Everything is now ready to start using our cloud storage bucket.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we have to obtain the reference to our workouts folder so we
    can modify it. Check the Firebase API documentation regarding bucket reference
    creation: [https://firebase.google.com/docs/storage/web/create-reference](https://firebase.google.com/docs/storage/web/create-reference).
    In our case, the reference will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Where should we use it? Somehow, before storing workouts, we should store the
    picture files, obtain their cloud URLs, and assign these URLs to the workouts''
    `pictures` property. So, here is our plan:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a method that uploads files and returns those files' download URLs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use this method before dispatching the `createNewWorkout` action to assign the
    URLs to the picture's property of the workout object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create a method that will upload a file and return its `downloadURL`.
    Check the Firebase documentation to learn how to use its API to upload files:
    [https://firebase.google.com/docs/storage/web/upload-files](https://firebase.google.com/docs/storage/web/upload-files).
    Have a look at the **Upload from a Blob or File** section. You will see that we
    should use the method "`put`" on a cloud storage reference, providing it with
    a file object. This will be a promise that is resolved with a snapshot object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'What is this `snapshot` object? This is a representation of your file stored
    on the cloud. It contains a lot of information, but the most important for us
    is its `downloadURL` attribute. So, our promise will look quite similar to the
    example promise but it will return `snapshot.downloadURL`. So, open the `actions.js`
    file and create a new method called `uploadImage`. This method will receive a
    file object, create a child reference on our `workout` cloud folder reference
    with this file''s name, and then `put` a file and resolve with the `downloadURL`.
    So, it will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Don't you see a little problem here? What will happen if two different users
    submit different pictures under the same name? Then these pictures will just override
    each other. As a small exercise, think of a way to avoid this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Hint: Have a look at this npm package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.npmjs.com/package/uuid](https://www.npmjs.com/package/uuid)'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we have our promise that uploads the file and returns its `downloadURL`.
    However, this is not yet our final action. Our final `action` method should upload
    an *array* of files, because that is what we get from our multiple file input
    – an array of file objects. Thus, our final promise will just return the result
    of all the promises and it will look as simple as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This action can now be used inside the `NewWorkout` component before calling
    the `createNewWorkout` action.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need to bind the `pictures` property to the file input element.
    The obvious choice would be to bind the property `pictures` to the input using
    the `v-model` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Is it so obvious though? The `v-model` directive determines the *two-way data
    binding*, but how would we set data to it? The data of the file input is either
    `FileObject` or `FileList`. How would we set it? It seems that applying two-way
    data binding to this element doesn't make sense.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can''t actually bind reactive data to the file inputs, but you can set
    your data inside the change event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://forum.vuejs.org/t/vuejs2-file-input/633/2](https://forum.vuejs.org/t/vuejs2-file-input/633/2)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, we have to listen to the `change` event and set our data on each change.
    Let''s bind this event to the `filesChange` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now let's create this method and just assign `this.pictures` to the parameter
    we receive. Well, not *just assign*, because we receive a `FileList` object which
    is not exactly an array which you can iterate over. Thus, we need to transform
    it into a simple array of `File` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can use the ES6 spread operator for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`filesArray = [...fileListObject]`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, our `filesChange` method will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can finally update our `onCreateNew` method. First, it should dispatch
    the `uploadImages` action and on promise resolution dispatch the `createNewWorkout`
    action, assigning the result of the promise to the `pictures` array. Now this
    method will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to import the `uploadImages` action. Also, create a `reset` method
    that will reset all the data to its initial state.
  prefs: []
  type: TYPE_NORMAL
- en: Create some workouts with images and enjoy the result!
  prefs: []
  type: TYPE_NORMAL
- en: Let's search!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So now we can create workouts and see them being displayed in the list of workouts.
    However, we have this nice search input, and it''s doing nothing: (. Nevertheless,
    we are using Vue.js so it''s really easy to implement this search. We just have
    to create a `searchTerm` data attribute and bind it to the search input and then
    filter the workouts array by this `searchTerm`. So, I will add the computed property,
    let''s call it `workoutsToDisplay`, and this property will represent a filtered
    workouts property (the one that we import from the Vuex store''s state) by its
    name, description, and username properties. So, it will give us the possibility
    of searching by all these terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t forget to add the `searchTerm` property to the component''s data and
    bind it to the search input element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And, of course, instead of iterating over the workouts array to display the
    workout cards, we should now iterate over the `workoutsToDisplay` array. So just
    edit slightly the `v-for` directive of the card `div`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the page and try to search! If I search by the user''s name, only workouts
    created by this user will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Let''s search!](../images/00131.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Makes sense, since I created all the existing workouts until now
  prefs: []
  type: TYPE_NORMAL
- en: 'If I search by the name of the workout, let''s say, push-up, only this workout
    will appear in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Let''s search!](../images/00132.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Searching by the workout's name
  prefs: []
  type: TYPE_NORMAL
- en: We're almost done! The only thing we have to do now is to show a randomly chosen
    workout from the list of workouts instead of hardcoded data during the resting
    periods of our Pomodoro. Try to do it yourself in the `pomodoro.vue` page.
  prefs: []
  type: TYPE_NORMAL
- en: You can now create new workouts and they will immediately appear in the workouts
    section. They also appear in our main page during the Pomodoro breaks.
  prefs: []
  type: TYPE_NORMAL
- en: Great job! Check the code for this part in the `chapter8/5/profitoro` folder.
    Pay special attention to the new actions inside the `store/actions.js` file and
    to the `Workouts` and `NewWorkout` components inside the `components/workouts`
    folder. Check how the random workout is being selected and displayed in the `pomodoro.vue`
    page.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Bootstrap modal to show each workout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we can see all the existing workouts on the page, which is great. However,
    our users would really like to have a look at each of the workouts in detail –
    see the workouts'' descriptions, rate them, see who has created them and when,
    and so on. It''s unthinkable to put all this information in the tiny `card` element,
    so we need to have a way of magnifying each element in order to be able to see
    its detailed information. A Bootstrap modal is a great tool that provides this
    functionality. Check the Bootstrap documentation regarding the modal API: [https://v4-alpha.getbootstrap.com/components/modal/](https://v4-alpha.getbootstrap.com/components/modal/).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that Bootstrap 4, at the time of writing, is in its alpha stage and that's
    why at some point this link might not work anymore, so just search for the relevant
    information on the official Bootstrap website.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, we need to have an element that will trigger a modal and a modal
    markup itself. In our case, each of the small workout cards should be used as
    a modal trigger; `WorkoutComponent` will be our modal component. So, just add
    `data-toggle` and `data-target` attributes to the `card` element inside the Workouts
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s work on the `WorkoutComponent` component. Let''s assume that it
    will receive the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: description
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: username
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: datecreated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: rate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pictures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thus, we can build a very simple markup for our modal, something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that this modal needs to have the exact same ID attribute by which
    it is being targeted from the toggling element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t forget to specify the required properties under the `props` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now this component can be imported into the Workouts component and used there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If you click on some of the small cards now, the empty modal will open:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using a Bootstrap modal to show each workout](../images/00133.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The modal works! But it's empty
  prefs: []
  type: TYPE_NORMAL
- en: 'We definitely should still do something, so the data of the chosen element
    is propagated to the component''s data. Let''s add a method that will do this
    job and bind it to the `click` event of the `card` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The method will just copy the workout''s data to the corresponding component''s
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: It looks a little bit better now!
  prefs: []
  type: TYPE_NORMAL
- en: '![Using a Bootstrap modal to show each workout](../images/00134.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Data binding just works!
  prefs: []
  type: TYPE_NORMAL
- en: It looks nice, all the data is here, but it's still not perfect. Think how we
    could improve it.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Make the date that appears on the modal''s footer human-readable. Do it in
    such a way that the footer appears like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercise](../images/00135.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Workout modal's footer with human-readable data
  prefs: []
  type: TYPE_NORMAL
- en: Try to use existing tools and not reinvent the wheel.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Think of the moment.js library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://momentjs.com/](https://momentjs.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: Check for yourself and the final code until this moment in the `chapter8/6/profitoro`
    folder. Pay attention to the `Workouts` and `Workout` components in the `components/workout`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: It's time to apply some style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application is fully functional now; it can be used right away. Of course,
    it is still not perfect. It lacks validations and some functionality, several
    requirements have not been implemented yet, and the most important thing…it lacks
    beauty! It's all gray, it doesn't have style…we are humans, we love beautiful
    things, don't we? Everyone implements styles in their own way. I strongly recommend
    that if you want to use this application, please find your own style and theme
    for it, and please implement it and share with me. I would love to see it.
  prefs: []
  type: TYPE_NORMAL
- en: As for me, since I am not a designer, I asked my good friend Vanessa ([https://www.behance.net/MeegsyWeegsy](https://www.behance.net/MeegsyWeegsy))
    to create a nice design for the ProFitOro application. She did a great job! Since
    I was busy writing this book, I had no time to implement Vanessa's design, therefore
    I asked my good friend, Filipe ([https://github.com/fil090302](https://github.com/fil090302)),
    to help me with it. Filipe did a great job as well! Everything looks exactly how
    Vanessa implemented it. We have used `scss`, so it must be familiar to you since
    we've been using it already in this application as a preprocessor.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can reuse the existing style to override some variables in order to create
    your own theme. Please check the final code in the `chapter8/7/profitoro` folder.
    All styles are located inside the `assets/styles` directory. It has the following
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![It''s time to apply some style](../images/00136.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Directory structure
  prefs: []
  type: TYPE_NORMAL
- en: As for the final look, here is what it looks like.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the main page with the Pomodoro timer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![It''s time to apply some style](../images/00137.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Main page that contains the Pomodoro timer
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what the Settings page looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![It''s time to apply some style](../images/00138.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Look and feel of the Settings page
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally, here is what the Workouts page looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![It''s time to apply some style](../images/00139.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Look and feel of the Workouts page
  prefs: []
  type: TYPE_NORMAL
- en: 'You will still have to implement the Statistics page – right now, it just shows
    the total amount of completed Pomodoros:'
  prefs: []
  type: TYPE_NORMAL
- en: '![It''s time to apply some style](../images/00140.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Statistics page is not fully complete, only showing the total amount of completed
    Pomodoros
  prefs: []
  type: TYPE_NORMAL
- en: There's still some work to do, but don't you agree that we have done great work
    so far? Not only do we have a fully functioning configurable Pomodoro timer, we
    can also already use it to do small workouts during our working day. How great
    is that?
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have finally implemented the workout management page. Now
    we can see all the workouts stored in the database and create our own workouts.
    We have learned how to use the Google Firebase data storage system and API to
    store static files and we were able to store newly created workouts in the Firebase
    real-time database. We have also learned how to use a Bootstrap modal and used
    it to display each workout in a nice modal popup.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will do the most important job of every software implementation
    process – we will test what we have done so far. We will use Jest ([https://facebook.github.io/jest/](https://facebook.github.io/jest/))
    to test our application. After that, we will finally deploy our application and
    define future work. Are you ready for testing your work? Then turn the page!
  prefs: []
  type: TYPE_NORMAL
