- en: Chapter 8. Let's Collaborate – Adding New Workouts Using Firebase Data Storage
    and Vue.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。让我们合作 - 使用Firebase数据存储和Vue.js添加新的锻炼
- en: In the previous chapter, we learned how to add some basic navigation to the
    Vue application using both `vue-router` and `Nuxt.js`. We have redesigned our
    ProFitOro application, transforming it into a Nuxt-based application. Now our
    application is functional, it has an authentication mechanism, and it is navigable.
    However, it still lacks one of the most important features – workouts. In this
    chapter, we are going to implement the workout management page. Do you still remember
    its requirements from [Chapter 2](part0024_split_000.html#MSDG2-449ee41b57ea4c048225480b41c8dbe3
    "Chapter 2. Under the Hood – Tutorial Explained"), *Under the Hood – Tutorial
    Explained*?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用`vue-router`和`Nuxt.js`为Vue应用程序添加一些基本导航。我们已经重新设计了我们的ProFitOro应用程序，将其转变为基于Nuxt的应用程序。现在我们的应用程序是功能性的，它具有身份验证机制，并且可以导航。但是，它仍然缺少最重要的功能之一
    - 锻炼。在本章中，我们将实现锻炼管理页面。你还记得它在[第2章](part0024_split_000.html#MSDG2-449ee41b57ea4c048225480b41c8dbe3
    "第2章。底层 - 教程解释") *底层 - 教程解释*中的要求吗？
- en: 'This page should allow users to see the existing workouts in the database,
    select or deselect them to be shown up during the Pomodoro breaks, rate them,
    and even add new workouts. We are not going to implement all these features. However,
    we are going to implement enough for you to continue this application and finish
    its implementation with great success! So, in this chapter we are going to do
    the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面应该允许用户查看数据库中现有的锻炼，选择或取消选择它们在番茄钟休息期间显示，对它们进行评分，甚至添加新的锻炼。我们不打算实现所有这些功能。但是，我们将实现足够的功能让你能够继续这个应用程序，并且以巨大的成功完成它的实现！因此，在本章中，我们将做以下工作：
- en: Define a responsive layout for the workout management page, which will consist
    of two essential parts – a searchable list of all the workouts as well as the
    possibility of adding a new workout to the list
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为锻炼管理页面定义一个响应式布局，它将包括两个基本部分 - 所有锻炼的可搜索列表以及向列表中添加新锻炼的可能性
- en: Store new workouts using the Firebase database and data storage mechanism to
    store workout images
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Firebase数据库和数据存储机制存储新的锻炼以及锻炼图片
- en: Use a Bootstrap modal to display every individual workout
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Bootstrap模态框显示每个单独的锻炼
- en: Make our footer nicer using responsive layout and the fixed-bottom class
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用响应式布局和fixed-bottom类使我们的页脚更好看
- en: Creating layouts using Bootstrap classes
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Bootstrap类创建布局
- en: 'Before we start implementing a layout for our workouts page, let me remind
    you what the mockup looks like:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始为锻炼页面实现布局之前，让我提醒你模拟看起来是什么样子的：
- en: '![Creating layouts using Bootstrap classes](../images/00124.jpeg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![使用Bootstrap类创建布局](../images/00124.jpeg)'
- en: This is how we have defined things initially in our mockups
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们最初在模拟中定义的东西
- en: We will do some things slightly differently - something similar to what we have
    done in the settings page. Let's create the two-column layout that will stack
    on mobile devices. So, this mockup will be valid for mobile screens but it will
    display two columns on desktop devices.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将做一些略有不同的事情 - 类似于我们在设置页面所做的事情。让我们创建一个在移动设备上堆叠的两列布局。因此，这个模拟将适用于移动屏幕，但在桌面设备上会显示两列。
- en: 'Let''s add two components – `WorkoutsComponent.vue` and `NewWorkoutComponent.vue`
    – inside the `components/workouts` folder. Add some dummy text to the templates
    of these new components and let''s define our two-column layout in the `workouts.vue`
    page. You certainly remember that in order to have stack columns on small devices
    and different-sized columns on other devices, we have to use the `col-*-<number>`
    notation, where `*` represents the size of the device (`sm` for small, `md` for
    medium, `lg` for large, and so on) and the number represents the size of the column,
    which might ranges from `1` to `12`. Since we want our layout to stack on small
    devices (this means that the size of the column should be `12`) and be two equal-sized
    columns on medium and large devices, I came up with the following layout definition:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Don''t forget to import both the `WorkoutsComponent.vue` and `NewWorkoutComponent.vue`
    components to the `workouts.vue` page:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now we have a two-column responsive layout:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating layouts using Bootstrap classes](../images/00125.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
- en: Two-column responsive layout for the workout management page
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Check the code for this implementation in the `chapter8/1/profitoro` folder.
    In particular, pay attention to the content of `components/workouts` folder and
    to the `workouts.vue` page.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Making the footer nice
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aren't you tired of this hardcoded word "**Footer**" always lying around beneath
    our content?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![Making the footer nice](../images/00126.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: The ugly flying hardcoded Footer always glued to our content
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do something with it! If you check our mockups, we have three columns
    there:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: One column for the copyright information
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another one for the fact of the day
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And the last for the author information
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You already know what to do, right? Again, we want these columns to be equally
    distributed on mediumand large-sized devices, and stack on mobile devices. Thus,
    our code will look like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s keep the fact of the day section hardcoded for now. Well, now our footer
    looks a bit nicer. At least it''s not just the word "Footer" lying around:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![Making the footer nice](../images/00127.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: Our footer is not just the word Footer anymore but it's still glued to the main
    content
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it''s still stuck to the main content, which is not really nice. It
    would be great if our footer was fixed to the viewport''s bottom. It''s a common
    problem, and you will find a lot of articles on the internet asking for this question
    and providing solutions: [https://stackoverflow.com/questions/18915550/fix-footer-to-bottom-of-page](https://stackoverflow.com/questions/18915550/fix-footer-to-bottom-of-page).
    Fortunately for us, we are using Bootstrap and it comes with a series of utility
    classes for sticky top, fixed bottom, and so on.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to make your footer fixed with Bootstrap, just add this class to it:
    `fixed-bottom`'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Once you add this class to your footer, you will see how it becomes stuck to
    the bottom of the viewport. Try to resize the viewport, moving the bottom of the
    page up and down, and you will see that our footer goes along the bottom.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Check the code for this section in the `chapter8/2/profitoro` folder. The only
    change was in the `HeaderComponent.vue` component, which is located in the `components/common`
    folder.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Storing new workouts using the Firebase real-time database
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before starting this section, check the code in the `chapter8/3/profitoro` folder.
    Both the `Workouts` and `NewWorkout` components are filled with a markup.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't forget to run `npm install` and `npm run dev`!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'It doesn''t work yet, but it displays something:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '![Storing new workouts using the Firebase real-time database](../images/00128.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
- en: Workout management page with some content
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to add workout objects to our workouts resource
    in the Firebase database. After that, we can finally learn how to store images
    using the Firebase data storage mechanism.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s add Firebase bindings just like we''ve done for statistics and
    configuration objects. Open the `action.js` file and find the `bindFirebaseReferences`
    method. Here, we should add the binding for the `workouts` resource. So, this
    method now contains three bindings:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We should also unbind them once the application is unloaded:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s also add `workoutsRef` and `workouts` attributes to our state. Last
    but not least, don''t forget to implement the mutation called `setWorkoutsRef`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, having the `workoutsRef` stored in our state, we can implement the action
    that will update it with newly created workouts. After this, we will be able to
    use this action inside the `NewWorkout` component and populate our workout database.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the Firebase documentation regarding reading and writing into the real-time
    database: [https://firebase.google.com/docs/database/web/read-and-write](https://firebase.google.com/docs/database/web/read-and-write).
    Scroll down until you find the "*new post creation*" example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '![Storing new workouts using the Firebase real-time database](../images/00129.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
- en: New post creation example in Firebase database documentation
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t you find this case extremely similar to ours? Each workout added by
    the user has its name, description, and a picture (or maybe even more than one
    picture). Workouts also belong to the users that created them. So, maybe we can
    do something very similar to this. It will also be useful to have a resource for
    `user-workouts` that contains workouts for each user. It might come in handy if
    we decide to implement the possibility for each user to delete their workouts.
    Before copying this code, let''s just agree on the workout object data structure.
    What should it contain? Since it''s coming from the `NewWorkout` component, it
    will already bring the workout''s name, description, and image URLs. Should we
    enrich it with anything else inside the action? Probably, we should add the name
    and UID of the user who added it, the date when it was created, and the rating
    attribute. This should be more than enough for now. So, our workout data structure
    will look like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `name`, `description`, `username`, and `uid` attributes are strings. The
    `pictures` attribute should be an array of URL strings, `rating` should be a number
    and let's store our `date` attribute in the form of a timestamp.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's good that we are implementing both the frontend and the backend parts,
    so we agree on a data schema between ourselves. If you ever work in a team that
    has frontend and backend developers, don't forget to agree on a data schema before
    any implementation takes place!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we know that the description, name, and picture URL should be populated
    inside the `NewWorkout` component. Thus, let''s populate everything else inside
    our `action` method. In the end, it will look really similar to the Firebase example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note again that we are introducing a new resource called `user-workouts`. We
    can bind this resource to our state the exact same way we have done with the statistics
    and configuration user data. If we decide to implement the deletion of user resources,
    it might become handy.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move to our `NewWorkout` component. Here, we just need to bind some
    Vue models to the corresponding inputs and the click event to the **Submit** button.
    The click event on the **Apply** button should be bound to the `createNewWorkout`
    action, invoking it along with the corresponding data. Don't worry about the `pictures`
    yet, we will deal with them in the next section.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we can replace the hardcoded array of workouts in the `Workouts`
    component with the state workouts object:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Check how your newly created workouts immediately appear in the workouts section!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Check the final code for this section in the `chapter8/4/profitoro` folder.
    Pay attention to the store files (`actions.js`, `mutations.js`) and to the `NewWorkoutComponent`
    and `WorkoutsComponent` components inside the `components/workouts` folder.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Storing images using the Firebase data storage
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Firebase cloud storage allows you to upload and retrieve different content (files,
    videos, images, and so on). In a very similar way, Firebase provides a way of
    accessing and managing your database, where you can access and manage your storage
    buckets. You can upload Blobs, strings in Base64, file objects, and so on.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, you should tell your Firebase application that you are going
    to use Google cloud storage. Thus, you need to add a `storageBucket` attribute
    to your application configuration object. Check your application''s settings on
    the Google Firebase console and copy the `storageBucket` reference to the `firebase/index.js`
    file:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now your firebase application knows what storage bucket to use. Let''s also
    open the data storage tab of the Firebase console and add a folder for our workout
    images. Let''s call it…workouts:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '![Storing images using the Firebase data storage](../images/00130.jpeg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
- en: Creating a folder called "workouts" in the Firebase data storage tab
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Everything is now ready to start using our cloud storage bucket.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we have to obtain the reference to our workouts folder so we
    can modify it. Check the Firebase API documentation regarding bucket reference
    creation: [https://firebase.google.com/docs/storage/web/create-reference](https://firebase.google.com/docs/storage/web/create-reference).
    In our case, the reference will look like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Where should we use it? Somehow, before storing workouts, we should store the
    picture files, obtain their cloud URLs, and assign these URLs to the workouts''
    `pictures` property. So, here is our plan:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Create a method that uploads files and returns those files' download URLs
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use this method before dispatching the `createNewWorkout` action to assign the
    URLs to the picture's property of the workout object
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create a method that will upload a file and return its `downloadURL`.
    Check the Firebase documentation to learn how to use its API to upload files:
    [https://firebase.google.com/docs/storage/web/upload-files](https://firebase.google.com/docs/storage/web/upload-files).
    Have a look at the **Upload from a Blob or File** section. You will see that we
    should use the method "`put`" on a cloud storage reference, providing it with
    a file object. This will be a promise that is resolved with a snapshot object:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'What is this `snapshot` object? This is a representation of your file stored
    on the cloud. It contains a lot of information, but the most important for us
    is its `downloadURL` attribute. So, our promise will look quite similar to the
    example promise but it will return `snapshot.downloadURL`. So, open the `actions.js`
    file and create a new method called `uploadImage`. This method will receive a
    file object, create a child reference on our `workout` cloud folder reference
    with this file''s name, and then `put` a file and resolve with the `downloadURL`.
    So, it will look like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Don't you see a little problem here? What will happen if two different users
    submit different pictures under the same name? Then these pictures will just override
    each other. As a small exercise, think of a way to avoid this problem.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Hint: Have a look at this npm package:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.npmjs.com/package/uuid](https://www.npmjs.com/package/uuid)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we have our promise that uploads the file and returns its `downloadURL`.
    However, this is not yet our final action. Our final `action` method should upload
    an *array* of files, because that is what we get from our multiple file input
    – an array of file objects. Thus, our final promise will just return the result
    of all the promises and it will look as simple as the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This action can now be used inside the `NewWorkout` component before calling
    the `createNewWorkout` action.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need to bind the `pictures` property to the file input element.
    The obvious choice would be to bind the property `pictures` to the input using
    the `v-model` directive:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Is it so obvious though? The `v-model` directive determines the *two-way data
    binding*, but how would we set data to it? The data of the file input is either
    `FileObject` or `FileList`. How would we set it? It seems that applying two-way
    data binding to this element doesn't make sense.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can''t actually bind reactive data to the file inputs, but you can set
    your data inside the change event:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[https://forum.vuejs.org/t/vuejs2-file-input/633/2](https://forum.vuejs.org/t/vuejs2-file-input/633/2)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, we have to listen to the `change` event and set our data on each change.
    Let''s bind this event to the `filesChange` method:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now let's create this method and just assign `this.pictures` to the parameter
    we receive. Well, not *just assign*, because we receive a `FileList` object which
    is not exactly an array which you can iterate over. Thus, we need to transform
    it into a simple array of `File` objects.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can use the ES6 spread operator for this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '`filesArray = [...fileListObject]`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, our `filesChange` method will look as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we can finally update our `onCreateNew` method. First, it should dispatch
    the `uploadImages` action and on promise resolution dispatch the `createNewWorkout`
    action, assigning the result of the promise to the `pictures` array. Now this
    method will look as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Don't forget to import the `uploadImages` action. Also, create a `reset` method
    that will reset all the data to its initial state.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Create some workouts with images and enjoy the result!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Let's search!
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So now we can create workouts and see them being displayed in the list of workouts.
    However, we have this nice search input, and it''s doing nothing: (. Nevertheless,
    we are using Vue.js so it''s really easy to implement this search. We just have
    to create a `searchTerm` data attribute and bind it to the search input and then
    filter the workouts array by this `searchTerm`. So, I will add the computed property,
    let''s call it `workoutsToDisplay`, and this property will represent a filtered
    workouts property (the one that we import from the Vuex store''s state) by its
    name, description, and username properties. So, it will give us the possibility
    of searching by all these terms:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Don''t forget to add the `searchTerm` property to the component''s data and
    bind it to the search input element:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And, of course, instead of iterating over the workouts array to display the
    workout cards, we should now iterate over the `workoutsToDisplay` array. So just
    edit slightly the `v-for` directive of the card `div`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Open the page and try to search! If I search by the user''s name, only workouts
    created by this user will be displayed:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '![Let''s search!](../images/00131.jpeg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
- en: Makes sense, since I created all the existing workouts until now
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'If I search by the name of the workout, let''s say, push-up, only this workout
    will appear in the list:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![Let''s search!](../images/00132.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: Searching by the workout's name
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: We're almost done! The only thing we have to do now is to show a randomly chosen
    workout from the list of workouts instead of hardcoded data during the resting
    periods of our Pomodoro. Try to do it yourself in the `pomodoro.vue` page.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: You can now create new workouts and they will immediately appear in the workouts
    section. They also appear in our main page during the Pomodoro breaks.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Great job! Check the code for this part in the `chapter8/5/profitoro` folder.
    Pay special attention to the new actions inside the `store/actions.js` file and
    to the `Workouts` and `NewWorkout` components inside the `components/workouts`
    folder. Check how the random workout is being selected and displayed in the `pomodoro.vue`
    page.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Using a Bootstrap modal to show each workout
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we can see all the existing workouts on the page, which is great. However,
    our users would really like to have a look at each of the workouts in detail –
    see the workouts'' descriptions, rate them, see who has created them and when,
    and so on. It''s unthinkable to put all this information in the tiny `card` element,
    so we need to have a way of magnifying each element in order to be able to see
    its detailed information. A Bootstrap modal is a great tool that provides this
    functionality. Check the Bootstrap documentation regarding the modal API: [https://v4-alpha.getbootstrap.com/components/modal/](https://v4-alpha.getbootstrap.com/components/modal/).'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that Bootstrap 4, at the time of writing, is in its alpha stage and that's
    why at some point this link might not work anymore, so just search for the relevant
    information on the official Bootstrap website.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, we need to have an element that will trigger a modal and a modal
    markup itself. In our case, each of the small workout cards should be used as
    a modal trigger; `WorkoutComponent` will be our modal component. So, just add
    `data-toggle` and `data-target` attributes to the `card` element inside the Workouts
    component:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now let''s work on the `WorkoutComponent` component. Let''s assume that it
    will receive the following properties:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: name
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: description
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: username
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: datecreated
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: rate
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pictures
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thus, we can build a very simple markup for our modal, something like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Keep in mind that this modal needs to have the exact same ID attribute by which
    it is being targeted from the toggling element.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t forget to specify the required properties under the `props` attribute:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now this component can be imported into the Workouts component and used there:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you click on some of the small cards now, the empty modal will open:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '![Using a Bootstrap modal to show each workout](../images/00133.jpeg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: The modal works! But it's empty
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'We definitely should still do something, so the data of the chosen element
    is propagated to the component''s data. Let''s add a method that will do this
    job and bind it to the `click` event of the `card` element:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The method will just copy the workout''s data to the corresponding component''s
    data:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It looks a little bit better now!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '![Using a Bootstrap modal to show each workout](../images/00134.jpeg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
- en: Data binding just works!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: It looks nice, all the data is here, but it's still not perfect. Think how we
    could improve it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Make the date that appears on the modal''s footer human-readable. Do it in
    such a way that the footer appears like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercise](../images/00135.jpeg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: Workout modal's footer with human-readable data
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Try to use existing tools and not reinvent the wheel.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Think of the moment.js library:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[https://momentjs.com/](https://momentjs.com/)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Check for yourself and the final code until this moment in the `chapter8/6/profitoro`
    folder. Pay attention to the `Workouts` and `Workout` components in the `components/workout`
    folder.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: It's time to apply some style
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application is fully functional now; it can be used right away. Of course,
    it is still not perfect. It lacks validations and some functionality, several
    requirements have not been implemented yet, and the most important thing…it lacks
    beauty! It's all gray, it doesn't have style…we are humans, we love beautiful
    things, don't we? Everyone implements styles in their own way. I strongly recommend
    that if you want to use this application, please find your own style and theme
    for it, and please implement it and share with me. I would love to see it.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: As for me, since I am not a designer, I asked my good friend Vanessa ([https://www.behance.net/MeegsyWeegsy](https://www.behance.net/MeegsyWeegsy))
    to create a nice design for the ProFitOro application. She did a great job! Since
    I was busy writing this book, I had no time to implement Vanessa's design, therefore
    I asked my good friend, Filipe ([https://github.com/fil090302](https://github.com/fil090302)),
    to help me with it. Filipe did a great job as well! Everything looks exactly how
    Vanessa implemented it. We have used `scss`, so it must be familiar to you since
    we've been using it already in this application as a preprocessor.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'You can reuse the existing style to override some variables in order to create
    your own theme. Please check the final code in the `chapter8/7/profitoro` folder.
    All styles are located inside the `assets/styles` directory. It has the following
    structure:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '![It''s time to apply some style](../images/00136.jpeg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: Directory structure
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: As for the final look, here is what it looks like.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the main page with the Pomodoro timer:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '![It''s time to apply some style](../images/00137.jpeg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
- en: Main page that contains the Pomodoro timer
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what the Settings page looks like:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![It''s time to apply some style](../images/00138.jpeg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: Look and feel of the Settings page
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally, here is what the Workouts page looks like:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '![It''s time to apply some style](../images/00139.jpeg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
- en: Look and feel of the Workouts page
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'You will still have to implement the Statistics page – right now, it just shows
    the total amount of completed Pomodoros:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '![It''s time to apply some style](../images/00140.jpeg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
- en: Statistics page is not fully complete, only showing the total amount of completed
    Pomodoros
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: There's still some work to do, but don't you agree that we have done great work
    so far? Not only do we have a fully functioning configurable Pomodoro timer, we
    can also already use it to do small workouts during our working day. How great
    is that?
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have finally implemented the workout management page. Now
    we can see all the workouts stored in the database and create our own workouts.
    We have learned how to use the Google Firebase data storage system and API to
    store static files and we were able to store newly created workouts in the Firebase
    real-time database. We have also learned how to use a Bootstrap modal and used
    it to display each workout in a nice modal popup.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will do the most important job of every software implementation
    process – we will test what we have done so far. We will use Jest ([https://facebook.github.io/jest/](https://facebook.github.io/jest/))
    to test our application. After that, we will finally deploy our application and
    define future work. Are you ready for testing your work? Then turn the page!
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
