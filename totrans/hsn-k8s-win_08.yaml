- en: Interacting with Kubernetes Clusters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a Kubernetes cluster user or operator, you need to interact with the Kubernetes
    API to manage Kubernetes Objects or debug applications running in the cluster.
    Generally, there are two ways to communicate with the Kubernetes API: you can
    use representational state transfer (RESTful) HTTPS endpoints directly—for example,
    for programmatic access—or you can use kubectl, which is the Kubernetes command-line
    tool (or **command-line interface** (**CLI**)). In general, kubectl wraps RESTful
    API communication and hides the complexity regarding locating and authenticating
    to the Kubernetes API server. Operations such as creating or listing Kubernetes
    Objects and executing into Pod containers are available as neatly organized kubectl
    sub-commands—you can use these commands when performing ad hoc operations on your
    cluster or as a part of **continuous integration/continuous deployment** (**CI/CD**)
    for your applications.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will provide you with a better understanding of how to install
    kubectl on a Windows machine and how to manage multiple Kubernetes clusters using
    kubectl. You will also learn the most common and useful kubectl commands for managing
    Kubernetes Objects and debugging containerized applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter consists of the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Kubernetes command-line tooling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing Kubernetes clusters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with development clusters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at common kubectl commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need the following installed:'
  prefs: []
  type: TYPE_NORMAL
- en: Windows 10 Pro, Enterprise, or Education (version 1903 or later, 64-bit)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Desktop for Windows 2.0.0.3, or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chocolatey package manager for Windows ([https://chocolatey.org/](https://chocolatey.org/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Azure CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installation of Docker Desktop for Windows and system requirements are covered
    in [Chapter 1](deffbcf5-3a21-4690-ad42-ae5e4cd97dea.xhtml)*, Creating Containers*.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Chocolatey package manager is not mandatory, but it makes the installation
    process and application version management much easier. The installation process
    is documented here: [https://chocolatey.org/install](https://chocolatey.org/install).
  prefs: []
  type: TYPE_NORMAL
- en: For the Azure CLI, you can find detailed installation instructions in [Chapter
    2](43d5e48b-311c-462c-a68e-6a0b5c4224e8.xhtml)*, Managing State in Containers**.*
  prefs: []
  type: TYPE_NORMAL
- en: To follow along using **Azure Kubernetes Service** (**AKS**), you will need
    your own Azure account and AKS instance created. If you haven't already created
    the account for previous chapters, you can read more about how to obtain a limited
    free account for personal use here: [https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/).
    AKS cluster deployment is covered in [Chapter 4](118e3c89-786e-4718-ba67-6c38928e2a42.xhtml),
    *Kubernetes Concepts and Windows Support*. You can also use the PowerShell script
    provided in that chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You can download the latest code samples for this chapter from the official
    GitHub repository: [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter06](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter06).
  prefs: []
  type: TYPE_NORMAL
- en: Installing Kubernetes command-line tooling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kubectl is available on a variety of operating systems, including Windows.
    If you have experience with using kubectl on Linux, you can expect that the only
    difference will be the installation process—the commands and basic principles
    remain the same. For Windows, you have several options for kubectl installation,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the kubectl binary directly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the PowerShell Gallery ([https://www.powershellgallery.com/](https://www.powershellgallery.com/)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use third-party Windows package managers: Chocolatey ([https://chocolatey.org/](https://chocolatey.org/))
    or Scoop ([https://scoop.sh/](https://scoop.sh/)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubectl can also be installed automatically by Docker Desktop for Windows while
    creating a local development Kubernetes cluster (executable installed in `C:\Program
    Files\Docker\Docker\Resources\bin\kubectl.exe`) or using the Azure CLI when creating
    the AKS cluster instance (using the `az aks install-cli` command, which installs
    kubectl in `~/.azure-kubectl/kubectl.exe`). This may create conflicts with already
    installed kubectl instances in different locations—you can always check which
    kubectl installation is used in PowerShell by using the `(Get-Command kubectl).Path`
    command. Switching to a different kubectl installation requires the `PATH` environment
    to be modified and the desired precedence to be ensured.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find detailed instructions for all installation types in the official
    documentation: [https://kubernetes.io/docs/tasks/tools/install-kubectl/](https://kubernetes.io/docs/tasks/tools/install-kubectl/).
    We will demonstrate how to install kubectl using Chocolatey, as this is the easiest
    and the most convenient way to install kubectl on Windows. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't installed the Chocolatey package manager already, you can find
    the instructions to do so here: [https://chocolatey.org/install](https://chocolatey.org/install).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the PowerShell window as Administrator, and install kubectl using the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to upgrade kubectl to the latest version, use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that kubectl has been installed, using—for example—the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: According to the Kubernetes version skew support policy, you should use a version
    of kubectl that is within one minor version (older or newer) of kube-apiserver.
    For example, kubectl 1.15 is guaranteed to work with kube-apiserver 1.14, 1.15,
    and 1.16\. It is advised that you use the latest kubectl version for your cluster
    whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the version of kubectl installed from Chocolatey may sometimes
    be older than the latest available stable version. In this case, if you need the
    latest stable version, follow the instructions for downloading the kubectl binary
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to demonstrate how you can organize access
    to multiple Kubernetes clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Kubernetes clusters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, kubectl uses the `kubeconfig` file located in `~\.kube\config` (note
    that we call it `kubeconfig`, but the filename is `config`), which on Windows
    machines expands to `C:\Users\<currentUser>\.kube\config`. This YAML configuration
    file contains all the parameters required for kubectl to connect to the Kubernetes
    API for your cluster. This configuration file may be also used by different tools
    than kubectl—for example, *Helm*.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `KUBECONFIG` environment variable or the `--kubeconfig` flag
    for individual commands to force kubectl to use a different `kubeconfig`. For
    the `KUBECONFIG` environment variable, it is possible to specify multiple `kubeconfig` and
    merge them in runtime. You can read more about this feature in the official documentation: [https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/#merging-kubeconfig-files](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/#merging-kubeconfig-files).
    Please note that, for Windows, you should specify `KUBECONFIG` paths separated
    by a semicolon, contrary to Linux, where you use a colon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Coordinating access to multiple Kubernetes clusters is organized in `kubeconfig`
    using contexts. Each context contains the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cluster**: The address of the Kubernetes API server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User**: The name of the user, which maps to user credentials (specified in
    `kubeconfig`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Namespace**: Optionally, you can provide the default namespace to use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you have been following the previous chapters, where we demonstrated the
    installation of Minikube and the local Kubernetes cluster in Docker Desktop for
    Windows, you have already used contexts that have been automatically added during
    installation of these clusters. When using kubectl, there is always one context
    marked as current. You can see the current context using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing all of the available contexts in your `kubeconfig` can be done in the
    following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you would like to switch to a different context, for example, `docker-desktop`,
    execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can modify the existing contexts or add your own contexts manually from
    the command line. For example, the following command will add a new context, `docker-desktop-kube-system`,
    which will connect to the `docker-desktop` cluster and use the `kube-system` namespace
    by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When you switch to the new context and run any command, for example, `kubectl
    get pods`, it will be executed against the `kube-system` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: At any given time, you can override the current context settings using `--cluster`,
    `--user`, `--namespace`, or even `--context` flags for kubectl commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, when working with managed Kubernetes providers or local development
    tools, the config will be either served as a separate file to download and use
    via the `KUBECONFIG` environment variable, or merged directly into the current
    `kubeconfig` as a new context (this is what the `az aks get-credentials` command
    does, in the case of AKS). If needed, you can perform merging of `kubeconfigs`
    manually, using the following PowerShell command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this command can be used as a new default `kubeconfig`—you should
    verify if the result is valid before overwriting the default configuration file.
    You can use the following code snippet to overwrite the default `kubeconfig` with
    a merged one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember about the `kubeconfig` merging precedence rules: the value in the
    first file wins if the same key is found in both files.'
  prefs: []
  type: TYPE_NORMAL
- en: Now you know how to manage access to Kubernetes clusters using kubeconfig and
    kubectl contexts, let's focus on strategies for working with development clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Working with development clusters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developing applications for Kubernetes introduces some unique challenges that
    are not present for classical development pipelines. The perfect solution would
    be introducing minimal changes to the pipelines and processes, but, unfortunately,
    it is not as simple as that. First of all, you need to maintain a development
    Kubernetes cluster where you deploy, test, and debug your applications. Secondly,
    you have to containerize your applications and deploy them to the dev cluster,
    possibly with more flexibility and access than in a secure production cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Informally, for Kubernetes applications development, you have four modes (concepts)
    that have been illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/372af989-6426-492e-9380-3760131cdc5f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s have a look at these four modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fully offline**: In a fully offline (local) environment, your development
    environment and Kubernetes cluster are hosted locally on your machine. A good
    example of such a configuration is a Minikube or Docker Desktop for Windows local
    Kubernetes cluster. In both cases, the Kubernetes cluster is hosted in a dedicated
    local **virtual machine** (**VM**). This development workflow requires the building
    of Docker images, pushing them to an image registry (local or remote), and using
    kubectl to deploy the application. You can, of course, leverage the fact that
    the cluster is running locally, and log in to the cluster nodes and debug the
    Pod containers. From a Windows containers'' perspective, this requires running
    a full, hybrid Linux/Windows Kubernetes cluster on Hyper-V VMs. This setup requires
    a local machine that is capable of running at least two VMs: one for the Linux
    master and one for the Windows worker node. We will be deploying a fully functional
    hybrid cluster in [Chapter 7](165c2fcc-4ce8-4dbc-a19c-c7fd427b3379.xhtml), *Deploying
    Hybrid On-Premises Kubernetes Cluster*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The deployment strategies that are presented in the next chapters can be used
    for both development and production clusters. The disadvantage of this approach
    for development is the significant amount of configuration compared to Minikube
    or other fully offline solutions. Unfortunately, at this point, there are no easy
    turnkey solutions for hybrid development clusters—if you need a cluster for development
    as soon as possible, the fully managed AKS is the best option.
  prefs: []
  type: TYPE_NORMAL
- en: '**Proxied**: When using a proxied environment, your Kubernetes cluster is hosted
    on a remote machine (but it can be also hosted on local VMs!). The development
    environment is still on your local machine, but you have a two-way network proxy
    configured so that you can run and debug your applications as if you were "inside"
    of a Pod in the cluster. In other words, you can simplify your development workflow
    and skip Docker overhead for development and debugging scenarios. This can be
    achieved using tools such as Telepresence ([https://www.telepresence.io/](https://www.telepresence.io/)).
    Unfortunately, Windows is currently supported only through Windows Subsystem for
    Linux, which means that there is no native Windows support.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Remote**: The next mode is remote, whereby you develop locally against a
    remote cluster, either hosted in your local data center or as a managed Kubernetes
    offering. This is similar to using a fully offline environment, but you have to
    beware of extra costs of using managed Kubernetes clusters and limited access
    to Kubernetes nodes. For Windows, if you are running AKS, you will not be able
    to log in to the Linux master, but, if you are deploying using AKS engine on bare
    Azure VMs, you can access both the Linux master and the Windows nodes. The advantage
    of this environment type is that you can leverage all cloud integrations for Kubernetes,
    such as LoadBalancer Services or Cloud Volumes. We will be covering AKS engine
    deployment in [Chapter 8](ab695a0d-05dc-48f8-8c41-bbd167cfbfa6.xhtml), *Deploying
    Hybrid Azure Kubernetes Service Cluster*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fully Online**: In fully online mode, your development environment, together
    with the Kubernetes cluster, is hosted remotely. Good examples of such an approach
    are Eclipse Che ([https://www.eclipse.org/che/docs/](https://www.eclipse.org/che/docs/))
    and Azure Dev Spaces ([https://docs.microsoft.com/en-us/azure/dev-spaces/about](https://docs.microsoft.com/en-us/azure/dev-spaces/about)),
    which fully integrates with Visual Studio Code. Support for Windows nodes is still
    in development at this point and requires manual configuration ([https://docs.microsoft.com/en-us/azure/dev-spaces/how-to/run-dev-spaces-windows-containers](https://docs.microsoft.com/en-us/azure/dev-spaces/how-to/run-dev-spaces-windows-containers)).
    In the future, this is the best candidate for offering a seamless Kubernetes development
    life cycle for Windows containers. We will cover Azure Dev Spaces in [Chapter
    12](028affe7-4a23-4c9b-8a24-9c0671efe5e5.xhtml), *Development Workflow with Kubernetes*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many tools that can boost your Kubernetes application development
    productivity and reduce the overhead of having "another cluster in the middle
    of everything". For example, for Windows support, you may want to check out Azure
    Draft ([https://draft.sh/](https://draft.sh/)), which simplifies the development
    pipeline using auto-generated Helm charts for your application, or ksync ([https://ksync.github.io/ksync/](https://ksync.github.io/ksync/)),
    which can be used for syncing your local code/binary changes to Pod containers,
    without a need for redeployment.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will take a quick look at the most common and useful
    kubectl commands that you should have in your toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at common kubectl commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kubectl is a powerful tool that provides most of the functionalities you will
    ever need when interacting with Kubernetes clusters. All of the kubectl commands
    follow the same syntax, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`[command]`, `[type]`, `[name]`, and `[flags]` are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[command]` specifies the operation—for example `get`, `apply`, `delete`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[type]` is the resource type (a detailed list can be found in the documentation:
    [https://kubernetes.io/docs/reference/kubectl/overview/#resource-types](https://kubernetes.io/docs/reference/kubectl/overview/#resource-types)),
    specified in singular, plural, or abbreviated form (case-insensitive)—for example, `service`,
    `services`, `svc`. You can find more information about each resource by using
    the `kubectl explain [type]` command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[name]` determines the name of the resource (case-sensitive). If the command
    allows the name to be omitted, the operation will be applied to all resources
    of a given type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[flags]` specifies the additional flags, which are either specific for a command
    or global for kubectl—for example, `--namespace kube-system`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can always use `kubectl help` or `kubectl [command] --help` to access comprehensive
    documentation on how each command works and what the available flags are. The
    official reference for kubectl can be found here: [https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands).
  prefs: []
  type: TYPE_NORMAL
- en: The terms *resource *and *object *are often used in Kubernetes interchangeably,
    although there are some differences considering Kubernetes internals. Objects
    are Kubernetes system entities (abstract concepts), whereas resources are the
    actual RESTful API resources that provide a representation of objects.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the commands, such as `get` or `create`, allow you to specify the output
    format using the `-o` or `--output` flag. For example, you can use `-o json` to
    force JSON output format, or `-o jsonpath=<template>` to extract information using
    JSONPath templates. This is especially useful when implementing automation based
    on kubectl commands. You can find more information about output types here: [https://kubernetes.io/docs/reference/kubectl/overview/#output-options](https://kubernetes.io/docs/reference/kubectl/overview/#output-options).
  prefs: []
  type: TYPE_NORMAL
- en: For *Bash* and *Zsh*, you can increase your kubectl productivity by using autocompletion([https://kubernetes.io/docs/tasks/tools/install-kubectl/#enabling-shell-autocompletion](https://kubernetes.io/docs/tasks/tools/install-kubectl/#enabling-shell-autocompletion)).
    For Windows, there is no autocompletion support for PowerShell yet, but, if you
    manage your Kubernetes cluster using Windows Subsystem for Linux, you can install
    Bash autocompletion as well.
  prefs: []
  type: TYPE_NORMAL
- en: Creating resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 4](118e3c89-786e-4718-ba67-6c38928e2a42.xhtml), *Kubernetes Concepts
    and Windows Support*, we have explained the ideas behind *imperative* and *declarative*
    resource management in Kubernetes. In short, when using imperative management,
    you rely on commands that create, delete, and replace resources (think of commands
    in a script). On the other hand, in declarative management, you only describe
    the desired state of a resource, and Kubernetes performs all the required actions
    to transform the current state of a resource to the desired one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a Kubernetes resource in an imperative way can be done using the `kubectl
    create -f <manifestFile>` command. For the declarative way, you have to use `kubectl
    apply -f <manifestFile>`. Note that you can apply the `-R` flag and process a
    directory *recursively* instead of a single file. Let''s demonstrate this on an
    example Deployment manifest file for Linux nginx Pods, which you can download
    from the GitHub repository for this book: [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter06/01_deployment-example/nginx-deployment.yaml](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter06/01_deployment-example/nginx-deployment.yaml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that you saved the manifest file as `nginx-deployment.yaml` in the
    current directory, use PowerShell to execute the following command to create a `nginx-deployment-example`
    Deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You can use the URL for manifest files directly in kubectl—for example, `kubectl
    create -f https://raw.githubusercontent.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/master/Chapter06/01_deployment-example/nginx-deployment.yaml`.
    Remember to always verify the contents of the manifest file, especially from a
    security perspective, before deploying them to your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can achieve the same using the `kubectl apply` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, these commands behave in the same way: they just create the
    Deployment. But now, if you modify the `nginx-deployment.yaml` file so that the
    number of replicas is increased to 4, check what happens for the `kubectl create`
    and `kubectl apply` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Creating the Deployment imperatively is not possible because it has been already
    created—you would have to replace it. In the case of a declarative `apply` command,
    the change has been accepted, and the existing Deployment has been scaled to 4
    replicas.
  prefs: []
  type: TYPE_NORMAL
- en: 'For declarative management, kubectl offers the `kubectl diff` command, which
    shows the difference between the current state of resources in the cluster and
    in the manifest file. Note that you need to have the `diff` tool in your `PATH`
    environment variable or use any other file-compare tool—for example, Meld ([http://meldmerge.org/](http://meldmerge.org/))—and
    specify it using the `KUBECTL_EXTERNAL_DIFF` environment variable. Increase the
    number of `replicas` to 5 in `nginx-deployment.yaml`, and check the comparison
    result, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can immediately see in the following screenshot which properties will be
    affected if you execute `kubectl apply`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e2108316-c229-42c4-b292-d6dcfd8a87c4.png)'
  prefs: []
  type: TYPE_IMG
- en: A general rule of thumb is that you should stick to declarative resource management
    whenever possible and leave imperative commands only for development/hacking scenarios.
    For fully declarative management of your Kubernetes applications, consider kubectl
    with Kustomize. You can read more about this approach at: [https://kubernetes.io/docs/tasks/manage-kubernetes-objects/kustomization/](https://kubernetes.io/docs/tasks/manage-kubernetes-objects/kustomization/).
  prefs: []
  type: TYPE_NORMAL
- en: Deleting resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to delete resources, you can use the `kubectl delete [type] [name]`
    command. This is also one of the imperative commands that are still recommended
    to be used in declarative cluster management, as it is more explicit. Using `kubectl
    apply` with the `--prune` flag is more dangerous, as you can accidentally delete
    more resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to delete the `nginx-deployment-example` Deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can specify the `--all` flag instead of the resource name if you want to
    delete all resources of a given type.
  prefs: []
  type: TYPE_NORMAL
- en: Describing and listing resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next command that you will often use is `kubectl get [type] [name]`, which
    shows detailed information about resource(s) of a given type. For example, in
    order to list Pods in the default namespace for the current context, execute the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `--all-namespaces` or `--namespace=<namespace>` global flags,
    which allow you to show resources from other namespaces, as illustrated in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, this command shows limited, predefined columns. You can see more
    details by using the `-o wide` flag, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In some cases, you will find it useful to watch resources. The following command
    lists all the Pods and periodically refreshes the view with the latest data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also a different command, `kubectl describe`, which can be used for
    showing resource details, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The difference between the `get` and `describe` commands is that `get` shows
    a pure representation of a resource from Kubernetes API, whereas `describe` prepares
    a detailed description, including events, controllers, and other resources.
  prefs: []
  type: TYPE_NORMAL
- en: '`kubectl get` supports different outputs than tables—for example, `-o json`
    or `-o yaml`, which are good for integrations with other tools or dumping a resource
    state to file, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need more processing of the output, you can use JSONPath ([https://github.com/json-path/JsonPath](https://github.com/json-path/JsonPath)),
    which is integrated into kubectl. For example, the following expression will list
    all container images being used in Pods in the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'And lastly, you may find it useful to list all resources from all namespaces
    with just a single command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This should always give you a good overview of what is happening in the cluster!
  prefs: []
  type: TYPE_NORMAL
- en: Editing resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned earlier in this section, imperative editing of Kubernetes resources
    is generally discouraged. `kubectl edit` is a combination of `kubectl get`, opening
    your favourite text editor, and `kubectl apply` of the modified manifest file,
    as illustrated in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: On a Windows machine, this command will open `notepad.exe` (or any other editor,
    if you specify the `EDITOR` or `KUBE_EDITOR` environment variables) with the current
    state of `nginx-deployment-example`. After editing, save the file, close the editor,
    and your changes will be applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another approach is using patches, which can be used in declarative management.
    `kubectl patch` updates a resource by merging the current resource state and a
    patch that contains only the modified properties. A common use case for patching
    is when you need to enforce a node selector for an existing DaemonSet in hybrid
    Linux/Windows clusters. The following JSON patch can be used for ensuring that
    a DaemonSet such as Flannel or kube-proxy is running only on Linux nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: It is possible to use YAML patches as well, but, unfortunately, due to PowerShell
    escaping rules, we cannot demonstrate this for the `beta.kubernetes.io/os` selector.
    JSON still requires additional preprocessing in PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to apply this patch to an `nginx-deployment-example` Deployment, save
    the patch as a `linux-node-selector.json` file and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You can find more about the patching of resources and merge types in the official
    documentation: [https://kubernetes.io/docs/tasks/run-application/update-api-object-kubectl-patch/](https://kubernetes.io/docs/tasks/run-application/update-api-object-kubectl-patch/).
  prefs: []
  type: TYPE_NORMAL
- en: Running an ad hoc Pod
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In debugging scenarios, you may find it useful to run an ad hoc Pod and attach
    to it. You can perform this using the `kubectl run` command—note that this command
    can generate different resources, but all generators apart from the Pod are deprecated.
    The following snippet will create a `busybox-debug` Pod with one `busybox` container,
    and run an interactive Bourne shell session in the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: When the shell prompt appears, you can perform actions from inside of the cluster—for
    example, pinging internal IPs. When you exit the shell, the container will be
    automatically removed.
  prefs: []
  type: TYPE_NORMAL
- en: You can use a similar approach to create an interactive PowerShell Pod for Windows
    nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Pod container logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Container logs provide crucial information when debugging applications running
    on Kubernetes. You can access Pod container logs using the `kubectl logs` command,
    similar to how you would for the Docker CLI, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This will work if the Pod is running only one container. If the Pod consists
    of more than one container, you need to use the `--container` or the `--all-containers`
    flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, you may want to tail `n` last lines of logs (`--tail=n` flag)
    and enable live streaming of logs (`--follow` flag), as illustrated in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Execcing into a Pod container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When debugging applications running on Kubernetes, you can `exec` into containers
    running in Pods, just as for bare Docker containers. For example, to list all
    files in the current working directory of the container, use the following `kubectl
    exec` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to attach an interactive Terminal and run a Bash session too,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: For multi-container Pods, you have to use the `--container` flag, or the first
    container in the Pod will be chosen.
  prefs: []
  type: TYPE_NORMAL
- en: Copying Pod container files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kubectl gives you the possibility to copy files between your machine and Pod
    containers (in both ways), analogously to the Docker CLI. For example, to copy
    the `/var/log/dpkg.log` file from a container running in the `nginx-deployment-example-5997d7d5fb-p9fbn` Pod
    to your current directory, execute the `kubectl cp` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In general, if you use a Pod container as a source or destination, you need
    to specify the Pod name and container filesystem path, separated by a colon (`:`).
    As for other commands, if the Pod is running multiple containers, you need to
    use the `--container` flag or the first container will be chosen.
  prefs: []
  type: TYPE_NORMAL
- en: Port forwarding and proxying traffic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kubectl can act as a simple proxy for accessing your Kubernetes cluster. Use
    port forwarding to Pods if you need to directly communicate from your local machine
    to a given port on the Pod. This is achieved without manually exposing Service
    Objects by using the `kubectl port-forward` command. The command can be used for
    forwarding to an automatically selected Pod based on other Objects selectors—for
    example, Deployment, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This command will forward all traffic from your local machine port `7000` to
    port `80` for one Pod in an `nginx-deployment-example` Deployment. Navigate to
    `http://localhost:7000` to verify that the default nginx page is accessible. Terminate
    the port-forwarding command when you are done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, kubectl can provide access to the Kubernetes API server for your
    local machine. Use the `kubectl proxy` command to expose the API at port `8080`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now, when you navigate to `http://localhost:8080/api/v1/namespaces/default/pods`
    in your browser, you will see the Pod Objects that are currently running in the
    cluster. Congratulations—you have successfully set up kubectl port forwarding!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you have learned how to install and use the Kubernetes command-line
    tool, kubectl. We have covered how to organize accessing multiple Kubernetes clusters
    using kubectl contexts, what are the possible strategies for working with development
    clusters, and how they fit Windows clusters. On top of that, you now know the
    basic kubectl commands and a few techniques that can be used for debugging applications
    running on Kubernetes: running ad hoc Pods, accessing Pod container logs, performing
    exec into a Pod container, and copying files between your local machine and the
    Pod container.'
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will focus on the deployment of hybrid Linux/Windows Kubernetes
    clusters in on-premises scenarios. We will demonstrate how to create a fully functional,
    multi-node cluster on your local machine using Hyper-V VMs.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is `kubeconfig`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you set up a custom `kubeconfig` location for kubectl?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the role of context in kubectl?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between `kubectl create` and `kubectl apply` commands?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a kubectl resource patch, and when would you use it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the command to show live logs from a Pod container?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you copy a file between your local machine and a Pod container using
    kubectl?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can find answers to these questions in *Assessments* of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information regarding Kubernetes concepts and the Kubernetes CLI,
    please refer to the following Packt books:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Complete Kubernetes Guide* ([https://www.packtpub.com/virtualization-and-cloud/complete-kubernetes-guide](https://www.packtpub.com/virtualization-and-cloud/complete-kubernetes-guide))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Getting Started with Kubernetes – Third Edition* ([https://www.packtpub.com/virtualization-and-cloud/getting-started-kubernetes-third-edition](https://www.packtpub.com/virtualization-and-cloud/getting-started-kubernetes-third-edition))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Kubernetes for Developers* ([https://www.packtpub.com/virtualization-and-cloud/kubernetes-developers](https://www.packtpub.com/virtualization-and-cloud/kubernetes-developers))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also refer to the excellent official Kubernetes documentation ([https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/))
    and the kubectl reference documentation ([https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
