- en: Chapter 4. Setting up a File Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered SSH and discussed SCP. While SCP is a great
    method to manually transfer individual files from one place to another, having
    one or more central locations to store shared files adds a lot of value to a network.
    Whether you're sharing important files on a business network or family photo albums
    on a home network, a central file storage location on your network is a convenient
    asset. In this chapter, we'll discuss three ways of accomplishing this goal. We'll
    first talk about some considerations while designing your file server, and then
    we'll cover NFS, Samba, and SSHFS.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: File server considerations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NFS v3 versus NFS v4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up an NFS server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the basics of Samba
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a Samba server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mounting network shares
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatically mounting network shares via fstab and systemd
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating networked filesystems with SSHFS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File server considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with most things in the Linux world, there is more than one way of accomplishing
    any goal. With each method, there are a multitude of best practices and caveats
    to understand before implementing a solution. As mentioned earlier, the three
    most common methods of sharing files from one Linux system to another are **Network
    File System** (**NFS**), **Samba**, and **Secure Shell File** **System** (**SSHFS**).
    Each of these three primarily serve different needs, and your network layout will
    determine which you should use.
  prefs: []
  type: TYPE_NORMAL
- en: The first consideration while designing a network file server is what types
    of platforms will need to access its files. NFS is often a great choice within
    a Linux-based environment; however, it doesn't handle mixed environments as well,
    so you may not want to choose it if you have Windows machines on your network
    that you need to share files with. It's not that you can't access NFS shares on
    Windows systems (you certainly can), but Microsoft limits NFS availability (called
    **Services for NFS)** to the most expensive edition of each version of Windows.
    Services for NFS is fine if you utilize versions of Windows that support it, but
    due to the extra licensing hurdle you'd need to overcome, it may make more sense
    to avoid it. Generally speaking, NFS is a great choice only when your network
    consists primarily of UNIX and Linux nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Next up for consideration is Samba. Samba allows you to share files between
    all three major platforms (Windows, Linux, and Mac OSX) and is a great choice
    within a mixed environment. Since Samba uses the **SMB** protocol, Windows systems
    are able to access your Samba shares regardless of the version you have installed,
    so licensing isn't as much of an issue. In fact, even the standard or home editions
    of Windows are able to access these shares natively, with no added plugins required
    for you to install. The downside to Samba is in the way that it handles permissions.
    When saving files between Windows and Linux nodes, some extra work is required
    to handle permissions, such that it's not always the best choice when dealing
    with UNIX or Linux nodes that need to retain specific permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, SSHFS is another method that is primarily geared toward sharing files
    between Linux nodes. It's certainly possible to connect and access SSHFS from
    Windows, but only with third-party utilities, as no built-in method exists in
    Windows (at least at the time this chapter is being written). Where SSHFS shines
    is its ease of use and the fact that file transfers are encrypted. While encryption
    certainly helps you to avoid eavesdropping, keep in mind that SSHFS (just like
    any other solution) is only as secure as the policies you have in place. But in
    good hands, SSH (and SSHFS) is a secure method of transferring files from one
    node to another. In addition, SSHFS is the easiest of the three methods listed
    here to get running. All you need is access to another node and permissions to
    access one or more directories. That's all you need, and then you're automatically
    able to create an SSHFS connection to any directory you have access to. Another
    benefit to SSHFS is that there's nothing to configure on the server other than
    SSH itself, which most servers have available anyway. SSHFS connections can also
    be created and disconnected on-demand very quickly. We'll discuss SSHFS later
    on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: NFS v3 versus NFS v4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another consideration regarding NFS is the version you'll be using. Nowadays,
    most (if not all) Linux distributions default to NFS v4\. However, there are some
    cases where you may have older servers on your network, and you'll need to be
    able to connect to their shares. While NFS v4 is definitely the preferred version
    going forward, you might need to connect to a node using the older protocol.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, directories on a file server can be shared via NFS by editing
    the `/etc/exports` file, which is where you'll list your shares (exports), one
    per line. We'll go over this file in more detail in the next section. But for
    now, keep in mind that the `/etc/exports` file is where you declare which directories
    on your filesystem are available for use with NFS. Different versions of NFS have
    different techniques of handling file locks and they differ in terms of the introduction
    of **idmapd**, performance, and security. Also, there are other differences such
    as NFS v4 moving to TCP-only (previous versions of the protocol allowed either
    UDP or TCP) and the fact that it is **stateful**, while previous versions were
    **stateless**.
  prefs: []
  type: TYPE_NORMAL
- en: By being stateful, NFS v4 includes file locking as part of the protocol itself,
    rather than relying on **Network Lock Manager** (**NLM**) to provide that function
    as NFS v3 did. If an NFS server were to crash or become unavailable, one or more
    nodes that were connected to it may have had open files, which would have been
    locked to those nodes. When the NFS server starts to back up, it re-establishes
    these locks and tries to recover from the crash. Although NFS servers do a fairly
    good job of recovering, they aren't perfect, and at times file locking can become
    a nightmare for administrators to deal with. With NFS v4, NLM is decommissioned
    and file locking is a part of the protocol itself, so locks are dealt with much
    more efficiently. However, it's still not perfect.
  prefs: []
  type: TYPE_NORMAL
- en: So, which version should you use? It's recommended to always use NFS v4 on all
    of your nodes and servers, unless you're dealing with an older server with older
    protocols that you still need to support.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an NFS server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Configuring an NFS server is relatively straightforward. Essentially, all you
    need to do is install the required packages, create your /`etc/exports` file,
    and ensure the required daemons (services) are running. In this activity, we'll
    set up an NFS server and also connect to it from a different node. In order to
    do so, it's recommended that you have at least two Linux machines to work with.
    It doesn't matter if these machines are physical or virtual machines, or any combination
    of those. If you've already followed through with [Chapter 1](ch01.html "Chapter 1. Setting
    up Your Environment"), *Setting up Your Environment*, you should already have
    several nodes to work with; hopefully, a mix of Debian and CentOS, since this
    procedure differs a bit between them.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's set up our NFS server. Pick a machine to act as the NFS server
    and install the required packages. It doesn't matter which distribution you choose
    as your server and which you choose as your client, I'll go over the configuration
    process for both CentOS and Debian. Since quite a few distributions are either
    based on Debian or use the same configuration as CentOS, this should work for
    most distributions out there. If you're using a distribution that doesn't follow
    either package naming convention, all you have to do is look up which package
    or meta-package to install on your server for your specific distribution. The
    rest of the configuration should be the same, since NFS is fairly standard.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the required packages on a CentOS system, we would execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And for Debian, we install `nfs-kernel-server`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: During installation of these packages, you may receive an error that NFS hasn't
    been started, due to `/etc/exports` not being present on the file system. When
    you install the required NFS packages on some distributions, this file may not
    be automatically created. Even if it does get created automatically, the file
    will just be a skeleton. If you do receive such an error, ignore it. We'll create
    this file shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll want to make sure that the services related to NFS are enabled
    so that they will start as soon as the server starts up. For CentOS systems, we''ll
    use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And for Debian, we can enable NFS via:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that we simply enabled the NFS daemon on our server, which means
    that when the system is restarted, NFS will also be started (providing we configured
    it properly). However, we don't have to restart our entire server in order to
    start NFS; we can start that any time after we create our configuration files.
    Since we haven't actually configured NFS yet, we won't need to start the daemon
    yet. We'll do that later. In fact, until we actually create our configuration,
    your distribution probably won't let you start NFS anyway.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to determine which directories on our server we wish to make
    available on our network. Which directories you share is pretty much up to you.
    Anything on the Linux filesystem is a candidate for an NFS export. However, some
    directories, such as `/etc` (which contains your systems configuration) or any
    other system directory, are probably best left private. While you can share any
    directory on your system, it's actually a common practice to create a single directory
    to house all of your shares, and then create subdirectories underneath, that you
    would then share to your clients.
  prefs: []
  type: TYPE_NORMAL
- en: For example, perhaps you would create a directory called `exports` at the root
    of your filesystem (`mkdir /exports`) and then create directories such as `docs`
    and `images` that would be accessible to others. The beauty of this is that your
    shares could be managed from one place (the `/exports` directory) and NFS itself
    has the ability to classify this directory as your export root (we'll discuss
    this later). Before moving on, create some directories on your filesystem that
    you'll use to share, as we'll be placing these directories in a configuration
    file in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Once you've determined which directories in the file system you'd like to share
    and created them, you're ready to begin the actual configuration. Each NFS share,
    referred to as an export, is configured by adding one line per directory we wish
    to share in the `/etc/exports` file. Since you've already installed the required
    packages in order to get NFS on your system, this file may or may not already
    exist. In my experience, CentOS doesn't create this file during installation while
    Debian does. But even if you did get a default `exports` file, it would only contain
    commented out lines of code that don't have any practical purpose. In fact, you
    may have even received a warning or error during installation that the NFS daemon
    wasn't started as `/etc/exports` was not found. That's fine because we'll create
    this file soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the default `exports` file is different from distribution to distribution
    (if it even gets created by default at all), the format for creating new exports
    is the same regardless of your chosen distribution, as NFS is fairly standard.
    The process for adding an export is to open the `/etc/exports` file in your favorite
    text editor and add each export to its own line. Any actual text editor will do,
    as long as it is a text editor and not a word processor. For example, if you''re
    a fan of vim, you can execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you prefer `nano`, you can execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In fact, you can even use graphical text editors such as Gedit, Kate, Pluma,
    or Geany if you would prefer to use GUI tools. These packages are available in
    the repositories of most distributions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It probably goes without saying, but to edit files within the `/etc` directory
    or any others that are owned by root, you''ll need to prefix such commands with
    `sudo` in order to edit them if you aren''t logged in as root. As a best practice,
    it''s recommended to not log in as root unless you absolutely have to. If you''re
    logged in as a normal user, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In Debian, you'll see that the default `/etc/exports` file contains a list of
    comments, which may be helpful to you in viewing how exports are formatted. We
    can create new exports by simply adding them to the end of the file, preserving
    the contents. If you'd prefer to start off with a blank file, you may want to
    back up the original in case you want to refer to it later.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have the file open in your favorite text editor, you should be ready
    to go. All of the directories you wish to share or *export* should be placed in
    this file, one on each line. Then, you append parameters to the share to control
    how it can be accessed and by whom. Here''s an example exports file with some
    example directories and some basic configuration parameters for each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see with those example exports, the format of each basically includes
    the directory we''d like to export, a network address we''d like to allow access
    to, followed by some additional options in parenthesis. There are many options
    you can append here, and we''ll go over some of them later in this chapter. But
    if you would like to view all of the options you can set here, refer to the following
    `man` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s discuss each section of the example `exports` file that was used previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/exports/docs`: The first section contains the directory we''re exporting
    to other nodes on the network. As mentioned before, you can share pretty much
    any directory you''d like. But just because you *can* share a directory doesn''t
    mean you *should*. Share only the directories that you wouldn''t mind others having
    access to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`10.10.10.0/24`: Here, we''re limiting access to nodes within the `10.10.10.0/24`
    network. A node outside of that network will not be able to mount any of these
    exports. In this example, we could have used `10.10.10.0/255.255.255.0` and we
    would have achieved the same result. In our example, `/24` was used, which is
    known as the **Classless Inter-Domain Routing** (**CIDR**) notation that is a
    shorthand for typing out the subnet mask. Of course, there is much more to CIDR
    than that, but for now, just keep in mind that the CIDR notation was used instead
    of the subnet mask to keep the example shorter (plus, it looks cooler).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ro`: In the first export (docs), I''ve set it to read-only for no reason other
    than to show you that you can. This is probably self-explanatory, but a directory
    exported as read-only would allow others to mount the export and access the files
    within it, but not make any changes to anything.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rw`: A read-write export allows nodes that mount it, to create new files and
    modify existing ones (as long as the user has the required permissions set on
    the files themselves).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`no_subtree_check`: While this option is default and we don''t actually need
    to explicitly make a request, not including it may make NFS complain when it restarts.
    This option is the opposite of `subtree_check`, which is largely avoided nowadays.
    This option in particular, controls whether or not the server scans the underlying
    filesystem when processing actions within exports, which can increase security
    a bit but lower reliability. As disabling this option is known to increase reliability,
    it''s been made the default in recent versions of NFS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although I didn't use it in any of my examples, a common export option you'll
    see set in `/etc/exports` is `no_root_squash`. Setting this option allows the
    root user on end-user devices to have root access to the files contained within
    the export. In most cases, this is a bad idea, but you will see this from time
    to time in the wild. This is the opposite of `root_squash`, which maps the root
    user to nobody instead. Unless you have a very good reason to do otherwise, `no_root_squash`
    is what you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to classifying options for a single network, you can make your
    exports available to additional networks by adding configuration for them to the
    same line. Here''s an example of our `docs` mount shared with an additional network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: With this example, we're exporting `/exports/docs` so that it can be accessed
    by nodes within the `10.10.10.0/24` network and the `192.168.1.0/24` network.
    While I used the same options for both, you don't have to. You could even configure
    the export to be read-only for one network and read-write for another if you so
    desired.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we''ve been sharing our exports with entire networks. This is done
    by making the last octet of the allowed IP address a `0`. With the last example,
    any node with an IP address of `10.10.10.x` or `192.168.1.x` and a subnet mask
    of `255.255.255.0` would qualify for access to the export. However, you may not
    always want to give access to an entire network. Perhaps you may want to allow
    access to a single node instead. You can classify an individual node just as easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we allowed a node with an IP address of `10.10.10.191`
    access to our export. Specifying an IP address or network enhances security, though
    it is not a 100 percent catch-all. However, limiting access to only the hosts
    that absolutely need it is a very good place to start when building your security
    policy. We'll cover security in greater detail in [Chapter 9](ch09.html "Chapter 9. Securing
    Your Network"), *Securing Your Network*. But for now, keep in mind that you can
    limit access to the export by specific networks or individual IPs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier, we touched on the fact that starting with Version 4, NFS can use a
    directory to serve as its export root, also known as the NFS pseudo filesystem.
    In the `/etc/exports` file, this is identified by placing either `fsid=0` or `fsid=root`
    as an option while exporting this directory. In this chapter, we''ve been using
    `/exports` to serve as the base of our NFS exports. If we wanted to identify this
    directory as our export root, we would change the `/etc/exports` file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'At first, this concept might be a big confusing, so let''s break this down
    a bit. In the first line, we identify our export root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, we declare `/exports` as our export root. This is now the root of the
    NFS filesystem. Sure, you have a complete filesystem beginning with `/` in terms
    of Linux itself, but as far as NFS is concerned, its filesystem now begins here
    at `/exports`. In this line, we also declared `/exports` as read-only. We don't
    want anyone to make changes to this directory, as it is the NFS root. It's also
    shared with everyone (notice the `*`) but that shouldn't matter, as we set more
    granular permissions for each individual export. With the NFS root in place, clients
    can now mount these exports without needing to know the full path to get to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a user might type the following to mount our `downloads` export
    to his or her local filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how you mount an NFS export from a local file server (`10.10.10.100`
    in this case), which is *not* using an NFS root. This requires the user to know
    that the directory is located at `/exports/downloads` on that server. But with
    the NFS root in place, we can have the user simplify the `mount` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we left out /exports in the previous command. While this may not
    seem like much, we're basically asking the server to give us the `downloads` export,
    wherever it may be on the file system. It doesn't matter if the `downloads` directory
    is located at `/exports/downloads`, `/srv/nfs/downloads`, or wherever else. We
    simply ask for the `downloads` export and the server knows where it is, because
    we set the NFS root.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve configured our `/etc/exports` file, it''s a good idea that
    we edit the `/etc/idmapd.conf` configuration file to configure some additional
    options. This isn''t absolutely required but it''s definitely recommended. The
    default `idmapd.conf` file is different from distribution to distribution, but
    each contains the options we would need to configure in this section. First, look
    for a line such as the following (or very similar):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: First, we'll need to uncomment that line. Remove the `#` symbol and the trailing
    space so that the line begins with `Domain`. Then, set your domain so that it
    is the same as other nodes on your network. This domain would most likely have
    been chosen during installation. If you don't remember what yours is, running
    the `hostname` command should give you your domain name, which is immediately
    after your hostname. Do this for every node you'd like to be able to access NFS
    exports.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering why this is necessary. When user and group accounts are
    created on a Linux system, they're assigned a **UID** (**User ID**) and **GID**
    (**Group ID**). Unless you created your user accounts on all of your systems in
    the same exact order, the UID and GID will most likely be different on each node.
    Even if you did create your user and group accounts in the same order, they could
    still be different. The `idmapd` file helps us by mapping these UIDs from one
    system to another. In order for `idmapd` to work, the `idmapd` daemon must be
    running on each node, and the file should also be configured with the same domain
    name. On both CentOS and Debian, this daemon runs under `/usr/sbin/rpc.idmapd`
    and is started along with the NFS server.
  prefs: []
  type: TYPE_NORMAL
- en: So, you might be wondering; what's the purpose of the `Nobody-User` and `Nobody-Group`?
    The `nobody` user runs scripts or commands that would be dangerous if run by a
    privileged user. Typically, the `nobody` user cannot log in to the system and
    does not have a home directory. If you run a process as `nobody`, its scope is
    limited if ever the account should be compromised. In the case of NFS, the `nobody`
    user and `nobody` group serve a special purpose. If the files are owned by a specific
    user on one system that doesn't exist on another, the permissions for the file
    will be displayed as being owned by the `nobody` user and group. This is also
    true of accessing files via the root user, when `no_root_squash` is not set. Depending
    on which distribution you're using, these accounts may have different names. In
    Debian, both `Nobody-User` and `Nobody-Group` default to simply `nobody`. In CentOS,
    these are both `nobody`. You can see in your `idmapd.conf` file which account
    is used for the `nobody` user and `nobody` group. You shouldn't need to rename
    these accounts, but if for some reason you do, you'll need to ensure that the
    `idmapd.conf` file has the correct names for them.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have NFS configured and ready to go, how do we start using it? If
    you've been following along, you may have caught the fact that we enabled the
    NFS daemon but have yet to start it. Now that the configuration is in place, nothing
    is stopping us from doing so.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Debian we can start the NFS daemons by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'On CentOS, we can execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: From this point onwards, our NFS exports should be shared and ready to go. Later
    on in this chapter, I'll explain how to mount these exports (as well as Samba
    shares) on other systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more thing in NFS that is worth mentioning. The `/etc/exports`
    file is read whenever the NFS daemon starts, which means you can activate new
    exports after you add them by restarting the server or the NFS daemon. However,
    in production, it''s not practical to restart NFS or the server itself. This would
    interrupt users that are currently using it and possibly cause stale mounts, which
    are invalidated connections to network shares (not a good situation to be in).
    Thankfully, activating new exports without restarting NFS itself is easy. Simply
    execute the following command and you''ll be good to go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Learning the basics of Samba
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Samba, like NFS, allows you to share directories on your server with other computers
    within your network. Although both serve the same purpose, they fit different
    environments and use cases.
  prefs: []
  type: TYPE_NORMAL
- en: NFS is the oldest method and is widely used in the Linux and UNIX world. While
    we certainly have newer solutions (such as SSHFS), NFS is tried and true. But
    it's perhaps not the best solution in a mixed environment. These days, it's possible
    that not every computer on your network runs a particular operating system, so
    you may have nodes where NFS access isn't available or is not practical.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, only the more expensive editions of Windows support NFS.
    If you have a large network of Windows machines, it would be quite expensive to
    update them all to a higher edition if you wouldn't otherwise need to. This is
    the area where Samba shines the most. Windows, Linux, and Mac computers can access
    directories shared via Samba. In the case of Windows, even the lower end editions
    can access Samba shares (such as Windows 7 Home Professional or Windows 10 core)
    without any new installations or purchases.
  prefs: []
  type: TYPE_NORMAL
- en: The downside to Samba is that it doesn't handle permissions as well as NFS does,
    so you need to manage the configuration file in special ways to respect permissions.
    However, it's not foolproof. For example, Windows and Linux/UNIX systems adopt
    very different schemes of permissions, so they are not inherently compatible.
    In Samba's configuration file, you can tell it to use certain user and group permissions
    on newly created files, and you can even force Samba to treat ownership as something
    other than what is actually stored with the file. So there are certainly ways
    to make Samba handle permissions better, but not inherently as good as a Linux
    or UNIX native solution such as NFS.
  prefs: []
  type: TYPE_NORMAL
- en: As far as how as Samba server might fit within your network, the basic rule
    of thumb is to use Samba in a mixed environment and NFS whenever cross-platform
    compatibility is not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Samba server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we''ll go ahead and set up a Samba server. In the next section,
    I''ll explain how to mount Samba shares. First, we''ll need to install Samba.
    On both CentOS and Debian systems, the package is simply referred to as `samba`.
    So, install that package via `apt-get` or `yum` and you should have everything
    you need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The command using `apt-get` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'On Debian systems, Samba is started as soon as it is installed. In fact, it''s
    enabled as well, so it will automatically start each time you bring up your system.
    In the case of CentOS though, it is not enabled nor started after installation.
    If you chose CentOS to be your Samba server, you''ll need to enable and start
    the daemon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, Samba is installed, enabled, but not configured. To configure Samba, we''ll
    need to edit the `/etc/samba/smb.conf` file. By default, this file is created
    as soon as you install the required packages. However, the default file mainly
    exists to provide you with configuration examples. It''s quite massive, but you
    may want to take a look at it to see some syntax examples you may want to use
    later. You can either open the file in a text editor or simply `cat` the file
    to view it on your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To simplify things, I recommend that you start with a fresh file. While the
    configuration examples are definitely good, we should probably use a shorter file
    for production purposes. Since the original file may be useful later, create a
    backup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, simply open the `smb.conf` file in a text editor, which will create a
    new/empty file since we moved the original file to a backup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can start with the following basic configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Let's go through this configuration file line by line. First, we start with
    the `[global]` section, which is where we're configuring options that will take
    effect for the entire server. In fact, this is the only section in this particular
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have `server string`. The `server string` is the description you'll
    see if browsing the network shares on a Windows system. For example, you may see
    a share named `Documents` and with a description beneath that reads; `File Server`.
    This section isn't required, but it's nice to have. In a business network, this
    can be useful for outlining a note about the system, such as where it is, or what
    it's used for.
  prefs: []
  type: TYPE_NORMAL
- en: Following that, we set our `workgroup`. Those of you who have been administrators
    of Windows systems probably know this very well. The workgroup serves as a namespace
    to contain all systems of a particular purpose. In practice, this is typically
    the name of your LAN. Each computer within your LAN would have the same workgroup
    name, so they would show up as existing within the same network. When browsing
    shares on a Windows system, you'll likely see a list of workgroups and double-clicking
    on one of them would take you to a listing of systems that are sharing resources
    underneath that workspace. In most cases, you'll probably want to have the same
    workgroup name on each system, unless you'd like to separate resources. To view
    the workgroup name on an existing system, right-click on **My Computer** or **This
    PC** (depending on your version) and click on **Properties**. Your workgroup name
    should be listed within the window that appears.
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up a Samba server](img/B03919_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Viewing properties of a Windows system to gather the workgroup name, which is
    LOCALNET in this case
  prefs: []
  type: TYPE_NORMAL
- en: The setting `security = user` tells Samba to use the user's username and password
    for authentication. If this matches, the user won't be prompted for a password
    to access the resource.
  prefs: []
  type: TYPE_NORMAL
- en: The `map to` `guest = Bad User` tells Samba that if the username and password
    that's provided does not match a local user account, treat the connecting user
    as if he or she connected via a guest account. If you'd rather such mapping not
    take place, remove this section.
  prefs: []
  type: TYPE_NORMAL
- en: Next, `name resolve order = bcast hosts wins` determines the order in which
    name resolution happens. Here, we're using whatever name is broadcast first, followed
    by any hostname mappings in our `/etc/hosts file`, followed by `wins` (`wins`
    has largely been replaced by DNS, it's only included here for compatibility).
    In most networks, this order should work fine.
  prefs: []
  type: TYPE_NORMAL
- en: Finally we've `include = /etc/samba/smbshared.conf` at the end of our configuration
    file. Basically, this allows us to include another configuration file as if it
    were part of the existing one. In this case, we're including the contents of `/etc/samba/smbshared.conf`,
    which would be read by Samba once it reads this particular line. We'll create
    this file next. Essentially, this allows us to designate our shares in a separate
    configuration file. This isn't required, but I think it makes things much easier
    to manage. If you'd prefer, you could include the contents of the `smbshared.conf`
    file in your `smb.conf` file so that everything is in a single file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example `smbshared.conf` I''ve created for the purposes of this
    activity. In your case, all you would need to do is to ensure that the values
    match your system and the directories you''ve chosen to share:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, I've created two shares. Each share begins with a name in brackets (which
    will be displayed on other systems while browsing shares on this machine) and
    then the configuration for that share. As you can see, I have a shared directory
    called `Music` and another called `Public`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare the path to a share, use `path =` and then the path to the directory
    that the share corresponds to. In my example, you can see that I have the following
    directories shared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Next, I also declare the shares as public by adding `public = yes`. This means
    that it's okay for guests to be able to access this share. If I would prefer guests
    not to be able to access it, I could set this to `no`.
  prefs: []
  type: TYPE_NORMAL
- en: In my music share, I have `writable = no`. As the name suggests, this disables
    the ability for other computers to change files within this share. In my case,
    I share my music collection with other computers on my network, but I wouldn't
    want to accidentally delete music files.
  prefs: []
  type: TYPE_NORMAL
- en: 'In my public share, I have added a few extra options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: These options all correspond to the permissions that are defaulted to when a
    new file is created within that share. For example, if I mounted my public share
    and then created a directory there, it would obtain permissions of `777`. If I
    created a file, its permissions would be `664`. Of course, you may not want to
    allow your files to be wide open, so you can change these permissions as you see
    fit. This option ensures consistency with permissions on newly created directories
    and files. This can be essential on a network where you may have automated processes
    running that need to access these files, and you'd want to make sure that you
    wouldn't need to manually correct the permissions each time such a process is
    run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you''ve created your own Samba configuration, it''s a good idea to
    test your configuration. Thankfully, Samba itself includes a special command that
    allows you to do this. If you run `testparm` on your system, it will display any
    errors in syntax that you may have in your file. Then, it will display your configuration.
    Go ahead and run `testparm` on your system. If there are any errors, go back and
    ensure that there are no issues with what you typed in. If everything proceeds
    normally, you should see no errors, and then you''ll get a summary of your configuration.
    Once you''ve verified your configuration, restart the Samba daemon so that the
    changes take effect. To do that, simply run the following command on your Debian
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'For CentOS, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you should be able to access your Samba shares on Windows or Linux systems.
    On Linux, most GUI file managers should allow you to browse your network for Samba
    shares. On Windows, you should be able to open **My Computer** or **This PC**
    and then click on **Network** to browse local networked computers with active
    shares. Perhaps a simpler way to access the shares on a Windows machine is to
    press the Windows key on your keyboard followed by *R* to open a run dialog, and
    then simply type in the name of your Samba server beginning with two backslashes.
    For example, to access my Debian-based file server (Pluto) from a Windows system,
    I would type the following into the run dialog and press *Enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'I got a list of shares from that system, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up a Samba server](img/B03919_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Viewing Samba shares (served from a Linux System) from a Windows 7 PC
  prefs: []
  type: TYPE_NORMAL
- en: Mounting network shares
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this chapter, we've worked through creating both NFS and Samba shares.
    But we haven't actually mounted any of those shares yet. In this section, we'll
    take care of that.
  prefs: []
  type: TYPE_NORMAL
- en: In Linux, the `mount` command works for mounting just about everything. Whether
    you connect an external hard drive, insert a CD, or wish to mount a network share,
    the `mount` command serves as a Swiss Army Knife to allow you to mount such resources
    to your system. The `mount` command allows you to mount a resource and attach
    it to a local directory on your system. In most cases, `mount` runs automatically
    on most Linux systems where a graphical desktop environment is used. You've probably
    seen this if you've inserted a flash drive or some sort of optical media. In network
    shares, these are not mounted automatically, though they can be configured to
    be.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the easiest way to mount network shares is to use a GUI file manager
    if you are using a system with a desktop environment installed. If you click on
    a file share, it will likely be mounted and you will be allowed to access it providing
    you have the necessary permissions on that system to do so. **Nautilus**, **Caja**,
    **Pcmanfm**, and **Dolphin** are popular Linux file managers.
  prefs: []
  type: TYPE_NORMAL
- en: '![Mounting network shares](img/B03919_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The pcmanfm file manager, viewing shares from a Samba file server
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mount` command is most useful on systems without a graphical environment,
    or when you''d prefer to mount a resource somewhere other than the default. To
    use the `mount` command, give it the type of resource you''d like to mount, where
    it can find the resource, followed by which local directory to use for the mount.
    For example, to mount an NFS export, we might do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, use the following command if we set our NFS root, as I mentioned
    earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In that example, we tell the mount command we''d like to mount an NFS export
    by providing it with the `-t` parameter followed by `nfs` for the type. In my
    lab, this share exists on a computer with an IP address `10.10.10.101`, which
    I provide next with a colon and the directory on that system I''m accessing. In
    this case, `/exports/docs` on `10.10.10.101` is being accessed. Finally, I have
    a local directory `/mnt/docs`, which exists on my local computer where I''d like
    for this share to be mounted. After executing this command, each time I access
    `/mnt/docs` on my local computer, I''m actually accessing `/exports/docs` on my
    file server. After using this export, I simply unmount it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Mounting a Samba share on a Linux machine is a bit more involved. I''ll include
    an example command that can be used to mount a Samba share from that same server.
    But before we get to that, you''ll first need to have the necessary packages installed
    on your system in order to be able to mount Samba shares. On CentOS, install `samba-client`.
    On Debian, the package is `smbclient`. After you install the required package,
    you should be able to mount Samba shares by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to access the resource via a password, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the same basic idea is used to mount a Samba share. But in this
    case, we format our target path differently, we use `cifs` for the filesystem
    type and we also include the username (and password, if your Samba server requires
    it). As in previous examples, we end the command with a local directory we would
    like to attach the mount to. In this case, I've created a `/mnt/samba/Videos`
    directory for this share.
  prefs: []
  type: TYPE_NORMAL
- en: Automatically mounting network shares via fstab and systemd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As handy as mounting network shares via the `mount` command can be, you may
    not want to manually mount a share each time you wish to use it. In a network
    with a central file server, it makes sense to configure workstations to mount
    network shares automatically so that every time you boot your system, the share
    will automatically be mounted and ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: The tried and tested approach to mounting resources automatically is the `/etc/fstab`
    file. Every Linux system has a `/etc/fstab` file, so go ahead and look at yours.
    By default, this file only contains configuration for mounting your local resources,
    such as partitions on your hard disk. It's standard practice to add additional
    lines of configuration to this file to mount anything from additional hard drives
    to network shares.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be careful while editing your `/etc/fstab` file. If you accidentally alter the
    configuration for your local hard disk, your system won't boot the next time you
    go to start it. Always use caution while editing this file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example `/etc/fstab` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In my file, the **Universally Unique Identifier** (**UUID**) reference my local
    hard disk partitions. These will be different on each system. Next, a mount point
    is listed for each. The `/` sign represents the root of the filesystem, and the
    swap partition doesn't need a mount point so it is set to `none`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the `/etc/fstab` file, we can add additional mounts that we would
    like to be available each time we start the system. If we wish to add an NFS share,
    we could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the first section, we declare the IP address of the server followed by a
    colon and the path to the exported directory. In this case, I'm accessing `/share/music`
    on `10.10.10.101`. The next section is the mount point, so I'm attaching this
    export to `/home/jay/music` on my local system. Next, we designate that the share
    we're accessing is `nfs`. No surprises there. Finally, we end the configuration
    with some options for how we would like to mount this share. An easy mount option
    is `rw`, which stands for read-write. We could've used `ro` here if we wanted
    to prevent the files contained within from being changed.
  prefs: []
  type: TYPE_NORMAL
- en: Among the options in the previous example is `x-systemd.automount`. Basically,
    this tells systemd (the default `init` system on Debian and CentOS since version
    8 and 7 respectively) that we would like to keep this mounted if possible. With
    this option, systemd will try its best to remount this share if for some reason
    it gets disconnected. Also, `x-systemd.device-timeout=10` can be added which tells
    the system to wait no longer than 10 seconds if the share isn't available on the
    network. We end the line with `0 0` because this isn't a local filesystem and
    doesn't need consistency check while booting.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're not using a distribution with systemd (such as CentOS 7 and Debian
    8), do not include the `x-systemd` options because they won't be understood by
    distributions that use different `init` systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, Samba shares can also be added to your `/etc/fstab` file. Here''s
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'One final note regarding the `/etc/fstab` file before we move on. The examples
    in this section have all assumed that you want a network share to be available
    automatically. However, this may not always be the case. If you add the `noauto`
    mount option to a configuration line in your `fstab`, the share will not automatically
    be mounted at boot time. With `noauto` added to our Samba example, the `fstab`
    line would be changed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'An NFS example would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several situations where this might be useful. One example might
    be using a laptop, where you wouldn''t always be connected to the same network.
    If that is the case, you wouldn''t want your machine to try and automatically
    mount something unless you''re actually connected to that network. With `noauto`
    added as a mount option, you can manually mount the resource any time you need
    it, without needing to memorize a long `mount` command to do so. For example,
    to mount an NFS export that''s contained in your `fstab` file, you would execute
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'By comparison, that''s a lot easier than typing the following each time you
    wish to mount that export:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Since we added the export to the `fstab` file, the `mount` command looks for
    a relevant line when we type a simplified `mount` command as we have just done.
    If it finds a configuration for the mount point you're trying to access, it will
    let you access it without needing to type out the entire command. Even if you
    don't want to access remote shares automatically, it can still be quite handy
    to add them to your `fstab` file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating networked filesystems with SSHFS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we worked through SSH, which is a crucial utility that
    is used multiple times per day by most Linux administrators. But while it's great
    for accessing other Linux systems on your network, it also allows you to access
    remote filesystems as if they were mounted locally. This is known as **SSHFS**.
    One of the great things about SSHFS is that there is no need to clarify any exported
    directories before hand. If you're able to connect to a remote Linux server and
    access a directory via SSH, then you're automatically able to mount it locally
    as if it were a network share.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Debian systems, you can simply install the `sshfs` package. On CentOS, the
    `sshfs` package is not available by default. Before you can install `sshfs` on
    a CentOS system, you''ll need to add a whole new repository, known as **Extra
    Packages for Enterprise Linux** (**EPEL**). To do that, simply install the `epel-release`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'After installing the `epel` repository, you should be able to install `sshfs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, you''re able to mount directories on your local file system
    quite easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In order to work, your user account must have access not only to the remote
    system, but also to the local mount point. Once you initiate the command, you'll
    see prompts similar to those you'd normally see while connecting to the server
    via SSH. Essentially, that's exactly what you're doing. The difference is that
    the connection remains open in the background, maintaining the relationship between
    the remote directory and the local directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `sshfs` is a great idea for when you need to mount something on a remote
    filesystem, but you may not need to access it again or that often. But similar
    to NFS and Samba shares, you can actually use `/etc/fstab` to mount a resource
    via SSHFS. Consider the following `fstab` example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'As we''ve done before, we set `noauto` so that we can establish this connection
    by simply typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this action-packed chapter, we worked through several ways of accessing and
    sharing files within a Linux-based network. We started off discussing NFS, which
    is an old but trusty method of sharing files within a Linux and UNIX network.
    We also covered Samba, a method of sharing resources within a mixed operating
    system environment. We also discussed how to mount such shares manually as well
    as automatically. We finished our discussion with SSHFS, which is a quite handy
    (yet not well-known) feature of SSH that allows us to mount directories from other
    systems on-demand.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, with relying on our networked resources in our network, it's important
    to keep each node running in tip top shape. In the next chapter, we'll work through
    monitoring system resources and keeping our nodes happy and healthy.
  prefs: []
  type: TYPE_NORMAL
