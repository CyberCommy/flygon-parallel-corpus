- en: Chapter 6. Generators and Coroutines – Infinity, One Step at a Time
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A generator is a specific type of iterator that generates values through a
    function. While traditional methods build and return a `list` of items, a generator
    will simply `yield` every value separately at the moment when they are requested
    by the caller. This method has several benefits:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Generators pause execution completely until the next value is yielded, which
    makes them completely lazy. If you fetch five items from a generator, only five
    items will be generated, so no other computation is needed.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generators have no need to save values. Whereas a traditional function would
    require creating a `list` and storing all results until they are returned, a generator
    only needs to store a single value.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generators can have infinite size. There is no requirement to stop at a certain
    point.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These benefits come at a price, however. The immediate results of these benefits
    are a few disadvantages:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Until you are done processing, you never know how many values are left; it could
    even be infinite. This makes usage dangerous in some cases; executing `list(some_infinite_generator)`
    will run out of memory.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot slice generators.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot get specific items without yielding all values before that index.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot restart a generator. All values are yielded exactly once.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to generators, there is a variation to the generator's syntax that
    creates coroutines. Coroutines are functions that allow for multitasking without
    requiring multiple threads or processes. Whereas generators can only yield values
    to the caller, coroutines actually receive values from the caller while it is
    still running. While this technique has a few limitations, if it suits your purpose,
    it can result in great performance at a very little cost.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, the topics covered in this chapter are:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: The characteristics and uses of generators
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generator comprehensions
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generator functions
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generator classes
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bundled generators
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coroutines
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are generators?
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A generator, in its simplest form, is a function that returns elements one at
    a time instead of returning a collection of items. The most important advantage
    of this is that it requires very little memory and that it doesn't need to have
    a predefined size. Creating an endless generator (such as the `itertools.count`
    iterator discussed in [Chapter 4](ch04.html "Chapter 4. Functional Programming
    – Readability Versus Brevity"), *Functional Programming – Readability Versus Brevity*)
    is actually quite easy, but it does come with a cost, of course. Not having the
    size of an object available makes certain patterns difficult to achieve.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic trick in writing generators (as functions) is using the `yield` statement.
    Let''s use the `itertools.count` generator as an example and extend it with a
    `stop` variable:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Due to the potentially infinite nature of generators, caution is required. Without
    the `stop` variable, simply doing `list(count())` would result in an out-of-memory
    situation quite fast.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'So how does this work? It''s just a normal `for` loop, but the big difference
    between this and the regular method of returning a list of items is that the `yield`
    statement returns the items one at a time. An important thing to note here is
    that the `return` statement results in a `StopIteration` and passing something
    along to `return` will be the argument to the `StopIteration`. It should be noted
    that this behavior changed in Python 3.3; in Python 3.2 and earlier versions,
    it was simply not possible to return anything other than `None`. Here is an example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Of course, as always, there are multiple ways of creating generators with Python.
    Other than functions, there are also generator comprehensions and classes that
    can do the same thing. Generator comprehensions are pretty much identical to list
    comprehensions but use parentheses instead of brackets, like this for example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For completeness, the class version of the `count` function is as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The biggest difference between the class and the function-based approach is
    that you are required to raise a `StopIteration` explicitly instead of just returning
    it. Beyond that, they are quite similar, although the class-based version obviously
    adds some verbosity.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Advantages and disadvantages of generators
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have seen a few examples of generators and know the basics of what you can
    do with them. However, it is important to keep their advantages and disadvantages
    in mind.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are most important pros:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Memory usage. Items can be processed one at a time, so there is generally no
    need to keep the entire list in memory.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The results can depend on outside factors, instead of having a static list.
    Think of processing a queue/stack for example.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generators are lazy. This means that if you're using only the first five results
    of a generator, the rest won't even be calculated.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generally, it is simpler to write than list generating functions.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The most important cons:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: The results are available only once. After processing the results of a generator,
    it cannot be used again.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The size is unknown until you are done processing, which can be detrimental
    to certain algorithms.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generators are not indexable, which means that `some_generator[5]` will not
    work.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considering all the advantages and disadvantages, my general advice would be
    to use generators if possible and only return a `list` or `tuple` when you actually
    need to. Converting a generator to a `list` is as simple as `list(some_generator)`,
    so that shouldn't stop you since generator functions tend to be simpler than the
    equivalents that produce `list`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'The memory usage advantage is understandable; one item requires less memory
    than many items. The lazy part, however, needs some additional explanation as
    it has a small snag:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, the generator effectively freezes right after the `yield` statement,
    so even the `After 2` won't print until `3` is yielded.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: This has important advantages, but it's definitely something you need to take
    into consideration. You can't have your cleanup right after the `yield` as it
    won't be executed until the next `yield`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Pipelines – an effective use of generators
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The theoretical possibilities of generators are infinite (no pun intended),
    but their practical uses can be difficult to find. If you are familiar with the
    Unix/Linux shell, you must have probably used pipes before, something like `ps
    aux | grep python''` for example to list all Python processes. There are many
    ways to do this, of course, but let''s emulate something similar in Python to
    see a practical example. To create an easy and consistent output, we will create
    a file called `lines.txt` with the following lines:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, let''s take the following Linux/Unix/Mac shell command to read the file
    with some modifications:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This reads the file using `cat`, outputs all lines that contain `spam` using
    `grep`, and replaces `spam` with `bacon` using the `sed` command. Now let''s see
    how we can recreate this with the use of Python generators:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That's the big advantage of generators. You can wrap a list or sequence multiple
    times with very little performance impact. Not a single one of the functions involved
    executes anything until a value is requested.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: tee – using an output multiple times
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned before, one of the biggest disadvantages of generators is that
    the results are usable only once. Luckily, Python has a function that allows you
    to copy the output to several generators. The name `tee` might be familiar to
    you if you are used to working in a command-line shell. The `tee` program allows
    you to write outputs to both the screen and a file, so you can store an output
    while still maintaining a live view of it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: The Python version, `itertools.tee`, does a similar thing except that it returns
    several iterators, allowing you to process the results separately.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, `tee` will split your generator into a tuple containing two different
    generators, which is why tuple unpacking works nicely here. By passing along the
    `n` parameter, this can easily be changed to support more than 2 generators. Here
    is an example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After seeing this code, you might be wondering about the memory usage of `tee`.
    Does it need to store the entire list for you? Luckily, no. The `tee` function
    is pretty smart in handling this. Assume you have a generator that contains 1,000
    items, and you read the first 100 items from `a` and the first `75` items from
    `b` simultaneously. Then `tee` will only keep the difference (`100 - 75 = 25`
    items) in the memory and drop the rest while you are iterating the results.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Whether `tee` is the best solution in your case or not depends, of course. If
    instance `a` is read from the beginning to (nearly) the end before instance `b`
    is read, then it would not be a great idea to use `tee`. Simply converting the
    generator to a `list` would be faster since it involves much fewer operations.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Generating from generators
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we have seen before, we can use generators to filter, modify, add, and remove
    items. In many cases, however, you''ll notice that when writing generators, you''ll
    be returning from sub-generators and/or sequences. An example of this is when
    creating a `powerset` using the `itertools` library:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This pattern was so common that the yield syntax was actually enhanced to make
    this even easier. Instead of manually looping over the results, Python 3.3 introduced
    the `yield from` syntax, which makes this common pattern even simpler:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: And that's how you create a powerset in only three lines of code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps, a more useful example of this is flattening a sequence recursively:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that this code uses `TypeError` to detect non-iterable objects. The result
    is that if the sequence (which could be a generator) returns a `TypeError`, it
    will silently hide it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Also note that this is a very basic flattening function that has no type checking
    whatsoever. An iterable containing an `str` for example will be flattened recursively
    until the maximum recursion depth is reached, since every item in an `str` also
    returns an `str`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Context managers
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with most of the techniques described in this book, Python also comes bundled
    with a few useful generators. Some of these (`itertools` and `contextlib.contextmanager`
    for example) have already been discussed in [Chapter 4](ch04.html "Chapter 4. Functional
    Programming – Readability Versus Brevity"), *Functional Programming – Readability
    Versus Brevity* and [Chapter 5](ch05.html "Chapter 5. Decorators – Enabling Code
    Reuse by Decorating"), *Decorators – Enabling Code Reuse by Decorating* but we
    can use some extra examples to demonstrate how simple and powerful they can be.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python context managers do not appear to be directly related to generators,
    but that''s a large part of what they use internally:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: While all this works just fine, the three levels of context managers tend to
    get a bit unreadable. Generally, decorators can solve this. In this case, however,
    we need the output from one context manager as the input for the next.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s where `ExitStack` comes in. It allows easy combining of multiple context
    managers:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Looks at least a bit simpler, doesn''t it? While the necessity is limited in
    this case, the convenience of `ExitStack` becomes quickly apparent when you need
    to do specific teardowns. In addition to the automatic handling as seen before,
    it''s also possible to transfer the contexts to a new `ExitStack` and manually
    handle the closing:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Most of the `contextlib` functions have extensive documentation available in
    the Python manual. `ExitStack` in particular is documented using many examples
    at [https://docs.python.org/3/library/contextlib.html#contextlib.ExitStack](https://docs.python.org/3/library/contextlib.html#contextlib.ExitStack).
    I recommend keeping an eye on the `contextlib` documentation as it is improving
    greatly with every Python version.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Coroutines
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Coroutines are subroutines that offer non-pre-emptive multitasking through multiple
    entry points. The basic premise is that coroutines allow two functions to communicate
    with each other while running. Normally, this type of communication is reserved
    only for multitasking solutions, but coroutines offer a relatively simple way
    of achieving this at almost no added performance cost.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Since generators are lazy by default, the working of coroutines is fairly obvious.
    Until a result is consumed, the generator sleeps; but while consuming a result,
    the generator becomes active. The difference between regular generators and coroutines
    is that coroutines don't simply return values to the calling function but can
    receive values as well.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: A basic example
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous paragraphs, we saw how regular generators can yield values.
    But that''s not all that generators can do. They can actually receive values as
    well. The basic usage is fairly simple:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: And that's all there is to it. The function is frozen until the `send` method
    is called, at which point it will process up to the next `yield` statement.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Priming
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since generators are lazy, you can''t just send a value to a brand new generator.
    Before a value can be sent to the generator, either a result must be fetched using
    `next()` or a `send(None)` has to be issued so that the code is actually reached.
    The need for this is understandable but a bit tedious at times. Let''s create
    a simple decorator to omit the need for this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you've probably noticed, even though the generator is still lazy, it now
    automatically executes all of the code until it reaches the `yield` statement
    again. At that point, it will stay dormant until new values are sent.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the `coroutine` decorator will be used throughout this chapter from
    this point onwards. For brevity, we will omit it from the following examples.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Closing and throwing exceptions
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike regular generators, which simply exit as soon as the input sequence
    is exhausted, coroutines generally employ infinite `while` loops, which means
    that they won''t be torn down the normal way. That''s why coroutines also support
    both `close` and `throw` methods, which will exit the function. The important
    thing here is not the closing but the possibility of adding a teardown method.
    Essentially, it is very comparable to how context wrappers function with an `__enter__`
    and `__exit__` method, but with coroutines in this case:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This generates the following output, which should be as expected—no strange
    behavior but simply two methods of exiting a coroutine:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Bidirectional pipelines
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous paragraphs, we saw pipelines; they process the output sequentially
    and one-way. However, there are cases where this is simply not enough—times where
    you need a pipe that not only sends values to the next pipe but also receives
    information back from the sub-pipe. Instead of always having a single list that
    is processed, we can maintain the state of the generator between executions this
    way. So, let''s start by converting the earlier pipelines to coroutines. First,
    the `lines.txt` file again:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, the coroutine pipeline. The functions are the same as before but using
    coroutines instead:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Given this example, you might be wondering why we are now printing the value
    instead of yielding it. Well! We can, but remember that generators freeze until
    a value is yielded. Let''s see what would happen if we simply `yield` the value
    instead of calling `print`. By default, you might be tempted to do this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Half of the values have disappeared now, so the question is, "Where did they
    go?" Notice that the second `yield` isn''t storing the results. That''s where
    the values are disappearing. We need to store those as well:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'But even this is far from optimal. We are essentially using coroutines to mimic
    the behavior of generators right now. Although it works, it''s just a tad silly
    and not all that clear. Let''s make a real pipeline this time where the coroutines
    send the data to the next coroutine (or coroutines) and actually show the power
    of coroutines by sending the results to multiple coroutines:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This makes the code much simpler and more readable, but more importantly, it
    shows how a single source can be split into multiple destinations. While this
    might not look too exciting, it most certainly is. If you look closely, you will
    see that the `tee` method splits the input into two different outputs, but both
    of those outputs write back to the same `print_` instance. This means that it's
    possible to route your data along whichever way is convenient for you while still
    having it end up at the same endpoint with no effort whatsoever.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Regardless, the example is still not that useful, as these functions still don't
    use all of the coroutine's power. The most important feature, a consistent state,
    is not really used in this case.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: The most important lesson to learn from these lines is that mixing generators
    and coroutines is not a good idea in most cases since it can have very strange
    side effects if used incorrectly. Even though both use the `yield` statement,
    they are significantly different creatures with different behavior. The next paragraph
    will show one of the few cases where mixing coroutines and generators can be useful.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Using the state
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we know how to write basic coroutines and which pitfalls we have to
    take care of, how about writing a function where remembering the state is required?
    That is, a function that always gives you the average value of all sent values.
    This is one of the few cases where it is still relatively safe and useful to combine
    the coroutine and generator syntax:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It still requires some extra logic to work properly though. To make sure we
    don''t divide by zero, we initialize the `count` to `1`. After that, we fetch
    our first item using `yield`, but we don''t send any data at that point because
    the first `yield` is the primer and is executed before we get the value. Once
    that''s all set up, we can easily yield the average value while summing. Not all
    that bad, but the pure coroutine version is slightly simpler to understand since
    we don''t have to worry about priming:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As simple as it should be, just keeping the count and the total value and simply
    send the new average for every new value.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Another nice example is `itertools.groupby`, also quite simple to do with coroutines.
    For comparison, we will once again show both the generator coroutine and the pure
    coroutine version:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As you can see, this function uses a few tricks. We store the previous `key`
    and `value` so that we can detect when the group (`key`) changes. And that is
    the second issue; we obviously cannot recognize a group until the group has changed,
    so only after the group has changed will the results be returned. This means that
    the last group will be sent only if a different group is sent after it, hence
    the `(None, None)`. And now, here is the pure coroutine version:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: While the functions are fairly similar, the pure coroutine version is, once
    again, quite a bit simpler. This is because we don't have to think about priming
    and values that might get lost.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter showed us how to create generators and both the strengths and weaknesses
    that they possess. Additionally, it should now be clear how to work around their
    limitations and the implications of doing so.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: While the paragraphs about coroutines should have provided some insights into
    what they are and how they can be used, not everything has been shown yet. We
    saw the constructs of both pure coroutines and coroutines that are generators
    at the same time, but they are still all synchronous. The coroutines allow sending
    the results to many other coroutines, therefore effectively executing many functions
    at once, but they can still freeze Python completely if an operation turns out
    to be blocking. That's where our next chapter will help.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然关于协程的段落应该已经提供了一些关于它们是什么以及如何使用它们的见解，但并非一切都已经展示出来。我们看到了纯协程和同时是生成器的协程的构造，但它们仍然是同步的。协程允许将结果发送给许多其他协程，因此可以有效地同时执行许多函数，但如果某个操作被阻塞，它们仍然可以完全冻结Python。这就是我们下一章将会帮助解决的问题。
- en: Python 3.5 introduced a few useful features, such as the `async` and `await`
    statements. These make it possible to make coroutines fully asynchronous and non-blocking,
    whereas this chapter uses the basic coroutine features that have been available
    since Python 2.5.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.5引入了一些有用的功能，比如`async`和`await`语句。这使得协程可以完全异步和非阻塞，而本章节使用的是自Python 2.5以来可用的基本协程功能。
- en: The next chapter will expand on the newer features, including the `asyncio`
    module. This module makes it almost simple to use coroutines for asynchronous
    I/O to endpoints such as TCP, UDP, files, and processes.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将扩展新功能，包括`asyncio`模块。这个模块使得使用协程进行异步I/O到诸如TCP、UDP、文件和进程等端点变得几乎简单。
