- en: Chapter 9. Patching a Bash Vulnerability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the bash vulnerability through Shellshock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shellshock's security issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The patch management system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying patches on the Linux systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the bash vulnerability through Shellshock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shellshock, or Bashdoor, is a vulnerability that's used in most versions of
    the Linux and Unix operating systems. It was discovered on September 12, 2014,
    and it affects all the distributions of Linux using a bash shell. The Shellshock
    vulnerability makes it possible to execute commands remotely using environment
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To understand Shellshock, we need a Linux system that uses a version of bash
    prior to 4.3, which is vulnerable to this bug.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will take a look at how to set up our system to understand
    the internal details of the Shellshock vulnerability:'
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to check the version of bash on the Linux system so that we
    can figure out whether our system is vulnerable to Shellshock. To check the version
    of bash, we run this command:![How to do it…](img/B04234_09_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bash versions from 4.3 and onwards have been reported to be vulnerable to Shellshock.
    For our example, we are using the Ubuntu 12.04 LTS desktop version. From the output
    shown in the preceding image, we can see that this system is vulnerable.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's check whether the vulnerability actually exists or not. To do so,
    we run this code:![How to do it…](img/B04234_09_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we run the preceding command, if the output has `shellshock` printed, the
    vulnerability is confirmed.
  prefs: []
  type: TYPE_NORMAL
- en: Let's understand the insights of the vulnerability. For this, we first need
    to understand the basics of the variables of the bash shell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we want to create a variable named `testvar` in bash and store a `shellshock`
    value in it, we run this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we wish to print the value of this variable, we use the `echo` command,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We shall open a child process of bash by running the `bash` command. Then, we
    again try to print the value of the `testvar` variable in the child process:![How
    to do it…](img/B04234_09_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can see that we don't get any output when we try to print the value in the
    child process.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we shall try to repeat the preceding process using the environment variables
    of bash. When we start a new shell session of bash, a few variables are available
    for use, and these are called **environment variables**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make our `testvar` variable an environment variable, we will export it. Once
    it's exported, we can use it in the child shell as well, as shown here:![How to
    do it…](img/B04234_09_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we have defined variables and then exported them, in the same way, we can
    define a function and export it in order to make it available in the child shell.
    The following steps show how you can define a function and export it:![How to
    do it…](img/B04234_09_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the preceding example, the `x` function has been defined, and it has been
    exported using the `-f` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s define a new variable, name it `testfunc`, and assign it a value,
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding variable can be accessed in the same way as a regular variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will export this variable to make it into an environment variable
    and then try to access it from the child shell, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B04234_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Something unexpected has taken place in the preceding result. In the parent
    shell, the variable is accessed as a normal variable. However, in the child shell,
    it gets interpreted as a function and executes the body of the function.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we shall terminate the definition of the function and then pass any arbitrary
    command to it.![How to do it…](img/B04234_09_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the preceding example, as soon as we start a new bash shell, the code that
    was defined outside the function is executed when bash is started.
  prefs: []
  type: TYPE_NORMAL
- en: This is the vulnerability in the bash shell.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We first check the version of bash running on our system. Then, we run a well-known
    code to confirm whether the Shellshock vulnerability exists.
  prefs: []
  type: TYPE_NORMAL
- en: To understand how the Shellshock vulnerability works, we create a variable in
    bash and then try to export it to the child shell and execute it there. Next,
    we try to create another variable and set its value as `''() { echo ''shellshock'';}''`.
    After doing this, when we export this variable to the child shell and execute
    it there, we see that it gets interpreted as a function in the child shell and
    executes the body of it.
  prefs: []
  type: TYPE_NORMAL
- en: This is what makes bash vulnerable to Shellshock, where specially crafted variables
    can be used to run any command in bash when it is launched.
  prefs: []
  type: TYPE_NORMAL
- en: Shellshock's security issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this era where almost everything is online, online security is a major concern.
    These days, a lot of web servers, web-connected devices, and services use Linux
    as their platform. Most versions of Linux use the Unix bash shell, so the *Shellshock*
    vulnerability can affect a huge number of websites and web servers.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous recipe, we took a look at the details of the Shellshock vulnerability.
    Now, we will understand how this bug can be exploited through SSH.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To exploit the Shellshock vulnerability, we need two systems. The first system
    will be used as a victim and should be vulnerable to Shellshock. In our case,
    we will use an Ubuntu system as the vulnerable system. The second system will
    be used as an attacker and can have any Linux version running on it. In our case,
    we will run Kali on the second system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The victim system will run the `openssH-server` package. It can be installed
    using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We will configure this system as a vulnerable SSH server to show how it can
    be exploited using the Shellshock bug.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To take a look at how the Shellshock bug can be used to exploit an SSH server,
    we need to first configure our SSH server as a vulnerable system. To do this,
    we will follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to add a new user account called `user1` on the SSH server
    system. We will also add `/home/user1` as its home directory and `/bin/bash` as
    its shell:![How to do it…](img/B04234_09_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the account has been added, we cross check by checking the `/etc/passwd`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a directory for `user1` in `/home` and grant the ownership of
    this directory to the `user1` account.![How to do it…](img/B04234_09_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we need to authenticate the attacker to log in to the SSH server using
    authorization keys. To do this, we will first generate these authorization keys
    on the attacker's system using this command:![How to do it…](img/B04234_09_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can see that the public/private keys have been generated.
  prefs: []
  type: TYPE_NORMAL
- en: After generating the authorization keys, we will send the public key to the
    remote SSH server over SFTP. First, we copy the `id_rsa.pub` public key file to
    `Desktop`, and then we run the command to connect to the SSH server using SFTP.![How
    to do it…](img/B04234_09_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When connected, we transfer the file using the `put` command.
  prefs: []
  type: TYPE_NORMAL
- en: On the victim SSH server system, we create a`.ssh` directory inside `/home/user1/`,
    and then we write the content of the `id_rsa.pub` file to `authorized_keys` inside
    the `/home/user1/.ssh/` directory:![How to do it…](img/B04234_09_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After this, we edit the configuration file of SSH, `etc/ssh/sshd_config`, and
    enable the `PublicKeyAuthentication` variable. We also check whether `AuthorizedKeysFile`
    has been specified correctly:![How to do it…](img/B04234_09_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the preceding steps are successfully completed, we can try to log in to
    the SSH server from the attacker system to check whether we are prompted for a
    password or not:![How to do it…](img/B04234_09_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we will create a basic script, which will display the **restricted** message
    if a user tries to pass the `date` command as an argument. However, if anything
    other than `date` is passed, it will get executed. We will name this script `sample.sh`:![How
    to do it…](img/B04234_09_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the script is created, we run this command to give executable permissions
    to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: After this, we use the `command` option in the `authorized_keys` file to run
    our `sample.sh` script by adding the path of the script, as shown here:![How to
    do it…](img/B04234_09_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Making the preceding changes in the `authorized_keys` file in order to restrict
    a user from executing a predefined set of commands will make the Public key authentication
    vulnerable.
  prefs: []
  type: TYPE_NORMAL
- en: Now, from the attacker's system, try connecting to the victim's system over
    SSH while passing `date` as the argument.![How to do it…](img/B04234_09_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can see the **restricted** message is displayed because of the script that
    we added to the `authorized_keys` file.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we try to pass our Shellshock exploit as an argument, as shown here:![How
    to do it…](img/B04234_09_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can see that even though we have restricted the `date` command in the script,
    it gets executed this time, and we get the output of the `date` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how to use the Shellshock vulnerability to compromise
    an Apache server, which runs any script that can trigger the bash shell with environment
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If Apache is not already installed on the victim''s system, we install it first
    using this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, we launch Apache server using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Next, we move to the `/usr/lib/cgi-bin/` path and create an `example.sh` script
    with the following code in it in order to display some HTML output:![How to do
    it…](img/B04234_09_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We then make it executable by running this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: From the attacker's system, we try to access the `example.sh` file remotely
    using a command-line tool called **curl**:![How to do it…](img/B04234_09_20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We get the output of the script as expected, which is `Example Page`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s send a malicious request to the server using curl to print the
    content of the `/etc/passwd` file of the victim''s system by running this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it…](img/B04234_09_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can see the output in the attacker's system, showing us how the victim's
    system can be remotely accessed using the Shellshock vulnerability. In the preceding
    command, `() { :;} ;` signifies a variable that looks like a function. In this
    code, the function is a single `:`, which does nothing and is only a simple command.
  prefs: []
  type: TYPE_NORMAL
- en: We try another command, as shown here, to take a look at the content of the
    current directory of the victim's system:![How to do it…](img/B04234_09_22.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We see the content of the `root` directory of the victim's system in the preceding
    output.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On our SSH server system, we create a new user account and assign the bash shell
    to it as its default shell. We also create a directory for this new user account
    in `/home` and assign its ownership to this account.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we configure our SSH server system to authenticate another system, connecting
    to it using authorization keys.
  prefs: []
  type: TYPE_NORMAL
- en: We then create a bash script to restrict a particular command, such as `date`,
    and add this script path to `authorized_keys` using the command option.
  prefs: []
  type: TYPE_NORMAL
- en: After this, when we try to connect to the SSH server from the other system whose
    authorization keys were configured earlier, we'll notice that if we pass the `date`
    command as an argument when connecting, the command gets restricted.
  prefs: []
  type: TYPE_NORMAL
- en: However, when the same `date` command is passed with the Shellshock exploit,
    we see the output of the `date` command, thus showing us how Shellshock can be
    used to exploit the SSH server.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we exploit the Apache server by creating a sample script and placing
    it in the `/usr/lib/cgi-bin` directory of the Apache system.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we try to access this script from the other system using the curl tool.
  prefs: []
  type: TYPE_NORMAL
- en: You'll notice that if we pass a **Shellshock exploit** when accessing the script
    through curl, we are able to run our commands on the Apache server remotely.
  prefs: []
  type: TYPE_NORMAL
- en: The patch management system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In present computing scenarios, vulnerability and patch management are part
    of a never-ending cycle. When a computer is attacked due to a known vulnerability
    for the purpose of being exploited, the patch for such a vulnerability already
    exists; however, it has not been implemented properly on the system, thus causing
    the attack.
  prefs: []
  type: TYPE_NORMAL
- en: As a system administrator, we have to know which patch needs to be installed
    and which one should be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since patch management can be done using the inbuilt tools of Linux, no specific
    settings need to be configured before performing the steps.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The easiest and most efficient way to keep our system updated is using Update
    Manager, which is built into the Linux system. Here, we will explore the workings
    of Update Manager in the Ubuntu system:'
  prefs: []
  type: TYPE_NORMAL
- en: To open the graphical version of **Update Manager** in Ubuntu, click on **Superkey**,
    which is on the left-hand side in the toolbar, and then type **update**. Here,
    we can see **Update Manager**:![How to do it…](img/B04234_09_23.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we open **Update Manager**, the following dialog box will appear, showing
    you the different security updates available for installation:![How to do it…](img/B04234_09_24.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the updates you want to install, and click on **Install Updates** to
    proceed.
  prefs: []
  type: TYPE_NORMAL
- en: In the same window, we have the **Settings** button in the bottom-left. When
    we click on it, a new **Software Sources** window will appear, which has more
    options to configure **Update Manager**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first tab reads **Ubuntu Software**, and it displays a list of repositories
    needed to download updates. We choose the options from the list as per our requirements:![How
    to do it…](img/B04234_09_25.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we click on the **Download from** option, we get an option to change the
    repository server that's used for the purposes of downloading. This option is
    useful in case we have any problem connecting to the currently selected server
    or the server is slow.![How to do it…](img/B04234_09_26.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the drop-down list, when we select the **Other...** option, we get a list
    to select the server we need, as shown in the following image:![How to do it…](img/B04234_09_27.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next **Other Software** tab is used to add partner repositories of Canonical:![How
    to do it…](img/B04234_09_28.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can choose any option from the list shown in the preceding image, and click
    on **Edit** to make changes to the repository details, as shown here:![How to
    do it…](img/B04234_09_29.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Updates** tab is used to define how and when the Ubuntu system receives
    updates:![How to do it…](img/B04234_09_30.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Authentication** tab contains details about the authentication keys of
    the software providers as obtained from the maintainer of the software repositories:![How
    to do it…](img/B04234_09_31.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last tab is **Statistics**, which is available for users who would like
    to anonymously provide data to the Ubuntu developer project. This information
    helps a developer increase the performance and improve the experience of the software.![How
    to do it…](img/B04234_09_32.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After making changes under any of these tabs, when we click on **Close**, we
    are prompted to confirm whether the new updates should be shown in the list or
    not. Click on **Reload** or **Close**:![How to do it…](img/B04234_09_33.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we want to check the list of locations from which Update Manager retrieves
    all the packages, we can check the content of the `/etc/apt/sources.list` file.
    We will then get this result:![How to do it…](img/B04234_09_34.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To update our Linux system, we use the built-in Update Manager as per the Linux
    distribution.
  prefs: []
  type: TYPE_NORMAL
- en: In the update manager, we either install all the updates available, or else,
    we configure it as per our requirements using the **Settings** window.
  prefs: []
  type: TYPE_NORMAL
- en: In the **Settings** window, we have option to display a list of repositories
    from where the updates can be downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: The second tab in the **Settings** window lets us add the third-party partner
    repositories of Canonical.
  prefs: []
  type: TYPE_NORMAL
- en: Using the next tab, we can specify when and what kind of updates should be downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: We also check the authentication keys of the software providers using the settings
    window.
  prefs: []
  type: TYPE_NORMAL
- en: The last tab, **Statistics**, helps send data to Ubuntu project developers in
    order to improve the performance of the software.
  prefs: []
  type: TYPE_NORMAL
- en: Applying patches on the Linux systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever a security vulnerability is found in any software, a security patch
    is released for the software so that the bug can be fixed. Normally, we use Update
    Manager, which is built into Linux, to apply security updates. However, for software
    that is installed by compiling source code, Update Manager may not be as helpful.
  prefs: []
  type: TYPE_NORMAL
- en: For such situations, we can apply the patch file to the original software's
    source code and then recompile the software.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we will use the built-in commands of Linux to create and apply a patch,
    nothing needs to be done before starting the following steps. We will be creating
    a sample program in C to understand the process of creating a patch file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will take a look at how to create a patch for a program
    using the `diff` command, and then we will apply the patch using the `patch` command.
  prefs: []
  type: TYPE_NORMAL
- en: The first step will be to create a simple C program, called `example.c`, to
    print `This is an example`, as shown here:![How to do it...](img/B04234_09_35.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we will create a copy of `example.c` and name it `example_new.c`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we edit the new `example_new.c` file to add a few extra lines of code
    to it, as shown here:![How to do it...](img/B04234_09_36.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, `example_new.c` can be considered as the updated version of `example.c`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will create a patch file and name it `example.patch` using the `diff` command:![How
    to do it...](img/B04234_09_37.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we check the content of the patch file, we get this output:![How to do it...](img/B04234_09_38.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before applying the patch, we can back up the original file using the `-b` option.![How
    to do it...](img/B04234_09_39.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will notice that a new `example.c.orig` file has been created, which is
    the backup file.
  prefs: []
  type: TYPE_NORMAL
- en: Before performing the actual patching, we can dry run the patch file to check
    whether we get any errors or not. To do this, we run this command:![How to do
    it...](img/B04234_09_40.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we don't get any error message, it means the patch file can be now run on
    the original file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will run the following command to apply the patch to the original file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: After applying the patch, if we now check the content of the `example.c` program,
    we will see that it has been updated with some extra lines of code, as written
    in `example_new.c`:![How to do it...](img/B04234_09_41.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the patch has been applied to the original file, if we wish to reverse
    it, this can be done using the `-R` option:![How to do it...](img/B04234_09_42.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can see the difference in the size of the file after patching and then reversing
    it.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We first create a sample C program. Then, we create its copy, and add few more
    lines of code to make it the updated version. After this, we create a patch file
    using the `diff` command. Before applying the patch, we check it for any errors
    by doing a dry run.
  prefs: []
  type: TYPE_NORMAL
- en: If we get no errors, we apply the patch using the patch command. Now, the original
    file will have the same content as the updated version file.
  prefs: []
  type: TYPE_NORMAL
- en: We can also reverse the patch using the `-R` option.
  prefs: []
  type: TYPE_NORMAL
