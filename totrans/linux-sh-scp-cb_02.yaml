- en: Chapter 2. Have a Good Command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Concatenating with cat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recording and playback of terminal sessions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding files and file listing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command output as argument to a command (xargs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Translating with tr
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checksum and verification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting, unique and duplicates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Temporary file naming and random numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Splitting files and data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slicing filenames based on extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Renaming files in bulk with rename and mv
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spell check and dictionary manipulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating interactive input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Commands are beautiful components of UNIX-like systems. They help us achieve
    many tasks making our work easier. When you practise the use of commands everywhere,
    you will love it. Many circumstances make you say "wow!". Once you've had a chance
    to try some of the commands that Linux offers you to make your life easier and
    more productive, you'll wonder how you did without using them before. Some of
    my personal favorite commands are `grep`, `awk`, `sed` , and `find` .
  prefs: []
  type: TYPE_NORMAL
- en: Using the UNIX/Linux command line is an art. You will get better at using it
    as you practice and gain experience. This chapter will introduce you to some of
    the most interesting and useful commands.
  prefs: []
  type: TYPE_NORMAL
- en: Concatenating with cat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`cat` is one of the first commands which a command line warrior must learn.
    `cat` is a beautiful and simple command. It is usually used to read, display,
    or concatenate the contents of a file, but `cat` is capable of more than just
    that.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We scratch our heads when we need to combine standard input data as well as
    data from a file using a single-line command. The regular way of combining `stdin`
    data as well as file data is to redirect `stdin` to a file and then append two
    files. But we can use the `cat` command to do it easily in a single invocation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `cat` command is a very simple command that is used very frequently in daily
    life. `cat` stands for concatenate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general syntax of `cat` for reading a file''s contents is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This command outputs concatenated data from the files with file names provided
    as command-line arguments. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a lot of features that come along with `cat`. Let's walk through several
    usage techniques that are possible with `cat`.
  prefs: []
  type: TYPE_NORMAL
- en: The `cat` command not only can read from files and concatenate the data, but
    also can read the input from the standard input.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to read from the standard input, use a pipe operator as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OUTPUT_FROM_SOME COMMANDS | cat`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can concatenate content from input files along with standard
    input using `cat`. Combine `stdin` and data from another file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this code `-` acts as filename for `stdin` text.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `cat` command has few other options for viewing files. Let's go through
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Squeezing blank lines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes many empty lines in text need to be squeezed into one to make it
    readable or for some other purpose. Squeeze adjacent blank lines in a text file
    by using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternately, we can remove all blank lines by using `tr` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the above usage of `tr`, it squeezes adjacent '`\n'` characters into a single
    '`\n'` (newline character).
  prefs: []
  type: TYPE_NORMAL
- en: Displaying tabs as ^I
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is hard to distinguish tabs and repeated space characters. While writing
    programs in languages like Python, it keeps special meaning for tabs and spaces
    for indentation purposes. They are treated differently. Therefore, the use of
    tab instead of spaces causes problems in indentation. It may become difficult
    to track where the misplacement of the tab or space occurred by looking through
    a text editor. `cat` has a feature that can highlight tabs. This is very helpful
    in debugging indentation errors. Use the `–T` option with `cat` to highlight tab
    characters as ^I. An example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Line numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using the `–n` flag for the `cat` command will output each line with a line
    number prefixed. It is to be noted that the `cat` command never changes a file;
    instead it produces an output on `stdout` with modifications to input according
    to the options provided. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Recording and playback of terminal sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you need to show somebody how to do something in the terminal or you need
    to prepare a tutorial on how to do something through command line, you would normally
    type the commands manually and show them. Or you could record a screencast video
    and playback the video to them. What if we can record the order and timing of
    the commands that we typed before and replay these commands again so that others
    can watch as if they were typing? The output of the commands gets displayed on
    the terminal until the playback is complete. Sounds interesting? It can be done
    using the commands `script` and `scriptreplay`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`script` and `scriptreplay` commands are available in most of the GNU/Linux
    distributions. Recording the terminal sessions to a file will be interesting.
    You can create tutorials of command-line hacks and tricks to achieve some task
    by recording the terminal sessions. You can also share the recorded files for
    others to playback and see how to perform a particular task using the command
    line.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can start recording the terminal session as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Two configuration files are passed to the `script` command as arguments. One
    file is for storing timing information (`timing.log`) at which each of the commands
    are run, whereas the other file (`output.session`) is used for storing command
    output. The `-t` flag is used to dump timing data to `stderr`. `2>` is used to
    redirect `stderr` to `timing.log`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using the two files, `timing.log` (stores timing information) and `output.session`
    (stores command output information), we can replay the sequence of command execution
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Usually, we record the desktop video to prepare tutorials. However, videos require
    good amount of storage. But a terminal script file is just a text file. Therefore,
    it always has a file size only in the order of Kilobytes.
  prefs: []
  type: TYPE_NORMAL
- en: You can share the files `timing.log` and `output.session` with anyone who wants
    to replay a terminal session in their terminal.
  prefs: []
  type: TYPE_NORMAL
- en: The `script` command can also be used to set up a terminal session that can
    be broadcasted to multiple users. It is a very interesting experience. Let's see
    how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Open two terminals, Terminal1 and Terminal2.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Terminal1 enter the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In Terminal2 enter the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Go back to Terminal1 and enter the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When you need to end the session, type `exit` and press *Return*. It will show
    the message "Script done, file is scriptfifo".
  prefs: []
  type: TYPE_NORMAL
- en: Now Terminal1 is the broadcaster and Terminal2 is the receiver.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you type anything in real-time on Terminal1, it will be played on Terminal2
    or any terminal that supplies the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This method can be used when handling a tutorial session for many users in a
    computer lab or over the Internet. It will save bandwidth as well as provide a
    real-time experience.
  prefs: []
  type: TYPE_NORMAL
- en: Finding files and file listing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`find` is one of the great utilities in the UNIX/Linux command-line toolbox.
    It is a very useful command for shell scripts, but most people do not use it effectively
    due to the lack of understanding. This recipe deals with most of the use cases
    of `find` and how it can be used to solve problems of different criterions.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `find` command uses the following strategy: `find` descends through a hierarchy
    of files, matches the files that meet specified criteria, and performs some actions.
    Let''s go through different use cases of find and the basic usages.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to list all the files and folders from the current directory to the
    descending child directories, use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`base_path` can be any location from which the `find` should start descending
    (for example, `/home/slynux/`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`.` specifies current directory and `..` specifies the parent directory. This
    convention is followed throughout the UNIX file system.'
  prefs: []
  type: TYPE_NORMAL
- en: The `-print` argument specifies to print the names (path) of the matching files.
    When `-print` is used `'\n'` will be the delimiting character for separating each
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The `-print0` argument specifies each matching file name printed with the delimiting
    character `'\0'`. This is useful when a filename contains a space character.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe we have learned the usage of the most commonly-used `find` command
    with an example. The `find` command is a powerful command-line tool and it is
    armed with a variety of interesting options. Let's walk through some of these
    different options of the `find` command.
  prefs: []
  type: TYPE_NORMAL
- en: Search based on file name or regular expression match
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `-name` argument specifies a matching string for the filename. We can pass
    wildcards as its argument text. `*.txt` matches all the filenames ending with
    `.txt` and prints them. The `–print` option prints the filenames or file paths
    in the terminal that matches the conditions (for example, `–name`) given as options
    to the `find` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `find` command has an option `–iname` (ignore case), which is similar to
    `-name`. `–iname` matches the name ignoring the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to match either of the multiple criterions, we can use OR conditions
    as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The previous code will print all of the `.txt` and `.pdf` files, since the `find`
    command matches both `.txt` and `.pdf` files. `\(` and `\)` is used to treat `-name
    "*.txt" -o -name "*.pdf"` as a single unit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-path` argument can be used to match the file path for files that match
    the wildcards. `-name` always matches using the given filename. However, `-path`
    matches the file path as a whole. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `-regex` argument is similar to `-path`, but `-regex` matches the file paths
    based on regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regular expressions are an advanced form of wildcard matching. It enables to
    specify a text with patterns. By using the patterns, we can make matches to the
    text and print them. A typical example of text matching using regular expressions
    is: parsing all e-mail addresses from a given pool of text. An e-mail address
    takes the form `name@host.root`. So, it can be generalized as `[a-z0-9]+@[a-z0-9]+.[a-z0-9]+`.
    The `+` signifies that the previous class of characters can occur one or more
    times, repeatedly, in the characters that follow.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command matches `.py` or `.sh` files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, using `-iregex` ignores the case for the regular expressions that
    are available. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Negating arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`find` can also take negation of arguments using "!". For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The above `find` construct matches all the file names, as long as the name
    does not end with `.txt`. The following example shows the result of the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Search based on the directory depth
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the `find` command is used it recursively walks through all the subdirectories
    as much as possible until it reaches the leaf of the subdirectory tree. We can
    restrict the depth to which the `find` command traverses using some depth parameters
    given to the find. `-maxdepth` and `-mindepth` are the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: In most of the cases, we need to search only in the current directory. It should
    not further descend into the subdirectories from the current directory. In such
    cases, we can restrict the depth to which the `find` command should descend using
    depth parameters. In order to restrict `find` from descending into the subdirectories
    from the current directory, the depth can be set as 1\. When we need to descend
    to two levels, the depth is set as 2, and so on for the rest of the levels.
  prefs: []
  type: TYPE_NORMAL
- en: 'For specifying the maximum depth we use the `–maxdepth` level parameter. Similarly,
    we can also specify the minimum level at which the descending should start. If
    we want to start searching from the second level onwards, we can set the minimum
    depth using the `–mindepth` level parameter. Restrict the `find` command to descend
    to a maximum depth of 1, by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This command lists all the regular files only from the current directory. If
    there are subdirectories, they are not printed or traversed. Similarly, `-maxdepth
    2` traverses up to at most two descending levels of subdirectories.
  prefs: []
  type: TYPE_NORMAL
- en: '`-mindepth` is similar to `–maxdepth`, but it sets the least depth level for
    the `find` traversal. It can be used to find and print the files that are located
    with a minimum level of depth from the base path. For example, to print all the
    files that are at least two subdirectories distant from the current directory
    use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Even if there are files in the current directory or `dir1` and `dir3`, it will
    not be printed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`-maxdepth` and `–mindepth` should be specified as the third argument to the
    find. If they are specified as the fourth or further arguments, it may affect
    the efficiency of the find as it has to do unnecessary checks (for example, if
    `–maxdepth` is specified as the fourth argument and `–type` as the third argument,
    the `find` command first finds out all the files having the specified `–type`
    and then finds all of the matched files having the specified depth. However, if
    the depth were specified as the third argument and `–type` as the fourth, `find`
    could collect all the files having at most the specified depth and then check
    for the file type, which is the most efficient way of searching.'
  prefs: []
  type: TYPE_NORMAL
- en: Search based on file type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: UNIX-like operating systems consider every object as a file. There are different
    kinds of files such as regular file, directory, character devices, block devices,
    symlinks, hardlinks, sockets, FIFO, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The file search can be filtered out using the `-type` option. By using `–type`,
    we can specify to the `find` command that it should only match files having a
    specified type.
  prefs: []
  type: TYPE_NORMAL
- en: 'List only directories including descendants as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'It is hard to list directories and files separately. But `find` helps to do
    it. List only regular files as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'List only symbolic links as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `type` arguments from the following table to properly match
    the required file type:'
  prefs: []
  type: TYPE_NORMAL
- en: '| File type | Type argument |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Regular file | `f` |'
  prefs: []
  type: TYPE_TB
- en: '| Symbolic link | `l` |'
  prefs: []
  type: TYPE_TB
- en: '| Directory | `d` |'
  prefs: []
  type: TYPE_TB
- en: '| Character special device | `c` |'
  prefs: []
  type: TYPE_TB
- en: '| Block device | `b` |'
  prefs: []
  type: TYPE_TB
- en: '| Socket | `s` |'
  prefs: []
  type: TYPE_TB
- en: '| Fifo | `p` |'
  prefs: []
  type: TYPE_TB
- en: Search on up file times
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'UNIX/Linux file systems have three types of timestamp on each file. They are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Access time** (-`atime`): This is the last timestamp of when the file was
    accessed by some user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modification time** (-`mtime`): This is the last timestamp of when the file
    content was modified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Change time** (-`ctime`): This is the last timestamp of when the metadata
    for a file (such as permissions or ownership) was modified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is nothing called creation time in UNIX.
  prefs: []
  type: TYPE_NORMAL
- en: '`-atime`, `-mtime` , `-ctime` are the time parameter options available with
    `find`. They can be specified with integer values in "number of days". These integer
    values are often attached with `-` or + signs. The `-` sign implies less than
    whereas the `+` implies greater than. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Print all the files that were accessed within the last 7 days as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Print all the files that are having access time exactly 7 days old as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Print all the files that are having access time older than 7 days as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, we can use the `–mtime` parameter for search files based on modification
    time and `-ctime` for search based on change time.
  prefs: []
  type: TYPE_NORMAL
- en: '`-atime`, `-mtime`, and `–ctime` are time-based parameters that use the time
    metric in days. There are some other time-based parameters that use the time metric
    in minutes. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-amin` (access time)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-mmin` (modification time)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-cmin` (change time)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to print all the files that are having access time older than seven
    minutes, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Another nice feature available with `find` is the `–newer` parameter. By using
    `-newer`, we can specify a reference file to compare with the timestamp. We can
    find all the files that are newer (older modification time) than the specified
    file with the `–newer` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, find all the files that are having a modification time greater
    than that of the modification time of a given `file.txt` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Timestamp manipulation flags for the `find` command are very useful for writing
    system backup and maintenance scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Search based on file size
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Based on the file sizes of the files, a search can be performed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of `k` we can use different size units as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`b` – 512 byte blocks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`c` – bytes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`w` – two byte words'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`k` – Kilobyte'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`M` – Megabyte'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`G` – Gigabyte'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting based on the file matches
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `-delete` flag can be used to remove files that are matched by `find`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove all the `.swp` files from the current directory as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Match based on the file permissions and ownership
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is possible to match files based on the file permissions. We can list out
    the files having specified file permission as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'As an example usage case, we can consider the case of Apache web server. The
    PHP files in the web server require proper permissions to execute. We can find
    out the PHP files that are not having proper execute permissions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We can also search files based on ownership of the files. The files owned by
    a specific user can be found out using the `-user USER` option.
  prefs: []
  type: TYPE_NORMAL
- en: The `USER` argument can be a username or UID.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to print the list of all files owned by the user slynux, you can
    use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Executing commands or actions with find
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `find` command can be coupled with many of the other commands using the
    `-exec` option. `-exec` is one of the most powerful features that comes with `find`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how to use the –`exec` option.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the example in the previous section. We used `–perm` to find out the
    files that do not have proper permissions. Similarly, in the case where we need
    to change the ownership of all files owned by a certain user (for example, `root`)
    to another user (for example, `www-data` the default Apache user in the web server),
    we can find all the files owned by root by using the `–user` option and using
    `–exec` to perform ownership change operation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You must run the `find` command as root for performing ownership change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In this command, `{}` is a special string used with the `–exec` option. For
    each file match, `{}` will be replaced with the file name in place for `–exec`.
    For example, if the `find` command finds two files `test1.txt` and `test2.txt`
    with owner slynux, the find command will perform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This gets resolved to `chown slynux test1.txt` and `chown slynux test2.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another usage example is to concatenate all the C program files in a given
    directory and write it to a single file `all_c_files.txt`. We can use `find` to
    match all the C files recursively and use the `cat` command with the `-exec` flag
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '`-exec` is followed with any command. `{}` is a match. For every matched filename,
    `{}` is replaced with filename.'
  prefs: []
  type: TYPE_NORMAL
- en: To redirect the data from `find` to the `all_c_files.txt` file, we used the
    `>` operator instead of `>>` (append) because the entire output from the `find`
    command is a single data stream (`stdin`). `>>` is necessary only when multiple
    data streams are to be appended to a single file.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to copy all the `.txt` files that are older than 10 days to a
    directory `OLD`, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, the `find` command can be coupled with many other commands.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**-exec with multiple commands**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We cannot use multiple commands along with the `–exec` parameter. It accepts
    only a single command, but we can use a trick. Write multiple commands in a shell
    script (for example, `commands.sh`) and use it with `–exec` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`–exec ./commands.sh {} \;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`-exec` can be coupled with `printf` to produce a very useful output. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Skip specified directories from the find
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Skipping certain subdirectories for a performance improvement is sometimes
    required while doing a directory search and performing some action. For example,
    when programmers look for particular files on a development source tree, which
    is under a version control system such as Git, the source hierarchy will always
    contain the `.git` directory in each of the subdirectories (`.git` stores version
    control related information for every directory). Since version control related
    directories do not produce useful output, they should be excluded from the search.
    The technique of excluding files and directories from the search is known as pruning.
    It can be performed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The above command prints the name (path) of all the files that are not from
    the `.git` directories.
  prefs: []
  type: TYPE_NORMAL
- en: Here, `\( -name ".git" -prune \)` is the exclude portion, which specifies that
    the `.git` directory should be excluded and `\( -type f -print \)` specifies the
    action to be performed. The actions to be performed are placed in the second block
    `-type f –print` (the action specified here is to print the names and path of
    all the files).
  prefs: []
  type: TYPE_NORMAL
- en: Playing with xargs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We use pipes to redirect `stdout` (standard output) of a command to `stdin`
    (standard input) of another command. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: But, some of the commands accept data as command-line arguments rather than
    a data stream through `stdin` (standard input). In that case, we cannot use pipes
    to supply data through command-line arguments.
  prefs: []
  type: TYPE_NORMAL
- en: We should go for alternate methods. `xargs` is a command that is very helpful
    in handling standard input data to the command-line argument conversions. `xargs`
    can manipulate `stdin` and convert to command-line arguments for the specified
    command. Also `xargs` can convert any one line or multiple line text input into
    other formats, such as multiple lines (specified number of columns) or a single
    line and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: All the Bash hackers love one-line commands. One-liners are command sequences
    that are joined by using the pipe operator, but do not use the semi colon terminator
    (;) between the commands used. Crafting one-line commands makes tasks efficient
    and simpler to solve. It requires proper understanding and practise to formulate
    one-liners for solving text processing problems. `xargs` is one of the important
    components for building one-liner commands.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `xargs` command should always appear immediately after a pipe operator.
    `xargs` uses standard input as the primary data stream source. It uses `stdin`
    and executes another command by providing command-line arguments for that executing
    command using the stdin data source. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `xargs` command can supply arguments to a command by reformatting the data
    received through `stdin`.
  prefs: []
  type: TYPE_NORMAL
- en: '`xargs` can act as a substitute that can perform similar actions as the `-exec`
    argument in the case of the `find` command. Let''s see a variety of hacks that
    can be performed using the `xargs` command.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Converting multiple lines of input to a single line output:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Multiple line input can be converted simply by removing the new line character
    and replacing with the " " (space) character. ''`\n`'' is interpreted as a newline,
    which is the delimiter for the lines. By using `xargs`, we can ignore all the
    newlines with spaces so that multiple lines can be converted into a single line
    text as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '**Converting single line into multiple line output:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Given maximum no of arguments in a line `= n`, we can split any `stdin` (standard
    input) text into lines of n arguments each. An argument is a piece of string delimited
    by " " (space). Space is the default delimiter. A single line can be split into
    multiple lines as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `xargs` command is appropriate to be applied to many problem scenarios with
    its rich and simple options. Let's see how these options can be used wisely to
    solve problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use our own delimiter towards separating arguments. In order to
    specify a custom delimiter for input, use the `–d` option as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, `stdin` contains a string consisting of multiple 'X' characters.
    We can use 'X' as the input delimiter by using it with `–d`. Here we have explicitly
    specified X as the input delimiter, whereas in the default case `xargs` takes
    Internal Field Separator (space) as the input delimiter.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using `–n` along with the above command, we can split the input into multiple
    lines having two words each as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have learned how to format `stdin` to different output as arguments from
    the above examples. Now let's learn how to supply these formatted output as arguments
    to commands.
  prefs: []
  type: TYPE_NORMAL
- en: '**Passing formatted arguments to a command by reading stdin**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Write a small custom echo for better understanding of example usages with xargs
    to provide command arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'When arguments are passed to the `cecho.sh`, it will print the arguments terminated
    by the `#` character. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s have a look at a problem:'
  prefs: []
  type: TYPE_NORMAL
- en: 'I have a list of arguments in a file (one argument in each line) to be provided
    to a command (say `cecho.sh`). I need to provide arguments in two methods. In
    the first method, I need to provide one argument each for the command as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, alternately, I need to provide two or three arguments each for each execution
    of command. For two arguments each, it would be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second method, I need to provide all arguments at once to the command
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Run the above commands and note down the output before going through the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The above problems can be solved using `xargs`. We have the list of arguments
    in a file called `args.txt`. The contents are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'For the first problem, we can execute the command multiple times with one argument
    per execution, by using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'For executing a command with X arguments per each execution, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'For the second problem, we can execute the command at once with all the arguments,
    by using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above examples, we have supplied command-line arguments directly to
    a specific command (for example, `cecho.sh`). We could only supply the arguments
    from the `args.txt` file. However, in realtime, we may also need to add some constant
    parameter with the command (for example, `cecho.sh`) along with the arguments
    taken from `args.txt`. Consider the following example with the format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above command execution `arg1` is the only variable text. All others
    should remain constant. We should read arguments from a file (`args.txt`) and
    supply it as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: To provide a command execution sequence as shown, `xargs` has an option `–I`.
    By using `–I` we can specify a replacement string that will be replaced while
    `xargs` expands. When `–I` is used with `xargs`, it will execute as one command
    execution per argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '`-I {}` specifies the replacement string. For each of the arguments supplied
    for the command, the `{}` string will be replaced with arguments read through
    `stdin`. When used with `-I`, the command is executed like in a loop. When there
    are three arguments the command is executed three times along with the command
    `{}`. Each time `{}` is replaced with arguments one by one.'
  prefs: []
  type: TYPE_NORMAL
- en: Using xargs with find
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`xargs` and `find` are best friends. They can be combined to perform tasks
    easily. Usually, people combine them in a wrong way. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This is dangerous. It may sometimes cause removal of unnecessary files. Here,
    we cannot predict the delimiting character (whether it is `'\n'` or `' '`) for
    the output of the `find` command. Many of the filenames may contain a space character
    (' ') and hence `xargs` may misinterpret it as a delimiter (for example, "hell
    text.txt" is misinterpreted by `xargs` as "hell" and "text.txt").
  prefs: []
  type: TYPE_NORMAL
- en: Hence we must use `-print0` along with `find` to produce an output with delimited
    character null (`'\0'`)whenever we use the `find` output as the `xargs` input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use `find` to match and list of all the `.txt` files and remove them
    using `xargs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This removes all `.txt` files. `xargs -0` interprets that the delimiting character
    is `\0`.
  prefs: []
  type: TYPE_NORMAL
- en: Counting number of lines of C code in a source code directory over many C files.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is a task most programmers do, that is, counting all C program files for
    LOC (Lines of Code). The code for this task is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: While and subshell trick with stdin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`xargs` is restricted to provide arguments in limited ways to supply arguments.
    Also, xargs cannot supply arguments to multiple set of commands. For executing
    commands with collected arguments from standard input, we have a very flexible
    method. I call it a subshell hack. A subshell with a `while` loop can be used
    to read arguments and execute commands in a trickier way as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Here, by replacing `cat $arg` with any number of commands using a `while` loop,
    we can perform many command actions with same arguments. We can also pass the
    output to other commands without using pipes. Subshell `( )` tricks can be used
    in a variety of problem environments. When enclosed within subshell operators,
    it acts as a single unit with multiple commands inside.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: If `cmd1` is `cd /`, within the subshell, the path of the working directory
    changes. However, this change resides inside the subshell only. `cmd4` will not
    see the directory change.
  prefs: []
  type: TYPE_NORMAL
- en: Translating with tr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`tr` is a small and beautiful command in the UNIX command-warrior toolkit.
    It is one of the important commands frequently used to craft beautiful one-liner
    commands.'
  prefs: []
  type: TYPE_NORMAL
- en: '`tr` can be used to perform substitution of characters, deletion of the characters,
    and squeezing of repeated characters from the standard input. It is often called
    translate, since it can translate a set of characters to another set.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`tr` accepts input only through `stdin` (standard input). It cannot accept
    input through command-line arguments. It has the following invocation format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Input characters from `stdin` are mapped from `set1` to `set2` and the output
    is written to `stdout` (standard output). `set1` and `set2` are character classes
    or a set of characters. If the length of sets is unequal, `set2` is extended to
    the length of `set1` by repeating the last character, or else, if the length of
    `set2` is greater than that of `set1`, all the characters exceeding the length
    of `set1` are ignored from `set2`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to perform translation of characters in the input from uppercase to
    lowercase, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '`''A-Z''` and `''a-z''` are the sets. We can specify custom sets as needed
    by appending characters or character classes.'
  prefs: []
  type: TYPE_NORMAL
- en: '`''ABD-}''`, `''aA.,''`, `''a-ce-x''`, `''a-c0-9''`, and so on are valid sets.
    We can define sets easily. Instead of writing continuous character sequences,
    we can use the `''startchar-endchar''` format. It can also be combined with any
    other characters or character classes. If `startchar-endchar` are not a valid
    continuous character sequence, then they are taken as a set of three characters
    (for example, `startchar`, `-`, and `endchar`). You can also use special characters
    such as `''\t''`, `''\n''`, or any ASCII characters.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By using `tr` with the concept of sets, we can map characters from one set
    to another set easily. Let''s go through an example on how to use `tr` for encrypting
    and decrypting numeric characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Let's try another interesting example.
  prefs: []
  type: TYPE_NORMAL
- en: 'ROT13 is a well known encryption algorithm. In the ROT13 scheme, the same function
    is used to encrypt and decrypt text. The ROT13 scheme performs alphabetic rotation
    of characters for 13 characters. Let''s perform ROT13 using `tr` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'By sending the encrypted text again to the same ROT13 function, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '`tr` can be used to convert tab characters into space as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deleting characters using tr
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`tr` has an option `-d` to delete a set of characters that appear on `stdin`
    by using the specified set of characters to be deleted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Complementing character set
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can use a set complement to `set1` by using the `-c` flag. `-c [set]` is
    equivalent to specifying a set (complement-set) which contains complement characters
    of `[set]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The complement of `set1` means that it is the set having all the characters
    except for characters in `set1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best usage example is to delete all the characters from the input text
    except the ones specified in the complement set. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Here, the complement set is the set containing all numerals, the space character,
    and newline. All other characters are removed since `–d` is used with `tr`.
  prefs: []
  type: TYPE_NORMAL
- en: Squeezing characters with tr
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `tr` command is very helpful in many text processing contexts. Repeated
    continuous characters should be squeezed to a single character in many circumstances.
    Squeezing of whitespace is a frequently occurring task.
  prefs: []
  type: TYPE_NORMAL
- en: '`tr` provides the `–s` option to squeeze repeating characters from the input.
    It can be performed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use `tr` in a tricky way to add a given list of numbers from a file
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: How does this hack work?
  prefs: []
  type: TYPE_NORMAL
- en: Here, the `tr` command is used to replace `'\n'` with the `'+'` character, hence
    we form the string `"1+2+3+..5+",` but at the end of the string we have an extra
    `+` operator. In order to nullify the effect of the `+` operator, `0` is appended.
  prefs: []
  type: TYPE_NORMAL
- en: '`$[ operation ]` performs a numeric operation. Hence it forms the string as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: If we use a loop to perform addition by reading numbers from a file, it would
    take few lines of code. Here a one-liner does the trick. The skill of crafting
    one-liners is attained by practice.
  prefs: []
  type: TYPE_NORMAL
- en: Character classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`tr` can use different character classes as sets. The different classes are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`alnum`: Alphanumeric characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alpha`: Alphabetic characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cntrl`: Control (non-printing) characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`digit`: Numeric characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`graph`: Graphic characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lower`: Lower-case alphabetic characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print`: Printable characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`punct`: Punctuation characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`space`: Whitespace characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`upper`: Upper-case characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xdigit`: Hexadecimal characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can select the required classes and use them with as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Checksum and verification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Checksum programs are used to generate checksum key strings from the files and
    verify the integrity of the files later by using that checksum string. A file
    might be distributed over the network or any storage media to different destinations.
    Due to many reasons, there are chances for the file being corrupted due to a few
    bits missing during the data transfer. These errors happen most often while downloading
    the files from the Internet, transferring through the network, CD ROM damage,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, we need to know whether the received file is the correct one or not by
    applying some kind of test. The special key string that is used for this file
    integrity test is known as **checksum**.
  prefs: []
  type: TYPE_NORMAL
- en: We calculate the checksum for the original file as well as the received file.
    By comparing both of the checksums, we can verify whether the received file is
    the correct one or not. If the checksums (calculated from original file at the
    source location and the one calculated from destination) are equal, it means that
    we have received the correct file without causing any erroneous data loss during
    the data transfer, or else, the user has to repeat the data transfer and try the
    checksum comparison again.
  prefs: []
  type: TYPE_NORMAL
- en: Checksums are crucial while writing backup scripts or maintenance scripts that
    consist of transfer of files through the network. By using checksum verification,
    files corrupted during the data transfer over the network can be identified and
    those files can be resend again from the source to the destination. Thus the integrity
    of the data received can always be ensured.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most famous and widely-used checksum techniques are `md5sum` and `sha1sum`.
    They generate checksum strings by applying the corresponding algorithm to the
    file content. Let's see how can we generate a checksum and from a file and verify
    the integrity of a file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to compute the `md5sum`, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: An `md5sum` is a 32 character hexadecimal string, as given above.
  prefs: []
  type: TYPE_NORMAL
- en: 'We redirect the checksum output into a file and use that MD5 file for verification
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The syntax for `md5sum` checksum calculation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'When multiple files are used, the output will contain a checksum for each of
    the file having one checksum string per line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The integrity of a file can be verified by using the generated file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, alternately, if we need to check all the files using all `.md5` info available,
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: SHA1 is another commonly used checksum algorithm like md5sum. It generates a
    40-character hex code from a given input file. The command used for calculating
    a SHA1 string is `sha1sum`. Its usage is very similar to that of `md5sum`. Replace
    `md5sum` with `sha1sum` in all the commands mentioned previously in this recipe.
    Instead of `file_sum.md5`, change the output filename to `file_sum.sha1`.
  prefs: []
  type: TYPE_NORMAL
- en: Checksum verification is much useful to verify the integrity of files that we
    download from the Internet. The ISO images that we download from the Internet
    are usually much more prone to erroneous bits. Therefore, to check whether we
    received the file correctly, checksums are widely used. For the same file data
    the checksum program will always produce the same checksum string.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Checksum are also useful when used with a number of files. Let's see how to
    apply checksum to many files and verify correctness.
  prefs: []
  type: TYPE_NORMAL
- en: Checksum for directories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Checksums are calculated for files. Calculating the checksum for a directory
    would mean that we will need to calculate the checksums for all the files in the
    directory, recursively.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be achieved by the command `md5deep` or `sha1deep`. Install the package
    `md5deep` to make these commands available. An example of this command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternately, combine it with `find` to calculate checksums recursively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Sorting, unique and duplicates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sorting is a common task that we always encounter with text files. Hence, in
    text processing tasks, sort is very useful. `sort` commands help us to perform
    sort operations over text files and `stdin`. Most often, it can also be coupled
    with many other commands to produce the required output. `uniq` is another command
    that is often used along with a `sort` command. It helps to extract unique lines
    from a text or `stdin`. `sort` and `uniq` can be coupled to find duplicates. This
    recipe illustrates most of the use cases with `sort` and `uniq` commands.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `sort` command accepts input as filenames as well as from `stdin` (Standard
    input) and outputs the result by writing into `stdout`. The `uniq` command follows
    the same sequence of operation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can easily sort a given set of files (for example, `file1.txt` and `file2.txt`)
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to find the unique lines from a sorted file, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are numerous scenarios where `sort` and `uniq` commands can be used. Let's
    go through various options and usage techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'For numerical sort use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'To sort in reverse order use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'For sorting by months (in the order Jan, Feb, March) use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'A file can be tested whether sorted or not as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to merge two sorted files without sorting again, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sort according to the keys or columns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We use sort by column if we need to sort a text as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: We can sort this in many ways; currently it is numeric sorted by serial number
    (the first column). We can also sort by second column and third column.
  prefs: []
  type: TYPE_NORMAL
- en: '`-k` specifies the key by which the sort is to be performed. Key is the column
    number by which sort is to be done. `-r` specifies the sort command to sort in
    the reverse order. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Always be careful about the `-n` option for numeric sort. The sort command treats
    alphabetical sort and numeric sort differently. Hence, in order to specify numeric
    sort the `–n` option should be provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, by default, keys are columns in the text file. Columns are separated
    by space characters. But in certain circumstances, we will need to specify keys
    as a group of characters in the given character number range (for example, key1=
    character4-character8). In such cases where keys are to be specified explicitly
    as a range of characters, we can specify the keys as ranges with the character
    position at key starts and key ends as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted characters are to be used as numeric keys. In order to extract
    them, use their start-pos and end-pos as the key format.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use the first character as the key, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Make the sort''s output xargs compatible with `\0` terminator, by using the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes the text may contain unnecessary extraneous characters like spaces.
    To sort by ignoring them in dictionary order by ignoring punctuations and folds,
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: The option `–b` is used to ignore leading blanks from the file and the `–d`
    option is used to specify sort in the dictionary order.
  prefs: []
  type: TYPE_NORMAL
- en: uniq
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`uniq` is a command used to find out the unique lines from the given input
    (`stdin` or from filename as command argument) by eliminating the duplicates.
    It can also be used to find out the duplicate lines from the input`. uniq` can
    be applied only for sorted data input. Hence, `uniq` is to be used always along
    with the `sort` command using pipe or using a sorted file as input.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can produce the unique lines (unique lines means that all lines in the
    input are printed, but the duplicate lines are printed only once) from the given
    input data as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Display only unique lines (the lines which are not repeated or duplicate in
    input file) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to count how many times each of the line appears in the file, use
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Find duplicate lines in the file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: To specify keys, we can use the combination of `-s` and `-w` arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '`-s` specifies the number for the first `N` characters to be skipped'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-w` specifies the maximum number of characters to be compared'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This comparison key is used as the index for the `uniq` operation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to use the highlighted characters as the uniqueness key. This is used
    to ignore the first 2 characters (`-s 2`) and the max number of comparison characters
    is specified using the `–w` option `(-w 2)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: While we use output from one command as input to the xargs command, it is always
    preferable to use a zero byte terminator for each of the lines of the output,
    which acts as source for `xargs`. While using the `uniq` commands output as the
    source for `xargs`, we should use a zero terminated output. If a zero byte terminator
    is not used, space characters are by default taken as delimiter to split the arguments
    in the `xargs` command. For example, a line with text "this is a line" from `stdin`
    will be taken as four separate arguments by the `xargs`. But, actually, it is
    a single line. When a zero byte terminator is used, `\0` is used as the delimiter
    character and hence, a single line including space is interpreted as a single
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Zero byte terminated output can be generated from the `uniq` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command removes all the files, with filenames read from `files.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: If multiple line entries of filenames exist in the file, the `uniq` command
    writes the filename only once to `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: String pattern generation with uniq
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is an interesting question for you: We have a string containing repeated
    characters. How can we find the number of times each of the character appears
    in the string and output a string in the following format?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Input: ahebhaaa'
  prefs: []
  type: TYPE_NORMAL
- en: 'Output: 4a1b1e2h'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the characters is repeated once, and each of them is prefixed with
    the number of times they appear in the string. We can solve this using `uniq`
    and `sort` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above code, we can split each of the piped commands as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Append a newline character to each of the characters so that only one character
    appears in one line. This is done to make the characters sortable by using the
    `sort` command. The `sort` command can take only items delimited by newline.
  prefs: []
  type: TYPE_NORMAL
- en: '`sed ''/^$/d''`: Here the last character is replaced as character `+\n`. Hence
    an extra newline is formed and it will form a blank line at the end. This command
    removes the blank line from the end.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sort`: Since each character appears in each line, it can be sorted so that
    it can serve as input to uniq.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uniq –c`: This command prints each of the line with how many times they got
    repeated(count).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tr –d '' \n''`: This removes the space characters and newline characters from
    the input so that output can be produced in the given format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Temporary file naming and random numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While writing shell scripts, we use often require to store temporary data. The
    most suitable location to store temporary data is `/tmp` (which will be cleaned
    out by the system on reboot). We can use two methods to generate standard filenames
    for temporary data.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`tempfile` is not seen in non-Debian Linux distributions. The `tempfile` command
    comes shipped with Debian-based distributions, such as Ubuntu, Debian, and many
    more.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code will assign a temporary filename to the variable `temp_file`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Use `echo $temp_file` to print the temporary file name in the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: The output will look similar to `/tmp/fileaZWm8Y`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes we may use a filename with a random number attached to it as a temporary
    filename. This can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: The `$RANDOM` environment variable always returns a random number.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Instead of using the `tempfile` command, we can also use our own temporary.
    Most experienced UNIX programmers use the following conventions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: The `.$$` suffix is attached. `$$` is expanded as the process ID of the current
    script upon execution.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting files and data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Splitting of files into many smaller pieces becomes essential in certain situations.
    Earlier, when memory was limited with devices like floppy disks, it was crucial
    to split files into smaller file sizes to transfer data in many disks. However,
    nowadays we split files for other purposes, such as readability, for generating
    logs, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Generate a test file (`data.file`) of 100kb as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: The above command creates a file filled with zeros with the size of 100kb.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can split files into smaller files by specifying the split size as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'It will split `data.file` into many files, each of a 10k chunk. The chunks
    will be named in the manner `xab`, `xac`, `xad`, and so on. This means it will
    have alphabetic suffixes. To use the numeric suffixes, use an additional `-d`
    argument. It is also possible to specify a suffix length using `-a length` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Instead of the `k` (kilobyte) suffix we can use `M` for MB, `G` for GB, `c`
    for byte, `w` for word, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `split` command has more options. Let's go through them.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying filename prefix for the split files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The above split files have a filename prefix "x". We can also use our own filename
    prefix by providing a prefix filename. The last command argument for the split
    command is `PREFIX`. It is in the format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the previous command with the prefix filename for split files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to split files based on number of lines in each split rather than
    chunk size, use `-l no_of_lines` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: There is another interesting utility called `csplit`. It can be used to split
    log file-based specified conditions and string match options. Let's see how to
    work with it.
  prefs: []
  type: TYPE_NORMAL
- en: '`csplit` is a variant of the `split` utility. The `split` utility can only
    split files based on chunk size or based on the number of lines. `csplit` makes
    the split based on context based split. It can be used to split files based on
    existence of a certain word or text content.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the example log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'We may need to split the files into `server1.log`, `server2.log`, and `server3.log`
    from the contents for each `SERVER` in each file. This can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'The details of the command are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/SERVER/` is the line used to match a line by which the split is to be carried
    out.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/[REGEX]/` is the format. It copies from current line (first line) upto the
    matching line that contains `"SERVER"` excluding match line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{*}` is used to specify to repeat splitting based on match upto the end of
    the file. By using `{integer}`, we can specify no of times it is to be continued.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-s` is the flag to make the command silent rather than printing other messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-n` is used to specify the number of digits to be used as suffix. 01, 02,
    03, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-f` is used for specifying the filename prefix for split files ("server" is
    the prefix in the previous example).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-b` is used to specify the suffix format. `"%02d.log"` is similar to the `printf`
    argument format in C. Here the filename = prefix + suffix = `"server" + "%02d.log"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We remove `server00.log` since the first split file is an empty file (the match
    word is the first line of the file).
  prefs: []
  type: TYPE_NORMAL
- en: Slicing filenames based on extension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Several custom shell scripts perform manipulations based on file names. We may
    need to perform actions like renaming the files by preserving extension, converting
    files from one format to another (change the extension by preserving the name),
    extracting a portion of the file name, and so on. The shell comes with inbuilt
    functionalities for slicing filenames based on different conditions. Let's see
    how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The name from `name.extension` can be easily extracted by using the `%` operator.
    You can extract the name from `"sample.jpg"` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: The next task is to extract the extension of a file from its filename. The extension
    can be extracted using the `#` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extract `.jpg` from the a filename stored in variable `file_jpg` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: How it works..
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the first task, in order to extract the name from the file name in the format
    `name.extension` we have used the `%` operator.
  prefs: []
  type: TYPE_NORMAL
- en: '`${VAR%.*}` can be interpreted as:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the string match from the `$VARIABLE` for the wildcard pattern that appears
    to the right-hand side of % (.* in the previous example). Evaluating from the
    right to the left direction should make the wildcard match.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let `VAR=sample.jpg`. Therefore, the wildcard match for `.*` from right to left
    is `.jpg`. Thus it is removed from the `$VAR` string and the output will be "sample".
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%` is a non-greedy operation. It finds the minimal match for the wildcard
    from the right to left. There is an operator `%%`, which is similar to `%`. But
    it is greedy in nature. That means it matches the maximal string for the wildcard.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'By using the % operator, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be: `hack.fun.book`.'
  prefs: []
  type: TYPE_NORMAL
- en: The operator `%` performs a non-greedy match for `.*` from right to left (`.txt`).
  prefs: []
  type: TYPE_NORMAL
- en: 'By using the %% operator, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be: `hack`'
  prefs: []
  type: TYPE_NORMAL
- en: The `%%` operator matches greedy match for `.*` from right to left (.`fun.book.txt`).
  prefs: []
  type: TYPE_NORMAL
- en: In the second task, we have used the `#` operator to extract the extension from
    the filename. It is similar to `%`. But it evaluates from left to right.
  prefs: []
  type: TYPE_NORMAL
- en: '`${VAR#*.}` can be interpreted as:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the string match from the `$VARIABLE` for the wildcard pattern match
    appears right side to the `#` (`*.` in the above example). Evaluating from the
    left to right direction should make the wildcard match.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, as in the case of `%%`, we have another greedy operator for `#`,
    which is `##`.
  prefs: []
  type: TYPE_NORMAL
- en: It makes greedy matches by evaluating from left to right and removes the match
    string from the specified variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'By using the `#` operator, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be: `fun.book.txt`.'
  prefs: []
  type: TYPE_NORMAL
- en: The operator `#` performs a non-greedy match for `*.` from left to right (`hack.`).
  prefs: []
  type: TYPE_NORMAL
- en: 'By using the ## operator, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be: `txt`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The operator ## matches greedy match for *. from left to right (txt).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The ## operator is more preferred over the # operator to extract an extension
    from a filename since the filename may contain multiple ''.'' characters. Since
    ## makes greedy match, it always extract extensions only.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is practical example that can be used to extract different portions of
    a domain name, given URL="[www.google.com](http://www.google.com)":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Renaming and moving files in bulk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Renaming a number of files is one of the tasks we frequently come across. A
    simple example is, when you download photos from your digital camera to the computer
    you may delete unnecessary files and it causes discontinuous numbering of image
    files. Sometimes you many need to rename them with custom prefix and continuous
    numbering for filenames. We sometimes use third-party tools for performing rename
    operations. We can use Bash commands to perform a rename operation in a couple
    of seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Moving all the files having a particular substring in the filename (for example,
    same prefix for filenames) or with a specific file type to a given directory is
    another use case we frequently perform. Let's see how to write scripts to perform
    these kinds of operations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `rename` command helps to change file names using Perl regular expressions.
    By combining the commands `find`, `rename`, and `mv`, we can perform a lot of
    things.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The easiest way of renaming image files in the current directory to our own
    filename with a specific format is by using the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: The script renames all the `.jpg` and `.png` files in the current directory
    to new filenames in the format `image-1.jpg`, `image-2.jpg`, `image-3.jpg` , `image-4.png`,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the above rename script, we have used a `for` loop to iterate through the
    names of all files ending with a `.jpg` extension. The wildcard `*.jpg` and *`.png`
    are used to match all the JPEG and PNG files. We can do a small improvisation
    over the extension match. The `.jpg` wildcard matches only the extension in lowercase.
    However, we can make it case insensitive by replacing `.jpg` with `.[jJ][pP][gG]`.
    Hence it can match files like `file.jpg` as well as `file.JPG` or `file.Jpg`.
    In Bash, when characters are enclosed in `[]`, it means to match one character
    from the set of characters enclosed in `[]`.
  prefs: []
  type: TYPE_NORMAL
- en: '`for img in *.jpg *.png` in the above code will be expanded as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`for img in hack.jpg new.jpg next.jpg`'
  prefs: []
  type: TYPE_NORMAL
- en: We have initialized a variable `count=1` in order to keep track of the image
    number. The next step is to rename the file using the `mv` command. The new name
    of the file should be formulated for renaming. `${img##*.}` in the script parses
    the extension of the filename currently in the loop (see the *Slicing file names
    based on extension* recipe for interpretation of `${img##*.}`).
  prefs: []
  type: TYPE_NORMAL
- en: '`let count++` is used to increment the file number for each execution of loop.'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that error redirection (`stderr`) to `/dev/null` is done for the
    `mv` command using the `2>` operator. This is to stop the error messages being
    printed into the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Since we use `*.png` and `*.jpg`, if atleast one image for a wildcard match
    is not present, the shell will interpret the wildcard itself as a string. In the
    above output, you can see that `.png` files are not present. Hence it will take
    `*.png` as yet another filename and execute `mv *.png image-X.png`, which will
    cause an error. An `if` statement with `[ $? –eq 0 ]` is used to check the exit
    status (`$?`). The value of `$?` will be 0 if the last executed command is successful,
    else it returns non-zero. When the `mv` command fails, it returns non-zero and,
    therefore, the message "Renaming file" will not be shown to the user, as well
    as the count will not be incremented.
  prefs: []
  type: TYPE_NORMAL
- en: There are a variety of other ways to perform rename operations. Let's walk through
    a few of them.
  prefs: []
  type: TYPE_NORMAL
- en: Renaming `*.JPG` to `*.jpg:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace space in the filenames with the `"_"` character as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '`# ''s/ /_/g''` is the replacement part in the filename and `*` is the wildcard
    for the target files. It can be `*.txt` or any other wildcard pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can convert any filename of files from uppercase to lowercase and vice
    versa as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to recursively move all the`.mp3` files to a given directory, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'Recursively rename all the files by replacing space with "`_"` character as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Spell checking and dictionary manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most Linux distributions come with a dictionary file. However, I find few people
    are aware of the dictionary file and hence many people fail to make use of them.
    There is a command-line utility called `aspell` that functions as a spell checker.
    Let's go through few scripts that make use of the dictionary file and the spell
    checker.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `/usr/share/dict/` directory contains some of the dictionary files. Dictionary
    files are text files that contain a list of dictionary words. We can use this
    list to check whether a word is a dictionary word or not.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to check whether the given word is a dictionary word, use the following
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'The usage is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In `grep`, `^` is the word start marker character and the character `$` is the
    word end marker.
  prefs: []
  type: TYPE_NORMAL
- en: '`-q` is used to suppress any output and to be silent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, alternately, we can use the spell check, `aspell`, to check whether a word
    is in a dictionary or not as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: The `aspell list` command returns output text when the given input is not a
    dictionary word, and does not output anything when a dictionary word is the input.
    A `-z` check ensures whether `$output` is an empty string or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'List all words in a file starting with a given word as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'Or alternately, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: By default, if the filename argument is not given to the `look` command, it
    uses the default dictionary (`/usr/share/dict/words`) and returns an output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: Automating interactive input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Automating interactive input for command-line utilities are extremely useful
    for writing automation tools or testing tools. There will be many situations when
    we deal with commands that read inputs interactively. Interactive input is the
    input typed by the user only when the command asks for some input. An example
    for execution of a command and supply of interactive input is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Automating utilities which can automate the acceptance of input as in the above
    mentioned manner are useful to supply input to local commands as well as for remote
    applications. Let's see how to automate them.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Think about the sequence of an interactive input. From the previous code we
    can formulate the steps of the sequence as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`1[Return]hello[Return]`'
  prefs: []
  type: TYPE_NORMAL
- en: Converting the above steps `1,Return,hello,Return` by observing the characters
    that are actually typed in the keyboard, we can formulate the following string.
  prefs: []
  type: TYPE_NORMAL
- en: '`"1\nhello\n"`'
  prefs: []
  type: TYPE_NORMAL
- en: The `\n` character is sent when we press *Return*. By appending return (`\n`)
    characters, we get the actual string that is passed to the `stdin` (standard input).
  prefs: []
  type: TYPE_NORMAL
- en: Hence by sending the equivalent string for the characters typed by the user,
    we can automate the passing of input in the interactive processes.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s write a script that reads input interactively and uses this script for
    automation examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s automate the sending of input to the command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: Thus crafting inputs with `\n` works.
  prefs: []
  type: TYPE_NORMAL
- en: We have used `echo -e` to produce the input sequence. If the input is large
    we can use an input file and redirection operator to supply input.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also manually craft the input file without `echo` commands by hand
    typing. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: This redirects interactive input data from a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are a reverse engineer, you may have played with buffer overflow exploits.
    To exploit them we need to redirect shellcode like `"\xeb\x1a\x5e\x31\xc0\x88\x46"`,
    which is written in hex. These characters cannot be typed directly through keyboard
    since, keys for these characters are not present in the keyboard. Therefore we
    should use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`echo -e "\xeb\x1a\x5e\x31\xc0\x88\x46"`'
  prefs: []
  type: TYPE_NORMAL
- en: This will redirect shellcode to a vulnerable executable.
  prefs: []
  type: TYPE_NORMAL
- en: We have described a method to automate interactive input programs by redirecting
    expected input text through `stdin` (standard input). We are sending the input
    without checking the input the program asks for. We are sending the input by expecting
    the program to ask input in a specific (static) order. If the program asks input
    randomly or in a changing order, or sometimes certain inputs are never asked,
    the above method fails. It will send wrong inputs to different input prompts by
    the program. In order to handle dynamic input supply and provide input by checking
    the input requirements by the program on runtime, we have a great utility called
    `expect`. The `expect` command supplies correct input for the correct input prompt
    by the program. Let's see how to use `expect`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Automation of interactive input can also be done using other methods. Expect
    scripting is another method for automation. Let's go through it.
  prefs: []
  type: TYPE_NORMAL
- en: Automating with expect
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `expect` utility does not come by default with most of the common Linux
    distributions. You have to install the expect package manually using package manager.
  prefs: []
  type: TYPE_NORMAL
- en: '`expect` expects for a particular input prompt and sends data by checking message
    in the input prompt.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'Run as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'In this script:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spawn` parameter specifies which command is to be automated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expect` parameter provides the expected message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`send` is the message to be sent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expect eof` defines the end of command interaction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
