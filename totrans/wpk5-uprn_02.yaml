- en: Working with Modules and Code Splitting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will explore modules and code splitting in Webpack 5\. Modules
    are a way of structuring content so that code is sorted in sections by function.
    Code splitting is the method Webpack uses to build these modules automatically;
    it will parcel off code from your project into modules that best suit the functionality
    and structure of the completed project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Explaining modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding code splitting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prefetching and preloading modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Webpack works with elements called modules. It uses these modules to build a
    dependency graph.
  prefs: []
  type: TYPE_NORMAL
- en: Modules are sections of code that deal with a related function; structuring
    your project according to a modular build will improve functionality. For instance,
    only code related to pertinent actions will need to be run, when compared to the
    need to run whole sections of unrelated code when the project is not built with
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: With that being said, the next thing to understand is the specific function
    of modules, which will be discussed in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: The function of modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A module is a set of pieces of code: for example, code of a similar language
    has a common function—that is to say, it is part of the same function or operation within
    an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, modules in Webpack 5 are grouped according to the scripting language
    used, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d145de8d-82c2-403f-a485-52765c3d1801.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram should help illustrate what most people see when exploring
    the contents of a Webpack build.
  prefs: []
  type: TYPE_NORMAL
- en: An application is then divided into modules and assets. As we explained in [Chapter
    1](26d5b9c8-5d08-4cca-b0fb-63d0e715eba0.xhtml), *Introduction to Webpack 5*, an
    asset is essentially images and videos that are not considered scripted by a developer.
    The directory structure is then subdivided into these modules, usually in a directory
    of their own.
  prefs: []
  type: TYPE_NORMAL
- en: Dividing an application into modules will naturally make the process of debugging
    easier. This will also aid us in verification and testing in general.
  prefs: []
  type: TYPE_NORMAL
- en: Building applications this way ensures that a boundary is made between well-written
    code and more-dubiously written code. Naturally, this helps with directory navigation,
    as each module has a defined purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Many platforms use modules and it is a term that you will no doubt be used to
    if you work in web development in general. However, each platform differs slightly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Webpack 5 forms these modules according to how it expresses the dependencies
    of the module. Here are a few examples of how Webpack 5 expresses them:'
  prefs: []
  type: TYPE_NORMAL
- en: Through a **2015 ECMAScript** `import` statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Through a **CommonJS **`require()` statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Through an **asynchronous module definition **(**ASM**) `define` and `require`
    statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Through an imageURLin a stylesheet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Through an `@import` statement in a stylesheet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, modular code makes things a lot easier and understanding how Webpack
    expresses dependencies will help you understand how you should compile your code.
    From here, the natural next step is to look at the supported module types and
    how loaders work with them.
  prefs: []
  type: TYPE_NORMAL
- en: Supported module languages and loaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make sure Webpack 5 supports these modules, they must be written in a programming
    language that can be understood and processed. Webpack 5 does this by using something
    called loaders.
  prefs: []
  type: TYPE_NORMAL
- en: Loaders make Webpack truly stand out over rival bundlers. In simple terms, a
    loader tells Webpack how to process code that is not JavaScript or other predefined
    code that Webpack automatically understands, such as JSON or HTML. Webpack 5 will
    then include this processed code as dependencies in your bundle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Webpack 5 has a community of developers, referred to as the Webpack community,
    who have built these loaders. These loaders currently support a large number of
    languages and processors; some examples are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**TypeScript**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SASS**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LESS**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**C++ **'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Babel**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bootstrap**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a full list of available loaders, see the *Further reading* section toward
    the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Being part of the Webpack community means you can write your loaders! This is
    something worth considering as it may be the best way to meet the requirements
    of your project.
  prefs: []
  type: TYPE_NORMAL
- en: There are many more loaders available from the Webpack community. The use of
    loaders means Webpack 5 can be described as a dynamic platform that allows the
    customization of just about any technology stack. In this chapter, we will begin
    to use loaders proactively as part of some example use cases that you can practice
    coding yourself.
  prefs: []
  type: TYPE_NORMAL
- en: During your development, you may come across the term **encapsulation**, especially
    when working with modules and loaders.
  prefs: []
  type: TYPE_NORMAL
- en: To understand encapsulation, you first need to understand that software can
    sometimes be developed independently until a requirement for interplay presents
    itself. For software to work together within a project, a dependency must be created
    between the two technology stacks. This is what is meant by the term encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation is a simple topic to outline; however, the next area of modular
    coding concerns resolution. It is a wider subject and has, therefore, been detailed
    as part of its own subsection.
  prefs: []
  type: TYPE_NORMAL
- en: The enabling of a new asset module type is an experimental feature shipped with
    v5\. The asset module type is similar to the `file-loader`, `url-loader`, or `raw-loader`
    (`experiments.asset` since alpha.19) data URLs and options related to that have
    been supported since beta.8.
  prefs: []
  type: TYPE_NORMAL
- en: Module resolution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Module resolution takes place via the use of a resolver. A resolver assists
    you in locating a module by its absolute path—the path to a module that is universally
    used throughout a project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that a module can act as a dependency of another module, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Regardless of whether the dependency module is from another library (not the
    resolver itself) or the application itself, the resolver will help to find the
    module code required to include in the bundle. Webpack 5 can also use `enhance-resolve`
    to resolve paths while bundling.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resolving rules for Webpack 5 mean that, using the `enhanced-resolve` method, Webpack 5 can
    resolve three kinds of file paths:'
  prefs: []
  type: TYPE_NORMAL
- en: Absolute paths
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relative paths
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module paths
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following sections will detail the meaning of each file path and there will
    be an example for each. This will become important later as we begin to build
    on our project bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Absolute paths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the uninitiated, an absolute path refers to the file path and the location
    of a file that is common to all files and assets that your project uses. This
    common location is sometimes called the `home` or `root` directory. Here is a
    command-line location by way of example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line is an example of an absolute path. The term **absolute**
    is something every JavaScript developer should be familiar with. It relates to
    the location of an object file or directory in a path that is universal throughout
    the system.
  prefs: []
  type: TYPE_NORMAL
- en: If we already have the absolute path, as in the preceding line, no further resolution
    is required.
  prefs: []
  type: TYPE_NORMAL
- en: Relative paths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A relative path refers to the location of an object file or directory to another
    location. In this case, it is the location of the `context` directory—the current
    and working location where development is carried out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the directory of the resource file is considered the
    `context` directory. The resource file refers to the file that the `import()` statement,
    the `require()` statement, or the call to an external file occurs.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the relative path is joined to the context directory path, which
    then produces an absolute path.
  prefs: []
  type: TYPE_NORMAL
- en: Module paths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A module path is something that not all JavaScript developers may be used to.
    With Webpack, it refers to a location relative to a module. In the following code
    snippet, `module` would be co-opted for the name of any specific module name you
    wish to use—the name of an existing module in your project, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Webpack 5 searches all the directories for modules that are specified in the
    `resolve.module` directive. An alias can be created for each original module file
    path using the `resolve.alias` configuration. Using this method, Webpack 5 checks
    the file path and whether it points to a file or directory.
  prefs: []
  type: TYPE_NORMAL
- en: Webpack 5 has an option called `resolve.extension`. If a path does not have
    a file extension, this resolver will indicate to Webpack which extensions can
    be used for resolution. These might include `.js`, `.jsx`, or similar extensions.
  prefs: []
  type: TYPE_NORMAL
- en: In the event of a file path not pointing to a file but only to a directory,
    Webpack 5 searches the directory for a `package.json` file. Webpack 5 then uses
    the fields specified in the `resove.main` field's configuration to search for
    fields contained in `package.json` and, from this, determines the correct contextual
    file path to use.
  prefs: []
  type: TYPE_NORMAL
- en: If there is no `package.json` file present in the directory, or if the main
    fields do not return a valid path, Webpack 5 simply searches for filenames specified
    in the `resolve.main` configuration.
  prefs: []
  type: TYPE_NORMAL
- en: File extensions are resolved similarly, but using the `resolve.extension` option.
  prefs: []
  type: TYPE_NORMAL
- en: We have, so far, covered modules, path resolution, supported languages, and
    loaders. The next crucial thing to understand is code splitting—what it is and
    how Webpack utilizes it to form both its modules and general output.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding code splitting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code splitting allows the user to **split code** into various bundles that can
    then be loaded on-demand or in parallel. The developers of Webpack consider this
    "*one of the most compelling features of Webpack*" ([Webpack.js.org](http://webpack.js.org)).
  prefs: []
  type: TYPE_NORMAL
- en: Code splitting has two key advantages—the process can be used to achieve smaller
    bundles and to control the priority of resource loading. This can lead to an improvement
    in loading time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three general code-splitting approaches available in Webpack 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Entry points**: This manually splits code using an entry point configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prevent duplication**: This approach uses `SplitChunksPlugin` to run a process
    called **dedupe**, which splits code into groups of modules called **chunks**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic imports**: This approach uses inline functions to make **calls**
    to split code within modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A chunk refers to a group of modules. This is a term used by Webpack and is
    not frequently encountered on other platforms.
  prefs: []
  type: TYPE_NORMAL
- en: dedupe is a Python library that uses machine learning to perform matching, **deduplication**,
    and entity resolution quickly. It helps remove duplicate entries from a spreadsheet
    of names and addresses.
  prefs: []
  type: TYPE_NORMAL
- en: With these three approaches outlined, we can now discuss each one in detail
    in the following sections. Let's begin with entry points.
  prefs: []
  type: TYPE_NORMAL
- en: Entry points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using entry points is probably the easiest way of performing code splitting.
    It is a manual operation and is, therefore, not automated like other methods.
  prefs: []
  type: TYPE_NORMAL
- en: We will now look at the development of splitting one module from the main bundle. To
    do this, we will begin with some practical work. From there, we will go over the
    concepts of duplication and dynamic imports.
  prefs: []
  type: TYPE_NORMAL
- en: We will now return to the project we were working on in [Chapter 1](26d5b9c8-5d08-4cca-b0fb-63d0e715eba0.xhtml),
    *Introduction to Webpack 5*. This time, we will utilize what we have learned so
    far in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: First, create a directory to work in. In this case, we are using the directory
    name we used in the last chapter. It might be a good idea to follow this same
    convention and, that way, you will be able to follow the course of the project's
    development as you continue through this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Organize a project folder structure to start a project that shows how entry
    points work. You should build this set of directories in your practice project
    directory. This is done in the same way as creating folders on your desktop. For
    the sake of this example, we will call this folder `webpack5-demo` (but you can
    choose any name you want):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Be sure to add the last line of text (in bold), if it is missing from the code
    you are using. This can be done on a command line; if that's what you decide to
    use, please refer to [Chapter 1](26d5b9c8-5d08-4cca-b0fb-63d0e715eba0.xhtml),
    *Introduction to Webpack 5*, for guidance. You may have noticed the inclusion
    of `another-module.js`. You might not find this a typical build but you will need
    to include this for our example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ultimately, you can name the project anything you like but, for the sake of
    following this practice project, you should use the same naming convention used
    up to now to prevent confusion.
  prefs: []
  type: TYPE_NORMAL
- en: To follow this project development, using your **integrated development environment**(**IDE**)
    or notepad, you should create each of the preceding files and folders. The `**/**` character
    indicates a folder. Note the `another-module.js` file; this rests in the `/node_modules`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: We will now edit and compile a build, beginning with the `another-module.js`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `another-module.js` in your IDE of choice or a notepad:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The file essentially imports `lodash`, ensuring the module that is loaded is
    recorded in the console log, setting the Webpack build mode to development, and
    setting entry points that Webpack begins mapping the assets in the application
    for bundling through and sets an output bundle name and location.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run a build with `npm` by entering the location of the context directory
    (the one you are developing in) in the command line and type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is all you need to produce a bundle output or development application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, check for successful compilation. When a build is run in your command
    line, you should see the following message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Success! However, some potential problems might occur when using entry points
    that a developer should be conscious of:'
  prefs: []
  type: TYPE_NORMAL
- en: If there are duplicated modules between entry chunks, they will be included
    in both bundles.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For our example, as `lodash` is also imported as part of the `./src/index.js` file
    in the project directory, it will be duplicated in both bundles. This duplication
    can be removed by using `SplitChunksPlugin`.
  prefs: []
  type: TYPE_NORMAL
- en: They can't be used to dynamically split code using the programming logic of
    the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we will cover preventing duplication.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing duplication with SplitChunksPlugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`SplitChunksPlugin` allows the extraction of common dependencies into entry
    chunks, either existing or new. In the following walk-through, this method will
    be used to deduplicate the `lodash` dependency from the preceding example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a code snippet from the `webpack.config.js` file, found in
    the preceding example''s project directory. This example shows the configuration
    options needed to use the plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin by ensuring that our configuration is coded to the same configuration
    as in the preceding example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Using the `optimization.splitChunks` configuration, the duplicate dependency
    should now be removed from `index.bundle.js` and `another.bundle.js`. `lodash`
    has been separated into a separate chunk and the main bundle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, perform `npm run build`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'There are other community-developed loaders and plugins that can be used to
    split code. Some of the more notable examples are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bundle-loader`: Used to split code and lazy-load the resulting bundles'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`promise-loader`: Similar to `bundle-loader` but uses promises'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mini-css-extract-plugin`: Useful for splitting CSS from the main application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, with a firm understanding of how duplication can be prevented, we will
    move on to a more difficult topic—dynamic imports.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic imports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dynamic imports are, essentially, on-demand imports on Webpack. If you have
    already bundled a lot of code but need to patch more to it, the dynamic import
    method will come to the rescue. This also includes dynamic code splitting, which,
    as it sounds, means splitting code and optimizing it after a bundle has been built.
  prefs: []
  type: TYPE_NORMAL
- en: 'Webpack 5 supports two methods of doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: The first method uses the `import()` syntax, which conforms to the dynamic import
    proposal for ECMAScript.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second is the `webpack-specific` approach, which uses the `require.ensure`
    method (this is a legacy method).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following is an example of the first approach; the goal is to demonstrate
    a modern method of using dynamic imports, which will be more common on recent
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: The `import()` call is an internal call to promises. A **promise** refers to
    the information returned from a loader.
  prefs: []
  type: TYPE_NORMAL
- en: When using `import()` with older browsers, use a `polyfill` function—such as `es6-promise` or `promise-polyfill`—to
    **shim promise**. `shim-loader` is a loader that transforms code so that it works
    in the Webpack 5 environment; this works similarly to doing this manually with
    `imports-loader` and `exports-loader`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to remove any surplus entries in the configuration file, which
    includes the `optmization.splitChunks` reference, as it will not be needed in
    the following demonstration:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the `webpack.config.js` file and make the following entries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of `chunkFilename`, which determines the name of non-entry chunk
    files.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding configuration was needed to prepare your project to use dynamic
    imports. Be sure to remove the text in bold as you may see this when working with
    the same code, as before.
  prefs: []
  type: TYPE_NORMAL
- en: Jumping back into the project, we need to update it with instructions to remove
    unused files.
  prefs: []
  type: TYPE_NORMAL
- en: You may have already set up your practice directory; however, it is recommended
    that you start with a fresh set of directories that doesn't contain any experimental
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The following demonstration will use dynamic importing to separate a chunk,
    instead of the static importing of `lodash`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `index.js` file and ensure the following entries are made:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When importing a `CommonJS` module, this import will not resolve the value of
    `module.exports`; instead, an artificial namespace object will be created. Therefore,
    we need a default when importing.
  prefs: []
  type: TYPE_NORMAL
- en: The use of `webpackChunkName` in the comment will cause our separate bundle
    to be named `lodash.bundle.js`, instead of just `[your id here].bundle.js`. For
    more information on `webpackChunkName` and the other available options, see the
    `import()` documentation.
  prefs: []
  type: TYPE_NORMAL
- en: If Webpack is now run, `lodash` will separate into a new bundle.
  prefs: []
  type: TYPE_NORMAL
- en: '`npm run build` can be run using your **command-line interface** (**CLI**).
    In your CLI utility, type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When a build is run, you should see the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`import()` can be used with asynchronous functions as it returns a promise.
    This requires the use of a preprocessor, such as the `syntax-dynamic-import` Babel
    plugin.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `src/index.js`, make the following amendments to show how the code can
    be simplified:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example uses the same file that we used in the *Dynamic imports*
    section. We have turned multi-line code into single lines, replaced a returning
    function with asynchronous code, expediting our coding practice. You will see
    that it is now much simpler than the earlier code—it uses the same file, `src/index.js`,
    and achieves the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: We often simplify code to help with loading times. Another key way of improving
    browsing speed is caching.
  prefs: []
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we finish this section on code splitting, we will go over caching. Caching
    is related to the previous processes and is no doubt something that will come
    up during programming. For the uninitiated, caching is the method of storing previously
    computed data to allow it to be served faster. It also relates to the following
    section on prefetching and preloading, methods that govern how memory is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Learning about caching will ensure you know how to split code more effectively.
    In the following example, we will see how it''s done. In Webpack, caching is done
    by something called **filename hashing** (when a computer traces the location
    of a file recursively) and, specifically, the hashing of the output bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note the `output` key handler in the preceding code block; within the parentheses,
    you will see the output  `bundle.js` filename and below that is the inline element
    we refer to as the hash. You should substitute the bracketed terms with your preferences.
    This method produces an alternative output that is only updated when the content
    updates and serves as our cache resource.
  prefs: []
  type: TYPE_NORMAL
- en: Every filesystem access is cached so that multiple parallel or serial requests
    to the same file occur faster. In `watch` mode, only modified files are evicted
    from the cache. If `watch` mode is turned off, then the cache is purged before
    every compilation.
  prefs: []
  type: TYPE_NORMAL
- en: This leads us to our next section, which also relates to imports—prefetching
    and preloading.
  prefs: []
  type: TYPE_NORMAL
- en: Prefetching and preloading modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Webpack 5 can output a **resource hint** when using inline directives and declaring
    imports. It will give the browser the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`preload` (may be needed during the current navigation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prefetch` (may be needed for future navigation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The terms "current" and "future" may be confusing, but they essentially refer
    to the fact that `prefetch` loads content before the user needs it, which, in
    a way, loads and queues content ahead of time. This is a simple definition—a full
    explanation will follow—but in general, you can see the advantages and disadvantages
    in terms of memory usage and efficiency of user experience.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to be aware of is that prefetching doesn't work for **Web Assembly** (**WASM**)
    yet in Webpack 5.
  prefs: []
  type: TYPE_NORMAL
- en: This simple `prefetch` example can have a `HomePage` component that renders
    a `LoginButton` component, which, upon being clicked, loads a `LoginModal` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `LoginButton` file will need to be created; follow these instructions in `LoginButton.js`
    to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will result in the following code snippet being appended
    to the header of the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This will instruct the browser, when idle, to prefetch the `**login-modal-chunk.js**`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `preload` directive has many differences when compared to `prefetch`:'
  prefs: []
  type: TYPE_NORMAL
- en: Chunks using the `preload` directive load in parallel to their parent chunk, whereas
    a prefetched chunk starts after the parent chunk finishes loading.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chunks must be instantly requested by the parent chunk when preloaded, whereas
    a prefetched chunk can be used at any time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chunks using the `preload` directive are instantly downloaded when called. A
    prefetched chunk is downloaded while the browser is idle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple `preload` directives can have components that always depend on libraries
    that should be in a separate chunk.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The choice of whether to use `preload` or `prefetch` depends largely on context;
    you will discover more on how that might apply to you as the tutorial progresses.
  prefs: []
  type: TYPE_NORMAL
- en: You should use `prefetch` or `preload`, depending on how the preceding points
    best suit your development needs. This largely depends on the complexity of the
    project and, ultimately, is a judgment call made by the developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example suggests an imagined component, `ChartComponent`, in `ChartComponent.js`,which
    requires a library that we will call `ChartingLibrary`. It instantly imports the
    library on demand and displays `LoadingIndicator` when rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: When `ChartComponent` is requested, `charting-library-chunk` is also requested
    through `<link rel="preload">`.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming `page-chunk` finishes loading faster, the page will be displayed with
    `LoadingIndicator` until `charting-library-chunk` finishes loading. This will
    give a loading time improvement since it only needs one round process instead
    of two. This is especially true in high-latency environments (where delays often
    occur in data processing networks).
  prefs: []
  type: TYPE_NORMAL
- en: Using `webpackPreload` incorrectly can harm the performance, so be mindful when
    using it.
  prefs: []
  type: TYPE_NORMAL
- en: One feature added with version 5 that is useful and related to fetching is the
    top-level await, a feature that enables modules to act as big async functions.
    That means they will be processed as code asynchronously. With top-level await,
    **ECMAScript Modules** (**ESMs**) can await resources, causing other modules that
    import them to wait before they start evaluating the body.
  prefs: []
  type: TYPE_NORMAL
- en: You should now understand the purposes of `prefetch` and `preload` and how their
    usage affects performance if done incorrectly. A decision on their use will depend
    largely on how you wish your application to perform. The best approach is to make
    your decision on their use after conducting a formal bundle analysis, which we
    will discuss in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with all programming, there are best practices that ensure the most optimum
    delivery. This is also an excellent way to conclude this chapter. If best practices
    are followed, a developer can protect their application from security breaches
    and hacking, poor performance, and difficulties when working collaboratively in
    a team, or when future development is needed by new developers, future-proofing
    the build. This latter reason speaks to the product owner or project manager more
    than a development team.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to Webpack, the foremost areas of salience here would be bundle
    analysis and code linting.
  prefs: []
  type: TYPE_NORMAL
- en: Bundle analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you start splitting code, it can be useful to analyze the output and check
    where modules have ended up. It''s important to get the most out of bundling,
    so a formal procedure for bundle analysis can be considered as fundamental, as
    well as browser and security testing. The official analyze tool is recommended.
    There are also some other options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`webpack-bundle-analyzer`: This is a plugin and CLI utility that represents
    bundle content as a convenient interactive **treemap**, where zooming options
    are available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`webpack-bundle-optimize-helper`: This tool will analyze your bundle and give
    suggestions to reduce your bundle size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`webpack-visualizer`: This is used to visually analyze bundles to see which
    modules are taking up too much space and which might be duplicated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`webpack-chart`: This offers an interactive pie chart used for Webpack stats.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Treemapping is a method used to display hierarchical data using nested figures,
    usually rectangles.
  prefs: []
  type: TYPE_NORMAL
- en: All the previously mentioned tools will help with optimization, which is the
    primary purpose of Webpack.
  prefs: []
  type: TYPE_NORMAL
- en: Code linting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another way that the application can be improved is through the removal of unwanted
    code. When automated, this is often called tree shaking, which we will discuss
    in later chapters. When this is done manually, it is referred to as code linting.
    A definition is probably in order as it is a phrase that is not often encountered
    in programming.
  prefs: []
  type: TYPE_NORMAL
- en: Code linting is the process of removing unwanted or surplus code, just like
    removing lint from a blazer. This could include unused coding artifacts, erroneous
    code, or anything else that's unwanted. Webpack uses an automated process to do
    this when integrating with task runners such as **Gulp**. This is discussed in
    the following chapter, [Chapter 6](c8eb858d-110e-459c-aaa9-c6b8f48aef50.xhtml), *Production,
    Integrations, and Federated Modules*.
  prefs: []
  type: TYPE_NORMAL
- en: If you follow these procedures, then there can be little doubt that your application
    will perform at its very best. Code splitting and modular programming are central
    to Webpack and a firm understanding is required to prevent you from getting lost
    as the complexity of bundling projects advances through this guide.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has followed the demonstration of various code-splitting practices,
    including code chunks and dynamic imports. You will now have a sound base of knowledge
    to carry out code splitting and use modules. These are fundamental features of
    Webpack, so a solid grounding is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Code splitting and modules are a matter of structural necessity for Webpack
    applications. Code chunks and dynamic imports will be more important on specialist
    tasks that require heavy-duty programming.
  prefs: []
  type: TYPE_NORMAL
- en: You were taken through prefetching modules and bundle analysis—important procedures
    that are needed to clearly understand the following chapter, where we will look
    at the world of configuration, understanding its limitations and capabilities
    as well as where options play their part.
  prefs: []
  type: TYPE_NORMAL
- en: These concepts are important as configuration is central to Webpack development
    and a matter of day-to-day programming. Options become more important when it
    comes to production and you need your project to operate correctly.
  prefs: []
  type: TYPE_NORMAL
- en: To test your skills, try the following quiz and see whether your understanding
    of the topics covered in this chapter is up to scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will conclude this chapter with a set of questions to test your knowledge.
    The answers to these questions can be found in the back of this book, in the *Assessment*
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between code splitting and modular programming?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a code chunk?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do dynamic imports differ from entry points?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are `preload` directives preferable to `prefetch` directives?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is meant by code linting?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is meant by the term promise?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does `SplitChunksPlugin` prevent duplication?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the `webpack-bundle-optimize-helper` tool offer?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the `webpack-chart` plugin do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is treemapping?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a full list of loaders, go to [https://github.com/webpack-contrib/awesome-webpack](https://github.com/webpack-contrib/awesome-webpack).
  prefs: []
  type: TYPE_NORMAL
