- en: Dealing with Processes and Threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Processes and threads are the foundations of any computation. A program is rarely
    made of just one thread or process. In this chapter, you will learn the fundamental
    recipes for dealing with threads and processes. You will also learn how easy and
    convenient it is to deal with threads compared with the **Portable Operating System
    Interface** (**POSIX**). Learning these skills is very important as part of the
    core skills of a system developer. C++ does not have the notion of *process* in
    its standard library, so the Linux native implementation will be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Starting a new process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Killing a process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a daemon process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to let you try the programs immediately, we've set up a Docker image that
    has all the tools and libraries we'll need throughout the book. This is based
    on Ubuntu 19.04.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to set it up, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download and install Docker Engine from [www.docker.com](https://www.docker.com/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Pull the image from Docker Hub by running the following command: `docker pull
    kasperondocker/system_programming_cookbook:latest`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The image should now be available. Type in the following command to view the
    image: `docker images`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should have at least this image now: `kasperondocker/system_programming_cookbook`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the Docker image with an interactive shell, with the help of the following
    command: `docker run -it --cap-add sys_ptrace kasperondocker/system_programming_cookbook:latest /bin/bash`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The shell on the running container is now available. Type in `root@39a5a8934370/#
    cd /BOOK/` to get all the programs developed, by chapters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `--cap-add sys_ptrace` argument is needed to allow the **GNU Project Debugger**
    (**GDB**) in the Docker container to set breakpoints, which, by default, Docker
    does not allow.
  prefs: []
  type: TYPE_NORMAL
- en: '**Disclaimer**: The C++20 standard has been approved (that is, technically
    finalized) by WG21 in a meeting in Prague at the end of February. This means that
    the GCC compiler version that this book uses, 8.3.0, does not include (or has
    very, very limited support for) the new and cool C++20 features. For this reason,
    the Docker image does not include the C++20 recipe code. GCC keeps the development
    of the newest features in branches (you have to use appropriate flags for that,
    for example, `-std=c++2a`); therefore, you are encouraged to experiment with them
    by yourself. So, clone and explore the GCC contracts and module branches and have
    fun.'
  prefs: []
  type: TYPE_NORMAL
- en: Starting a new process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show how to start a new process programmatically. The C++ standard
    does not include any support for processes, so the Linux native implementation
    will be used. Being able to manage processes in a program is an important skill,
    and this recipe will teach you the fundamental concepts of processes, the **process
    identifier** (**PID**), the parent PID, and the system calls needed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe will show how to start a child process and how to make the parent
    process wait for the child to finish by using Linux system calls. Two different
    techniques shall be shown: the first, where the parent just forks the child; and
    the second, where the child process uses the `execl` system call to run an application.'
  prefs: []
  type: TYPE_NORMAL
- en: An alternative option to system calls is to use an external library (or framework),
    such as the **Boost** library.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, type the program in a new file called `process_01.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to consider the case that a child might not be forked, so we need to
    write this part:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This branch is a happy case, where the parent can fork its child correctly.
    The child, here, just prints its PID to the standard output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to make the parent wait for the child process to finish:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's develop the `fork-exec` version of the previous program.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, type the program in a new file called `process_02.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The following code block shows the child section running `ls -l` with `execl`*: *
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The next section will describe the details of the two different approaches (`fork`
    versus `fork-exec`)*.*
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s analyze the two preceding examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fork` system call: By compiling `g++ process_01.cpp` and running `./a.out`,
    the output would be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ee5c3fb9-61b9-4ed8-a7c1-ba0ba262c4d8.png)'
  prefs: []
  type: TYPE_IMG
- en: The program, by calling `fork`, creates a copy of the calling process. This
    means that the two processes have the same code and, although they are two completely
    different processes, the code base will be the same. The user has to hook the
    child code in the `else if (child == 0)`  section. The parent, eventually, will
    have to wait for the child to finish its task with the `wait(&status);` call.
    Another alternative is the `waitpid (123, &status, WNOHANG);` call, which waits
    for a specific PID (or waits for all the child processes if the first parameter
    is `-1`). `WNOHANG` makes `waitpid` immediately return, even if the status of
    a child is not immediately available.
  prefs: []
  type: TYPE_NORMAL
- en: What happens if the parent process does not wait for the child to finish? That
    is, what happens is there is no `wait(&status);` call? Technically, the parent
    will finish, and the child, still running, will become a **zombie**. This was
    a huge problem in the Linux kernel before version 2.6 as the zombie processes
    stayed in the system until they were *waited* for. The child's processes are now
    adopted by the `init` process (which has a PID of `1`), which, periodically, waits
    for children who can die.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fork-exec` system call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ba51686a-cefb-4c91-9f71-5b4a93a1fc55.png)'
  prefs: []
  type: TYPE_IMG
- en: The most common way of creating processes is the `fork`/`exec` combination.
    As we've seen, `fork` creates a completely new process with its own PID, but now,
    the `else if (child == 0)` section executes an external process, which has a different
    code base. This example just calls the `ls -l` command to list files and directories,
    but a developer can put any executable file here.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Why a process should be used instead of a thread is an important aspect to
    consider. The answer depends, but in general, the following aspects should be
    considered:'
  prefs: []
  type: TYPE_NORMAL
- en: A thread runs in the same memory space of the process that launched it. This
    aspect has both pros and cons. The main implication is that if a thread crashes,
    the whole application crashes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication between threads is much faster than interprocess communications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A process can be spawned with lower privileges (through `setrlimit`) to limit
    the resources available to untrusted code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A program designed in processes is more segregated than one designed in threads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are many variations to the `fork`/`execl`/`wait` calls seen in this recipe.
    The `man pages` offer full comprehensive documentation to the whole family of
    calls. The following screenshot refers to `man execl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/67bf3f79-e515-41b1-9a1a-779d804c909d.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: See [Chapter 1](c3cda38c-220e-4aae-89c6-c381df46daec.xhtml), *Getting Started
    with System Programming*, for a refresher on `man pages` and Linux in general.
  prefs: []
  type: TYPE_NORMAL
- en: Killing a process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we've seen two ways to start a new process where the
    parent always waits for their children to finish the task. This is not always
    the case. Sometimes, a parent should be able to kill the child process. In this
    recipe, we will see an example of how to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's important to go through the *Starting a new process *recipe as a prerequisite.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we create a program where a parent process forks its child
    process, the child process will do an infinite loop, and the parent kills it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s develop the child program that will be killed by the parent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to develop the parent program (`process_03.cpp` in the `/BOOK/Chapter03`
    folder):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in the child section of the parent program, we start the child program
    developed in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the parent section (`else` section) of the parent program, we have to kill
    the child process and check that it is correctly killed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We've seen both the parent and the child program, with the parent killing the
    child process. In the next section, we'll learn the mechanics of these programs.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before all this, we have to compile both the child and parent programs—`g++
    process_03.cpp` and `g++ -o child.out process_04.cpp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When compiling `process_04.cpp`, we have to specify `-o child.out` as needed
    by the parent process (with the process name as `a.out`*)*. By running it, the
    output produced is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/93a1d294-77bb-4e04-b466-55e24149172d.png)'
  prefs: []
  type: TYPE_IMG
- en: The execution shows that the child process with `PID = 218` is correctly killed
    by the parent process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in this recipe is just a variation of the *Starting a new process* recipe.
    The difference is that now, the parent process, as part of its elaboration, kills
    the child process `int status = kill (child, 9);`. The `kill` system call accepts
    as the first parameter the PID of the process to kill, and, as the second parameter,
    the signal to send to the child process. The accepted signals are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`1` = `HUP` (hangup)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2` = `INT` (interrupt)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3` = `QUIT` (quit)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`6` = `ABRT` (abort)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`9` = `KILL` (non-catchable, non-ignorable kill)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`14` = `ALRM` (alarm clock)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`15` = `TERM` (software termination signal)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`man 2 kill`, the `kill` system call, sends a signal to a process. On success,
    return `0`; otherwise, return `-1`. You need to include `#include <sys/types.h>` and
    `#include <signal.h>` to use it.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Understanding concurrency* recipe in [Chapter 2](1bf083f4-9d12-4b2e-bf5c-35a2e3d99c36.xhtml),
    *Revisiting C++*, we offer two alternative solutions (and advocate them for the
    nature of this book) based on `std::thread` and `std::async`, if possible. The
    next recipe also offers a concrete example of `std::thread` use.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new thread
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Processes are not the only way of structuring a software system; a lightweight
    alternative is to use threads. This recipe shows how to create and manage threads
    using the C++ standard library. We've seen that the main advantages of using the
    C++ standard library are its portability and the fact that it's not dependent
    on external libraries (for example, Boost).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code we'll write will be the concurrent version of summing up a large vector
    of integers. The vector is split into two parts; each thread calculates the sum
    of its part, and the main thread shows the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define a vector of 100,000 integers, and generate random numbers in
    the `main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, start the first thread, passing the first 50,000 integers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, start the second thread, passing the second 50,000 integers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the results from the two threads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The next section explains the dynamics.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By compiling the program with `g++ thread_01.cpp -lpthread` and executing it,
    the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49847d80-39be-498e-864d-f9653ab3426d.png)'
  prefs: []
  type: TYPE_IMG
- en: In *step 1*,  we defined the `threadFunction` method, which is the basic thread
    unit that will take care of summing up from `start` to `end` the elements in `speeds`,
    saving the result in the `res` output variable.
  prefs: []
  type: TYPE_NORMAL
- en: In s*tep 2* and *step 3*, we started two threads to do the calculation for the
    first 50,000 items for the `t1` thread and the second 50,000 items for the `t2` thread. 
    These two threads ran concurrently, so we needed to wait for them to finish to
    do this. In *step 4*, we waited for the `th1` and `th2` results to be completed,
    summed up the two results—`th1Results` and `th2Results`— and printed them in the
    standard output (`stdout`).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Starting a new process* recipe showed how to create a process, and in which
    circumstances a process suits the solution. One important aspect worth highlighting
    is that a thread runs in the **same address space** of the process that created
    it. Although threads are still a nice way of structuring a system software in
    a more independent (runnable) module, if a thread crashes (due to a segmentation
    fault, or if **`terminate` **is somehow called, among many others), the whole
    application crashes.
  prefs: []
  type: TYPE_NORMAL
- en: On the positive side, the ease of communication among threads, as we've seen
    in the preceding code, is extremely simple and efficient. Furthermore, threads
    share the **static** and the **heap** memorywith each other, and with the process
    that created them.
  prefs: []
  type: TYPE_NORMAL
- en: The code in this recipe, although simple, has shown how a task (sum of a large
    array) can be executed concurrently. As a side note, a multithreaded application
    is worthless if the algorithm is not designed to be run concurrently—that is,
    if there are dependencies among threads.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note in this context that if the two threads were to run on
    two processors at the same time, we'd use the word **parallel**. We don't have
    this guarantee, in this case.
  prefs: []
  type: TYPE_NORMAL
- en: We've used `std::thread` from the C++ standard library, but the same example
    can be written using `std::async`. [Chapter 2](1bf083f4-9d12-4b2e-bf5c-35a2e3d99c36.xhtml), *Revisiting
    C++*, shows an example of both. You are invited to rewrite this recipe's code
    using the second method.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Understanding concurrency* recipe in [Chapter 2](1bf083f4-9d12-4b2e-bf5c-35a2e3d99c36.xhtml), *Revisiting
    C++*, there is an introduction to the concurrency topic with a recipe that includes
    both `std::thread` and `std::async`. You are also invited to read the section
    dedicated to threads in *Effective Modern C++* by Scott Meyers, and *The C++ Programming
    Language* by Bjarne Stroustrup.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a daemon process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: System programming is really about dealing closely with operating system resources,
    creating processes, threads, releasing resources, and much more. There are cases
    where we need a process to run *indefinitely;* that is, a process first offers
    some services or manages a resource, and then it keeps running all the time. A
    process that runs *indefinitely in the background* is called a **daemon**. This
    recipe will show how a daemon could be spawned programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned, a daemon is a process that runs indefinitely. A process, in order
    to be classified as a daemon*,* must have some well-defined properties that will
    be shown in this recipe with a program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type the following code to reset the initial access permission of the child
    process by calling the `umask` system call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Type the code to fork for a child:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Type the `setsid` command on the child process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the working directory to the child process (which is a daemon now):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the daemon-specific task—in this case, just sleep for `10` seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The parent process exits after `fork`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The next section will explain these six points in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Compile the code with `g++ daemon_01.cpp` (in (`/BOOK/Chapter03`) folder of
    the Docker image) and run it. The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d3d2b3b2-859c-41b4-a28e-75a75e9411ee.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When we run a process on a shell, the Terminal waits for the children to finish
    before being ready for another command. We can run the command with the `&` symbol (for
    example, `ls -l &`), and the shell will prompt the Terminal for another command.
    Please note that the child process will still be in the same session as the parent
    process. For a process to be a daemon, the following rules should be applied (numbers *2*
    and *3* are mandatory; the others are optional):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Call `umask` with parameter `0`** (`umask(0)`): When a parent creates a child
    process, the file mode creation mask is inherited (that is, the child process
    will inherit the initial access permission of the parent). We want to make sure
    we reset them.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Have the parent exit after the fork**: In the preceding code, after the parent
    has created the child process, it returns.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Call** `setsid`. This does three things:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The child process becomes the leader of a newly created session.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It becomes the leader of a new process group.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It gets disassociated from its controlling Terminal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Change working directory**: The parent process might run in a temporary (or
    mounted) folder that might not exist for long. It''s a good practice to set the
    current folder to meet the long-term expectations of the daemon process.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Logging**: Since the daemon service is not associated with any Terminal device
    anymore, it is a good practice to redirect the standard input, output, and error
    to `/dev/null`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A process, as seen so far, has a PID as its unique identifier. It also belongs
    to a group that has a **process** **group ID** (**PGID**). A process group is
    a collection of one or more processes. All the processes in the same group can
    receive signals from the same Terminal. Each group has a leader, and the PGID
    has the same value as the leader's PID.
  prefs: []
  type: TYPE_NORMAL
- en: A session is a collection of one or more groups. This recipe showed that a new
    session can be created by calling the `setsid` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'A session can have a (single) controlling Terminal. The `ps -efj` command shows
    all the processes running with the `PID`, `PPID`, and `PGID`, and the controlling
    Terminal (`TTY`) info for each process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/68f40447-735e-48ba-a16b-4a44ac8be662.png)'
  prefs: []
  type: TYPE_IMG
- en: The output shows that the `./a.out` daemon has `PID = 19` and it's a leader
    for the group (`PGID = 19`), and it is not attached to any controlling Terminal
    (`TTY= ?`).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Chapter 13* of *Advanced Programming in the UNIX*®* Environment* by W.R. Stevens
    is dedicated to the daemon processes.'
  prefs: []
  type: TYPE_NORMAL
