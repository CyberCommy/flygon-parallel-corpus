- en: Chapter 10. Adding Real-time Chat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous two chapters, we extended our social network by adding new
    features to create pages and share posts. In this chapter, we will discuss real-time
    communication between users in the system. The technology that we are going to
    use is called WebSockets. The plan for this part of the book is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know WebSockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bringing Socket.IO to the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing the UI of the chat area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exchanging messages between the client and the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending messages to the user's friends only
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing the output of the chat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting to know WebSockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebSockets is a technology that opens a two-way (bidirectional) interactive
    channel between the server and the browser. By using this type of communication,
    we are able to exchange messages without the need of an initial request. Both
    sides simply dispatch events to each other. The other benefits of WebSockets are
    lower bandwidth requirement and latency.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of ways to transfer data from the server to the client and
    vice versa. Let''s check the most popular ones and see why WebSockets is considered
    the best option for real-time web apps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Classic HTTP communication**: The client requests a resource from the server.
    The server figures out what the response should be and sends it. In the context
    of real-time applications, this is not very practical because we have to manually
    ask for more data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ajax polling**: It is similar to the classical HTTP request except for the
    fact that we have the code that constantly sends requests to the server, for instance,
    in an interval of half a second. This is not really a good idea because our server
    will receive a huge amount of requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ajax long-polling**: We again have a client that performs HTTP requests,
    but this time, the server delays the result and does not respond immediately.
    It waits till there is new information available and then answers the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTML5 Server-sent Events (EventSource)**: In this type of communication,
    we have a channel from the server to the client and the server automatically sends
    data to the browser. This technique is used mostly when we need a one-directional
    data flow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WebSockets**: As mentioned before, if we use WebSockets, we have a two-way
    (bidirectional) data flow. Both sides, the client and the server, can send messages
    without asking the other side.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Server-sent Events may work in some cases, but for real-time chat, we definitely
    need WebSockets because we want users to be able to send messages to each other.
    The solution to this that we will implement looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting to know WebSockets](img/image00186.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Every user will connect to the server and start sending messages. Our backend
    will be in charge of distributing the messages to the rest of the users.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the raw WebSockets API may be not so easy. In the next section,
    we will introduce a really helpful Node.js module to deal with WebSockets.
  prefs: []
  type: TYPE_NORMAL
- en: Bringing Socket.IO to the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Socket.IO ([http://socket.io/](http://socket.io/)) is a real-time engine built
    on the top of WebSockets technology. It is a layer that makes web development
    easy and straightforward. Like every new thing nowadays, WebSockets comes with
    its own problems. Not every browser supports this technology. We may have problems
    with the protocol and missing events such as heartbeats, timeouts, or disconnection
    support. Thankfully, Socket.IO fixes these issues. It even provides fallbacks
    for the browsers that do not support WebSockets and goes with techniques such
    as long-polling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before making changes in our backend, we need to install the module. The engine
    is distributed in the same way as every other Node.js module; it is available
    via the package manager. So, we have to add Socket.IO to the `package.json` file
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After that change, we will run `npm install` and get the `node_modules/socket.io`
    folder populated. Having installed the module, we can start updating our social
    network. Let''s add a `Chat.js` file to the backend directory containing the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The new module exports a function that accepts the HTTP server. In `server.js`,
    we can initialize it by using `http.createServer`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Socket.IO is entirely built on the concept of event firing and listening. The
    `io` variable represents our communication hub. Every time a new user connects
    to our server, we get a connection event, and the handler that is invoked receives
    a `socket` object that we will use to process messages from and to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we sent (`emit`) an event with the `news` name containing
    some simple data. After this, we started listening to the other event that would
    come from the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, even if we restart the server, we are not going to receive any socket
    connections. This is because we did not change the frontend code. In order to
    make Socket.IO work on the client side, we need to include the `/socket.io/socket.io.js`
    file in our pages. The layout of our application is stored in `backend/tpl/page.html`,
    and after the modification, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `socket.io.js` file does not exist in our codebase. It is a part of the
    Socket.IO module. The engine automatically registers a route to it and takes care
    that it serves the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step in the testing of our WebSockets implementation is the connecting
    to the server. For the sake of simplicity, let''s add a few lines of code to the
    `frontend/js/app.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We will put our code in the `onload` handler because we want to make sure that
    all the external JavaScript files are fully loaded. Then, we will initialize a
    connection to `http://localhost:9000`, which is the same host and port that the
    Node.js server runs on. The rest of the code does only one thing—it listens for
    a `news` event and responds with the other event message. If we run the server
    and load `http://localhost:9000` in a browser, we will get the following result
    in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bringing Socket.IO to the project](img/image00187.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We got `{ my: ''data'' }` as an output because we have `console.log(data)`
    in the `backend/Chat.js` file.'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the UI of the chat area
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because real-time chat is an important part of our social network, we will
    create a separate page for it. As we did in the previous chapters, we will start
    with a new link in the main navigation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The latest link in the list will forward the user to the `http://localhost:9000/chat`
    URL where he/she will see the interface of the chat.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s handle the `/chat` route by tweaking the `frontend/js/app.js` file.
    Let''s make another addition to our router, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same file, we will require the `frontend/js/controllers/Chat.js` module.
    It will contain the chat logic in the client side. We will start with something
    simple—a basic Ractive.js component, which can be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Like every other controller in our application, `Chat.js` has an associated
    template that contains an empty `<div>` element to display chat messages, a text
    field, and a button to send data to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It is worth a mentioning that if you want to update the content of the `chat-output`
    element, you need to change the value of the `output` variable. The button also
    dispatches a `send` event, and we will catch this in the next section. After the
    compilation of the assets, if you go to the chat''s URL, you will see the following
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing the UI of the chat area](img/image00188.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Exchanging messages between the client and the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are ready to write some working Socket.IO code. So far, we placed code snippets
    that only proved that the socket connection works. For example, the code that
    was added to `frontend/js/app.js` should be moved to `frontend/js/controllers/Chat.js`,
    which is the controller responsible for the chat page. Because it acts as a base
    for this real-time feature, we will start from there. Let''s add a couple of local
    variables to the component, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'These variables have default values, and they are available in the component''s
    template. The first one, `messages`, will keep all the messages that come from
    the users in the chat, including the current user. The `output` variable is used
    to populate the message container on the screen. The last one, `socketConnected`,
    controls the visibility of the text field and the button. If it is set to `false`,
    the controls will be hidden. Before initializing the connection with the server
    or getting disconnected for some reason, it is better to hide the chat input text
    field until the connection with the server is initialized. Otherwise, we may get
    disconnected for some reason. Here is how the updated template looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The difference is the `{{if}}` operator that wraps the field and the button.
    At the end of the chapter, we will colorize the messages, and we will be required
    to pass HTML tags. We will use `{{{output}}}` instead of `{{output}}` so that
    the framework displays them correctly (by turning off autoescaping).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to the frontend controller. We mentioned that the code placed
    in `app.js` moves here. It was the actual connection to the socket server. We
    will extend it in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: After receiving the `connect` event, we will add the `Connected!` string to
    the `messages` array. So, after receiving the **Loading. Please wait.** message,
    the user will see a confirmation that informs him/her that the application has
    established a successful socket connection. By setting `socketConnected` to `true`,
    we reveal the input controls and give an option to the user to send chat messages.
    The last thing in this handler is forcing the browser to focus on the input field,
    a nice little detail that saves a mouse click of the user.
  prefs: []
  type: TYPE_NORMAL
- en: The `socket` object may dispatch another event—`disconnect`. There are two actions
    that we can take in this situation—hiding the input controls and notifying the
    user by showing the `Disconnected!` string in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: The last event that we were listening to was `server-talking`. This is our own
    event—a message that our backend code will dispatch. In the beginning, the `data`
    object will contain only one `text` property, which will be the chat message.
    We will simply append it to the rest of the elements of the `messages` array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lines that we talked about earlier listen to the events that come from
    the backend. Let''s write some code that sends information from the client to
    the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `send` function is called when the user clicks the button. We use the same
    `socket` object and its `emit` method to transfer the text to the server. We also
    clear the content of the input field so that the user can start composing a new
    message. Pressing the button every time is probably annoying. The following code
    triggers the `send` function when the user presses the *Enter* key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `this.find` method returns a valid DOM element. We attach the `keypress`
    listener to the `form` element because the `input` variable is not always visible.
    Thanks to events bubbling, we are able to catch the event in the upper element.
    It is also worth a mention that in some browsers, a different code is required
    to listen to DOM events.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing that we have to take care of is the displaying of the content
    of the `messages` array on the screen. If you check the code that we''ve written
    so far, you will see that we did not update the `output` variable. Here is a new
    component method that will handle this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Instead of looping through all the elements of the array, we use the `join`
    method. It joins all the elements of the array into a string separated by the
    given parameter. In our case, we need a new line after every message. Once we
    start receiving more data, we will need to scroll the `<div>` element down so
    that the user sees the latest ones. The other two lines of the function position
    the scroller of the container at the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `updateOutput` function should be called once a new message arrives. The
    Ractive.js observing is perfect for such cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Only one line is needed to wire the updating of a `messages` array to the `updateOutput`
    method. After this addition, every `push` to the message array will force the
    render of the `chat-output` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the component is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The frontend is ready to send and receive messages through the socket. However,
    the backend still contains the initial example code that we started with. A small
    update of the `Chat` module will make it possible to send messages to the users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We are still listening for the `connection` event. The `socket` object that
    we receive in the handler represents the connection with the user. After this,
    we will start listening to the `client-talking` event that is dispatched by the
    frontend when the user types something in a field or presses the button or the
    *Enter* key. Once the data is received, we broadcast it to all the users in the
    system. The `io.sockets.emit` variable sends a message to all the clients who
    are currently using the server.
  prefs: []
  type: TYPE_NORMAL
- en: Sending messages to the user's friends only
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last change in our backend dispatches the received chat messages to all
    the users in our social network. This is of course not really practical, because
    we may exchange text with people who do not know each other. We have to change
    our code accordingly so that we send messages only to the users in our friends
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Socket.IO, we do not have access to the `request` and `response` objects
    as we do in the backend API by default. This will make the solving of the problem
    a bit more interesting because we can''t recognize the user sending the message.
    Thankfully, Socket.IO gives us access to the active session. It is in a raw format.
    So, we will need to parse it and extract the user''s profile data. To do this,
    we will use the `cookie` Node.js module. Let''s add it to the `package.json` file
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'With another `npm install` in the terminal, we will be able to `require` the
    module. In [Chapter 8](part0054.xhtml#aid-1JFUC1 "Chapter 8. Creating Pages and
    Events"), *Creating Pages and Events*, we refactored our API and created the `backend/api/helpers.js`
    file that contains utility functions. We will add another file similar to `getCurrentUser`
    by using only the `session` object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If we compare both methods, we will see that there are two differences. The
    first difference is that we do not receive the usual request and response objects;
    we receive only a callback and a `session` object. The second change is that the
    result is always sent to the callback even if it is an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Armed with the `getCurrentUserBySessionObj` function, we can modify `backend/Chat.js`
    so that it sends messages only to the friends of the current user. Let''s initialize
    the needed helpers first. We will add the following lines to the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We already talked about the `cookie` module. The session data that is available
    throughout the Socket.IO engine is reachable through `socket.request.headers.cookie`.
    If we print the value in the console, we will get something like the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sending messages to the user''s friends only](img/image00189.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding output is a Base64-encoded string that we definitely cannot directly
    use. Thankfully, Node.js has interfaces to easily decode such values. Here is
    a short function that will extract the needed JSON object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We passed the string from the cookie and received the normal `user` object that
    we will later use in `getCurrentUserBySessionObj`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we have mechanisms to find out who the current user is and who his/her
    friends are. All we have to do is cache the available socket connections and associated
    users. We will introduce a new global (for the module) `users` variable. It will
    act as a hash map where the key will be the ID of the user and the value will
    contain the socket and the friends. In order to broadcast messages to the right
    users, we can summarize the logic in the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This code provides a function that accepts the ID of a user and the text message.
    We will first check whether a socket reference is cached. If it is, then we will
    make sure that the user has friends. If this is valid too, then we will start
    dispatching messages. The first `emit` item is to the user himself/herself so
    that he/she receives his/her own message. The rest of the code loops over the
    friends and sends the text to all of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We, of course, have to update the code that accepts the socket connection.
    Here is the new version of the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We will now fetch the cookie value and determine the current user. The `socket`
    object and the user's friends are cached. Then, we will continue listening for
    the `client-talking` event, but now, we will send messages via the `broadcastMessage`
    function. A small but very important addition is made towards the end; we listen
    for the `disconnect` event and remove the cached data. That is needed to prevent
    sending data to the disconnected users.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the output of the chat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is nice that we can send messages to the right people, but the chat is still
    a bit confusing because every text message that appears on the screen is in the
    same color and we don't know which of our friends sent it. In this section, we
    are going to make two improvements—we will append the user's name to the front
    of the message and colorize the text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the colors and add a new helper method to the `backend/api/helpers.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function generates a valid RGB color that is ready for use in
    CSS. The right moment for you to pick a color for the user is when you cache the
    `socket` object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: So, along with the `socket` object and `friends`, we store a randomly picked
    color. There is another small update. We no longer pass the user's ID to the `broadcastMessage`
    function. We send the whole object because we need to fetch the first and last
    name of the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the updated `broadcastMessage` helper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now, the `data` object that goes to the client contains two additional properties—the
    name of the current user and his/her randomly picked color.
  prefs: []
  type: TYPE_NORMAL
- en: 'The backend does its job. All we have to do now is tweak the frontend controller
    so that it uses the name and color, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Instead of sending only text, we wrap the message in a `<span>` tag. It has
    a text color applied. Also, the message starts with the name of the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final result of our work looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing the output of the chat](img/image00190.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Socket.IO is one of the most popular Node.js tools used to develop real-time
    applications. In this chapter, we successfully used it to build an interactive
    chat. The users in our network were able to not only post content that appeared
    in their feeds but also exchange messages with other users in real time. The WebSockets
    technology made this possible.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is dedicated to testing. We will learn about a few popular
    modules that will help us write tests.
  prefs: []
  type: TYPE_NORMAL
