- en: Real-Time Web Application Functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we considered how we could validate and process user-generated
    data through a web form. When the user properly filled out the contact form, it
    successfully cleared two rounds of validation, and the user was presented with
    a confirmation message. Once the form had been submitted, the workflow was complete.
    What if we wanted to consider a more engaging workflow, one where the user could
    engage with the server-side application, perhaps, in a conversation-like manner?
  prefs: []
  type: TYPE_NORMAL
- en: The web of today is far different from the nascent web that Tim Berners-Lee
    devised in the early 1990s. Back then, the emphasis on the Web was to hyperlink
    connected documents. The HTTP transaction between the client and the server had
    always meant to be short-lived.
  prefs: []
  type: TYPE_NORMAL
- en: In the early 2000s, this started to change. Researchers demonstrated the means
    by which the server could maintain a persistent connection with the client. Early
    prototypes on the client side were created using Adobe Flash, one of the only
    technologies available at the time, to make a persistent connection between the
    web server and the web client.
  prefs: []
  type: TYPE_NORMAL
- en: In parallel to these early attempts, an era of inefficiency was born in the
    form of AJAX (XHR) long polling. The client would keep making calls to the server
    (similar to a heartbeat check), and check whether the state of something the client
    was interested in had changed. The server would return the same, tired response
    until the state that the client was interested in changed, which could be reported
    back to the client. The major inefficiency of this approach is the sheer amount
    of network calls that have to be made between the web client and the web server.
    Unfortunately, the inefficient practice of AJAX long polling became so popular,
    that it is still widely used by many websites today.
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind real-time web application functionality is to provide a far
    greater user experience by providing information in near real-time. Keep in mind
    that with network latency and the limitations on signals imposed by the laws of
    physics, no communication is ever conducted in *real time* but ,rather, in *near
    real time*.
  prefs: []
  type: TYPE_NORMAL
- en: The primary ingredient to implement real-time web application functionality
    is the WebSocket, a protocol allowing for bidirectional communication between
    the web server and the web client. Go makes for an ideal programming language
    to implement real-time web applications due to the built-in capabilities it possesses
    for both networking and web programming.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will build a live chat application that demonstrates real-time
    web application functionality, which will allow the website user to converse with
    a rudimentary chatbot. As the user asks questions to the bot, the bot will respond
    in real time, and all communication between the user and the bot will be performed
    over a  WebSocket connection between the web browser and the web server.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The live chat feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the live chat's server-side functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the live chat's client-side functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conversing with the agent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The live chat feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's common nowadays to see chatbots (also known as agents) service the needs
    of website users for a wide variety of purposes, from deciding what shoes to purchase
    to providing tips on what stocks would look good on a client's portfolio, for
    example. We will build a rudimentary chatbot, that will provide some friendly
    tips on Isomorphic Go to IGWEB users.
  prefs: []
  type: TYPE_NORMAL
- en: Once the live chat feature is activated, the user can continue to access different
    sections of the website without having their conversation with the bot interrupted,
    provided that the user utilizes the navigation menu on the website or links found
    on the website that are routed on the client side. In a real-world scenario, this
    functionality would be an attractive proposition for both product sales and technical
    support usage scenarios. For instance, if a user has a particular question on
    a product listed on the website, the user can freely browse through the website,
    without worrying about losing their current chat conversation with the agent.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the agent that we will build has a low intelligence level.
    The agent is presented here for illustration purposes only, and a far more robust
    **Artificial Intelligence** (**AI**) solution should be utilized for production
    needs. With the knowledge you will gain from this chapter, it should be fairly
    straightforward to replace the current agent's brain with a more robust one that
    will meet your specific needs in the live chat feature.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the live chatbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following diagram is a wireframe design depicting the top bar of IGWEB.
    The icon at the far right, will active the live chat feature when it is clicked
    on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e3c6a10-56a1-4066-919b-6f8bd0060092.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: Wireframe design depicting IGWEB''s top bar'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram is a wireframe design depicting the live chat box. The
    chat box consists of an avatar image of the agent named "Case" along with its
    name and title. A close button is included in the top-right corner of the chat
    box. Users may enter their message to the agent in the bottom text area that has
    the placeholder text Type your message here. The conversation with the human and
    the bot will be presented in the middle area of the chat box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/882b8a7c-655f-4dd8-9e42-da1d856c53d8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: Wireframe design of the live chat box'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the live chat box templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to have the chat box present in all sections of the website, we will
    need to place the chat box `div` container right below the primary content `div` container
    in the web page layout template (`layouts/webpage_layout.tmpl`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The chat box will be implemented as a partial template in the `chatbox_partial.tmpl`
    source file in the `shared/templates/partials` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the HTML markup required to implement the wireframe design depicted
    in *Figure 8.2* of the live chat box. Note that the `input` textfield having the
    id `"chatboxInputField"`. This is the `input` field where the user will be able
    to type their message. Each message created, both the one that the user writes,
    as well as the one that the bot writes, will use the `livechatmsg_partial.tmpl`
    template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Each message is inside its own `div` container that has two `div` containers
    (shown in bold) housing the name of the sender of the message and the message
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: There are no buttons necessary in the live chat feature, since we will be adding
    an event listener to listen for the press of the Enter key to submit the user's
    message to the server over the WebSocket connection.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've implemented the HTML markup that will be used to render the chat
    box, let's examine the functionality required to implement the live chat feature
    on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the live chat's server-side functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the live chat feature is activated, we will create a persistent, WebSocket
    connection, between the web client and the web server.  The Gorilla Web Toolkit
    provides an excellent implementation of the WebSocket protocol in their `websocket`
    package, which can be found at [http://github.com/gorilla/websocket](http://github.com/gorilla/websocket).
    To fetch the `websocket` package, you may issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The Gorilla web toolkit also provides a useful example web chat application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/gorilla/websocket/tree/master/examples/chat](https://github.com/gorilla/websocket/tree/master/examples/chat).'
  prefs: []
  type: TYPE_NORMAL
- en: Rather than reinventing the wheel, we will repurpose Gorilla's example web chat
    application to fulfill the live chat feature. The source files needed from the
    web chat example have been copied over to the `chat` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three major changes we need to make to realize the live chat feature
    using the example chat application provided by Gorilla:'
  prefs: []
  type: TYPE_NORMAL
- en: Replies from the chatbot (the agent) should be targeted to a specific user,
    and not be sent out to every connected user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to create the functionality to allow the chatbot to send a message back
    to the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to implement the front-end portion of the chat application in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's consider each of these three points in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: First, Gorilla's web chat example is a free-for-all chat room. Any user can
    come in, type a message, and all other users connected to the chat server will
    be able to see the message. A major requirement for the live chat feature is that
    each conversation between the chatbot and the human should be exclusive. Replies
    from the agent must be targeted to a specific user, and not to all connected users.
  prefs: []
  type: TYPE_NORMAL
- en: Second, the example web chat application from the Gorilla web toolkit doesn't
    send any messages back to the user. This is where the custom chatbot comes into
    the picture. The agent will communicate directly with the user over the established
    WebSocket connection.
  prefs: []
  type: TYPE_NORMAL
- en: Third, the front-end portion of the example web chat application is implemented
    as a HTML document containing inline CSS and JavaScript. As you may have guessed
    already, we will implement the front-end portion for the live chat feature in
    Go, and the code will reside in the `client/chat` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have established our plan of action to implement the live chat feature
    using the Gorilla web chat example as a foundation to start from, let's begin
    the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The modified web chat application that we will create contains two main types:
    `Hub` and `Client`.'
  prefs: []
  type: TYPE_NORMAL
- en: The hub type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The chat hub is responsible for maintaining a list of client connections and
    directing the chatbot to broadcast a message to the relevant client. For example,
    if Alice asked the question "What is Isomorphic Go?*"*, the answer from the chatbot
    should go to Alice and not to Bob (who may not have even asked a question yet).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the `Hub` struct looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `chatbot` is a chat bot (agent) that implements the `Bot` interface. This
    is the brain that will answer the questions received from clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `clients` map is used to register clients. The key-value pair stored in
    the `map` consists of the key, a pointer to a `Client` instance, and the value
    consists of a Boolean value set to `true` to indicate that the client is connected.
    Clients communicate with the hub over the `broadcastmsg`, `register`, and `unregister`
    channels. The `register` channel registers a client with the hub. The `unregister`
    channel, unregisters a client with the hub. The client sends the message entered
    by the user over the `broadcastmsg` channel, a channel of type `ClientMessage`.
    Here''s the `ClientMessage` struct that we have introduced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: To fulfill the first major change we laid out previously, that is, the exclusivity
    of the conversation between the agent and the user, we use the `ClientMessage`
    struct to store, both the pointer to the `Client` instance that sent the user's
    message along with the user's message itself (a `byte` slice).
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor function, `NewHub`, takes in `chatbot` that implements the
    `Bot` interface and returns a new `Hub` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We implement an exported getter method, `ChatBot`, so that the `chatbot` can
    be accessed from the `Hub` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This action will be significant when we implement a Rest API endpoint to send
    the bot's details (its name, title, and avatar image) to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SendMessage` method is responsible for broadcasting a message to a particular
    client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The method takes in a pointer to `Client`, and the `message`, which is a `byte`
    slice, that should be sent to that particular client. The message will be sent
    over the client's `send` channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Run` method is called to start the chat hub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We use the `select` statement inside the `for` loop to wait on multiple client
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: In the case that a pointer to a `Client` comes in over the hub's `register`
    channel, the hub will register the new client by adding the `client` pointer (as
    the key) to the clients `map` and set a value of `true` for it. We will fetch
    a `greeting` message to return to the client by calling the `Greeting` method
    on `chatbot`. Once we get the greeting (a string value), we call the `SendMessage`
    method passing in the `client` and the `greeting` converted to a `byte` slice.
  prefs: []
  type: TYPE_NORMAL
- en: In the case that a pointer to a `Client` comes in over the hub's `unregister`
    channel, the hub will remove the entry in `map` for the given `client` and close
    the client's `send` channel, which signifies that the `client` won't be sending
    any more messages to the server.
  prefs: []
  type: TYPE_NORMAL
- en: In the case that a pointer to a `ClientMessage` comes in over the hub's `broadcastmsg`
    channel, the hub will pass the client's `message` (as a string value) to the `Reply`
    method of the `chatbot` object. Once we get `reply` (a  string value) from the
    agent, we call the `SendMessage` method passing in the `client` and the `reply`
    converted to a `byte` slice.
  prefs: []
  type: TYPE_NORMAL
- en: The client type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Client` type acts as a broker between  `Hub` and the `websocket` connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the `Client` struct looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Each `Client` value contains a pointer to `Hub`, a pointer to a `websocket`
    connection, and a buffered channel, `send`, meant for outbound messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `readPump` method is responsible for relaying inbound messages coming in
    over the `websocket` connection to the hub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We had to make a slight change to this function to fulfill the requirements
    of the live chat feature. In the Gorilla web chat example, the message alone was
    relayed over to `Hub`. Since we are directing chat bot responses, back to the
    client that sent them, not only do we need to send the message to the hub, but
    also the client that happened to send the message (shown in bold). We do so by
    creating a `ClientMessage` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `ClientMessage` struct contains fields to hold both the pointer to the client
    as well as the `message`, a `byte` slice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to the `readPump` function in the `client.go` source file, the following
    two lines are instrumental in allowing the `Hub` to know which client sent the
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `writePump` method is responsible for relaying outbound messages from the
    client''s `send` channel over the `websocket` connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ServeWS` method is meant to be registered as an HTTP handler by the web
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This method performs two important tasks. The method upgrades the normal HTTP
    connection to a `websocket` connection and registers the client to the hub.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've set up the code for our web chat server, it's time to activate
    it in our web application.
  prefs: []
  type: TYPE_NORMAL
- en: Activating the chat server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `igweb.go` source file, we have included a function called `startChatHub`,
    which is responsible for starting the `Hub`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We add the following code in the `main` function to create a new chatbot, associate
    it with the `Hub`, and start the `Hub`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When we call the `registerRoutes` function to register all the routes for the
    server-side web application, note that we also pass in the `hub` value to the
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `registerRoutes` function, we need the `hub` to register the route handler
    for the Rest API endpoint that returns the agent''s information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We will go over this endpoint in the section, *Exposing the agent's information
    to the client*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `hub` is also used to register the route handler for the WebSocket route,
    `/ws`. We register the `ServeWS` handler function, passing in the `hub`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have everything in place to activate the chat server, it's time
    to focus on the star of the live chat feature—the chat agent.
  prefs: []
  type: TYPE_NORMAL
- en: The agent's brain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The chat bot type that we will use for the live chat feature, `AgentCase`,
    will implement the following `Bot interface`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `Greeting` method will be used to send an initial greeting to the user,
    enticing them to interact with the chat bot.
  prefs: []
  type: TYPE_NORMAL
- en: The `Reply` method accepts a question (a string) and returns a reply (also a
    string) for the given question.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the methods implemented are for purely psychological reasons to
    give humans the illusion that they are communicating with someone, rather than
    something.
  prefs: []
  type: TYPE_NORMAL
- en: The `Name` method is a getter method that returns the chat bot's name.
  prefs: []
  type: TYPE_NORMAL
- en: The `Title` method is a getter method that returns the chat bot's title.
  prefs: []
  type: TYPE_NORMAL
- en: The `ThumbnailPath` method is a getter method that returns the path to the chat
    bot's avatar image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the getter methods has a corresponding setter method: `SetName`, `SetTitle`,
    and `SetThumbnailPath`.'
  prefs: []
  type: TYPE_NORMAL
- en: By defining the `Bot` interface, we are clearly stating the expectations of
    a chat bot. This allows us to make the chat bot solution extensible in the future.
    For example, the intelligence that `Case` exhibits may be too rudimentary and
    limiting. In the near future, we may want to implement a bot named Molly, whose
    intelligence may be implemented using a more powerful algorithm. As long as the
    Molly chat bot implements the `Bot` interface, the new chat bot can be easily
    plugged into our web application.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, from the perspective of the server-side web application, it would just
    be a one-line code change. Instead of instantiating an `AgentCase` instance, we
    would instantiate an `AgentMolly` instance instead. Besides the difference in
    intelligence, the new chat bot, Molly, would come with its own name, title, and
    avatar image, so humans would be able to differentiate it from `Case`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the `AgentCase` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We have embedded the `Bot` interface to the `struct` definition, indicating
    that the `AgentCase` type will implement the `Bot` interface. The field `name`
    is for the name of the agent. The field `title` is for the title of the agent.
    The field `thumbnailPath` is used to specify the path to the chat bot's avatar
    image.
  prefs: []
  type: TYPE_NORMAL
- en: The `knowledgeBase` field is  `map` of type `map[string]string`. This is essentially
    the agent's brain. Keys in the `map` are the common terms found in a particular
    question. Values in the `map` are the answers to the question.
  prefs: []
  type: TYPE_NORMAL
- en: The `knowledgeCorpus` field, a string `byte` slice, is a knowledge corpus of
    the terms that may exist in questions that the bot will be asked. We use the keys
    of the `knowledgeBase` map to construct the `knowledgeCorpus`. A corpus is a collection
    of text that is used to conduct linguistic analysis. In our case, we will conduct
    the linguistic analysis based on the question (the query) that the human user
    provided to the bot.
  prefs: []
  type: TYPE_NORMAL
- en: The `sampleQuestions` field, a string `byte` slice, will contain a list of sample
    questions that the user may ask the chat bot. The chat bot will provide the user
    with a sample question when it greets them to entice the human user into a conversation.
    It is understood that the human user is free to paraphrase the sample question
    or ask an entirely different question depending on their preference.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `initializeIntelligence` method is used to initialize Case''s brain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three important tasks that occur within this method:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we set Case's knowledge base.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, we set Case's knowledge corpus.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third, we set the sample questions, which Case will utilize when greeting the
    human user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first task we must take care of is to set Case''s knowledge base. This
    consists of setting the `knowledgeBase` property of the `AgentCase` instance.
    As mentioned earlier, the keys in the `map` refer to terms found in the question,
    and the values in the `map` are the answers to the question. For example, the
    `"isomorphic go isomorphic go web applications"` key could service the following
    questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What is Isomorphic Go?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What can you tell me about Isomorphic Go?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It can also service statements that aren''t questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Tell me about Isomorphic Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Give me the rundown on Isomorphic Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Due to the the large amount of text contained within the map literal declaration
    for the `knowledgeBase` map, I encourage you to view the source file, `agentcase.go`,
    on a computer.
  prefs: []
  type: TYPE_NORMAL
- en: The second task we must take care of is to set Case's corpus, the collection
    of text used for linguistic analysis used against the user's question. The corpus
    is constructed from the keys of the `knowledgeBase` map. We set the `knowledgeCorpus`
    field property of the `AgentCase` instance to a newly created string `byte` slice
    using the built-in `make` function. Using a `for` loop, we iterate through all
    the entries in the `knowledgeBase map` and append each key to the `knowledgeCorpus`
    field slice.
  prefs: []
  type: TYPE_NORMAL
- en: The third and last task we must take care of is to set the sample questions
    that `Case` will present to the human user. We simply populate the `sampleQuestions`
    property of the `AgentCase` instance. We use the string literal declaration to
    populate all the sample questions that are contained in the string `byte` slice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the getter and setter methods of the `AgentCase` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: These methods are used to get and set the name, title, and `thumbnailPath` fields
    of the `AgentCase` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the constructor function used to create a new `AgentCase` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We declare and initialize the `agentCase` variable with a new `AgentCase` instance,
    setting the fields for `name`, `title`, and `thumbnailPath`. We then call the
    `initializeIntelligence` method to initialize Case's brain. Finally, we return
    the newly created and initialized `AgentCase` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Greeting the human
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Greeting` method is used to provide a first-time greeting to the user
    when the live chat feature is activated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Since the greeting will include a randomly selected sample question that can
    be asked to Case, the `randomNumber` function is called to obtain the index number
    of the sample question. We pass the minimum value and the maximum value to the
    `randomNumber` function to specify the range that the produced random number should
    be in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the `randomNumber` function used to generate a random number within
    a given range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Returning to the `Greeting` method, we get the sample question retrieved from
    the `sampleQuestions` string slice using the random index. We then assign the
    sample question to the `greeting` variable and return `greeting`.
  prefs: []
  type: TYPE_NORMAL
- en: Replying to a human's question
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've initialized the intelligence of the chat bot and prepared it
    to greet the human user, it's time to guide the chat bot on how to think about
    a user's question so that the chat bot may offer a sensible reply.
  prefs: []
  type: TYPE_NORMAL
- en: The replies that the chat bot will send to the human user are limited to those
    found as the values in the `knowledgeBase` map of the `AgentCase` struct. If the
    human user asks a question outside the scope of what the chat bot knows (the knowledge
    corpus), it will simply reply with the message `"I don't know the answer to that
    one."`
  prefs: []
  type: TYPE_NORMAL
- en: To analyze the user's question and provide the best reply for it, we will be
    using the `nlp` package, which contains a collection of machine learning algorithms
    that can be used for basic natural language processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install the `nlp` package by issuing the following `go get` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go over the `Reply` method piece by piece, starting with the method
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The function takes in a question string and returns an answer string for the
    given question.
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare the `result` variable that represents the answer to the user''s
    question:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `result` variable will be returned by the `Reply` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `nlp` package, we create a new `vectoriser` and a new `transformer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The **`vectoriser`** will be used to encode the query terms from the knowledge
    corpus into a term document matrix, where each column will represent a document
    within the corpus, and each row represents a term. It is used to keep track of
    the frequency of terms found within a particular document. For our usage scenario,
    you may consider the document as the unique entry found in the `knowledgeCorpus`
    string slice.
  prefs: []
  type: TYPE_NORMAL
- en: The `transformer` will be used to remove bias of frequently appearing terms
    in `knowledgeCorpus` . For example, words that are repeated across `knowledgeCorpus`
    such as *the*, *and*, and *web* will have a lesser weight. The transformer is
    a **TFIDF (term frequency inverse document frequency)** transformer.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then proceed to create `reducer`, which is a new `TruncatedSVD` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `reducer` that we just declared is significant, since we will be performing
    **Latent Semantic Analysis** (**LSA**), also known as **Latent Semantic Indexing**
    (**LSI**), for the search and retrieval of the proper document to the users's
    query term. LSA helps us find semantic attributes that exist within a corpus based
    on the co-occurrence of terms. It assumes that words that frequently appear together
    must have some semantic relation.
  prefs: []
  type: TYPE_NORMAL
- en: The `reducer` is used to find semantic meaning that may be hidden beneath the
    term frequencies within the document feature vectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is a pipeline that transforms the corpus into a Latent Semantic
    Index, which fits the models to the documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to run the user''s query through the same pipeline so that it is projected
    in the same dimensional space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have `lsi` and the `queryVector` in place, it is time to find the
    document that best matches the query term. We do so by calculating the cosine
    similarity of each document in our corpus against the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The **cosine similarity** calculates the difference between the angles of two
    numerical vectors.
  prefs: []
  type: TYPE_NORMAL
- en: The document in the corpus having the highest similarity with the user's query
    will be matched as the best document that reflects the user's question. The possible
    values for the cosine similarity can fall between the range of 0 to 1\. A 0 value
    indicates complete orthogonality and a 1 value indicates a perfect match. The
    cosine similarity value can also be a **NaN (not a number)** value. The NaN value
    is indicative that there is no match at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `highestSimilarity` value will be `-1` if no match was found; otherwise,
    it will be a value between 0 and 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the `if` conditional block, we check whether the `highestSimilarity` value
    is `-1`; if it is, the answer to the user will be `"I don't know the answer to
    that one."`.
  prefs: []
  type: TYPE_NORMAL
- en: If we reach the `else` block, it indicates that the `highestSimilarity` is a
    value between 0 and 1, indicating that a match was found. Recall that the document
    in our `knowledgeCorpus` has a corresponding key in the `knowledgeBase` `map`.
    The answer to the user's question is the value in the `knowledgeBase` `map` with
    the provided key, and we set the `result` string to this value. In the last line
    of code in the method, we return the `result` variable.
  prefs: []
  type: TYPE_NORMAL
- en: The logic to implement the chatbot's intelligence was inspired from James Bowman's
    article, *Semantic analysis of webpages with machine learning in Go* ([http://www.jamesbowman.me/post/semantic-analysis-of-webpages-with-machine-learning-in-go/](http://www.jamesbowman.me/post/semantic-analysis-of-webpages-with-machine-learning-in-go/)).
  prefs: []
  type: TYPE_NORMAL
- en: Exposing the agent's information to the client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've implemented the chat agent, `AgentCase`, we need a way to expose
    Case's information to the client, notably, its name, title, and the path to its
    avatar image.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a new Rest API endpoint, `GetAgentInfoEndpoint`, to expose the chat
    agent''s information to the client-side web application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note that in the signature of the `GetAgentInfoEndpoint` function, we accept
    the `env` object and the `chatbot` object. Note that the `chatbot` is of type
    `bot.Bot`, an interface type, rather than the `AgentCase` type. This provides
    us with the flexibility to easily swap in another bot, such as `AgentMolly`, instead
    of `AgentCase`, in the future.
  prefs: []
  type: TYPE_NORMAL
- en: We simply create a map, `m`, of type `map[string]string`, containing the bot's
    name, title, and avatar image path. We set a header to indicate that the server
    response will be in the JSON format. Finally, we write out the JSON encoded `map`
    using `http.ResponseWriter`, `w`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the live chat's client-side functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've covered the server-side functionality needed to implement the
    chat bot, it's time focus on the live chat feature from the perspective of the
    client-side web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `InitialPageLayoutControls` function, we add an `event` listener
    on the `click` event to the live chat icon found on the top bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: If the live chat feature has already been activated, the `chatbox` div element
    will already exist, that is, it will be a non-nil value. In this scenario, we
    return from the function.
  prefs: []
  type: TYPE_NORMAL
- en: However, in the case that the live chat feature has not been activated yet,
    we call the `StartLiveChat` function located in the `chat` package as a goroutine,
    passing in the `env` object. Calling this function, will activate the live chat
    feature.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the live chat client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use the `gopherjs/websocket/websocketjs` package to create a WebSocket
    connection that will be used to connect to the web server instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install this package using the following `go get` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The client-side implementation of the live chat feature can be found in the
    `client/chat/chat.go` source file. We define the `ws` variable of the type `websocketjs.WebSocket` and
    the `agentInfo` variable of type `map[string]string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We also declare a constant that represents the key code for the Enter key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GetAgentInfoRequest` function is used to obtain the agent information
    from the `/restapi/get-agent-info` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Once we retrieve the JSON encoded data from the server, we decode it to `map`
    of type `map[string]string`. We then send the `agentInfo map` over the channel,
    `agentInfoChannel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `getServerPort` function is a helper function to obtain the port the server
    is running on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This function is used when constructing the `serverEndpoint` string variable
    inside the `StartLiveChat` function, which represents the server endpoint that
    we'll be making the WebSocket connection to.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user clicks on the live chat icon in the top bar, the `StartLiveChat`
    function will be called as a goroutine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We first start out by fetching the agent's info by calling the `GetAgentInfoRequest` function
    as a goroutine. The agent's  information will be sent as a map of the type `map[string]string` over
    the `agentInfoChannel` channel. The `agentInfo` `map` will be used as the data
    object that is passed to the `partials/chatbox_partial` template to display the
    agent's details (name, title, and avatar image).
  prefs: []
  type: TYPE_NORMAL
- en: 'We then proceed to create a new WebSocket connection and connect to the server
    endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We use the helper `getServerPort` function to get the port that the server is
    running on. The server port value is used when constructing the `serverEndpoint`
    string variable, which represents the WebSocket address of the server endpoint
    we will be connecting to.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `env.Document` object''s `GetElementByID` method to get the chat
    container `div` element by suppling the ID of `"chatboxContainer"`. We also add
    a CSS animated style to make the chat box container pulsate for a dramatic effect
    when the chatbot is available to answer questions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We call the `Render` method of the template set object, rendering the `"partials/chatbox_partial"`
    template and supplying the template render parameters. We specify that the data
    object that is to be fed to the template will be the `agentInfo` map. We specify
    that the disposition of the rendering should be to replace the inner HTML contents
    of the associated element with the rendered template output. Finally, we specify
    that the associated element to render to is the `chatContainer` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the live chat feature is functional and the WebSocket connection to the
    server is connected, then the chat box header bar, the strip containing the chat
    box title, the `chatboxHeaderBar`, will be colored green. If the WebSocket connection
    has been disconnected or there is an error, the strip will be colored red. By
    default, the strip will be colored green when we set the default CSS class of
    the `chatboxHeaderBar` to `"chatboxHeader"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Initializing the event listeners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we call the `InitializeChatEventHandlers` function, passing in the
    `env` object, to initialize the event handlers for the live chat feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `InitializeChatEventHandlers` function is responsible for setting up all
    the event listeners required by the live chat feature. There are two controls
    that require user interaction. The first is the message `input` field, where the
    user types and sends their questions by hitting the Enter key. The second is the
    close button, the X, that's found on the upper right hand corner of the chat box,
    used to close the live chat feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle the user interaction with the message `input` field, we set up the
    `keypress` event listener, which will detect a `keypress` event inside the message
    `input` textfield element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We fetch the `input` message textfield element by calling the `GetElementByID`
    method on the `env.Document` object. We then attach a `keypress` event listener
    function to the element. If the key that the user presses is the Enter key, then
    we will prevent the default behavior of the `keypress` event and call the `ChatSendMessage`
    function, as a goroutine, passing in the `env` object and the `Value` property
    of the `msgInput` element. Finally, we clear the text in the message input field
    by setting its `Value` property to the empty string value.
  prefs: []
  type: TYPE_NORMAL
- en: The close chat control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To handle the user interaction when clicking on the X control to close the
    live chat feature, we set up an event listener to handle the click event of the
    close control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We get the `div` element that represents the close control by calling the `GetElementByID`
    method on the `env.Document` object, specifying the ID `"chatboxCloseControl"`.
    We attach an event listener, to the close control, on the `click` event, which
    will call the `CloseChat` function.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up event listeners for the WebSocket object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve set up the event listeners for the user interactions, we must
    set up event listeners on the WebSocket object, `ws`. We first add an event listener
    on the `message` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `message` event listener will be triggered when a new message comes across
    the WebSocket connection. This is indicative of the agent sending a message back
    to the user. In this situation we call the `HandleOnMessage`, function, passing
    in the `env` object and the event object, `ev`, to the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other event we have to listen for from the WebSocket object is the `close` event.
    This event can be triggered from a normal operating scenario, such as the user
    closing the live chat feature using the close control. The event can also be triggered
    from an abnormal operating scenario, such as the web server instance suddenly
    going down, breaking off the WebSocket connection. Our code must be intelligent
    enough to fire only in the abnormal connection closing scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We do so by first fetching the chatbox container `div` element. If the number
    of child nodes within the chatbox container is greater than zero, it means that
    the connection has abnormally closed while the user is using the live chat feature,
    and we must call the `HandleDisconnection` function, as a goroutine, passing in
    the `env` object to the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'There may be certain scenarios, where the close event will not fire, such as
    when we lose internet connectivity. The TCP connection that the WebSocket connection
    is communicating over, may still be considered to be live even though the internet
    connection has been disconnected. In order for our live chat feature to be resilient
    to handle this scenario, we need to listen for the `env.Window` object''s `offline` event,
    which will fire when the network connection is lost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We perform the same action as we did previously to handle this event. We call
    the `HandleDisconnection` function, as a goroutine, passing in the `env` object
    to the function. Take note that the last closing brace, `}`, indicates the end
    of the `InitializeChatEventHandlers` function.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have set up all the necessary event listeners for the live chat
    feature, it's time to examine each function that was called by the event listeners
    we just set up.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ChatSendMessage` function is called after the user hits the Enter key
    inside the message `input` textfield:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We call the `Send` method of the WebSocket object, `ws`, to send the user's
    question over to the web server. We then call the `UpdateChatBox` function to
    render the user's message to the chat box's conversation container. We pass in
    the `env` object, `message` the user wrote, and the `sender` string as input values
    to the `UpdateChatBox` function. The `sender` string is the person who sent the
    message; in this case, since the user sent it, the `sender` string will be `"Me"`.
    The `sender` string helps the user differentiate between messages the user sent
    versus messages the chatbot replied with.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `UpdateChatBox` function is used to update the chat box conversation container
    area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We create a new map of the `map[string]string` type, which will be used as the
    data object that will be fed to the `partials/livechatmsg_partial` template. The
    map consists of an entry with the key `"Name"` to represent `sender` and an entry
    with the key `"Message"` for the `message`. The values for both the `"Name"` and
    the `"Message"` will be displayed in the chat box's conversation container area.
  prefs: []
  type: TYPE_NORMAL
- en: We obtain the element for `conversationContainer` by calling the `env.Document`
    object's `GetElementByID` method and specifying the `id` value of `"chatboxConversationContainer"`.
  prefs: []
  type: TYPE_NORMAL
- en: We call the `Render` method of the `env.TemplateSet` object and specify that
    we want to render the `partials/livechatmsg_partial` template. In the render parameters
    (`RenderParams`) object, we set the `Data` field to the `map`, `m`. We set the
    `Disposition` field to `isokit.PlacementAppendTo` to specify that the disposition
    operation will be an *append to* operation relative to the associated element.
    We set the `Element` field to the `conversationContainer`, since this is the element
    where the chat messages will be appended to.
  prefs: []
  type: TYPE_NORMAL
- en: The final two lines in the function will auto-scroll the `conversationContainer`
    all the way to the bottom upon rendering a new message so that the most recent
    message will always be displayed to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the `ChatSendMessage` function, the other utilizer of the `UpdateChatBox`
    function is the `HandleOnMessage` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Recall that this function will be called upon the `"message"` event being fired
    from the WebSocket connection. We fetch the response from the chatbot, communicated
    over the WebSocket connection, by getting the string value of the `data` property
    of the `event` object. We then call the `UpdateChatBox` function passing in the
    `env` object, the `response` string, and the `sender` string, `agentInfo["AgentName"]`.
    Note that we have passed the name of the agent, the value in the `agentInfo` `map`
    obtained using the `"AgentName"` key, as the `sender` string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CloseChat` function is used to close the web socket connection and dismiss
    the chat box from the user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We first call the `Close` method on the WebSocket object. We get the `chatboxContainer`
    element and remove its first child node, which will subsequently remove all the
    children of the first child node.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that this function will be called either when the user hits the
    X control in the chat box, or in the scenario of an abnormal WebSocket connection
    termination encountered while the live chat feature is open.
  prefs: []
  type: TYPE_NORMAL
- en: Handling a disconnection event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This leads us to the last function, `HandleDisconnection`, which is called
    either on an abnormal WebSocket connection close event or when the internet connection
    has been disconnected, that is, when the `wenv.Window` object fires an `offline`
    event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: We first set the CSS `classname` value of the `chatContainer` to empty string,
    using the `SetClass` method, to disable the `chatContainer`  element's pulsate
    effect to indicate that the connection has been broken.
  prefs: []
  type: TYPE_NORMAL
- en: We we then change the background color of `chatboxHeaderBar` to red by setting
    the `chatboxHeaderBar` element's CSS `classname` value to `"chatboxHeader disconnected"` using
    the `SetClass` method.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining code will present the user with a message indicating that the
    connection has been disconnected, and the live chat feature will automatically
    initiate a countdown. The `chatboxHeaderBar` will display the countdown, 5-4-3-2-1,
    by the second, as the live chat feature shuts itself down. We use two goroutines,
    one for the countdown ticker and the other for the countdown timer. When the countdown
    timer has expired, it signifies that the countdown is over, and we call the `CloseChat`
    function passing in the `env` object to close the live chat feature.
  prefs: []
  type: TYPE_NORMAL
- en: Conversing with the agent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we have implemented the server-side and client-side functionality
    to realize the live chat feature, showcasing real-time web application functionality.
    Now it's time to to start up a conversation (question and answer session) with
    the chat agent.
  prefs: []
  type: TYPE_NORMAL
- en: 'After clicking on the live chat icon found on the website''s top bar, we are
    presented with the chat box in the lower right-hand side portion of the web page.
    The following screenshot depicts the chat box with the chat agent''s greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/156fc180-8401-4377-a6a2-e2e39b2bf9fe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: The chat box opens up with a greeting from the chat agent'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can close the live chat box window using the X control in the top-right
    corner of the chat box. We can reactivate the live chat feature by clicking on
    the live chat icon again in the top bar. Instead of asking the chat agent a question
    such as What is Isomorphic Go?, we can actually provide a statement such as Tell
    me more about Isomorphic Go as we have shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c3eafb6a-f985-4e2e-8f24-58389c7c9db6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.4: The chat agent understands an information request even if it isn''t
    a question'
  prefs: []
  type: TYPE_NORMAL
- en: The question and answer session between the human user and the chat agent can
    continue for as long as the human user wishes, as shown in the next screenshot.
    This is perhaps the greatest strength of a chat agent—it has unlimited patience
    when dealing with humans.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd3b7d18-d40e-4fb8-990c-53fe05c5a7dc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.5: The question and answer session can continue as long as the human
    wants it to'
  prefs: []
  type: TYPE_NORMAL
- en: 'The chat agent we have implemented has an extremely narrow and limited set
    of intelligence. The chat agent will admit that it doesn''t know the answer, when
    the human user asks a question outside of the scope of its intelligence, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ca621a3-a61d-4ba4-8d13-14f02f9e92f4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.6: The chat agent doesn''t have an answer for a question outside the
    scope of its intelligence'
  prefs: []
  type: TYPE_NORMAL
- en: Some human users can be rude to the chat agent. This comes along with the public-facing
    role that the chat agent serves. If we tune the corpus just right, we can have
    our chat agent exhibit a witty reply.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/daf82631-447d-4a5b-acc9-8dbc20cb0fe1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.7: The chat agent exhibiting a witty reply'
  prefs: []
  type: TYPE_NORMAL
- en: 'As noted earlier, we have strategically placed the chat box container outside
    of the primary content area in the web page layout. Having done so, the chat box
    and the conversation with the chat agent, can be continued, as we freely navigate
    through the links of IGWEB, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/08c6306f-7edc-45b9-8f53-b000a8cb82d0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.8: The chat conversation will be retained as the user navigates through
    IGWEB'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the chat conversation is continued even after clicking on the
    Coffee Mug product image to get to the product detail page, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f18de492-5396-4668-855d-b0735549ab42.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.9: The chat conversation has been retained as the user visits the
    product detail page for the coffee mug'
  prefs: []
  type: TYPE_NORMAL
- en: 'A real-time web application depends on a persistent connection to the Internet.
    Let''s see how the live chat feature gracefully handles the scenario where we
    disconnect the Internet connection, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/073b2350-2bbb-4a2e-a245-c88950a9018a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.10: Switching off the internet connection'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the internet connection has been turned off, we immediately are notified
    of the disconnection in the chat box''s header bar as shown in *Figure 8.11*.
    The background color of the chat box header bar turns red and a countdown to close
    the live chat feature is initiated. After the countdown is complete, the live
    chat feature closes itself automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5caf4ba7-a60e-44bb-9380-3e142e10bc86.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.11: The countdown to shutdown the live chat feature appears in the
    chat box''s header bar'
  prefs: []
  type: TYPE_NORMAL
- en: When implementing real-time web application functionality, it's always important
    to consider the scenario of the persistent WebSocket connection being interrupted. By
    having the live chat close down gracefully, when the persistent connection between
    the web client and the web server is interrupted, we have a means to provide a
    *heads up* to the user to disengage with the chat agent.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we implemented real-time web application functionality in the
    form of IGWEB's live chat feature. You learned how to establish a persistent connection
    between the web server and the web client using a WebSocket. On the server-side,
    we introduced you to the `websocket` package from the Gorilla toolkit project.
    On the client-side, we introduced you to the `gopherjs/websocket/websocketjs`
    package from the GopherJS project.
  prefs: []
  type: TYPE_NORMAL
- en: We created a simple, rudimentary chatbot that answers questions posed by users
    in real-time, with the conversation between the human and the bot being relayed
    through the established WebSocket connection. Since the real-time web application
    functionality depends on the persistent connection, we also added code to automatically
    shut down the live chat feature in case of an interrupted internet connection.
  prefs: []
  type: TYPE_NORMAL
- en: We used the `nlp` package to implement the brain of the rudimentary chat agent
    so that it could answer a few questions related to Isomorphic Go. We made our
    chat agent solution extensible, where new bots of varying intelligence could be
    added in the future by defining the `Bot` interface.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](cbb6c046-c40f-4681-a25d-9b979614b2cf.xhtml), *Cogs– Reusable
    Components*, we will explore how to implement reusable interface widgets all across
    IGWEB. Reusable components provide a means to promote greater reusability, and
    they can be used in a plug and play manner. As you will learn, cogs are also efficient,
    making use of a virtual DOM to rerender their content as needed.
  prefs: []
  type: TYPE_NORMAL
