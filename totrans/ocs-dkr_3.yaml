- en: Chapter 3. Configuring Docker Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw all the different commands available in Docker.
    We took a look at examples covering how to pull images, run containers, attach
    images to containers, commit, and push an image to the repositories. We also learned
    how to write Dockerfiles to make building an image a repeatable process.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look closer at gaining control over how our containers
    run. Although Docker containers are sandboxed, this doesn''t prevent a stray rogue
    process in one of the containers from hogging the resources available to other
    containers, including the host. For instance, beware of this command (don''t run
    it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You would fork bomb the container as well as the host you run it on by running
    the preceding command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Wikipedia definition of a *fork bomb* is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"In computing, a fork bomb is a denial-of-service attack wherein a process
    continually replicates itself to deplete available system resources, causing resource
    starvation and slowing or crashing the system."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Since Docker is expected to be used in production, the possibility of one container
    stalling all others would be fatal. So there are mechanisms to limit the amount
    of resources that a container can take ownership of, which we will be looking
    at in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we had a basic introduction to volumes when we talked
    about the `docker` run. We will now explore volumes in more detail and discuss
    why they are important and how to use them best. We will also try to change the
    storage driver being used by the `docker` daemon.
  prefs: []
  type: TYPE_NORMAL
- en: Another aspect is networking. While inspecting running containers, you might
    have noticed that Docker randomly chooses a subnet and allots an IP address (the
    default is usually the range 172.17.42.0/16). We will try to override this by
    setting our own subnet and explore other options available that help manage the
    networking aspects. In many scenarios, we will need to communicate between containers
    (imagine one container running your application and another running your database).
    Since IP addresses are not available at build time, we need a mechanism to dynamically
    discover the services running in other containers. We will be looking at ways
    to achieve this, both when the containers are running in the same host and when
    they are running in different hosts.
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, in this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Constraining resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CPU
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RAM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing data in containers with volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Docker to use a different storage driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring networking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Port forwarding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A custom IP address range
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linking containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linking within the same host using container links
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-host linking using ambassador containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constraining resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is imperative for any tool that promises sandboxing capabilities to provide
    a mechanism to constrain resource allocation. Docker provides mechanisms to limit
    the amount of CPU memory and RAM that a container can use when it is being started.
  prefs: []
  type: TYPE_NORMAL
- en: Setting CPU share
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The amount of CPU share a container takes up can be controlled using the `-c`
    option in the `docker run` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The value, `10`, is the relative priority given to this container with respect
    to other containers. By default, all containers get the same priority, and hence
    the same ratio of CPU processing cycles, which you can check out by running `$
    cat /sys/fs/cgroup/cpu/docker/cpu.shares` (add SSH to the boot2Docker VM before
    doing this if you are on OS X or Windows). However, you can give your own priority
    values when you run containers.
  prefs: []
  type: TYPE_NORMAL
- en: Is it possible to set CPU shares when a container is already running? Yes. Edit
    the file at `/sys/fs/cgroup/cpu/docker/<container-id>/cpu.shares` and enter the
    priority you want to give it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the location mentioned doesn't exist, find out where `cpu` `cgroup` is mounted
    by running the command `$ grep -w cgroup /proc/mounts | grep -w cpu`.
  prefs: []
  type: TYPE_NORMAL
- en: However, this is a hack, and might change in the future if Docker decides to
    change the way CPU sharing is implemented.More information about this can be found
    at [https://groups.google.com/forum/#!topic/docker-user/-pP8-KgJJGg](https://groups.google.com/forum/#!topic/docker-user/-pP8-KgJJGg).
  prefs: []
  type: TYPE_NORMAL
- en: Setting memory limit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similarly, the amount of RAM that a container is allowed to consume can also
    be limited while starting the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, `unit` can be `b`, `k`, `m`, or `g`, representing bytes, kilobytes, megabytes,
    and gigabytes, respectively).
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a unit can be represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This sets a memory limit of 1 GB for the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'As in the case with limiting CPU shares, you can check the default memory limit
    by running this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As the filename states, the preceding code prints the limit in bytes. The value
    shown in the output corresponds to 1.8 x 1010 gigabytes, which practically means
    that there is no limit.
  prefs: []
  type: TYPE_NORMAL
- en: Is it possible to set a memory limit when a container is already running?
  prefs: []
  type: TYPE_NORMAL
- en: 'As with CPU shares, memory limit is enforced by the `cgroup` file, which means
    that we can change the limit on the fly by changing the value of the container''s
    `cgroup` memory file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the location of the `cgroup` file doesn't exist, find out where the file
    is mounted by running `$ grep -w cgroup /proc/mounts | grep -w memory`.
  prefs: []
  type: TYPE_NORMAL
- en: This is also a hack, and might change in the future if Docker decides to change
    the way memory limiting is internally implemented.
  prefs: []
  type: TYPE_NORMAL
- en: More information about this can be found at [https://groups.google.com/forum/#!topic/docker-user/-pP8-KgJJGg](https://groups.google.com/forum/#!topic/docker-user/-pP8-KgJJGg).
  prefs: []
  type: TYPE_NORMAL
- en: Setting a storage limit on the virtual filesystem (Devicemapper)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Limiting disk usage can be a bit tricky. There is no direct way to limit the
    amount of disk space a container can use. The default storage driver, AUFS, doesn't
    support disk quotas, at least not without hacks (the difficulty is because AUFS
    does not have its own block device. Visit [http://aufs.sourceforge.net/aufs.html](http://aufs.sourceforge.net/aufs.html)
    for in-depth information on how AUFS works). At the time of writing this book,
    Docker users who need disk quota opt for the `devicemapper` driver, which will
    allow each container to use up to a certain amount of disk space. But a more generic
    mechanism that works across storage drivers is under progress and may be introduced
    in future releases.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `devicemapper` driver is a Linux kernel framework used to map block devices
    to higher-level virtual block devices.
  prefs: []
  type: TYPE_NORMAL
- en: The `devicemapper` driver creates a `thin` pool of storage blocks based on two
    block devices (think of them as virtual disks), one for data and another for metadata.
    By default, these block devices are created by mounting sparse files as loopback
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **sparse file** is a file that contains mostly empty space. So a sparse file
    of 100 GB might actually just contain a few bytes in the beginning and the end
    (and occupy just these bytes on the disk), and yet be visible to an application
    as a 100 GB file. When reading sparse files, the filesystem transparently converts
    the empty blocks into real blocks filled with zero bytes at runtime. It tracks
    the location of the written and empty blocks through the file's metadata. In UNIX-like
    operating systems, a loopback device is a pseudo-device that makes a file accessible
    as a block device.
  prefs: []
  type: TYPE_NORMAL
- en: A `thin` pool is called so because it only marks storage blocks as used (from
    the pool) when you actually write to the blocks. Each container is provisioned
    a base thin device of a certain size, and the container is not allowed to accumulate
    data more than that size limit.
  prefs: []
  type: TYPE_NORMAL
- en: What are the default limits? The default limit for the `thin` pool is 100 GB.
    But since the loopback device used for this pool is a sparse file, it will initially
    not take up this much space.
  prefs: []
  type: TYPE_NORMAL
- en: The default size limit for the base device created for each container and image
    is 10 GB. Again, since this is sparse, it will not initially take up this much
    space on the physical disk. However, the amount of space it takes up increases
    with the increase in the size limit because, the larger the size of the block
    device, the greater is the (virtual) size of the sparse file, and the metadata
    it needs to store is more.
  prefs: []
  type: TYPE_NORMAL
- en: How can you change these default values? You can change these options using
    the `--storage-opts` option, which is available when running the `docker` daemon,
    with the `dm` (for `devicemapper`) prefix.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before running any of the commands in this section, back up all your images
    with `docker save` and stop the `docker` daemon. It might also be wise to completely
    remove `/var/lib/docker` (the path where Docker stores image data).
  prefs: []
  type: TYPE_NORMAL
- en: Devicemapper configurations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The various configurations available are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dm.basesize`: This specifies the size of the base device, which is used by
    containers and images. By default, this is set to 10 GB. The device created is
    sparse, so it will not initially occupy 10 GB. Instead, it will fill up as and
    when data is written into it, until it reaches the 10 GB limit:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`dm.loopdatasize`: This is the size of the `thin` pool. The default size is
    100 GB. It is to be noted that this file is sparse, so it will not initially take
    up this space; instead, it will fill up gradually as more and more data is written
    into it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`dm.loopmetadatasize`: As mentioned earlier, two block devices are created,
    one for data and another for metadata. This option specifies the size limit to
    use when creating this block device. The default size is 2 GB. This file is sparse
    too, so it will not initially take up the entire size. The recommended minimum
    size is 1 percent of the total pool size:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`dm.fs`: This is the filesystem type to use for the base device. The `ext4`
    and `xfs` filesystems are supported, although `ext4` is taken by default:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`dm.datadev`: This specifies a custom block device to use (instead of loopback)
    for the `thin` pool. If you are using this option, it is recommended to specify
    block devices for both data and metadata to completely avoid using the loopback
    device:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There are more options available, along with a neat explanation of how all of
    this works at [https://github.com/docker/docker/tree/master/daemon/graphdriver/devmapper/README.md](https://github.com/docker/docker/tree/master/daemon/graphdriver/devmapper/README.md).
  prefs: []
  type: TYPE_NORMAL
- en: Another great resource is a blog post on resizing containers by Docker contributor
    Jérôme Petazzoni at [http://jpetazzo.github.io/2014/01/29/docker-device-mapper-resize/](http://jpetazzo.github.io/2014/01/29/docker-device-mapper-resize/).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you switch storage drivers, the older containers and images will no longer
    be visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the beginning of this section, it was mentioned that there is a possibility
    to have quotas and still use AUFS through a hack. The hack involves creating a
    loopback filesystem based on the `ext4` filesystem on demand and bind mounting
    it as a volume specifically for the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now bind mount the `$DB_DIR` directory to the container with the `-v`
    option of the `docker run` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Managing data in containers with volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some salient features of a volume in Docker are mentioned as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A volume is a directory that is separated from the container's `root` filesystem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is managed directly by the `docker` daemon and can be shared across containers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A volume can also be used to mount a directory of the host system inside a container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes made to a volume will not be included when an image is updated from
    a running container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since a volume is outside the filesystem of the container, it doesn't have the
    concept of data layers or snapshots. Hence, reads and writes happen directly on
    the volume.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If multiple containers use the same volume, the volume persists until there
    is at least one container using it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creating a volume is easy. Just start a container with the `-v` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now note that volumes have no `ID` parameter, so you cannot exactly name a volume
    like you name a container or tag an image. However, the clause that says that
    a volume persists until at least one container uses it can be exploited, which
    introduces the concept of data-only containers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since Docker version 1.1, if you so wish, you can bind mount the whole filesystem
    of the host to a container using the -v option, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: However, it is forbidden to mount to / of the container, so you cannot replace
    the `root` filesystem of the container, for security reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Data-only container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A data-only container is a container that does nothing except exposing a volume
    that other data-accessing containers can use. Data-only containers are used to
    prevent volumes from being destroyed if containers accessing the volume stop or
    crash due to an accident.
  prefs: []
  type: TYPE_NORMAL
- en: Using volumes from another container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we start a container with a `-v` option, we have created a volume. We can
    share the volumes created by a container with other containers using the `--volumes-from`
    option. Possible use cases of this option can be backing up databases, processing
    logs, performing operations on user data, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Use case – MongoDB in production on Docker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a use case, say you want to use **MongoDB** in your production environment,
    you would be running a MongoDB server as well as a `cron` job, backing up your
    database snapshots at regular intervals.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MongoDB is a document database that provides high performance, high availability,
    and easy scalability. You can get more information about MongoDB at [http://www.mongodb.org](http://www.mongodb.org).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how make the MongoDB setup using `docker` volumes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we need a data-only container. The task of this container is only
    to expose the volume where MongoDB stores the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need to run the MongoDB server, which uses the volume created by the
    data-only container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `mongod` command runs the MongoDB server and is usually run as a daemon/service.
    It is accessed through port `27017`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we will need to run the `backup` utility. In this case, we are just
    dumping the MongoDB data store to the current directory on the host:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is by no means an exhaustive example of setting up MongoDB in production.
    You might need a process that monitors the health of the MongoDB server. You will
    also need to make the MongoDB server container discoverable by your application
    containers (which we will learn in detail later).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Docker to use a different storage driver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before using a different storage driver, back up all your images with `docker
    save` and stop the `docker` daemon. Once you have backed up all your important
    images, remove `/var/lib/docker`. Once you change the storage driver, you can
    restore the saved images.
  prefs: []
  type: TYPE_NORMAL
- en: We are now going to change our default storage driver, AUFS, to two alternative
    storage drivers – `devicemapper` and `btrfs`.
  prefs: []
  type: TYPE_NORMAL
- en: Using devicemapper as the storage driver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is easy to switch to the `devicemapper` driver. Just start the `docker`
    daemon with the `-s` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, you can provide various `devicemapper` driver options with the
    `--storage-opts` flag. The various available options and examples for the `devicemapper`
    drivers have been covered under the *Constraining resources storage* section of
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are running on RedHat/Fedora that doesn't have AUFS out of the box, Docker
    will have been using `devicemapper` driver, which is available.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have switched the storage driver, you can verify the change in it by
    running `docker info`.
  prefs: []
  type: TYPE_NORMAL
- en: Using btrfs as the storage driver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use btrfs as the storage driver, you have to first set it up. This section
    assumes you are running it on an Ubuntu 14.04 operating system. The commands may
    vary according to the Linux distribution you are running. The following steps
    will set up a block device with the `btrfs` filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, you need to install `btrfs` and its dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you need to create a block device of the `btrfs` filesystem type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create the directory for Docker (you should have backed up all important
    images and cleaned `/var/lib/docker` by this point.):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then mount the btrfs block device at `/var/lib/docker`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Check whether the mount is successful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Source: [http://serverascode.com/2014/06/09/docker-btrfs.html](http://serverascode.com/2014/06/09/docker-btrfs.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can start the `docker` daemon with the `-s` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Once you have switched the storage driver, you can verify the change in it by
    running the `docker info` command.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Docker's network settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker creates a separate network stack for each container and a virtual bridge
    (`docker0`) to manage network communication within the container, between the
    container and the host, and between two containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few network configurations that can be set as arguments to the
    `docker run` command. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--dns`: A DNS server is what resolves a URL, such as [http://www.docker.io](http://www.docker.io),
    to the IP address of the server that is running the website.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--dns-search`: This allows you to set DNS search servers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A DNS search server resolves `abc` to `abc.example.com` if `example.com` is
    set as the DNS search domain. This is useful if you have a lot of subdomains in
    your corporate website that you need to access frequently. It is too painful to
    repeatedly keep typing the entire URL. If you try to access a site that is not
    a fully qualified domain name (for example, `xyz.abc.com`.), it adds the search
    domains for the lookup. Source : [http://superuser.com/a/184366](http://superuser.com/a/184366).'
  prefs: []
  type: TYPE_NORMAL
- en: '`-h` or `--hostname`: This allows you to set the hostname. This will be added
    as an entry to the `/etc/hosts` path against the host-facing IP of the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--link`: This is another option that can be specified while starting a container.
    It allows containers to communicate with other containers without needing to know
    their actual IP addresses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--net`: This option allows you to set the network mode for the container.
    It can have four values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bridge` : This creates a network stack for the container on the docker bridge.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`none` : No networking stack will be created for this container. It will be
    completely isolated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`container:<name|id>` : This uses another container''s network stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`host` : This uses the host''s network stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These values have side effects such as the local system services being accessible
    from the container. This option is considered insecure.
  prefs: []
  type: TYPE_NORMAL
- en: '`--expose`: This exposes the container''s port without publishing it on the
    host.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--publish-all`: This publishes all exposed ports to the host''s interfaces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--publish`: This publishes a container''s port to the host in the following
    format: `ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort
    | containerPort`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If `--dns` or `--dns-search` is not given, then the `/etc/resolv.conf` file
    of the container will be the same as the `/etc/resolv.conf` file of the host the
    daemon is running on.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are some configurations that can be given to the `docker` daemon
    process too when you run it. They are mentioned as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These options can only be supplied when starting the `docker` daemon and cannot
    be tweaked once it is running. This means you must provide these arguments along
    with the `docker -d` command.
  prefs: []
  type: TYPE_NORMAL
- en: '`--ip`: This option allows us to set the host''s IP address at the container-facing
    `docker0` interface. As a result, this will be the default IP address used when
    binding container ports. For example this option can be shown as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`--ip-forward`: This is a `Boolean` option. If it is set to `false`, the host
    running the daemon will not forward the packets between containers or from the
    outside world to the container, completely isolating it (from a network perspective).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This setting can be checked using the `sysctl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`--icc`: This is another `Boolean` option that stands for `inter-container
    communication`. If it is set to `false`, the containers will be isolated from
    each other, but will still be able to make general HTTP requests to package managers
    and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How do you enable communication only between those two containers you need?
    Through links. We will explore links in detail in the *Linking containers* section.
  prefs: []
  type: TYPE_NORMAL
- en: '`-b or --bridge`: You can make Docker use a custom bridge instead of `docker0`.
    (The creation of a bridge is out of the scope of this discussion. However, if
    you are curious, you can find more information at [http://docs.docker.com/articles/networking/#building-your-own-bridge](http://docs.docker.com/articles/networking/#building-your-own-bridge).)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-H or --host`: This option can take multiple arguments. Docker has a RESTful
    API. The daemon acts as a server, and when you run client commands such as `run`
    and `ps`, it makes `GET` and `POST` requests to the server, which performs the
    necessary operations and returns a response. The `-H` flag is used to tell the
    `docker` daemon the channels it must listen to for client commands. The arguments
    can be as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TCP sockets, represented in the form of `tcp://<host>:<port>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UNIX socket in the form of `unix:///path/to/socket`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring port forwarding between container and host
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Containers can make connections to the outside world without any special configurations,
    but the outside world is not allowed to peek into them. This is a security measure
    and is fairly obvious, since the containers are all connected to the host through
    a virtual bridge, thus effectively placing them in a virtual network. But what
    if you were running a service in a container that you wanted to expose to the
    outside world?
  prefs: []
  type: TYPE_NORMAL
- en: Port forwarding is the easiest way to expose services running in containers.
    It is always advisable to mention in the Dockerfile of an image the ports that
    need to be exposed. In earlier versions of Docker, it was possible to specify
    which host port the Dockerfile should be bound to in the Dockerfile itself, but
    this was dropped because sometimes, services already running in the host would
    interfere with the container. Now, you can still specify in a Dockerfile the ports
    that are intended to be exposed (with the `EXPOSE` instruction), but if you want
    to bind it to ports of your choice, you need to do this when starting the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to start a container and bind its ports to host ports. They
    are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-P or --publish-all`: Starting a container using `docker run` with the `-P`
    option will publish all the ports that were exposed using the `EXPOSE` instruction
    in the image''s Dockerfile. Docker will go through the exposed ports and bind
    them to a random port between `49000` and `49900`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-p or --publish`: This option allows you to explicitly tell Docker which port
    on which IP should be bound to a port on a container (of course, one of the interfaces
    in the host should have this IP). Multiple bindings can be done by using the option
    multiple times:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker run -p ip:host_port:container_port`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`docker run -p ip::container_port`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`docker run -p host_port:container_port`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Custom IP address range
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've seen how to bind a container's port to a host's port, how to configure
    a container's DNS settings, and even how to set the host's IP address. But what
    if we wanted to set the subnet of the network between the containers and the host
    ourselves? Docker creates a virtual subnet in one of the available private ranges
    of IP addresses provided by RFC 1918.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting your own subnet range is marvelously easy. The `--bip` option of the
    `docker` daemon can be used to set the IP address of the bridge as well as the
    subnet in which it is going to create the containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we have set the IP address of `192.168.0.1` to the `docker` daemon
    and mentioned that it has to assign IP addresses to the containers in the subnet
    range `192.168.0.0/24` (that is, from `192.168.0.2` to `192.168.0.254`, a total
    of 252 possible IP addresses).
  prefs: []
  type: TYPE_NORMAL
- en: That's it! There are more advanced network configurations and examples at [https://docs.docker.com/articles/networking/](https://docs.docker.com/articles/networking/).
    Be sure to check them out.
  prefs: []
  type: TYPE_NORMAL
- en: Linking containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Binding container ports to host ports is all okay if you just have a plain web
    server that you want to expose to the Internet. Most production systems, however,
    are made of lots of individual components that are constantly communicating with
    each other. Components such as the database servers must not be bound to publicly
    visible IPs, but the containers running the frontend applications still need to
    discover the database containers and connect to them. Hardcoding a container's
    IP addresses in the application is neither a clean solution nor will it work because
    IP addresses are randomly assigned to the containers. So how do we solve this
    problem? The answer is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Linking containers within the same host
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A link can be specified when starting the container using the `--link` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: How does this work? When a link option is given, Docker adds an entry to the
    container's `/etc/hosts` file, with the `ALIAS` command as the hostname and the
    IP address of the container named `CONTAINER_IDENTIFIER`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `/etc/hosts` file can be used to override DNS definitions, that is, to point
    a hostname to a certain IP address. During hostname resolution, `/etc/hosts` is
    checked before making a request to a DNS server.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example the command line code is shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command runs a PostgreSQL server (whose Dockerfile exposes port
    5432, PostgeSQL's default port) and the second container will link to it with
    the `postgres` alias.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PostgreSQL is a fully **ACID**-compliant, powerful open source object-relational
    database system.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-host linking using ambassador containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Linking containers works fine when all the containers are within the same host,
    but Docker's containers might often be spread across hosts, and linking in these
    cases fails because the IP address of a container running in a different host
    is not known by the `docker` daemon running in the current host. Besides, links
    are static. This means that if a container restarts, its IP address changes and
    all containers linked to it will lose the connection. A portable solution is to
    use ambassador containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram displays the ambassador container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cross-host linking using ambassador containers](graphics/4787OS_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this architecture, the database server in one host is exposed to the other.
    Here too, if the database container changes, only the ambassador container in
    the `host1` phase needs to be restarted.
  prefs: []
  type: TYPE_NORMAL
- en: Use case - a multi-host Redis environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's set up a multi-host Redis environment using the `progrium/ambassadord`
    command. There are other images that can be used as ambassador containers as well.
    They can be searched for either using the `docker search` command or at [https://registry.hub.docker.com](https://registry.hub.docker.com).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Redis is an open source, networked, in-memory, key-value data store with optional
    durability. It is known for its fast speed, both for reads and writes.
  prefs: []
  type: TYPE_NORMAL
- en: In this environment, there are two hosts, `Host` `1` and `Host` `2`. `Host`
    `1` has an IP address of `192.168.0.100` and is private (not exposed to the public
    Internet). `Host` `2` is at 192.168.0.1 and is bound to a public IP. This is the
    host that runs your frontend web application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To try this example, start two virtual machines. If you use Vagrant, I suggest
    using an Ubuntu image with Docker installed. If you have Vagrant v1.5, you can
    use Phusion's Ubuntu image by running `$ vagrant init phusion/ubuntu-14.04-amd64`.
  prefs: []
  type: TYPE_NORMAL
- en: Host 1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the first host, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This command starts a Redis server and exposes port `6379` (which is the default
    port the Redis server runs at), but doesn't bind it to any host port.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command starts an ambassador container, links to the Redis server
    and binds the port 6379 to port 6379 of its private network''s IP address (which
    in this case happens to be 192.168.0.100). This is still not public because the
    host is private (not exposed to public Internet):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Host 2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In another host (another VM if you are using Vagrant in development), run the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This ambassador container listens to the port of the destination IP, which
    in this case is Host 1''s IP address. We have exposed port 6379 so that it can
    be now hooked to by our application container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This would be the container that would be exposed to the public on the Internet.
    As the Redis server is running in a private host, it cannot be attacked from outside
    the private network.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how to provision resources such as CPU, RAM, and storage
    in a Docker container. We also discussed how to use volumes and volume containers
    to manage persistent data produced by applications in containers. We realized
    what goes into switching storage drivers used by Docker and the various networking
    configurations and their relevant use cases. Lastly, we saw how to link containers
    both within a host and across hosts.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at the tools and approaches that will help
    when we are thinking about deploying our application using Docker. Some of the
    things we will be looking at are coordination of multiple services, service discovery,
    and Docker's remote API. We will also cover security considerations.
  prefs: []
  type: TYPE_NORMAL
