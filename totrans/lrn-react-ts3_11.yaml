- en: Unit Testing with Jest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a robust suite of unit tests that catches real bugs and doesn't flag
    false positives as we refactor our code is one of the hardest tasks we do as software
    developers. Jest is a great testing tool that helps us meet this challenge, as
    we'll find out in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the easiest bits of an app to unit test are pure functions, because
    there are no side effects to deal with. We'll revisit the validator functions
    we built in [Chapter 7](712041e2-6abb-46fa-ad99-3aa78a357939.xhtml), *Working
    with Form*, and implement some unit tests against them in order to learn how to
    unit test pure functions.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing components is the most common type of unit test we'll be carrying
    out while building our apps. We'll learn about it in detail, and leverage a library
    to help us implement tests that don't unnecessarily break when we refactor our
    code.
  prefs: []
  type: TYPE_NORMAL
- en: We'll learn what snapshot testing is, and how we can leverage it to implement
    our tests quicker. Snapshots can be used for testing pure functions as well as
    components, so they are a very useful tool to have at our disposal.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking is a challenging topic because if we mock too much, we aren't really
    testing our app. However, there are certain dependencies that make sense to mock,
    such as a REST API. We'll revisit the app we built in [Chapter 9](c4badffb-0c23-40cc-878c-8b598d427227.xhtml), *Interacting
    with Restful APIs*, in order to implement some unit tests against it and learn
    about mocking.
  prefs: []
  type: TYPE_NORMAL
- en: When implementing a suite of unit tests for our app, it is useful to know which
    bits we've tested and which bits we haven't. We'll learn how to use a code coverage
    tool to help us quickly identify areas of our app that need more unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing pure functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Jest snapshot tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting code coverage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We use the following technologies in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Node.js and `npm`**: TypeScript and React are dependent on these. Install
    them from the following link: [https://nodejs.org/en/download/](https://nodejs.org/en/download/).
    If you already have these installed, make sure `npm` is at least version 5.2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual Studio Code**: We''ll need an editor to write our React and TypeScript
    code, which can be installed from [https://code.visualstudio.com/](https://code.visualstudio.com/).
    We''ll also need the TSLint extension (by egamma) and the Prettier extension (by
    Estben Petersen).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**React shop**: We''ll be implementing unit tests on the React shop we created.
    This is available on GitHub at the following link: [https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/08-ReactRedux%EF%BB%BF](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/08-ReactRedux%EF%BB%BF).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Chapter 9 code**: We''ll be implementing unit tests on the app we created
    in [Chapter 9](c4badffb-0c23-40cc-878c-8b598d427227.xhtml), *Interacting with
    RESTful APIs*. This is available on GitHub at the following link: [https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/09-RestfulAPIs/03-AxiosWithClass](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/09-RestfulAPIs/03-AxiosWithClass).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to restore code from a previous chapter, the `LearnReact17WithTypeScript`
    repository at [https://github.com/carlrip/LearnReact17WithTypeScript](https://github.com/carlrip/LearnReact17WithTypeScript) can
    be downloaded. The relevant folder can then be opened in Visual Studio Code and `npm
    install` entered in the terminal to do the restore. All the code snippets in this
    chapter can be found online at the following link: [https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/11-UnitTesting](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/11-UnitTesting).
  prefs: []
  type: TYPE_NORMAL
- en: Testing pure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll start our unit testing journey in this section by implementing a unit
    test on a pure function.
  prefs: []
  type: TYPE_NORMAL
- en: A pure function has a consistent output value for a given set of parameter values.
    Pure functions only depend on the function arguments, and on nothing outside the
    function. These functions also don't change any of the argument values passed
    into them.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that these functions only depend on their parameter values makes them
    straightforward to unit test.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to implement a unit test on the `required` validator function we
    created in our `Form` component in the React shop we built. If you haven't already,
    open this project in Visual Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use Jest, which is very popular for unit testing React apps,
    as our unit testing framework. Luckily the `create-react-app` tool installs and
    configures this for us when creating a project. So, Jest is ready to be used in
    our React shop project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic pure function test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create our first unit test in our project to test the `required` function
    in `Form.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a file called `Form.test.tsx` in the `src` folder. We'll use
    this file for our test code, to test the code in `Form.tsx`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `test.tsx` extension is important because Jest automatically looks for files
    with this extension when finding tests to execute. Note that if our tests don't
    contain any JSX, we could use a `test.ts` extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s import the function we want to test, along with a TypeScript type we
    need for a parameter value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start to create our test using the Jest `test` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `test` function takes in two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter is a message telling us whether the test passed or not,
    which will be shown in the test output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second parameter is an arrow function that will contain our test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ll move on to calling the `required` function with a `values` parameter
    that contains an empty `title` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Our next task in this test is to check that the result from the `required`
    function is what we expect. We can use the Jest `expect` function to do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We pass the variable we are checking into the `expect` function. We then chain
    a `toBe` matcher function onto this, which checks that the result from the `expect`
    function is the same as the parameter supplied to the `toBe` function.
  prefs: []
  type: TYPE_NORMAL
- en: '`toBe` is one of many Jest matcher functions we can use to check a variable
    value. The full list of functions can be found at [https://jestjs.io/docs/en/expect](https://jestjs.io/docs/en/expect).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our test is complete, we can run the test by typing the following
    in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This starts the Jest test runner in watch mode, which means that it will continuously
    run, executing tests when we change the source files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Jest will eventually find our test file, execute our test, and output the result
    to the terminal, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5a80eb3d-465a-4d50-861d-6ea156f89e70.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s change the expected result in the test to make the test fail:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When we save the test file, Jest automatically executes the test and outputs
    the failure to the terminal, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a0719956-b0a4-44af-b67b-6a0b84b5f999.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Jest gives us valuable information about the failure. It tells us this:'
  prefs: []
  type: TYPE_NORMAL
- en: Which test failed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the expected result was, in comparison to the actual result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The line in our test code where the failure occurred
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This information helps us quickly resolve test failures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on, let''s correct our test code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When we save the change, the test should now pass.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Jest watch options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After Jest executes our tests, it provides us with the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'These options let us specify what tests should be executed, which is really
    useful as the number of tests grows. Let''s explore some of these options:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we press *F*, Jest will execute only the tests that have failed. In our
    code, we get confirmation that we have no failing tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/92898667-2723-4795-8169-2cbe94f29d0b.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's press *F* to exit this option and take us back to all the options that
    are available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s press *P*. This allows us to test a specific file or a collection
    of files with names matching a regular expression pattern. Let''s enter `form`
    when prompted for the filename pattern:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/0e1a490c-e71c-469c-914e-a5571eb66a0a.png)'
  prefs: []
  type: TYPE_IMG
- en: Our test in `Form.test.tsx` will then be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to leave the filename filter on and press *T*. This will allow
    us to add an additional filter by test name. Let''s enter `required`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/2d2f150e-883d-487e-8e72-1d83ec81a32c.png)'
  prefs: []
  type: TYPE_IMG
- en: Our test on the `required` function will then be executed.
  prefs: []
  type: TYPE_NORMAL
- en: To clear the filters, we can press *C*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we receive an error—watch is not supported without git/hg, please use --watchAll,
    this will be because our project isn't in a Git repository. We can resolve the
    issue by entering the `git init` command in the Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: We have a good handle on the options available to execute our tests now.
  prefs: []
  type: TYPE_NORMAL
- en: Adding structure to unit test results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we implement more unit tests, it is useful to add some structure to the unit
    test results so that we can read them more easily. There is a Jest function called
    `describe` that we can use to group the results of certain tests together. It
    may make reading test results easier if all the tests for a function are grouped
    together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do this and refactor the unit test we created earlier, using the `describe`
    function in Jest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The describe function takes in two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter is the title for the group of tests. We have used the function
    name we are testing for this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second parameter is an arrow function that contains the tests to execute.
    We have placed our original test here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we save our test file, the tests will automatically run, and our improved
    output is shown in the terminal with our test result under a `required` heading:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/30db856d-4fbd-4bd0-8aa9-57bd32a074a8.png)'
  prefs: []
  type: TYPE_IMG
- en: We're starting to get familiar with Jest, having implemented and executed a
    unit test. In the next section, we will move on to the more complex topic of unit
    testing components.
  prefs: []
  type: TYPE_NORMAL
- en: Testing components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit testing a component is challenging because a component has dependencies
    such as the browser's DOM and the React library. How exactly can we render a component
    in our test code before we do the necessary checks? How can we trigger DOM events
    when coding a user interaction, such as clicking a button?
  prefs: []
  type: TYPE_NORMAL
- en: We'll answer these questions in this section, by implementing some tests on
    the `ContactUs` component we created in our React shop.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic component test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to start by creating a unit test to verify that submitting the
    Contact Us form without filling in the fields results in errors being displayed
    on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: We are going to implement a unit test on the `ContactUs` component. We'll start
    by creating a file called `ContactUs.test.tsx` in the `src` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We are going to use `ReactDOM` to render a test instance of the `ContactUs`
    component. Let''s import `React` and `ReactDOM`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to simulate the form submit event, so let''s import the `Simulate`
    function from the React testing utilities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now import the component we need to test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to import the submission result interface from `Form.tsx` as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start to create our test using the Jest `test` function, with the results
    outputting to a `ContactUs` group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The first task in our test implementation is to create our React component
    in the DOM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: First, we create a container `div` tag and then render our `ContactUs` component
    into this. We have also created a handler for the `onSubmit` prop, which returns
    success. The last line in the test cleans up by removing the DOM elements that
    were created in the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to get a reference to the form, and then submit it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the step-by-step description:'
  prefs: []
  type: TYPE_NORMAL
- en: We use the `querySelector` function, passing in the `form` tag to get a reference
    to the `form` tag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then check that the form is not `null` by using the Jest `expect` function
    with the `not` and `toBeNull` functions chained together.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `submit` event is simulated using the `Simulate` function from the React
    testing utilities. We use an `!` after the `form` variable to inform the TypeScript
    compiler that it is not `null`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our final task is to check that the validation errors are displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see this step-by-step:'
  prefs: []
  type: TYPE_NORMAL
- en: We use the `querySelectorAll` function on the container DOM node, passing in
    a CSS selector to find the `span` tags that should contain the errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then use the Jest `expect` function to verify that two errors are displayed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the test runs, it should pass successfully, giving us two passing tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/7f8227b3-6643-4c54-bfa8-e879a79166c7.png)'
  prefs: []
  type: TYPE_IMG
- en: In this test, Jest is rendering the component in a fake DOM. The form `submit`
    event is also simulated, using the `simulate` function from standard React testing
    utilities. So, there's a lot of mocking going on in order to facilitate an interactive
    component test.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that we are referencing internal implementation details in our test
    code. We reference a `form` tag, along with a `form-error` CSS class. What if
    we later change this CSS class name to `contactus-form-error`? Our test would
    break, without there necessarily being a problem with our app.
  prefs: []
  type: TYPE_NORMAL
- en: This is called a **false positive**, and can make code bases with these kinds
    of tests very time-consuming to change.
  prefs: []
  type: TYPE_NORMAL
- en: Improving our tests with react-testing-library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: react-testing-library is a set of utilities that helps us write maintainable
    tests for React components. It focuses heavily on helping us remove implementation
    details from our test code.
  prefs: []
  type: TYPE_NORMAL
- en: We'll use this library to remove the CSS class references in our test code,
    and also the tight coupling to React's event system.
  prefs: []
  type: TYPE_NORMAL
- en: Installing react-testing-library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s install `react-testing-library` first as a development dependency via
    the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: After a few seconds, this will be added to our project.
  prefs: []
  type: TYPE_NORMAL
- en: Removing CSS class references from our tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll make our first improvement to our test by removing the dependencies
    on the `form-error` CSS class. Instead, we will get a reference to the errors
    via the error text, which is what the user sees onscreen and not an implementation
    detail:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll import a `render` function from `react-testing-library`, which we will
    now use to render our component. We''ll also import a `cleanup` function, which
    we''ll use at the end of our tests to remove the test component from the DOM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can render our component using the `render` function we have just imported,
    rather than using `ReactDOM.render`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We get the container DOM node back in a `container` variable, along with a `getallByText` function,
    which we'll use to get a reference to the displayed errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now use the `getAllByText` function to get the errors displayed on the
    page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The last change we are going to make is to clean up our DOM at the end of the
    test using the `cleanup` function we just imported, rather than `ReactDOM.unmountComponentAtNode`.
    We are also going to do this outside our test, in Jest''s `afterEach` function.
    Our completed test should now look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When the test runs, it should still execute okay and the tests should pass.
  prefs: []
  type: TYPE_NORMAL
- en: Using fireEvent for user interaction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are now going to switch to depending on the native event system, rather
    than React''s event system which sits on top of it. This gets us closer to testing
    what happens when users are using our app, and increases our confidence in our
    test:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding the `fireEvent` function to the import statement from
    `react-testing-library`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to add the `getByText` function to the destructured variables
    from the call to the `render` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We can also remove the destructured `container` variable, as that won't be needed
    anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then use this function to get a reference to the Submit button. After
    that, we can use the `fireEvent` function we imported to click the button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The previous code that referenced the `form` tag has now been removed.
  prefs: []
  type: TYPE_NORMAL
- en: When the test runs, it still passes.
  prefs: []
  type: TYPE_NORMAL
- en: So, our test references items that the user sees, rather than implementation
    details, and is far less likely to unexpectedly break.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a second test for a valid form submission
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have got the gist of how to write robust tests, let''s add a second
    test to check that no validation errors are shown when the form is filled incorrectly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by creating a new test in our `ContactUs` group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll render the component in the same way as the first test, but destructuring
    slightly different variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll need the `container` object to check whether there are any errors displayed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll use the `getByText` function to locate the Submit button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll use the `getByLabelText` function to get references to our inputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can now get a reference to the name input using the `getByLabelText` function.
    After that, we do a little check to verify that the name input does exist:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to simulate the user filling in this input. We do this by calling
    the native `change` event, passing in the required event argument, which includes
    our input value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We have simulated the user setting the name field as `Carl`.
  prefs: []
  type: TYPE_NORMAL
- en: We use a type assertion after the call to `getByLabelText` to inform the TypeScript
    compiler that the returned element is of type `HTMLInputElement`, so that we don't
    get a compilation error.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then can follow the same pattern for filling in the email field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have simulated the user setting the email field as `carl.rippon@testmail.com`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then submit the form by clicking the Submit button, in the same way
    as in our first test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Our final task is to verify there are no errors displayed on the screen. Unfortunately,
    we can''t use the `getAllByText` function we used in the last test, as this expects
    to find at least one element, and in our case we expect there to be no elements.
    So, before we carry out this check, we are going to add a wrapping `div` tag around
    errors. Let''s go to `Form.tsx` and do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We've given the `div` tag a `data-testid` attribute, which we'll use in our
    test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to our test. We can now locate the `div` tag around the errors
    using the `data-testid` attribute. We can then verify that this `div` tag is `null`,
    because no errors are displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: When the test runs in our suite of tests, we'll find we now have three passing
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: Isn't referencing the `data-testid` attribute an implementation detail, though?
    The user doesn't see or care about the `data-testid` attribute—this seems to contradict
    what we said earlier.
  prefs: []
  type: TYPE_NORMAL
- en: It is kind of an implementation detail, but it is specifically for our test.
    So, an implementation refactor is unlikely to unexpectedly break our test.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to add another test, this time using Jest
    snapshot tests.
  prefs: []
  type: TYPE_NORMAL
- en: Using Jest snapshot tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A snapshot test is one where Jest compares all the elements and attributes in
    a rendered component to a previous snapshot of the rendered component. If there
    are no differences, then the test passes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to add a test to verify the `ContactUs` component renders OK,
    by checking the DOM nodes using a Jest snapshot test:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll create a test with the title `Renders okay` in the `ContactUs` group
    of tests, rendering the component in the same way as previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now add the line to carry out the snapshot test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Doing a snapshot test is pretty simple. We pass the DOM node we want to compare
    into Jest's `expect` function, and then chain the `toMatchSnapshot` function after
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the test runs, we''ll get confirmation that the snapshot has been written
    in the terminal, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/40d1d8d8-f581-4f3d-abdd-f860f1e4fa42.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we look at our `src` folder, we''ll see it now contains a `__snapshots__` folder.
    If we look in this folder, we''ll see a file called `ContactUs.test.tsx.snap`.
    Opening the file, we''ll see the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Some of the content is stripped out in this snippet, but we get the gist: we
    have a copy of every DOM node including their attributes from the `container` element
    we passed into the `toMatchSnapshot` function.'
  prefs: []
  type: TYPE_NORMAL
- en: This test is heavily coupled to our implementation, though. So, any change to
    our DOM structure or attributes will break our test.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let''s add a `div` tag inside our `Form` component in `Form.tsx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'When the test runs, we''ll see confirmation that our test has broken. Jest
    does a great job of showing us the difference in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/eeb2f477-38cd-460d-bfd0-910b640cf3c6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We are happy that this is a valid change, so we can press *U* to let Jest update
    the snapshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/ee14c380-8e94-4ba6-884f-33891162b018.png)'
  prefs: []
  type: TYPE_IMG
- en: So, are snapshot tests a good thing or a bad thing? They are volatile because
    they are tightly coupled to the implementation of a component. However they are
    super-easy to create, and when they do break, Jest does a great job of highlighting
    the problem area and allowing us to efficiently correct the test snapshot. They
    are well worth a try to see if your team gains value from them.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned a lot already in this chapter about unit testing React and TypeScript
    apps. Next up, we'll learn how we can mock dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mocking a component's dependencies can make the component easier to test. However,
    if we mock too many things, is the test really verifying that the component will
    work in our real app?
  prefs: []
  type: TYPE_NORMAL
- en: Establishing what to mock is one of the hardest tasks when writing unit tests.
    There are some things that make a lot of sense to mock, though, such as REST APIs.
    A REST API is a pretty fixed contract between the frontend and backend. Mocking
    a REST API also allows our tests to run nice and fast.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll eventually learn how to mock REST API calls made with
    `axios`. First, though, we'll learn about Jest's function mocking feature.
  prefs: []
  type: TYPE_NORMAL
- en: Using a mock function in Jest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to make another improvement to the test that verified that submitting
    the Contact Us form without filling in the fields results in errors being displayed
    on the page. We are going to add an additional check, to make sure the submit
    handler is not executed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to the first component test we wrote: `ContactUs.test.tsx`.
    We manually created a `handleSubmit` function that we referenced in our instance
    of the `ContactUs` component. Let''s change this to a Jest mock function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Our test will run correctly, as it did before, but this time Jest is mocking
    the function for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that Jest is mocking the submit handler, we can check whether it was called
    as an additional check at the end of our test. We do this using the `not` and `toBeCalled`
    Jest matcher functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This is really nice, because we've not only simplified our submit handler function,
    but we've also really easily added a check to verify that it hasn't been called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on to the second test we implemented, which verified that a valid Contact
    Us form was submitted okay:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll again change the `handleSubmit` variable to reference a Jest mock function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s verify that the submit handler is called. We do this using the `toBeCalledTimes` Jest
    function to pass in the number of times we expect the function to be called, which
    is `1` in our case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: When the test executes, it should still pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one other useful check we can do. We know that the submit handler
    is being called, but does it have the correct arguments? We can use the `toBeCalledWith`
    Jest function to check this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Again, when the test executes, it should still pass.
  prefs: []
  type: TYPE_NORMAL
- en: So, by letting Jest mock our submit handler, we've quickly added a few valuable
    additional checks to our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking Axios with axios-mock-adapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to move to the project we created in [Chapter 9](c4badffb-0c23-40cc-878c-8b598d427227.xhtml), *Interacting
    with Restful APIs.* We are going to add a test that verifies the posts are rendered
    on the page correctly. We''ll mock the JSONPlaceholder REST API so we are in control
    of the data that is returned, and so that our test will execute nicely and quickly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to install the `axios-mock-adapter` package as a development
    dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We are also going to install `react-testing-library`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The project already has a test file, `App.test.tsx`, which includes a basic
    test on the `App` component. We'll remove the test, but leave the imports, as
    we'll need these.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In addition, we are going to import some functions from react-testing-library, `axios`
    and a `MockAdapter` class that we''ll use to mock the REST API calls:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add the usual cleanup line that will execute after each test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll create our test with an appropriate description, and place it under
    an `App` group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `arrow` function is marked with the `async` keyword. This is because
    we'll eventually make an asynchronous call in our test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first job in our test is to mock the REST API call using the `MockAdapter`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We use the `onGet` method to define the response HTTP status code and body we
    want when the URL to get the posts is called. So, the call to the REST API should
    return two posts containing our test data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to check that the posts are rendered correctly. In order to do this,
    we are going to add a `data-testid` attribute to the unordered posts list in `App.tsx`.
    We are also only going to render this when we have data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Moving back to our test, we can now render the component and destructure the
    `getByTestId` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to check that the rendered posts are correct, but this is tricky, because
    these are rendered asynchronously. We need to wait for the posts list to be added
    to the DOM before doing our checks. We can do this using the `waitForElement`
    function from react-testing-library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `waitForElement` function takes in an arrow function as a parameter, which
    in turn returns the element we are waiting for. We use the `getByTestId` function
    to get the posts list, which finds it using its `data-testid` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then use a snapshot test to check that the content in the posts list
    is correct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Before our test can execute successfully, we need to make a change in `tsconfig.json`
    so that the TypeScript compiler knows that we are using `async` and `await`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: When the test executes, the snapshot is created. If we inspect the snapshot,
    it will contain the two list items containing data that we told the REST API to
    return.
  prefs: []
  type: TYPE_NORMAL
- en: We've learned about some great features in Jest and react-testing-library that
    help us write maintainable tests on pure functions and React components.
  prefs: []
  type: TYPE_NORMAL
- en: How can we tell what bits of our app are covered by unit tests, though—and,
    more importantly, what bits are uncovered? We'll find out in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Getting code coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code coverage is how we refer to how much of our app code is covered by unit
    tests. As we write our unit tests, we'll have a fair idea of what code is covered
    and what code is not covered, but as the app grows and time passes, we'll lose
    track of this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Jest comes with a great code coverage tool, so we don''t have to keep what
    is covered in our heads. In this section, we''ll use this to discover the code
    coverage in the project we worked on in the previous section, where we mocked
    `axios`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first task is to add an `npm` script that will run the tests with the coverage
    tracking tool switched on. Let''s add a new script called `test-coverage` that
    includes the `--coverage` option when `react-scripts` is executed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then run this command in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'After a few seconds, Jest will render some nice high-level coverage statistics
    on each file in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c426c06b-40a8-412f-9e86-ae592f821802.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we look in our project file structure, we''ll see that a `coverage` folder
    has been added with a `lcov-report` folder within it. There is an `index.html`
    file within the `lcov-report` folder that contains more detailed information on
    the coverage within each file. Let''s open this and have a look:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/3db8e56c-d029-4380-bcdd-cab3127e597a.png)'
  prefs: []
  type: TYPE_IMG
- en: We see the same information as presented in the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: What do these four columns of statistics mean?
  prefs: []
  type: TYPE_NORMAL
- en: The `Statements` column shows how many statements in the code have been executed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Branches` column shows how many branches in the conditional statements in
    the code have been executed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Function` column shows how many functions in the code have been called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Line` column shows how many lines in the code have been executed. Generally,
    this will be the same as the `Statements` figure. However, it can be different
    if multiple statements have been placed on a single line. For example, the following
    is counted as a single line, but two statements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We can drill into each file to find which specific bits of code aren''t covered.
    Let''s click on the `App.tsx` link:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/12137a97-2add-4bdf-88a5-0312a8c06d0a.png)'
  prefs: []
  type: TYPE_IMG
- en: The `1x` with a green background to the left of the lines of code indicates
    that those lines have been executed by our tests once. The code highlighted in
    red is code that isn't covered by our tests.
  prefs: []
  type: TYPE_NORMAL
- en: So, getting coverage statistics and identifying additional tests that we may
    want to implement is pretty easy. It's something well worth using to give us confidence
    that our app is well-tested.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to test pure functions written in TypeScript
    using Jest. We simply execute the function with the parameters we want to test,
    and use Jest's `expect` function chained with one of Jest's matcher functions, such
    as `toBe`, to validate the result.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at how to interact with Jest's test runner, and how to apply filters
    so that only the tests we are focusing on are executed. We learned that testing
    React and TypeScript components is more involved than testing pure functions,
    but Jest and react-testing-library give us a great deal of help.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned how to render a component using the `render` function, and how
    to interact with and inspect elements using various functions such as `getByText` and
    `getLabelByText` from react-testing-library.
  prefs: []
  type: TYPE_NORMAL
- en: We learned that we can easily test asynchronous interactions using the `waitForElement` function
    in react-testing-library as well. We now understand the benefit of not referencing
    implementation details in our tests, which will help us build more robust tests.
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed Jest's clever snapshot testing tool. We looked at how these
    tests can regularly break, but also why they are incredibly easy to create and
    change.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to mock and spy into functions is another great Jest feature we
    now know about. Checking that functions for component event handlers have been
    called with the right parameters can really add value to our tests.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed the `axios-mock-adapter` library which we can use for mocking `axios`
    REST API requests. This allows us to easily test container components that interact
    with RESTful APIs.
  prefs: []
  type: TYPE_NORMAL
- en: We now know how to quickly identify the additional tests that we need to implement
    to give us confidence that our app is well-tested. We created an `npm` script
    command to enable us to do this, using `react-scripts` and the `--coverage` option.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, we now have the knowledge and the tools to robustly create unit tests
    for our apps with Jest.
  prefs: []
  type: TYPE_NORMAL
- en: Jasmine and Mocha are two popular alternative testing frameworks to Jest. The
    big advantage of Jest is that it is configured by `create-react-app` to work out
    the box. We would have to configure Jasmine and Mocha manually if we wanted to
    use them. Jasmine and Mocha are worth considering, though, if your team is already
    experienced with either of these tools, rather than learning another testing framework.
  prefs: []
  type: TYPE_NORMAL
- en: Enzyme is another popular library used with Jest to test React apps. It supports
    shallow rendering, which is a way of rendering only the top-level elements in
    a component and not child components. It is well worth exploring, but remember
    that the more we mock, the further from the truth we get, and the less confidence
    we have that our app is well-tested.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say we are implementing a Jest test and we have a variable called `result`,
    which we want to check isn't `null`. How can we do this with Jest matcher functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s say we have a variable called `person` that is of type `IPerson`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to check that the `person` variable is `{ id: 1, name: "bob" }`. How
    can we do this with Jest matcher functions?'
  prefs: []
  type: TYPE_NORMAL
- en: Is it possible to carry out our check in the last question with a Jest snapshot
    test? If so, how?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have implemented a component called `CheckList` which renders text from
    an array in a list. Each list item has a checkbox so that the user can select
    list items. The component has a function prop called `onItemSelect` that is called
    when a user selects an item by checking the checkbox. We are implementing a test
    to verify that the `onItemSelect` prop works. The following line of code renders
    the component in the test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: How can we use a Jest mock function for `handleListItemSelect` and check that
    it is called?
  prefs: []
  type: TYPE_NORMAL
- en: In the implementation of `SimpleList` in the last question, the `onItemSelect`
    function takes in a parameter called `item`, which is the `string` value that
    the user has selected. In our test, let's pretend we have already simulated the
    user selecting `Banana`. How can we check the `onItemSelect` function was called,
    with the item parameter being `Banana`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the implementation of `SimpleList` in the last two questions, the text is
    displayed using a label that is tied to the checkbox using the `for` attribute.
    How can we use functions in react-testing-library to firstly locate the `Banana`
    checkbox and then check it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this chapter, we found that the coverage was low in our code that rendered
    posts from the JSONPlaceholder REST API. One of the areas that wasn't covered
    was handling HTTP error codes in the `componentDidMount` function when we get
    the posts from the REST API. Create a test to cover this area of code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following resources are useful for finding more information on unit testing
    React and TypeScript apps:'
  prefs: []
  type: TYPE_NORMAL
- en: Official Jest documentation can be found at the following link: [https://jestjs.io/](https://jestjs.io/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The React Testing Library GitHub repository is at the following link: [https://github.com/kentcdodds/react-testing-library](https://github.com/kentcdodds/react-testing-library)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Read the documentation for Enzyme at the following link: [https://airbnb.io/enzyme/docs/api/](https://airbnb.io/enzyme/docs/api/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Jasmine GitHub page is as follows: [https://jasmine.github.io/index.html](https://jasmine.github.io/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Mocha homepage can be found at [https://mochajs.org/](https://mochajs.org/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
