- en: Assessments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chapter 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What is an immutable function?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An immutable function is a function that doesn't change its argument values
    or the state of the program.
  prefs: []
  type: TYPE_NORMAL
- en: '**How do you write an immutable function?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you want the compiler to help you, make the arguments `const`.
  prefs: []
  type: TYPE_NORMAL
- en: '**How do immutable functions support code simplicity?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since they don't change their arguments, they remove any potential complexity
    from the code, thus allowing programmers to understand it better.
  prefs: []
  type: TYPE_NORMAL
- en: '**How do immutable functions support a simple design?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Immutable functions are boring because they only do computation. Therefore,
    they facilitate maintenance over long periods of time.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is a high-level function?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A high-level function is a function that receives another function as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '**What examples of high-level functions can you give from STL?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are many examples of high-level functions in STL, particularly in the
    algorithms. `sort` is the example that we used in this chapter; however, if you
    look in the `<algorithm>` header, you will find many others, including `find`,
    `find_if`, `count`, `search`, and more.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are the advantages of functional loops over structured loops? What are
    their potential disadvantages?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Functional loops avoid off-by-one errors and express the intent of the code
    more clearly. They are also composable, thus allowing complex operations by chaining
    multiple loops. However, when composed, they require multiple passes through the
    collection, which could otherwise be avoided by using simple loops.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is OOP from the perspective of Alan Kay? How does it relate to functional
    programming?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alan Kay saw OOP as a way to structure code on the principles of cellular organisms.
    Cells are separate entities that communicate through chemical signals. Therefore,
    communication between small objects is the most important part of OOP.
  prefs: []
  type: TYPE_NORMAL
- en: This means that we can use functional algorithms on data structures that are
    represented as objects without any conflict.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What is a pure function?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A pure function is a function that has two constraints, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It always returns the same output values for the same argument values.
  prefs:
  - PREF_OL
  - PREF_UL
  type: TYPE_NORMAL
- en: It doesn't have side effects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How is immutability related to pure functions?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pure functions are immutable because they don't change anything in the program
    state.
  prefs: []
  type: TYPE_NORMAL
- en: '**How can you tell the compiler to prevent changes to a variable that''s passed
    by value?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Simply define the parameter as `const`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**How can you tell the compiler to prevent changes to a variable that''s passed
    by reference?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Simply define the parameter as `const&`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**How can you tell the compiler to prevent changes to a pointer address that''s
    passed by reference?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the pointer is passed by value, nothing is needed since all the changes
    will be local to the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If the pointer is passed by reference, we need to tell the compiler that the
    address cannot change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**How can you tell the compiler to prevent changes to the value that''s pointed
    by a pointer?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the pointer is passed by value, we apply the same rule as for simple values
    that are passed by value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To prevent changes to both the value and the address when passing the pointer
    by reference, more use of the `const` keyword is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Chapter 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What is the simplest lambda you can write?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The simplest lambda receives no parameters and returns a constant; it can be
    something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**How can you write a lambda that concatenates two string values passed as
    parameters?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are a few variations to this answer, depending on your preferred way
    of concatenating strings. The simplest way using STL is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**What if one of the values is a variable that''s captured by value?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The answer is similar to the preceding solution, but using the value from context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we can also use the default capture by value notation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**What if one of the values is a variable that''s captured by reference?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There''s very little change from the previous solution, as shown in the following
    code, except if you want to protect against value changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to protect against a value change, we need to cast to `const`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**What if one of the values is a pointer that''s captured by value?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We could ignore the immutability, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we could use a pointer to a `const` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we could just use the value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '**What if one of the values is a pointer that''s captured by reference?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This allows us to change both the value pointed to and the pointer address inside
    the lambda.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way is to ignore immutability, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to constrain immutability, we could use the cast to `const`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it''s usually best to simply use the value instead, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**What if both values are captured by value using the default capture specifier?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This solution requires no arguments, just two values captured from the context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '**What if both values are captured by reference using the default capture specifier?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we don''t care about mutating the values, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To preserve immutability, we need to do the cast to `const`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: There's no way to ensure immutability using just the default capture by reference
    specifier. Use capture by value instead.
  prefs: []
  type: TYPE_NORMAL
- en: '**How can you write the same lambda as a data member in a class that has the
    two string values as data members?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a class, we need to specify the type of the lambda variable and whether we
    capture either the two data members or this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how to capture values by copy with the `[=]` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows how to capture `this` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '**How can you write the same lambda as a static variable in the same class?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to receive the data members as parameters, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We've seen that this is better than passing as parameter a whole instance of
    `AClass` because it reduces the coupling area between the function and the class.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What is functional composition?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Functional composition is an operation on functions. It takes two functions,
    *f* and *g*, and creates a third function, *C*, with the following property for
    any argument: *x*, *C(x) = f(g(x))*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Functional composition has a property that is usually associated with mathematical
    operations. What is it?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Functional composition is not commutative. For example, squaring the increment
    of a number is not the same as incrementing the square of a number.
  prefs: []
  type: TYPE_NORMAL
- en: '**How can you turn an add function with two parameters into two functions with
    one parameter?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Consider the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can turn the preceding function into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '**How can you write a C++ function that comprises two single parameter functions?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the chapter, we saw that it''s very easy to do so with the help of templates
    and the magic of `auto` types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '**What are the advantages of functional composition?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Functional composition allows us to create complex behaviors by composing very
    simple functions. Additionally, it allows us to remove certain types of duplication.
    It also raises the probability of reuse by allowing small functions to be recomposed
    in infinite ways.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are the potential disadvantages of implementing operations on functions?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The operations on functions can have very complex implementations and can become
    very difficult to understand. Abstractions come with a cost, and the programmer
    must always balance the benefits of composability and small code with the costs
    of using abstract operations.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What is partial function application?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Partial function application is the operation of obtaining a new function that
    takes *N-1* parameters from a function, which in turn takes *N* parameters by
    binding one of the parameters to a value.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is currying?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Currying is the operation of splitting a function that takes *N* parameters
    into *N* function, with each taking one parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '**How does currying help to implement partial application?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given the curried function *f(x)(y)*, the partial application of *f* on *x =
    value* can be obtained by simply calling *f* with the value like this: *g = f(value)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**How can we implement partial application in C++?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Partial application can be implemented manually in C++, but it's easier to implement
    it using the `bind` function from the `functional` header.
  prefs: []
  type: TYPE_NORMAL
