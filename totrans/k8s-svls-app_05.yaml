- en: Using Funktion for Serverless Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we move on to launching a Kubernetes cluster in a public cloud, we are
    going to take a look at one more local example; this time we will be looking at
    Funktion. We will be covering the following subjects:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Funktion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and configuring Funktion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running our first function using Funktion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Twitter flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we walk through installing and configuring Funktion, we should take a
    moment to discuss what it does, as it is a little different from the other frameworks
    covered in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Funktion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Funktion's tagline describes it as event-based Lambda programming for Kubernetes.
    On the face of it, Funktion seems pretty close to Kubeless and the other Serverless
    frameworks we have discussed in previous chapters. However, it has its own twist
    which sets it apart from the other frameworks we are looking at.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the serverless functions we are looking at support two basic event
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**HTTP**: This is where data is passed to the framework using a standard HTTP
    request; typically the data will be posted as a JSON object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subscription**: This is where the framework listens for topics in an event
    stream, for example, Kubeless uses Apache Kafka ([https://kafka.apache.org/](https://kafka.apache.org/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Funktion expands on the number of event types—in fact, it supports around 200
    different types of event. That is a quite a jump! It achieves this using Apache
    Camel ([https://camel.apache.org/](https://camel.apache.org/)). Apache Camel is
    an open source Java framework that acts as plumbing for developers, allowing them
    to both ingest and publish data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To give you an idea of some of the event streams that are supported by Apache
    Camel, and therefore Funktion, here are some of the highlights:'
  prefs: []
  type: TYPE_NORMAL
- en: AWS-SNS support for working with Amazon's **Simple Notification Service** (**SNS**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Braintree allows for interaction with the Braintree payment gateway service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: etcd allows you to interact with the etcd key value store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Facebook opens up the full Facebook API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitHub allows you to listen for events from GitHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kafka—like Kubeless, you can subscribe to Kafka streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Twitter gives you the ability to listen out for hashtags, posts, and more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are numerous others such as LinkedIn, Slack, various SQL and NoSQL databases,
    file services such as S3 from AWS, Dropbox, and Box, to name but a few.
  prefs: []
  type: TYPE_NORMAL
- en: All of this choice makes it a very good proposition compared to the other frameworks
    we have been and will be looking at.
  prefs: []
  type: TYPE_NORMAL
- en: There are several different components that make up a Funktion deployment. To
    start with we have a **function**; this is the code itself, which is managed by
    Kubernetes ConfigMap.
  prefs: []
  type: TYPE_NORMAL
- en: A function by itself is not very useful as it only exists as data within a ConfigMap.
    Because of this, we need a **runtime**, a Kubernetes deployment that takes the
    function and executes it when called. Runtimes are automatically created when
    the Funktion operator (more on that in a little while) detects that a new function
    is added.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have a **connector**; this is a representation of an event source such
    as the ones we discussed earlier in this section—it contains information on the
    event type, the configuration (such as API credentials), and also data search
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Then we have **flow**; this is a sequence of steps that could be consuming events
    from a connector that invokes a function.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have the **Funktion** operator. This is a pod running in Kubernetes
    that monitors all of the components that make up our Funktion deployments, such
    as function, runtime, connector, and flow. It is responsible for creating the
    Kubernetes services that provide the Funktion functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Funktion is open source and is released under Apache License 2.0; it was developed
    by fabric8, which is an upstream project for Red Hat's JBoss Middleware platform.
    fabric8 itself is a Java-focused microservice platform based on Docker, Kubernetes,
    and Jenkins. It also works well with Red Hat's own OpenShift platform.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a little bit of background about how Funktion differs from
    the other frameworks, we can look at installing it on our single-node Kubernetes
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring Funktion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are three steps to get up-and-running with Funktion. First, we need to
    install the command line. This is where the bulk of the commands that deploy and
    manage our Funktion deployments will be entered. Once the command-line client
    is installed we can launch our single-node Kubernetes cluster using Minikube,
    before then using the Funktion CLI to bootstrap our environment.
  prefs: []
  type: TYPE_NORMAL
- en: The command-line client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like a lot of the frameworks we are covering, Funktion is written in Go. This
    means that there are standalone executables for our three platforms.
  prefs: []
  type: TYPE_NORMAL
- en: However, at the time of writing, there is no installer available using either
    Homebrew on macOS or Chocolatey on Windows 10 Professional, meaning that we will
    be doing a manual installation on all three platforms.
  prefs: []
  type: TYPE_NORMAL
- en: The executables are available from the project's releases page on GitHub, which
    you can find at [https://github.com/funktionio/funktion/releases/](https://github.com/funktionio/funktion/releases/).
    At the time of writing, the current version is 1.0.14 so the following instructions
    will cover the installation of that version; if you need to install a later version
    then please replace the version number in the following commands.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by working through how to install on macOS.
  prefs: []
  type: TYPE_NORMAL
- en: macOS 10.13 High Sierra
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Installing on macOS is simple, as the project has published uncompressed standalone
    executables. All we need to do is download the right package and make it executable.
    To do this, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the command-line tool is installed we can test it by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The Funktion version will be returned as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/684fc742-aa4d-49c0-83bd-4ab22703661d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, while the installation process is quite simple there is a downside
    to the package not being available within Homebrew. If it was, then it would be
    easier to update to later versions as Homebrew takes care of checking for and
    installing upgrades whenever you run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As it stands, you would have to remove the current version and download the
    new version in its place if you needed to upgrade.
  prefs: []
  type: TYPE_NORMAL
- en: Windows 10 Professional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The process for installing the Funktion command-line client on Windows is similar
    to that of macOS. First of all, open a PowerShell window as the admin user by
    selecting Run as Administrator from the PowerShell menu in the taskbar. Once open,
    you should see that you are in the folder `C:\WINDOWS\system32`; if you aren''t,
    then run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you are in the in the `C:\WINDOWS\system32` folder run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You should be able to then run the following command to check the version of
    the Funktion command-line client installed by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The Funktion version will be returned as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ece541a5-0e24-42fb-83f1-c3578a9c610e.png)'
  prefs: []
  type: TYPE_IMG
- en: Again, as we have not used a package manager to install Funktion upgrading,
    to do so you will have to remove the old executable and then repeat the installation
    process, making sure to update the version number in the URL to reflect your desired
    version.
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu 17.04
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lastly, we have Ubuntu 17.04\. The installation process is pretty much the
    same as the commands we executed for macOS. However, making sure that we download
    the correct executable and also that we use the `sudo` command as the permissions
    on the `/usr/local/bin` folder is slightly different between the operating systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once downloaded and made executable you should be able to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/05a226e2-1ff8-4f7a-8654-2beb75cd8fcd.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have the command-line client installed on our three operating systems
    we can progress with the deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Launching a single-node Kubernetes cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have noticed that we have again found ourselves in a position where
    we can now use the same command on whichever operating system you have used. This
    means that the remainder of the commands in the chapter will be able to run on
    all three of our target operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we launch our single-node Kubernetes cluster using Minikube, you can
    check to see if there are any updates by running the following commands. macOS
    10.13 High Sierra users can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then to check and update Minikube, run the following commands, starting with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This will present you with a list of the packages that can be updated. If Minikube
    is listed, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Windows 10 Professional users can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Ubuntu 17.04 users will need to check the release page details in [Chapter 3](7836cfd9-bce3-4d77-9331-f8dda5a31999.xhtml),
    *Installing Kubernetes Locally*, remove the old binaries, and repeat the installation
    process using the newer releases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have checked for updates to Minikube you can launch your cluster by
    running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As per [Chapter 3](7836cfd9-bce3-4d77-9331-f8dda5a31999.xhtml), *Installing
    Kubernetes Locally* and [Chapter 4](f1b36345-157f-4e54-970c-5f948110ad0f.xhtml),
    *Introducing Kubeless Functioning*, this will launch the single-node Kubernetes
    cluster and configure your local Kubernetes client to interact with it. If you
    have updated Minikube, you may also notice that a more recent version of Kubernetes
    is downloaded and installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ae41ec23-755c-4e99-817c-11ec3884c41d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you have upgraded Minikube, you can check everything is running using the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now we have our single-node Kubernetes cluster back up-and-running, the final
    stage in the Funktion installation is to bootstrap the deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping Funktion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Installing Funktion is really straightforward—in fact, it is a single command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8f6ea10f-3067-4c3d-a405-4c57cd5cc3dd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After a minute or two you should be able to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding commands will check the status of the deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/df639ea0-009b-40ca-a096-94488c7ea422.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You should also be able to see the Pods and Deployments in the Kubernetes dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b21219ed-9f41-4034-984f-8a4a82a2c85c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Running the following command should return an empty list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This proves that the Funktion command-line client can connect to your newly
    installed Funktion deployment and interact with it.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a simple function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our Funktion deployment up-and-running, we can look at deploying
    a really simple hello world example. In the `/Chapter05/hello-world/src` folder
    in the GitHub repository that supports this book, you will find a file called
    `hello.js`. This file contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the following command in the `/Chapter05/hello-world/` folder will
    create our first function using the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/600fedfc-5558-4f33-a151-a7981b66f6a5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see from the Terminal output, this has created a `function` called
    `hello`. Now, we have `function` running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This should return some results. As you can see from the following output,
    we can now see the `NAME`, `PODS`, and `URL` listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3ff904eb-5dd0-45c8-8d54-5a3cda0f18b0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can run the following commands to return just the `URL` of the function,
    or open it in our browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f9b79f93-0384-4443-b1d8-796a0f19eace.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The browser window that opens displays the following. I am sure you will agree
    it is not the most exciting of pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cdee65b3-4613-48ec-a18f-9d315546065c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'But it does demonstrate that our function is working and displaying content.
    You can display the logs for the function by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This will stream the log content in real-time to your Terminal window. You can
    see this by refreshing your browser a few times—you should see your page requests
    being logged alongside the internal health check requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our first function created, we can install some connectors.
    To do so, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have some connectors installed, we can create a flow. Our first
    flow will use the timer connector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a flow called `foo` that will execute every `5000` milliseconds,
    targeting our function called `hello`. To get information on the flow you can
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/692c3065-80b5-4b34-957c-ada291af1fdf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the flow is called `timer-foo1`; we will need to use this name
    when interacting with it. For example, you can check the logs for the flow by
    running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Or in the Kubernetes dashboard you can find the pod called `timer-foo1` and
    check the logs there:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6ae5d078-e47f-4af9-a05e-9d29cac3ef39.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Check the logs for the function by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see that there is a page request every five seconds from a client
    with a user agent of `Apache-HttpClient/4.5.2`. This is the timer flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/09ce6583-f8c7-45cf-8f48-c14acaa401e2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To remove the flow simply run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This will remove the pod running the connector and your function will stop receiving
    automated requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to the Kubernetes dashboard and clicking on Config Maps should display
    a list of everything that Funktion has created. As you can see, most parts of
    Funktion have a ConfigMap:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9943de0f-e06d-4673-a155-c34fe2a1fc81.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking on the Config Maps for `hello` will show you something that looks
    like the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4ac40215-c69f-42c1-ba2f-8d7853c9f080.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, this contains the code for our function and it has automatically
    detected that it is written in Node.js, and also that it was deployed from the
    `src` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we look at more advanced examples, there is one more thing which you
    might find interesting, and that is the integration with the *Chrome Dev* tools.
    To do this, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This opens a process in the foreground and give you a URL to put into Google
    Chrome:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/62def47d-76d9-4c17-bfd8-08798e93ca02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have Google Chrome open and pointed at your function you can perform
    tasks such as editing the code directly within the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1675f236-2d75-405f-af6c-cfc913783906.png)Any changes made using
    the Chrome Dev tools are made directly within the pod and they will not persist
    if you relaunch the pod; this should be used purely for testing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove our `hello` function we just need to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This should leave us with a clean installation ready for a more advanced example.
  prefs: []
  type: TYPE_NORMAL
- en: Twitter streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we installed the Twitter connector in the previous section, let''s take
    a look at configuring it to pull in some data. To start with, you can view all
    of the configurable options for the connector by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something like the following Terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8e704887-839f-4a85-b6e4-589f47c085c8.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can configure a proxy as well as providing an `accessToken`,
    `accessTokenSecret`, `consumerKey`, and `consumerSecret`. You should have these
    from the previous chapter. If not then regenerate them using the instructions
    in [Chapter 4](f1b36345-157f-4e54-970c-5f948110ad0f.xhtml), *Introducing Kubeless
    Functioning*.
  prefs: []
  type: TYPE_NORMAL
- en: Like the tokens and secrets I will be using to demonstrate the commands you
    need to run, the details listed in the preceding screenshot are the default dummy
    placeholder details and are not valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'To update the connector with your own details, run the following command, ensuring
    that you replace the details with your own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You should receive confirmation that the connector has been updated. Now, we
    are able to launch a flow that uses the Twitter adapter. To do this we should
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8b8b8510-287d-44c3-bf45-0b177377ac3e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have started the pod, you can check the logs by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Or by viewing the logs for the `twitsearch` pod in the dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b28585bf-ed9d-461c-876f-5ba68769c7c6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, Camel is printing a stream of tweets that contain the work
    Kubernetes. Your application can subscribe to this stream and you can then process
    the tweets. Finally, running the following command will delete the flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You can then remove your Minikube machine using the `minikube delete` command.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have taken a brief look at Funktion. We installed the command-line
    client and then installed it on our single-node Kubernetes cluster. Once deployed
    we launched a test function and interacted with it before using one of the many
    event streams to search for tweets containing Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Funktion is still in its early stages of development and it currently has a
    small, but active, community making contributions on the project's GitHub pages.
    Because of this, at the time of writing there are not too many practical examples
    of full-blown applications that take advantage of the many flows that Funktion
    supports via Apache Camel. I would recommend keeping an eye on Funktion if you
    are planning on writing any applications that ingest data and then process it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we are going to look at taking our Kubernetes cluster from
    a single-node on our local machine to a multi-node cluster hosted on public clouds.
  prefs: []
  type: TYPE_NORMAL
