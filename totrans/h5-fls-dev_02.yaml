- en: Chapter 2. Preparing for the Battle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you understand what technologies make up HTML5, we can start getting
    our hands dirty. But before we jump right into coding HTML, CSS, and JavaScript,
    we need to cover the fundamentals of the first step of developing a project, asset
    preparation. Without a design, assets, and content, your web pages won't be very
    appealing or, for that matter, functional. During the preparation we will also
    dig into the syntax specification for JavaScript and how it's related to ActionScript
    3, to prepare us for full-fledged development in [Chapter 3](ch03.html "Chapter 3. Scalability,
    Limitations, and Effects"), *Scalability, Limitations, and Effects*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: The preparation of common assets such as images, audio, and video for use within
    an HTML5 document
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In-browser code outputs and debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basics of JavaScript and the syntax variance from ActionScript 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples of JavaScript in action and the proper methods for code execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing the asset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While developing applications in Flash, integrating assets such as images, audio,
    and video into a typical project can be accomplished in a couple of different
    ways. You may choose to integrate assets in the typical way by importing them
    directly in a Flash project library. The addition of an asset into a Flash project
    results in the asset inclusion into the compiled SWF file. Since all assets are
    compiled within a single file, there is no need to acquire assets from external
    resources such as the Internet. Assets within a compiled Flash project are inherently
    protected from acquisition or being referenced by public.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, assets internally referenced within the project library cannot
    be updated or changed once the project has been exported. Developing applications
    such as a video playback UI or photo gallery requires assets to be integrated
    dynamically, resulting in a single application instance that can be used infinitely.
    External assets may be integrated via requests for external files which are publicly
    accessible on the Internet. External integration allows for smaller application
    sizes as well as the ability to modify the external assets without the need for
    application updates. Unfortunately, if the file is unavailable or the user isn't
    connected to the Internet, the asset cannot be integrated and may result in a
    failure within the application.
  prefs: []
  type: TYPE_NORMAL
- en: External asset integration is the standard way of including content into web-based
    documents. Files that will be referenced by HTML documents are typically placed
    on the same web server as the HTML documents embedding them.
  prefs: []
  type: TYPE_NORMAL
- en: Assets can also be referenced from other web servers on the Internet, however
    the content is at the mercy of the developers or administrators with access to
    that content. Developer's laziness or attempts to lower bandwidth costs can result
    in images or other assets being embedded from external sources, moving bandwidth
    charges to a web server other than your own. This process is known as **hotlinking**
    and is frowned upon within the web development community, as you force other website
    owners to deal with the cost of asset distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Due to lack of automatic optimization of web content as in the compiler in Flash,
    web developers must take it upon themselves to prepare their content and assets
    for web usage. Since web content is delivered on demand to users over variable
    Internet connection speeds, assets should be as small in file size as possible
    to allow playback and viewing with as little latency as possible for the end user.
    Let's review each of the common asset types and the proper methods for preparing
    each of them for embedding into our HTML documents.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the assets used for optimizations and conversions can be found in the downloadable
    examples files for book within the `Chapter 02_examples` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Adding images into your project is usually one of the first asset integration
    techniques used in every web-based project. All images on the Web generally come
    in one of three different formats: JPEG, PNG, or GIF. Each of these formats serves
    specific purposes and should be used according to what a design and function requires.
    As common as these image formats are within everyday use, it is important to understand
    what each format can and can''t do to allow for optimized image integration into
    HTML documents.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Follow this book along with the example files available for download on the
    Packt Publishing website ([www.packtpub.com](http://www.packtpub.com)). If you
    don't have a copy of Photoshop CS6, a demo for the same can be downloaded and
    installed for free from [http://www.adobe.com/cfusion/tdrc/index.cfm?product=photoshop&loc=en_us&promoid=IICUB](http://www.adobe.com/cfusion/tdrc/index.cfm?product=photoshop&loc=en_us&promoid=IICUB).
  prefs: []
  type: TYPE_NORMAL
- en: Consider this high-quality, uncompressed image in **CR2** format taken directly
    from a Cannon digital SLR camera. The size of this raw image is 27 megabytes and
    hence it isn't compatible for viewing or embedding within any modern web browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](img/3325OT_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Even if a web browser could handle placing this image within an HTML document,
    the time it would take to download the image would be enormous. Despite today's
    common high-speed Internet connections, not many users are willing to wait more
    than a couple of minutes to view a single image while loading a web page. Therefore,
    before using this image for the Web, it must be optimized for the Web. When this
    CR2 image is opened in Photoshop, the Photoshop Camera RAW window will display
    not only the photo data and file size but also the image dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](img/3325OT_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It looks like the digital camera used to take this photo saved this image at
    17.9 megapixels, which makes this image 5184 pixels wide and 3456 pixels high.
    This image would never be used at this resolution on the Web as it wouldn't fit
    on a computer monitor and would need to be scaled down in order to be viewed.
    Scaling down an image for using it on the Web may make it smaller in size and
    easier to view on the Web, but the file needed to display it is still the enormous
    master version that will be slow to load. Let's continue by opening this file
    in Photoshop by selecting **Done** within the Camera RAW import window.
  prefs: []
  type: TYPE_NORMAL
- en: It is good practice to export a web-ready version of your images with the resolution
    your web page design requires them to be displayed at. Changing the image resolution
    to an appropriate size for the Web can be easily accomplished within Photoshop
    by selecting **Image Size** under the **Image** tab.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](img/3325OT_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the **Image Size** window, we can enter some more realistic values into the
    **Width** and **Height** parameters to see what kind of optimizations we can achieve.
    By using values such as 1920 x 1280, which is still a very high-resolution image
    for the Web, you can view what the expected output image source file size will
    be in the text above the **Width** and **Height** parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](img/3325OT_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After updating the **Width** and **Height** parameters within the **Image Size**
    window, the resulting file size can be viewed immediately above them. Keep in
    mind that the file size change displayed will not be the final output size as
    we can still optimize this image source with techniques such as JPEG compression.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While optimizing image sizes for usage within a specific web design, there is
    generally no need to export images larger in size than what is set within a design.
    If a thumbnail is needed within a design, exporting two images, a large and a
    small, is better than using a single image for both instances.
  prefs: []
  type: TYPE_NORMAL
- en: Photoshop's **Save for Web** feature located under the **File** tab can be said
    to be web developers' best friend. This tool allows you to easily export images
    from Photoshop with the specific intent of optimization for the Web in mind. Whether
    spicing up designs or converting assets to single instances, whenever you are
    going to export something from Photoshop for usage on the Web, this tool is the
    best way to accomplish it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](img/3325OT_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Clicking on the **Save for Web** option will open a dedicated window that will
    aid you in selecting the best format and compression method while exporting your
    data. So let's export a couple of versions of this photo to see what can be the
    minimum possible file size while trying to retain as much image quality as possible.
  prefs: []
  type: TYPE_NORMAL
- en: With the format type set to **JPG** to allow for better compression, select
    the **4-Up** tab at the top of the window to bring up side-by-side comparisons
    of different levels of compression on your image data. Play around with these
    values and see how low you can take the quality levels before you see dramatic
    changes to your image. While doing this, keep an eye on the expected file size
    to see how the level of compression is affecting the size.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](img/3325OT_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The background of this dog photo specifically takes a hit in quality as the
    compression level rises. This is due to the long grass creates a very dynamic
    and busy area where pixilation can be seen. Areas within the dog's solid color
    body maintain more of the original quality as the pixels in the same area are
    very similar in color. Another interesting feature within the **Save for Web**
    window is the expected time to download output each version of image has with
    it. You can easily change the expected bandwidth levels to see how much time it
    may take to deliver this image to a user over the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since every image is different, there is no single perfect optimization setting.
    Taking the time to make sure that each image looks its best at the smallest file
    size will reward you with a better looking website that loads quickly.
  prefs: []
  type: TYPE_NORMAL
- en: For example purposes, I have exported this image in a couple of different resolutions
    and compression levels using the JPEG format.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](img/3325OT_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from preceding the file listing, we initially started out with
    a 27-MB photo taken directly from a digital SLR camera. Using different exporting
    methods in Photoshop, we can easily get a decent version of the same image with
    a smaller resolution in a file that is well under 500 kilobytes. Considering that
    in a fully developed web page this image could be one of many, the general rule
    of thumb is to keep every image files size as small as possible. This will allow
    your content to load quickly and display properly for the design you have created.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, as previously mentioned, JPG is not the only image format available
    for use within web pages. Let's quickly cover each of the formats and what each
    of them brings to the table.
  prefs: []
  type: TYPE_NORMAL
- en: JPEG
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Outputting an image as `.jpeg` or more commonly `.jpg` allows for lossy image
    compression, which aims to decrease file size by discarding some of the data within
    the image. The amount of compression used when saving in JPEG format is typically
    user defined, allowing designers and developers to create a smaller file than
    the original such that is as close to its source as possible. One of the major
    downsides to the JPEG format is the lack of transparency support as the format
    contains no alpha channels.
  prefs: []
  type: TYPE_NORMAL
- en: PNG
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Portable Network Graphics** (**PNG**) is a bitmap image format that doesn''t
    use compression when saving image data. PNG images are great for design and asset
    images as they retain the quality and color palette used in design and also support
    transparency. However, they are not typically utilized for images such as photographs,
    as the resulting file size will be too large due to the amount of details in the
    image.'
  prefs: []
  type: TYPE_NORMAL
- en: GIF
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The beloved GIF file, or more commonly seen nowadays as the **animated GIF**
    has been available for usage since CompuServe released the format in 1987\. GIF
    images support 256 colors, transparency, as well as animations via multiple image
    frames. Though it is still in use all around the Web till date, due to the lack
    of timeline control of animated images, techniques such as sprite sheets (of which
    we will cover more in the following chapters) are becoming more popular for animated
    image integration.
  prefs: []
  type: TYPE_NORMAL
- en: Audio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Preparing audio for the Web is relatively straight forward as majority of web
    browsers support **MP3** audio formats within HTML5's new audio element. Aside
    from MP3, some browsers support the use of **OGG** audio files. Therefore, exporting
    audio in either of the formats will allow you to target all modern HTML5 compatible
    browsers and ensure that your end user hears the audio regardless of what browser
    they choose to view your content with.
  prefs: []
  type: TYPE_NORMAL
- en: The audio element
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Creating the `audio` element, as with HTML syntax for most of the elements,
    is pretty straight forward. One major difference from traditional source references
    within HTML elements is the use of the `source` element which is encased within
    the `audio` element. By utilizing this new `source` element, we can reference
    multiple assets within the same element and load only the first file which is
    compatible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If a user attempts to open this element within a browser with no HTML5 audio
    support, the remaining internal content within the `audio` element will be displayed.
    In this case, we display only text, but you could easily append a reference to
    a Flash audio playback application or a warning styled with CSS. However, if all
    is well with the browser as per the given requisites, the page will display an
    audio playback UI that look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The audio element](img/3325OT_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The audio playback control user interface is specific to the browser displaying
    the data. The preceding image is what Google Chrome currently renders as its internal
    audio playback control user interface. Default audio controls can be removed by
    excluding the `controls` parameter within the `audio` tag element. Without the
    default control UI, you can build your own controls with images, HTML, and CSS
    and control them with JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Video
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned in [Chapter 1](ch01.html "Chapter 1. Why HTML5?"), *Why HTML5?*,
    video integration into HTML5 documents is now easier than ever. As simple as integrating
    video into HTML5 documents is, it all begins with preparing the video for use
    on the Web. This process should not only minimize the size of the video file but
    also encode it with a specific codec and save it within a specific video container.
  prefs: []
  type: TYPE_NORMAL
- en: The HTML5 `video` tag supports the inclusion of multiple video container formats.
    While attempting to support the full range of HTML5 compliant browsers, developers
    must include references to the same video saved in multiple formats as not every
    browser supports all of the allowed video file types. Therefore, a solid understanding
    of video containers and codecs is necessary for web developers to properly integrate
    video into their documents.
  prefs: []
  type: TYPE_NORMAL
- en: '![Video](img/3325OT_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Video codecs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Codecs are used for compression and decompression of videos, to decrease file
    size and allow large video files to be shared using less bandwidth. Without the
    use of compression on video files, users would have to wait an inordinate amount
    of time to transfer a video over a typical Internet connection. To put this into
    perspective, a raw high-definition video, around 5 minutes in length, can be well
    over 25 GB of data. Video codecs are made up of advanced algorithms that remove
    similar data that blends from frame to frame. Rather than storing each individual
    frame as a separate image, an encoded video stores a specialized data set that
    is usually many times smaller than the raw source material. For viewing, the encoded
    data needs to be decoded from the streamlined data source back to viewable frame-based
    video. Codecs are the all-in-one piece of technology to get this task completed.
    Each of the supported video containers in HTML5 supports only one video codec,
    so choosing one is pretty straight forward. However, since video is usually accompanied
    by audio, the audio must also be run via a specific audio codec as well.
  prefs: []
  type: TYPE_NORMAL
- en: Video containers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the major issues while attempting to embed video into an HTML5 document
    is supporting all modern browsers with the same content. Unfortunately, not all
    the HTML5 compatible browsers available support the same video formats. Therefore,
    in order to support the widest range of browsers, developers must embed multiple
    versions of the same video file encoded in multiple formats. Since this issue
    is not likely to change anytime in the near future, understanding the available
    video containers and their corresponding codecs is an important step in preparing
    video for your HTML5 documents.
  prefs: []
  type: TYPE_NORMAL
- en: MP4
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: From the perspective of a Flash developer, the **MP4** container should be the
    most familiar as they are very similar to **FLV** or **F4V** files. **MPEG-4**
    or MP4 containers are currently supported for embedding within the video element
    by Internet Explorer 9+, Google Chrome, and Safari. MP4 videos must be encoded
    using the **H.264** codec, which was also used by FLV and F4V videos in Flash.
  prefs: []
  type: TYPE_NORMAL
- en: WebM
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The WebM audio and video format is a project sponsored by Google to bring a
    completely open multimedia container and codec to the Web. WebM files are supported
    by Firefox, Google Chrome, and Opera. When encoding videos for use within a WebM
    container, the VP8 video codec, which is also owned by Google, is used.
  prefs: []
  type: TYPE_NORMAL
- en: GG
  prefs: []
  type: TYPE_NORMAL
- en: '**OGG** containers are supported by Firefox, Google Chrome, and Opera. When
    encoding videos for use within a OGG container, the **Theora** codec is used.
    Since the full spectrum of browsers is covered by using just MP4 and WebM videos,
    encoding in OGG format is not entirely necessary. There is no harm in adding it
    as a failsafe anyways; only the first video file format the browser finds within
    the source list is utilized during display, all of the other files are ignored
    and not downloaded.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sample encoded video files as well as the high-quality master video file can
    be found within the `Chapter 02_examples` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Video encoding software
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many great applications available online that can encode your video
    content into formats compatible with HTML5\. As long as the container and codec
    specification is met, any application or method can be used to get the job done.
    To aid in getting you up and running, for this chapter and the remainder of this
    book, here are some of the most popular encoding tools and applications web developers
    use to get videos on the Web in a snap.
  prefs: []
  type: TYPE_NORMAL
- en: Miro Video Converter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you are looking for a simple way to get videos ready for the Web, look no
    further than Miro Video Converter, which can be found on Miro's website [http://www.mirovideoconverter.com](http://www.mirovideoconverter.com).
    This software is not only free and open source but also supports exporting videos
    and audios in all HTML5 compatible formats. Miro Video Converter is available
    for Windows and OS X and is probably the easiest way to prepare audios and videos
    for your HTML5 projects.
  prefs: []
  type: TYPE_NORMAL
- en: '![Miro Video Converter](img/3325OT_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With the application installed and opened, the next step is to simply drag-and-drop
    your source video file into the application for queuing. If you have multiple
    videos, you can also add them to the queue and all of them will be encoded one
    after another.
  prefs: []
  type: TYPE_NORMAL
- en: '![Miro Video Converter](img/3325OT_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once all the videos you require to be encoded have been added to the queue,
    select the **Format** option at the bottom of the window and select one of the
    three available formats within the convertor. Keep in mind that to enable video
    element playback support in every browser, you will need to encode your videos
    once in each format. If you require more in depth configuration in the encoding
    job, Miro Video Converter allows us to control basic parameters such as aspect
    ratio and video dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: Adobe Media Encoder
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Flash developers who have included videos within their projects have probably
    made use of the Adobe Media Encoder. This handy software comes bundled with Flash
    and can easily encode videos for use within Flash and HTML5 projects. Unfortunately,
    this application will only output videos natively in Flash video formats of HTML5-ready
    MP4.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adobe Media Encoder](img/3325OT_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Handbrake
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don't have access to Adobe Media Encoder, then the next easiest way to
    encode MP4 videos for free is by heading over to [http://handbrake.fr](http://handbrake.fr)
    and downloading Handbrake. Not only is Handbrake open source but also it is built
    for Windows, OS X, and Linux so it's hard to be left out in the cold.
  prefs: []
  type: TYPE_NORMAL
- en: '![Handbrake](img/3325OT_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: FFMPEG
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Finally, my personal favorite, FFMPEG. If you are a lover of the command line
    as I am, this amazing piece of software is for you. When it comes to media, it's
    hard to say what FFMPEG can't be used to accomplish. If you're in need of high-level
    video transcoding, be sure to visit [http://ffmpeg.org](http://ffmpeg.org) to
    learn more.
  prefs: []
  type: TYPE_NORMAL
- en: The video element
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once our video content has been encoded in the necessary formats, all that
    is left is to do is to reference the video from within the body of the HTML document.
    Just like the `audio` element, instead of the typical `src` parameter used within
    an tag to create a reference to the file, the `video` element supports the `source`
    tags within the `video` element to allow referencing multiple assets. It should
    be noted that if you are only embedding a single video reference, the `src` parameter
    within the `video` tag can be used rather than adding the `source` tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Again, just like the `audio` element, the `video` element allows for playback
    control integration by appending the `controls` parameter in the `video` tag.
    Videos can be played automatically on page load by appending `autoplay="true"`
    in the `video` tag.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have all of our assets prepped and ready for action, it's about
    time to start moving into the development environment. Since the web browser is
    our target platform, let's take some time to cover what the modern web browsers
    of today give us in terms of web developer tools to aid us in our development
    cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging and output methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the popularity of HTML5 and other heavily client-side driven web content,
    comes the need for a robust developer toolset to allow for easy debugging and
    testing of web pages. Fortunately, each of the modern browsers have adapted or
    integrated some very similar setups for doing just this. One of the most important
    features within this toolset is the JavaScript console. The JavaScript console
    is to web developers what the Flash Output window is to Flash developers. This
    is a critically important area to print data from initialized applications or
    websites and print statements or values specified within the code. In ActionScript,
    printing data to the output window is accomplished by using the `trace()` function.
    In JavaScript, we utilize the `console` object''s built-in methods for doing the
    same. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This example can be found within the `Console-Example` directory within the
    `Chapter 02_examples` directory.
  prefs: []
  type: TYPE_NORMAL
- en: This code example creates a function in JavaScript to calculate the sum of numbers
    and calls the method with example parameters to display the output in the browser
    console. Similar to traces in ActionScript, console integration in JavaScript
    works behind the scenes, segregated from the actual web page. The primary function
    of the console is to aid a developer with debugging JavaScript, CSS, or HTML properties
    during runtime. Not only can the developer console be used for printing data from
    the application but it can also be used to trigger specific functions in your
    code without the need for a specific event or interaction to take place.
  prefs: []
  type: TYPE_NORMAL
- en: As important as the console is, the entire user interface and interaction changes
    depending on what browser is being used to view the document. Therefore, understanding
    where to find and how to use the console in all popular browsers is an important
    step in helping you build robust code. Let's quickly run our simple calculate
    sum example in a couple of the common browsers to see how they handle the output.
  prefs: []
  type: TYPE_NORMAL
- en: Google Chrome
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All versions of Google Chrome come packaged with a built-in developer toolset
    and it can be easily opened by right-clicking on a web page and selecting the
    **Inspect Element** option in the dialog box. This will reveal the developer tools
    window attached to the bottom of the browser window. Selecting the **Console**
    tab will display the JavaScript console to view the output from the web page.
    Opening our JavaScript `calculateSum` function example in Chrome with the console
    open should display something like the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Google Chrome](img/3325OT_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the output from the `console.log()` call has been displayed
    along with what file and line number the call was dispatched from. Even from a
    simple perspective, I am sure you are starting to see how handy this tool could
    be if you have 100 or even 1000 lines of code in multiple files to deal with.
    As similar to the output window for traces in ActionScript this tool is, the cherry
    on top of the pie is its ability to invoke further JavaScript execution directly
    from the console window. Within the console, we can continue and find the sum
    of new numbers by calling the `calculateSum` function with the necessary values
    directly from the console.
  prefs: []
  type: TYPE_NORMAL
- en: '![Google Chrome](img/3325OT_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Some browsers, such as Chrome, even have auto completion feature that expands
    the text as you type in method or property names, a feature I am sure most Flash
    developers wished they had within the Flash IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Firebug for Firefox
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since Firefox does not come pre-packed with a robust developer toolset, a common
    option for web developers is to install the **Firebug** extension to enable this
    feature. The extension can easily be added to your Firefox installation in a couple
    of seconds by visiting [http://getfirebug.com](http://getfirebug.com). Once installed
    and activated, right-click anywhere on a page and select **Inspect Element with
    Firebug**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Firebug for Firefox](img/3325OT_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This should all feel pretty familiar to what we did within Chrome. Firebug is
    a great little project that almost all developers I know utilize. There are a
    ton of great features in all of these toolsets, many of which we will touch on
    in this book. Since we have a very simple HTML page open with barely anything
    in it, now might be a good time to see the UI and output from a more vanilla web
    page, so feel free to click around and check things out.
  prefs: []
  type: TYPE_NORMAL
- en: '![Firebug for Firefox](img/3325OT_02_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Safari
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To enable the developer tools in Safari, open the **Preferences** window and
    select the **Advanced** tab. Select the check box at the bottom of the window
    labeled **Show Develop menu in menu bar** and then you can close the window.
  prefs: []
  type: TYPE_NORMAL
- en: '![Safari](img/3325OT_02_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From this point on, you can right-click, as usual, on any web page and select
    **Inspect Element** to display the tools window.
  prefs: []
  type: TYPE_NORMAL
- en: '![Safari](img/3325OT_02_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you were paying attention, you may notice that this console is almost identical
    to the console within Google Chrome. Of course, it has a command-line integration
    as we have seen in the other browsers.
  prefs: []
  type: TYPE_NORMAL
- en: '![Safari](img/3325OT_02_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Opera
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to Google Chrome, the developer tools in Opera can be easily accessed
    by right-clicking on a web page and selecting **Inspect Element**. Once the developer
    tools window opens at the bottom of the browser, select the **Console** tab to
    open the developer console. Initially, the console will be blank and clear of
    any interaction from the web page you are currently viewing.
  prefs: []
  type: TYPE_NORMAL
- en: '![Opera](img/3325OT_02_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Rather than having the console always active, Opera has decided to read console
    commands only when the console is actually open. Therefore, refreshing the page
    will reveal the console interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Opera](img/3325OT_02_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Internet Explorer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As of Internet Explorer 9, Microsoft has begun including a developer's toolset
    directly within the browser. The **Developers Tools** window can be opened at
    anytime by pressing *F12* while viewing a page. Just like Opera, Internet Explorer
    requires a page to be refreshed to enable the usage of the console on the active
    page, as it stays inactive when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Internet Explorer](img/3325OT_02_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Of course, just like every other console, we can call our JavaScript methods
    and variables from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: '![Internet Explorer](img/3325OT_02_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Syntax differences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have some media to work with and the browser tools at our disposal,
    let's start some more toying with JavaScript and compare its syntax to what you
    already know in ActionScript 3.
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike variables declared within ActionScript 3, JavaScript variables are not
    strictly typed. This takes the familiar ActionScript 3 variable declaration from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'to a simpler syntax within JavaScript which looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This lack of strict typing is referred to as dynamic typing. Variables in JavaScript
    can be used as any type at any time. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Dynamic typing allows code to be writing faster by requiring less input from
    the developer, but this development ease comes at the cost of debugging large
    applications. ActionScript 3's strict typing allows the compiler to catch issues
    even before exporting a new version of your application. JavaScript will not do
    this natively, and it is probably one of the biggest complaints most developers
    with prior ActionScript 3 experience have when using the language.
  prefs: []
  type: TYPE_NORMAL
- en: Variable type conversion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Although variables in JavaScript are not strictly typed, there are methods
    to ensure that variable data is in correct form for the desired action. Type conversion
    can be used on variables to ensure they are formatted properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Conditions and loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will cover these two aspects together as the syntax for conditions and loops
    in JavaScript are almost the same to what you are used to in ActionScript 3\.
    `If`, `if... else`, and `if... else if` conditions are no different than that
    in ActionScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, the `switch` statements can be used and just like `if` statements; the
    syntax is exactly the same as that in ActionScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Loops are no different to their counterparts in ActionScript. Consider these
    `for` and `while` loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As in ActionScript 3, functions in JavaScript are blocks of code encased within
    curly braces (`{ }`). Every function is associated with a keyword that is used
    to call the function and run the encased code within it. As usual, functions may
    return values back to the point where the call was originally made. This is accomplished
    using the `return` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of JavaScript function is very similar to ActionScript functions
    but is without the need for strict typing of expected parameters and the function
    return types. As a Flash developer, your ActionScript 3 functions probably looked
    something like the follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This syntax can be easily converted to JavaScript just by removing the variable
    and return type declarations so that the same function in JavaScript can be written
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Technically, everything declared in JavaScript is an object, however, time
    will come when you will need to create your own custom objects. This can be done
    in one of the following two manners. The first one, which should be very familiar
    to ActionScript developers is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also create objects by defining them as a functions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: DOM events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Integrating DOM events allows you to use JavaScript to deal with events that
    occur within HTML documents.
  prefs: []
  type: TYPE_NORMAL
- en: Mouse events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The DOM exposes mouse events for basic user interactions with the mouse pointer.
    By using the `onclick` event parameter within an HTML tag, we can execute JavaScript
    when a user clicks on a specific element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we can also target the element completely from JavaScript and deal
    with the event handler outside our HTML source code, to keep our project clean
    and easy to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you are not limited to just clicks for mouse events. Events can also
    be handled for mouse over, mouse out, mouse down, and mouse up. In the examples
    within this book, we will utilize all of these events as well as methods to extend
    them even further.
  prefs: []
  type: TYPE_NORMAL
- en: Example JavaScript in action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With all of the JavaScript syntax specifications covered, let''s use some of
    them into a working example and see what happens. Have a look at the following
    simple HTML document containing JavaScript to sort a randomized array of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This example covers many of the features and syntax specifications of JavaScript
    that we have just covered. Within our JavaScript block declared in the HTML document
    `head` tag, we have created two functions. The first function is our initiation
    method to prepare and run the application once it called. The second function
    contains the popular insertion sort algorithm, which will sort our randomized
    array of numbers. To enable both functions to use the same variable, we create
    `elementCount` and `sortlist` as global variables outside of each function's scope.
    Within the HTML `body` tag is a `button` element, which renders a typical form
    button element on the page and when a user clicks this button, the `onclick` handler
    calls the `init` function.
  prefs: []
  type: TYPE_NORMAL
- en: This example isn't flashy by any means but, as I mentioned above, it covers
    many of the different aspects of the JavaScript syntax specifications.
  prefs: []
  type: TYPE_NORMAL
- en: Timing JavaScript execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One important point to note while dealing with JavaScript execution timing
    is to be sure that the entire page has finished loading prior to allowing the
    JavaScript to begin executing its code. The reason for waiting for page to load
    is to allow all of the assets and external references to load on the page before
    attempting to manipulate them. If your JavaScript attempts to perform an action
    on an element that doesn''t exist, your application flow could fail. To avoid
    this issue, we can add an event listener to the DOM allowing it to run only once
    the page has been completely loaded and comes to display. Utilizing the DOM event
    for JavaScript offers an easy way to do just this as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, when the window has completed its load process the `init` function is called
    and the remainder of the application code can begin execution. JavaScript actually
    has a number of ways to accomplish execution of the code, specifically once the
    page has finished loading. The following chapters of this book will use and explain
    many of them using examples.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we spent some time to better familiarize ourselves with the
    process involved in preparing media assets for our HTML5 projects. Also, preparation
    and integration techniques for each of the typical multimedia formats as well
    as some popular pieces of software available to aid in getting this done were
    covered in this chapter. We took a quick jump right into ActionScript 3 versus
    JavaScript syntax in order to become more familiar with the small but important
    difference while writing JavaScript compared to ActionScript 3\. This sets us
    up perfectly for [Chapter 3](ch03.html "Chapter 3. Scalability, Limitations, and
    Effects"), *Scalability, Limitations, and Effects*, where we will begin putting
    HTML5 to the limits in order to see what are its limitations and short comings
    as well as all of the surprising things it can do.
  prefs: []
  type: TYPE_NORMAL
