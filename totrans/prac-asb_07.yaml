- en: Consuming and Creating Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book, we have almost constantly referred to and made use of
    Ansible modules. We have treated these as "black boxes" – that is to say, we have
    just accepted that they exist and that they will work in a certain documented
    manner. However, one of the many great things about Ansible is that it is an open
    source product, and as such, not only can you view and modify its source code,
    but you can also write your own additions. To date, there are literally thousands
    of modules available for Ansible, handling everything from simple commands such
    as copying files and installing packages, through to configuring highly complex
    and bespoke networking equipment. This large array of modules has grown out of
    a genuine need to solve problems with Ansible, and the number included with each
    release of Ansible increases every time.
  prefs: []
  type: TYPE_NORMAL
- en: Sooner or later, you will come across a specific piece of functionality that
    doesn't exist in any of the current Ansible modules. Of course, you could attempt
    to fill this gap in functionally, either by writing your own module or by contributing
    enhancements to one of the existing modules back to the Ansible project for everyone
    else to benefit from. In this chapter, you will learn the basics of creating your
    own modules, as well as how to contribute your code back to the upstream Ansible
    project if you wish.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, in this chapter, you will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Executing multiple modules using the command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing the module index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing module documentation from the command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module return values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing custom modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter assumes that you have set up your control host with Ansible, as
    detailed in [Chapter 1](0efc8364-b8a4-4866-9ff4-1e2d09f6724b.xhtml), *Getting
    Started with Ansible*, and are using the most recent version available – the examples
    in this chapter were tested with Ansible 2.9\. This chapter also assumes that
    you have at least one additional host to test against. Ideally, this should be
    Linux-based. Although we will give specific examples of hostnames in this chapter,
    you are free to substitute them with your own hostname and/or IP addresses. Details
    of how to do this will be provided in the appropriate places.
  prefs: []
  type: TYPE_NORMAL
- en: The module development work that will be covered in this chapter assumes the
    presence of a Python 2 or Python 3 development environment on your computer and
    that you are running either Linux, FreeBSD, or macOS. Where additional Python
    modules are needed, their installation is documented. The task of building module
    documentation has some very specific requirements around Python 3.5 or later,
    so you will need to install a suitable Python environment if you wish to attempt
    this.
  prefs: []
  type: TYPE_NORMAL
- en: The code bundle for this chapter is available here: [https://github.com/PacktPublishing/Ansible-2-Cookbook/tree/master/Chapter%205](https://github.com/PacktPublishing/Ansible-2-Cookbook/tree/master/Chapter%205).
  prefs: []
  type: TYPE_NORMAL
- en: Executing multiple modules using the command line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As this chapter is all about modules and how to create them, let's recap how
    to use modules. We've done this throughout this book, but we have not drawn attention
    to some of the specifics related to how they work. One of the key things we have
    not discussed is how the Ansible engine talks to its modules and vice versa, so
    let's explore this now.
  prefs: []
  type: TYPE_NORMAL
- en: 'As ever, when working with Ansible commands, we need an inventory to run our
    commands against. For this chapter, as our focus is on the modules themselves,
    we will use a very simple and small inventory, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, for the first part of our recap, you can run a module very easily via
    an ad hoc command and use the `-m` switch to tell Ansible which module you want
    to run. Hence, one of the simplest commands you can run is the Ansible `ping` command,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, one thing we have not previously looked at is the communication between
    Ansible and its modules; however, let''s examine the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Did you notice the structure of the output – the curly braces, colons, and commas?
    Yes, Ansible uses JSON-formatted data to talk to its modules, and the modules
    report their data back to Ansible in JSON as well. The preceding output is, in
    fact, a subset of the JSON-formatted data returned to the Ansible engine by the
    `ping` module.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we never have to worry about this as we work with the modules using
    either `key=value` pairs on the command line or YAML in playbooks and roles. Hence,
    the JSON is shielded from us, but this is an important fact to bear in mind as
    we head into the world of module development later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible modules are just like functions in a high-level programming language,
    in that they take a well-defined list of arguments as input, perform their function,
    and then provide a set of output data, which is also well-defined and documented.
    We'll look at this in more detail later in this chapter. Of course, the preceding
    command didn't include any arguments, so this was the simplest possible invocation
    of a module via Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s run another command that takes an argument and passes that data
    to the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we provided a single string as an argument to the command module,
    which Ansible, in turn, converts into JSON and passes down to the command module
    when it''s invoked. When you run this ad hoc command, you will see an output similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this instance, the output data does not appear to be JSON formatted; however,
    what Ansible prints to the Terminal when you run a module is only a subset of
    the data that each module returns – for example, both the `CHANGED` status and
    `rc=0` exit code from our command were passed back to Ansible in a JSON-formatted
    data structure – this was just hidden from us.
  prefs: []
  type: TYPE_NORMAL
- en: 'This point doesn''t need to be labored too much, but it is important to set
    a context. It is this context that we shall build upon throughout this chapter,
    so simply remember these key points:'
  prefs: []
  type: TYPE_NORMAL
- en: Communication between Ansible and its modules is done through JSON-formatted
    data structures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules take input data that controls how they function (arguments).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules always return data – at the very least, the status of the module's execution
    (for example, `changed`, `ok`, or `failed`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, before you start coding your own modules, it makes sense to check
    whether a module that can perform all (or some) of the functionality you need
    already exists. We will explore this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the module index
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As discussed in the preceding section, Ansible provides thousands of modules
    to make it fast and easy to develop playbooks and run them across multiple host
    machines. How do you go about finding the right module to begin with, though,
    when there are so many? Fortunately, the Ansible documentation features a well-organized,
    categorized list of modules that you can consult to find your desired module – this
    is available here: [https://docs.ansible.com/ansible/latest/modules/modules_by_category.html](https://docs.ansible.com/ansible/latest/modules/modules_by_category.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s suppose you want to see whether there is a native Ansible module that
    can help you configure and manage your Amazon Web Services S3 buckets. That''s
    a fairly precise, well-defined need, so let''s approach this in a logical manner:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by opening the categorized module index in your web browser, as discussed
    previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, we know that Amazon Web Services is almost certainly going to feature in
    the `Cloud` modules category, so let's open that in our browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are still hundreds, if not thousands, of modules listed on this page!
    So, let''s use the Find function (*Ctrl* + *F*) in the browser to see whether
    the `s3` keyword appears anywhere:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/dfa7f773-fcca-4f39-ae84-a0ecd968e7e9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We''re in luck – it does, and there are several more listings further down
    the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f0611a81-5115-4749-9a37-ff80186fc8d1.png)'
  prefs: []
  type: TYPE_IMG
- en: We now have a shortlist of modules to work with – granted, there are several,
    so we still need to work out which one (or ones) we will need for our playbook.
    As shown from the preceding short descriptions, this will depend on what your
    intended task is.
  prefs: []
  type: TYPE_NORMAL
- en: 'The short descriptions should be enough to give you some clues about whether
    the module will suit your needs or not. Once you have an idea, you can click on
    the appropriate document links to view more details about the module and how to
    work with it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/cff1ffb2-7801-4c9f-ae0d-605181e91ae3.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the documentation page for each module provides a great deal
    of information, including a longer description. If you scroll down the page, you
    will see a list of the possible arguments that you can provide the module with,
    some practical examples of how to use them, and some details about the outputs
    from the module. Also, note the Requirements section in the preceding screenshot –
    some modules, especially cloud-related ones, require additional Python modules
    before they will work, and if you attempt to run the `aws_s3` module from a playbook
    without installing the `boto`, `boto3`, and `botocore` modules on Python 2.6 or
    later, you will simply receive an error.
  prefs: []
  type: TYPE_NORMAL
- en: All modules must have documentation like this created before they will be accepted
    as part of the Ansible project, so you must keep this in mind if you intend to
    submit your own modules. This is also one of the reasons for Ansible's popularity
    – with easy-to-maintain and well-documented standards, it is the perfect community
    platform for automation. The official Ansible website isn't the only place you
    can obtain documentation, however, as it is even available on the command line.
    We shall look at how to retrieve documentation via this route in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing module documentation from the command line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in the preceding section, the Ansible project prides itself on
    its documentation, and making this documentation readily accessible is an important
    part of the project itself. Now, suppose you are working on an Ansible task (in
    a playbook, role, or even an ad hoc command) and you are in a data center environment
    where you only have access to the shell of the machine you are working on. How
    would you get access to the Ansible documentation?
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, part of the Ansible installation that we have not discussed yet
    is the `ansible-doc` tool, which is installed as standard along with the familiar
    `ansible` and `ansible-playbook` executables. The `ansible-doc` command includes
    a complete (text-based) library of documentation for all the modules that ship
    with the version of Ansible you have installed. This means that the very information
    you need in order to work with modules is at your fingertips, even if you are
    in the middle of a data center and without a working internet connection!
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some examples to show you how to interact with the `ansible-doc`
    tool:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can list all of the modules that there''s documentation for on your Ansible
    control machine by simply issuing the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'There are many pages of output, which just shows you how many modules there
    are! In fact, you can count them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: That's right – 3,387 modules ship with Ansible 2.9.6!
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, you can search for specific modules using your favorite shell tools
    to process the index; for example, you could `grep` for `s3` to find all of the
    S3-related modules, as we did interactively in the web browser in the previous
    section:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can easily look up the specific documentation for the module that interests
    us. Say we want to learn more about the `aws_s3` module – just as we did on the
    website, simply run the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This should produce an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Although the formatting is somewhat different, `ansible-doc` tells us about
    the module, provides a list of all of the arguments (`OPTIONS`) that we can pass
    it, and as we scroll down, even gives some working examples and possible return
    values. We shall explore the topic of return values in the next section as they
    are important to understand, especially as we approach the topic of developing
    our own modules.
  prefs: []
  type: TYPE_NORMAL
- en: Module return values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed earlier in this chapter, Ansible modules return their results as
    structured data, formatted behind the scenes in JSON. You came across this return
    data in the previous example, both in the form of exit code and where we used
    the `register` keyword to capture the results of a task in an Ansible variable.
    In this section, we shall explore how to discover the return values for an Ansible
    module so that we can work with them later on in a playbook, for example, with
    conditional processing (see [Chapter 4](2f8c4f41-8a8d-4f23-9df2-6979159e5992.xhtml),
    *Playbooks and Roles*).
  prefs: []
  type: TYPE_NORMAL
- en: Due to conserving space, we shall choose what is perhaps one of the simplest
    Ansible modules to work with when it comes to return values – the `ping` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without further ado, let''s use the `ansible-doc` tool that we learned about
    in the previous section and see what this says about the return values for this
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you scroll to the bottom of the output from the preceding command, you should
    see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Hence, we can see that the `ping` module will only return one value, and that
    is called `ping`. `description` tells us what we should expect this particular
    return value to contain, while the `returned` field tells us that it will only
    be returned on `success` (if it would be returned on other conditions, these would
    be listed here). The `type` return value is a string (denoted by `str`), and although
    you can change the value with an argument provided to the `ping` module, the default
    return value (and hence `sample`) is `pong`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see what that looks like in practice. For example, there's nothing
    contained in those return values that would tell us whether the module ran successfully
    and whether anything was changed; however, we know that these are fundamental
    pieces of information about every module run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put a very simple playbook together. We''re going to run the `ping`
    module with no arguments, capture the return values using the `register` keyword,
    and then use the `debug` module to dump the return values onto the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see what happens when we run this playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `ping` module does indeed return a value called `ping`, which
    contains the `pong` string (as the ping was successful). However, you can see
    that there are, in fact, two additional return values that were not listed in
    the Ansible documentation. These accompany every single task run, and are hence
    implicit – that is to say, you can assume they will be among the data that's returned
    from every module. The `changed` return value will be set to `true` if the module
    run resulted in a change on the target host, while the `failed` return value will
    be set to `true` if the module run failed for some reason.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `debug` module to print the output from a module run is an incredibly
    useful trick if you want to gather more information about a module, how it works,
    and what sort of data is returned. At this point, we've covered just about all
    of the fundamentals of working with modules, so in the next section, we'll make
    a start on developing our very own (simple) module.
  prefs: []
  type: TYPE_NORMAL
- en: Developing custom modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we're familiar with modules, how to call them, how to interpret their
    results, and how to find documentation on them, we can make a start on writing
    our own simple module. Although this will not include the deep and intricate functionality
    of many of the modules that ship with Ansible, it is hoped that this will give
    you enough information to proceed with confidence when you build out your own,
    more complex, ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'One important point to note is that Ansible is written in Python, and as such,
    so are its modules. As a result, you will need to write your module in Python,
    and to get started with developing your own module, you will need to make sure
    you have Python and a few essential tools installed. If you are already running
    Ansible on your development machine, you probably have the required packages installed,
    but if you are starting from scratch, you will need to install Python, the Python
    package manager (`pip`), and perhaps some other development packages. The exact
    process will vary widely between operating systems, but here are some examples
    to get you started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On Fedora, you would run the following command to install the required packages:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, on CentOS, you would run the following command to install the required
    packages:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'On Ubuntu, you would run the following commands to install the packages you
    need:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are working on macOS and are using the Homebrew packaging system, the
    following command will install the packages you need:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have the required packages installed, you will need to clone the Ansible
    Git repository to your local machine as there are some valuable scripts in there
    that we will need later on in the module development process. Use the following
    command to clone the Ansible repository to your current directory on your development
    machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Finally (although optionally), it is good practice to develop your Ansible modules
    in a virtual environment (`venv`) as this means any Python packages you need to
    install go in here, rather than in with your global system Python modules. Installing
    modules for the entire system in an uncontrolled manner can, at times, cause compatibility
    issues or even break local tools, and so although this is not a required step,
    it is highly recommended.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exact command to create a virtual environment for your Python module development
    work will depend on both the operating system you are running and the version
    of Python you are using. You should refer to the documentation for your Linux
    distribution for more information; however, the following commands were tested
    on CentOS 7.7 with the default Python 2.7.5 to create a virtual environment called
    `moduledev` inside the Ansible source code directory you just cloned from GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With our development environment set up, let's start writing our first module.
    This module will be very simple as it's beyond the scope of this book to provide
    an in-depth discussion around how to write large amounts of Python code. However,
    we will code something that can use a function from a Python library to copy a
    file locally on the target machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, this overlaps heavily with existing module functionality, but it
    will serve as a nice concise example of how to write a simple Python program in
    a manner that allows Ansible to make use of it as a module. Now, let''s start
    coding our first module:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your preferred editor, create a new file called (for example) `remote_filecopy.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Start with a shebang to indicate that this module should be executed with Python:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Although not mandatory, it is good practice to add copyright information, as
    well as your details, in the headers of your new module. By doing this, anyone
    using it will understand the terms under which they can use, modify, or redistribute
    it. The text given here is merely an example; you should investigate the various
    appropriate licenses for yourself and determine which is the best for your module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also good practice to add an Ansible metadata section that includes `metadata_version`,
    `status`, and `supported_by` information immediately after the copyright section.
    Note that the `metadata_version` field represents the Ansible metadata version
    (which, at the time of writing, should be `1.1`) and is not related to the version
    of your module, nor the Ansible version you are using. The values suggested in
    the following code will be fine for just getting started, but if your module gets
    accepted into the official Ansible source code, they are likely to change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember `ansible-doc` and that excellent documentation that is available on
    the Ansible documentation website? That all gets automatically generated from
    special sections you add to this file. Let''s get started by adding the following
    code to our module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Pay particular attention to the `author` dictionary – to pass the syntax checks
    for inclusion in the official Ansible codebase, the author's name should be appended
    with their GitHub ID in brackets. If you don't do this, your module will still
    work, but it won't pass the test we'll perform later.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how the documentation is in YAML format, enclosed between triple single
    quotes? The fields listed should be common to just about all modules, but naturally,
    if your module takes different options, you would specify these so that they match
    your module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The examples that you will find in the documentation are also generated from
    this file – they have their own special documentation section immediately after
    `DOCUMENTATION` and should provide practical examples on how you might create
    a task using your module, as shown in the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The data that''s returned by your module to Ansible should also be documented
    in its own section. Our example module will return the following values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Immediately after we have finished our documentation section, we should import
    any Python modules we''re going to use. Here, we will include the `shutil` module,
    which will be used to perform our file copy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve built up the module headers and documentation, we can actually
    start working on the code. Now, you can see just how much effort goes into the
    documentation of every single Ansible module! Our module should start by defining
    a `main` function, in which we will create an object of the `AnsibleModule` type and
    use an `argument_spec` dictionary to obtain the options that the module was called
    with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'At this stage, we have everything we need to write our module''s functional
    code – even the options that it was called with. Hence, we can use the Python
    `shutil` module to perform the local file copy, based on the arguments provided:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we''ve executed the task our module was designed to complete.
    However, it is fair to say that we''re not done yet – we need to exit the module
    cleanly and provide our return values to Ansible. Normally, at this point, you
    would write some conditional logic to detect whether the module was successful
    and whether it actually performed a change on the target host or not. However,
    for simplicity, we''ll simply exit with the `changed` status every time – expanding
    this logic and making the return status more meaningful is left as an exercise
    for you:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `module.exit_json` method comes from `AnsibleModule`, which we created earlier
    – remember, we said it was important to know that data was passed back and forth
    using JSON!
  prefs: []
  type: TYPE_NORMAL
- en: 'As we approach the end of our module code, we must now tell Python where it
    can import the `AnsibleModule` object from. This can be done with the following
    line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for the final two lines of code for the module – this is where we tell
    the module that it should be running the `main` function when it starts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it – with a series of well-documented steps, you can write your own
    Ansible modules in Python. The next step is, of course, to test it, and before
    we actually test it in Ansible, let''s see whether we can run it manually in the
    shell. Of course, to make the module think it is being run within Ansible, we
    must generate some arguments in – you guessed it – JSON format. Create a file
    with the following contents to provide the arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Armed with this little snippet of JSON, you can execute your module directly
    with Python. If you haven''t already done so, you''ll need to set up your Ansible
    development environment as follows. Note that we also manually create the source
    file, `/tmp/foo`, so that our module can really perform the file copy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you''re finally ready to run your module for the first time. You can do
    this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Success! Your module works – and it both ingests and produces JSON data, as
    we discussed earlier in this chapter. Of course, there's much more to add to your
    module – we've not addressed `failed` or `ok` returns from the module, nor does
    it support check mode. However, we're off to a flying start, and if you want to
    learn more about Ansible modules and fleshing out your functionality, you can
    find more details here: [https://docs.ansible.com/ansible/latest/dev_guide/developing_modules_general.html](https://docs.ansible.com/ansible/latest/dev_guide/developing_modules_general.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that when it comes to testing your module, creating arguments in a JSON
    file is hardly intuitive, although, as we have seen, it does work well. Luckily
    for us, it is easy to run our Ansible module in a playbook! By default, Ansible
    will check the playbook directory for a subdirectory called `library/` and will
    run referenced modules from here. Hence, we might create the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a simple inventory file in this playbook directory, just as we
    did previously, and add a playbook with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'For the purposes of clarity, your final directory structure should look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, try running the playbook in the usual manner and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Success! Not only have you tested your Python code locally, but you have also
    successfully run it on two remote servers in an Ansible playbook. That was really
    easy, which just proves how straightforward it is to get started expanding your
    Ansible modules to meet your own bespoke needs.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the success of running this piece of code, we've not checked the documentation
    yet, nor tested its operation from Ansible. Before we address these issues in
    more detail, in the next section, we'll take a look at some of the common pitfalls
    of module development and how to avoid them.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding common pitfalls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is vital that your modules are well thought out and handle error conditions
    gracefully – people are going to rely on your module someday to automate a task
    on perhaps thousands of servers, and so the last thing they want is to spend significant
    amounts of time debugging errors, especially trivial ones that could have been
    trapped or handled gracefully. In this section, we'll look specifically at error
    handling and ways to do this so that playbooks will still run and exit gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: One piece of overall guidance before we get started is that just like documentation
    receives a high degree of attention in Ansible, so should your error messages.
    They should be meaningful and easy to interpret, and you should steer clear of
    meaningless strings such as `Error!`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, right now, if we remove the source file that we''re attempting to copy
    and then rerun our module with the same arguments, I think you''ll agree that
    the output is neither pretty nor meaningful, unless you happen to be a hardened
    Python developer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We can, without a doubt, do better. Let''s make a copy of our module and add
    a little code to it. First of all, replace the `shutil.copy` lines of code with
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This is some incredibly basic exception handling in Python, but what it does
    is allow the code to try the `shutil.copy` task. However, if this fails and an
    exception is raised, rather than exiting with a traceback, we exit cleanly using
    the `module.fail_json` call. This will tell Ansible that the module failed and
    cleanly sends a JSON-formatted error message back. Naturally, we could do a lot
    to improve the error message; for example, we could obtain the exact error message
    from the `shutil` module and pass it back to Ansible, but again, this is left
    as an exercise for you to complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when we try and run the module with a non-existent source file, we will
    see the following cleanly formatted JSON output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the module still works in the same manner as before if the copy succeeds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'With this simple change to our code, we can now cleanly and gracefully handle
    the failure of the file copy operation and report something more meaningful back
    to the user rather than using a traceback. Some additional pointers for exception
    handling and processing in your modules are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Fail quickly – don't attempt to keep processing after an error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return the most meaningful possible error messages using the various module
    JSON return functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Never return a traceback if there's any way you can avoid it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try making errors meaningful in the context of the module and what it does (for
    example, for our module, `File copy error` is more meaningful than `File error` – and
    I think you'll easily come up with even better error messages).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't bombard the user with errors; instead, try to focus on reporting the most
    meaningful ones, especially when your module code is complex.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That completes our brief yet practical look at error handling in Ansible modules.
    In the next section, we shall return to the documentation we included in our module,
    including how to build it into HTML documentation so that it can go on the Ansible
    website (and indeed, if your module gets accepted into the Ansible source code,
    this is exactly how the web documentation will be generated).
  prefs: []
  type: TYPE_NORMAL
- en: Testing and documenting your module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already put a great deal of work into documenting our module, as we
    discussed earlier in this chapter. However, how can we see it, and how can we
    check that it compiles correctly into the HTML that would go on the Ansible website
    if it were accepted as part of the Ansible source code?
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get into actually viewing our documentation, we should make use of
    a tool called `ansible-test`, which was newly added in the 2.9 release. This tool
    can perform a sanity check on our module code to ensure that our documentation
    meets all the standards required by the Ansible project team and that the code
    is structured correctly (for example, the Python `import` statements should always
    come after the documentation blocks). Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the sanity tests, assuming you have cloned the official repository,
    change into this directory and set up your environment. Note that if your standard
    Python binary isn''t Python 3, the `ansible-test` tool will not run, so you should
    ensure Python 3 is installed and, if necessary, set up a virtual environment to
    ensure you are using Python 3\. This can be done as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, use `pip` to install the Python requirements so that you can run the
    `ansible-test` tool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, provided you have copied your module code into the appropriate location
    in the source tree (an example copy command is shown here), you can run the sanity
    tests as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding output, you can see that apart from one warning related to
    us not having a base branch to compare against, the module code that we developed
    earlier in this chapter has passed all the tests. If you had an issue with the
    documentation (for example, the author name format was incorrect), this would
    be given as an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have passed the sanity checks with `ansible-test`, let''s see whether
    the documentation looks right by using the `ansible-doc` command. This is very
    easy to do. First of all, exit your virtual environment, if you are still in it,
    and change to the Ansible source code directory you cloned from GitHub earlier.
    Now, you can manually tell `ansible-doc` where to look for modules instead of
    the default path. This means that you could run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'You should be presented with the textual rendering of the documentation we
    created earlier – an example of the first page is shown here to give you an idea
    of how it should look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent! So, we can already access our module documentation using `ansible-doc` and
    indeed confirm that it renders correctly in text mode. However, how do we go about
    building the HTML version? Fortunately, there is a well-defined process for this,
    which we shall outline here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Under `lib/ansible/modules/`, you will find a series of categorized directories
    that modules are placed under – ours fits best under the `files` category, so
    copy it to this location in preparation for the build process to come:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Change to the `docs/docsite/` directory as the next step in the documentation
    creation process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Build a documentation-based Python file. Use the following command to do so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Now, in theory, making the Ansible documentation should be this simple; however,
    unfortunately, at the time of writing, the source code for Ansible v2.9.6 refuses
    to build `webdocs`. This will no doubt be fixed in due course as, at the time
    of writing, the documentation build scripts are being ported to Python 3\. To
    get the `make webdocs` command to run at all, I had to clone the source code for
    Ansible v2.8.10 as a starting point.
  prefs: []
  type: TYPE_NORMAL
- en: Even in this environment, on CentOS 7, the `make webdocs` command fails unless
    you have some very specific Python 3 requirements in place. These are not well-documented,
    but from testing, I can tell you that Sphinx v2.4.4 works. The version supplied
    with CentOS 7 is too old and fails, while the newest version available from the
    Python module repositories (v3.0.1, at the time of writing) is not compatible
    with the build process and fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once I''d started working from the Ansible v2.8.10 source tree, I had to make
    sure I had removed any preexisting `sphinx` modules from my Python 3 environment
    (you need Python 3.5 or above to build the documentation locally – if you don''t
    have this installed on your node, please do this before proceeding) and then ran
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, you will be able to successfully run `make webdocs` to
    build your documentation. You will see pages of output. A successful run should
    end with something like the output shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, notice how, at the end of this process, the `make` command tells us where
    to look for the compiled documentation. If you look in here, you will find the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Try opening up the HTML file in your web browser – you should see that the page
    renders just like one of the documentation pages from the official Ansible project
    documentation! This enables you to check that your documentation builds correctly
    and looks and reads well in the context that it will be viewed in. It also gives
    you confidence that, when you submit your code to the Ansible project (if you
    are doing so), you are submitting something consistent with Ansible's documentation
    quality standards.
  prefs: []
  type: TYPE_NORMAL
- en: More information on building the documentation locally is provided here: [https://docs.ansible.com/ansible/latest/community/documentation_contributions.html#building-the-documentation-locally](https://docs.ansible.com/ansible/latest/community/documentation_contributions.html#building-the-documentation-locally).
    Although this is an excellent document, it does not currently reflect the compatibility
    issues around Sphinx, nor the build issues regarding Ansible 2.9\. Hopefully,
    however, it will give you all of the other pointers you need to get going with
    your documentation.
  prefs: []
  type: TYPE_NORMAL
- en: The current process of building the documentation is currently a little fussy
    around the environments that are supported; however, hopefully, this is something
    that will be resolved in due course. In the meantime, the process outlined in
    this section has given you a tested and working process to start from.
  prefs: []
  type: TYPE_NORMAL
- en: The module checklist
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to the pointers and good practices that we have covered so far,
    there are a few more things you should adhere to in your module code to produce
    something that will be considered of a high standard for potential inclusion with
    Ansible. The following list is not exhaustive but will give you a good idea of
    the practices you should adhere to as a module developer:'
  prefs: []
  type: TYPE_NORMAL
- en: Test your modules as much as you can, both in cases that will succeed and in
    those that cause errors. You can test them using JSON data, as we did in this
    chapter, or make use of them within a test playbook.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try and keep your Python requirements to a minimum. Sometimes, there is no way
    to avoid the need for additional Python dependencies (such as the `boto` requirements
    of the AWS-specific modules), but in general, the less you can use, the better.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't cache data for your module – the execution strategies of Ansible across
    differing hosts mean you are unlikely to get good results from doing this. Expect
    to gather all of the data you need on each run.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules should be a single Python file – they shouldn't be distributed across
    multiple files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Make sure you investigate and run the Ansible integration tests when you are
    submitting your module code. More information on these is available here: [https://docs.ansible.com/ansible/latest/dev_guide/testing_integration.html](https://docs.ansible.com/ansible/latest/dev_guide/testing_integration.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure you include exception handling at the appropriate points in your module
    code, as we did in this chapter, to prevent issues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not use `PSCustomObjects` in Windows modules unless you absolutely cannot
    avoid it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Armed with the information you've gained from this chapter, you should have
    everything you need to start creating your own modules. You may not decide to
    submit them to the Ansible project, and there is certainly no requirement to do
    so. However, even if you don't, following the practices outlined in this chapter
    will ensure that you build a good quality module, regardless of its intended audience.
    Finally, on the basis that you do want to submit your source code to the Ansible
    project, in the next section, we'll look at how to do this through a pull request
    to the Ansible project.
  prefs: []
  type: TYPE_NORMAL
- en: Contributing upstream – submitting a GitHub pull request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you've worked hard on your module and thoroughly tested and documented
    it, you might feel that it is time to submit it to the Ansible project for inclusion.
    Doing this means creating a pull request on the official Ansible repository. Although
    the intricacies of working with GitHub are beyond the scope of this book, we will
    give you a practically focused outline of the basic procedures involved.
  prefs: []
  type: TYPE_NORMAL
- en: Following the process outlined here will generate a real request against the
    Ansible project on GitHub so that the code you are committing can be merged with
    their code. *Do not* follow this process unless you genuinely have a new module
    that is ready for submission to the Ansible codebase.
  prefs: []
  type: TYPE_NORMAL
- en: 'To submit your module as a pull request of the Ansible repository, you need
    to fork the `devel` branch of the official Ansible repository. To do this, log
    into your GitHub account from your web browser (or create an account if you don''t
    already have one), and then navigate to the URL shown in the following screenshot.
    Click Fork in the top-right corner. As a reminder, the official Ansible source
    code repository URL is [https://github.com/ansible/ansible.git](https://github.com/ansible/ansible.git):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/0779e17d-e64b-4699-8632-6bede2ca8db0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that you have forked the repository to your own account, we will walk through
    the commands you need to run in order to add your module code to it. Then, we''ll
    show you how to create the required **pull requests** (also known as **PRs**)
    so that you can merge your new module with the upstream Ansible project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone the `devel` branch that you''ve just forked to your local machine. Use
    a command similar to the following, but be sure to replace the URL with the one
    that matches your own GitHub account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy your module code into the appropriate modules directory – the `copy` command
    given in the following code is just an example to give you a clue as to what to
    do, but in reality, you should choose the appropriate category subdirectory for
    your module as it won''t necessarily fit into the `files` category. Once you''ve
    added your Python file, perform `git add` to make Git aware of the new file, and
    then commit it with a meaningful commit message. Some example commands are as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, be sure to push the code to your forked repository using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Return to GitHub in your web browser and navigate to the Pull Requests page,
    as shown here. Click the New pull request button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/2b2235ef-6a3a-4f76-9d4b-f035cb98cbdb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Follow the pull request creation process through, as guided by the GitHub website.
    Once you have successfully submitted your pull request, you should be able to
    navigate to the list of pull requests on the official Ansible source code repository
    and find yours there. An example of the pull requests list is shown here for your
    reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/6148a8a0-6da2-4a93-882c-2b86faa880ce.png)'
  prefs: []
  type: TYPE_IMG
- en: When this screenshot was taken, there were almost 31,000 closed pull requests
    and nearly 1,700 open for review! By the time you read this book, there will surely
    be many more, demonstrating how much Ansible relies on the open source community
    for its continued development and growth. Just think – you could be part of this!
    Don't be alarmed if it takes a long time for your pull request to get reviewed
    – this is simply a facet of how many pull requests there are to review and process.
    You can always use your module code locally by adding it to a local `library/`
    directory, as we demonstrated earlier, so that the speed of your pull request
    being processed doesn't hinder your work with Ansible. Further details of where
    to place your plugin code when working locally can be found here: [https://docs.ansible.com/ansible/latest/dev_guide/developing_locally.html](https://docs.ansible.com/ansible/latest/dev_guide/developing_locally.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many more ways to contribute to the Ansible project other than creating
    pull requests for custom modules. Here are some examples of other ways you can
    contribute to the project:'
  prefs: []
  type: TYPE_NORMAL
- en: Review the Ansible documentation and report any bugs you find in it (one was
    filed in the creation of [Chapter 4](2f8c4f41-8a8d-4f23-9df2-6979159e5992.xhtml),
    *Playbooks and Roles*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a local Ansible MeetUp to spread your knowledge about Ansible. If you
    are lucky enough to have one in your area already, consider attending it on a
    regular basis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spread Ansible knowledge and awareness via social media with the appropriate
    account references and hashtags; for example, `@ansible`, `#ansible`, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That completes our journey of learning how to create modules, from the very
    first steps of looking into the theory of module operation, all of the way through
    to contributing your new module code to the official Ansible project on GitHub.
    We hope you have found this journey informative and valuable and that it enhances
    your ability to work with Ansible and extend its functionality where required.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modules are the very lifeblood of Ansible – without them, Ansible could not
    perform all of the complex and varied tasks it performs so well across a wide
    variety of systems. By virtue of being an open source project, it is incredibly
    easy to extend the functionality of Ansible by yourself, and in this chapter,
    we explored how you can, with a little Python knowledge, write your own custom
    module from scratch. Ansible is, at the time of writing, incredibly feature-rich,
    but this ease of customization and extension makes Ansible virtually limitless
    in terms of its potential, especially given the power and popularity of Python
    as a programming language.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we started with a recap of how to execute multiple modules
    using the command line. We then explored the process of interrogating the current
    module index, as well as how to obtain documentation about modules to evaluate
    their suitability for our needs, regardless of whether we have an active internet
    connection or not. We then explored module data and its JSON format, before finally
    going on a journey through which we put together the code for a simple custom
    module. This provided you with a basis for creating your own modules in the future,
    if you so desire.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the process of using and creating another
    core Ansible feature, known as plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering the plugin types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible's code has always been designed to be modular—indeed, this is one of
    its core strengths. Whether that is through the use of modules to perform tasks
    or through plugins (as we will see shortly), Ansible's modular design allows it
    to be as versatile and powerful as it has demonstrated itself to be so far in
    this book. As with modules, Ansible plugins are all written in Python and are
    expected to ingest and return data in a certain well-defined format (more on this
    later). Ansible's plugins are often invisible in their function in that you rarely
    call them by name in your commands or playbooks, yet they are responsible for
    some of the most important features Ansible has to offer, including SSH connectivity,
    the ability to parse inventory files (in INI format, YAML, or otherwise), and
    the ability to run `jinja2` filters on your data.
  prefs: []
  type: TYPE_NORMAL
- en: 'As ever, let''s validate the presence of a suitably installed version of Ansible
    on your test machine before proceeding further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: As much work goes into documenting the plugins as it does in documenting the
    modules, and you will be pleased to know that there is a plugin index available
    at [https://docs.ansible.com/ansible/latest/plugins/plugins.html](https://docs.ansible.com/ansible/latest/plugins/plugins.html).
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the `ansible-doc` command as we did before, only you need to
    add the `-t` switch to it, too. Plugins are always placed in an appropriate category
    as their function is radically different between categories. If you don't specify
    the `-t` switch with `ansible-doc`, you end up specifying the `ansible-doc -t`
    module, which returns a list of the available modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, the following plugin categories can be found in Ansible:'
  prefs: []
  type: TYPE_NORMAL
- en: '`become`: Responsible for enabling Ansible to obtain super-user access (for
    example, through `sudo`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cache`: Responsible for caching facts retrieved from backend systems to improve
    automation performance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`callback`: Allows you to add new behaviors when responding to events—for example,
    changing the format that data is printed in the output in of an Ansible playbook
    run'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cliconf`: Provides abstractions to the command-line interfaces of various
    network devices, giving Ansible a standard interface to operate on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`connection`: Provides connectivity from Ansible to remote systems (for example,
    over SSH, WinRM, Docker, and many more)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`httpapi`: Tells Ansible how to interact with a remote system''s API (for example,
    for a Fortinet firewall)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inventory`: Provides Ansible with the ability to parse various static and
    dynamic inventory formats'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lookup`: Allows Ansible to look up data from an external source (for example,
    by reading a flat text file)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`netconf`: Provides Ansible with abstractions to enable it to work with NETCONF-enabled
    networking devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shell`: Provides Ansible with the ability to work with various shells on different
    systems (for example, `powershell` on Windows versus `sh` on Linux)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`strategy`: Provides plugins to Ansible with different execution strategies
    (for example, the debug strategy we saw in [Chapter 4](2f8c4f41-8a8d-4f23-9df2-6979159e5992.xhtml),
    *Playbooks and Roles*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vars`: Provides Ansible with the ability to source variables from certain
    sources, such as the `host_vars` and `group_vars` directories we explored in [Chapter
    3](1bbd0c5e-1eb1-4521-b84d-16cc07083f64.xhtml), *Defining Your Inventory*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will leave exploring the plugin documentation on the Ansible website as
    an exercise for you to complete. However, if you want to explore the various plugins
    using the `ansible-doc` tool, you would need to run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `ansible-doc` command to list all the plugins available in a given
    category, you can run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return a textual index of the connection plugins, similar to what
    we saw when we were looking at the module documentation. The first few lines of
    the index output are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then explore the documentation for a given plugin. For example, if
    we want to learn about the `paramiko_ssh` plugin, we can issue the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'You will find that the plugin documentation takes on a very familiar format,
    similar to what we saw for the modules in [Chapter 5](6f89dca6-e6ba-4229-a7fd-dc4ef5ca39f5.xhtml),
    *Consuming and Creating Modules*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to all the hard work and effort that goes into documenting every area
    of Ansible, you can easily find out about the plugins that are included with Ansible
    and how to work with them. So far, we have seen that the documentation for plugins
    is no less complete than it is for modules. In the next section of this chapter,
    we'll dive a bit deeper into how to find the plugin code that accompanies your
    Ansible distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which command line can be passed down as a parameter to a module?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) `ansible dbservers -m command "/bin/echo 'hello modules'"`
  prefs: []
  type: TYPE_NORMAL
- en: B) `ansible dbservers -m command -d "/bin/echo 'hello modules'"`
  prefs: []
  type: TYPE_NORMAL
- en: C) `ansible dbservers -z command -a "/bin/echo 'hello modules'"`
  prefs: []
  type: TYPE_NORMAL
- en: D) `ansible dbservers -m command -a "/bin/echo 'hello modules'"`
  prefs: []
  type: TYPE_NORMAL
- en: E) `ansible dbservers -a "/bin/echo 'hello modules'"`
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following practices is not recommended when you create a custom
    module and address exceptions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) Design a custom module simply and never provide a traceback to the user,
    if you can avoid it.
  prefs: []
  type: TYPE_NORMAL
- en: B) Fail your module code quickly, and verify that you are providing helpful
    and understandable exception messages.
  prefs: []
  type: TYPE_NORMAL
- en: C) Only display error messages for the most relevant exceptions, rather than
    all possible errors.
  prefs: []
  type: TYPE_NORMAL
- en: D) Ensure that your module documentation is relevant and easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: E) Delete playbooks that result in errors and then recreate them from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: 'True or False: To contribute to the Ansible upstream project, you need to submit
    your code to the `devel` branch.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) True
  prefs: []
  type: TYPE_NORMAL
- en: B) False
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Documentation regarding the common return values of modules in Ansible can be
    found here: [https://docs.ansible.com/ansible/latest/reference_appendices/common_return_values.html#common](https://docs.ansible.com/ansible/latest/reference_appendices/common_return_values.html#common).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check out the following documentation for all the existing modules on Windows
    machines that you can use: [https://docs.ansible.com/ansible/latest/modules/list_of_windows_modules.html#windows-modules](https://docs.ansible.com/ansible/latest/modules/list_of_windows_modules.html#windows-modules).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some of the major module indexes, along with their categorization, can be found
    at the following links:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cloud modules**: [https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html](https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clustering modules**: [https://docs.ansible.com/ansible/latest/modules/list_of_clustering_modules.html](https://docs.ansible.com/ansible/latest/modules/list_of_clustering_modules.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Commands modules**: [https://docs.ansible.com/ansible/latest/modules/list_of_commands_modules.html](https://docs.ansible.com/ansible/latest/modules/list_of_commands_modules.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Crypto modules**: [https://docs.ansible.com/ansible/latest/modules/list_of_crypto_modules.html](https://docs.ansible.com/ansible/latest/modules/list_of_crypto_modules.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database modules**: [https://docs.ansible.com/ansible/latest/modules/list_of_database_modules.html](https://docs.ansible.com/ansible/latest/modules/list_of_database_modules.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identity modules**: [https://docs.ansible.com/ansible/latest/modules/list_of_identity_modules.html](https://docs.ansible.com/ansible/latest/modules/list_of_identity_modules.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**All modules**: [https://docs.ansible.com/ansible/latest/modules/list_of_all_modules.html](https://docs.ansible.com/ansible/latest/modules/list_of_all_modules.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
