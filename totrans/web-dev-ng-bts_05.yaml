- en: Flex-Layout - Angular's Responsive Layout Engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flex-Layout is a TypeScript-based layout engine for Angular. It is an alternative
    to using Bootstrap's grid for laying out your components in your Angular projects.
    Flex-Layout evolved from AngularJS Material, a UI Component Framework, which was
    created by a team at Google led by Thomas Burleson—a well-known speaker at Angular
    conferences. I've not yet had the chance to attend an Angular conference, such
    as ng-conf or AngularMix, but I will. Maybe I'll see you there! There are many
    conferences on Angular spanning the globe—so you know that you're spending your
    time wisely studying a technology that is in high demand and is here to stay.
    I don't think I've said this to you yet, so I will now. Congratulations! Congratulations
    on selecting such a great technology to use in your projects, or maybe even as
    the cornerstone technology on which to build your career.
  prefs: []
  type: TYPE_NORMAL
- en: I can't help but get excited when I discover technologies that transform the
    way I create software for my clients and for myself, and now I get to share my
    excitement with you! So, pardon the slight tangent from the material at hand.
  prefs: []
  type: TYPE_NORMAL
- en: OK, let's now take a look at what we'll be covering in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Why this chapter was included in the book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The four available techniques for the layout of our components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why FlexBox CSS is probably the best option
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Flex-Layout and why should you consider using it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating Flex-Layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Flex-Layout API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design strategies when using Flex-Layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Associating our wireframes and components with the chapters and topics in this
    book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing our selected wireframes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why this chapter was included in the book
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a very short chapter. In fact, it's probably the shortest in the book.
    However, I wanted to include it to give you options, particularly in terms of
    having an alternative technology to Bootstrap. Within reason, the more options
    you have, the better off you are. Additionally, some developers enjoy using Bootstrap,
    while others don't. I suspect that the reason for this is that Bootstrap's layout
    system is a grid. I don't know many developers who like being sandboxed into something
    like that. Don't get me wrong, I'm not knocking Bootstrap (Bootstrap is a great
    technology, and the name is even in the title of this book!), but Flex-Layout
    definitely feels like it is less rigid. Another reason that some developers would
    prefer working with something like Flex-Layout is that it feels more developer-friendly.
    For instance, instead of using `DIV` elements with special attributes, you use
    dedicated elements. This is sometimes referred to as taking a declarative approach, which
    sometimes simply feels more natural to developers. This may or may not make sense
    to you at the moment, but it will by the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The four available techniques for the layout of our components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As web developers, and unless you're privileged to have a web designer on your
    team, we necessarily find ourselves needing to spend time with the layout of the
    components on our pages.
  prefs: []
  type: TYPE_NORMAL
- en: As a quick aside, let's put some terminology in place for our discussions moving
    forward. I've used the terms *component* and *pages* interchangeably in the first
    few chapters, but it is now time to get more precise. As you know, Angular applications
    are SPAs by default and thus only have one page. I've mentioned a few times in
    the book that an Angular application is like a tree of components, and it all
    starts with the root component. Components are composable, which is to say that
    a component can be made of other components. What's the result of this? Well,
    we need a web page in order to have our root component rendered—and from that
    moment forth, our root component brings in other components, which, in turn, bring
    in yet other components. The end result is that our components recursively render
    themselves to give the illusion that we have multiple pages. Of course, we don't
    have multiple pages. We have a single web page, and the way in which we're architecting
    our application is that we have a main encompassing component for each *page* in
    our application. All that means is that when you see me mention *page*, instead
    of *component*, I'm really referring to the main component on that *page*.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look back at the code we wrote for [Chapter 4](66c21daa-b131-470d-a21b-0fbed56c3ec9.xhtml),
    *Routing*, and it should all start to be making sense to you. Specifically, a
    given URL maps to a component. With more traditional web applications that are
    not SPAs, the URLs are mapped to views, or "pages". OK, let's return our focus
    to considerations and available options as to layout strategies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Laying out the components in our application includes the following four necessities:'
  prefs: []
  type: TYPE_NORMAL
- en: Laying out our components within their containers (that is, parent component
    and child component(s))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sizing our components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Positioning our components relative to each other
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styling the components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I don''t profess to be an expert in styling or CSS. I can barely color coordinate
    the clothes I wear. While we have seen some CSS in [Chapter 3](6694dd13-5500-4563-9688-74a21a06a9a9.xhtml),
    *Bootstrap – Grid Layout and Components*, in our SASS crash course (and we''ll
    certainly see more CSS in the chapters ahead), this is not a book about design
    and styling. Packt Publishing offers a few excellent books on CSS. In this chapter,
    we''ll only concern ourselves with laying out our components within their containers.
    To that end, we have four techniques that we can choose from: tables, float and
    clear, FlexBox CSS, and CSS Grid.'
  prefs: []
  type: TYPE_NORMAL
- en: Yes, of course, Flex-Layout is also an option for us because we've chosen Angular
    (big smile). However, the four layout techniques I've listed apply to web development
    in general—regardless of a frontend framework, library, or just plain old HTML
    and CSS. As we have seen in [Chapter 3](6694dd13-5500-4563-9688-74a21a06a9a9.xhtml),
    *Bootstrap – Grid Layout and Components*, Bootstrap is a CSS framework built on
    top of FlexBox CSS, and so also applies to web development in general.
  prefs: []
  type: TYPE_NORMAL
- en: Getting back to our discussion of layout techniques, let's contrast the four
    that are generally available to web developers, and see whether there is a clear
    winner. From there, we'll move on to the nitty-gritty of this chapter and take
    a look at what Flex-Layout is and why we should use it.
  prefs: []
  type: TYPE_NORMAL
- en: Table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every web developer (born before the year 2000) has heard of and has likely
    used the `TABLE` tag. Where did this come from? Well, a long time ago, in a galaxy
    far, far away, a team of alien programmers invented HTML table tags. These aliens
    soon grew weary of using this layout technique, so they banned its use and banished
    all the web development books that taught table tags their planet. Meanwhile,
    somewhere on Earth, circa 1994, a web developer who was frustrated with layout
    issues was hit on the head with what seemed like a technical book. Its markings
    appeared to be some form of hieroglyphics—all indecipherable to the young techie,
    except the distinctly familiar markup language. The first chapter's heading was
    simply, `<TABLE>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kidding aside, while tables were tremendously helpful in the early days of
    web development, they are now an ancient layout technique that is often frowned
    upon. Here are some reasons why tables are no longer the default method for laying
    out page elements:'
  prefs: []
  type: TYPE_NORMAL
- en: They tend to clutter up the markup in our web pages and components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are a maintenance nightmare, since moving things around is extremely tedious
    using tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are rigid—more so than a grid, to the extent that we sometimes had to resort
    to having nested tables, which, of course, exacerbate the first two bullet points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, despite these negatives, using tables is still a valid option and is
    why I've listed it here as one of the main four.
  prefs: []
  type: TYPE_NORMAL
- en: Positioning using float, and clear
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CSS has some pretty cool features. Among my favorites were a couple of its declarations
    that deal with positioning. Specifically, the two CSS declarations I'm referring
    to are float and clear. These declarations can be applied to block elements, such
    as `<div>`, as well as inline elements, such as `<img>`. Block-level elements
    are elements that occupy 100% of the parent element's space, whereas inline elements
    are happy to share the horizontal space they reside within their parent element.
  prefs: []
  type: TYPE_NORMAL
- en: The notion of *floating* an element (such as a `<div>`) is that it relinquishes
    its demand to take up the entire horizontal line. In short, it collapses its space
    to only consume what it needs—instead of being greedy with the horizontal real
    estate available—and other elements can now reside beside it, instead of being
    pushed below it. This is true for when the element being floated does not take
    up the entire space. Elements that are floated beside it, when there is not enough
    room horizontally, will wrap down to the next line. With that being said, you
    can start to see how you can achieve some degree of responsive design by using
    the CSS float declaration to float elements.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of *clearing* is to control how the float takes effect. When you
    use the CSS declaration of clear on an element, you are basically instructing
    that element to not float up to the higher horizontal space—even if there is space
    to float up in. Remember, floating elements means that the element will take the
    highest vertical space it can take, provided that there is room, and that its
    adjoining elements have also been floated (especially for block-level elements
    that want to consume the entire horizontal space on their own). When there isn't
    sufficient space, it'll wrap down to the next highest available spot, and if there
    is enough space, it'll float up to be beside the other element. The exception
    to this is if you apply the clear declaration to it in its style or class, in
    which it will always behave as it wraps down—even when there's room higher up.
    Are we good on this? Cool.
  prefs: []
  type: TYPE_NORMAL
- en: Positioning elements via *float* and *clear* definitely works, and you can create
    some fairly sophisticated layouts by using them. But their effects may not always
    be what you want to see happen, as the viewport size gets smaller. In the world
    of responsive layout, having as much control as possible over your layout is paramount,
    and being limited to just floating and clearing can often make it a bit of a challenge
    to have your layout rearrange itself, given a wide array of viewport sizes—at
    least with as much precision as the next two options give you. Another thing that
    you need to get used to with floating elements is that you need to reorder the
    listing of elements on your page, depending on whether you're floating the elements
    to the left or to the right.
  prefs: []
  type: TYPE_NORMAL
- en: The reason I took a little more time here on *float* and *clear* is that it's
    an area where too many developers don't take the time to let it sink in. The takeaway
    point here is that you can get very far with just this layout technique, and,
    depending on the nature of the project and its requirements, it may be what the
    doctor ordered. Of course, there's more to say about *float* and *clear* in terms
    of design strategies, but that is a whole other book. As always, I recommend playing
    around with this layout technique/strategy.
  prefs: []
  type: TYPE_NORMAL
- en: FlexBox CSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: FlexBox CSS is a layout technique that came into being with CSS3\. It's a very
    powerful thing, and this is why other frameworks, such as Bootstrap and Flex-Layout,
    are built on top of it. But the best thing about FlexBox CSS is that it's understood
    by nearly all of the browsers in general use today. With FlexBox we get the best
    of both worlds — tremendous browser outreach and admirable layout flexibility
    for your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'I won''t say much more than this for FlexBox CSS because chances are that you
    will not use it—at least not directly. There are three reasons why I can probably
    safely make that assumption:'
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap is built on top of FlexBox CSS, and you're probably more likely to
    use the Bootstrap grid as opposed to using FlexBox CSS directly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same thing holds true with Flex-Layout, since it basically wraps FlexBox
    CSS in a nice API, making it easier to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSS Grid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CSS Grid FlexBox CSS is a layout technique that comes into being with CSS4\.
    It's also a very powerful thing, and it makes some things easier to do than with
    FlexBox CSS, but, at the same time, some things are harder to implement than doing
    it with FlexBox CSS. Being a relatively new addition to the world of CSS, it is
    not as widely integrated into browsers that are generally in use.
  prefs: []
  type: TYPE_NORMAL
- en: Why FlexBox CSS is probably the best option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After reading the few preceding paragraphs in the previous section, who the
    winner is should come as no surprise to you. It''s definitely FlexBox CSS. Let''s
    summarize this with a list of factors that should be considered when selecting
    a layout option:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Browser reach:** As developers, we care deeply about the reach of our web
    applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ease of use**: This one is a bit of a stretch, I know—both Bootstrap''s grid
    and Flex-Layout are built on top of it, making it easier to use. But once you
    get your head around FlexBox CSS, most layout requirements can be handled fairly
    easily.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ease of maintenance**: This one follows from the previous bullet point. But
    something that most developers are surprised by is the fact that, during the lifespan
    of a typical application, 20% of the time that developers are involved with it
    is in building it, whereas 80% of developer time with the application is in maintaining
    it—and so this last bullet point cannot be overemphasized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Again, we're not considering Bootstrap and Flex-Layout to be layout techniques
    because they are tools/frameworks superimposed on top of the underlying layout
    techniques.
  prefs: []
  type: TYPE_NORMAL
- en: What is Flex-Layout and why should you use it?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered why the best option for us from the four for laying out our components
    is FlexBox CSS, but this is a chapter on Flex-Layout, and so I now need to introduce
    it to you. So let's do that now, and then I'll list a few reasons why you should
    consider using it instead of using FlexBox CSS directly (again since Flex-Layout
    is built on top of FlexBox CSS).
  prefs: []
  type: TYPE_NORMAL
- en: 'Flex-Layout''s home can be found here: [https://www.github.com/angular/flex-layout](https://www.github.com/angular/flex-layout).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few bullet points detailing what Flex-Layout is:'
  prefs: []
  type: TYPE_NORMAL
- en: It's a standalone library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's Angular-native (and is a TypeScript implementation).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's integrated with the CLI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It has static APIs, which are for the containers, and other static APIs, which
    are for the container children. These APIs have the following characteristics:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are declarative
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They support data binding and change detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are directives used in HTML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's no CSS for us to write since it's dynamically injected for us
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some advantages of using it instead of FlexBox CSS, and following from the
    preceding bullet points, are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: You don't have to be a CSS expert (in fact, as you'll soon see, we won't even
    be using a CSS style sheet)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It fits Angular perfectly (in fact, it's Angular-native)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are APIs which helps developers in faster application development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another nice thing to know is that since Flex-Layout is a standalone (that is,
    self-contained) library, it can be used with or without Angular Material. We'll
    be taking a look at Angular Material in [Chapter 9](1a222c0e-7130-4ac2-959d-ae9d6cc1ca7d.xhtml),
    *Working with Angular Material*, where we'll be utilizing a couple of its components.
    Again, these components can be used as replacements for, or in conjunction with,
    ng-Bootstrap. We'll be taking a look at ng-Bootstrap in [Chapter 8](784689d5-c12c-4a1d-b2a4-dfcdbe7e6d38.xhtml), *Working
    with NG Bootstrap.*
  prefs: []
  type: TYPE_NORMAL
- en: I've mentioned in the preceding bullet list that Flex-Layout has static APIs.
    What I have not mentioned is that it also has responsive APIs. We'll be covering
    Flex-Layout's static APIs in an upcoming section, The *Flex-Layout API*, but I
    leave the reading of its responsive API to you (I have included links to the Flex-Layout
    documentation at the end of that section).
  prefs: []
  type: TYPE_NORMAL
- en: However, I would like to say a quick word on responsive APIs. Responsive APIs
    are there so that you can create an adaptive UX (that is, an adaptive user experience
    to have a slightly different layout for various viewport sizes). In order to do
    that, you need to also leverage MediaQueries—not only FlexBox CSS. Now, yes, this
    is a chapter on Flex-Layout, so why am I mentioning that you need to leverage
    MediaQueries in conjunction with FlexBox CSS? I mention this to point out the
    fact that the Flex-Layout team has us covered in this space (that is, responsive
    UX, not just layout) as well. And they have done this by providing extensions
    to the static APIs to abstract the MediaQueries away from us. This means that
    we don't have to handcraft tedious rule sets—and since they created extensions
    on the static APIs, we can leverage what we learn there and apply the extensions
    to create the adaptive UX right in our HTML. It's really quite brilliant!
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Flex-Layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Flex-Layout library comes as one self-contained module, and so we only need
    to import it in one place. It is more straightforward to integrate than routing
    was in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add Flex-Layout to our project. The first thing we need to do is
    to install the library. In your Terminal, navigate to the root folder of the `realtycarousel`
    application that we started creating in [Chapter 4](66c21daa-b131-470d-a21b-0fbed56c3ec9.xhtml),
    *Routing*, and type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will install the library, so we can later import it into any of our Angular
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: If your CLI outputs a warning, such as something along the lines of `"``@angular/flex-layout@5.0.0-beta.14`
    requires a peer of `@angular/cdk@^5.0.0` but none is installed. You must install
    peer dependencies yourself" (which is what happened to me), just install it the
    same way as anything else, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to import it into our `RealtyCarousel` application. To do this,
    we need to add a couple of things to our application''s main module. Open your
    `RealtyCarousel` project in your IDE, and then open the `app.module.ts` file from
    within the `src/app` directory. At the top of the file within our other import
    statements, add the following import statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: (Just underneath the `import` statement , that we added for the `RouterModule`
    will be just fine.)
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to include the `FlexLayoutModule` in the imports array within
    the `@NgModule` section, like this: (just underneath the statement `RouterModule.forRoot(appRoutes)`, we
    had added for the `RouterModule` would be just fine.)'
  prefs: []
  type: TYPE_NORMAL
- en: With that, we're done. We now have the power of Flex-Layout at our disposal.
    Virtually anything else we'll do with Flex-Layout gets done in our HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the Flex-Layout API next—which is how we'll be leveraging
    Flex-Layout in our pages (that is, component templates).
  prefs: []
  type: TYPE_NORMAL
- en: The Flex-Layout API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What makes Flex-Layout easier to work with than FlexBox CSS is the fact that
    it has APIs that abstract the CSS away for us. We still need CSS (remember, browsers
    only understand HTML, JavaScript, and CSS), but what I mean by the face that CSS
    will be abstracted away for us is that when our application is transpiled, Angular
    Flex-Layout will inject the CSS for us. As I've mentioned, Flex-Layout doesn't
    even have a CSS style sheet, and we don't have to write any CSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a table of the Flex-Layout APIs, detailing what they are used
    for, together with a quick syntactical example:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **API** | **Used for** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| Static (for container) | `fxLayout` | Defines the direction of the flow (that
    is, flex-direction). | `<div fxLayout="row" fxLayout.xs="column">` `</div>` |'
  prefs: []
  type: TYPE_TB
- en: '| Static (for container) | `fxLayoutAlign` | Defines the alignment of the elements.
    | `<div fxLayoutAlign="start stretch">` `</div>` |'
  prefs: []
  type: TYPE_TB
- en: '| Static (for container) | `fxLayoutWrap` | Defines whether the elements should
    wrap. | `<div fxLayoutWrap>` `</div>` |'
  prefs: []
  type: TYPE_TB
- en: '| Static (for container) | `fxLayoutGap` | Sets the spacing between elements.
    | `<div fxLayoutGap="15px">` `</div>` |'
  prefs: []
  type: TYPE_TB
- en: '| Static (for children) | `fxFlex` | Specifies resizing of the host element
    within its container flow layout. | `<div fxFlex="1 2 calc(15em + 20px)">` `</div>`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Static (for children) | `fxFlexOrder` | Defines the order of a FlexBox item.
    | `<div fxFlexOrder="2">` `</div>` |'
  prefs: []
  type: TYPE_TB
- en: '| Static (for children) | `fxFlexOffset` | Offsets a FlexBox item within its
    container flow layout. | `<div fxFlexOffset="20px">` `</div>` |'
  prefs: []
  type: TYPE_TB
- en: '| Static (for children) | `fxFlexAlign` | Similar to `fxLayoutAlign`, but for
    a specific FlexBox item (not all). | `<div fxFlexAlign="center">` `</div>` |'
  prefs: []
  type: TYPE_TB
- en: '| Static (for children) | `fxFlexFill` | Maximizes dimensions of the element
    to that of its parent container. | `<div fxFlexFill>` `</div>` |'
  prefs: []
  type: TYPE_TB
- en: These APIs have options, and defaults. For instance, the `fxLayout` API defaults
    to row, but also has column, as well as row-reverse, and column-reverse.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the `.xs` in the example for the `fxLayout` API has a similar notion as
    the Bootstrap grid in that it provides a way to allow for different viewport sizes.
    So, in the first example in the preceding table, the layout for regular viewports
    will be that elements flow from left to right within the row, and, for small viewports,
    the elements will be stacked in a single column.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting thing to point out in the examples in the preceding table
    is where there is a calculation made in the `fxFlex` API. This is a little like
    what we looked at in the SASS crash course in [Chapter 3](6694dd13-5500-4563-9688-74a21a06a9a9.xhtml), *Bootstrap –
    Grid Layout and Components*, although SASS was compiled by Ruby, whereas Flex-Layout
    is compiled by TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: I won't enumerate all the options here because you didn't purchase this book
    to read documentation, any more than I wrote this book to just copy documentation.
    Of course, I will point you to the place to look up the documentation for Flex-Layout.
    You can find it at their official website: [https://github.com/angular/flex-layout/wiki/API-Documentation](https://github.com/angular/flex-layout/wiki/API-Documentation).
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the Flex-Layout team has done a fantastic job with the documentation.
    Their wiki also includes several live layout demos that you can take a look at.
    Here is the direct link: [https://tburleson-layouts-demos.firebaseapp.com/#/docs](https://tburleson-layouts-demos.firebaseapp.com/#/docs).
  prefs: []
  type: TYPE_NORMAL
- en: Design strategies when using FlexBox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Flex-Layout is more of a flowing kind of thing, as opposed to being a
    grid, it's often easier to think of vertical sections of your application and
    assign them their own container. This is because the sections within your containers
    will automatically wrap downward as the viewport size gets smaller. Elements within
    the container should be thought of as belonging together. Contrasting this with
    a grid system, such as Bootstrap, the thinking is different; the cells in the
    grid mark the physical boundaries of the elements. The elements within the cells
    don't automatically wrap because when you are thinking of the design/layout, you
    insert elements in specific cells. Another way to conceptualize the differences
    between a grid and FlexBox is to think of a grid as being two-dimensional (that
    is, rows and columns—much like a spreadsheet), and FlexBox as being one-dimensional
    (in that it either flows horizontally, or it flows vertically).
  prefs: []
  type: TYPE_NORMAL
- en: Once you have your vertical containers in mind, you can then think about sub-containers
    flowing from left to right, and the sub-container then wrapping downward as the
    viewport size gets smaller—and when it does wrap downward, all the elements with
    that sub-container go along for the ride. Bear in mind, when I mention sub-containers,
    that I'm referring to the fact that FlexBox containers can be nested—which is
    what gives much of the layout control to the developer. When laying out your page,
    think of the flows as *outside-in*. This is to say that you should break up your
    page into large vertical sections—such as a header, main body, and footer—and
    then dive into each of the sections to add your sub-containers, which will flow
    from left to right.
  prefs: []
  type: TYPE_NORMAL
- en: It's difficult to describe *flow* in words, and so the best thing to do, as
    always, is to experiment with your containers and elements and study the behavior
    of their flow as you adjust your viewport size. This chapter includes code listings
    for three of our component templates (that is, *pages*) as well as their wireframes.
    You'll see exactly how I've designed the layouts for these component templates.
    Along the way, I'll also tell you why I've made some of the decisions I've made.
  prefs: []
  type: TYPE_NORMAL
- en: Associating our components with the chapters and topics in this book
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we haven't discussed where and when we'll be implementing our
    components. Part of the reason was that we didn't even start writing any Angular
    code until [Chapter 4](66c21daa-b131-470d-a21b-0fbed56c3ec9.xhtml), *Routing*—with
    the sole exception being our to-do list mini-application in [Chapter 1](f1243d74-a120-408f-8181-cb379b457dd1.xhtml),
    *Quick Start*. However, now that we have started writing Angular code, it's time
    to do that now.
  prefs: []
  type: TYPE_NORMAL
- en: A good place to start the discussion is to select which component templates
    we'll be laying out with Flex-Layout. Since this book focuses more on Bootstrap
    than it does with Flex-Layout, we'll be using Bootstrap's grid for the rest of
    our component templates, which is the majority of them.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we'll do is to list our wireframes, as a reference,which represent
    our application's *pages* (that is, component templates), and we'll select three
    of them, which we will implement in the following section, *Implementing our selected
    wireframes*. And then, we'll look at the table that follows, which will show you
    which component templates we will implement and which chapters and, specifically,
    which topics we're pairing them up with.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of our 13 wireframes from [Chapter 1](f1243d74-a120-408f-8181-cb379b457dd1.xhtml),
    *Quick Start*:'
  prefs: []
  type: TYPE_NORMAL
- en: Home
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sign Up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log In
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edit Profile (excluded from coverage in the book)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Property Listing (excluded from coverage in the book)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create Listing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edit Listing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preview Listing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Property Details (excluded from coverage in the book)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Photo Listing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upload Photo / Create Card
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edit Photo (excluded from coverage in the book)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preview Photo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a table of the wireframes that we will implement together
    in this book, along with a list of their associated chapters and topics. You can
    use this as a kind of roadmap in conceptually piecing together our application
    in your mind—meaning, at a high level, you''ll know in which chapter we''ll be
    implementing various parts of the component templates in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Wireframe /component template** | **Associated chapters** | **Associated topics**
    |'
  prefs: []
  type: TYPE_TB
- en: '| Home | 3 | Bootstrap grid |'
  prefs: []
  type: TYPE_TB
- en: '| Sign Up | 3, 8, 10 | Modal dialog, ng-Bootstrap (input boxes), Forms |'
  prefs: []
  type: TYPE_TB
- en: '| Log In | 14 | Authentication |'
  prefs: []
  type: TYPE_TB
- en: '| Create Listing | 5, 14 | Flex-Layout, Custom validation |'
  prefs: []
  type: TYPE_TB
- en: '| Edit Listing | 5, 10 | Flex-Layout, Forms |'
  prefs: []
  type: TYPE_TB
- en: '| Preview Listing | 5, 6, 9 | Flex-Layout, Components, Angular Material (chips)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Photo Listing | 6, 7 | Components, Templates |'
  prefs: []
  type: TYPE_TB
- en: '| Upload Photo / Create Photo Card | 10 | Forms |'
  prefs: []
  type: TYPE_TB
- en: '| Preview Photo | 6, 9 | Components, Angular Material (card) |'
  prefs: []
  type: TYPE_TB
- en: The preceding table shows us topics from which chapters we will be implementing
    in our wireframes (that is, component templates). For example, by taking a look
    at the fourth row from the top, we can see that when we implement our Create Listing
    wireframe (that is, our `CreateListingComponent`), we'll be using Flex-Layout
    from this chapter, and Custom Validation from [Chapter 14](485921eb-86e2-4068-b314-5c62a1545c22.xhtml), *Advanced
    Angular Topics*.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that every wireframe will require components—despite not listing
    [Chapter 6](acd5e47c-07a7-4954-993d-360134221325.xhtml), *Building Angular Components*,
    in the associated chapters column, and components in the associated topics column.
    The reason I did this for some of the wireframes, such as Photo Listing and Preview
    Photo, is that we're going to discuss components a little more than we will, say,
    for the Sign-Up or Edit Listing wireframes. Also, certain wireframes will have
    us focusing much more on other topics. For instance, you can see for the Upload
    Photo wireframe that we'll be focusing on forms, from [Chapter 10](5f27121b-6fb2-4429-aa6e-394aec2152ac.xhtml),
    *Working with Forms*.
  prefs: []
  type: TYPE_NORMAL
- en: Since we won't be jumping from chapter to chapter, this means that we'll be
    revisiting the majority of our pages (that is, component templates) two, three,
    or even four times, as we progress through the book.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing our selected wireframes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The three wireframes (that is, component templates) that I''ve selected to
    implement with you in this chapter are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create Listing (included because there are many sections and elements within
    the view)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edit Listing (included for the same reason as Create Listing)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preview Listing (included because there are very few elements within the view)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the listing of the aforementioned wireframes , you may have noticed that
    there are three wireframes that have been marked as *excluded from coverage in
    the book*. Here is the wireframe exclusion list, along with the reason for its
    exclusion:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Edit Profile**: This has been excluded because it is just another edit form
    (much like the Edit Listing screen)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Property Listing**: This has been excluded because it is just another listing
    screen (much like the Photo Listing screen)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Property Details**: This has been excluded because it is a static screen
    that is uninteresting to us, from an Angular perspective'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Edit Photo**: This has been excluded because it''s yet again just another
    edit form'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, don't fret. All the code for the application that we'll be building
    together throughout the remaining pages, including the code for the four wireframes
    that we won't be implemented in the book, as well as the non-UI-based code (such
    as the Python-based APIs in [Chapter 12](9610f27b-03db-4258-8a68-24eb3901117b.xhtml),
    *Integrating Backend Data Services*, and more), are being made available to you
    as a download. I have you covered.
  prefs: []
  type: TYPE_NORMAL
- en: One last noteworthy point, and then we'll get on with some Flex-Layout coding.
    You can tell that our application will require some wireframes to be revisited
    more than once so that we can complete it—that is, we'll be building our application
    in pieces and in what seems like a chaotic back and forth fashion. This is not
    because the author is off his rocker—as some of his friends would love to tell
    you stories that make a strong case for just the opposite—but rather, it is by
    design. Remember, the philosophy of this book is to maximize your effectiveness
    of the absorption of the material, so you embark on the journey to becoming an
    Angular guru as quickly as possible. To the extent possible, we will immediately
    implement what material we cover so that it makes immediate sense, and sticks.
    That's the goal—and is also why I wanted to include the preceding table (that
    is, associating the wireframes with the chapters and topics).
  prefs: []
  type: TYPE_NORMAL
- en: There's typically a method to my madness (wink). Let's now turn our attention
    to the implementation of the three wireframes for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The Create Listing wireframe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will bring all our knowledge and understanding together
    and learn to create our application pages for the Create Listing page. Take a
    look at the following wireframe, which we will convert into code using Flex-Layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/952c07b6-0b5c-467b-a454-d51e1219ad9e.png)'
  prefs: []
  type: TYPE_IMG
- en: The other wireframe shows that we will need a header section and a two-column
    layout to hold the form and input elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first create a new component in our application and call it `Create
    Listing`. In the component template file, let''s add the following sample code
    to the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are creating a row using the `fxLayout` to create
    a placeholder for our logo. Next, we are creating the menu links and, using `fxFlexOrder`,
    we are sorting the menu links. Now, we will need to create a two-column layout,
    so we are now creating child elements inside the `fxLayout` row with two divisions,
    each `fxFlex` for 60 and 40, respectively. Inside the two columns, we will place
    our form input elements to create the form, as shown in the wireframe. Run the
    app and we should see the output, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5ee464c0-2a23-4602-b2aa-8855b27e4577.png)'
  prefs: []
  type: TYPE_IMG
- en: We have got our layout ready for the **Create Listing** page. If you look closely,
    our labels are not exactly next to the input fields. What needs to be updated?
    That's right; we need to create a child column inside the main column. Try it
    out by way of your homework. Now, on similar lines, we can easily implement our
    Edit Listing page.
  prefs: []
  type: TYPE_NORMAL
- en: The Edit Listing wireframe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we have created our **Create Listing** page. In this
    section, we will learn to implement the page layout for our Edit Listing page.
    Take a look at the example we will implement. Does it not look exactly the same
    as the **Create Listing** page? That's correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'The layout of the **Create** and **Edit Listing** pages will mostly be the
    same, except for the fact that there is data loaded when we launch the **Edit**
    page, whereas in the **Create** screen, there will be no data loaded initially:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0e242f70-fe76-4216-b713-a02a8102963b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, it''s time for some code action. We will create a new component in our
    Angular project named edit-listing and, in the component template file, we will
    reuse the same code to create the layout from the **Create Listing** page to quickly
    get the **Edit Listing** page ready:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are creating two rows,  one for the header section
    and the other for the content row. Inside the content row, we are creating two
    child columns using `fxRow`, which will be populated with the form input field
    elements. The output will be exactly the same as that of the Create Listing page.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter provided a quick tour of exciting technology. Of course, a small
    book can be written that is exclusively dedicated to FlexBox CSS and Flex-Layout,
    so covering it in just a few pages does not do it the justice it deserves. If
    there is an industry that changes rapidly, it is ours, and so alternative technologies
    should be mentioned—and, if the technology was exciting enough, maybe even get
    its own chapter—regardless of which tech book and which technologies. This was
    precisely the case for Flex-Layout and this book. I wanted to introduce Flex-Layout
    to you, in some depth.
  prefs: []
  type: TYPE_NORMAL
- en: We started the chapter with a quick review of the four options for the layout
    techniques, explaining why FlexBox CSS is the best choice of the four. I then
    introduced Flex-Layout to you and presented a few compelling reasons for why you
    should consider using it instead of using FlexBox. Next, we saw how to integrate
    Flex-Layout into our Angular project, and took a look at a few of its APIs. Lastly,
    we circled back to our wireframes (that is, components) and associated each of
    them with the chapters in this book, and then implemented the components that
    were associated with this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you enjoyed this chapter and will make it a point to experiment with
    Flex-Layout in at least one of your web development projects. My prediction is
    that many Angular developers will choose Flex-Layout as their tool of choice for
    laying out their components. I was already leaning toward using Flex-Layout instead
    of Bootstrap's grid for my next project, for all component templates.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn all about the building blocks of
    any Angular applications - components. We will deep-dive to learn and create some
    cool stuff with Angular components. Happy Reading.
  prefs: []
  type: TYPE_NORMAL
