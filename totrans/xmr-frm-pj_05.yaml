- en: Building a Weather App for Multiple Form Factors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Xamarin.Forms isn''t only be used for creating apps for phones; it can also
    be used for creating apps for tablets and desktop computers. In this chapter,
    we will build an app that will work on all of these platforms. As well as using
    three different form factors, we are also going to be working on three different
    operating systems: iOS, Android, and Windows.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use `FlexLayout` in Xamarin.Forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use `VisualStateManager`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use different views for different form factors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use behaviors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To work on this project, we need to have Visual Studio for Mac or PC installed,
    as well as the Xamarin components. See [Chapter 1](80b2455c-7174-4e4b-b2eb-916d03b9d3f6.xhtml), *Introduction
    to Xamarin,* for more details on how to set up your environment.
  prefs: []
  type: TYPE_NORMAL
- en: Project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applications for iOS and Android can run on both phones and tablets. Very often,
    apps are just optimized for phones. In this chapter, we will build an app that
    will work on different form factors, but we aren't going to stick to just phones
    and tablets—we are going to target desktop computers as well. The desktop version
    will be for the **Universal Windows Platform** (**UWP**).
  prefs: []
  type: TYPE_NORMAL
- en: The app that we are going to build is a weather app that displays the weather
    forecast based on the location of the user.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use either Visual Studio 2017 for PC or Visual Studio for Mac to work
    on this project. To build an iOS app using Visual Studio for PC, you have to have
    a Mac connected. If you don't have access to a Mac at all, you can choose to just
    work on the Windows and Android parts of this project. Similarly, if you only
    have a Mac, you can choose to work on only the iOS and Android parts of this project.
  prefs: []
  type: TYPE_NORMAL
- en: Building the weather app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's time to start building the app. Create a new blank Xamarin.Forms app using .NET
    Standard as the Code Sharing Strategy, and select iOS, Android, and Windows (UWP) as
    the platforms. We will name the project `Weather`.
  prefs: []
  type: TYPE_NORMAL
- en: As the data source for this app, we will use an external weather API. This project
    will use `OpenWeatherMap`, a service that offers a couple of free APIs. You can
    find this service at [https://openweathermap.org/api](https://openweathermap.org/).
    We will use the service called `5 day / 3 hour forecast `in this project, which
    provides a five-day forecast in three-hour intervals. To use the `OpenWeather`
    API, we have to create an account to get an API key. If you don't want to create
    an API key, we can mock the data instead.
  prefs: []
  type: TYPE_NORMAL
- en: Creating models for the weather data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we write the code to fetch data from the external weather service, we
    will create models in order to deserialize the results from the service so that
    we have a common model that we can use to return data from the service.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to generate models to use when we are deserializing results
    from the service is to make a call to the service either in the browser or with
    a tool (such as Postman) to see the structure of the JSON. We can either create
    classes manually or use a tool that can generate C# classes from the JSON. One
    tool that can be used is **quicktype**, which can be found at [https://quicktype.io/](https://quicktype.io/).
  prefs: []
  type: TYPE_NORMAL
- en: If you generate them manually, make sure to set the namespace to `Weather.Models`.
  prefs: []
  type: TYPE_NORMAL
- en: As stated, you can also create these models manually. We will describe how to
    do this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the weather API models manually
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you choose to add the models manually, then go through the following instructions.
    We will be adding a single code file called `WeatherData.cs` that will contain
    multiple classes:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Weather` project, create a folder named `Models`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a file called `WeatherData.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there are quite a lot of classes. These map directly to the
    response we get from the service.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the app-specific models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will create the models that our app will translate the
    Weather API models into. Let''s start by adding the `WeatherData` class (unless
    you created this manually in the preceding section), using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder with the name `Models` in the `Weather` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new file with the name `WeatherData`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Paste or write the code for the classes based on the JSON. If code other than
    the properties is generated, ignore it and just use the properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename `MainClass` (this is what quicktype names the root object) as `WeatherData`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will now create models based on the data we are interested in. This will
    make the rest of the code more loosely coupled to the data source.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the ForecastItem model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first model we are going to add is `ForecastItem`, which represents a specific
    forecast for a point in time. We do this by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Weather` project, create a new class called `ForecastItem`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Adding the Forecast model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we''ll create a model called `Forecast` that will keep track of a single
    forecast for a city. The `Forecast` keeps a list of multiple `ForeCastItem` objects,
    each representing a forecast for a specific point in time. Let''s set this up
    by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Weather` project, create a new class called `Forecast`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our models for both the Weather API and the app, we need to
    fetch data from the Weather API.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a service for fetching the weather data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make it easier to change the external weather service and to make the code
    more testable, we will create an interface for the service. Here''s how we go
    about it:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Weather` project, create a new folder and name it `Services`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `public interface` and name it `IWeatherService`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a method for fetching data based on the location of the user, as shown
    in the following code. Name the method `GetForecast`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When we have an interface, we can create an implementation for it by going
    through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Services` folder, create a new class with the name `OpenWeatherMapWeatherService`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the interface and add the `async` keyword to the `GetForecast` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we call the `OpenWeatherMap` API, we need to build a URI for the call
    to the Weather API. It will be a `GET` call and the latitude and longitude will
    be added as query parameters. We will also add the API key and the language in
    which we would like the response. Let''s set this up by going through the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WeatherProject`, open the `OpenWeatherMapWeatherService` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the code marked in bold in the following code fragment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to deserialize the JSON that we will get from the external service,
    we will use `Json.NET`, the most popular NuGet package for serializing and deserializing
    JSON in .NET applications. We can install it using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the NuGet Package Manager.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the `Json.NET` package. The ID of the package is `Newtonsoft.Json`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To make the call to the `Weather` service, we will use the `HttpClient` class
    and the `GetStringAsync` method using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new instance of the `HttpClient` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `GetStringAsync` and pass the URL as the argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `JsonConvert` class and the `DeserializeObject `method from `Json.NET`
    to convert the JSON string in to an object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Map the `WeatherData` object to a `Forecast` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code should look like the bold code in the following fragment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To optimize the performance, we can use `HttpClient` as a singleton and reuse
    it for all network calls in the application. The following information is from
    Microsoft's documentation: *HttpClient** is intended to be instantiated once and
    reused throughout the life of an application. Instantiating an HttpClient class
    for every request will exhaust the number of sockets available under heavy loads.
    This will result in SocketException errors. *This can be found at: [https://docs.microsoft.com/en-gb/dotnet/api/system.net.http.httpclient?view=netstandard-2.0](https://docs.microsoft.com/en-gb/dotnet/api/system.net.http.httpclient?view=netstandard-2.0).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous code, we have a call to a `ToDateTime` method, which is a method
    that we will need to create. This method converts the date from a Unix timestamp
    in to a `DateTime` object, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: By default, `HttpClient` uses the Mono implementation of `HttpClient` (iOS and
    Android). To increase performance, we can use a platform-specific implementation
    instead. For iOS, use `NSUrlSession`. This can be set in the project settings
    of the iOS project under the iOS Build tab. For Android, use Android. This can
    be set in the project settings of the Android project under Android Options | Advanced.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the applications to use location services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to use location services, we need to carry out some configurations
    on each platform. We will use Xamarin.Essentials and the classes it contains.
    Ensure that you have installed Xamarin.Essentials from NuGet into all projects
    in the solution before going through the steps in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the iOS app to use location services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use location services in an iOS app, we need to add a description to indicate
    why we want to use the location in the `info.plist` file. In this app, we only
    need to get the location when we are using the app, so we only need to add a description
    for this. Let''s set this up by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `info.plist` in `Weather.iOS` with the XML (Text) Editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the key, which is `NSLocationWhenInUseUsageDescription`, using the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Configuring the Android app to use location services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For Android, we need to set the app to require the following two permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: ACCESS_COARSE_LOCATION
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ACCESS_FINE_LOCATION
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can set this in the `AndroidManifest.xml` file that can be found in the
    `Properties` folder in the `Weather.Android` project, but we can also set it in
    the project properties under the Android Manifest tab as well, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/234daa3f-c5a6-471f-8efd-9a1b53904304.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When we request permissions in an Android app, we also need to add the following
    code to `MainActivity.cs` file in the Android project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'For Android, we also need to initialize Xamarin.Essentials. We will do this
    in the `OnCreate` method of the `MainActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Configuring the UWP app to use location services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we will use location services in the UWP app, we need to add the Location
    capability under Capabilities in the `Package.appxmanifest` file of the `Weather.UWP`
    project, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a04a344-7e1a-4ee7-9bd3-aa2124362a41.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating the ViewModel class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now have a service that is responsible for fetching weather data from the
    external weather source. It''s time to create a `ViewModel`. First, however, we
    will create a base view model, where we can put the code that can be shared between
    all view models of the app. Let''s set this up by going through the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder with the name `ViewModels`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new class with the name `ViewModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the new class `public` and `abstract`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add and implement the `INotifiedPropertyChanged` interface. This is necessary
    because we want to use data bindings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a `Set` method that will make it easier to raise the `PropertyChanged`
    event from the `INotifiedPropertyChanged` interface, as shown in the following
    code. The method will check whether the value has changed. If it has, it will
    raise the event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `CallerMemberName` attribute can be used in a method body if you want the
    name of the method or the property that made the call to the method to be a parameter.
    We can always override this, however, by simply passing a value to it. The default
    value of the parameter is required when you are using the `CallerMember` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a base view model. We can use this for the view model that we are
    creating now, as well as for all of the other view models that we will add later.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s now time to create `MainViewModel`, which will be `ViewModel` for our
    `MainView` in the app. We do this by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `ViewModels` folder, create a new class called `MainViewModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the abstract `ViewModel` class as a base class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because we are going to use constructor injection, we will add a constructor
    with the `IWeatherService` interface as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a read-only `private` field that we will use to store the `IWeatherService`
    instance using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`MainViewModel` takes any object that implements `IWeatherService` and stores
    a reference to that service in a field. We will be adding functionality to fetch
    weather data in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting the weather data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now create a new method for loading the data. This will be a three-step
    process. First, we will get the location of the user. Once we have this, we can
    fetch data related to that location. The final step is to prepare the data that
    the views can consume to create a user interface for the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the location of the user, we will use Xamarin.Essentials, which we installed
    earlier as a NuGet package, and the `Geolocation` class, which exposes methods
    to fetch the location of the user. We do this by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new method called `LoadData`. Make it an asynchronous method that returns
    a `Task`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `GetLocationAsync` method on the `Geolocation` class to get the location
    of the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Pass the latitude and longitude from the result of the `GetLocationAsync` call
    and pass it to the `GetForecast` method on the object that implements `IWeatherService`
    using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Grouping the weather data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we present the weather data, we will group it by day so that all of the
    forecasts for one day will be under the same header. To do this, we will create
    a new model that we will name `ForecastGroup`. To make it possible to use this
    model with the Xamarin.Forms `ListView`, it has to have an `IEnumerable` type
    as the base class. Let''s set this up by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class called `ForecastGroup` in the `Models` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `List<ForecastItem>` as the base class for the new model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an empty constructor and a constructor that has a list of `ForecastItem` instances
    as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `Date` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a property, `DateAsString`, that returns the `Date` property as a short
    date string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a property, `Items`, that returns the list of `ForecastItem` instances,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When we have done this, we can update `MainViewModel` with two new properties
    by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a property called `City` for the name of the city for which we are fetching
    the weather data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a property called `Days` that will contain the grouped weather data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `MainViewModel` class should look like the bold code in the following fragment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to do the actual grouping of the data. We will do this in
    the `LoadData` method. We will loop through the data from the service and add
    items to groups by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `itemGroups `variable of the `List<ForecastGroup>`type .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `foreach` loop that loops through all items in the `forecast` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an `if` statement that checks whether the `itemGroups` property is empty.
    If it is empty, add a new `ForecastGroup` to the variable and continue to the
    next item in the item list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `SingleOrDefault` method (this is an extension method from System.Linq)
    on the `itemGroups` variable to get a group based on the date of the current `ForecastItem`.
    Add the result to a new variable, `group`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the group property is `null`, then there is no group with the current day
    in the list of groups. If this is the case, a new `ForecastGroup` should be added to
    the list in the `itemGroups` variable, and the execution of the code will continue
    to the next `forecast` item in the `forecast.Items` list. If a group is found,
    it should be added to the list in the `itemGroups` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the `foreach` loop, set the `Days` property with a new `ObservableCollection<ForecastGroup>`and
    use the `itemGroups` variable as an argument in the constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `City` property to the `City` property of the `forecast` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `LoadData` method should now look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Don't use the `Add` method on `ObservableCollection` when you want to add more
    than a couple of items. It is better to create a new instance of `ObservableCollection`
    and pass a collection to the constructor. The reason for this is that every time
    you use the `Add` method, you will have a binding to it from the view, and it
    will trigger a rendering of the view. We will get a better performance if we avoid
    using the `Add` method.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Resolver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create a helper class for **Inversion of Control** (**IoC**). This
    will help us to create types based on a configured IoC container. In this project,
    we will use Autofac as the IoC library. Let''s set this up by going through the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the NuGet package Autofac in the `Weather` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new class called `Resolver` in the `Weather` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `private static` field called `container` of the `IContainer` type (from
    Autofac).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `public static` method called `Initialize` with `IContainer` as a parameter.
    Set the value of the parameter to the `container` field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a generic `public static` method called `Resolve<T>`, which will return
    an instance of an object of the type specified with the `T` parameter. The `Resolve<T>`
    method will then call the `Resolve<T>` method on the `IContainer` instance that
    was passed to it during initialization.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code should now look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Creating a bootstrapper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will create a `Bootstrapper` class that we will use to
    set up the common configurations that we need in the startup phase of the app.
    Usually, there is one part of the bootstrapper for each target platform and one
    that is shared for all platforms. In this project, we only need the shared part.
    Let''s set this up by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Weather` project, create a new class called `Bootstrapper`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new `public static` method called `Init`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `ContainerBuilder` and register the types to `container`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `Container` by using the `Build` method of the `ContainerBuilder`.
    Create a variable called `container` that contains the instance of `Container`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `Initialize` method on `Resolver` and pass `container` variable as an
    argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `Bootstrapper` class should now look like the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the `Init` method of `Bootstrapper` in the constructor in the `App.xaml.cs`
    file after the call to the `InitializeComponent` method. Also, set the `MainPage` property
    to `MainView`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Creating a RepeaterView based on a FlexLayout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Xamarin.Forms, we can use `ListView` if we want to show a collection of data.
    Using `ListView` is great, and we will use it later in this chapter, but it can
    only show data vertically. In this app, we want to show data in both directions.
    In the vertical direction, we will have the days (we group forecasts based on
    days), while in the horizontal direction, we will have the forecasts within a
    particular day. We also want the forecasts within a day to wrap if there is not
    enough space for all of them in one row. With `FlexLayout`, we are able to add
    items in both directions. However, `FlexLayout` is a layout, which means that
    we can't bind items to it, so we have to extend its functionality. We will name
    our extended `FlexLayout` `RepeaterView`. The `RepeaterView` class will render
    content based on a `DataTemplate` and the items added to it will appear as if
    you have used `ListView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create `RepeaterView` by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder called `Controls` in the `Weather` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new class called `RepeaterView` to the `Controls` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an empty method called `Generate`**. **We will add code to this method
    later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new private field called `itemsTemplate` of the `DataTemplate`type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new property called `ItemsTemplate` of the `DataTemplate`type. The
    `get` method will just return the `itemsTemplate` field. The `set` method will
    set the `itemsTemplate` field to the new value. However, it will also call the
    `Generate` method to trigger a regeneration of the data when we have a new template
    that needs to be generated. The generation has to be done on the main thread,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to bind to a property, we need to add `BindableProperty` by going
    through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a `public static BindableProperty` field called `ItemsSourceProperty` that
    returns `null` as a default value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `public` property called `ItemsSource`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a setter to the `ItemSource` that sets the value of `ItemsSourceProperty`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a getter to the `ItemsSource` property that returns the value of `ItemsSourceProperty`,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In a bindable property declaration like the one in the preceding code, we can
    take action on different actions. The one we are interested in is the `propertyChanged`
    action. If we assign a delegate to this property, then it will get called any
    time that property changes in value and we can take action on that change. In
    this case, we will regenerate the content of `RepeaterView`. We do this by going
    through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a property-changed delegate (as shown in the following code) as an argument
    to the `Create` method of `BindableProperty` to regenerate the UI when the `ItemsSource` property
    changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check that `DateTemplate` is not `null` before regenerating the UI on the main
    thread, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The last step of `RepeaterView` is to generate content in the `Generate` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement the `Generate` method by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Clear all child controls with `Children.Clear();`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that `ItemSource` is not `null`. If it is `null`, do an empty `return`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Loop through all items and generate content from `DataTemplate`. Set the current
    item as `BindingContext` and add it as a child of `FlexLayout`, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Creating the view for tablets and desktop computers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step is to create the view that we will use when the app is running
    on a tablet or a desktop computer. Let''s set this up by going through the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder in the `Weather` project and name it `Views`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Content Page with XAML and name it `MainView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the `Resolver` in the constructor of the view to set`BindingContext` to `MainViewModel`,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: To trigger `LoadData` method in `MainViewModel`, call the `LoadData` method by
    overriding the `OnAppearing` method on the main thread. We need to make sure that
    the call gets marshaled to the UI thread since it will interact directly with
    the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Weather` project, open the `MainView.xaml.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an override of the `OnAppearing` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the code in bold in the following fragment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the XAML, add a binding for the `Title` property of `ContentPage` to the
    `City` property in`ViewModel` by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Weather` project, open the `MainView.xaml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `Title` binding to the `ContentPage` element, as highlighted in bold
    in the following code fragment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Using RepeaterView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To add a custom control to a view, we need to import a namespace to the view.
    If the view is in another assembly, we also need to specify the assembly, but
    in this case, we have both the view and the control in the same namespace, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Follow the steps below to build the view:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a `Grid` as the root view of the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `ScrollView` to `Grid`. We need this to be able to scroll if the content
    is higher than the height of the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `RepeaterView` to `ScrollView` and set the direction to `Column` so the
    content will be in a vertical direction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a binding to the `Days` property in `MainViewModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set a `DataTemplate` to the content of `ItemsTemplate`, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The content for each item will be a header with the date and a horizontal `RepeaterView`
    with the forecasts for the day. Let''s set this up by going through the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Weather` project, open the `MainView.xaml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `StackLayout` so that the children we are adding to it will be placed in
    a vertical direction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `ContentView` to `StackLayout` with `Padding` set to `10` and `BackgroundColor` set
    to `#9F5010`. This will be the header. The reason that we need `ContentView` is
    that we want to have padding around the text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `Label`to `ContentView` with the `TextColor` set to `White` and `FontAttributes` set
    to `Bold`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a binding to `DateAsString` for the `Text` property of `Label`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code should be placed at the  `<!-- Content will be added here -->` comment,
    and should look like the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the date in the user interface, we need to add a `RepeaterView`
    that will repeat through `Items` in `MainViewModel` by going through the following
    steps. `RepeaterView` is the control we created earlier that inherits from `FlexLayout`:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a `RepeaterView` after the `</ContentView>` tag, but before the `</StackLayout>`
    tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `JustifyContent` to `Start`to set the `Items` to be added from the left
    side without distributing them over the available space.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set `AlignItems` to `Start` to set the content to the left of each item in `FlexLayout`
    that `RepeaterView` is based on, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'After defining `RepeaterView`, we need to provide an `ItemsTemplate` that defines
    how each item in the list should be rendered. Continue adding the XAML directly
    under the `<controls:RepeaterView>` tag you just added by going through the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Set the `ItemsTemplate` property to `DataTemplate`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Fill the `DataTemplate` with elements, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we want to add formatting to a binding, we can use `StringFormat`. In this
    case, we want to add the degree symbol after the temperature. We can do this by
    using the `{Binding Temperature, StringFormat='{0}° C'}` phrase. With the `StringFormat`
    property of the binding, we can format data with the same arguments that we would
    use if we did it in C#. This is the same as `string.Format("{0}° C", Temperature)`
    in C#. We can also use it to format a date—for example `{Binding Date, StringFormat='yyyy'}`.
    In C#, this would look like `Date.ToString("yyyy")`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `AspectFill `phrase, as a value of the `Aspect` property for `Image`, means
    that the whole image will always be visible and that aspects will not be changed.
    The `AspectFit`phrase will also keep the aspect of an image, but the image can
    be zoomed and cropped to fill the whole `Image` element. The last value that `Aspect`
    can be set to, `Fill`, means that the image can be stretched or compressed to
    match the `Image` view without ensuring that the aspect is kept.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a toolbar item to refresh the weather data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to refresh the data without restarting the app, we will add a Refresh
    button to the toolbar. `MainViewModel` is responsible for handling any logic that
    we want to perform, and we must expose any action as an `ICommand` that we can
    bind to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating the `Refresh` command property on `MainViewModel`
    by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Weather` project, open the `MainViewModel` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an `ICommand` property with the name `Refresh` and a `get` method that returns
    a new `Command`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an action as an expression to the constructor of the `Command`that calls
    the `LoadData` method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have defined `Command`, we need to bind it to the user interface
    so that when the user clicks the toolbar button, the action will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Weather` app, open the `MainView.xaml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new `ToolbarItem` with the `Text` property set to `Refresh` to the `ToolbarItems` property
    of `ContentPage` and set the `Icon` property to `refresh.png` (the icon can be
    downloaded from GitHub; see [https://github.com/PacktPublishing/Xamarin.Forms-Projects/tree/master/Chapter-5](https://github.com/PacktPublishing/Xamarin.Forms-Projects/tree/master/Chapter-5)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Bind the `Command` property to the `Refresh` property in `MainViewModel`, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: That's all for refreshing the data. Now we need some kind of indicator that
    data is loading.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a loading indicator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we refresh the data, we want to show a loading indicator so the user will
    know that something is happening. To do this, we will add `ActivityIndicator`,
    which is what this control is called in Xamarin.Forms. Let''s set this up by going
    through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Weather` project, open the `MainViewModel` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Boolean property with the name `IsRefreshing` to the `MainViewModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `IsRefreshing` property to `true` at the beginning of the `LoadData`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the end of the `LoadData` method, set the `IsRefreshing` property to `false`,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have added some code in the `MainViewModel`, we need to bind the `IsRefreshing`
    property to a user interface element that will be displayed when the `IsRefreshing`
    property is `true`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `MainView.xaml`, add a `Frame` after the `ScrollView` as the last element
    in the `Grid`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bind the `IsVisible` property to the `IsRefreshing` method that we created in
    the `MainViewModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `HeightRequest` and the `WidthRequest` to `100`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `VerticalOptions` and the `HorizontalOptions` to `Center` so that the
    `Frame` will be in the middle of the view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `BackgroundColor` to `#99000000` to set the background to white with
    a little bit of transparency.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add `ActivityIndicator` to the `Frame` with the `Color` set to `Black` and
    `IsRunning` set to `True`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This will create a spinner that will be visible while data is loading, a really
    good practice when creating any user interface. Now we'll add a background image
    to make the app look a bit nicer.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a background image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last thing we will do to this view for the moment is to add a background
    image. The image we are using in this example is a result of a Google search for
    images that are free to use. Let''s set this up by going through the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Weather` project, open the `MainView.xaml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wrap the `ScrollView` in a `Grid`. Using a `Grid` is great if we want to have
    our elements in layers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `Background` property of the `ScrollView` to `Transparent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an `Image` element in the `Grid` with `UriImageSource` as the value of the
    `Source` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `CachingEnabled` property to `true` and the `CacheValidity` to `5`.
    This means that the image will be cached in five days.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The XAML should now look like the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We can also set the URL directly in the `Source` property by using `<Image Source="https://ourgreatimage.url"
    />`. However, if we do this, we can't specify the caching for the image.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the view for phones
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Structuring content on a tablet and on a desktop computer is very similar in
    many ways. On phones, however, we are much more limited in what we can do. Therefore,
    in this section, we will create a specific view for this app when used on phones
    by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new XAML-based Content Page in the `Views` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new view called `MainView_Phone`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the `Resolver` in the constructor of the view to set the `BindingContext`
    to the `MainViewModel`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'To trigger the `LoadData` method in the `MainViewModel`, call the `LoadData`
    method by overriding the `OnAppearing` method on the main thread. To do this,
    go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Weather` project, open the `MainView_Phone.xaml.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the override of the `OnAppearing` method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In the XAML, add a binding for the `Title` property of the `ContentPage` to
    the `City` property in the `ViewModel`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Weather` project, open the `MainView_Phone.xaml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `Title` property with a binding to the `City` property of the `MainViewModel`,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Using a grouped ListView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We could use `RepeaterView` for the phone's view, but because we want our user
    experience to be as good as possible, we will use `ListView` instead. To get the
    headers for each day, we will use grouping for the `ListView`. For `RepeaterView`,
    we had `ScrollView`, but for `ListView`, we don't need that because `ListView`
    can handle scrolling by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue to create the user interface for the phone''s view by going
    through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Weather` project, open the `MainView_Phone.xaml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `ListView` to the root of the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set a binding to the `Days` property in `MainViewModel` for the `ItemSource`
    property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `IsGroupingEnabled` to `True` to enable grouping in the `ListView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `HasUnevenRows` to `True` so the height of each cell will be calculated
    for each item in the `ListView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `CachingStrategy` to `RecycleElement` to reuse cells that are not on
    the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the `BackgroundColor` to `Transparent`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Set the `CachingStrategy` to `RecycleElement` to get better performance from
    the `ListView`. This means it will reuse cells that are not shown on the screen,
    so it will use less memory and we will get a smoother scrolling experience if
    we have many items in the `ListView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To format how each header will look, we will create a `DataTemplate` by going
    through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a `DataTemplate` to the `GroupHeaderTemplate` property of the `ListView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `ViewCell` to the `DataTemplate`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the content for the row to the `ViewCell`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'To format how each forecast will look, we will create a `DataTemplate`, as
    we did with the group header. Let''s set this up by going through the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a `DataTemplate` to the `ItemTemplate` property of the `ListView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `ViewCell` to the `DataTemplate`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `ViewCell`, add a `Grid` that contains four columns. Use the `ColumnDefinition`
    property to specify the width of the columns. The second column should be `50`
    and the other three will share the rest of the space. We will do this by setting
    the `Width` to `*`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add content to the `Grid`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Adding pull to refresh functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the tablet and desktop version of the view, we added a button to the toolbar
    to refresh the weather forecast. In the phone version of the view, however, we
    will instead add pull to refresh, which is a common way to refresh content in
    a list of data. The `ListView` in Xamarin.Forms has built-in support for pull
    to refresh. Let''s set this up by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the `MainView_Phone.xaml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `IsPullToRefreshEnabled` property to `True`to enable pull-to-refresh
    for the `ListView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bind the `Refresh` property in the `MainViewModel` to the `RefreshCommand` property
    of the `ListView` to trigger a refresh when the user performs a pull-to-refresh
    gesture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To show a loading icon when the refresh is in progress, bind the `IsRefreshing`
    property in the `MainViewModel` to the `IsRefreshing` property of the `ListView`.
    When we are setting this, we will also get a loading indicator when the initial
    load is running, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Navigating to different views based on the form factor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have two different views that should be loaded in the same place in the
    app. `MainView` should be loaded if the app is running on a tablet or on a desktop
    and `MainView_Phone` should be loaded if the app is running on a phone.
  prefs: []
  type: TYPE_NORMAL
- en: The `Device` class in Xamarin.Forms has a static `Idiom` property that we can
    use to check which form factor the app is running on. The value of `Idiom` can
    be `Phone`, `Table`, `Desktop`, `Watch`, or `TV`. Because we only have one view
    in this app, we could have used an `if` statement when we were setting `MainPage`
    in `App.xaml.cs` and checked what the `Idiom` value was. Instead, however, we
    are going to build a solution that we can also use for a bigger app.
  prefs: []
  type: TYPE_NORMAL
- en: One solution is to build a navigation service that we can use to navigate to
    different views based on a key. Which view will be loaded for which key will be
    configured upon starting the app. With this solution, we can configure different
    views on the same key on different types of devices. An open source navigation
    service that we can use for this purpose is `TinyNavigationHelper`, which can
    be found at [https://github.com/TinyStuff/TinyNavigationHelper](https://github.com/TinyStuff/TinyNavigationHelper)
    and was created by the authors of this book.
  prefs: []
  type: TYPE_NORMAL
- en: There is also an MVVM library called `TinyMvvm` that includes `TinyNavigationHelper`
    as a dependency. The `TinyMvvm` library is a library that contains helper classes
    to get started quicker with MVVM in a Xamarin.Forms app. We created `TinyMvvm`
    because we want to avoid writing the same code again and again. You can read more
    at [https://github.com/TinyStuff/TinyMvvm](https://github.com/TinyStuff/TinyMvvm).
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow the steps below to add `TinyNavigationHelper` to the app:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the `TinyNavigationHelper.Forms` NuGet package in the `Weather` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to `Bootstrapper.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the start of the `Execute` method, create a `FormsNavigationHelper` and pass
    the current application to the constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an `if` statement to check whether the `Idiom` is `Phone`. If this is true,
    the `MainView_Phone` view should be registered for the `MainView` key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an `else` statement that registers the `MainView` for the `MainView` key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `Bootstrapper` class should now look as shown in the following code, with
    the new code marked in bold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use the `NavigationHelper` class to set the root view of the app
    in the constructor of the `App` class by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Weather` app, open the `App.xaml.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the constructor of the `App` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the assignment of the `MainPage` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the code to set the root view via the `NavigationHelper`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The constructor should now look like the bold code in the following fragment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: If we want to load different views on different operating systems, we can use
    the static `RuntimePlatform `method on the Xamarin.Forms `Device` class—for example, `if(Device.RuntimePlatform
    == Device.iOS)`.
  prefs: []
  type: TYPE_NORMAL
- en: Handling states with VisualStateManager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`VisualStateManager` was introduced in Xamarin.Forms 3.0\. It is a way to make
    changes in the UI from the code. We can define states and set values for selected
    properties to apply for a specific state. `VisualStateManager` can be really useful
    in cases where we want to use the same view for devices with different screen
    resolutions. It was first introduced in UWP to make it easier to create Windows
    10 applications for multiple platforms because Windows 10 could run on Windows
    Phone as well as on desktops and tablets (the OS was called Windows 10 Mobile).
    However, Windows Phone has now been depreciated. `VisualStateManager` is really
    interesting for us as Xamarin.Forms developers, especially when both iOS and Android
    can run on both phones and tablets.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this project, we will use it to make a forecast item bigger when the app
    is running in landscape mode on a tablet or on a desktop. We will also make the
    weather icon bigger. Let''s set this up by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Weather` project, open the `MainView.xaml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the first `RepeaterView` and in the `DataTemplate`, insert a `VisualStateManager.VisualStateGroups`
    element in the first `StackLayout`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'To the `VisualStateGroup`, we should add two states, we will do that by following
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new `VisualState` called `Portrait` to the `VisualStateGroup`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a setter in the `VisualState` and set the `WidthRequest` to `150`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another `VisualState` called `Landscape` to the `VisualStateGroup`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a setter in the `VisualState` and set the `WidthRequest` to `200`, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We also want the icons in a forecast item to be bigger when the item itself
    is bigger. To do this, we will use the `VisualStateManager` again. Let''s set
    this up by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Insert a `VisualStateManager.VisualStateGroups` element in the second `RepeaterView`
    and in the `Image` element in the `DataTemplate`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `VisualState` for both `Portrait` and `Landscape`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add setters to the states to set the `WidthRequest` and the `HeightRequest`.
    The value should be `1oo` in the `Portrait` state and `150` in the `Landscape`
    state, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Creating a behavior to set state changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With `Behavior`, we can add functionality to controls without having to subclass
    them. With behaviors, we can also create a more reusable code than we could if
    we subclassed a control. The more specific the `Behavior` we create, the more
    reusable it will be. For example, a `Behavior` that inherits from `Behavior<View>`
    could be used on all controls, but a `Behavior` that inherits from a `Button` can only be
    used for buttons. Because of this, we always want to create behaviors with a less
    specific base class.
  prefs: []
  type: TYPE_NORMAL
- en: When we create a `Behavior`, we need to override two methods: `OnAttached` and
    `OnDetachingFrom`. It is really important to remove event listeners in the `OnDeattached`
    method if we have added them in the `OnAttached` method. This will make the app
    use less memory. It is also important to set back values to the value that they
    had before the `OnAppearing` method ran; otherwise, we might see some strange
    behavior, especially if the behavior is in a `ListView` that is reusing cells.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this app, we will create a `Behavior` for the `RepeaterView`. This is because
    we can''t set the state of an item in the `RepeaterView` from the code behind.
    We could have added the code to check whether the app runs in portrait or landscape
    in the `RepeaterView`, but if we use `Behavior` instead, we can separate that
    code from the `RepeaterView` so that it will be more reusable. Instead, we will
    add a `Property `string to the `RepeaterView`, which will set the state for the
    `RepeaterView` and all children in it. Let''s set this up by going through the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Weather` project, open the `RepeaterView.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `private string` field called `visualState`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `string` property called `VisualState`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a getter that uses an expression to return `visualState`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the setter, set the state of the `RepeaterView` and all children, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This will iterate through each `child` control and set the visual state. Now
    let''s create the behavior that will trigger state changes by following these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Weather` project, create a new folder called `Behaviors`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new class called `RepeaterViewBehavior`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `Behavior<RepeaterView>` as a base class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `private` field of the `RepeaterView` type called `view`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code should look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '`RepeaterViewBehavior` is a class that inherits from the `Behavior<RepeaterView>`
    base class. This will give us the ability to override some virtual methods that
    will be called when we attach and detach the behavior from a `RepeaterView`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But first, we need to create a method to handle the change in state by going
    through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Weather` project, open the `RepeaterViewBehavior.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `private` method called `UpdateState`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the code on the `MainThread` to check whether the app is running in portrait
    or landscape mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable called `page` and set its value to `Application.Current.MainPage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check whether the `Width` is larger than the `Height`. If this is true, set
    the `VisualState` property on the view variable to `Landscape`. If this is not
    true, set the `VisualState` property on the view variable to `Portrait`, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `UpdateState` method is now added. Now we need to override the `OnAttachedTo`
    method that will be called when the behavior is added to the `RepeaterView`. When
    it is, we want to update the state by calling this method and also hook up to
    the `SizeChanged` event of the `MainPage` so that when the size changes, we will
    update the state again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set this up by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Weather` project, open the `RepeaterViewBehavior.cs`file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override the `OnAttachedTo` method from the base class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `view` property to the parameter from the `OnAttachedTo` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an event listener to `Application.Current.MainPage.SizeChanged`. In the
    event listener, add a call to the `UpdateState` method, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'When we remove behaviors from a control, it''s very important to also remove
    any event handlers from it in order to avoid memory leaks, and in the worst case,
    a crash of the app. Let''s do this by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Weather` project, open the `RepeaterViewBehavior.cs`file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override `OnDetachingFrom` from the base class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the event listener from `Application.Current.MainPage.SizeChanged`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the `view` field to `null`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Follow the steps below to add the `behavior` to the view:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Weather` project, open the `MainView.xaml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `Weather.Behaviors` namespace, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we will do is add the `RepeaterViewBehavior` to the second `RepeaterView`,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now successfully created an app for three different operating systems—iOS,
    Android, and Windows—and three different form factors—phones, tablets, and desktop
    computers. To create a good user experience on all platforms and form factors,
    we used `FlexLayout` and `VisualStateManager`. We also learned a way of handling
    when we want to use different views for different form factors, as well as how
    to use `Behaviors`.
  prefs: []
  type: TYPE_NORMAL
- en: The next app we will build is a chat app with real-time communication. In the
    next chapter, we will take a look at how we can use the SignalR service in Azure
    as the backend for the chat app.
  prefs: []
  type: TYPE_NORMAL
