- en: Chapter 3. Snap – the Code Snippet Sharing Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will build our first fully functional, database-backed application.
    This application, codenamed Snap, will allow users to create an account with a
    username and password. Users will be allowed to login, logout, add and list the
    so-called semiprivate *snaps* of text that can be shared with others.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this chapter, you should be familiar with at least one of the following
    relational database systems: PostgreSQL, MySQL, or SQLite. Additionally, some
    knowledge of the SQLAlchemy Python library, which acts as an abstraction layer
    and object-relational mapper for these (and several other) databases, will be
    an asset. If you are not well versed in the usage of SQLAlchemy, fear not. We
    will have a gentle introduction to the library that will bring new developers
    up to speed and serve as a refresher for the more experienced.'
  prefs: []
  type: TYPE_NORMAL
- en: From this point on, in the book, the SQLite database will be our relational
    database of choice. The other database systems that we listed are all client/server-based
    with a multitude of configuration options that may need adjustment depending on
    the system they are installed in, while SQLite's default mode of operation is
    self-contained, serverless, and zero-configuration.
  prefs: []
  type: TYPE_NORMAL
- en: We suggest that you use SQLite to work with this project and the projects in
    the following chapters, but any major relational database supported by SQLAlchemy
    will do.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make sure we start things correctly, let''s create a folder where this project
    will exist and a virtual environment to encapsulate any dependencies that we will
    require:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will create a folder called `snap` at the given path and take us to this
    newly created folder. It will then create the snap virtual environment and install
    Flask in this environment.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that the `mkvirtualenv` tool will create the virtual environment, which
    will be the default set of locations to install the packages from `pip`, but the
    `mkvirtualenv` command does not create the project folder for you. This is why
    we will run a command to create the project folder first and then create the virtual
    environment. Virtual environments, by virtue of the `$PATH` manipulation that
    is performed after the environments are activated, are completely independent
    of the location of your project files in the file system.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will then create our basic blueprint-based project layout with an empty
    users blueprint. The contents of all the files are nearly the same as we described
    at the end of the previous chapter, and the layout should resemble the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Flask-SQLAlchemy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the above files and folders have been created, we need to install the
    next important set of dependencies: SQLAlchemy, and the Flask extension that makes
    interacting with this library a bit more Flask-like, Flask-SQLAlchemy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This will install the Flask extension to SQLAlchemy along with the base distribution
    of the latter and several other necessary dependencies in case they are not already
    present.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we were using a relational database system other than SQLite, this is
    the point where we would create the database entity in, say, PostgreSQL, along
    with the proper users and permissions so that our application can create tables
    and modify the contents of these tables. SQLite, however, does not require any
    of that. Instead, it assumes that any user that has access to the filesystem location
    of the database should also have permission to modify the contents of this database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later on in this chapter, we will see how the SQLite database file can be created
    automatically via SQLAlchemy. For the sake of completeness, however, here is how
    one would create an empty database in the current folder of your filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned previously, we will be using SQLite as the database for our example
    applications and the directions given will assume that SQLite is being used; the
    exact name of the binary may differ on your system. You can substitute the equivalent
    commands to create and administer the database of your choice if anything other
    than SQLite is being used.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can begin the basic configuration of the Flask-SQLAlchemy extension.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Flask-SQLAlchemy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we must register the Flask-SQLAlchemy extension with the `application`
    object in the `application/__init__.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of `app.config[''SQLALCHEMY_DATABASE_URI'']` is the escaped relative
    path to the `snap.db SQLite` database that we created previously. Once this simple
    configuration is in place, we will be able to create the SQLite database automatically
    via the `db.create_all()` method, which can be invoked in an interactive Python
    shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an idempotent operation, which means that nothing would change even
    if the database already exists. If the local database file did not exist, however,
    it would be created. This also applies to adding new data models: running `db.create_all()`
    will add their definitions to the database, ensuring that the relevant tables
    have been created and are accessible. It does not, however, take into account
    the modification of an existing model/table definition that already exists in
    the database. For this, you will need to use the relevant tools (for example,
    the sqlite CLI, or a migration tool such as Alembic, which we discuss in a later
    chapter) to modify the corresponding table definitions to match those that have
    been updated in your models.'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy basics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SQLAlchemy is, first and foremost, a toolkit to interact with the relational
    databases in Python.
  prefs: []
  type: TYPE_NORMAL
- en: While it provides an incredible number of features—including the SQL connection
    handling and pooling for various database engines, ability to handle custom datatypes,
    and a comprehensive SQL expression API—the one feature that most developers are
    familiar with is the Object Relational Mapper. This mapper allows a developer
    to connect a Python object definition to a SQL table in the database of their
    choice, thus enabling them with the flexibility to control the domain models in
    their own application and requiring only minimal coupling to the database product
    and the engine-specific SQLisms that each of them exposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'While debating the usefulness (or the lack thereof) of an object relational
    mapper is outside the scope of this chapter, for those who are unfamiliar with
    SQLAlchemy we will provide a list of benefits that using this tool brings to the
    table, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Your domain models are written to interface with one of the most well-respected,
    tested, and deployed Python packages ever created—SQLAlchemy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Onboarding new developers to a project becomes an order of magnitude easier
    due to the extensive documentation, tutorials, books, and articles that have been
    written about using SQLAlchemy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The validation of queries is accomplished using the SQLAlchemy expression language
    at module import time instead of executing each query string against the database
    to determine if there is a syntax error present. The expression language is in
    Python and can thus be validated with your usual set of tools and IDE.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thanks to the implementation of design patterns such as the Unit of Work, the
    Identity Map, and various lazy loading features, the developer can often be saved
    from performing more database/network roundtrips than necessary. Considering that
    the majority of a request/response cycle in a typical web application can easily
    be attributed to network latency of one type or another, minimizing the number
    of database queries in a typical response is a net performance win on many fronts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While many successful, performant applications can be built entirely on the
    ORM, SQLAlchemy does not force it upon you. If, for some reason, it is preferable
    to write raw SQL query strings or to use the SQLAlchemy expression language directly,
    then you can do that and still benefit from the connection pooling and the Python
    DBAPI abstraction functionality that is the core of SQLAlchemy itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we've given you several reasons why you should be using this database
    query and domain data abstraction layer, let's look at how we would go about defining
    a basic data model.
  prefs: []
  type: TYPE_NORMAL
- en: Declarative mapping and Flask-SQLAlchemy
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: SQLAlchemy implements a design pattern known as a **data mapper**. Fundamentally,
    the job of this data mapper is to bridge the definition and manipulation of a
    data model in code (in our case, Python class definitions) and the representation
    of this data model in a database. The mapper should know how code-related actions
    (for example, object construction, attribute modifications, and so on) relate
    to the SQL-specific statements in a database of our choice, ensuring that actions
    performed on our mapped Python objects are properly synchronized with the database
    table(s) they are linked to.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways in which we can integrate SQLAlchemy into our application:
    through the use of the declarative mapping that provides a consistent integration
    of tables, Python objects and the data mapper that glues them together, or by
    manually specifying these relations ourselves. Additionally, it is also possible
    to use the so-called SQLAlchemy "core", which eschews the data domain-centric
    approach for one based on the SQL expression language constructs that are included
    within SQLAlchemy.'
  prefs: []
  type: TYPE_NORMAL
- en: For the purposes of this (and future) chapters, we will be utilizing the declarative
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the declarative mapping functionality, we need to ensure that any model
    classes that we define will inherit from the declarative base `Model` class that
    Flask-SQLAlchemy makes available to us (once we have initialized the extension):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This `Model` class is, essentially, an instance of a `sqlalchemy.ext.declarative.declarative_base`
    class (with some additional defaults and useful functionalities), which provides
    the object with a metaclass that will handle the appropriate mapping constructs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have our model class definition in place, we will define the details
    about the related SQL table that will be mapped via the class-level attributes
    utilizing `Column` object instances. The first argument to a Column invocation
    is the type constraint that we want to impose on the attribute (which corresponds
    to a specific schema data type supported by the database), along with any optional
    arguments that the type supports, such as the size of the field. Additional arguments
    can be provided to indicate the constraints on the resulting table field definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As indicated previously, simply defining the attributes will not automatically
    translate into new tables and columns in our database. For this, we will need
    to call `db.create_all()` to initialize the table and column definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily create an instance of this model and assign some values to the
    attributes that we declared in our class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may have noticed that our user model does not define a `__init__` method,
    yet we are able to pass the `email` and `username` arguments to the object constructor
    when instantiating the above example. This is a feature of the SQLAlchemy declarative
    base class, which automatically assigns the named arguments at object construction
    time to their object attribute counterparts. As a result, defining a concrete
    constructor method for your data models is generally not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The instantiation of a model object does not imply that it has been persisted
    to the database. For that, we need to inform the SQLAlchemy session that we wish
    to add a new object to be tracked and have it committed to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the object has been committed, the `id` attribute will obtain the value
    of the primary key that the underlying database engine has assigned to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to modify the value of an attribute, for example, change the e-mail
    address of a particular user, we simply need to assign the new value and then
    commit the change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, you may have noticed that there has not been a single line of
    SQL written for any of the previous operations and might be getting a bit concerned
    that the information embedded in the objects that you''ve created is not being
    persisted to the database. A cursory inspection of the database should put your
    mind at ease:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that the exact name of the SQLite binary may differ on your operating
    system of choice. Additionally, if you chose a database engine other than SQLite
    to follow along with these examples, the relevant commands and results may be
    wildly different.
  prefs: []
  type: TYPE_NORMAL
- en: 'And there we have it: SQLAlchemy has successfully managed the relevant SQL
    INSERT and UPDATE statements behind the scenes, letting us work with native Python
    objects and signaling the session when we are ready to persist the data to the
    database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are not limited to defining class attributes, of course. In many instances
    it may prove useful to declare instance methods on our models so that we can perform
    more complex data manipulations. For example, imagine that we need to obtain the
    primary key ID of a given user and determine whether or not it is an even or odd
    integer. The method declaration would be just as you expect it to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The instance method call can be performed as usual with the caveat that before
    the object is committed to the session, the primary key value will be none:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the preceding implementation is trivial and somewhat meaningless
    in the context of most web applications. However, the ability to define model
    instance methods in order to encode business logic is quite convenient and we
    will see some of this with the Flask-Login extension later on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Snap data models
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we''ve explored the basics of the SQLAlchemy declarative base and
    the Flask-SQLAlchemy extension using a somewhat simplified model, our next step
    is to flesh out a user data model that is the cornerstone of almost any web application.
    We''ll create this model in the users blueprint in a new `users/models.py` module,
    and utilize the knowledge that we''ve gained regarding SQLAlchemy models to add
    the fields for a user `password` and a `created_on` field to store when the record
    was created. Additionally, we''ll define a few instance methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `is_authenticated`, `is_active`, `is_anonymous`, and `get_id` methods may
    seem arbitrary at the moment but are required for the next step, which will be
    installing and setting up the Flask-Login extension in order to help us manage
    our user authentication system.
  prefs: []
  type: TYPE_NORMAL
- en: Flask-Login and Flask-Bcrypt for authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we''ve done several times already with other libraries, we will install
    the extensions in our current project''s virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The first is a Flask-specific library to normalize much of the standard user
    login process that nearly every web application requires, and the latter will
    allow us to ensure that the user passwords we store in our database are hashed
    using an industry standard algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once installed, we need to instantiate and configure the extension in the usual
    manner. For this, we will add to the `application/__init__.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to function correctly, the Flask-Login extension must also know how
    to load a user from your database given only the ID of this user. We must decorate
    a function that will accomplish this, and we''ll insert it at the very end of
    the `application/__init__.py` module for the sake of simplicity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've set up the model and required methods/function so that Flask-Login
    can operate correctly, our next step will be to allow users to log in as they
    would on almost any web application using a form.
  prefs: []
  type: TYPE_NORMAL
- en: Flask-WTF – form validation and rendering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Flask-WTF ([https://flask-wtf.readthedocs.org/en/latest/](https://flask-wtf.readthedocs.org/en/latest/))
    extension wraps the WTForms library, an incredibly flexible tool for managing
    and validating forms, and makes it readily available for use in Flask applications.
    Let''s install this now and then we''ll define our first form to handle user logins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will define our first form in our `users/views.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here we defined `LoginForm`, a subclass of `Form`, with the class attributes
    of `username` and `password`. The values of these attributes are `StringField`
    and `PasswordField`, each with their own set of validators to indicate that the
    form data of both fields is required to be non-empty and the password field itself
    should be at least six characters long in order to be considered valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `LoginForm` class will be utilized in two different ways, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It will render the required form fields in our `login.html` template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will validate the POST'ed form data that we will require to complete a successful
    login from a user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To accomplish the first, we will need to define our HTML layout in `application/templates/layout.html`,
    using the Jinja2 templating language. Note the use of the `current_user` object
    proxy that is made available in all Jinja templates via the Flask-Login extension
    which allows us to determine whether the person who is browsing is already authenticated,
    and if so, then this person should be presented with a slightly different page
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our extremely basic layout, we need to create our `login.html`
    page at `application/users/templates/users/login.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The somewhat convoluted path of `application/users/templates/users/index.html`
    is required when using Blueprints due to the manner in which the default template
    loader searches the registered template paths; it allows for some relatively simple
    overriding of blueprint templates in your main application template folder at
    the cost of some additional file tree complexity.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will extend the basic application-level `layout.html` that
    we defined previously and insert the hidden form fields (required for the built-in
    CSRF protection that Flask-WTF offers), form labels, form inputs, and submit button.
    We will also display the inline errors returned to us by WTForms in the event
    that our submitted data does not pass our form validators for the fields in question.
  prefs: []
  type: TYPE_NORMAL
- en: '**Cross-Site Request Forgery** (**CSRF**) *is a type of attack that occurs
    when a malicious website, email, blog, instant message, or program causes a user''s
    web browser to perform an unwanted* *action on a trusted site in which the user
    is currently authenticated. OWASP definition of CSRF*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most common way of preventing a cross-site request forgery is to include
    a token with each HTML form that is sent to the user, which can then be validated
    against a matching token in the session of the authenticated user. If the token
    does not validate, then the form data is rejected, as there is a chance that the
    currently authenticated user did not willingly submit the form data in question.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have created the `login.html` template, we can next hook up a route
    view handler in `application/users/views.py` to process the login and form logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Hashing user passwords
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will update our user model in order to ensure that the passwords are encrypted
    by Flask-Bcrypt when the `password` field is updated. In order to accomplish this,
    we will use a feature of SQLAlchemy that is similar in spirit and functionality
    to the Python `@property` decorator (and the associated `property.setter` method),
    named hybrid attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Hybrid attributes are so named because they can provide distinctly different
    behaviors when invoked at the class level or instance level. The SQLAlchemy documentation
    is a great place to learn about the various roles that they can fulfill in your
    domain modeling.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will simply rename the password class-level attribute with `_password` so
    that our hybrid attribute methods do not conflict. Subsequently, we add the hybrid
    attribute methods which encapsulate the password hashing logic on attribute assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to the hybrid property approach, our requirements for password hashing
    on assignment could also be satisfied using a SQLAlchemy TypeDecorator, which
    allows us to augment the existing types (for example, a String column type) with
    additional behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to generate a user for testing purposes (and to verify that our password
    was hashed on instance construction/attribute assignment), let''s load the Python
    console and create a user instance ourselves using the model that we defined and
    the SQLAlchemy database connection that we created:'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember to initialize the database with `db.create_all()` if you `haven't already.`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Configure an application SECRET_KEY
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last little bit that we need is to define an application-wide `SECRET_KEY`
    that will be used by Flask-WTF to sign a token to be used for the prevention of
    CSRF attacks. We will add this key to the application configuration in `application/__init__.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course, you'll want to use your own unique secret key; the easiest way to
    accomplish this would be to use your system kernel's random number device via
    `/dev/urandom, available` for most Linux distributions. In python, you can use
    the `os.urandom` method to get a random string with *n* bytes of entropy.
  prefs: []
  type: TYPE_NORMAL
- en: Hook up the blueprint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we can run the application, we need to register our newly created users
    blueprint with the Flask application object. This necessitates a slight modification
    to `application/__init__.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Let's run this thing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we''ve put all the little pieces together, let''s run the application
    and make things happen. We will use a similar `run.py` file that we used in the
    previous chapter, which has been adapted to work with our application factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This file is placed as a sibling to the `application` folder and then invoked
    in the usual way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Visit `http://localhost:5000/users/login` and you should be presented with
    the `username` and `password` input fields that we created. If you attempt to
    input invalid fields (for example, a username that does not exist), the page will
    render with the relevant error message. If you attempt to log in with the user
    credentials that we created at the interactive prompt earlier, then you should
    be greeted with the text: `Success! You logged in`.'
  prefs: []
  type: TYPE_NORMAL
- en: The data model for snaps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we've created our bare bones user models, view functions, and hooked
    up our authentication system, let's create the model required to store our Snaps
    in a new blueprint, under `application/snaps/models.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't forget to create `application/snaps/__init__.py`, otherwise the folder
    will not be recognized as a package!
  prefs: []
  type: TYPE_NORMAL
- en: 'This model will be very similar to our User model but will contain additional
    information regarding the relationships between a user and their snaps. In SQLAlchemy,
    we will describe the relations between records in tables via the use of `ForeignKey`
    objects and the `relationship` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of this model should be relatively familiar; it is not that much different
    from the one we constructed previously for our User schema. For our snaps, we
    will require a few mandatory attributes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`user_id`: This is the ID of the user who has created the snap. As our current
    implementation will require a user to be authenticated in order to create a snap,
    all the resulting snaps will be tied to the user who posted them. This will also
    make it trivial to extend the system at a later time so as to include the user
    profiles, personal snap statistics, and ability to delete a snap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`created_on`: This is set in the constructor to be the current UTC timestamp
    and will be used to sort the snaps in descending order to display them in a list
    on our landing page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hash_key`: This attribute is also set in the constructor and is the cryptographic
    hash of the contents of the snap concatenated with the timestamp it was created
    on. This gives us a unique, secure ID that is not easily guessable that we can
    use in order to refer to the snap at a later time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even though the conditions that we described for the preceding `hash_key` do
    not guarantee that the value is unique, The uniqueness of the snap hash key is
    also enforced at the database level via a unique index constraint.
  prefs: []
  type: TYPE_NORMAL
- en: '`content`: This is the content of the snap itself—the meat and potatoes of
    the model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`extension`: This is the file extension of the snap, so that we can include
    simple syntax highlighting if we so desire.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: This is the name of the snap, which is not required to be unique.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`user`: This is a special attribute to declare that every snap instance is
    related to a user instance and will allow us to access the data of the user who
    has created a snap. The `backref` option also specifies that the reverse should
    be possible: that is, accessing all the snaps created by a user via the snaps
    attribute on a user instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Better defaults with content-sensitive default functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One improvement that can be made to the preceding model is the removal of the
    explicit `__init__` method. The only reason that it was defined initially was
    to ensure that the `hash_key` field could be constructed from the value of the
    content field. While in most instances the explicit object constructor that was
    defined would be good enough, SQLAlchemy provides us with the functionality that
    will allow us to set the default value of one field based on the contents of another.
    This is known as a **Context–Sensitive Default Function** and can be declared
    as such at the top of the `application/snaps/models.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this method exists, we can define the default argument of the `hash_key`
    column to be our `content_hash` content-sensitive default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Snap view handlers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Continuing on, we will now create the views and templates that are required
    to list and add snaps. To this end, we will instantiate a `Blueprint` object in
    our `application/snaps/views.py` and declare our route handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have wrapped our `add()` route handler with a `@login_required`
    decorator, which will prevent unauthenticated users from accessing this endpoint
    for all defined HTTP verbs (GET and POST, in this case) and return a 401.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Instead of having the server return an HTTP 401 Unauthorized, Flask-Login can
    be configured to redirect the unauthenticated user to the login page by setting
    the `login_manager.login_view` attribute to the `url_for` compatible location
    of the login page itself, which in our case would be `users.login`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create the WTForm object to represent a snap and place it in the
    `application/snaps/views.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While it is somewhat a matter of personal preference, the forms created with
    WTForms (or any other similar abstraction) could be placed alongside the models
    instead of the views. Or, to go a step further, if you have many different forms
    with complex data relationships, it may also be advisable to put all the declared
    forms in their own module in your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our snaps require a name, an extension, and the content of the snap itself,
    and we''ve encapsulated these basic requirements in the preceding Form declaration.
    Let''s implement our `add()` route handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Briefly, we will validate the submitted POST data in order to ensure that it
    satisfies the validators that we specified in the `SnapForm` class declaration
    and then proceed to instantiate a `Snap` object with the supplied form data and
    ID of the currently authenticated user. Once built, we will add this object to
    the current SQLAlchemy session and then attempt to commit it to the database.
    If a SQLAlchemy exception occurs (all SQLAlchemy exceptions inherit from `salalchemy.exc.SQLALchemyError`),
    we will log an exception to the default application log handler and set a flash
    message so that the user is alerted that something unexpected has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of completeness, we will include the extremely simple `application/snaps/templates/snaps/add.html`
    Jinja template here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve completed the `add()` handler and associated template, now it''s
    time to move on to the `listing()` handler, which will incidentally be the landing
    page for our application. The listing page will, somewhat unimaginatively, show
    a listing of the 20 most recent snaps which have been posted, in reverse chronological
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `application/snaps/templates/snaps/add.html` Jinja template renders the
    snaps that we''ve queried from the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we must ensure that the snaps blueprint that we''ve created is loaded
    in the application and prefixed to the root/URI path by adding it to the `application/__init__.py`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to test our new functionality, we''ll need to add the newly created
    snap model to our database. We can accomplish this by executing the `db.create_all()`
    function that we described earlier in the chapter. As we tend to run this command
    quite a lot, let''s put it in a script sibling to our main application package
    folder and name the file `database.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Once in place, we can simply execute the script with the Python interpreter
    in order to create the new snap model in our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that our database should be up to date with our model definitions, let''s
    ensure that the application runs as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming that there were no errors, you should be able to visit the URL that
    is displayed and log in with the credentials of one of the users that we created
    earlier in the chapter. You can, of course, create a new user via the interactive
    Python interpreter and then use these credentials so as to test the authentication
    functionality of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After having gone through this chapter and building the Snap application, we
    have seen several facets of how Flask may be augmented with the use of extensions,
    such as Flask-WTF (for web form creation and validation), Flask-SQLAlchemy (for
    simple integration with the SQLAlchemy database abstraction library), Flask-Bcrypt
    (for password hashing), and Flask-Login (to abstract much of the standard implementation
    requirements for a simple user login system). While Flask itself is relatively
    spartan, the ecology of extensions that are available make it such that building
    a fully fledged user-authenticated application may be done quickly and relatively
    painlessly.
  prefs: []
  type: TYPE_NORMAL
- en: We explored the aforementioned extensions and their usefulness, including Flask-WTF
    and Flask-SQLAlchemy, and architected a simple blueprint-based application that
    integrated all of the above components. While the Snap application itself is quite
    simple and leaves much to be implemented, it lends itself very easily to updates
    and additional features.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will build an application with a more complex data model
    and include some social features that are common among today's web apps. Moreover,
    it will be built and set up for unit and functional testing, something that no
    trivial application should go without.
  prefs: []
  type: TYPE_NORMAL
