- en: Chapter 9. Attack Automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automating tools enable us to explore and exploit more vulnerabilities than
    any manual method possibly could. In my opinion, nothing beats manual security
    testing combined with a set of automated sections performed by an experienced
    security specialist. Sophisticated scripts can split the attack between several
    hosts and avoid being blacklisted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: SFTP automations with paramiko
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nmap automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: W3af REST API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metasploit scripting with MSGRPC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OWASP zap API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breaking captcha
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing BeEF API with Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing Nessus 6 API with Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paramiko
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running commands in remote systems via SSH is one of the most common components
    of automation. The Python module paramiko makes this easy by providing a programmatic
    interface to SSH. Paramiko gives you an easy way to use SSH functions in Python
    through an imported library. This allows us to drive SSH tasks, which you would
    normally perform manually.
  prefs: []
  type: TYPE_NORMAL
- en: Establish SSH connection with paramiko
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main class of paramiko is `paramiko.SSHClient`, which provides a basic
    interface to initiate server connections:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Establish SSH connection with paramiko](img/1-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This will create a new SSHClient instance, and we then call the `connect()`
    method, which connects to the SSH server.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we connect to a remote machine with any SSH client, that remote host''s
    key will be automatically stored in the `.ssh/known_hosts` file in our home directory.
    So, the first time we connect to a remote system, we will get a message, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Establish SSH connection with paramiko](img/4323OS_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When you type `yes` for this message, it will add an entry in the `known_hosts`
    file. By accepting this message, a level of trust is added for that host. The
    same rule is applicable for paramiko. By default, the SSHClient instance will
    refuse to connect a host that does not have a key saved in our `known_hosts` file.
    This will create problems when creating automation scripts. We can set the host
    key policy to add missing host keys automatically with paramiko as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the script to connect to `ssh` with auto-add host keys will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Establish SSH connection with paramiko](img/2-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Running commands with paramiko
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are now connected to the remote host with paramiko. We can then run commands
    on the remote host using this connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The response data will be the tuple (`stdin`, `stdout`, `stderr`), and we could
    read the output and write to input. For example, if we are running a command which
    requires an input, we could use `stdin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: With this, we could create an interactive shell that could automate many tasks.
  prefs: []
  type: TYPE_NORMAL
- en: SFTP with paramiko
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can also use paramiko to handle file manipulations on a remote host with
    SFTP.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**SFTP** stands for **SSH File Transfer Protocol**, or **Secure File Transfer
    Protocol**. It is a separate protocol that works almost the same as FTP over a
    secure connection with SSH.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we first instantiate a new `paramiko.SSHClient` instance as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SFTP with paramiko](img/3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Then we use `open_sftp()` after connecting to the remote host, which will return
    a `paramiko.SFTPClient` client object. The `paramiko.SFTPClient` will support
    all the SFTP operations. Here, we listed the files in the root of the remote server.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `get()` method to download and the `put()` method to upload files
    with paramiko.
  prefs: []
  type: TYPE_NORMAL
- en: 'To download the remote password file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To upload a file to a remote host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: python-nmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Network Mapper** (**Nmap**) is a free and open-source tool used for network
    discovery and security auditing. It runs on all major computer operating systems,
    and official binary packages are available for Linux, Windows, and Mac OS X. The
    `python-nmap` library helps to programmatically manipulate scanned results of
    `nmap` to automate port scanning tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, we have to import the module `nmap` after installing `python-nmap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Instantiate the `nmap` port scanner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Set `host` and `port` range to scan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We could print the `command_line` command used for the scan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we could get the `nmap` scan information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we scan all the hosts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We also scan all protocols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This script will provide an output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![python-nmap](img/image_09_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You could get more options of `python-nmap` from here:  [https://bitbucket.org/xael/python-nmap](https://bitbucket.org/xael/python-nmap).
  prefs: []
  type: TYPE_NORMAL
- en: W3af REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Web Application audit and attack framework** (**W3af**) is a powerful and
    flexible environment for web vulnerability assessments and for exploiting web
    application vulnerabilities. It has many plugins that could communicate with each
    other. For instance, the discovery plugin collects different URLs to test and
    pass on to the audit plugin, which uses these URLs to search for vulnerabilities.
    W3af could also exploit the vulnerabilities that it finds.'
  prefs: []
  type: TYPE_NORMAL
- en: 'W3af has eight different types of plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Discovery plugins**: Crawl the web application to find new URLs, forms, and
    many other interesting parts of the web application. These plugins run in a loop,
    and the output is fed as the input to the next plugin.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Audit plugins**: These are the main parts of W3af, and they take the output
    of discovery plugins as input and scan for all types of web application vulnerabilities
    like SQL, XSS injections, and others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Grep plugins**: Like the UNIX grep utility, they search each and every HTTP
    request and response to find unusual and interesting information. It can be anything
    like IPs, Error codes, e-mail IDs, credit card numbers, or even risky JavaScript
    codes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bruteforce plugins**: These help to brute-force the basic HTTP authentications
    and form login authentications that are found during the discovery phase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attack plugins**: This plugin will read the vulnerability objects from the
    knowledge base and try to exploit them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mangle plugins**: These help to modify requests and responses based on regular
    expressions like sed editor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Evasion plugins**: These help to avoid simple **Intrusion Detection Rules**
    (**IDS**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Output plugins**: These help to create output files in different file formats
    as reports.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We could use the `w3af` API to connect to `w3af` and use these modules. First,
    we have to run the `w3af` API. To do this, get the `w3af` and run `w3af_api`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `w3af` API already has some configured profiles that can be used for particular
    tasks. For instance, the `OWASP_TOP10` profile includes several discovery, audit,
    and grep plugins to perform OWASP Top 10 security analysis. So, we could make
    use of those profile files, or we could create our own profiles to run the `w3af`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `w3af_api_client` to access `w3af_api` from scripts. Install `w3af_api_client`
    and import it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can create a connection to the `w3af` API. This will be running at port
    `5000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can make sure the connection is proper by checking its version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can define the profile file and the target URL to scan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we instantiate the scan instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can start the scan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'After starting the scan we could get the findings, URLs, and logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We could get the `fuzzable` URLs with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As W3af is a Python tool, we can import `w3af` as a module in our scripts and
    use its functionalities in our script. For that, we have to download `setup.py`
    for `w3af`. We can get the whole module's files from [https://github.com/andresriancho/w3af-module](https://github.com/andresriancho/w3af-module).
  prefs: []
  type: TYPE_NORMAL
- en: Download this module and verify that the sub-module folder `w3af` has all the
    files in it. If not, download the `w3af` folder from [https://github.com/andresriancho/w3af](https://github.com/andresriancho/w3af)
    and replace that folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This will install `w3af` as a Python module. Next, we can import it, as we
    do for other Python modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we could import other `w3af` modules such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Metasploit scripting with MSGRPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Metasploit** is an open-source project that provides public resources for
    developing, testing, and executing exploits. It can also be used to create security
    testing tools, exploit modules, and as a penetration testing framework.'
  prefs: []
  type: TYPE_NORMAL
- en: Metasploit is written in Ruby and it does not support modules or scripts written
    in Python.
  prefs: []
  type: TYPE_NORMAL
- en: However, Metasploit does have a MSGRPC, Bidirectional RPC (Remote Procedure
    Call) interface using MSGPACK. The `pymetasploit` Python module helps to interact
    between Python and Metasploit's `msgrpc`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So before scripting, we have to load `msfconsole` and start the `msgrpc` service.
    Next, let''s start Metasploit and the MSGRPC interface. We could start MSGRPC
    with `msfrpcd` in Metasploit. Here are the full options for `msfrpcd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Metasploit scripting with MSGRPC](img/image_09_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To start MSGRPC with the password `123456`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '![Metasploit scripting with MSGRPC](img/image_09_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that Metasploit's RPC interface is listening on port `55553`. We can proceed
    to write our Python script.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with MSGRPC is almost similar to interacting with `msfconsole`.
    First, we have to create an instance of the `msfrpc` class. Then, log in to the
    `msgrpc` server with the credentials, and create a virtual console.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the PyMetasploit Python module to automate the exploitation tasks
    with Python. Clone the module from [https://github.com/allfro/pymetasploit](https://github.com/allfro/pymetasploit):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Move to the following module folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can import the module in our scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can create a new instance for `MsfRpcClient`. We have to authenticate
    into the Metasploit to run any commands in it. So, pass the password to authenticate
    to Metasploit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can navigate through the core Metasploit functionalities with this instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This will list the core functionalities. Now we can list the auxiliary options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can list all the core modules of exploits, encoders, payloads,
    and post, using the same syntax. We can activate one of these modules with the
    use method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can set the parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, run the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If the execution was successful, then the output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: If this fails, the `job_id` will be none.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we can use the sessions method to access the shells and consoles if the
    attack was a success:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This will list all current active sessions. If the attack provides shell access
    to the victim, then we can get the available shells and access them with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also connect to the console and run the commands as we do in the `msfconsole`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Create console with the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use this instance to run Metasploit commands as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The output will print in the console itself.
  prefs: []
  type: TYPE_NORMAL
- en: Here we used the PyMetasploit module, but we can also use the msgrpc module
    ([https://github.com/SpiderLabs/msfrpc](https://github.com/SpiderLabs/msfrpc)).
    This will help us to get access to underlying functions and to handle the results
    and console output within the scripts.
  prefs: []
  type: TYPE_NORMAL
- en: ClamAV antivirus with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use pyClamd, an open-source Python module, to use the ClamAV antivirus
    engine on Linux, MacOSX, and Windows. To use ClamAV programmatically from Python,
    you have to run an instance of the `clamd` daemon.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can install ClamAV in Windows, Linux, and MacOSx. To install it in Windows
    and Linux, refer to the official ClamAV documentation at [http://www.clamav.net/documents/installing-clamav](http://www.clamav.net/documents/installing-clamav).
    To install in MacOSX, use homebrew.
  prefs: []
  type: TYPE_NORMAL
- en: After installing ClamAV, configure it to work with the network socket or Unix
    socket. To do this, we have to update the `clamd` configurations. You can find
    two configuration files in the `/etc/clamav/` folder for Linux, `c:\clamAV\` for
    Windows, and at `/usr/local/etc/clamav` for MacOSX. The files are as follows: `freshclam.conf` and
    `clamd.conf`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you cannot find these configuration files, create them from sample config
    files, and update the database mirror URL in the `freshclam.conf` file. Freshclam
    will fetch the antivirus database updates, so we should immediately run it in
    order to get the initial database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'After updating the database mirror, download the ClamAV database with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Enable the Unix socket or network socket in `clamd.conf`. To enable Unix socket,
    update `clamd.conf` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Now you can run the `clamd` daemon with `clamd` in a terminal window.
  prefs: []
  type: TYPE_NORMAL
- en: When installing `clamd` as a service in Windows, run the installer and let it
    install to the default location at `c:\clamav\`. Also, make sure you configure
    the Unix socket properly and that the location you specified in the `config` file
    exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then you can use `clamd` from the Python script. Import the `pyclamd` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, try to connect to the `clamd` daemon with Unix socket and if it fails,
    try to connect with the network socket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We can confirm the code by printing the `clamd` version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, scan the file or folder for viruses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This will output the details of virus signatures, if any are found.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can get the full pyclamd documentation here: [http://xael.org/pages/python-module-pyclamd.html](http://xael.org/pages/python-module-pyclamd.html).'
  prefs: []
  type: TYPE_NORMAL
- en: OWASP ZAP from Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**OWASP ZAP** (**Zed Attack Proxy**) is an open-source, cross-platform web
    application security scanner written in Java, and is available in all the popular
    operating systems: Windows, Linux, and Mac OS X.'
  prefs: []
  type: TYPE_NORMAL
- en: OWASP ZAP provides a REST API, which allows us to write a script to communicate
    with Zap programmatically. We can use the `python-owasp-zap` module to access
    this API. The `python-owasp-zap-v2.4` module can be installed with pip.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by loading the required modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the target to scan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can instantiate the `zap` instance, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This will instantiate a new instance with the assumption `zap` listens in the
    default port `8080`. If Zap listens a non-default port, then we have to pass the
    custom proxy settings as the parameters, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the target and start a session in `zap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'It would be better to wait for some time, so that the URL list gets updated
    in `zap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can start the spidering task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We can start a passive scan with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can use `pprint` to print the alerts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This gives us the alerts from `zap`.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking weak captcha
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **captcha** (**Completely Automated Public Turing test to tell Computers and
    Humans Apart**) is a type of challenge-response test to ensure that the response
    is generated by a human. It helps to prevent bots from sending spam, fraudulent
    registrations, fake sweepstakes entries, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Many sites implement their own captcha, and in such cases we can get the captcha
    image from the source. This can be a link that generates an image with a new random
    digit every time we access the URL. Hence, to bypass the captcha, we need to get
    the random number or word in that image.
  prefs: []
  type: TYPE_NORMAL
- en: We have already learnt how to send the post requests automatically with Python.
    Here we can learn to get the random code from the image. We can use the `pytesseract`
    Python moduleto read the image with an **optical character reader** (**OCR**)
    engine.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can read more on pytesseract here to install it on your system: [https://github.com/madmaze/pytesseract](https://github.com/madmaze/pytesseract).'
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, we can import the required modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Download the captcha image and save it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Read the image with the OCR engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print out the word in captcha. At times, it requires some image manipulations,
    according to the noise used in the captcha image. We can use `PIL` library features
    for this purpose. Here is an example for making the letters bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Then, use this output image to feed the OCR engine. After getting the word in
    the captcha image, we can post the form with the captcha value filled in.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For better accuracy, we can train the OCR engine. To read more on training the
    Tesseract: [https://github.com/tesseract-ocr/tesseract/wiki/TrainingTesseract](https://github.com/tesseract-ocr/tesseract/wiki/TrainingTesseract).
  prefs: []
  type: TYPE_NORMAL
- en: Automating BeEF with Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Browser Exploitation Framework** (**BeEF**) is a security tool that advantages
    browser vulnerabilities to assess the security issues of the target. BeEF is a
    framework which provides client-side attack vectors for the security testers.
    Also, it allows us to select specific modules for each browser and context. This
    section will discuss how to use the REST API that is available with the framework
    to automate the tasks and its features.'
  prefs: []
  type: TYPE_NORMAL
- en: BeEF focuses on the context of customers using a JavaScript hook. It create
    a botnet that can be controlled from a control panel. When a user navigates a
    website which contains a hook, that browser will automatically become part of
    that botnet. Then an attacker can send instructions to a hook to perform tasks
    on the hooked web browser of the victim. This will give access to the basic information
    about the web browser, enable or disable plugins and extensions, or can force
    navigation to another website. As it is a  simple JavaScript file running in the
    context of the web page visited by the victim, closing this website including
    the hook will disconnect the browser from the botnet and thus solve the problems.
  prefs: []
  type: TYPE_NORMAL
- en: Installing BeEF
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: BeEF is developed in Ruby. So, it requires Ruby interpreter installed on your
    system. Usually, it is a bit difficult to work with multiple tools like BeEF and
    Metasploit as both are developed in Ruby  and use different versions of Ruby.
    So, it would be better to use **Ruby Version Manager** (**RVM**) to manage multiple
    versions of Ruby on your system.
  prefs: []
  type: TYPE_NORMAL
- en: You can have a look at the official website of RVM  here [https://rvm.io](https://rvm.io).
  prefs: []
  type: TYPE_NORMAL
- en: It will help to make things easier and you'll save a lot of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install BeEF, download the latest version of the project from GitHub using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Then install the bundler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Then install the BeEF:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the BeEF  use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing BeEF](img/Capture.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To manage multiple victims from a web interface is inefficient and tedious.
    BeEF has a REST API that helps to automate many tasks. To access this API it requires
    an API key which is generated by BeEF when it starts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Installing BeEF](img/4323OS_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Connecting BeEF with Metasploit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'BeEF can be integrated with Metasploit and run exploits and payloads in hooked
    victim browsers. To use the Metasploit extension, we have to start the MSGRPC
    with the `msfrpcd` utility in the Metasploit framework as we done before. In addition
    to that, we have to enable the Metasploit extension available in the BeEF, to edit
    the master configuration file in the root of the BeEF folder (`config.yaml`) and
    enable Metasploit extensions in the `"extension"` section by changing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'To:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The main configuration file is ready to support the Metasploit extension and
    the MSGRPC service has started. Now, we have to update the extension settings
    to update connection details to the MSGRPC server. To do this, edit the configuration
    file of the Metasploit extension (`extensions/metasploit/config.xml`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting BeEF with Metasploit](img/4323OS_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we can start the BeEF. There will be an extra notification which indicates
    the number of  loaded Metasploit exploits if the connection is successful as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting BeEF with Metasploit](img/Capture-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Accessing BeEF API with Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Rest API of BeEF has almost everything required to automate activities that
    can be done from the Wed UI. This API is not very complicated as it is only required
    to send HTTP requests with the correct parameters. So, it is possible to use Python
    to automate these HTTP requests using different libraries.
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed in previous chapters, Python has many libraries for handling
    HTTP requests like  `urllib`, `urllib2`, `httplib`,  and `requests`. Here, we
    will use a simple library called BeEF-API written with the `requests` module.
  prefs: []
  type: TYPE_NORMAL
- en: We can download the BeEF-API Python library from GitHub [https://github.com/byt3bl33d3r/BeEF-API](https://github.com/byt3bl33d3r/BeEF-API).
    To install it you only need to run the `setup.py` script with the parameter `install`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can import the `BeefAPI` module and login to the BeEF-API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can list all the loaded modules with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We can search the modules for a specific string with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This will print all the modules with the string `firefox` in its name.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run a module against one or more hooked browsers, for that we have to
    obtain the corresponding browser object and then run the module on it by specifying
    the identifier of the module to be used against the browser. Each hooked browse
    object has a method called `run` which receives a numeric value that represents
    the identifier of a module as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The module with the identifier `231` is the *replace videos* module. This module
    will rewrite all the href attributes of all the matched links. The `run` method
    will execute the specified module and return a structure in the `.json` format
    with an identifier (`command_id`) of the command, which will be subsequently used
    to obtain the results returned by the module.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Nessus 6 API with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nessus is one of the popular vulnerability scanners developed by Tenable Network
    Security, which scans a computer and raises an alert if it discovers any vulnerabilities
    that an attacker could use to access any computer you have connected to a network.
    Nessus provides an API to access it programmatically. We can use any library to
    make HTTP requests, which abound in Python.  Tenable created a `python` library
    nessrest ([https://github.com/tenable/nessrest](https://github.com/tenable/nessrest))
    with the `requests`  module for using the Nessus 6  REST API.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this module in our Python script, import it as we did for other modules
    after installation. We can install the `nessrest` module with `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, import it in our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can initialize the scanner, as we are running Nessus with a self-signed
    certificate, we have to disable SSL certificate checking. For that, pass another
    parameter `insecure=True` to the `Scanner` initializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'To add and launch a scan, specify the target and run the scan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'We can get the scan results with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To know more about services that are available in Nessus 6, you can check the
    documentation included in the Nessus installation `https://localhost:8834/nessus6-api.html`.
    You have to start a Nessus instance to see this documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have gone through some of the libraries which can be used for security automation.
    Now we are ready to use these modules in our scripts. This will help us to automate
    many security tasks. We can also use the results from one script or tool to another,
    thus cascading the tools to automate pentesting.
  prefs: []
  type: TYPE_NORMAL
- en: This book brings insight into the basic usage of Python and its related modules,
    which helps the reader to attain profound knowledge in Penetration Testing. The
    chapters cover the fundamental ideas of performing security testing with Python,
    in a nutshell. The reader can attain unprecedented heights in security testing
    with the help of the techniques and resources presented in this book. The power
    of Python is yet to be harnessed in its entirety. Its outreach in security testing
    is broad, and we leave the reader at a crossroads, to explore this in more depth.
  prefs: []
  type: TYPE_NORMAL
