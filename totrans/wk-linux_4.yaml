- en: Chapter 4. CLI – The Hidden Recipe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will start by focusing on sed, one of the tools that can scare
    a lot of Linux users. We will look at some basic `sed` commands that could make
    hours of refractor turn into a few minutes. We will see how you can locate any
    file by using Linux puter. Furthermore, we will see just how remote work will
    get a whole lot better when Tmux enters our skill set. You can run long lasting
    commands, split screens, and never lose your work with the help of the best terminal
    multiplexor. Then, you will learn how to discover and interact with your network
    with the help of commands like netstat and nmap. Lastly, we will see how Autoenv
    helps switch environments automatically and how to use rm command to interact
    with trash from command line using the trash utility.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the working of sed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with tmux, a terminal multiplexer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatically switching environments using Autoenv
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using rm command line to remove (delete) files or directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sed – one-liner productivity treasure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If a picture is worth 1000 words, then sed one liners are definitely worth a
    thousand lines of code! One of the most feared commands in the Linux CLI is, you
    guessed it, sed! It's been feared by programmers and sysadmins everywhere, because
    of it's cryptic usage, but it can serve as a very powerful tool for quickly editing
    large amounts of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have created five files to help demonstrate the power of this awesome tool.
    The first one is a simple file containing the humble line of text: *Orange is
    the new black*. Let''s start by creating a simple `sed` command to replace the
    word *black* with *white*.'
  prefs: []
  type: TYPE_NORMAL
- en: The first argument of sed is the replace command. It's divided into 3 parts
    by 3 `/`. The first part is `s` for substitute, the second part is the word to
    be replaced, `black`, in our case, and the third part is the replacement word,
    `white`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second argument is the input, in our case, a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![Sed – one-liner productivity treasure](img/image_04_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, the result will be printed on the screen, and you can see the word black
    has been replaced by white.
  prefs: []
  type: TYPE_NORMAL
- en: Our second example contains yet another line of text, this time with the word
    black in both upper and lower case. If we run the same command using this new
    file, we will see that it replaces only the word that matches the case. If we
    want to do a case insensitive replace, we will add two more characters to the
    end of our `sed` command; `g` and `l`.
  prefs: []
  type: TYPE_NORMAL
- en: '`g`: It means global replace, used for replacing all the occurrences in the
    file. Without this, it will only replace the first argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`l`: means case insensitive search.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![Sed – one-liner productivity treasure](img/image_04_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: And as you can see, both words have been replaced. If we want to save the results
    in our file instead of printing to the screen, we use the `-i` argument, which
    stands for inline replace.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some scenarios, we might also want to save our initial files, just in case
    we have an error in the `sed` command. To do this, we specify a suffix after `-i`
    which will create a backup file. In our case, we use the `.bak` suffix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![Sed – one-liner productivity treasure](img/image_04_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we check the content of the files, we can see that the initial file contains
    the updated text, and the backup file contains the original text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at a more practical example. Let''s say we have a shell script
    that contains multiple variables and we want to surround our variables with curly
    brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sed – one-liner productivity treasure](img/image_04_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to do this we will write:'
  prefs: []
  type: TYPE_NORMAL
- en: '`s`: It''s for substitute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`g`: It''s for global; meaning replace all occurrences found.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\$`: This matches all strings starting with the dollar sign. Here dollar needs
    to be escaped, so that it''s not confused with the *start of the row* anchor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will enclose the string following `$` in (), so that we can reference it
    in the replace part of our command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[ ]`: This is for specifying a range of characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`A-Z`: It matches all uppercase characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0-9`: It matches all numbers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_`: It matches `_`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\+`: Any character in the `[ ]` must appear one or multiple times'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the replace part, we will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`\$`: The dollar sign'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{ }`: The curly brackets we want to add.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\1`: The string that was previously matched in the ( )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![Sed – one-liner productivity treasure](img/image_04_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Other common scenarios are replacing content in `xml` or `html` files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we have a basic html file with a `<strong>` text inside. Now, we know
    that the `<strong>` text has more semantic value for search engine optimizations,
    so maybe we want to make our strong tags be a simple `<b>` (bold), and manually
    decide the `<strong>` words in the page. For this we say:'
  prefs: []
  type: TYPE_NORMAL
- en: '`s`: This is for substitute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<strong`: The actual text we are searching for.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\( \)`: This will be used again for selecting a piece of text, that will be
    added back.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.*`: This means any character, found any number of times. We want to select
    everything between "`<strong`" and "`strong>`".'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`</`: This is the closing of the tag. This, we want to keep intact.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<b\1b>`: Just add `<b b>`, and the text that you previously found in the `(
    )`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![Sed – one-liner productivity treasure](img/image_04_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the text was updated correctly, the `red` class still applies
    to the new tag, and the old text is still contained between our tags, which is
    exactly what we wanted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sed – one-liner productivity treasure](img/image_04_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Besides replacing, sed can also be used for deleting lines of text. Our `5.txt`
    file contains all the words from the `lorem ipsum` text. If we wanted to delete
    the third line of text, we would issue the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Hit *:e,* to reload the file in vim, and we see the word `dolor` is no longer
    there. If, for example, we wanted to delete the first 10 lines of the file, we''d
    simply run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Hit *:e*, and you see the lines are no longer there. For our last example,
    if we scroll down, we can see multiple empty lines of text. These can be deleted
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![Sed – one-liner productivity treasure](img/image_04_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Which stands for:'
  prefs: []
  type: TYPE_NORMAL
- en: '`^`: Beginning of line anchor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$`: End of line anchor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d`: Delete'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reload the file, and you see that the lines are no longer there.
  prefs: []
  type: TYPE_NORMAL
- en: Now, as you can imagine, these have only been some basic examples. The power
    of sed is much greater than this, and there are many more possibilities of using
    it than what we have seen today. We recommend that you gain a good understanding
    of the features presented here today, as these are the features you will probably
    use the most. It's not as complicated as it might seem at first, and it really
    comes in handy in lots of scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: You can run, but you can't hide… from find
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tens of projects, hundreds of folders and thousands of file; does this scenario
    sound familiar? If the answer is *yes*, then you probably found yourself more
    than once in a situation where you couldn''t find a specific file. The `find`
    command will help us locate any file in our project and much more. But first,
    for creating a quick playground, let''s download the electron open source project
    from GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: Git clone [https://github.com/electron/electron](https://github.com/electron/electron)
  prefs: []
  type: TYPE_NORMAL
- en: 'And `cd` into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We see here lots of different files and folders, just like in any normal sized
    software project. In order to find a particular file, let''s say `package.json`,
    we will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![You can run, but you can''t hide… from find](img/image_04_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`.`: This starts the search in the current folder'
  prefs: []
  type: TYPE_NORMAL
- en: '`-name`: This helps to search the file name'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to look for all readme files in the project, the previous command
    format is not helpful. We need to issue a case insensitive find. For demonstration
    purposes, we will also create a `readme.md` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also use the `-iname` argument for case insensitive search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![You can run, but you can''t hide… from find](img/image_04_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You see here that both `readme.md` and `README.md` have been found. Now, if
    we were to search for all JavaScript files we would use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![You can run, but you can''t hide… from find](img/image_04_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And as you can see, there are quite a few results. For narrowing down our results,
    let''s limit the find to the `default_app` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![You can run, but you can''t hide… from find](img/image_04_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, there are only two `js` files in this folder. And if we were
    to find all files that are not JavaScript, just add a `!` mark before the name
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![You can run, but you can''t hide… from find](img/image_04_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see here all files that don''t end their name with `js`. If we were
    to look for all inodes in the directory, which are of type file, we would use
    the `-type f` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![You can run, but you can''t hide… from find](img/image_04_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the same way, we''d use `-type d` to find all directories in a specific
    location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![You can run, but you can''t hide… from find](img/image_04_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Find can also locate files based on time identifiers. For example, in order
    to find all files in the `/usr/share` directory that were modified in the last
    24 hours, issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![You can run, but you can''t hide… from find](img/image_04_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: I have quite a big list. You can see the `-mtime -3` broadens the list even
    more.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to find, for example, all the files modified in the last hour, we
    can use `-mmin -60`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![You can run, but you can''t hide… from find](img/image_04_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A good folder to search is `~/.local/share`, If we use `-mmin -90`, the list
    broadens again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Find can also show us the list of files accessed in the last 24 hours by using
    the `-atime -1` argument like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '![You can run, but you can''t hide… from find](img/image_04_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'While working with lots of project files, if sometimes the case in some projects
    remain empty, and we forget to delete them. In order to locate all empty files
    just do a:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![You can run, but you can''t hide… from find](img/image_04_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, electron has a few empty files. Find will also show us empty
    directories, or links.
  prefs: []
  type: TYPE_NORMAL
- en: 'Removing empty files will keep our project clean, but when it comes to reducing
    size, we sometimes want to know which files are taking up most of the space. Find
    can also do searches based on file size. For example, let''s find all the files
    larger than `1` mega:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: use -1M for smaller.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we said in the beginning, find can do much more than locating files in your
    project. Using the `-exec` argument, it can be combined with almost any other
    command, which gives it almost infinite capabilities. For example, if we want
    to find all `javascript` files that contain the text `manager`, we can combine
    find with `grep`, command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![You can run, but you can''t hide… from find](img/image_04_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This will execute the grep command on all the files returned by find. Let's
    also search inside the file using vim, so that we verify the result is correct.
    As you can see, the text "manager" appears in this file. You don't have to worry
    about `{} \;`, it's just standard -exec syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on with the practical examples, let''s say you have a folder where you
    want to remove all the files modified in the last 100 days. We can see our `default_app`
    folder contains such files. If we combine find with `rm` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can do a quick cleanup. Find can be used for smart backups. For example,
    if we were to backup all `json` files in the project we would combine find with
    the `cpio` backup utility using a pipe and a standard output redirection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![You can run, but you can''t hide… from find](img/image_04_021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can see that this command has created a `backup.cpio` file, of type `cpio`
    archive.
  prefs: []
  type: TYPE_NORMAL
- en: Now this could probably have been written with `-exec` also, but it's critical
    you understand that pipes can also be used in this type of scenario, together
    with redirects.
  prefs: []
  type: TYPE_NORMAL
- en: 'When doing reports, you may have to count the number of lines written:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, we combine find with `wc -l`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us all `js` files and the number of lines. We can pipe this
    to cut:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To only output the number of lines, and then pipe to the paste command, we
    do this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The above will merge all our lines with the `+` sign as a delimiter. This,
    of course, can translate to an arithmetic operation, which we can calculate using
    the binary calculator (`bc`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![You can run, but you can''t hide… from find](img/image_04_022.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This last command will tell us how many lines our `javascript` files contain.
    Of course, these are not actual lines of code, as they can be empty lines or comments.
    For a precise calculation of lines of code, you can use the `sloc` utility.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to mass rename files, like changing the file extension name to `node`
    for all `js` files we can use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the rename syntax is quite similar to sed. In addition, there are
    no more `.js` files left, as all have been renamed to `.node`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![You can run, but you can''t hide… from find](img/image_04_023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Some software projects require all source code files to have a copyright header.
    As this is not required in the beginning, often times we can find ourselves in
    the situation that we have to add copyright information at the beginning of all
    our files.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, we can combine find with sed like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: What this is basically doing is telling the computer to find all `.node` files,
    and add the copyright notice in the beginning of each file, followed by a new
    line.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check one random file and, yes, the copyright notice is there:'
  prefs: []
  type: TYPE_NORMAL
- en: '![You can run, but you can''t hide… from find](img/image_04_024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Update version numbers in all files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you can imagine, find has lots of use cases. The examples I've shown you
    are only the first piece of the pie. Learning find, along with `sed` and the `git
    cli` can set you free from your IDE when it comes to finding, refactoring or working
    with `git`, which means you can more easily switch from one IDE to the other,
    because you don't have to learn all the features. You just use your friendly CLI
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: tmux – virtual consoles, background jobs and the like
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will be looking at another great tool called tmux. Tmux
    comes in particularly handy when working in remote `ssh` sessions, because it
    gives you the ability to continue your work from where you left off. It can also
    replace some of the features in terminator, if you are working, for example, on
    Mac, and you can't install terminator.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with `tmux` on Ubuntu, we first need to install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '![tmux – virtual consoles, background jobs and the like](img/image_04_025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then just run the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '![tmux – virtual consoles, background jobs and the like](img/image_04_026.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And you will find yourself inside a brand new virtual console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![tmux – virtual consoles, background jobs and the like](img/image_04_027.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For demonstration purposes, we will open up a new tab that you can see the
    list of open sessions with `tmux ls`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![tmux – virtual consoles, background jobs and the like](img/image_04_028.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s start a new `tmux` named session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '![tmux – virtual consoles, background jobs and the like](img/image_04_029.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we can see that opening a `tmux` session maintains the current directory.
    To list and switch `tmux` sessions inside `tmux`, hit *Ctrl* + *B* *S*.
  prefs: []
  type: TYPE_NORMAL
- en: We can see that we can switch to another tmux session, execute commands inside,
    and switch back to our initial session if we want to. To detach (leave a session
    running and go back to the normal terminal) hit *Ctrl* + *b d*;
  prefs: []
  type: TYPE_NORMAL
- en: Now we can see we have two opened sessions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To attach to a session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '![tmux – virtual consoles, background jobs and the like](img/image_04_030.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This scenario comes in handy when you login to a remote server and want to execute
    a long running task, then leave and come back when it ends. We will replicate
    this scenario with a quick script called infinity.sh. We will execute it. It's
    writing to the standard output. Now let's detach from tmux.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the script, it's just a simple while loop that goes on forever,
    printing text each second.
  prefs: []
  type: TYPE_NORMAL
- en: Now when we come back to our session, we can see the script was running while
    we were detached from the session and it's still outputting data to the console.
    I will manually stop it by hitting *Ctrl* + *c*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alright, let''s go to our first tmux session and close it. In order to manually
    kill a running tmux session, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '![tmux – virtual consoles, background jobs and the like](img/image_04_031.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This will kill the running session. If we switch over to our second tab, we
    can see that we have been logged off tmux. Let''s also close this terminator tab,
    and open a brand new tmux session:'
  prefs: []
  type: TYPE_NORMAL
- en: '![tmux – virtual consoles, background jobs and the like](img/image_04_032.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Tmux gives you the possibility to split the screen, just like terminator, horizontally
    with *Ctrl* + *b* + ", and vertically with *Ctrl* + *b* + *%*. After that, use
    *Ctrl* + *b* + arrows to navigate between the panes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![tmux – virtual consoles, background jobs and the like](img/image_04_033.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You also have the possibility to create windows (tabs):'
  prefs: []
  type: TYPE_NORMAL
- en: '*Ctrl* + *b c*: create:![tmux – virtual consoles, background jobs and the like](img/image_04_034.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ctrl* + *b w*: list:![tmux – virtual consoles, background jobs and the like](img/image_04_035.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ctrl* + *b &*: delete![tmux – virtual consoles, background jobs and the like](img/image_04_036.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These last functionalities are very similar to what terminator offers.
  prefs: []
  type: TYPE_NORMAL
- en: You can use tmux in situations where you want to have two or more panes or even
    tabs in your remote `ssh` connection, but you don't want to open multiple `ssh`
    sessions. You could also use it locally, as a terminator replacement, but the
    keyboard shortcuts are much harder to use. Although they can be changed, you will
    lose the option to use tmux remotely, because opening a tmux session in another
    tmux session is discouraged. In addition, configuring new tmux keyboard shortcuts
    might make tmux a burden when working on lots of servers due to the shortcut differences.
  prefs: []
  type: TYPE_NORMAL
- en: Network – Who's listening?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with network applications, it comes in handy to be able to see
    open ports and connections and to be able to interact with ports on different
    hosts for testing purposes. In this section, we will be looking at some basic
    commands for networking and in what situations they might come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first command is `netstat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '![Network – Who''s listening?](img/image_04_037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This will show all open ports on our host. You can see here that we only have
    one open port on a default Ubuntu desktop installation, which is port `53`. We
    can look this up in the special file `/etc/services`. This file contains all basic
    port numbers for programs and protocols. We see here port `53` is the DNS server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Network – Who''s listening?](img/image_04_038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Just by analyzing the output, we cannot determine which program is listening
    on this port, because this process is not owned by our current user. That''s why
    the *PID/Program Name* column is empty. If we run the same command again with
    `sudo`, we see that this process is named `dnsmasq` and, if we want more information,
    we can look it up in the man page. It''s a lightweight DHCP and caching DNS server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Network – Who''s listening?](img/image_04_039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Other useful information we get from this command:'
  prefs: []
  type: TYPE_NORMAL
- en: The program protocol, in this case dhcp.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Total bytes not copied.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Total bytes not acknowledged.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local and foreign address and port. Getting the port is the main reason we are
    using this command. This is also important for determining if the port is open
    just on localhost or if it's listening for incoming connections on the network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The state of the port. Usually this is **LISTEN**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The PID and program name, which helps us identify which program is listening
    on what port.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, if we run a program that is supposed to be listening on a certain port
    and we don''t know if it''s working, we can find out with `netstat`. Let''s open
    the most basic HTTP server by running the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '![Network – Who''s listening?](img/image_04_040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the output, it's listening on port `8000` on interface `0.0.0.0`.
    If we open a new pane and run the `netstat` command, we will see the open the
    port, and the PID / name.
  prefs: []
  type: TYPE_NORMAL
- en: 'You probably already know this but, just to be on the safe side, we will look
    at adding different hostnames as static `dns` entries on our machine. This is
    helpful when developing applications that need to connect to servers and the servers
    change their IP address, or when you want to emulate a remote server on a local
    machine. For this we type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '![Network – Who''s listening?](img/image_04_041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can quickly understand the format of the file from the existing content.
    Let''s add an alias for our localhost, so that we can access it under a different
    name. Add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We recommend using non existing top level domain names for localhost, such as
    .local or .dev. This is to avoid overriding any existing address, because `/etc/hosts`
    takes precedence in `dns` resolution. Now, if we open the address in the browser
    on port `8000`, we will see our local Python server running and serving content.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next command is `nmap`. As you can see, it is not installed by default
    on Ubuntu, so let''s go ahead and install it by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '![Network – Who''s listening?](img/image_04_042.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Nmap is a command used for checking all open ports on a remote host, also known
    as a port scanner. If we run `nmap` on our network gateway, which, in our case,
    is `192.68.0.1`, we''ll get all of the open ports on the gateway:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type: **nmap 192.168.0.1**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Network – Who''s listening?](img/image_04_043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, there is again the `dns` port open, the http and https servers,
    which are used as a web page for configuring the router, and port `49152`, which,
    at this time, is not specific to any common protocol-and that's why it is marked
    as unknown. Nmap does not know for sure that those specific programs are actually
    running on the host; all it does is verify what ports are open and write the default
    application that usually runs on that port.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we are not sure what server we need to, connect to or if we want to know
    how many servers are in our current network, we can run `nmap` on the local network
    address, specifying the network mask as the destination network. We get this information
    from `ifconfig`; if our IP address is `192.168.0.159`, and our network mask is
    `255.255.255.0`, that means the command will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '![Network – Who''s listening?](img/image_04_044.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In `/24 = 255.255.255.0`, basically the network will have `ips` ranging from
    `192.168.0.0` to `192.168.0.255`. We see here that we have three active hosts,
    and it even gives us the latency, so we can determine which host is closer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nmap is helpful when developing client-server applications, for example, when
    you want to see what ports are accessible on the server. However, `nmap` might
    miss application-specific ports, which are non-standard. To actually connect to
    a given port, we will be using telnet, which comes preinstalled on Ubuntu desktop.
    To see if a particular port accepts connections, just type the hostname, followed
    by the port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '![Network – Who''s listening?](img/image_04_045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If the port is listening and accepts connections, telnet will output a message
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Trying `192.168.0.1`...
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connected to `192.168.0.1`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Escape character is `^]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This means that you can also connect from your application. So if you are having
    difficulties connecting, it's usually a client problem; the server is working
    fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get out of telnet, hit: *Ctrl* +*]*, followed by *Ctrl* + *d*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, in some cases we need to get the ip address of a particular hostname.
    The simplest way to do this is to use the host command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '![Network – Who''s listening?](img/image_04_046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ve learned only the basics, the minimum elements you need, in order to
    start working with hostnames and ports. For a deeper understanding of networks
    and package traffic, we recommend checking out courses on penetration testing
    or network traffic analyzing tools such as Wireshark. Here''s one such course:
    [https://www.packtpub.com/networking-and-servers/mastering-wireshark"](https://www.packtpub.com/networking-and-servers/mastering-wireshark)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Autoenv – Set a lasting, project-based habitat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Projects are different from one another and so are environments. We might be
    developing an application on our local machine with certain environment variables
    like debug level, API keys, or memory size. Then we want to deploy the application
    to a staging or production server, which has other values for the same environment
    variables. A tool that comes in handy for loading environments on the fly is `autoenv`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install it we go to the official GitHub page and follow the instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/kennethreitz/autoenv](https://github.com/kennethreitz/autoenv)'
  prefs: []
  type: TYPE_NORMAL
- en: 'First we will clone the project in our home directory, and then we add the
    following line to our .zshrc config file, so that every time zsh starts, autoenv
    is loaded by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Now let's create an example workplace with two imaginary projects, project 1
    and project 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'We open an environment file for project 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now imagine that project 1 uses an environment variable called `ENV`,
    which we will set to `dev`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '![Autoenv – Set a lasting, project-based habitat](img/image_04_047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s do the same thing for project 2, but with a different value for
    `ENV`; `qa`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '![Autoenv – Set a lasting, project-based habitat](img/image_04_048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Save and close both files. Now when we cd in the project 1 folder, we see the
    following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Hit *y* to load the file. This happens every time a new environment file is
    sourced. Now if we grep the environment for the ENV variable, we can see it present
    and with a value of `dev`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Autoenv – Set a lasting, project-based habitat](img/image_04_049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s change the directory to `project 2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Autoenv – Set a lasting, project-based habitat](img/image_04_050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the same warning message is issued. And when we grep for the
    ENV variable, we now see that its value is `qa`. If we leave this folder, the
    environment variable is still defined, and will be defined until some other script
    overrides it or when the current session is closed. The `.env` file is sourced,
    even if we cd to a directory deeper inside project1.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look at a more complex example for project1.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say we want to get the version from `package.json`, and we also want to
    use a variable called COMPOSE_FILE that will specify a different file for docker
    compose. Docker users know what it's all about, but if you don't.. Google time!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'For this to take effect, we need to first copy a `package.json` file, and test
    that the `cat` command works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Autoenv – Set a lasting, project-based habitat](img/image_04_051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Everything seems fine, so let''s `cd` into our folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Autoenv – Set a lasting, project-based habitat](img/image_04_052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And as you can see, the environment variables have been set:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Autoenv – Set a lasting, project-based habitat](img/image_04_053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`Autoenv` can really come in handy, and is not limited to just exporting environment
    variables. You can do stuff like issuing a reminder when entering a certain project
    or running a `git pull` or updating the look and feel of the terminal so that
    a distinct feel is given for each project.'
  prefs: []
  type: TYPE_NORMAL
- en: Don't rm the trash
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Commands can be categorized as harmless or harmful. Most commands fall within
    the first category, but there is one that is very common and that has been known
    to produce a lot of damage in the world of computers. The dreaded command is `rm`,
    which has wiped out numerous hard drives, making precious volumes of data inaccessible.
    The Linux desktop has borrowed the concept of trash from other desktops and the
    default action when deleting a file is sending it to the `Trash`. Sending files
    there is a good practice, so that no unintentional removing is done. But this
    trash is no magic location; it's just a hidden folder, usually located in `~/.local`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this part, we will be looking at a utility tool designed to work with trash.
    We will install it with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '![Don''t rm the trash](img/image_04_054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This will install multiple commands. Let's look at our current directory that
    contains quite a few files. Let's assume we don't need the files starting with
    file.`*`
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to remove files we will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '![Don''t rm the trash](img/image_04_055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '(There is a separate command for working with the trash. We will rehash to
    reload our path.) We list all the trash commands. The command for listing the
    trash content is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '![Don''t rm the trash](img/image_04_056.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we see the files that are in our trash. It is only showing the files that
    were put there with the trash command. We can see the date when they were deleted,
    the hour, and the exact location. If we'd have had multiple files with the same
    name and path, they would have been listed here, and we could have identified
    them by the deletion date.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to restore a file from trash we will use the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '![Don''t rm the trash](img/image_04_057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It will show us a list of options and ask for a number corresponding to the
    file we want restored. In this case we will select 1, meaning we want to restore
    the `json` file.
  prefs: []
  type: TYPE_NORMAL
- en: We open the file and we can see that the content was not altered in the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to remove all the files in the trash, we use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '![Don''t rm the trash](img/image_04_058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is the equivalent of doing `rm` in the first place. Now if we list the
    trash again, we see it doesn't have any content.
  prefs: []
  type: TYPE_NORMAL
- en: Although the internet is full of `rm -rf /` jokes, this is actually a serious
    issue that can cause headaches and wasted time trying to restore the damage caused.
    If you've been using `rm` for a long time and can't get into the habit of using
    trash, we suggest adding an alias for `rm` to actually run the trash command instead.
    In this case, it's a good idea to pile up stacks of files in trash than to risk
    removing a file that might be needed, before committing, or even removing the
    whole root partition!
  prefs: []
  type: TYPE_NORMAL
