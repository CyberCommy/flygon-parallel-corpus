- en: Node Fundamentals – Part 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll continue our discussion on some more node fundamentals.
    We'll explore yargs, and we'll see how to parse command-line arguments using `process.argv`
    and yargs. After that, we'll explore JSON. JSON is nothing more than a string
    that looks kind of like a JavaScript object, with the notable differences being
    that it uses double quotes instead of single quotes and all of your property names—like
    `name` and `age`, in this case—require quotes around them. We'll look into how
    to convert an object into a string, then define that string, use it, and convert
    it back to an object.
  prefs: []
  type: TYPE_NORMAL
- en: After we've done that, we'll fill out the `addNote` function. Finally, we'll
    look into refactor, moving the functionality into individual functions and testing
    the functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'More specifically, we''ll go through following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: yargs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding note
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: yargs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will use yargs, a third-party npm module, to make the process
    of parsing much easier. It will let us access things such as title and body information
    without needing to write a manual parser. This is a great example of when you
    should look for an npm module. If we don't use a module, it would be more productive
    for our Node application to use a third-party module that has been tested and
    thoroughly vetted.
  prefs: []
  type: TYPE_NORMAL
- en: To get started, we'll install the module, then we'll add it into the project,
    parsing for things such as a title of the body, and we'll call all the functions
    that will get defined over in `notes.js`. If the command is `add`, we'll call
    `add note`, so on.
  prefs: []
  type: TYPE_NORMAL
- en: Installing yargs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s view the documents page for yargs. It''s always a good idea to
    know what you''re getting yourself into. If you search for `yargs` on Google,
    you should find the GitHub page as your first search result. As shown in the following
    screenshot, we have the GitHub page for the yargs library:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af292fc6-2252-400f-b807-37dc2f91b054.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, yargs is a very complex library. It has a ton of features for validating
    all sorts of input, and it has different ways in which you can format that input.
    We will start with a very basic example, although we will be introducing more
    complex examples throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to look at any other features that we don't discuss in the chapter,
    or you just want to see how something works that we have talked about, you can
    always find it in the [yarg documents](http://yargs.js.org/docs/).
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll now move into Terminal to install this module inside of our application.
    To do this, we''ll use `npm install` followed by the module name, `yargs`, and
    in this case, I''ll use the `@` sign to specify the specific version of the module
    I want to use, 11.0.0, which is the most recent version at the time of writing.
    Next, I''ll add the `save` flag, which, as we know, updates the `package.json`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If I leave off the `save` flag, yargs will get installed into the `node_modules`
    folder, but if we wipe that `node_modules` folder later and run `npm install`,
    yargs won't get reinstalled because it's not listed in the `package.json` file.
    This is why we use the `save` flag.
  prefs: []
  type: TYPE_NORMAL
- en: Running yargs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve installed yargs, we can move over into Atom, inside of `app.js`,
    and get started with using it. The basics of yargs, the very core of its feature
    set, is really simple to take advantage of. The first thing we''ll do is to `require`
    it up, as we did with `fs` and `lodash` in the previous chapter. Let''s make a
    constant and call it `yargs`, setting it equal to `require(''yargs'')`, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'From here, we can fetch the arguments as yargs parses them. It will take the
    same `process.argv` array that we discussed in the previous chapter, but it goes
    behind the scenes and parses it, giving us something that''s much more useful
    than what Node gives us. Just above the `command` variable, we can make a `const`
    variable called `argv`, setting it equal to `yargs.argv`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `yargs.argv` module is where the yargs library stores its version of the
    arguments that your app ran with. Now we can print it using `console.log`, and
    this will let us take a look at the `process.argv` and `yargs.argv` variables;
    we can also compare them and see how yargs differs. For the command where we use
    `console.log` to print `process.argv`, I''ll make the first argument a string
    called `Process` so that we can differentiate it in Terminal. We''ll call `console.log`
    again. The first argument will be the `Yargs` string, and the second one will
    be the actual `argv` variable, which comes from yargs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now we can run our app (refer to the preceding code block) a few different ways
    and see how these two `console.log` statements differ.
  prefs: []
  type: TYPE_NORMAL
- en: 'First up, we''ll run at `node app.js` with the `add` command, and we can run
    this very basic example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We already know what the `process.argv` array looks like from the previous
    chapter. The useful information is the third string inside of the array, which
    is ''add''. In the fourth string, Yargs gives us an object that looks very different:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df9afaf0-8b6c-4e8c-9725-21912fffd11a.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding code output, first we have the underscore property,
    then commands such as add are stored.
  prefs: []
  type: TYPE_NORMAL
- en: 'If I were to add another command, say `add`, and then I were to add a modifier,
    say `encrypted`, you would see that add would be the first argument and encrypted
    the second, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/374665b4-ede6-49f6-951c-ba21dba9f234.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So far, yargs really isn''t shining. This isn''t much more useful than what
    we have in the previous example. Where it really shines is when we start passing
    in key-value pairs, such as the title example we used in the *Getting input* section
    of *Node Fundamentals - Part 1* in [chapter 2](9e56dc82-3ad8-4376-81b7-27ba482bd4e2.xhtml).
    I can set my `title` flag equal to `secrets`, press *enter*, and this time around,
    we get something much more useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code output, we have the third string that we would need to
    parse in order to fetch the value and the key, and in the fourth string, we actually
    have a title property with a value of secrets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/919e2194-261b-4da5-990e-302f7d5c7ae5.png)'
  prefs: []
  type: TYPE_IMG
- en: Also, yargs has built-in parsing for all the different ways you could specify
    this.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can insert a space after `title`, and it will still work just as it did
    before; we can add quotes around `secrets`, or add other words, like `secrets
    from Andrew`, and it will still parses it correctly, setting the `title` property
    to the `secrets from Andrew` string, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/9fa340c3-87f8-47db-a5f7-208d1c145319.png)'
  prefs: []
  type: TYPE_IMG
- en: This is where yargs really shines! It makes the process of parsing your arguments
    a lot easier. This means that inside our app, we can take advantage of that parsing
    and call the proper functions.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the add command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s work with the `add` command, for example, for parsing your arguments
    and calling the functions. Once the `add` command gets called, we want to call
    a function defined in `notes`, which will be responsible for actually adding the
    note. The `notes.addNote` function will get the job done. Now, what do we want
    to pass to the `addNote` function? We want to pass in two things: the title, which
    is accessible on `argv.title`, as we saw in the preceding example; and the body,
    `argv.body`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Currently, these command-line arguments, `title` and `body`, aren't required.
    So technically, the user could run the application without one of them, which
    would cause it to crash, but in future, we'll be requiring both of these.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have `notes.addNote` in place, we can remove our `console.log` statement,
    which was just a placeholder, and we can move into the notes application `notes.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `notes.js`, we''ll get started by making a variable with the same name
    as the method we used over `app.js` and `addNote`, and we will set it equal to
    an anonymous arrow function, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this alone isn''t too useful, because we''re not exporting the `addNote`
    function. Below the variable, we can define `module.exports` in a slightly different
    way. In previous sections, we added properties onto `exports` to export them.
    We can actually define an entire object that gets set to `exports`, and in this
    case, we can set `addNote` equal to the `addNote` function defined in preceding
    code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In ES6, there's actually a shortcut for this. When you're setting an object
    attribute and a value that's a variable and they're both exactly the same, you
    can actually leave off the colon and the value. Either way, the result identical.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, we're setting an object equal to `module.exports`, and
    that object has a property, `addNote`, which points to the `addNote` function
    we defined as a variable in the preceding code block.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, `addNote:` and `addNote` are identical inside of ES6\. We will be
    using the ES6 syntax for everything throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now I can take my two arguments, `title` and `body`, and actually do something
    with them. In this case, we''ll call `console.log` and `Adding note`, passing
    in the two arguments as the second and third argument to `console.log`, `title`
    and `body`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now we're in a pretty good position to run the `add` command with `title` and
    `body` and see if we get exactly what we'd expect, which is the `console.log`
    statement shown in the preceding code to print.
  prefs: []
  type: TYPE_NORMAL
- en: 'Over in Terminal, we can start by running the app with `node app.js`, and then
    specify the filename. We''ll use the `add` command; which will run the appropriate
    function. Then, we''ll pass in `title`, setting it equal to `secret`, and then
    we can pass in `body`, which will be our second command-line argument, setting
    that equal to the string, `This is my secret`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this command, we specified three things: the `add` command the `title` argument,
    which gets set to `secret`; and the `body` argument, which gets set to `"This
    is my secret"`. If all goes well, we''ll get the appropriate log. Let''s run the
    command.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following command output, you can see Adding note secret, which is the
    title; and This is my secret, which is the body:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ada96524-27a8-475a-b80a-44a32452a2c9.png)'
  prefs: []
  type: TYPE_IMG
- en: With this in place, we now have one of our methods set up and ready to go. The
    next thing that we'll do is convert the other commands we have—the `list`, `read`,
    and `remove` commands. Let's look into one more command, and then you'll do the
    other two by yourself as exercises.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the list command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, with the `list` command, I''ll remove the `console.log` statement and
    call `notes.getAll`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: At some point, `notes.getAll` will return all of the notes. Now, `getAll` doesn't
    take any arguments since it will return all of the notes regardless of the title.
    The `read` command will require a title, and `remove` will also require the title
    of the note you want to remove.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, we can create the `getAll` function. Inside `notes.js`, we''ll go
    through that process again. We''ll start by making a variable, calling it `getAll`,
    and setting it equal to an arrow function, which we''ve used before. We start
    with our arguments `list`, then we set up the arrow (`=>`), which is the equal
    sign and the greater than sign. Next, we specify the statements we want to run.
    Inside our code block, we''ll run `console.log(Getting all notes)`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step to the process after adding that semicolon will be to add `getAll`
    to the `exports`, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Remember that in ES6, if you have a property whose name is identical to the
    value, which is a variable, you can simply remove the value variable and the colon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have `getAll` in `notes.js` in place, and we''ve wired it up in
    `app.js`, we can run things over in Terminal. In this case, we''ll run the `list`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/33f36369-3d7e-43da-ab9e-aa99cb60f7c2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding code output, you can see at the bottom that Getting all notes
    prints to the screen. Now that we have this in place, we can remove `console.log(''Process'',
    process.argv)` from the `command` variable in `app.js`. The resultant code will
    look like the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We will keep the yargs log around since we'll be exploring the other ways and
    methods to use yargs throughout the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the `list` command in place, next, I'd like you to create a
    method for the `read` and `remove` commands.
  prefs: []
  type: TYPE_NORMAL
- en: The read command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the `read` command is used, we want to call `notes.getNote`, passing in
    `title`. Now, `title` will get passed in and parsed using yargs, which means that
    we can use `argv.title` to fetch it. And that''s all we have to do when it comes
    to calling the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to define `getNote`, because currently it doesn''t exist.
    Over in `notes.js`, right below the `getAll` variable, we can make a variable
    called `getNote`, which will be a function. We''ll use the arrow function, and
    it will take an argument; it will take the `note` title. The `getNote` function
    takes the title, then it returns the body for that note:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside `getNote`, we can use `console.log` to print something like `Getting
    note`, followed by the title of the note you will fetch, which will be the second
    argument to `console.log`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is the first command, and we can now test it before we go on to the second
    one, which is `remove`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Over in Terminal, we can use `node app.js` to run the file. We''ll be using
    the new `read` command, passing in a `title` flag. I''ll use a different syntax,
    where `title` gets set equal to the value outside of quotes. I''ll use something
    like `accounts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This `accounts` value will read the accounts note in the future, and it will
    print it to the screen, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed29fd53-b7d8-4c61-b33b-2b6c4fc782b3.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding code output, we get an error, which we'll debug
    now.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with the errors in parsing commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Getting an error is not the end of the world. Getting an error usually means
    that you have a small typo or you forgot one step in the process. So, we''ll first
    figure out how to parse through these error messages, because the error messages
    you get in the code output can be pretty daunting. Let''s refer to the code output
    error here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1d14b0b9-86ba-4da5-9bd7-b5ac3513bce2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the first line shows you where the error occurred. It''s inside
    of our `app.js` file, and the number 19 after the colon is the line number. It
    shows you exactly where things went bad. The `TypeError: notes.getNote is not
    a function` line is telling you pretty clearly that the `getNote` function you
    tried to run doesn''t exist. Now we can take this information and debug our app.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `app.js`, we see that we call `notes.getNote`. Everything looks great, but
    when we move into `notes.js`, we realize that we never actually exported `getNote`.
    This is why when we try to call the function, we get `getNote is not a function`.
    All we have to do to fix that error message is export `getNote`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when we save the file and rerun the app from Terminal, we''ll get what
    we expect—Getting note followed by the title, which is accounts, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ee76344-03dc-4a00-abe1-db51f870bdf1.png)'
  prefs: []
  type: TYPE_IMG
- en: This is how we can debug our error messages. Error messages contain really useful
    information. For the most part, the first couple of lines are code that you've
    written, and the other ones are internal Node code or third-party modules. In
    our case, the first line of the stack trace is important, as it shows exactly
    where the error occurred.
  prefs: []
  type: TYPE_NORMAL
- en: The remove command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, since the `read` command is working, we can move on to the last one, which
    is the `remove` command. Here, I''ll call `notes.removeNote`, passing in the title,
    which as we know is available in `argv.title`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, we''ll define the `removeNote` function over inside of our notes API
    file, right below the `getNote` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now, `removeNote` will work much the same way as `getNote`. All it needs is
    the title; it can use this information to find the note and remove it from the
    database. This will be an arrow function that takes the `title` argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we''ll print the `console.log` statement, `Removing note`; then,
    as the second argument, we''ll simply print `title` back to the screen to make
    sure that it''s going through the process successfully. This time around, we''ll
    export our `removeNote` function; we''ll define it using the ES6 syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing to do is test it and make sure it works. We can reload the last
    command using the up arrow key. We change `read` to `remove`, and that is all
    we need to do. We''re still passing in the `title` argument, which is great, because
    that is what `remove` needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'When I run this command, we get exactly what we expected. Removing note prints
    to the screen, as shown in the following code output, and then we get the title
    of the note that we''re supposed to be removing, which is accounts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/794f3513-27f1-4303-b518-374f61bb6cbf.png)'
  prefs: []
  type: TYPE_IMG
- en: This looks great! That is all it takes to use yargs to parse your arguments.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we now have a place to define all of that functionality, for saving,
    reading, listing, and removing notes.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last thing I want to discuss before we wrap up this section is—how we fetch
    `command`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we know, `command` is available in the `_` property as the first and only
    item. This means that in the `app.js`, `var command` statement, we can set `command`
    equal to `argv`, then `._`, and then we''ll use `[]` to grab the first item in
    the array, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, we now have the same functionality, but we''ll use yargs
    everywhere. If I rerun the last command, we can test that the functionality still
    works. And it does! As shown in the following command output, we can see that
    Command: remove shows up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d31df46-2653-4c07-b9bf-0f5f84665e7f.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, we'll look into filling out the individual functions. We'll take a look
    first at how we can use JSON to store our notes inside our file system.
  prefs: []
  type: TYPE_NORMAL
- en: JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know how to parse command-line arguments using `process.argv` and
    yargs, you've solved the first piece to the puzzle for the `notes` application.
    Now, how do we get that unique input from the user? The second piece to the puzzle
    is to solve how we store this information.
  prefs: []
  type: TYPE_NORMAL
- en: When someone adds a new note, we want to save it somewhere, preferably on the
    filesystem. So the next time they try to fetch, remove, or read that note, they
    actually get the note back. To do this, we'll need to introduce something called
    JSON. If you're already familiar with JSON, you probably know it is super popular.
    It stands for **JavaScript Object Notation**, and it's a way to represent JavaScript
    arrays and objects using a string. Now, why would you ever want to do that?
  prefs: []
  type: TYPE_NORMAL
- en: Well, you might want to do that because strings are just text, and that's pretty
    much supported anywhere. I can save JSON to a text file, and then I can read it
    later, parse it back into a JavaScript array or object, and do something with
    it. This is exactly what we'll take a look at in this section.
  prefs: []
  type: TYPE_NORMAL
- en: To explore JSON and how it works, let's go ahead and make a new folder inside
    our project called `playground`.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the book, I'll create the `playground` folders and various projects,
    which store simple one-off files that aren't a part of the bigger application;
    they're just a way to explore a new feature or learn a new concept.
  prefs: []
  type: TYPE_NORMAL
- en: In the `playground` folder, we'll make a file called `json.js`, this is where
    we can explore how JSON works. To get started, let's make a very simple object.
  prefs: []
  type: TYPE_NORMAL
- en: Converting objects into strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first make a variable called `obj`, setting it equal to an object. On
    this object, we''ll just define one property, `name`, and set it equal to your
    first name; I''ll set this one equal to `Andrew`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's assume that we want to take this object and work on it. Let's say
    we want to, for example, send it between servers as a string and save it to a
    text file. To do this, we'll need to call one JSON method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a moment to define a variable to store the result, `stringObj`,
    and we''ll set it equal to `JSON.stringify`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `JSON.stringify` method takes your object, in this case, the `obj` variable,
    and returns the JSON-stringified version. This means that the result stored in
    `stringObj` is actually a string. It''s no longer an object, and we can take a
    look at that using `console.log`. I''ll use `console.log` twice. First up, we''ll
    use the `typeof` operator to print the type of the string object to make sure
    that it actually is a string. Since `typeof` is an operator, it gets typed in
    lowercase, there is no camel casing. Then, you pass in the variable whose type
    you want to check. Next up, we can use `console.log` to print the contents of
    the string itself, printing out the `stringObj` variable, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'What we''ve done here is we''ve taken an object, converted it into a JSON string,
    and printed it onto the screen. Over in Terminal, I''ll navigate into the `playground`
    folder using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: For now, it doesn't matter where you run the command, but in future it will
    matter when we are in the `playground` folder, so take a moment to navigate into
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use `node` to run our `json.js` file. When we run the file, we see
    two things:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fba1baff-bbdb-4edf-95ba-fb767eb815cd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the preceding code output, first, we will get our type, which is
    a string, and this is great, because remember, JSON is a string. Next, we will
    get our object, which looks pretty similar to a JavaScript object, but there are
    a few differences. These differences are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First up, your JSON will have its attribute names automatically wrapped in double
    quotes. This is a requirement of the JSON syntax.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next up, you'll notice your strings are also wrapped in double quotes as opposed
    to single quotes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, JSON doesn't just support string values, you can use an array, a Boolean,
    a number, or anything else. All of those types are perfectly valid inside of your
    JSON. In this case, we have a very simple example where we have a `name` property
    and it's set to `"Andrew"`.
  prefs: []
  type: TYPE_NORMAL
- en: This is the process of taking an object and converting it into a string. Next
    up, we'll define a string and convert that into an object we can actually use
    in our app.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a string and using in app as an object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get started by making a variable called `personString`, and we''ll to
    set it equal to a string using single quotes since JSON uses double quotes inside
    of itself, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we''ll define our JSON in the quotes. We''ll start by opening and closing
    some curly braces. We''ll use double quotes to create our first attribute, which
    we''ll call `name`, and we''ll set that attribute equal to `Andrew`. This means
    that after the closing quote, we''ll add `:`; then we''ll open and close double
    quotes again and type the value `Andrew`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, we can add another property. After the value, `Andrew`, I''ll create
    another property after the comma, called `age`, which will be set equal to a number.
    I can use my colon and then define the number without the quotes, in this case,
    `25`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You can go ahead and use your name and your age, obviously, but make sure the
    rest looks identical to what you see here.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's say we get the earlier-defined JSON from a server or we grab it from
    a text file. Currently, it's useless; if we want to get the `name` value, there
    is no good way to do that because we're using a string, so `personString.name`
    doesn't exist. What we need to do is take the string and convert it back into
    an object.
  prefs: []
  type: TYPE_NORMAL
- en: Converting a string back to an object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To convert the string back to object, we''ll use the opposite of `JSON.stringify`,
    which is `JSON.parse`. Let''s make a variable to store the result. I''ll create
    a `person` variable and it will be set equal to `JSON.parse`, passing in as the
    one and only argument the string you want to parse, in this case, the `person`
    string, which we defined earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now, this variable takes your JSON and converts it from a string back into its
    original form, which could be an array or an object. In our case, it converts
    it back into an object, and we have the `person` variable as an object, as shown
    in the preceding code. Also, we can prove that it's an object using the `typeof`
    operator. I'll use `console.log` twice, just like we did previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'First up, we''ll print `typeof person`, and then we''ll print the actual `person`
    variable, `console.log(person)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, we can now rerun the command in Terminal; I''ll actually
    start `nodemon` and pass in `json.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the following code output, you can now see that we''re working
    with an object, which is great, and we have our regular object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1ede340-6c8d-49fd-8dde-a7365f3ca724.png)'
  prefs: []
  type: TYPE_IMG
- en: We know that `Andrew` is an object because it's not wrapped in double quotes;
    the values don't have any quotes, and we use single quotes for `Andrew`, which
    is valid in JavaScript, but it's not valid in JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the entire process of taking an object, converting it to a string,
    and then taking the string and converting it back into the object, and this is
    exactly what we''ll do in the `notes` app. The only difference is that we''ll
    be taking the following string and storing it in a file, then later on, we''ll
    be reading that string from the file using `JSON.parse` to convert it back to
    an object, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Storing the string in a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the basics in place, let's take it just one step further, that is, by storing
    the string in a file. Then, we want to read the contents of that file back by
    using the `fs` module and printing some properties from it. This means that we'll
    need to convert the string that we get back from `fs.readfilesync` into an object
    using `JSON.parse`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the file in the playground folder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go ahead and comment out all the code we have so far and start with
    a clean slate. First up, let''s go ahead and load in the `fs` module. The `const`
    variable `fs` will be set equal to `require`, and we''ll pass the `fs` module
    that we''ve used in the past, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The next thing we'll do is define the object. This object will be stored inside
    of our file, and then will be read back and parsed. This object will be a variable
    called `originalNote`, and we'll call it `originalNote` because later on, we'll
    load it back in and call that variable `Note`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, `originalNote` will be a regular JavaScript object with two properties.
    We''ll have the `title` property, which we''ll set equal to `Some title`, and
    the `body` property, which we will set equal to `Some body`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The next step that you will need to do is take the original note and create
    a variable called `originalNoteString`, and set that variable equal to the JSON
    value of the object we defined earlier. This means that you'll need to use one
    of the two JSON methods we used previously in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, once you have that `originalNoteString` variable, we can write a file
    to the filesystem. I''ll write that line for you, `fs.writeFileSync`. The `writeFileSync`
    method, which we used before, takes two arguments. One will be the filename, and
    since we''re using JSON, it''s important to use the JSON file extension. I''ll
    call this file `notes.json`. The other arguments will be text content, `originalNoteString`,
    which is not yet defined, as shown in this code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This is the first step to the process; this is how we'll write that file into
    the `playground` folder. The next step to the process will be to read out the
    contents, parse it using the JSON method earlier, and print one of the properties
    to the screen to make sure that it's an object. In this case, we'll print the
    title.
  prefs: []
  type: TYPE_NORMAL
- en: Reading out the content in the file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step to print the title is to use a method we haven't used yet. We'll
    use the `read` method available on the filesystem module to read the contents.
    Let's make a variable called `noteString`. The `noteString` variable will be set
    equal to `fs.readFileSync`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, `readFileSync` is similar to `writeFileSync` except that it doesn''t take
    the text content, since it''s getting the text content back for you. In this case,
    we''ll just specify the first argument, which is the filename, `notes.JSON`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the string, it will be your job to take that string, use one
    of the preceding methods, and convert it back into an object. You can call that
    variable `note`. Next up, the only thing left to do is to test whether things
    are working as expected, by printing with the help of `console.log(typeof note)`.
    Then, below this, we''ll use `console.log` to print the title, `note.title`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, over in Terminal, you can see (refer to the following screenshot) that
    I have saved the file in a broken state and it crashed, and that''s expected when
    you''re using `nodemon`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d09a35f5-c804-4889-9ba7-dbb6be822a14.png)'
  prefs: []
  type: TYPE_IMG
- en: To resolve this, the first thing I'll do is fill out the `originalNoteString`
    variable, which we had commented out earlier. It will now be a variable called
    `originalNoteString`, and we'll set it equal to the return value from `JSON.stringify`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we know `JSON.stringify` takes our regular object and it converts the
    object into a string. In this case, we''ll take the `originalNote` object and
    convert it into a string. The next line, which we already have filled out, will
    save that JSON value into the `notes.JSON` file. Then we will read that value
    out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The next step will be to create the `note` variable. The `note` variable will
    be set equal to `JSON.parse`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `JSON.parse` method takes the string JSON and converts it back into a regular
    JavaScript object or array, depending on whatever you save. Here we will pass
    in `noteString`, which we''ll get from the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, we are now done. When I save this file, `nodemon` will
    automatically restart and we would expect to not see an error. Instead, we expect
    that we''ll see the object type as well as the note title. Right inside Terminal,
    we have object and Some title printing to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb8126dd-2d1b-4213-9419-38b86f7d9424.png)'
  prefs: []
  type: TYPE_IMG
- en: With this in place, we've successfully completed the challenge. This is exactly
    how we will save our notes.
  prefs: []
  type: TYPE_NORMAL
- en: 'When someone adds a new note, we''ll use the following code to save it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'When someone wants to read their note, we''ll use the following code to read
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Now, what if someone wants to add a note? This will require us to first read
    all of the notes, then modify the notes array, and then use the code (refer to
    the previous code block) to save the new array back into the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you open up that `notes.JSON` file, you can see right here that we have
    our JSON code inside the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad6c82b5-3af0-4fb8-8677-b579be0e6f68.png)'
  prefs: []
  type: TYPE_IMG
- en: '`.json` is actually a file format that''s supported by most text editors, so
    I actually already have some nice syntax highlighting built in. Now, in the next
    section, we''ll be filling out the `addNote` function using the exact same logic
    that we just used inside of this section.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding and saving notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, you learned how to work with JSON inside Node.js, and
    this is the exact format we'll be using for the `notes.js` application. When you
    first run a command, we'll load in all the notes that might already exist. Then
    we'll run the command, whether it's adding, removing, or reading notes. Finally,
    if we've updated the array, like we will when we add and remove notes, we'll save
    those new notes back into the JSON file.
  prefs: []
  type: TYPE_NORMAL
- en: Now, this will all happen inside of the `addNote` function, which we defined
    in the `notes.js` application, and we already wired up this function. In earlier
    sections, we ran the app `add` command, and this function executed with the `title`
    and `body` arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Adding notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started with adding notes, the first thing we''ll do is create a variable
    called `notes`, and for the moment, we''ll set it equal to an empty array, just
    as in the following, using our square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the empty array, we can go ahead and make a variable called
    `note`, which is the individual note. This will represent the new note:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'On that note, we''ll have the two properties: a `title` and a `body`. Now,
    `title` can be set equal to the `title` variable, but, as we know, inside ES6,
    we can simply remove it when both values are the same; so we''ll add `title` and
    `body` as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Now we have the `note` and the `notes` array.
  prefs: []
  type: TYPE_NORMAL
- en: Adding notes to the notes array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step in the process of adding notes will be to add the `note` to the
    `notes` array. The `notes.push` method will let us do just that. The `push` method
    on an array lets you pass in an item, which gets added to the end of the array,
    and in this case, we''ll pass in the `note` object. So we have an empty array,
    and we add our one item, as shown in the following code; next, we push it in,
    which means that we have an array with one item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The next step in the process will be to update the file. Now, we don't have
    a file in place, but we can load an `fs` function and start creating the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Up above the `addNote` function, let''s load in the `fs` module. I''ll create
    a `const` variable called `fs` and set it equal to the return result from `require`,
    and we''ll require the `fs` module, which is a core node module, so there''s no
    need to install it using NPM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, we can take advantage of `fs` inside the `addNote` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right after we push our item on to the `notes` array, we''ll call `fs.writeFileSync`,
    which we''ve used before. We know we need to pass in two things: the file name
    and the content we want to save. For the file, I''ll call, `notes-data.JSON`,
    and then we''ll pass in the content to save, which in this case will be the `stringify`
    notes array, which means we can call `JSON.stringify` passing in `notes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We could have broken `JSON.stringfy(notes)` out into its own variable and referenced
    the variable in the above statement, but since we'll only be using it in one place,
    I find this is the better solution.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, when we add a new note, it will update the `notes-data.JSON`
    file, which will be created on the machine since it does not exist, and the note
    will sit inside it. Now, it's important to note that currently every time you
    add a new note, it will wipe all existing ones because we never load in the existing
    ones, but we can get started testing that this note works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ll save the file, and over inside of Terminal, we can run this file using
    `node app.js`. Since we want to add a `note`, we will be using that `add` command
    which we set up, then we''ll specify our title and our body. The `title` flag
    can get set equal to `secret`, and for the `body` flag, I''ll set it equal to
    the `Some body here` string, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we run this command from Terminal, we''ll see what we''d expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c9217989-f386-40c8-93ca-2f52480535b7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the preceding screenshot, we see a couple of the file commands
    we added: we see that the `add` command was executed, and we have our Yargs arguments.
    The title and body arguments also show up. Inside Atom, we also see that we have
    a new `notes-data.json` file, and in the following screenshot, we have our note,
    with the `secret` title and the `Some body here` body:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/20bb3654-0b57-403a-9e51-106a98033c0d.png)'
  prefs: []
  type: TYPE_IMG
- en: This is the first step in wiring up that `addNote` function. We have an existing
    `notes` file and we do want to take advantage of these notes. If notes already
    exist, we don't want to simply wipe them every time someone adds a new note. This
    means that in `notes.js`, earlier at the beginning of the `addNote` function,
    we'll fetch those notes.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching new notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I''ll add code for fetching new notes where I define the `notes` and `note`
    variables. As shown in the following code, we''ll use `fs.readFileSync`, which
    we''ve already explored. This will take the filename, in our case, `notes-data.JSON`.
    Now, we will want to store the return value from `readFileSync` on a variable;
    I''ll call that variable, `notesString`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this is the string version, we haven''t passed it through the `JSON.parse`
    method. So, I can set `notes` (the variable we defined earlier in `addNote` function)
    equal to the return value from the `JSON.parse` method. Then `JSON.parse` will
    take the string from the file we read and it will parse it into an array; we could
    pass in `notesString` just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, adding a new note is no longer going to remove all of the
    notes that were already there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Over in Terminal, I''ll use the up arrow key to load in the last command, and
    I''ll navigate over to the `title` flag and change it to `secret2` and rerun the
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In Atom, this time you can see we now have two notes inside of our file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f5cb9595-6c07-44ad-8e25-2e20db88fab3.png)'
  prefs: []
  type: TYPE_IMG
- en: We have an array with two objects; the first one has the title of `secret` and
    the second one has the title of `secret2`, which is brilliant!
  prefs: []
  type: TYPE_NORMAL
- en: Trying and catching code block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, if the `notes-data.json` file does not exist, which it won''t when the
    user first runs the command, the program will crash, as shown in the following
    code output. We can prove this by simply rerunning the last command after deleting
    the `note-data.JSON` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b2d6170-3913-45eb-850b-b86ce5c4720e.png)'
  prefs: []
  type: TYPE_IMG
- en: Right here, you can see we're actually getting a JavaScript error, no such file
    or directory; it's trying to open up the `notes-data.JSON` file, but without much
    success. To fix this, we'll use a `try`-`catch` statement from JavaScript, which
    hopefully you've seen in the past. To brush up this, let's go over it really quick.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a `try`-`catch` statement, all you do is you type `try`, which is
    a reserved keyword, and then you open and close a set of curly braces. Inside
    the curly braces is the code that will run. This is the code that may or may not
    throw an error. Next, you''ll specify the `catch` block. Now, the `catch` block
    will take an argument, an error argument, and it also has a code block that runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will run if and only if one of your errors in `try` actually occurs.
    So, if we load the file using `readFileSync` and the file exists, that''s fine,
    `catch` block will never run. If it fails, `catch` block will run and we can do
    something to recover from that error. With this in place, all we''ll do is move
    the `noteString` variable and the `JSON.parse` statements into `try`, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: That's it; nothing else needs to happen. We don't need to put any code in `catch`,
    although you do need to define the `catch` block. Now, let's take a look at what
    happens when we run the whole code.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing that happens is that we create our static variables—nothing
    special there—then we try to load in the file. If the `notesString` function fails,
    that is fine because we already defined `notes` to be an empty array. If the file
    doesn't exist and it fails, then we probably want an empty array for `notes` anyways,
    because clearly there are no `notes`, and there's no file.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we'll parse that data into notes. There is a chance that this will
    fail if there's invalid data in the `notes-data.JSON` file, so the two lines can
    have problems. By putting them in `try`-`catch`, we're basically guaranteeing
    that the program isn't going to work unexpectedly, whether the file does or doesn't
    exist, but it contains corrupted data.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in place, we can now save `notes` and rerun that previous command.
    Note that I do not have the `notes-data` file in place. When I run the command,
    we don''t see any errors, everything seems to run as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c22407eb-04c5-4087-977d-bf2ad0afa79e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When you now visit Atom, you can see that the `notes-data` file does indeed
    exist, and the data inside it looks great:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6741579-1700-4aeb-a58d-9751e468208e.png)'
  prefs: []
  type: TYPE_IMG
- en: This is all we need to do to fetch the notes, update the notes with the new
    note, and finally save the notes to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Now, there is still a slight problem with `addNote`. Currently, `addNote` allows
    for duplicate titles; I could already have a note in the JSON file with the title
    of `secret`. I can come along and try to add a new note with the title of `secret`
    and it will not throw an error. What I'd like to do is to make the title unique,
    so that if there's already a note with that title, it will throw an error, letting
    you know that you need to create a note with a different title.
  prefs: []
  type: TYPE_NORMAL
- en: Making the title unique
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step to make the title unique will be to loop through all of the
    notes after we load them in and check whether there are any duplicates. If there
    are duplicates, we''ll not call the following two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: If there are no duplicates then it's fine, we will call both of the lines shown
    in the preceding code block, updating the `notes-data` file.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we'll be refactoring this function down the line. Things are getting a
    little wonky and a little out of control, but for the moment, we can add this
    functionality right into the function. Let's go ahead and make a variable called
    `duplicateNotes`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `duplicateNotes` variable will eventually store an array with all of the
    notes that already exist inside the `notes` array that have the title of the note
    you''re trying to create. Now, this means that if the `duplicateNotes` array has
    any items, that''s bad. This means that the note already exists and we should
    not add the note. The `duplicateNotes` variable will get set equal to a call to
    `notes`, which is our array of `notes.filter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The `filter` method is an array method that takes a callback. We''ll use an
    arrow function, and that callback will get called with the argument. In this case,
    it will be the singular version; if I have an array of notes, it will be called
    with an individual note:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This function gets called once for every item in the array, and you have the
    opportunity to return either true or false. If you return true, it will keep that
    item in the array, which will eventually get saved into `duplicateNotes`. If you
    return false, the new array it generates will not have that item inside `duplicateNotes`
    variable. All we want to do is to return true if the titles match, which means
    that we can return `note.title === title`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: If the titles are equal, then the preceding `return` statement will result as
    true and the item will be kept in the array, which means that there are duplicate
    notes. If the titles are not equal, which is most likely the case, the statement
    will result as false, which means that there are no duplicate notes. Now, we can
    simplify this a little more using arrow functions.
  prefs: []
  type: TYPE_NORMAL
- en: Arrow functions actually allow you to remove the curly braces if you only have
    one statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ll use the arrow function, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Here, I have deleted everything except `note.title === title` and added this
    in front of the arrow function syntax.
  prefs: []
  type: TYPE_NORMAL
- en: This is perfectly valid using ES6 arrow functions. You have your arguments on
    the left, the arrow, and on the right, you have one expression. The expression
    doesn't take a semicolon and it's automatically returned as the function result.
    This means that the code we have here is identical to the code we had earlier,
    only it's much simpler and it only takes up one line.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have this in place, we can go ahead and check the length of the
    `duplicateNotes` variable. If the length of `duplicateNotes` is greater than `0`,
    this means that we don't want to save the note because a note already exists with
    that title. If it is `0`, we'll save the note.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, inside the `if` condition, we''re comparing the notes length with the
    number zero. If they are equal, then we do want to push the note onto the `notes`
    array and save the file. I''ll cut the following two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s paste them right inside of the `if` statement, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: If they're not equal, that's okay too; in that case we'll do nothing.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in place, we can now save our file and test this functionality out.
    We have our `notes-data.json` file, and this file already has a note with a title
    of `secret2`. Let''s rerun the previous command to try to add a new note with
    that same title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/36e0f2c8-3e88-4e3d-a16c-d64b2162035b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You''re in Terminal, so we''ll head back into our JSON file. You can see right
    here that we still just have one note:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bca02d09-6b41-42b8-8744-c7a3c3e18ad9.png)'
  prefs: []
  type: TYPE_IMG
- en: Now all the titles inside of our application will be unique, so we can use these
    titles to fetch and delete notes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and test that other notes can still be added. I''ll change
    the `title` flag from `secret2` to `secret`, and run that command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/2ae3b082-396c-487d-80cd-c823b4500d9e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Inside our `notes-data` file, you can see both notes show up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e1998cee-6016-4e62-aacf-8dec5cd336ff.png)'
  prefs: []
  type: TYPE_IMG
- en: As I mentioned earlier, next we will be doing some refactoring, since the code
    that loads the file, and the code that saves the file, will both be used in most
    of the functions we have defined and/or will define (that is, the `getAll`, `getNote`
    and `removeNote` functions).
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, you created the `addNote` function, which works well.
    It starts by creating some static variables, then we fetch any existing notes,
    we check for duplicates, and if there are none, we push it onto the list, and
    then we save the data back into the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: The only problem is that we'll be doing a lot of these steps over and over again
    for every method. For example, with `getAll`, the idea is to fetch all of the
    notes, and send them back to `app.js` so it can print them to the screen for the
    user. The first thing we'll to do inside of the `getAll` statement is have the
    same code; we'll have our `try`-`catch` block to fetch the existing notes.
  prefs: []
  type: TYPE_NORMAL
- en: Now, this is a problem because we'll be repeating code throughout the application.
    It will be best to break out the fetching of notes and the saving of notes into
    separate functions that we can call in multiple locations.
  prefs: []
  type: TYPE_NORMAL
- en: Moving functionality into individual functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To resolve the problem, I''d like to get started by creating two new functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fetchNotes`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`saveNotes`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first function, `fetchNotes`, will be an arrow function, and it will not
    to take any arguments since it will be fetching notes from the filesystem, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The second function, `saveNotes`, will need to take an argument. It will need
    to take the `notes` array you want to save to the filesystem. We''ll set it equal
    to an arrow function, and then we''ll provide our argument, which I will name
    `notes`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have these two functions, we can go ahead and start moving some
    of the functionality from `addNote` up into the individual functions.
  prefs: []
  type: TYPE_NORMAL
- en: Working with fetchNotes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First up, let's do `fetchNotes`, which will need the following `try`-`catch`
    block.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ll actually cut it out of `addNote` and paste it in the `fetchNotes` function,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'This alone is not enough, because currently we don''t return anything from
    the function. What we want to do is to return the notes. This means that instead
    of saving the result from `JSON.parse` onto the `notes` variable, which we haven''t
    defined, we''ll simply return it to the calling function, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: So, if I call `fetchNotes` in the `addNote` function, shown as follows, I will
    get the `notes` array because of the `return` statement in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if there are no notes, maybe there''s no file at all; or there is a file,
    but the data isn''t JSON, we can return an empty array. We''ll add a `return`
    statement inside of `catch`, as shown in the following code block, because remember,
    `catch` runs if anything inside `try` fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this lets us simplify `addNote` even further. We can remove the empty
    space and we can take the array that we set on the `notes` variable and remove
    it and instead call `fetchNotes`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, we now have the exact same functionality we had before,
    but we have a reusable function, `fetchNotes`, which we can use in the `addNote`
    function to handle the other commands that our app will support.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of copying code and having it in multiple places in your file, we've
    broken it into one place. If we ever want to change how this functionality works,
    whether we want to change the filename or some of the logic such as the `try`-`catch`
    block, we can change it once instead of having to change it in every function
    we have.
  prefs: []
  type: TYPE_NORMAL
- en: Working with saveNotes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, the same thing will go for `saveNotes` just as in the case of the `fetchNotes`
    function. The `saveNotes` function will take the `notes` variable and it will
    say this using `fs.writeFileSync`. I will cut out the line in `addNote` that does
    this (that is, `fs.writeFileSync(''notes-data.json'', JSON.stringfy(notes));`)
    and paste it in the `saveNotes` function, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `saveNotes` doesn''t need to return anything. In this case, we''ll copy
    the line in `saveNotes` and then call `saveNotes` in the `if` statement of the
    `addNote` function, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This might seem like overkill, we've essentially taken one line and replaced
    it with a different line, but it is a good idea to start getting in the habit
    of creating reusable functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, calling `saveNotes` with no data is not going to work, we want to pass
    in the `notes` variable, which is our `notes` array defined earlier in the `saveNotes`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, the `addNote` function should now work as it did before
    we did any of our refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step in the process will be to test this out by creating a new note.
    We already have two notes, with a title of `secret` and a title of `secret2` in
    `notes-data.json`, let''s make a third one using the `node app.js` command in
    Terminal. We''ll use the `add` command and pass in a title of `to buy` and a body
    of `food`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'This should create a new note, and if I run the command, you can see we don''t
    have any obvious errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5e2807f-894f-416c-9d86-6117f68a76f2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Inside of our `notes-data.json` file, if I scroll to the right, we have our
    brand new note as a title of `to buy` and a body of `food`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5c5b8e9-aac7-4a78-af70-483f995a4e0d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So, everything is working as expected even though we''ve refactored the code.
    Now, the next thing I want to do inside `addNote` is take a moment to return the
    note that''s being added, and that will happen right after `saveNotes` comes back.
    So we''ll return `note`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'This `note` object will get returned to whoever called the function, and in
    this case, it will get returned to `app.js`, where we called it in the `if else`
    block of the `add` command in the `app.js` file. We can make a variable to store
    this result and we can call it `note`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: If `note` exists, then we know that the note was created. This means that we
    can go ahead and print a message, like `Note created`, and we can print the `note`
    title and the `note` body. Now, if `note` does not exist, if it's undefined, this
    means that there was a duplicate and that title already exists. If that's the
    case, I want you to print an error message such as `Note title already in use`.
  prefs: []
  type: TYPE_NORMAL
- en: There's a ton of different ways you could do this. The goal, though, is to print
    two different messages depending on whether or not a note was returned.
  prefs: []
  type: TYPE_NORMAL
- en: Now, inside `addNote`, if the `duplicateNotes` `if` statement never runs, we
    don't have an explicit call to return. But as you know, in JavaScript, if you
    don't call `return`, then `undefined` automatically is returned. This means that
    if `duplicateNotes.length` is not equal to zero, undefined will be returned and
    we can use that as the condition for our statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing I''ll do here is to create an `if` statement, right next to
    the `note` variable we defined in `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: This will be an object if things went well, and it will be undefined if things
    went poorly. This code in here is only ever going to run if it's an object. The
    `Undefined` result will fail the condition inside of JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if the `note` was created successfully, what we''ll do is to print a little
    message to the screen, using the following `console.log` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'If things went poorly, inside the `else` clause, we can call `console.log`,
    and we can print something like `Note title taken`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the other thing that we want to do if things went well is print the `notes`
    content. I''ll do this by first using `console.log` to print a couple of hyphens.
    This will create a little space above my note. Then I can use `console.log` twice:
    the first time we''ll print the title, I''ll add `Title:` as a string to show
    you what exactly you''re seeing, then I can concatenate the title, which we have
    access to in `note.title`, as shown in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the preceding syntax uses an ES5 syntax; we can swap this out with an
    ES6 syntax using what we''ve already talked about: template strings. We''ll add
    `Title`, a colon, and then we can use our dollar sign with our curly braces to
    inject the `note.title` variable, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, I''ll add `note.body` after this to print out the body of the note.
    With this in place, the code should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we should be able to run our app and see both of the title and body notes
    printed. In Terminal, I''ll rerun the previous command. This will try to create
    a note with to buy, which already exists, so we should get an error message, and
    right here you can see Note title taken:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc0ca745-0319-4bf4-b419-5c68751c4556.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we can rerun the command, changing the title to something else, such as
    `to buy from store`. This is a unique `note` title so the note should get created
    without any problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/5a370f6c-aeea-483e-bea1-63915466ed7b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the preceding output, you can see that we get just that: we have
    our Note created message, our little spacer, and our title along with the body.'
  prefs: []
  type: TYPE_NORMAL
- en: The `addNote` command is now complete. We have an output when the command actually
    finishes, and we have all the code that runs behind the scenes to add the note
    to the data that gets stored in our file.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned that parsing in `process.argv` can be a real pain.
    We would have to write a lot of manual code to parse out those hyphens, the equal
    signs, and the optional quotes. However, yargs can do all of that for us and it
    puts it on a really simple object we can access. You also learned how to work
    with JSON inside Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we filled out the `addNote` function. We're able to add notes using the
    command line, and we're able to save those notes into a JSON file. Finally, we
    pulled out a lot of the code from `addNote` into separate functions, `fetchNotes`
    and `saveNotes`, which are now separate, and they're able to be reused throughout
    the code. When we start filling out the other methods, we can simply call `fetchNotes`
    and `saveNotes` instead of having to copy the contents over and over again to
    every new method.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll continue our journey on node fundamentals. We'll
    explore some more concepts related to node, such as debugging; we'll work on the
    `read` and `remove` notes commands. Apart from this, we'll also learn about the
    advanced features of yargs and the arrow function.
  prefs: []
  type: TYPE_NORMAL
