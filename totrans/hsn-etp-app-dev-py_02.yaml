- en: Design Patterns – Making a Choice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a software application development project is taken up, it is essentially
    thought of as a problem that requires a solution. When we start to develop the
    application, we start developing a solution specific to the given problem. Eventually,
    this solution may start getting reused in problems of a similar kind, and becomes
    a standard solution for solving such problems. As time passes, we see that a lot
    of problems that display the same pattern. Once we modify our standard solution
    to work on this observed pattern, we come up with a **design pattern**. Design
    patterns are no joke; they take years to produce, after being tried and tested
    for solving a great number of problems with a similar pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The design patterns not only define the way in which we architect our software
    application, they also provide knowledge about what worked and what did not, while
    trying to solve a particular type of problem. There are times when no particular
    design pattern might suit the needs of a particular application and the developers
    are left with no choice but to come up with something unique.
  prefs: []
  type: TYPE_NORMAL
- en: Are there some existing standard design patterns that can be used for a particular
    type of problem? How can we decide which design pattern to use for our problem?
    Can we deflect from a particular design pattern and use them while working on
    our solution? We will try to answer these questions as we progress through the
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will know about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns and their classification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The object-oriented nature of Python, and how we can use it to implement some
    common design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use cases where a particular pattern may be used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code listings in this book can be found under `chapter02` directory at [https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python.](https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python)
  prefs: []
  type: TYPE_NORMAL
- en: 'The code samples can be cloned by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The instructions to run the code samples can be found under the `README.md`
    file present inside the chapter directory.
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A design pattern defines a way in which we can organize our solution to a given
    problem. It does not define algorithms that can be used to solve the problem,
    but rather provides an abstraction about how, for example, the code should be
    organized, what classes need to be defined, what their granularity will be, and
    how the different objects will be created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The design patterns have gained a lot of traction, and the book *Design Patterns:
    Elements of Reusable Object-Oriented Software, *though published in 1994, still
    serves as a de facto reference when trying to understand design patterns.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A design pattern will usually consist of the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A problem statement**: A problem statement describes what we want to solve
    and hence also defines the design patterns we can use. The problem statement will
    tell us about the scope of the design that we are planning to pursue, the constraints
    that we may need to take care of, and at times how the different components will
    communicate with each other in the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The solution**: A solution describes the design that makes up for the problem.
    It goes into detail about how the class hierarchies should be formed, how the
    objects will be formed, the relationship between the objects, and how the communication
    will take place between the different components. The solution will be an abstract
    design, not specifying the details of the implementation. This makes the solution
    generic, to be applied to a class of problems, without caring about what algorithms
    should be used to solve a particular problem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The consequences**: In the world of software development, nothing comes for
    free. Everything has a cost, and we trade off one thing for another. What matters
    is whether the trade-off is justifiable or not. The same applies to the choice
    of design patterns, which come with consequences of their own. Most of the time,
    these consequences are in the terms of space and time trade-offs, and form an
    important part of evaluating alternative options if a particular design choice
    is not justifying the cost of trade-offs. Sometimes, the consequences may also
    define the implementation barriers of a language, and can often impact the reusability
    and flexibility of an application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The choice of a design pattern is not something that is common for every set
    of problems. What pattern will be used to solve the problem will be based upon
    several factors, such as the interpretation of the problem by the developers,
    any restraints on the programming language that need to be used, the deadlines
    associated with the project, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Classification of design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the book *Design Patterns: Elements of Reusable Object-Oriented Software*,
    the design patterns have been classified into three major categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creational patterns**: These patterns define how the objects can be created
    so that your code can be made independent of which objects are present, and hence
    decouples it from the impact that may happen when new objects are introduced into
    the code base. This requires the isolation of the object creation logic from the
    code base. The patterns, such as Singleton and Factory, come under the category
    of creational patterns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Structural patterns**: Unlike creational patterns, which deal with how the
    objects are created, the structural patterns are often used to describe ...'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the choice of design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When choosing a design pattern, we may want a certain set of characteristics
    that the design pattern should fulfill. Let''s take a look at what these characteristics
    may consist of if we were to use Python to implement our design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Principle of least astonishment**: The Zen of Python says that the principle
    of least astonishment should be followed. That means that a design pattern being
    used should not surprise its user in terms of the behavior it is expected to show.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduced coupling**: Coupling is defined as the degree to which the different
    components inside a software are interdependent on each other. A software with
    a high degree of coupling may be very hard to maintain, since a change to one
    component may require a change to a lot of other components. Coupling as an effect
    cannot be completely removed from the software, but the choice of design pattern
    should be made such that the degree of coupling can be minimized in the development
    process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Focus on simplicity**: Starting to develop a software with a design principle
    that is too generalized can do more harm than good. It may introduce a lot of
    unwanted functionality into the code base, which is used very sparingly or not
    used at all. The choice of design pattern should be made to focus more on providing
    a simple solution to the stated problem, rather than with a focus on how many
    common types of problems a particular design pattern can solve.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoid duplication**: A good choice of design pattern will help the developer
    to avoid duplicating the code logic and keep it in one place, from where the different
    components of the system can access it. The reduction in duplication of logic
    will not only save development time, but will also make the maintenance process
    easy, where the change in the logic will need to be done only at a single point,
    and not in multiple parts of the code base.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object-oriented Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Object-oriented programming** (**OOP**) refers to the organization of code
    in a format where we are not concerned with the organization of methods, but rather
    we are concerned with the objects, their properties, and their behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: An object may represent any logical entity, such as an animal, vehicle, and
    furniture, and will contain properties and behaviors describing them.
  prefs: []
  type: TYPE_NORMAL
- en: The basic building block of an OOP-based language is the **class** that often
    groups the logically related entities together into a single unit. When we need
    to work with this unit, we create a new instance of this unit known as the class
    object, and manipulate the object using the public interfaces exposed by the object.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented programming in Python ...
  prefs: []
  type: TYPE_NORMAL
- en: The basic OOP principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A language cannot be considered an object-oriented language merely based on
    the fact that it supports classes and objects. The language will also need to
    support a set of different functionalities, such as encapsulation, polymorphism,
    composition, and inheritance, to be considered an object-oriented langauge. Python
    in this regard supports a lot of OOP-based concepts, but does it a bit differently
    due to its loosely typed nature. Let's take a look at how these features differ
    in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encapsulation is a term that is used to refer to the ability of a class to restrict
    the access to its members only through the public interfaces exposed by the object.
    The concept of encapsulation helps us in just working on the details about what
    we want to do with the object and not about how the object will deal with the
    changes internally.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, the encapsulation is not strictly enforced, in that we do not have
    the support of access modifiers, such as private, public, and protected, which
    can be used to strictly control the access to a particular member inside a class.
  prefs: []
  type: TYPE_NORMAL
- en: However, Python does support encapsulation with the help of name mangling, which
    can be used to restrict direct access to a particular property of a ...
  prefs: []
  type: TYPE_NORMAL
- en: Composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Composition is a property that is used to express a relationship between the
    different objects. The way this relationship is expressed in composition is by
    making an object an attribute of another object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python supports the concept of composition by allowing the programmer to build
    objects that can then be made part of other objects. For example, let''s take
    a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the example, we have made the `message_handler` object an
    attribute of the `watchdog` object. This marks one of the ways through which we
    can achieve composition in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inheritance is a way through which we create hierarchies in the objects, going
    from the most general to the most specific. A class that usually forms the base
    for another class is also known as a base class, whereas a class that inherits
    from a base class is known as a child class. For example, if a class `B` derives
    from class `A`, then we will say that class `B` is a child class of class `A`.
  prefs: []
  type: TYPE_NORMAL
- en: Just like C++, Python supports the concept of both multiple and multilevel inheritance,
    but does not support the use of access modifiers while inheriting in a class that
    C++ supports.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at how inheritance can be achieved in Python by trying to
    model how a new request will look in our BugZot application. The following snippet
    gives ...
  prefs: []
  type: TYPE_NORMAL
- en: Multiple inheritance in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at an abstract example of how we can implement multiple
    inheritance in Python, as can be seen in the code snippet that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The example shows how we can get multiple inheritance to work in Python. One
    interesting thing here is to understand how the method resolution order works
    in Python when we use multiple inheritance. So, let's take a look.
  prefs: []
  type: TYPE_NORMAL
- en: Method resolution order in multiple inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, based on the previous example, what happens if we create an object of the
    `C` class?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, only the derived class constructor was called here. So what
    if we wanted to call the parent class constructor also? For that, we will require
    the help of the `super()` call inside our class `C` constructor. To see it in
    action, let''s modify the implementation of `C` a little bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As soon as we created the object of the derived class, we can see that the derived
    class constructor was called first, followed by the constructor of the first inherited
    class. The `super()` call automatically ...
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing mixins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mixins is a concept that is present in every object-oriented language, and can
    be used to implement object classes that can be reused again and again in different
    places of the code. Projects such as Django web framework provide a lot of pre-built
    mixins, which can be used to achieve a certain set of functionality (for example,
    object manipulation, rendering of forms, and so on) in the custom classes we implement
    for our applications.
  prefs: []
  type: TYPE_NORMAL
- en: So, are mixins some special feature of the language? The answer to this is no,
    they are not some special feature, but rather are small classes that are not built
    to be turned into independent objects. Instead, they are built to provide some
    specified extra functionality to a class through the support of multiple inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to our sample application, BugZot, we will need a way to return
    the data from multiple objects in JSON format. Now, we have two options; we can
    build the functionality of returning JSON data at the level of individual methods,
    or we can build a mixin that can be reused again and again in multiple classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s imagine, if we wanted our bug class that we implemented in the
    example while trying to understand inheritance. All we needed to do was to just
    inherit `JSONMixin` in the `Bug` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: And, by simply inheriting the class, we got the required functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract base classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In OOP, abstract base classes are those classes that contain just the method
    declarations and not their implementations. These classes are not supposed to
    have independent objects, but rather are built to act as base classes. The classes
    that derive from the abstract base classes are required to provide implementation
    for the methods declared in the abstract classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, although you can build abstract classes by not providing the implementation
    for the declared methods, the language in itself does not enforce that concept
    of derived classes to provide the implementation for the method. So, the following
    example will run perfectly fine if executed in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Metaclasses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python provides a lot of features, some of which are directly visible to us,
    such as list comprehensions, dynamic type evaluation, and so on, and some of them
    not so directly. In Python, a lot of things can be considered magic, happening
    behind the scenes. One of them is the concept of metaclasses.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, everything is an object, be it a method or a class. Even inside Python,
    classes are considered to be first-class objects that can be passed on to methods,
    assigned to variables, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: But, as the concept of OOP states, every object denotes an instance of a class.
    So, if our classes are objects, then they should also be instances of some class.
    So, which class is that? The answer to this question is the `type` class. Every
    class in Python is an instance of the `type` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be verified quite easily, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: These classes, whose object is a class, are known as metaclasses.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, we don''t often use metaclasses directly, because most of the time
    the problems we are trying to solve with the help of metaclasses can usually be
    solved through the use of some other simple solutions. But the metaclasses do
    provide us with a lot of power to how we create our classes. Let''s first take
    a look at how we can create our own metaclasses by designing a `LoggerMeta` class,
    which will enforce the instance class to provide a valid handler method for different
    log methods prefixed by `HANDLER_`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have defined a `metaclass` named `LoggerMeta` by inheriting
    from the type class. (For defining any metaclass, we need to either inherit from
    the type class or any other metaclass. The concept of inheritance is applicable
    even during the `metaclass` creation.) Once we have declared our `metaclass`,
    we provide a definition for the `__init__` magic method in the `metaclass`. The
    `__init__` magic method of the metaclass takes in the class object, the name of
    the new class to be created, a list of base classes the new class will derive
    from, and a dictionary containing the properties of the new class that is used
    to initialize the new class.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `__init__` method, we have provided an implementation for verifying
    if the class properties whose name starts with `HANDLER_` have a valid handler
    assigned to them or not. In case the handler assigned to the property is not callable,
    we raise an `AttributeError` and prevent the creation of the class. And at the
    end of the `__init__` method, we return the call results of a base class `__init__`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: In the next example, we create two simple methods that will act as our handlers
    for dealing with error type messages and warning type messages.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on in the example, we define a class log whose metaclass is `LoggerMeta`.
    This class contains a few properties, such as `HANDLER_ERROR`, `HANDLER_WARN`,
    `HANDLER_INFO` and the magic method `__init__`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see what happens if we try to execute the provided example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the output, as soon as the definition of class log was parsed
    by the interpreter to create the class, the metaclass `__init__` method was called,
    which validated the properties of the class and raised an `AttributeError`.
  prefs: []
  type: TYPE_NORMAL
- en: The metaclasses in Python provide us with a lot of power at our disposal and
    enable us to do a lot of things magically, for example, generating class properties
    based on the name of the methods, and keeping track of how many instances of a
    class have been initialized.
  prefs: []
  type: TYPE_NORMAL
- en: With all the things we have learned about OOP and metaclasses in Python, let's
    now move on to using them to implement some of the design patterns in Python,
    and learning about how to decide upon the choice of the design pattern to use.
  prefs: []
  type: TYPE_NORMAL
- en: The Singleton pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Singleton pattern is one of the patterns that finds its place in the book
    by *Gang of Four*, and which can have various uses where all we want is a class
    to have a single instance throughout an application.
  prefs: []
  type: TYPE_NORMAL
- en: The Singleton pattern enforces that a class will have only one instance that
    will be used by any of the components/modules inside an application. This kind
    of enforcement can be useful when we want to control the access to a resource
    using only one object. These type of resources can be log files, databases, crash-handling
    mechanisms, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In most of the OOP-based languages, to implement the Singleton pattern, the
    first step is to make the class constructor private and then use a static method
    inside a class ...
  prefs: []
  type: TYPE_NORMAL
- en: The __call__ magic method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `__call__` magic method is special in context to Python metaclasses. Unlike
    the `__init__` method, which gets called when we create a new class from our metaclass,
    the `__call__` method is called when the object of the initialized class is created.
    To better understand this, let''s try to run the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: From this example, it is clear that the `__init__` method is called once the
    interpreter has completed the initialization of a class based on the `metaclass`
    and the `__call__` method is called when the object of the class is created.
  prefs: []
  type: TYPE_NORMAL
- en: Now, with this understanding in place, let's build our database connection class,
    which will provide the hold of our database operations. In this example, we will
    just focus on the initialization part of the class, while providing the complete
    class implementation details in the later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, under the `bugzot` directory, let''s create a file named `database.py`
    which will hold our database class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have defined the database class that will help us establish
    a connection to the database. The different thing about this class is, whenever
    we try to create a new instance of this class, it will always return the same
    object. For example, let''s try to see what happens if we create two different
    objects of this same class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we can see that the same instance of the database object was
    returned when we tried to instantiate a new object of the class.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a look at one other interesting pattern, known as the **Factory**
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The Factory pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During the development of large applications, there are certain cases where
    we might want to initialize a class dynamically, based upon the user input or
    some other dynamic factor. To achieve this, either we can initialize all the possible
    objects during the class instantiation and return the one that is required based
    on the inputs from the environment, or we can altogether defer the creation of
    class objects until an input has been received.
  prefs: []
  type: TYPE_NORMAL
- en: The Factory pattern is the solution to the latter case, where we develop a special
    method inside a class, which will be responsible for initializing the objects
    dynamically, based on the input from the environment.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see how we can implement the Factory pattern in Python ...
  prefs: []
  type: TYPE_NORMAL
- en: The Model-View-Controller pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start the discussion about the MVC pattern with a diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/fa47a996-2063-4385-b24f-40db473eac1e.png)'
  prefs: []
  type: TYPE_IMG
- en: The diagram shows the flow of a request in an **Application** using the MVC
    pattern. When a user makes a new **Request**, the **Request** is intercepted by
    the **Application**, which then forwards the **Request** to the appropriate **Controller**
    for that **Request**. Once the **Request** is received by the **Controller**,
    it then interacts with the model, which performs some business logic based on
    the **Request** received by it. This could involve the updating of databases,
    or fetching some data. Once the business logic is executed by the **Model**, the
    **Controller** executes the **View** with any data that needs to be passed to
    the **View**, which then displays the **Response** for the **Request**.
  prefs: []
  type: TYPE_NORMAL
- en: Although we will be implementing the MVC pattern later in the book, when we
    develop our BugZot application, let's take a look at the different components
    in the MVC pattern, and what roles they play.
  prefs: []
  type: TYPE_NORMAL
- en: Controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The controller acts as an intermediary between the model and the view. When
    a request is first made to the application, the controller intercepts the request
    and, based on that, decides which model and views need to be called. Once this
    is decided, the controller then executes the model to run the business logic,
    retrieving the data from the model. Once the data has been retrieved and model
    execution has been finished, the controller then executes the view with the data
    that is gathered from the model. Once the view execution is finished, the user
    sees a response from the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a brief, the controller is responsible for doing the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Intercepting the requests made to the application, and executing the required
    ...
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The model is the place where the business logic of the application lives. Many
    a time, developers confuse a model with a database, which may be true for some
    web applications, but is otherwise not if considered in general.
  prefs: []
  type: TYPE_NORMAL
- en: The role of the model is to deal with the data, provide access to it, and allow
    for modifications as they are requested. This includes retrieving data from the
    database or filesystem, adding new data to it, and modifying the existing data
    when updates are required.
  prefs: []
  type: TYPE_NORMAL
- en: A model is not concerned with how the data stored should be presented to the
    user or another component of the application, and hence decouples the presentation
    logic from the business logic. The model also doesn't change its schema frequently,
    and is more or less consistent throughout the application life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in brief, the model is responsible for performing the following roles:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide methods to access the data stored in the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decouple the presentation logic from business logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide persistence to the data being stored in the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide a consistent interface to deal with the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The view is responsible for presenting the data to the user, or presenting an
    interface to the user through which they can manipulate the data stored in the
    model. The view in MVC is usually dynamic and changes frequently based on the
    changes that happen in the model. A view can also be considered to contain just
    the presentation logic for the application, without having consideration for how
    the data will be stored by the application and how it will be retrieved. Often,
    a view can be used to cache the presentation state to accelerate the display of
    the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in brief, here are the functions performed by the view:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide the presentation logic for the application to display the data stored
    in the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide the user with ...
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went through the concept of design patterns and how they
    can help us solve some of the commonly encountered problems in designing our applications.
    We then went through how to decide upon which design pattern to use, and if it
    is compulsory to choose one of the patterns that has already been defined. Moving
    further in the chapter, we explored some of the object-oriented capabilities of
    Python as a language, and also explored some examples of implementing abstract
    classes and metaclasses in Python, and how we can use them to build other classes
    and modify their behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Equipped with the knowledge of object-oriented Python, we moved on to implement
    some of the common design patterns, such as the Singleton and Factory patterns
    in Python, and also explored the MVC pattern, learning about what problems they
    try to solve.
  prefs: []
  type: TYPE_NORMAL
- en: Now with the knowledge of design patterns with us, it is time for us to understand
    how we can make the process of handling the data inside our application efficient.
    The next chapter takes us through the journey of exploring the different techniques
    that will help us in efficiently handling the database operations that are going
    to take place inside our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we implement the chain of responsibility pattern in Python, and what
    are some of the possible use cases where it can be used?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the differences between the `__new__` method and the `__init__` method?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we implement an abstract class using the ABCMeta class as the metaclass
    for the abstract class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
