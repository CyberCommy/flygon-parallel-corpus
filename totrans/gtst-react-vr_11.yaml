- en: Take a Walk on the Wild Side
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've built some real, yet small, worlds so far in the chapters up to here.
  prefs: []
  type: TYPE_NORMAL
- en: There has been something missing, however. At the start, I've talked about VR
    as being something that you can interact with — a reality, even if it doesn't
    look real. So far, most of what we've been doing is looking and seeing things,
    but we can't move around.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will do exactly that.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using NPM to add components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Gaze button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a Gaze button to trigger an event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding in JavaScript files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting the JavaScript files to build geometry on the fly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving the point of view in the world we've created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving makes things seem more real
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A little more about VR controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Going loco–VR locomotion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I used to get carsick as a kid. VR can do this to you too — the reasons for
    this were discussed earlier while introducing VR, but this is a very important
    topic, so it bears repeating.
  prefs: []
  type: TYPE_NORMAL
- en: If you move a point of view, independently of what the user is doing (user agency),
    the brain knows that it didn't move. Yet, the brain also sees the world moving
    through your (VR) eyes. The brain then relies on a very ancient, important survival
    characteristic—you will think you've been poisoned.
  prefs: []
  type: TYPE_NORMAL
- en: When you've been poisoned, your body is very good at emesis. In less clinical
    terms, you throw up. Your body figures that something is trying to kill you, so
    it just gets rid of whatever is in your stomach as a panic reaction.
  prefs: []
  type: TYPE_NORMAL
- en: So, how do you move around in VR? How to enable VR locomotion without making
    people loco?
  prefs: []
  type: TYPE_NORMAL
- en: Types of VR locomotion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A discussion of VR locomotion wouldn't be complete without discussing VR controllers
    at least a little bit. What you've got in your hands, under your feet, holding
    you up, or letting you roll around in obviously makes a huge difference.
  prefs: []
  type: TYPE_NORMAL
- en: We are discussing WebVR, which, while very easy for people to get into, probably
    means that your users may not have all of the various types of VR gear handy.
    If you do have gear handy, you may still find that for your app, simpler types
    of locomotion are better, and they are certainly faster to code.
  prefs: []
  type: TYPE_NORMAL
- en: When discussing equipment, people discuss **Degrees of Freedom **(**DOF**).
    This really is less about strictly considering degrees of freedom but mostly about
    what is tracked.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a handheld device, you may have only **3DOF**; this means that the
    electronics can track whether you spin it around its center or not. A **6DOF**
    controller is tracked that way, but it can also detect whether it is moving around,
    in other words, translating. Usually, each of these has 3 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: A 6DOF controller is much more lifelike; you can reach out and touch things.
    However, they require some form of tracking, which, for the current state of the
    industry, usually means external trackers such as the Vive lighthouses or the
    Oculus cameras.
  prefs: []
  type: TYPE_NORMAL
- en: There is a third type of tracking called *inside out* tracking, which simply
    means that the headset itself sees the controllers and figures out where they
    are. They do use cameras, just not external cameras scattered about the room.
  prefs: []
  type: TYPE_NORMAL
- en: It's difficult to categorize types of locomotion as things that work without
    controllers; it may also work great with controllers (teleportation).
  prefs: []
  type: TYPE_NORMAL
- en: I won't really include moving your head around (or mousing around), although
    that is movement; without that, a VR system isn't really VR (in my definition).
    However, there have been VR headsets that did not include this feature—or don't
    do it well. This is the real breakthrough for high-end cell phones (for Samsung
    Gear VR and Google Daydream) and for the PC headsets, Vive and Rift.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following types of VR Locomotion:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Gaze detection**:You look at something, and it activates an effect, a blink,
    or makes you move'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vehicles/Cockpit locomotion**: Your view shows walls or details of a cockpit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can move with gaze detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With controllers (joysticks, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timed/artificial (push a button or move the player after a time)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only a slight chance of getting ill
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Room scale**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Walk around (up to bounds)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Very low chance of getting ill
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requires hardware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Teleportation or blinks**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usually with Gaze or with 3DOF or 6DOF controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Teleportation can also be done in small steps—removing motion (vection); this
    makes it feel like you are moving, but won't make you sick
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Treadmills**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A device you stand on and move your feet, and it detects how you move
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are hang glider simulators as well as flight simulators, where you lay
    down or sit down and fly by shifting your body weight
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these are large and expensive, usually limited to VR arcades
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tracked 6DOF controller movement paradigms**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vive/Rift usually use teleportation, and the 6DOF controllers make it easy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many other ways to move with 6DOF controllers; one good list can be
    found at [http://bit.ly/VRLoco](http://bit.ly/VRLoco)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Artificial locomotion/rails**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you've used your UI to indicate what to do, the VR system moves you along
    a path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gaze/head controlled turning is in this category.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Very easy to make people sick.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be irritating — if your head turns, just change the way you move; even
    if you don't get sick, you'll feel as if you are being carried away. Still, it
    can work with careful implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding ways to move around are, of course, constrained by how much hardware
    you have. Another constraint is how large you want your audience to be. If you
    design your VR app to be **room scale** (natural walking around), you've excluded
    every mobile phone user. Yet, by the same token, if you've decided on a gaze teleportation
    system, people that do have room scale VR will feel frustrated that they cannot
    just walk around.
  prefs: []
  type: TYPE_NORMAL
- en: 'WebVR is currently more aimed at mobile VR, with room scale being a large programming
    challenge. It is possible, but is not built in ''out of the box'' with React-VR,
    and for that matter WebVR. Looking from the point of view of hardware is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**No equipment** (Google Cardboard):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Natural locomotion (pan/tilt)–small amounts only
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gaze detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Artificial movement ('rails' movement, like you are on a rail) either by timer
    or gaze detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VR Headset with controller** (Gear VR, Daydream, others):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we have better ways, but can still do all the previous ways:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Natural locomotion (pan/tilt) - small amounts only
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gaze detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Artificial movement ('rails' movement, like you are on a rail) either by timer
    or gaze detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cockpit locomotion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Teleport via controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Joystick/controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PC VR–Vive/Rift**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we have better ways, but can still do all the previous ways:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Natural locomotion (pan/tilt)–small amounts only
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gaze detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Artificial movement ('rails' movement, like you are on a rail) either by timer
    or gaze detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cockpit locomotion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Teleport via controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Joystick/controller (on the tracked 6DOF controllers)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracked 6DOF controller movement paradigms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Room scale walking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High-end equipment**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Omni virtual treadmill or other treadmill
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding the ghost effect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is another reason why we want people to be able to move around without
    some type of user agency; without movement, it really isn't Virtual Reality. In
    reality, we all move around; cats move their heads sideways when stalking. If
    you're intrigued or curious, you tilt your head. With 360 video, one of the challenges
    is that you can only look around; you can't move. Tilting your head really does
    nothing.
  prefs: []
  type: TYPE_NORMAL
- en: What happens with 360 video, as detailed as it can be, is that you feel like
    a disembodied ghost. You can't look down and see yourself (you might see the camera
    rig though), you can't move around, you can't reach out and touch something, and
    you can't move your point of view. If you tilt your head, or  move side-to-side,
    there is no parallax effect.
  prefs: []
  type: TYPE_NORMAL
- en: I really like 360 video, but I also feel that it isn't really VR, as ultimately
    you feel disembodied, essentially a chained ghost. Sure, the video might move,
    but you can't change how it moves; you're just along for the ride.
  prefs: []
  type: TYPE_NORMAL
- en: One of the subtle things I was very impressed with WebVR is that if you tilt
    your head, the VR view does shift slightly, as if you are moving your head to
    the side. It's a subtle effect; it isn't room scale VR, where you can just walk
    around, but it is a type of VR. You don't feel like a disembodied ghost.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing people to explore their environment is important; without that, you
    really do feel like a ghost. For our example, we will use a teleport movement
    metaphor and allow people to explore a maze.
  prefs: []
  type: TYPE_NORMAL
- en: Without the ability to interact with the world and move around, you feel like
    a disembodied ghost. Although it's taken us nearly the entire book to get to this
    point, the ability to interact with your environment and world is one of the most
    important things in VR.
  prefs: []
  type: TYPE_NORMAL
- en: You will be able to do that in this chapter with any WebVR client. If we knew
    everyone had an HTC Vive or a room scale Oculus Rift, we could show you code to
    walk around the maze, although this brings up some interesting UI issues — what
    if someone walks through a hedge? Until we get full haptic head to toe suits,
    you can walk through a virtual wall. There are ways of using the user interface
    to counteract this, such as fading the screen to black briefly and then teleporting
    the user back to the start, just allowing them to cheat (not good), or other interesting
    ways around this.
  prefs: []
  type: TYPE_NORMAL
- en: For now, we will simply allow the user to move to the next cell/open spot in
    the maze, and  to that location only. We will use gaze selection, meaning that
    when you stare at a UI element, we'd know you've *clicked* on it. This will work
    with all VR devices on the market, and this really is the best place to start
    at. More sophisticated UI elements would need to check to see what kind of VR
    controllers and tracking the user has and enable the proper movement as appropriate.
    This is a little beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Before we discuss how to move in our world, we will need something interesting
    to move around in. For example, perhaps we were strolling through the forest and
    found our way blocked by a maze or it is early morning and we wanted to get to
    a small lake and see the early morning fog.
  prefs: []
  type: TYPE_NORMAL
- en: Let's build that maze.
  prefs: []
  type: TYPE_NORMAL
- en: Building a maze
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few ways we could build a maze. The most straightforward way would
    be to fire up our 3D modeler package (say, Blender) and create a labyrinth out
    of polygons. This would work fine and could be very detailed.
  prefs: []
  type: TYPE_NORMAL
- en: However, it would also be very boring. Why? The first time we get through the
    maze will be exciting, but after a few tries, you'll know the way through. When
    we construct VR experiences, you usually want people to visit often and have a
    fun time every time.
  prefs: []
  type: TYPE_NORMAL
- en: A modeled labyrinth would be boring. Life is too short to do boring things.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we want to generate a `Maze` randomly. This way, you can change the `Maze`
    every time so that it''ll be fresh and different. The way to do that is through
    random numbers to ensure that the `Maze` doesn''t shift around us, so we want
    to actually do it with pseudo-random numbers. To start doing that, we''ll need
    a basic application created. Please go to your VR directory and create an application
    called ''WalkInAMaze'':'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Almost random–pseudo random number generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To have a chance of replaying value or being able to compare scores between
    people, we really need a pseudo–random number generator. The basic JavaScript
    `Math.random()` is not a pseudo–random generator; it really gives you a totally
    random number every time. We need a pseudo–random number generator that takes
    a seed value. If you give the same seed to the random number generator, it will
    generate the same sequence of random numbers. (They aren't completely random,
    but are very close.) Random number generators are a complex topic; for example,
    they are used in cryptography, and if your random number generator isn't completely
    random, someone could break your code.
  prefs: []
  type: TYPE_NORMAL
- en: We aren't so worried about that, we just want repeatability. Although the UI
    for this may be a bit beyond the scope of this book, creating the `Maze` in a
    way that clicking on *Refresh* won't generate a totally different `Maze` is really
    a good thing and will avoid frustration on the part of the user. This will also
    allow two users to compare scores; we could persist a *board number* for the `Maze`
    and show this. This may be out of scope for our book; however, having a predictable
    `Maze` will help immensely during development. If it wasn't for this, you might
    get lost while working on your world. (Well, probably not, but it makes testing
    easier.)
  prefs: []
  type: TYPE_NORMAL
- en: Including library code from other projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, I've shown you how to create components in React VR (or React).
    JavaScript interestingly has a historical issue with `include`. With C++, Java,
    or C#, you can `include` a file in another file or make a reference to a file
    in a project. After doing that, everything in those other files, such as functions,
    classes, and global properties (variables), are then usable from the file that
    you've issued the include statement in.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a browser, the concept of "including" JavaScript is a little different.
    With Node.js, we use `package.json` to indicate what packages we need. To bring
    those packages into our code, we will use the following syntax in your .js files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, instead of using `Math.random()`, we will create a new random number
    generator and pass a seed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: From this point on, you just call `rng.random()` instead of `Math.random()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, we can just use `npm install <package>` and the `require` statement
    for properly formatted packages. In the next chapter, we''ll discuss upgrades
    and modify `package.json` to make sure that the code ships and updates properly.
    Much of this can be done for you by executing the `npm` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember, the --save command to update our manifest in the project. While we
    are at it, we can install another package we''ll need later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a good random number generator, let's use it to complicate
    our world.
  prefs: []
  type: TYPE_NORMAL
- en: The Maze render()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How do we build a `Maze`? I wanted to develop some code that dynamically generates
    the `Maze`; anyone could model it in a package, but a VR world should be living.
    Having code that can dynamically build `Maze` in any size (to a point) will allow
    a repeat playing of your world.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of JavaScript packages out there for printing mazes. I took
    one that seemed to be everywhere, in the public domain, on GitHub and modified
    it for HTML. This app consists of two parts: `Maze.html` and `makeMaze.JS`. Neither
    is React, but it is JavaScript. It works fairly well, although the numbers don't
    really represent exactly how wide it is.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/bd1de5fc-463e-4c9c-b084-6106bcadee46.png)'
  prefs: []
  type: TYPE_IMG
- en: First, I made sure that only one `x` was displaying, both vertically and horizontally.
    This will not print well (lines are usually *taller* than *wide*), but we are
    building a virtually real `Maze`, not a paper `Maze`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Maze` that we generate with the files at `Maze.html` (`localhost:8081/vr/maze.html`)
    and the JavaScript file—`makeMaze.js`—will now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It is a little hard to read, but you can count the squares vs. `x`s. Don't worry,
    it's going to look a lot fancier. Now that we have the HTML version of a `Maze`
    working, we'll start building the hedges.
  prefs: []
  type: TYPE_NORMAL
- en: This is a slightly larger piece of code than I expected, so I broke it into
    pieces and loaded the `Maze` object onto GitHub rather than pasting the entire
    code here, as it's long. You can find a link for the source at: [http://bit.ly/VR_Chap11](http://bit.ly/VR_Chap11)
  prefs: []
  type: TYPE_NORMAL
- en: Adding the floors and type checking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the things that look odd with a 360 Pano background, as we've talked
    about before, is that you can seem to "float" against the ground. One fix, other
    than fixing the original image, is to simply add a floor. This is what we did
    with the Space Gallery, and it looks pretty good as we were assuming we were floating
    in space anyway.
  prefs: []
  type: TYPE_NORMAL
- en: For this version, let's `import` a ground square. We could use a large square
    that would encompass the entire `Maze`; we'd then have to resize it if the size
    of the `Maze` changes. I decided to use a smaller cube and alter it so that it's
    "underneath" every cell of the `Maze`. This would allow us some leeway in the
    future to rotate the squares for worn paths, water traps, or whatever.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the floor, we will use a simple cube object that I altered slightly
    and is UV mapped. I used Blender for this. We also `import` a `Hedge` model, and
    a `Gem`, which will represent where we can teleport to. Inside ''`Maze.js`'' we
    added the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, inside the `Maze.js` we could instantiate our floor with the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we don''t use ''`vr/components/Hedge.js`'' when we do the import;
    we''re inside Maze.js. However, in index.vr.js to include the Maze, we do need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s slightly more complicated though. In our code, the Maze builds the data
    structures when props have changed; when moving, if the maze needs rendering again,
    it simply loops through the data structure and builds a collection (mazeHedges)
    with all of the floors, teleport targets, and hedges in it. Given this, to create
    the floors, the line in `Maze.js` is actually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here is where I ran into two big problems, and I'll show you what happened so
    that you can avoid these issues. Initially, I was bashing my head against the
    wall trying to figure out why my floors looked like hedges. This one is pretty
    easy—we imported `Floor` from the `Hedge.js` file. The floors will look like hedges
    (did you notice this in my preceding code? If so, I did this on purpose as a learning
    experience. Honest).
  prefs: []
  type: TYPE_NORMAL
- en: This is an easy fix. Make sure that you code `import Floor from './floor.js';` note
    that `Floor` not type-checked. (It is, after all, JavaScript.) I thought this
    was odd, as the `hedge.js` file exports a `Hedge` object, not a `Floor` object,
    but be aware you can rename the objects as you `import` them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second problem I had was more of a simple goof that is easy to occur if
    you aren''t really thinking in React. You may run into this. JavaScript is a lovely
    language, but sometimes I miss a strongly typed language. Here is what I did:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `maze.js` file, I had code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: After some debugging, I found out that the value of `j` was going from `0` to
    `42`. Why did it get `42` instead of `6`? The reason was simple. We need to fully
    understand JavaScript to program complex apps. The mistake was in initializing
    SizeX to be `'4'` ; this makes it a string variable. When calculating `j` from
    `0` (an integer), React/JavaScript takes `2`, adds it to a string of `'4'`, and
    gets the `42` string, then converts it to an integer and assigns this to `j`.
  prefs: []
  type: TYPE_NORMAL
- en: When this is done, very weird things happened.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we were building the Space Gallery, we could easily use the `''5.1''`
    values for the input to the box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, later use the transform statement below inside the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: React/JavaScript will put in the string values into `This.Props.MyX`, then realize
    it needs an integer, and then quietly do the conversion. However, when you get
    more complicated objects, such as our `Maze` generation, you won't get away with
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that your code isn't "really" JavaScript. It's processed. At the heart,
    this processing is fairly simple, but the implications can be a killer.
  prefs: []
  type: TYPE_NORMAL
- en: Pay attention to what you code. With a loosely typed language such as JavaScript,
    with React on top, any mistakes you make will be quietly converted to something
    you didn't intend.
  prefs: []
  type: TYPE_NORMAL
- en: You are the programmer. Program correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, back to the `Maze`. The `Hedge` and `Floor` are straightforward copies
    of the initial `Gem` code. Let''s take a look at our starting `Gem`, although
    note it gets a lot more complicated later (and in your source files):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `Hedge` and `Floor` are essentially the same thing. (We could have made
    a prop be the file loaded, but we want a different behavior for the `Gem`, so
    we will edit this file extensively.)
  prefs: []
  type: TYPE_NORMAL
- en: 'To run this sample, first, we should have created a directory as you have before,
    called `WalkInAMaze`. Once you do this, download the files from the Git source
    for this part of the chapter ([http://bit.ly/VR_Chap11](http://bit.ly/VR_Chap11)).
    Once you''ve created the app, copied the files, and fired it up, (go to the `WalkInAMaze` directory and
    type `npm start`), and you should see something like this once you look around
    - except, there is a bug. This is what the maze should look like (if you use the
    file  ''`MazeHedges2DoubleSided.gltf`'' in `Hedge.js`, in the `<Model>` statement):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/11460f25-89c6-4293-b109-f9f57dcf91ef.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, how did we get those neat-looking hedges in the game? (OK, they are pretty
    low poly, but it is still pushing it.) One of the nice things about the pace of
    improvement on web standards is their new features. Instead of just .obj file
    format, React VR now has the capability to load glTF files.
  prefs: []
  type: TYPE_NORMAL
- en: Using the glTF file format for models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: glTF files are a new file format that works pretty naturally with WebGL. There
    are exporters for many different CAD packages. The reason I like glTF files is
    that getting a proper export is fairly straightforward. Lightwave OBJ files are
    an industry standard, but in the case of React, not all of the options are imported.
    One major one is transparency. The OBJ file format allows that, but at of the
    time of writing this book, it wasn't an option. Many other graphics shaders that
    modern hardware can handle can't be described with the OBJ file format.
  prefs: []
  type: TYPE_NORMAL
- en: This is why glTF files are the next best alternative for WebVR. It is a modern
    and evolving format, and work is being done to enhance the capabilities and make
    a fairly good match between what WebGL can display and what glTF can export.
  prefs: []
  type: TYPE_NORMAL
- en: This is, however, a chapter on interacting with the world, so I'll give a brief
    mention on how to export glTF files and provide the objects, especially the `Hedge`,
    as glTF models.
  prefs: []
  type: TYPE_NORMAL
- en: 'The nice thing with glTF from the modeling side is that if you use their material
    specifications, for example, for Blender, then you don''t have to worry that the
    export won''t be quite right. Today''s **physically Based Rendering** (**PBR**)
    tends to use the metallic/roughness model, and these import better than trying
    to figure out how to convert PBR materials into the OBJ file''s specular lighting
    model. Here is the metallic-looking `Gem` that I''m using as the gaze point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/bedfa54d-f990-4ad9-a111-d03c08d7fd71.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the glTF Metallic Roughness model, we can assign the texture maps that
    programs, such as Substance Designer, calculate and import easily. The resulting
    figures look metallic where they are supposed to be metallic and dull where the
    paint still holds on.
  prefs: []
  type: TYPE_NORMAL
- en: I didn't use Ambient Occlusion here, as this is a very convex model; something
    with more surface depressions would look fantastic with Ambient Occlusion. It
    would also look great with architectural models, for example, furniture.
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert your models, there is user documentation at [http://bit.ly/glTFExporting](http://bit.ly/glTFExporting).
    You will need to download and install the Blender glTF exporter. Or, you can just
    download the files I have already converted. If you do the export, in brief, you
    do the the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the files from [http://bit.ly/gLTFFiles](http://bit.ly/gLTFFiles). You
    will need the `gltf2_Principled.blend` file, assuming that you are on a newer
    version of Blender.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Blender, open your file, then link to the new materials. Go to File->Link,
    then choose the `gltf2_Principled.blend` file. Once you do that, drill into "NodeTree"
    and choose either glTF Metallic Roughness (for metal), or glTF specular glossiness
    for other materials.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the object you are going to export; make sure that you choose the Cycles
    renderer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/a01e8241-d327-4f09-9289-c9543e843d18.png)'
  prefs: []
  type: TYPE_IMG
- en: Open the Node Editor in a window (like you did for images in earlier chapters). Scroll
    down to the bottom of the Node Editor window, and make sure that the box Use Nodes is
    checked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/ebec695d-f40a-4540-baf3-86533b1921b9.png)'
  prefs: []
  type: TYPE_IMG
- en: Add the node via the nodal menu, Add->Group->glTF Specular Glossiness or Metallic
    Roughness.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the node is added, go to Add->Texture->Image texture. Add as many image
    textures as you have image maps, then wire them up. You should end up with something
    similar to this diagram.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/ff400999-4004-4c90-9536-1fc01c17591d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To export the models, I recommend that you disable camera export and combine
    the buffers, unless you think you will be exporting several models that share
    geometry or materials. The Export options I used are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/d64cf541-7053-4e14-acf3-0af94bf489c2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, to include the exported glTF object, use the `<Model>` component as you
    would with an OBJ file, except you have no MTL file. The materials are all described
    inside the .glTF file. To include the exported glTF object, you just put the filename
    as a gltf2 prop in the `<Model`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: To find out more about these options and processes, you can go to the glTF export
    web site at: [http://bit.ly/WebGLTF](http://bit.ly/WebGLTF). This site also includes
    tutorials on major CAD packages and the all important glTF shaders (for example,
    the Blender model I showed earlier).
  prefs: []
  type: TYPE_NORMAL
- en: I have loaded several .OBJ files and .glTF files at [http://bit.ly/VR_Chap11](http://bit.ly/VR_Chap11) so
    you can experiment with different combinations of low poly and transparency. When
    glTF support was added in React VR version 2.0.0, I was very excited as transparency
    maps are very important for a lot of VR models, especially vegetation; just like
    our hedges. However, it turns out there is a bug in WebGL or three.js that does
    not render the transparency properly. As a result, I have gone with a low polygon
    version in the files on the GitHub site; the pictures, above, were with the file `MazeHedges2DoubleSided.gltf`
    in the `Hedges.js` file (in vr/components).
  prefs: []
  type: TYPE_NORMAL
- en: If you get 404 errors, check the paths in the glTF file. It depends on which
    exporter you use—if you are working with Blender, the gltf2 exporter from the
    Khronos group calculates the path correctly, but the one from Kupoman has options,
    and you could export the wrong paths.
  prefs: []
  type: TYPE_NORMAL
- en: Animation — VR Buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OK! We want to animate something. To do that, we will use the VRButton. It
    activates when one of the following things occur:'
  prefs: []
  type: TYPE_NORMAL
- en: Button A on an XBox Gamepad
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Space button on a keyboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Left click with a Mouse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Touch on a screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unfortunately, our "lowest common denominator" is a Google Cardboard, which
    may, or may not, have a button. You don't want to have to stick your finger inside
    and try to touch the screen. (After having said that, the newer VR headsets have
    a little lever arm that pokes the screen, even in the actual cardboard versions).
    What we will use is a *Gaze button*. When a mouse pointer or center of the screen
    (marked by a small dot) go over your object, events will be called, and our code
    will handle this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Gaze button is also packaged into a nice `<GazeButton>` object in the `npm`
    ecosystem. Please refer to the web page at: [http://bit.ly/GazeButton](http://bit.ly/GazeButton).
    To use it, we''ll need to understand what it does, and how we can let the View
    know that a `Gem` has been "touched" (or looked at for two seconds). We installed
    it earlier in the chapter; if you haven''t up to now, we install it by using Node.js
    command prompt and entering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We could use VR Button, but then we'd have to handle entering the object, leaving
    it, counting down, and so on. The `GazeButton` does all of this for us. Note that
    the way it expects children is a bit different to what we have been used to up
    to now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `Gem.js` code (note the capital) should now be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, when we try this on the desktop, it seems to work, but on a mobile phone
    (I tried it with Samsung GearVR), there is no cursor and nothing to click on.
    We need to implement a raycaster (even without controls).
  prefs: []
  type: TYPE_NORMAL
- en: There are so many different kinds of VR control systems, as we discussed briefly
    at the start of the chapter, where the default is "no" VR input device, including
    a center of the screen cursor.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of a proper control system is in our hands.
  prefs: []
  type: TYPE_NORMAL
- en: When you are using a desktop browser to do your initial development, you get
    a mouse cursor (including a *hand* cursor when over a tracked component), which
    can imply a gaze cursor is built in; they aren't. Just be aware there is a valid
    reason for this.
  prefs: []
  type: TYPE_NORMAL
- en: Raycasters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **raycaster** shoots a ray out into the world and calculates what it touches.
    You usually see these as glowing lines from VR controllers. Without a controller,
    the raycaster will cast a ray from the center of the screen; this is exactly what
    we need to implement our Gaze button.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, as we did with the button, there is already a  `simple-raycaster`
    out there. If you haven''t yet, you need to install it from `npm` via the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You might want to skip the `--save` while experimenting with packages; if you
    do, remember to update your `package.json` file manually or via the appropriate
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementation of the `simple-raycaster` is pretty easy. In `client.js`, below
    the existing `import` line (VRInstance), add the following `import` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Where it says `// Add custom options here`, insert the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: On your PC, things get a little strange at this point—the center of the screen
    will activate (and drop) the gems, even if you don't click. That's the entire
    point.
  prefs: []
  type: TYPE_NORMAL
- en: If we had more pages, we would make the gems spin when your gaze enters them.
    For now, we will give this exercise up to the reader.
  prefs: []
  type: TYPE_NORMAL
- en: You'll want to start an animation during the `onClick` handler.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we've shown how to get events when a gem is gazed at. That's good, we
    can use the event to trigger a movement, but how do we move?
  prefs: []
  type: TYPE_NORMAL
- en: One thing that is a little odd, is that React VR has no way to move the camera
    as many graphics systems do. To move the current point of view, you translate
    the `<View>` at the start of the `index.vr.js` to the opposite direction; this
    moves everything in the world the other way, which makes it look like you are
    moving forward. To move a point of view, we need to pass on the click event from
    the `Gem` to its parent's parent (the top level View).
  prefs: []
  type: TYPE_NORMAL
- en: Props, state, and events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React, and thus React VR, at its core, handles props, events, and state in a
    predictable, deterministic manner and this is what makes React apps consistent,
    clean, and easy to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Props are created when an object is declared and should not change over the
    life of the object. If an object needs to change, for example, our teleport gems,
    then you should assign these values to `state`. This enforces a top-down, unidirectional
    data flow. If a component needs the same state in different areas, then that `state`
    should be lifted up to the highest parent.
  prefs: []
  type: TYPE_NORMAL
- en: This causes interesting issues if you want a subcomponent to let a parent component
    know about an event or change its state based on an event at a lower level.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways of handling this; it can be a complicated subject in
    the React world. React VR doesn't differ from React Native or React in how state,
    props, and events are handled. A good place to start is the React Documentation,
    on *State and Lifecycle*.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, in a React app, there should be a single source of truth for something
    that changes. If a parent doesn't care, for example, if a `Gem` is higher or lower
    (stepped on or not), then you do not need to have that parent keep track of its
    children's height. Keeping `state` at a level as low as possible is the right
    decision. The height can be calculated from "have we stepped on the `Gem`", and
    so shouldn't be a prop that is passed down. (You might consider a *starting height*,
    though, as a prop; good programming says not to hardcode values, even though in
    a lot of the book files, we have for brevity.)
  prefs: []
  type: TYPE_NORMAL
- en: With our maze world, we have a quandary. We move the point of view by changing
    the `<View>` node at the top of our world tree. Yet, as we click on each `<Gem>`,
    we want the view to change.
  prefs: []
  type: TYPE_NORMAL
- en: We could handle this with context; a number of libraries, such as Redux or MobX,
    use context under the covers. There are event libraries that use context and other
    abilities. Context, however, is a bit of an advanced concept and a bit of overkill
    for what we are doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this particular case, we will simply pass a `callback` function down the
    child tree. The reasons we will do this are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, our app is fairly small from a hierarchy view, only three levels.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Maze` itself may need to know when the user has gotten to the end (for
    example, to display fireworks or update a high score). The `Gem` doesn't know
    this. If the `Gem` sent the notification directly to the View, the `Maze` would
    never know.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could bring in additional libraries, but this is a straightforward project,
    and too many external dependencies in an open source world can break things. This
    isn't a big problem usually, though—if something breaks, it's open source; go
    fix it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If, while looking for external packages, you do break things, you need to uninstall
    the offending package, then restart your Node.js server by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm start -- --reset-cache`'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm cache clean --force` does *not* do this cache reset. The error message
    you get should point this out if you forget.'
  prefs: []
  type: TYPE_NORMAL
- en: Making updates flow up river
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although updates ripple down, we need to pass the information up. How do we
    do that? Easy, with a functional `callback`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `index.vr.js`, create a couple of routines and do an all important binding
    of these routines to this—the `WalkInAMaze` component. I''m just showing the changed
    lines at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside our `Gem.js`, we already have an `onClick` method. We just need to add
    a few new `props`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, what''s this `this.props.onClickGem`? This is a prop, which is a function,
    that is passed from the parent. Where we create the `Gem`, we just insert this
    following prop (the inserted line in bold—not that source code can be bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, where do we get `this.handleClickGem`? In this (simple) case, the `Maze`
    won''t be doing anything with the event, just passing it through. In `Maze.js`,
    we will add a handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we note another prop here. This is, of course, passed to us by the maze''s
    parent; so, in `index.vr.js`, add the (bold) line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s pretty much it. What happens when the `Gem`''s VR Gaze button detects
    a click? It calls the prop, which is a function. This causes the maze''s `handleClickGem`
    to be called; it, in turn, calls `handleClickGem()` inside `index.vr.js`. This
    routine (pun intended) then sets internal state. This state causes the view to
    be re-rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: That's all it takes. Note that you don't just set the `state` with `this.startX
    = -X`, you need to call `this.setState()` as shown in the preceding code. This
    routine will then handle the rippling down of the `render()` updates.
  prefs: []
  type: TYPE_NORMAL
- en: These are big files, and we just made a lot of changes. I called out important
    lines in the above, but I highly recommend you download the source files from [http://bit.ly/VR_Chap11](http://bit.ly/VR_Chap11)
    and take a look at what we have done. In it, I've built a 4x4 maze that should
    have reasonable frame rate on most PC's and mobile devices. You can experiment
    with some other versions of the various objects (hedges that look like hedges
    or low poly hedges).
  prefs: []
  type: TYPE_NORMAL
- en: Where to go from here?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is a pretty basic game, but there is a lot you could do with it. Some
    things we''ve discussed before, that would be easy to include, are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Our teleporting is a bit abrupt. We should have a sound, or even do two updates
    (by changing the `HandleClickGem()` routine) to either add a brief animation or
    a two-step teleport. Note that it is generally not a good idea to smoothly animate
    the view itself; this makes people sick, as their eyes say they are moving but
    their body says not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of gems clicked on could become a score. This gives us an advantage
    to go slower, step by step and click on all the gems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You could time how long it takes to get to the exit, and lower numbers could
    increase your score. This gives an advantage to go faster and skip the teleport
    gems. The two goals here are exclusive, which, with balancing, can make it fun.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You could include buttons at the front of the maze to increase/decrease the
    size or generate different random numbers (and display them).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The scores and the random numbers could be loaded into a high score API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event passing libraries, such as `eventing-bus`, make the passing of `props`
    a lot easier. My goal was to show you the React VR way of doing it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned the final pieces to build complete apps and games
    on the web; coupled with what we learned earlier, our journey is nearly complete;
    this is really just the first step toward bringing reality to the web. The topics
    we covered included how to move in a VR world, including basic teleport mechanics.
    We discussed Gaze buttons and using ray casting to implement them. We discussed
    the important mechanics of `props`, `state`, and events. To implement these flows,
    we went over the important React philosophy of pushing `state` up and handling
    events down stream. We also discussed using pseudo random number generators to
    make sure that our `props` and `state` didn't change chaotically. All together,
    we now know how to create, move around in, and make worlds react to us.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll discuss where to go from here, how to upgrade React
    VR, and how to publish your virtual worlds on the internet.
  prefs: []
  type: TYPE_NORMAL
