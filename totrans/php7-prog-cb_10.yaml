- en: Chapter 10. Looking at Advanced Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Using getters and setters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a linked list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a bubble sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a binary search class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a search engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying a multi-dimensional array and accumulating totals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we cover recipes that implement various advanced algorithms
    such as linked list, bubble sort, stacks, and binary search. In addition, we cover
    getters and setters, as well as implementing a search engine and displaying values
    from a multi-dimensional array with accumulated totals.
  prefs: []
  type: TYPE_NORMAL
- en: Using getters and setters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At first glance, it would seemingly make sense to define classes with `public`
    properties, which can then be directly read or written. It is considered a best
    practice, however, to make properties `protected`, and to then define a **getter**
    and **setter** for each. As the name implies, a *getter* retrieves the value of
    a property. A *setter* is used to set the value.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Best practice**'
  prefs: []
  type: TYPE_NORMAL
- en: Define properties as `protected` to prevent accidental *outside* access. Use
    `public` get* and set* methods to provide access to these properties. In this
    manner, not only can you more precisely control access, but you can also make
    formatting and data type changes to the properties while getting and setting them.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Getters and setters provide additional flexibility when getting or setting values.
    You are able to add an additional layer of logic if needed, something which would
    not be possible if you were to directly read or write a public property. All you
    need to do is to create a public method with a prefix of either `get` or `set`.
    The name of the property becomes the suffix. It is a convention to make the first
    letter of the variable uppercase. Thus, if the property is `$testValue`, the getter
    would be `getTestValue()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this example, we define a class with a protected property, `$date`. Notice
    that the `get` and `set` methods allow for treatment as either a `DateTime` object
    or as a string. The value is actually stored in any event as a `DateTime` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Getters and setters allow you to filter or sanitize the data coming in or going
    out. In the following example, there are two properties, `$intVal` and `$arrVal`,
    which are set to a default initial value of `NULL`. Notice that not only are the
    return values for the getters data-typed, but they also provide defaults. The
    setters also either enforce the incoming data-type, or type-cast the incoming
    value to a certain data-type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you have a class with lots and lots of properties, it might become tedious
    to define a distinct getter and setter for each property. In this case, you can
    define a kind of *fallback* using the magic method `__call()`. The following class
    defines nine different properties. Instead of having to define nine getters and
    nine setters, we define a single method, `__call()`, which makes a determination
    whether or not the usage is `get` or `set`. If `get`, it retrieves the key from
    an internal array. If `set`, it stores the value in the internal array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `__call()`method is a magic method which is executed if an application makes
    a call to a non-existent method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Copy the code mentioned in step 1 into a new file, `chap_10_oop_using_getters_and_setters.php`.
    To test the class, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the output (shown next), you can see that the `$date` property can be set
    using either a `string` or an actual `DateTime` instance. When `getDate()` is
    executed, you can return either a `string` or a `DateTime` instance, depending
    on the value of the `$asString` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, have a look at the code defined in step 2\. Copy this code into a file,
    `chap_10_oop_using_getters_and_setters_defaults.php`, and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the following output, setting a *proper* integer value works
    as expected. A non-numeric value defaults to `0`. Interestingly, if you supply
    a Boolean `TRUE` as an argument to `setIntVal()`, it is interpolated to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you call `getArrVal()` without setting a value, the default is an empty
    array. Setting an array value works as expected. However, if you supply a non-array
    value as an argument, the type hint of the array causes a `TypeError` to be thrown,
    which can be caught as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_10_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, take the `LotsProps` class defined in step 3 and place it in a separate
    file, `chap_10_oop_using_getters_and_setters_magic_call.php`. Now add code to
    set values. What will happen, of course, is that the magic method `__call()` is
    invoked. After running `preg_match()`, the remainder of the non-existent property,
    after the letters `set`, will become a key in the internal array `$values`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then define HTML that displays the values using the corresponding `get`
    methods. These will in turn return keys from the internal array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the final output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_10_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementing a linked list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A linked list is where one list contains keys that point to keys in another
    list. An analogy, in database terms, would be where you have a table that contains
    data, and a separate index that points to the data. One index might produce a
    list of items by ID. Another index might yield a list according to title and so
    on. The salient feature of the linked list is that you do not have to touch the
    original list of items.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the diagram shown next, the primary list contains ID numbers
    and the names of fruits. If you were to directly output the primary list, the
    fruit names would display in this order: **Apple**, **Grape**, **Banana**, **Orange**,
    **Cherry**. If you were to use the linked list as an index, on the other hand,
    the resulting output of fruit names would be **Apple**, **Banana**, **Cherry**,
    **Grape**, and **Orange**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing a linked list](graphics/B05314_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the primary uses of a linked list is to produce a display of items in
    a different order. One approach would be to create an iteration of key value pairs,
    where the key represents the new order, and the value contains the value of the
    key in the primary list. Such a function might look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We use an anonymous function to generate the new key in order to provide extra
    flexibility. You will also notice that we do a sort by key (`ksort()`) so that
    the linked list iterates in key order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'All we need to do to use the linked list is to iterate through it, but produce
    results from the primary list, `$customer` in this example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that in no way do we touch the primary list. This allows us to generate
    multiple linked lists, each representing a different order, while retaining our
    original set of data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Another important use of a linked list is for the purposes of filtering. The
    technique is similar to that shown previously. The only difference is that we
    expand the `buildLinkedList()` function, adding a filter column and filter value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We only include items in the linked list where the value represented by `$filterCol`
    in the primary list matches `$filterVal`. The iteration logic is the same as that
    shown in step 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, another form of linked list is the *doubly* linked list. In this case,
    the list is constructed in such a manner that the iteration can occur in either
    a forward or reverse direction. In the case of PHP, we are fortunate to have an
    SPL class, `SplDoublyLinkedList`, which neatly does the trick. Here is a function
    that builds a doubly linked list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The terminology for `SplDoublyLinkedList` can be misleading. `SplDoublyLinkedList::top()`
    actually points to the *end* of the list, whereas `SplDoublyLinkedList::bottom()`
    points to the *beginning*!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Copy the code shown in the first bullet into a file, `chap_10_linked_list_include.php`.
    In order to demonstrate the use of a linked list, you will need a source of data.
    For this illustration, you can make use of the `customer.csv` file that was mentioned
    in earlier recipes. It is a CSV file with the following columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can add the following functions to the include file mentioned previously
    to generate a primary list of customers, and to display information about them.
    Note that we use the first column, id as the primary key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then define a calling program, `chap_10_linked_list_in_order.php`,
    which includes the file defined previously, and reads `customer.csv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then define an anonymous function that will produce a key in the linked
    list. In this illustration, define a function that breaks down column 1 (name)
    into first and last names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then call the function to build the linked list, and use `printCustomer()`
    to display the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how the output might appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To produce a filtered result, modify `buildLinkedList()` as discussed in step
    4\. You can then add logic that checks to see whether the value of the filter
    column matches the value in the filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'PHP 7.1 introduced the use of `[ ]` as an alternative to `list()`. If you look
    at the anonymous function mentioned previously, you could rewrite this in PHP
    7.1 as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: For more information, see [https://wiki.php.net/rfc/short_list_syntax](https://wiki.php.net/rfc/short_list_syntax).
  prefs: []
  type: TYPE_NORMAL
- en: Building a bubble sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The classic **bubble sort** is an exercise often assigned to university students.
    Nonetheless, it's important to master this algorithm as there are many occasions
    where built-in PHP sorting functions do not apply. An example would be sorting
    a multi-dimensional array where the sort key is not the first column.
  prefs: []
  type: TYPE_NORMAL
- en: The way the bubble sort works is to recursively iterate through the list and
    swap the current value with the next value. If you want items to be in ascending
    order, the swap occurs if the next item is less than the current item. For descending
    order, the swap occurs if the reverse is true. The sort is concluded when no more
    swaps occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, after the first pass, **Grape** and **Banana** are
    swapped, as are **Orange** and **Cherry**. After the 2nd pass, **Grape** and **Cherry**
    are swapped. No more swaps occur on the last pass, and the bubble sort ends:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a bubble sort](graphics/B05314_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We do not want to actually *move* the values around in the array; that would
    be horribly expensive in terms of resource usage. Instead, we will use a **linked
    list**, discussed in the previous recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First we build a linked list using the `buildLinkedList()` function discussed
    in the previous recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We then define a new function, `bubbleSort()`, which accepts the linked list
    by reference, the primary list, a sort field, and a parameter that represents
    sort order (ascending or descending):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The variables needed include one that represents the number of iterations,
    the number of swaps, and an iterator based upon the linked list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `while()` loop, we only proceed if the iteration is still `valid`, which
    is to say still in progress. We then obtain the current key and value, and the
    next key and value. Note the extra `if()` statement to ensure the iteration is
    still valid (that is, to make sure we don''t drop off the end of the list!):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we check to see whether the sort is to be ascending or descending. Depending
    on the direction, we check to see whether the next value is greater than, or less
    than, the current value. The result of the comparison is stored in `$expr`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If the value of `$expr` is `TRUE`, and we have valid current and next keys,
    the values are swapped in the linked list. We also increment `$swaps`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if any swaps have occurred, we need to run through the iteration again,
    until there are no more swaps. Accordingly, we make a recursive call to the same
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The *real* return value is the re-organized linked list. We also return the
    number of iterations just for reference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add the `bubbleSort()` function discussed previously to the include file created
    in the previous recipe. You can use the same logic discussed in the previous recipe
    to read the `customer.csv` file, producing a primary list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then produce a linked list using the first column as a sort key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, call the `bubbleSort()` function, providing the linked list and customer
    list as arguments. You can also provide a sort column, in this illustration column
    2, that represents the account balance, using the letter `''A''` to indicate ascending
    order. The `printCustomer()` function can be used to display output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementing a stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **stack** is a simple algorithm normally implemented as **Last In First Out**
    (**LIFO**). Think of a stack of books sitting on a library table. When the librarian
    goes to restore the books to their place, the topmost book is processed first,
    and so on in order, until the book at the bottom of the stack has been replaced.
    The topmost book was the last one to be placed on the stack, thus last in first
    out.
  prefs: []
  type: TYPE_NORMAL
- en: In programming terms, a stack is used to temporarily store information. The
    retrieval order facilitates retrieving the most recent item first.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First we define a class, `Application\Generic\Stack`. The core logic is encapsulated
    in an SPL class, `SplStack`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we define a property to represent the stack, and set up an `SplStack`
    instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'After that we define methods to add and remove from the stack, the classic
    `push()` and `pop()` methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We also throw in an implementation of `__invoke()` that returns an instance
    of the `stack` property. This allows us to use the object in a direct function
    call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One possible use for a stack is to store messages. In the case of messages,
    it is usually desirable to retrieve the latest first, thus it is a perfect use
    case for a stack. Define the `Application\Generic\Stack` class as discussed in
    this recipe. Next, define a calling program that sets up autoloading and creates
    an instance of the `stack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To do something with the stack, store a series of messages. As you would most
    likely store messages at different points in your application, you can use `sleep()`
    to simulate other code running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, simply iterate through the stack to retrieve messages. Note that you
    can call the stack object as if it were a function, which returns the `SplStack`
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Building a binary search class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Conventional searches often proceed through the list of items in a sequential
    manner. This means that the maximum possible number of items to be searched could
    be the same as the length of the list! This is not very efficient. If you need
    to expedite a search, consider implementing a *binary* search.
  prefs: []
  type: TYPE_NORMAL
- en: 'The technique is quite simple: you find the midpoint in the list, and determine
    whether the search item is less than, equal to, or greater than the midpoint item.
    If less, you set the upper limit to the midpoint, and search only the first half
    of the list. If greater, set the lower limit to the midpoint, and search only
    the last half of the list. You would then proceed to divide the list into 1/4,
    1/8, 1/16, and so on, until the search item is found (or not).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's important to note that although the maximum number of comparisons is considerably
    smaller than a sequential search (*log n + 1* where *n* is the number of elements
    in the list, and *log* is the binary logarithm), the list involved in the search
    must first be sorted, which of course downgrades performance.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We first construct a search class, `Application\Generic\Search`, which accepts
    the primary list as an argument. As a control, we also define a property, `$iterations`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we define a method, `binarySearch()`, which sets up the search infrastructure.
    The first order of business is to build a separate array, `$search`, where the
    key is a composite of the columns included in the search. We then sort by key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We then pull out the keys into another array, `$binary`, so that we can perform
    the binary sort based on numeric keys. We then call `doBinarySearch()`, which
    results in a key from our intermediary array `$search`, or a Boolean, `FALSE`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The first `doBinarySearch()` initializes a series of parameters. `$iterations`,
    `$found`, `$loop`, `$done`, and `$max` are all used to prevent an endless loop.
    `$upper` and `$lower` represent the slice of the list to be examined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We then implement a `while()` loop and set the midpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We now get to use the new PHP 7 **spaceship operator**, which gives us, in
    a single comparison, less than, equal to, or greater than. If less, we set the
    upper limit to the midpoint. If greater, the lower limit is adjusted to the midpoint.
    If equal, we''re done and home free:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for a bit of loop control. We increment the number of iterations and make
    sure it does not exceed the size of the list. If so, something is definitely wrong
    and we need to bail out. Otherwise, we check to see whether the upper and lower
    limits are the same more than twice in a row, in which case the search item has
    not been found. Then we store the number of iterations and return whatever was
    found (or not):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, implement the `Application\Generic\Search` class defining the methods
    described in this recipe. Next, define a calling program, `chap_10_binary_search.php`,
    which sets up autoloading and reads the `customer.csv` file as a search target
    (as discussed in the previous recipe):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then create a new `Search` instance, and specify an item somewhere
    in the middle of the list. In this illustration, the search is based on column
    1, customer name, and the item is `Todd Lindsey`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'For illustration, add this line just before `switch()` in `Application\Generic\Search::doBinarySearch()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown here. Notice how the upper, middle, and lower limits adjust
    until the item is found:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information on binary search, there is an excellent article on Wikipedia
    that goes through the basic math at [https://en.wikipedia.org/wiki/Binary_search_algorithm](https://en.wikipedia.org/wiki/Binary_search_algorithm).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a search engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to implement a search engine, we need to make provision for multiple
    columns to be included in the search. In addition, it's important to recognize
    that the search item might be found in the middle of the field, and that very
    rarely will users provide enough information for an exact match. Accordingly,
    we will rely heavily on the SQL `LIKE %value%` clause.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we define a basic class to hold search criteria. The object contains
    three properties: the key, which ultimately represents a database column; the
    operator (`LIKE`, `<`, `>`, and so on); and optionally an item. The reason why
    an item is optional is that some operators, such as `IS NOT NULL`, do not require
    specific data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we need to define a class, `Application\Database\Search\Engine`, and provide
    the necessary class constants and properties. The difference between `$columns`
    and `$mapping` is that `$columns` holds information that will ultimately appear
    in an HTML `SELECT` field (or the equivalent). For security reasons, we do not
    want to expose the actual names of the database columns, thus the need for another
    array `$mapping`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define a set of operators we are willing to support. The key represents
    actual SQL. The value is what will appear in the form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor accepts a database connection instance as an argument. For
    our purposes, we will use `Application\Database\Connection`, defined in [Chapter
    5](ch05.html "Chapter 5. Interacting with a Database"), *Interacting with a Database*.
    We also need to provide the name of the database table, as well as `$columns`,
    an array of arbitrary column keys and labels, which will appear in the HTML form.
    This will reference `$mapping`, where the key matches `$columns`, but where the
    value represents actual database column names:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'After the constructor, we provide a series of useful getters and setters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Probably the most critical method is the one that builds the SQL statement
    to be prepared. After the initial `SELECT` setup, we add a `WHERE` clause, using
    `$mapping` to add the actual database column name. We then add the operator and
    implement `switch()` which, based on the operator, may or may not add a named
    placeholder that will represent the search item:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the core `SELECT` has been defined, we remove any trailing `OR` keywords,
    and add a clause that causes the result to be sorted according to the search column.
    The statement is then sent to the database to be prepared:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to move on to the main show, the `search()` method. We accept
    an `Application\Database\Search\Criteria` object as an argument. This ensures
    that we have an item key and operator at a minimum. To be on the safe side, we
    add an `if()` statement to check these properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We then call `prepareStatement()` using `try` / `catch` to trap errors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we build an array of parameters that will be supplied to `execute()`.
    The key represents the database column name that was used as a placeholder in
    the prepared statement. Note that instead of using `=`, we use the `LIKE %value%
    construct`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The statement is executed, and the results returned using the `yield` keywords,
    which effectively turns this method into a generator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Place the code discussed in this recipe in the files `Criteria.php` and `Engine.php`
    under `Application\Database\Search`. You can then define a calling script, `chap_10_search_engine.php`,
    which sets up autoloading. You can take advantage of the `Application\Database\Connection`
    class discussed in [Chapter 5](ch05.html "Chapter 5. Interacting with a Database"),
    *Interacting with a Database*, and the form element classes covered in [Chapter
    6](ch06.html "Chapter 6. Building Scalable Websites"), *Building Scalable Websites*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now define which database columns will appear in the form, and a matching
    mapping file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now set up the database connection and create the search engine instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to display the appropriate drop-down `SELECT` elements, we define
    wrappers and elements based on `Application\Form\*` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We then get input parameters (if defined), set form element options, create
    search criteria, and run the search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The display logic mainly orients towards rendering the form. A more thorough
    presentation is discussed in [Chapter 6](ch06.html "Chapter 6. Building Scalable
    Websites"), *Building Scalable Websites*, but we show the core logic here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is sample output from a browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Displaying a multi-dimensional array and accumulating totals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How to properly display data from a multi-dimensional array has been a classic
    problem for any web developer. For illustration, assume you wish to display a
    list of customers and their purchases. For each customer, you wish to show their
    name, phone number, account balance, and so on. This already represents a two
    dimensional array where the *x* axis represents customers and the *y* axis represents
    data for that customer. Now add in purchases and you have a third axis! How can
    you represent a 3D model on a 2D screen? One possible solution would be to incorporate
    "hidden" division tags with a simple JavaScript visibility toggle.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First we need to generate a 3D array from a SQL statement that uses a number
    of `JOIN` clauses. We will use the `Application/Database/Connection` class introduced
    in [Chapter 1](ch01.html "Chapter 1. Building a Foundation"), *Building a Foundation,*
    to formulate an appropriate SQL query. We leave two parameters open, `min` and
    `max`, in order to support pagination. Unfortunately, we cannot use a simple `LIMIT`
    and `OFFSET` in this case, as the number of rows will vary depending on the number
    of purchases for any given customer. Accordingly, we can restrict the number of
    rows by placing restrictions on the customer ID that presumably (hopefully) is
    incremental. To make this work properly, we also need to set the primary `ORDER`
    to customer ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we can implement a form of pagination, based on restrictions on the customer
    ID, using simple `$_GET` parameters. Note that we add an extra check to make sure
    the value of `$prev` does not go below zero. You might consider adding another
    control that ensures the value of `$next` does not go beyond the last customer
    ID. In this illustration, we just allow it to increment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We then calculate the values for `$min` and `$max`, and prepare and execute
    the SQL statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'A `while()` loop can be used to fetch results. We use a simple fetch mode of
    `PDO::FETCH_ASSOC` for the purpose of this example. Using the customer ID as a
    key, we store basic customer information as array parameters. We then store an
    array of purchase information in a sub-array, `$results[$key][''purchases''][]`.
    When the customer ID changes, it''s a signal to store the same information for
    the next customer. Note that we accumulate totals per customer in an array key
    total:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we implement the view logic. First, we start with a block that displays
    primary customer information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Next comes the logic to display a list of purchases for this customer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'For the purposes of pagination, we then add buttons to represent *previous*
    and *next*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The result so far, unfortunately, is nowhere near neat and tidy! Accordingly
    we add a simple JavaScript function to toggle the visibility of a `<div>` tag
    based on its `id` attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we wrap the purchases table inside an initially invisible `<div>` tag.
    Then, we can place a limit of how many sub-rows are initially visible, and add
    a link that *reveals* the remaining purchase data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We then add a button that, when clicked, reveals the hidden `<div>` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Place the code described in steps 1 to 5 into a file, `chap_10_html_table_multi_array_hidden.php`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just inside the `while()` loop, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Just after the `while()` loop, add an `exit` command. Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You will notice that the basic customer information, such as the ID and name,
    repeats for each result row, but purchase information, such as transaction and
    product title, varies. Go ahead and remove the `printf()` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the `exit` command with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how the newly composed 3D array looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can now add the display logic shown in steps 5 to 7\. As mentioned, although
    you are now showing all data, the visual display is not helpful. Now go ahead
    and add the refinements mentioned in the remaining steps. Here is how the initial
    output might appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_10_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When the **Purchases** button is clicked, initial purchase info appears. If
    the link to **More** is clicked, the remaining purchase information shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
