- en: Chapter 7. Forensic Analysis of Android Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will cover application analysis, using free and open source tools.
    It will focus on analyzing the data that would be recovered using any of the logical
    or physical techniques detailed in [Chapters 4](part0031.xhtml "Chapter 4. Extracting
    Data Logically from Android Devices") and [Chapter 5](part0040.xhtml "Chapter 5. Extracting
    Data Physically from Android Devices"). It will also rely heavily on the storage
    methods discussed in [Chapter 2](part0019.xhtml "Chapter 2. Setting Up an Android
    Forensic Environment"). We will see numerous SQLite databases, XML files, and
    other file types from various locations within the file hierarchy described in
    the second chapter. By the end of this chapter, you should be familiar with the
    following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An overview of application analysis:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contacts/Calls/SMS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wi-Fi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User dictionary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Third-party applications and various methods used by popular applications to
    store and obfuscate data listed as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plain text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Epoch time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebKit time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Misnaming file extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Julian dates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Base64 encoding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encryption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic steganography
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQLCipher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic application reverse engineering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Forensically analyzing an application is as much of an art as it is a science.
    There are myriad ways an application can store or obfuscate its data. Different
    versions of the same application may even store the same data differently. A developer
    is really only limited by their imagination (and Android platform restrictions)
    when it comes to choosing how to store their data. As a result of these factors,
    application analysis is a constantly shifting target. The methods that an examiner
    uses one day may be completely irrelevant the next.
  prefs: []
  type: TYPE_NORMAL
- en: The end goal of forensically analyzing an application is consistently the same,
    to understand what the app was used for and find user data.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at the current version of many common applications.
    As apps can, and do, change how they store data through updates, nothing in this
    chapter is a definitive guide for how to analyze that application. Instead, we
    will look at a broad range of applications to show a variety of different methods
    used by applications to store their data. For the most part, we will look at very
    common applications (millions of downloads from Google Play), except for cases
    where looking at an obscure app can reveal interesting new ways of storing data.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While we made every attempt to be thorough in our usage of each application
    when populating our test data, it is entirely possible that not every feature
    of every application was used. The apps analyzed in the following sections are
    examples of how to examine data from that application, but may not include every
    possible bit of data that may be recovered.
  prefs: []
  type: TYPE_NORMAL
- en: All of our testing used the default settings of each application, as if the
    application was downloaded and immediately used. Different settings may affect
    the data that is stored and the location of the data on the device.
  prefs: []
  type: TYPE_NORMAL
- en: Also, this analysis was done on a Nexus 5 running Android 5.0.1\. Certain manufacturers,
    such as HTC and Samsung, may provide applications that duplicate functionality
    from these apps (such as a home screen widget that accesses Facebook). These apps
    may store data in different locations. Some files we analyze may not be present
    on other versions.
  prefs: []
  type: TYPE_NORMAL
- en: Why do app analysis?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For starters, even standard phone functions, such as contacts, calls, and SMS,
    are done through applications on Android devices. So, even acquiring basic data
    requires us to analyze an application. Second, a person''s app usage can tell
    you a lot about them: where they''ve been (and when they were there), who they''ve
    communicated with, and even what they may be planning in the future.'
  prefs: []
  type: TYPE_NORMAL
- en: Many phones can come out of the box with more than 20 preinstalled applications.
    A Yahoo study in 2014 revealed that users have, on average, 95 apps installed
    on their device. A Nielsen study showed that the average user uses 26 apps per
    month. An examiner has no real way of knowing which of these apps could contain
    information useful for an investigation, and therefore, all of them must be analyzed.
    An examiner may be tempted to skip over certain apps that would appear to have
    little useful data, such as games. This would be a bad idea, though. Many popular
    games, such as *Words with Friends* or *Clash of Clans*, have a built-in chat
    feature that could yield useful information. The following analysis will focus
    heavily on messaging applications, as our experience shows that these tend to
    be the most valuable in forensic analysis.
  prefs: []
  type: TYPE_NORMAL
- en: The layout of this chapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For each application we examine, we will provide a package name, version number
    if possible, and files of interest. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Package name: `com.android.providers.contacts`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Version: Default version with Android 5.0.1 (not listed within app)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Files of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/files/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`photos/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All apps store their data in the `/data/data` directory by default. Apps could
    also use the SD card if they ask for this permission when the app is installed.
    The package name is the name of the directory for the application in the `/data/data`
    directory. Files of interest are from the root of the package name (that is, /`data/data/com.android.providers.contacts/files/photos`
    for the preceding example). Paths to data on the SD card are shown beginning with
    `/sdcard` (that is, `/sdcard/com.facebook.orca`). Do not expect to find data paths
    beginning with `/sdcard` in the `/data/data` directory of the application!
  prefs: []
  type: TYPE_NORMAL
- en: We will begin by looking at some of Google's applications, because these are
    preinstalled on the vast majority of devices (though they do not have to be).
    Then, we will look at third-party applications that can be found on Google Play.
  prefs: []
  type: TYPE_NORMAL
- en: Determining what apps are installed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To see what applications are on the device, an examiner could navigate to `/data/data`
    and run the `ls` command. However, this doesn''t provide well-formatted data that
    will look good in a forensic report. We suggest that you pull the `/data/system/packages.list`
    file. This file lists the package name for every app on the device and path to
    its data (if this file does not exist on the device, the `adb shell pm list packages
    -f` command is a good alternative). For example, here is an entry for Google Chrome
    (the full file on our test device contained 120 entries):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Determining what apps are installed](img/image00389.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the first method of data storage: plain text. Often, we will see apps
    store data in plain text, including data you wouldn''t expect (such as passwords).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps of greater interest is the `/data/system/package-usage.list` file,
    which shows the last time a package (or application) was used. It''s not perfect;
    the times shown in the file did not correlate exactly with the last time we used
    the app. It appears that the app updating or receiving notifications (even if
    the user does not view them) may affect the time. However, it is good for a general
    indication of the last apps the user accessed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Determining what apps are installed](img/image00390.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you're wondering where the time is in the preceding line, it's in a format
    known as Linux epoch time.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Linux epoch time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Linux epoch time**, also known as Unix time or Posix time, is stored as the
    number of seconds (or milliseconds) since midnight on 1 January, 1970, UTC. A
    10-digit value indicates it is in seconds, while a 13-digit value is indicative
    of a millisecond value (at least for times likely to be found on a smartphone,
    as 9-digit second and 12-digit millisecond values haven''t occurred since 2001).'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, the value is `1422206858650`; Google Chrome was last
    used 1 billion, 422 million, 206 thousand, 858 seconds, and 650 milliseconds since
    midnight on 1 January, 1970! Don't worry; we don't know what date/time that is
    either. There are many scripts and tools available for download to convert this
    value to a human-readable format. We prefer the free tool **DCode**, which can
    be found at [http://www.digital-detective.net/digital-forensic-software/free-tools/](http://www.digital-detective.net/digital-forensic-software/free-tools/).
  prefs: []
  type: TYPE_NORMAL
- en: 'In DCode, simply select **Unix: Millisecond Value** from the drop-down list,
    type in the value in the **Value to Decode** field, and click on **Decode**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding Linux epoch time](img/image00391.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The **Add Bias** field can be selected to convert the time to the desired time
    zone.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, there is also a very useful online epoch converter at [http://www.epochconverter.com/](http://www.epochconverter.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Using either method, we can see that Google Chrome was actually last used on
    January 25, 2015, at 17:27:38.650 UTC. Linux epoch time is frequently used on
    Android devices to store date/time values and will come up repeatedly in our application
    analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the second data storage method: Linux epoch time.'
  prefs: []
  type: TYPE_NORMAL
- en: Wi-Fi analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Wi-Fi is not technically an application (as evidenced by the fact that it is
    not recovered from `/data/data`), but it is an invaluable source of data that
    should be examined. So, we''ll briefly discuss it here. Wi-Fi connection data
    is found in `/data/misc/wifi/wpa_supplicant.conf`. The `wpa_supplicant.conf` file
    contains a list of access points that the user has chosen to connect to automatically
    (this is set by default when a new access point is connected to). Access points
    that the user has "forgotten" through the device settings will not be shown. If
    the access point requires a password, that would also be stored in the file in
    plain text. In the following example, the `NETGEAR60` access point required a
    password (`ancientshoe601`), while `hhonors` did not:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wi-Fi analysis](img/image00392.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The presence of a **Service Set ID** (**SSID**) in this file does NOT mean that
    this device connected to that access point. These settings are saved to a user's
    Google account and added to the device when that account is set up. An examiner
    can only conclude that the user connected to these access points from some Android
    device, but not necessarily the device being examined.
  prefs: []
  type: TYPE_NORMAL
- en: Contacts/call analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Contacts and call logs are stored in the same database. Contacts do not have
    to be added explicitly by the user. They may be autofilled when an e-mail is sent
    through Gmail, or a person is added on Google+, or possibly many other ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'Package name: `com.android.providers.contacts`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Version: Default version with Android 5.0.1 (not listed within app)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Files of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/files/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`photos/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`profile/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/databases/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contacts2.db`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `files` directory contains photos for the user's contacts in the `photos`
    directory and the user's profile photo in the `profile` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `contacts2.db` database contains all of the information about calls made
    to and from the device and all contacts in the user''s Google account. It contains
    the following tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Table | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `accounts` | This shows the accounts on the device that have access to the
    contacts list. At least one of the accounts will show the user''s Google account
    e-mail address. This list may include third-party apps installed that have permission
    to access the contacts list (we will see this in the Tango, Viber, and WhatsApp
    sections). |'
  prefs: []
  type: TYPE_TB
- en: '| `calls` | This contains information regarding all calls to and from the device.
    The `number` column shows the remote user''s phone number, whether the call was
    sent or received. The `date` column is the date/time of the call, stored in the
    Linux epoch format. The `duration` column is the length of the call, in seconds.
    The `type` column indicates the type of call:'
  prefs: []
  type: TYPE_NORMAL
- en: '`1` = incoming'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2` = outgoing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3` = missed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `name` column shows the remote user's name, if the number was stored in
    the contact list. The `geocoded_location` column shows the location of the phone
    number based on the area code (for US numbers) or country code. |
  prefs: []
  type: TYPE_NORMAL
- en: '| `contacts` | This contains partial information for contacts (more data can
    be found in the `raw_contacts` table). The `name_raw_contact_id` value corresponds
    to the `_id` value in the `raw_contacts` table. The `photo_file_id` value corresponds
    to the filename found in the `/files/photos` directory. The `times_contacted`
    and `last_time_contacted` columns show the number of times that contact was called
    from or made a call to the device, and the time of the last call in the Linux
    epoch format. |'
  prefs: []
  type: TYPE_TB
- en: '| `data` | This table contains all of the information for each contact: e-mail
    address, phone numbers, and so on. The `raw_contact_id` column is a unique value
    for each contact that can be correlated with the `_id` value in `raw_contact_id`
    to identify the contact. Note that each contact may have several rows, as seen
    by the identical `raw_contact_id` values. There are 15 data columns (`data1` to
    `data15`) that contain some information about the contact, but there are no discernible
    patterns. The same column may contain the contact name, an e-mail address, a Google+
    profile, and so on. The value in the `data14` column correlates to the filenames
    of the images in the `/files/profiles` path. The `data15` column contains a thumbnail
    of the contact''s profile photo. |'
  prefs: []
  type: TYPE_TB
- en: '| `deleted_contacts` | This contains a `contact_id` value and `deleted_contact_timestamp`
    in the Linux epoch format. However, this cannot be correlated back to any other
    tables to identify the name of the contact that was deleted. It may be possible
    to use the deleted data-recovery techniques in [Chapter 6](part0048.xhtml "Chapter 6. Recovering
    Deleted Data from an Android Device"), *Recovering Deleted Data from an Android
    Device*, to recover the contact names, though. The `contact_id` value corresponds
    to the `contact_id` column in the `raw_contacts` table. |'
  prefs: []
  type: TYPE_TB
- en: '| `groups` | This shows groups in the contact list, either automatically generated
    or created by the user. The title of the group is the name of the group. There
    does not appear to be a way to identify users in each group. |'
  prefs: []
  type: TYPE_TB
- en: '| `raw_contacts` | This contains all information for every contact in the contact
    list. The `display_name` column shows the contact''s name, if it is available.
    To determine the contact''s phone number, e-mail address, or other information,
    the `_id` column value must be matched back to the `raw_contact_id` value in the
    data table. The `sync3` column shows a timestamp, but based on our testing, this
    cannot be assumed to be the time the contact was added. We had contacts several
    years old that were synced this month. The `times_contacted` and `last_time_contacted`
    columns only apply for phone calls; sending an e-mail or SMS to a contact did
    not increment these values.We were unable to identify any means to determine whether
    a contact was added through the phone interface, added as a friend on Google+,
    or added through other methods. |'
  prefs: []
  type: TYPE_TB
- en: SMS/MMS analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SMS and MMS messages are stored in the same database. In our experience, this
    database is also used, regardless of what application is used to send the SMS/MMS
    (that is, sending an SMS through Google Hangouts will populate this database,
    not the Hangouts database examined here). However, third-party apps may also record
    the data in their own databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Package name: `com.android.providers.telephony`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Version: Default version with Android 5.0.1 (not listed within app)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Files of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/app_parts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/databases/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mmssms.db`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`telephony.db`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `app_parts` directory contains attachments sent as an MMS, both sent and
    received.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `telephony.db` database is small, but contains one potentially useful source
    of information. The table in telephony.db is described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Table | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `siminfo` | This contains historical data for all SIMs that have been used
    in the device, including the ICCID, phone number (if it was stored on the SIM),
    and the **mobile country code** (**MCC**) / **mobile network code** (**MNC**),
    which can be used to identify the network provider. |'
  prefs: []
  type: TYPE_TB
- en: 'The `mmssms.db` database contains all information regarding SMS and MMS messages
    as described in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Table | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `part` | This contains information about files attached to an MMS. Each message
    will have at least two parts: an SMIL header and the attachment. This can be seen
    in the `mid` and `ct` columns, as well as the file type attached. The `_data`
    column provides the path to find the file on the device. |'
  prefs: []
  type: TYPE_TB
- en: '| `pdu` | This contains metadata about each MMS. The `date` column identifies
    when the message was sent or received, in the Linux epoch format. The `_id` column
    appears to correspond to the mid value in the part column; correlating these values
    will show the time a specific image was sent. The `msg_box` column shows the direction
    of the message (`1` = received and `2` = sent). |'
  prefs: []
  type: TYPE_TB
- en: '| `sms` | This contains metadata about each SMS (it does not include MMS information).
    The `address` column shows the phone number of the remote user, regardless of
    whether it was a sent or received message. The `person` column contains a value
    that can be looked up in the `contacts2.db` database and corresponds with `raw_contact_id`
    in the `data` table. The `person` column would be blank if it was a sent message
    or if the remote user is not in the contacts list. The `date` column shows the
    timestamp when a message was sent in the Linux epoch format. The `type` column
    shows the direction of the message (`1` = received, `2` = sent). The `body` column
    displays the content of the message. The `seen` column indicates whether or not
    the message was read (`0` = unread, `1` = read); all sent messages will be marked
    as unread. |'
  prefs: []
  type: TYPE_TB
- en: '| `words`, `words_content`, `words_segdir` | This appears to contain duplicate
    content of messages; the exact purpose of this table is unclear. |'
  prefs: []
  type: TYPE_TB
- en: User dictionary analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **user dictionary** is an incredible source of data for an examiner. While
    it is not necessarily a standalone application, its data is stored in /`data/data
    directory` as if it were. The user dictionary is populated any time the user types
    a word that isn't recognized and chooses to save the word to avoid it being flagged
    by autocorrect. Interestingly, our test device contained dozens of words that
    we never typed or saved on the device. This data appears to sync with a user's
    Google account and persists across multiple devices. Words synced from the account
    were added in alphabetical order at the top of the database, while words added
    manually afterwards were populated in the order they were added at the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: 'Package name: `com.android.providers.userdictionary`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Version: Default version with Android 5.0.1 (not listed within app)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Files of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/databases/user_dict.db`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The table in the user dictionary is described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Table | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `words` | The `word` column contains the word that was added to the dictionary.
    The `frequency` column should likely be ignored; it displayed the same value (250)
    regardless of the number of times we used the word. |'
  prefs: []
  type: TYPE_TB
- en: 'Here are sample entries from a user dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '![User dictionary analysis](img/image00393.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Gmail analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gmail is an e-mail service provided by Google. A Gmail account is often asked
    for, though is not required, when the device is being set up for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Package name: `com.google.android.gm`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Version: Default version with Android 5.0.1 (not listed within app)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Files of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/cache`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/databases/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mailstore.<username>@gmail.com.db`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`databases/suggestions.db`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/shared_prefs/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MailAppProvider.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Gmail.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UnifiedEmail.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `/cache` directory within the application folder contains recent files that
    were attached to e-mails, both sent and received. These attachments are saved
    here even if they are not explicitly downloaded by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mailstore.<username>@gmail.com.db` file contains a variety of useful information.
    Interesting tables within the database include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Table | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `attachments` | This contains information about attachments, including their
    size and file path on the device (the `/cache` directory mentioned earlier). Each
    row also contains a `messages_conversation` value. This value can be compared
    with the `conversations` table to correlate an attachment with the e-mail it was
    included within. The `filename` column identifies the path on the device where
    the file is located. |'
  prefs: []
  type: TYPE_TB
- en: '| `conversations` | In older versions, entire e-mail conversations could be
    recovered. In the current version, Google no longer stores the entire conversation
    on the device, possibly assuming that the user will have a data connection to
    download the full conversation. Instead, only the subject line and a "snippet"
    can be recovered. The snippet is roughly the amount of text that would appear
    in the notification bar or inbox screen of the app. The `fromCompact` column identifies
    the sender and any other recipients. |'
  prefs: []
  type: TYPE_TB
- en: The `suggestions.db` database contains terms that were searched within the application.
  prefs: []
  type: TYPE_NORMAL
- en: The XML files within the `shared_prefs` directory can confirm the account(s)
    that were used with the application. `Gmail.xml` contained another account that
    was linked with our test account, but never used with the application. `UnifiedEmail.xml`
    contained a partial list of senders who e-mailed the account, but with no discernible
    rationale. Many senders were on the list, but far from all, and they appeared
    in no particular order. `Gmail.xml` also contained the last time that the application
    was synced in the Linux epoch format.
  prefs: []
  type: TYPE_NORMAL
- en: Google Chrome analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Google Chrome is a web browser and is the default browser on Nexus and many
    other devices. Chrome data on the device is somewhat unique, in that, it contains
    data not just from the device, but from all devices on which the user has logged
    in to Chrome. This means that it is entirely possible (even very likely) that
    data from the user browsing on their desktop computer will be found in the databases
    on their phone. However, this also leads to huge amounts of data for an examiner
    to sort through, but that's a good problem to have.
  prefs: []
  type: TYPE_NORMAL
- en: 'Package name: `com.android.chrome`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Version: 40.0.2214.89'
  prefs: []
  type: TYPE_NORMAL
- en: 'Files of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/app_chrome/Default/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sync Data/SyncData.sqlite3`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Bookmarks`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cookies`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Google Profile Picture.png`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`History`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Login Data`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Preferences`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Top Sites`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Web Data`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/app_ChromeDocumentActivity/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the files listed earlier in the `/app_chrome/Default` folder, except
    for the one `.png` file, Bookmarks, and Preferences, are SQLite databases despite
    the lack of a file extension.
  prefs: []
  type: TYPE_NORMAL
- en: The `SyncData.sqlite3` database is interesting because it appears to contain
    a list of data that has been synced from the user's account on the device back
    to Google's servers. Our database, with a very active Chrome account, contained
    over 2700 entries and included browsing history, autofill form information, passwords,
    and bookmarks. As an example, we were able to find a term one of the authors had
    searched for from 2012, seen in the following screenshot. This is interesting
    because the user purchased this phone in 2014, but previous data is still synced
    to the device.
  prefs: []
  type: TYPE_NORMAL
- en: '![Google Chrome analysis](img/image00394.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '| Table | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `metas` | There are many columns in the database that contain timestamps,
    and in our database, they all appear to be within seconds of each other for each
    entry. It is unclear which time corresponds to the exact time an entry was added,
    but all of the times roughly correspond with the time of the activity in the user''s
    account. The columns with timestamps are `mtime`, `server_mtime`, `ctime`, `server_ctime`,
    `base_version`, and `server_version`.The `non_unique_name` and `server_non_unique_name`
    columns show the content that was synced. For example, one of our entries shows:`autofill_entry`
    &#124; `LNAME` &#124; `Tindall`Other entries in these columns include URLs visited,
    passwords, and even devices that the account has used. |'
  prefs: []
  type: TYPE_TB
- en: 'The `Bookmarks` file is a plain-text file that contains information about the
    bookmarks synced with the account. It includes the name of each site that is bookmarked,
    the URL, and the date/time it was bookmarked, stored in a format we have not come
    across yet: the WebKit format. To decode the values, see the Decoding the WebKit
    time format section.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the third method of data storage: the WebKit time format.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Cookies` database stores cookie information for sites visited (depending
    on the site and Chrome settings), including the name of the site, date the cookie
    was saved, and the last time the cookie was accessed, in the WebKit time format.
  prefs: []
  type: TYPE_NORMAL
- en: The `Google Profile Picture.PNG` file is the user's profile picture.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `History` database contains the user''s web history stored in the following
    tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Table | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `keyword_search_terms` | This contains a list of terms that were searched
    to use Google within Chrome. The `term` column shows what was searched, while
    `url_id` can be correlated with the URLs table to see the time of the search.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `segments` | This table contains some URLs that were visited, but not all.
    It is not clear what causes data to be entered into this table. |'
  prefs: []
  type: TYPE_TB
- en: '| `urls` | This contains the browsing history for the Google account across
    all devices, not just the device the database was pulled from. Our history went
    back approximately 3 months and contained 494 entries, although the Google account
    is much older than that, and we have certainly visited more than 494 pages in
    that time. It is unclear exactly what causes this discrepancy or determines the
    cut-off date for the history.The `id` column is a unique value for each row in
    the table. The `url` and `title` columns contain the URL visited and the name
    of the page. The `visit_count` column appears to be an accurate count of how many
    times the URL was visited. The value in `typed_count` column is always equal to
    or lesser than the value in the `visit_count` column, but we do not know exactly
    what it indicates. For some sites, the discrepancy can be accounted for by factoring
    in the number of times the site was visited through a bookmark rather than typing
    the URL, but this does not hold true for all cases. The `last_visit_time` column
    is the last time the URL was visited, in the WebKit time format. |'
  prefs: []
  type: TYPE_TB
- en: '| `visits` | This contains a row for each visit to the URLs in the urls table;
    the number of entries in this table for a URL corresponds to the value in the
    `visit_count` column of the `url` table. The `url` column value correlates to
    the value in the `id` column of the `url` table. The time of each visit can be
    found in the `visit_time` column, again in the WebKit time format. |'
  prefs: []
  type: TYPE_TB
- en: The `Login Data` database contains login information saved in Chrome and is
    synced across all devices that use the Google account.
  prefs: []
  type: TYPE_NORMAL
- en: '| Table | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `logins` | The `origin_url` is the site the user visited initially, and `action_url`
    is the URL of the login page if the user is redirected to one. If the first page
    visited is the login page, then both URLs are the same. The `username_value` and
    `password_value` columns show the username and password stored for that URL in
    plain text; and no, we''re not going to include a screenshot of our database!
    The `date_created` is the date/time that the login information was first saved,
    in the WebKit time format. The `date_synced` column is the date/time on which
    the login data was synced locally to the device, again in the WebKit time format.
    The `times_used` column shows the number of times that login information was autofilled
    by Chrome after it was saved (excluding the first login, so some values may be
    0). |'
  prefs: []
  type: TYPE_TB
- en: '`Preferences file` is a text file and contains the Google account(s) the user
    has signed into Chrome with.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Top Sites` database contains the sites that are most frequently visited,
    as these are shown by default when Chrome opens.
  prefs: []
  type: TYPE_NORMAL
- en: The `Web Data` database contains information the user has saved in order to
    automatically fill in forms on websites.
  prefs: []
  type: TYPE_NORMAL
- en: '| Table | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `autofill` | This contains a list of fields on web-based forms and the value
    the user typed. The `name` column shows the name of the field that was typed in,
    while the `value` column shows what the user typed. The `date_created` and `date_last_used`
    columns are self-explanatory and are stored in the Linux epoch format.Note that
    while this is potentially very valuable information (for example, our database
    contained a few usernames not stored elsewhere), there is also very little context
    available. The URL where the information is not stored may not be determinable.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `autofill_profile_emails` | This contains all values the user has saved to
    autofill the `e-mail` field on a web form. |'
  prefs: []
  type: TYPE_TB
- en: '| `autofill_profile_names` | This contains all values the user has saved to
    autofill the `First`, `Middle`, `Last`, and `Full Name` fields on a web form.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `autofill_profile_phonwa` | This contains all values the user has saved to
    autofill the `Phone Number` field on a web form. |'
  prefs: []
  type: TYPE_TB
- en: '| `autofill_profiles` | This contains all values the user has saved to autofill
    address information fields on a web form. |'
  prefs: []
  type: TYPE_TB
- en: The `/app_ChromeDocumentActivity`/ directory contains files with history for
    recent tabs that were open on the device. URLs can be recovered from these files
    for sites that were visited.
  prefs: []
  type: TYPE_NORMAL
- en: Decoding the WebKit time format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is a sample WebKit time value: `13066077007826684`.'
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, it appears to be very similar to the Linux epoch time, just
    slightly longer (perhaps it is storing nanoseconds?). An examiner who attempts
    to decode this as epoch time will get a date in May 2011, which may seem accurate,
    but is, in fact, several years off from the correct date!
  prefs: []
  type: TYPE_NORMAL
- en: The WebKit time is an epoch time. It is just based on a different starting point
    than the Linux epoch time. The WebKit epoch time is the number of microseconds
    since midnight on January 1, 1601\. Yes, we said the year 1601\. Once we know
    where the epoch begins, converting to a recognizable format simply becomes a math
    problem. However, once again, we'd rather use DCode.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, in DCode, choose Google Chrome Value in the **Decode Format** drop-down
    selection and click on **Decode**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Decoding the WebKit time format](img/image00395.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The actual value of our example is November 2, 2014 at 18:04:33 UTC. This is
    significantly different from the value we would have come up with if we thought
    it was a Linux epoch time!
  prefs: []
  type: TYPE_NORMAL
- en: Google Maps analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maps is a map/navigation application provided by Google.
  prefs: []
  type: TYPE_NORMAL
- en: 'Package name: `com.google.android.apps.maps`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Version: 9.2.0 (#902013124)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Files of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/cache/http/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/databases/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gmm_myplaces.db`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gmm_storage.db`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `/cache/http` folder contains many files, with `.0` and `.1` file extensions.
    The `.0` files are web requests for the corresponding `.1` file. The `.1` files
    are predominantly images and can be viewed by changing their extension appropriately.
    On our test device, they were either `.jpg` or `.png` files. These files were
    predominantly locations near the user, not necessarily locations the user specifically
    searched for.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the fourth data storage method: misnamed file extensions.'
  prefs: []
  type: TYPE_NORMAL
- en: Always verify the header of a file that can't be opened, or use automated tools,
    such as EnCase, to detect the mismatched header/file extension. A good resource
    to verify a file's signature is [http://www.garykessler.net/library/file_sigs.html](http://www.garykessler.net/library/file_sigs.html).
  prefs: []
  type: TYPE_NORMAL
- en: The `gmm_myplaces.db` database contains locations saved by the user. This file
    syncs with the user's Google account, so these locations were not necessarily
    saved using the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `gmm_storage.db` database contains search hits and locations that were
    navigated to the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Table | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `gmm_storage_table` | The `_key_pri` column appears to identify the type
    of the location. bundled appears to be a hit that came up on a search, while `ArrivedAtPlacemark`
    identifies locations that were actually navigated to. The `_data` column contains
    the address for the location. |'
  prefs: []
  type: TYPE_TB
- en: Google Hangouts analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Hangouts** is a chat/SMS application provided by Google. Hangouts is the
    default SMS client on Android devices.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Package name: `com.google.android.gm`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Version: Default version with Android 5.0.1 (not listed within the app)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Files of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/cache/volleyCache/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/databases/babel#.db` (our device had babel0.db and babel1.db)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/shared_prefs/accounts.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `cache` directory contains `.0` files, as discussed in the Google Maps example
    earlier. The files contain a URL to fetch the profile pictures of contacts, as
    well as a `.jpg` embedded within the file. Visiting the URL or carving the `.jpg`
    from the file will recover the contact's picture.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `babel#.db` file contains all messaging data. On our test device, `babel0.db`
    was blank, and `babel1.db` had all of the data for the active account. There are
    many tables within this database worth looking at:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Table | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `conversations` | This contains conversation data. There is a unique `conversation_id`
    value for each chat. The `latest_message_timestamp` column is the time of the
    most recent chat, in the Linux epoch format. The `generated_name` column has a
    list of all participants in the chat, minus the account on the device. The `snippet_text`
    column is the content of the most recent message; like Gmail, the entire chat
    is not stored on the device. The `latest_message_author_full_name` and `latest_message_author_first_name`
    columns identify the author of the `snippet_text` column. The `inviter_full_name`
    and `inviter_first_name` columns identify which person initiated the conversation.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `dismissed_contacts` | This has a list of names of former contacts that had
    been messaged. These are labeled as "Hidden Contacts" within the app. |'
  prefs: []
  type: TYPE_TB
- en: '| `messages` | As expected, this contains a detailed message history for each
    conversation. The `text` column contains the content of the message, and the `timestamp`
    column is the date/time in the Linux epoch format. The `remote_url` column is,
    once again, a URL to retrieve images shared in the message. Again, it can be accessed
    publically. The `author_chat_id` is a value that can be correlated with the participants
    table to identify the author of each message. |'
  prefs: []
  type: TYPE_TB
- en: '| `participants` | This contains a list of people chatted with. It includes
    full names, profile picture URLs, and a `chat_id` value to identify the person
    in the messages table. |'
  prefs: []
  type: TYPE_TB
- en: The `accounts.xml` file has a `phone_verification` field that contains the phone
    number associated with the Google account when Hangouts is configured to send
    SMS. This could be highly useful, because it is frequently difficult to obtain
    the device's phone number as it is often not stored on the device.
  prefs: []
  type: TYPE_NORMAL
- en: Google Keep analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keep is a note-taking application provided by Google. It can also be used to
    set reminders, either at a certain date/time or when the user is at a specified
    location.
  prefs: []
  type: TYPE_NORMAL
- en: 'Package name: `com.google.android.keep`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Version: Default version with Android 5.0.1 (not listed within app)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Files of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/databases/keep.db`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/files/1/image/original`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `files/1/image/original` directory contains photos taken using the app.
    Notes and reminders can both be associated with an image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `keep.db` contains all of the information about notes and reminders. There
    are, once again, several tables of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Table | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `alert` | This contains information about location-based reminders. The `reminder_id`
    column can be correlated with entries in the reminder table. The `reminder_detail`
    table contains the latitude and longitude set for the reminder. The `scheduled_time`
    column is the date/time the reminder was set, in the Linux epoch time. |'
  prefs: []
  type: TYPE_TB
- en: '| `blob` | This contains metadata about images in the `/files` directory mentioned
    earlier, including the filename and size. The `blob_id` column can be correlated
    with the `_id` column in the `blob_node` table. |'
  prefs: []
  type: TYPE_TB
- en: '| `blob_node` | This contains the time-created value for the images in the
    `/files` directory, in the Linux epoch time. |'
  prefs: []
  type: TYPE_TB
- en: '| `list_item` | This stores data for each note on the device. The `text` column
    contains the full text of each note. The `list_parent_id` column is a unique value
    for each note. If multiple rows have the same value, it means they were created
    as a list within the same note. The `time_created` and `time_last_updated` columns
    are the time the note was created and the time it was last synced with the Google
    servers, in the Linux epoch time. |'
  prefs: []
  type: TYPE_TB
- en: '| `reminder` | This contains data about each reminder set within the app. If
    the reminder is time based, the `julian_date` and `time_of_day` columns will be
    populated. |'
  prefs: []
  type: TYPE_TB
- en: Converting a Julian date
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Julian dates** are similar to the Linux epoch format, simply starting with
    a different date. The Julian date system counts the number of days since noon
    on January 1, 4713 BC. The United States Naval Observatory has an excellent Julian
    date calculator. To obtain the Julian date from the database, simply combine the
    two columns with a decimal in between. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Converting a Julian date](img/image00396.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding date would correspond to the Julian date 2457042.46800000\. When
    this value is input to the website, we can find out that the date the reminder
    is set for is January 19, 2015 at 23:13:55:2 UTC. The `location_name`, `latitude`,
    `longitude`, and `location_address` columns would be populated if a reminder is
    set as location based. Finally, the `time_created` and `time_last_updated` columns
    are the time the note was created and the time it was last synced with the Google
    servers, in the Linux epoch time.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The fifth data-storage method is Julian date.
  prefs: []
  type: TYPE_NORMAL
- en: Google Plus analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Google Plus is the Google-based social network. It allows us to share text/videos/images,
    add friends, follow people, and message. Google Plus may also, depending on the
    user's settings, automatically upload all pictures taken on the user's device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Package name: `com.google.android.apps.plus`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Version: 4.8.0.81189390'
  prefs: []
  type: TYPE_NORMAL
- en: 'Files of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/databases/es0.db`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Es0.db` database contains all the information an examiner would expect
    to find from a social-media account:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Table | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `all_photos` | This contains a URL to download images shared by and with
    the user as well as the creation date/time in the Linux epoch format. |'
  prefs: []
  type: TYPE_TB
- en: '| `activites` | This contains data displayed in the user''s stream (that is,
    their news feed). The created and modified time for each post is, once again,
    stored in the Linux epoch time. The title and comment columns will contain the
    post title and at least some of the comments from it. The `permalink` column contains
    a URL that can be followed to view the post, if it was shared publically. If the
    post is shared privately, the content can still be recovered from the embed table.
    The `relateds` column contains the hashtags automatically generated for the post
    by Google; this would also populate even if the post is private. |'
  prefs: []
  type: TYPE_TB
- en: '| `activity_contacts` | This contains a list of names for people whose posts
    are in the activities table. |'
  prefs: []
  type: TYPE_TB
- en: '| `all_photos` | This contains a list of *all* photos the user has backed up
    to Google Plus, whether they were shared or not. The values in the `image_url`
    column can be used to download any of the user''s photos and is publically available.
    Removing `-d` at the end of the URL will view the image without downloading it.
    The `timestamp` column is the date/time the image was taken, based on the image
    metadata. It does not indicate when the image was uploaded. |'
  prefs: []
  type: TYPE_TB
- en: '| `all_tiles` | This contains an unknown subset of `all_photos`, but also includes
    images shared with the user. |'
  prefs: []
  type: TYPE_TB
- en: '| `circle_contact` | This contains a list of people the user has added to their
    circles. It does not include names, but some of the `link_person_id` values include
    e-mail addresses. The `link_circle_id` value can be correlated with the circles
    table to identify the name of each circle. The `link_person_id` value can then
    be correlated with the `contacts` table to identify which user is in which circle.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `circles` | This has all the circles the user has created, as well as a count
    of the number of users in each one. |'
  prefs: []
  type: TYPE_TB
- en: '| `contacts` | This contains a list of all contacts in the user''s circles.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `events` | This lists all events the user has been invited to, whether they
    attended or not. The `name` column is the title of the event. The `creator_gaia_id`
    column can be correlated with the `gaia_id` column in the contacts table to identify
    the event creator. The `start_time` and `end_time` columns are the time of the
    event, in the Linux epoch format. The `event_data` column has the description
    of the event entered by the creator, as well as information about the location
    if added. It also lists all the other users who were invited to the event. |'
  prefs: []
  type: TYPE_TB
- en: '| `squares` | This contains a list of groups the user has joined. |'
  prefs: []
  type: TYPE_TB
- en: Facebook analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Facebook is a social-media application with more than 1 billion downloads from
    Google Play.
  prefs: []
  type: TYPE_NORMAL
- en: 'Package name: `com.facebook.katana`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Version: 25.0.0.19.30'
  prefs: []
  type: TYPE_NORMAL
- en: 'Files of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/files/video-cache/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/cache/images/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/databases/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bookmarks_db2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contacts_db2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nearbytiles_db`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`newsfeed_db`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`notifications_db`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prefs_db`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`threads_db2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `/files/video-cache` directory contains videos from the user's newsfeed,
    though there does not appear to be a way to correlate them back to the user who
    posted them.
  prefs: []
  type: TYPE_NORMAL
- en: The `/cache/images` directory contains images from the user's newsfeed as well
    as the profile photos of contacts. This directory contains a multitude of other
    directories (65 on our test phone), and each directory can contain multiple `.cnt`
    files. The `.cnt` files are typically `.jpg` files or other image formats.
  prefs: []
  type: TYPE_NORMAL
- en: The `bookmarks_db2` database is a list of items that appear on the side of the
    user's newsfeed, such as groups and applications. Many of these bookmarks are
    automatically generated by Facebook, but may also be created by the user.
  prefs: []
  type: TYPE_NORMAL
- en: '| Table | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `bookmarks` | This contains all of the info within the database. The `bookmark_name`
    column is the name of the bookmark displayed to the user. The `bookmark_pic` column
    has a publically accessible URL to view the `bookmark` icon displayed to the user.
    The `bookmark_type` column identifies the type of the group. Our testing showed
    `profile`, `group`, `app`, `friend_list`, `page`, and `interest_list`. Finally,
    the `bookmark_unread_count` column shows how many messages in the group have not
    been read by the user. |'
  prefs: []
  type: TYPE_TB
- en: 'The `contacts_db2` database predictably contains information about all of the
    user''s contacts stored in the following tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Table | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `contacts` | This contains all information about the user''s contacts. The
    `fbid` column is a unique ID that is used to identify the contact in other databases.
    The `first_name`, `last_name`, and `display_name` columns show the contact''s
    name. The `small_picture_url`, `big_picture_url`, and `huge_picture_url` columns
    contain public links to the contact''s profile picture. The `communication_rank`
    column appears to be a number identifying how often the contact communicates with
    the user (taking into account messages, comments, and possibly other factors);
    a higher number indicates more communication with that contact. The `added_time_ms`
    column shows the time (in the Linux epoch format) the contact was added as a friend.
    The `bday_day` and `bday_month` columns show the contact''s birth date, but not
    the year. The `data` column contains a duplicate of all the rest of the data in
    the database, but also contains the contact''s location, which is not found elsewhere
    in the database. |'
  prefs: []
  type: TYPE_TB
- en: The `nearbytiles_db` database contains locations near the user that may interest
    them. This is apparently populated constantly, even if the user does not view
    the locations. It is interesting because, while it isn't a fine location (most
    of our tests showed locations within 6–10 miles of our location), it is a rough
    idea of places a user has been.
  prefs: []
  type: TYPE_NORMAL
- en: '| Table | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `nearby_tiles` | This contains the `latitude` and `longitude` values for
    locations near the user, as well as the time the location was retrieved from the
    Facebook servers in the Linux epoch format. |'
  prefs: []
  type: TYPE_TB
- en: 'The `newsfeed_db` database contains data shown to the user in their newsfeed.
    Depending on the usage of the app, it can be a very large file containing the
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Table | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `home_stories` | The `fetched_at` column shows the time the story was pulled
    from the Facebook servers and likely corresponds closely with the time the user
    was using the application or saw the story. The `story_data` column contains the
    story stored as a blob of data. When viewed in a hex or text editor, the username
    of the person posting the story can be found. The content of the post can also
    be found in plain text and is often preceded by a tag that says `text`. An example
    of this is shown in the following screenshot. |'
  prefs: []
  type: TYPE_TB
- en: '![Facebook analysis](img/image00397.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the actual content of this one cell in the `story_data` column. It
    contained over 10,000 bytes of data, though the actual message is only around
    50 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `notifications_db` database contains notifications sent to the user stored
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Table | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `gql_notifications` | The `seen_state` column shows whether or not the notification
    has been seen and read. The `updated` column contains the time the notification
    was updated (that is, sent if it is unread or the time it was read) in the Linux
    epoch format. The `gql_payload` column contains the content of the notification
    as well as the sender, similar to the `story_data` column in `newsfeed_db`. The
    message content again is frequently preceded by the flag `text`. A much smaller
    amount of data showing the text of the notification can be found in the `summary_graphql_text_with_entities`
    and `short_summary_graphql_text_with_entities` columns. The `profile_picture_uri`
    contains a public URL to view the sender''s profile picture, and the `icon_url`
    column has a link to view the icon associated with the notification. |'
  prefs: []
  type: TYPE_TB
- en: 'The `prefs_db` database contains application preferences stored as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Table | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `preferences` | The `/auth/user_data/fb_username` row shows the user''s Facebook
    username. The `/config/gk/last_fetch_time_ms` value is the timestamp of the app''s
    last communication with Facebook servers, but may not be an exact time of the
    user''s last interaction with the app. The `/fb_android/last_login_time` value
    shows the last time the user logged in through the app. The database contains
    many other timestamps. When put together, these timestamps can be used to build
    a decent profile of the app''s usage. The `/auth/user_data/fb_me_user` value contains
    data about the user, including their name, e-mail address, and phone number. |'
  prefs: []
  type: TYPE_TB
- en: 'The `threads_db` database contains messaging information described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Table | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `messages` | Each message has a unique ID in the `msg_id` column. The `text`
    column contains the message in plain text. The `sender` column identifies the
    Facebook ID and name of the message sender. The `timestamp_ms` column is the time
    the message was sent, in the Linux epoch format. The `attachments` column contains
    a public URL to retrieve attached images. The `coordinates` column would have
    the sender''s latitude and longitude if they have opted to show their location.
    The `source` column identifies whether the message was sent via the website or
    app. |'
  prefs: []
  type: TYPE_TB
- en: Facebook Messenger analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Facebook Messenger is a messaging app separate from the main Facebook application.
    It has over 500,000,000 downloads in the Play Store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Package name: `com.facebook.orca`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Version: 18.0.0.27.14'
  prefs: []
  type: TYPE_NORMAL
- en: 'Files of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/cache/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`audio/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fb_temp/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`image/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sdcard/com.facebook.orca`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/files/ rti.mqtt.analytics.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/databases/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`call_log.sqlite`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contacts_db2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prefs_db`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`threads_db2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `/cache/audio` directory contains audio messages sent through the application.
    The files have a `.cnt` file extension, but are actually `.riff` files that can
    be played with Windows Media Player, VLC media player, and other programs.
  prefs: []
  type: TYPE_NORMAL
- en: The `/cache/fb_temp` path contains temp files for images and video sent through
    the application. It is unclear how long these files will remain. In our testing,
    we sent and received a total of five files, and all five were still in the temp
    folder one week later.
  prefs: []
  type: TYPE_NORMAL
- en: The `/cache/image` directory contains a multitude of other directories (33 on
    our test phone), and each directory can contain multiple `.cnt` files. The file
    header should be verified on each file, as some were video files and some were
    images. Several of the files from the `fb_temp` folder were found, as well as
    the profile pictures of some contacts.
  prefs: []
  type: TYPE_NORMAL
- en: The `fb_temp` folder on the SD card contains sent images and video only.
  prefs: []
  type: TYPE_NORMAL
- en: The application also includes an option (disabled by default) to download all
    the received images/video to the device's gallery. If this option is selected,
    all received images/video would be found on the SD card.
  prefs: []
  type: TYPE_NORMAL
- en: The `/files/rti.mqtt.analytics.xml` file has the user's Facebook UID.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `call_log.sqlite` database contains a log of calls made through the application.
    The `person_summary` table contains the relevant data described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Table | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `person_summary` | The `user_id` column contains the Facebook ID of the remote
    user. This can be correlated with the `fbid` column in `contacts_db2` to determine
    the user''s name. The `last_call_time` column contains the time of the previous
    call in the Linux epoch format. This table does not contain information about
    the direction of the call (sent or received). |'
  prefs: []
  type: TYPE_TB
- en: 'The `contacts_db2` file is a SQLite database, despite the lack of a file extension.
    Useful tables within this database include the following ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Table | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `contacts` | This table includes the contacts the user has added, as well
    as the contacts that were scraped from the user''s phone book (if the phone book
    contact uses Facebook Messenger). It contains the first and last names of each
    contact, as well as that contact''s Facebook ID (as discussed in the `call_log.sqlite`
    table earlier). The `added_time_ms` column shows the time each user was added
    into the app. This can give some insight into whether the contact was added manually
    or automatically. A large group of contacts added within milliseconds of each
    other were likely created automatically when the app was installed. The `small_picture_url`,
    `big_picture_url`, and `huge_picture_url` columns contain public links to the
    contact''s profile picture. A contact''s phone number can be found in the blob
    of information within the data column.It should be noted that we have no idea
    where some of the contacts in this database came from. They were not Facebook
    friends with our account and were not contacts in our device''s phone book, but
    were added at the same time that the phone book was scraped. Our best guess is
    that some contacts in our phone have phone numbers that Facebook associated with
    other users. |'
  prefs: []
  type: TYPE_TB
- en: '| `favorite_contacts` | The `favorite_contacts` table shows contacts that have
    been added as favorites by the user. They are identified by the `fbid` column,
    which can be correlated back to the contacts table. |'
  prefs: []
  type: TYPE_TB
- en: 'The `prefs_db` database contains useful metadata about the app and the account:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Table | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `preferences` | The `/messenger/first_install_time` value indicates the time
    the application was installed, in the Linux epoch time. The `/auth/user_data/fb_username`
    value shows the username associated with the application. The `/config/neue/validated_phonenumber`
    value shows the phone number associated with the application. The users first
    and last names can be found in the `/auth/user_data/fb_me_user` value. |'
  prefs: []
  type: TYPE_TB
- en: 'Finally, the `threads_db2` database contains data about messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Table | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `group_clusters` | This shows folders the user has created. |'
  prefs: []
  type: TYPE_TB
- en: '| `group_conversations` | This contains the `thread_key` value for each group
    chat. This can be correlated with the `messages` table. |'
  prefs: []
  type: TYPE_TB
- en: '| `messages` | The `thread_key` value is a unique ID generated for each chat
    session. The `text` column has the contents of each text message sent and received.
    This also identifies voice calls using the phrases "You called Facebook User.",
    "Facebook User called you.", and "You missed a call from Facebook User.". The
    `sender` column identifies which user sent each message (or made each call). The
    `timestamp_ms` column shows the time each message was sent, in the Linux epoch
    format. The `attachments` column will show data for each sent or received attachment.
    The file type is also visible in the data. The `pending_send_media_attachment`
    column shows the path on the device to recover sent attachments. Finding received
    attachments directly does not appear possible, although they were recovered in
    the `/cache/images` directory discussed earlier. There was no way to correlate
    them with a specific message or sender. |'
  prefs: []
  type: TYPE_TB
- en: Skype analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Skype is a voice-/video-calling app, as well as a messaging app owned by Microsoft.
    It has over 100,000,000 installs on Google Play.
  prefs: []
  type: TYPE_NORMAL
- en: 'Package name: `com.skype.raider`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Version: 5.1.0.58677'
  prefs: []
  type: TYPE_NORMAL
- en: 'Files of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/cache/skype-4228/DbTemp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sdcard/Android/data/com.skype.raider/cache/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/files/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shared.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<username>/thumbnails/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<username>/main.db`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<username>/chatsync`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `/cache/skype-4228/DbTemp` directory contained multiple files with no extension.
    One of these files (`temp-5cu4tRPdDuQ3ckPQG7wQRFgU` on our device) was actually
    a SQLite database that contained the SSID and **Media Access Control** (**MAC**)
    of the wireless access points it had been connected to.
  prefs: []
  type: TYPE_NORMAL
- en: The SD card path will contain any images or files received in a chat. If a file
    is downloaded, it would be in the `Downloads` folder in the root of the SD.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `shared.xml` file listed the account''s username as well as the last IP
    address that connected to Skype:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Skype analysis](img/image00398.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The `<username>/thumbnails` directory contained the user's profile picture.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main.db` database, like it sounds, contains the app usage history. Some
    important tables to look at are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Table | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Accounts` | This shows the accounts used on the device and the associated
    e-mail addresses. |'
  prefs: []
  type: TYPE_TB
- en: '| `CallMembers` | This includes call logs from the app. The `duration` table
    is the duration of the call, and the `start_timestamp` column is the start time
    in the Linux epoch format; neither of these columns is populated if the call is
    not answered. The `creation_timestamp` column is the actual beginning of the call.
    It is populated as soon as the call is initiated within the app, so even unanswered
    calls are shown in this column. The `ip_address` column shows the IP address of
    the user for connected calls. The `type` column indicates whether the call was
    outgoing or incoming (1=incoming, 2=outgoing). The `guid` column also shows the
    direction of the call, listing each participant from left to right, with the user
    on the left-hand side being the one who initiated the call. The `call_db_id` column
    can be correlated with the `Calls` table to find further information about the
    call. |'
  prefs: []
  type: TYPE_TB
- en: '| `Calls` | This is very similar to `CallMembers`, but with less information.
    It is worth noting that the `begin_timestamp` column in this table is identical
    to `creation_timestamp` in `CallMembers`. There is an `is_incoming` column to
    show the direction of the call; `0` indicates outgoing, and `1` indicates incoming.
    Finally, it should be noted that the duration of some calls did *not* match the
    `CallMembers` table. One of the durations was a second longer than the other table
    indicated. It appears that the `CallMembers` table calculates duration based on
    `start_timestamp`, while the `Calls` table calculates duration based on `begin_timestamp`.
    The difference in duration is likely caused by the amount of time it took the
    user to accept the call. |'
  prefs: []
  type: TYPE_TB
- en: '| `ChatMembers` | This shows the users in each chat. The `adder` column lists
    the user that initiated the chat. |'
  prefs: []
  type: TYPE_TB
- en: '| `Chats` | This lists each unique chat session. The `timestamp` column is
    the date/time the conversation began, in the Linux epoch format. The `dialog_partner`
    column shows users in the chat, excluding the account on the device. The `posters`
    column shows every user who has made a comment in the chat and includes the account
    on the device if it has posted. The `participants` column is similar to the `dialog_partner`
    column, but includes the user''s account. Finally, the `dbpath` column contains
    the name of the chat backup file found in the `<username>/chatsync` directory.
    This will become important further in this analysis. |'
  prefs: []
  type: TYPE_TB
- en: '| `Contacts` | This is actually a very misleading table. In our test, we added
    two users to our contact list; the `Contacts` table has 233 entries! The `is_permanent`
    column indicates the status of the users listed in this table; if it is `1`, the
    user would be added as an actual contact within the application. The other 231
    entries appear to be names that came up in results when we searched for contacts,
    but we never communicated with or added them. |'
  prefs: []
  type: TYPE_TB
- en: '| `Conversations` | We have no idea what the difference between `Conversations`
    and `Chats` is. They mostly contain the same information and, in fact, appear
    to be referencing the same chat sessions. |'
  prefs: []
  type: TYPE_TB
- en: '| `Messages` | This contains every individual message from chats/conversations.
    The `convo_id` column has a unique value for each conversation; any messages with
    the same `convo_id` value are from the same conversation. The `author` and `from_dispname`
    columns show who wrote each message. The `timestamp` column, once again, shows
    the date/time of the message in the Linux epoch format. The `type` column indicates
    the type of message that was sent. Here are the values from our testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '`50`: friend request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`51`: request accepted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`61`: plain text message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`68`: file transfer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`30`: call begin (voice or video)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`39`: call end (voice or video)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`70`: video message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `body_xml` column has the content of the message. For plain-text messages
    and friend requests, the content is simply what the message said. File transfers
    show the size and name of the file. Video messages say that they are video messages,
    but provide no other information. Calls would show the duration if it was connected,
    and no duration if they were missed/ignored. The `identities` column shows who
    sent each message, but may be blank if it was sent by the user account on the
    device. The `reason` column appears to be for calls and shows either `no_answer`
    or `busy` to explain why a call was not connected. |
  prefs: []
  type: TYPE_NORMAL
- en: '| `Participants` | This is similar to `ChatMembers`. It shows each user involved
    with a chat/conversation. |'
  prefs: []
  type: TYPE_TB
- en: '| `SMSes` | Our testing did not include SMS messaging. However, each column
    in this table appears self-explanatory. |'
  prefs: []
  type: TYPE_TB
- en: '| `Transfers` | This shows information about files transferred. This includes
    the filename, size, and path on the device. The `partner_dispname` column identifies
    which user began the file transfer. |'
  prefs: []
  type: TYPE_TB
- en: '| `VideoMessages` | This shows the author and creation timestamp of video messages.
    Note that video messages are *not* stored on the device. Accessing them will be
    covered in a separate section later on in the chapter. |'
  prefs: []
  type: TYPE_TB
- en: '| `VoiceMails` | Our testing did not include voice mails. However, each column
    in this table appears self-explanatory. |'
  prefs: []
  type: TYPE_TB
- en: Recovering video messages from Skype
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As noted earlier, video messages are not stored on the device. Luckily, for
    us, they can be accessed via the Internet. The first step is to verify that a
    video message was sent by looking in the `Messages` table in the `body_xml` column.
    Next, note the `convo_id` field for the message shown in the following screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Recovering video messages from Skype](img/image00399.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Our video message is in `convo_id` `257`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Third, look in the `Chats` table for `convo_id` in the `conv_dbid` column and
    find the `dbpath` value. This will be the name of the conversation''s backup file
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Recovering video messages from Skype](img/image00400.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: To find the backup file, look in `files/<username>/chatsync`. There will be
    a folder for each conversation; the name of the folder is the first two digits
    of the backup name. Our backup will be in folder `28`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the backup file in a hex editor, and search for `videomessage`. You should
    find a URL and a code to access the video:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Recovering video messages from Skype](img/image00401.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Actually, accessing the URL may require an additional warrant or legal permission,
    depending on your local jurisdiction. As this data is not on the device and is
    private, viewing it without legal guidance could invalidate any evidence found
    in the video.
  prefs: []
  type: TYPE_NORMAL
- en: Snapchat analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Snapchat is an image-sharing and text-messaging service with over 100,000,000
    downloads. Its signature feature is that images and videos sent will "self-destruct"
    after a time limit set by the sender, from 1-10 seconds. Furthermore, if a user
    takes a screenshot of the image, the sender is notified. Text chats do not have
    an expiration timer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Package name: `com.snapchat.android`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Version: 8.1.2'
  prefs: []
  type: TYPE_NORMAL
- en: 'Files of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/cache/stories/received/thumbnail/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sdcard/Android/data/com.snapchat.android/cache/my_media/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/shared_prefs/com.snapchat.android_preferences.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/databases/tcspahn.db`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `/cache/stories/received/thumbnail` path contains thumbnails of pictures
    taken by the user on the device. The `/sdcard` path contains full-sized images.
    These remain even after the time limit has expired, and the recipient can no longer
    access them. The files in both of these locations may not have proper file extensions.
  prefs: []
  type: TYPE_NORMAL
- en: The `com.snapchat.android_preferences.xml` file contains the e-mail address
    used to create an account and the phone number of the device registered with the
    account.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `tcspahn.db` database contains all other information about the app''s usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Table | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Chat` | This lists all text chats. It shows the sender, recipient, and timestamp
    in the Linux epoch time and the text of the message. |'
  prefs: []
  type: TYPE_TB
- en: '| `ContactsOnSnapchat` | This shows all the users in the user''s phonebook
    who also have Snapchat installed. The `isAddedAsFriend` column would show a `1`
    value if the user has actually been added as a contact. |'
  prefs: []
  type: TYPE_TB
- en: '| `Conversation` | This has information about each open conversation. It includes
    the sender and recipient and the timestamp of the last sent and received snaps
    in the Linux epoch format. |'
  prefs: []
  type: TYPE_TB
- en: '| `Friends` | This is similar to `ContactsOnSnapchat`, but only includes users
    who have been added as a friend. It includes the timestamp when each user added
    the other. |'
  prefs: []
  type: TYPE_TB
- en: '| `ReceivedSnaps` | This contains metadata about received images and videos.
    Once the image/video is viewed, it appears to be removed from this table at some
    point. It contains a timestamp for each message, a status, information whether
    or not a snap was screenshot, and the sender. |'
  prefs: []
  type: TYPE_TB
- en: '| `SentSnaps` | This contains metadata about sent images and videos. Once the
    image/video is viewed, it appears to be removed from this table at some point.
    It contains a timestamp for each message, a status, and the recipient. |'
  prefs: []
  type: TYPE_TB
- en: Viber analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Viber is a messaging and voice-/video-calling app with over 100,000,000 downloads.
  prefs: []
  type: TYPE_NORMAL
- en: 'Package name: `com.viber.voip`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Version: 5.2.1'
  prefs: []
  type: TYPE_NORMAL
- en: 'Files of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/files/preferences/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`activated_sim_serial`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`display_name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reg_viber_phone_num`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sdcard/viber/media/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/User Photos/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/Viber Images/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/Viber Videos/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/databases/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`viber_data`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`viber_messages`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The files in `/files/preferences` contain the SIM card's **Integrated Circuit
    Card ID** (**ICCID**), the name the user displays in the app, and the phone number
    used to register with the app.
  prefs: []
  type: TYPE_NORMAL
- en: The files in the `/sdcard/viber/media` path are the profile photos of people
    in the user's contact list who use Viber (regardless of whether they have been
    added as friends in the app) and all images and video sent through the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `viber_data` file is a database, even though it does not have the `.db`
    file extension. It contains information about the user''s contacts:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Table | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `calls` | This table did not populate, even though we made calls from within
    the app. |'
  prefs: []
  type: TYPE_TB
- en: '| `phonebookcontact` | This table could be extremely valuable from a forensic
    standpoint. When Viber is first opened, it scrapes the user''s phonebook and adds
    all the entries it finds to this database. This means it may contain historical
    data about the user''s contacts. If he later deletes an entry from the phone book,
    it may still be recovered in this database. This table only includes names of
    contacts in the phonebook. |'
  prefs: []
  type: TYPE_TB
- en: '| `phonebookdata` | This is similar to phonebook contact, except that it includes
    e-mail addresses and phone numbers for contacts in the device''s phonebook. |'
  prefs: []
  type: TYPE_TB
- en: '| `vibernumbers` | This shows the Viber phone number for each contact in the
    device''s phonebook that uses the app. The value in `actual_photo` corresponds
    with the filenames in the `/sdcard/viber/media/User Photos` directory. |'
  prefs: []
  type: TYPE_TB
- en: 'The `viber_messages` file is a database, even though it does not have the `.db`
    file extension. It contains information about the app''s usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Table | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `conversations` | This contains a unique ID, the recipient, and date for
    each unique conversation. |'
  prefs: []
  type: TYPE_TB
- en: '| `messages` | This contains each individual message from all conversations.
    The address is the phone number of the remote party in the conversation. The `date`
    column is in the Linux epoch format. The `type` column corresponds to incoming
    or outgoing; `1` is an outgoing message, and `0` is incoming. The `location_lat`
    and `location_lng` columns will be populated if a location is shared. Shared files
    can be sent with text to describe them; this is found in the `description` column.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `messages_calls` | This table did not populate, even though we made calls
    from within the app. |'
  prefs: []
  type: TYPE_TB
- en: '| `participants_info` | This has the profile information for each account that
    has been in a conversation with the user. |'
  prefs: []
  type: TYPE_TB
- en: Tango analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tango is a voice-/text-/video-messaging application. It has over 100,000,000
    downloads in the Play Store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Package name: `com.sgiggle.production`'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This package name is seemingly innocuous and could be overlooked by an examiner
    thinking it was a game. This is an example of why every application should be
    analyzed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Version: 3.13.128111'
  prefs: []
  type: TYPE_NORMAL
- en: 'Files of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/sdcard/Android/data/com.sgiggle.production/files/storage/appdata/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TCStorageManagerMediaCache_v2/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`conv_msg_tab_snapshots/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/files/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tc.db`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`userinfo.xml.db`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `/TCStorageManagerMediaCache_v2` path on the SD card contains images that
    were sent and received with the application as well as profile pictures of contacts.
    However, it also contains many images that were never seen or used in the application.
    They appear to either be images for ads or stock emoji-type images that can be
    attached to conversations. The filenames found here can be correlated with `tc.db`
    to find the exact image that was used in a conversation.
  prefs: []
  type: TYPE_NORMAL
- en: The `conv_msg_tab_snapshots` path on the SD card contains files with a `.dat`
    extension. When viewed in a hex editor, we were able to find snippets of conversations
    in plain text, as well as paths and URLs to images sent and received in conversations.
    It is unclear what causes these files to exist, but it may be possible to retrieve
    content from these files that may have been deleted in `tc.db`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `tc.db` database is what Tango uses to store all message information:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Table | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `conversations` | This contains a unique ID in the `conv_id` column for each
    conversation. |'
  prefs: []
  type: TYPE_TB
- en: '| `messages` | This contains messages sent and received through the app. The
    `msg_id` column is a unique identifier for each message, and the `conv_id` column
    identifies which conversation the message is from. The `send_time` column identifies
    the time a message was sent or when it was received, depending on the direction.
    The `direction` column shows the direction of the message; `1` = sent and `2`
    = received. The `type` column identifies the type of the message. Based on our
    testing, they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0` = plain text message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1` = video message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2` = audio message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3` = image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`4` = location/coordinates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`35` = voice call'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`36` = attempted voice call (missed by either party)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`58` = attached stock image, such as the emojis found in the TCStorageManagerMediaCache_v2
    path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the `payload` column contains the content of the message. The data
    is Base64 encoded, which will be discussed in detail in the following section.
    |
  prefs: []
  type: TYPE_NORMAL
- en: The `user_info_xml.db` database contains metadata about the account, such as
    the user's name and phone number. However, its data is entirely Base64 encoded,
    like the messages in `tc.db`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next data-storage method is Base64.
  prefs: []
  type: TYPE_NORMAL
- en: Decoding Tango messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Base64 is an encoding scheme that is commonly used for data transport. It is
    not considered encryption, because it has a known method for decoding and does
    not require a unique key to decode the data. Base64 contains ASCII-printable characters,
    but the underlying data is binary (which will make our output somewhat messy!).
    An example from the `payload` column in the `messages` table of `tc.db` looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`EhZtQzVtUFVQWmgxWnNRUDJ6aE44cy1nGAAiQldlbGNvbWUgdG8gVGFuZ28hIEhlcmUncyBob3cgdG8gY29ubmVjdCwgZ2V0IHNvY2lhbCwgYW5kIGhhdmUgZnVuIYABAKoBOwoFVGFuZ28SABoWbUM1bVBVUFpoMVpzUVAyemhOOHMtZyILCgcKABIBMRoAEgAqADD///////////8BsAHYioX1rym4AYKAgAjAAQHQAQDoAdC40ELIAgTQAgDqAgc4MDgwODg5yAMA2AMA2AXTHw==`'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The equal signs at the end of our message. This is a strong indicator that the
    data is Base64 encoded. The input that will be encoded needs to be divisible by
    3, for the math behind Base64 to work properly. If the input is not divisible
    by 3, it would be padded, resulting in the equal signs seen in the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Input string | Number of characters/bytes | Output |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Hello`, `World` | 12 | `SGVsbG8sIFdvcmxk` |'
  prefs: []
  type: TYPE_TB
- en: '| `Hello, World!` | 13 | `SGVsbG8sIFdvcmxkIQ==` |'
  prefs: []
  type: TYPE_TB
- en: '| `Hello, World!!` | 14 | `SGVsbG8sIFdvcmxkISE=` |'
  prefs: []
  type: TYPE_TB
- en: You can see that the 12-byte input (divisible by 3) has no padding, while the
    other two inputs have padding because they are not divisible by 3\. This is important
    because it shows that while the equal signs are a strong indicator of Base64,
    the lack of an equal sign does not mean it isn't Base64!
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand a little about Base64 and recognize that our `payload`
    column is very likely encoded in Base64, we need to decode it. There are websites
    that will allow the user to paste in encoded data, and it will be decrypted (such
    as [www.base64decode.org](http://www.base64decode.org)). However, it is inconvenient
    for large amount of data as each message must be input individually (and putting
    evidentiary data on the Internet is also frowned upon in most cases). Likewise,
    it can be decoded on the command line of Linux-based systems, but is equally inconvenient
    for large amounts of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our solution was to build a Python script that pulls the Base64 data from the
    database, decodes it, and writes it back out to a new file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the code, simply paste this code into a new file named `tcdb.py`, place
    the script in the same directory as `tc.db`, and on the command line, navigate
    to that directory and run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The script will make a file named `tcdb_out.txt` in the same directory. Opening
    the file in a text editor (or importing it into Excel as a tab-delimited file)
    will show the `msg_id` value so that the examiner can correlate the message back
    to the messages table. The decoded payload shows a plain text message (noted as
    type `0` in the database):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Decoding Tango messages](img/image00402.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the message content is now visible in plain text and is preceded by
    the conversation ID. There is also a ton of binary data cluttering up our output;
    this is likely metadata or other information used by Tango. If the message was
    received, the user's name will also be in the output (above it is Tango).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other message types worth looking at, also. Here is a decoded payload
    entry for a video message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Decoding Tango messages](img/image00403.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note that with the video message, we can see two URLs. They are both public,
    meaning anyone with the link can access them. The URL ending in thumbnail is a
    thumbnail of the video, while the other URL will download the complete video in
    the `.mp4` format. The path to the SD card and filename for the image is also
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: Image and audio messages are stored in a very similar format and contain URLs
    to either view or download the file. They also contain the path to the file on
    the SD card.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a sample location message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Decoding Tango messages](img/image00404.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This time, we can see the exact coordinates the user was at as well as the address.
    Again, a path on the SD card is also present and will show the map view of the
    location. As with other message types, a received message would also show the
    sender's name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s take a look at the `userinfo.xml.db` database. Here is what
    it looks like before being decoded properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Decoding Tango messages](img/image00405.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We wrote another script very similar to the first to parse the `userinfo.xml.db`
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The only difference in the code is that the filenames, table names, and values
    changed. This time, both the columns in the database are base64 encoded. Again,
    the code can be run by placing it in the same location as `userinfo.xml.db` and
    running it using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the relevant portion of the resulting output file, showing the personal
    data the user used to register the account:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Decoding Tango messages](img/image00406.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Further down in the output, there is also a list of all of the user's contacts
    who use Tango. The output also includes the contacts' names and phone numbers.
  prefs: []
  type: TYPE_NORMAL
- en: WhatsApp analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WhatsApp is a popular chat-/video-messaging service with over 500,000,000 downloads
    in Google Play.
  prefs: []
  type: TYPE_NORMAL
- en: 'Package name: `com.whatsapp`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Version: 2.11.498'
  prefs: []
  type: TYPE_NORMAL
- en: 'Files of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/files/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Avatars/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`me`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`me.jpeg`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/shared_prefs/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RegisterPhone.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VerifySMS.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/databases/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`msgstore.db`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wa.db`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sdcard/WhatsApp/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Media/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Databases/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `/files/avatars` directory contains thumbnails of the profile pictures of
    contacts that use the app, and `me.jpg` is a full-size version of the user's profile
    picture. The `me` file contains the phone number associated with the account
  prefs: []
  type: TYPE_NORMAL
- en: The phone number associated with the account can also be recovered in `/shared_prefs/RegisterPhone.xml`.
    The `/shared_prefs/VerifySMS.xml` file shows the time that the account was verified
    (in the Linux epoch format, of course), indicating when the user first began using
    the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `msgstore.db` database, like it sounds, contains messaging data:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Table | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `chat_list` | The `key_remote_jid` column shows each account the user has
    communicated with. The value in the table is the remote user''s phone number.
    For example, if the value is `13218675309@s.whatsapp.net`, the remote user''s
    number is `1-321-867-5309`. |'
  prefs: []
  type: TYPE_TB
- en: '| `group_participants` | This contains metadata about group chats. |'
  prefs: []
  type: TYPE_TB
- en: '| `messages` | This shows all the message data. Once again, the `key_remote_jid`
    field identifies the remote sender. The `key_from_me` value indicates the direction
    of the message (`0` = received, and `1` = sent). The data column contains the
    text of messages, and timestamp is the sent or received time in the Linux epoch
    format.For attachments, `media_mime_type` identifies the file format. The `media_size`
    and `media_name` columns should be self-explanatory. If the attachment had a caption,
    the text would be shown in the `media_caption` column. If the attachment was a
    location, the `latitude` and `longitude` columns would be populated appropriately.
    The `thumb_image` column has a lot of useless data in it, but also contains the
    path of the attachment on the device. The `raw_data` column contains thumbnails
    for images and videos. |'
  prefs: []
  type: TYPE_TB
- en: 'The `wa.db` database is used to store contact information:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Table | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `wa_contacts` | Like other apps, WhatsApp scrapes and stores the user''s
    entire phone book and stores the information in its own database. It contains
    the contacts'' names and phone numbers, as well as their statuses if the contacts
    are WhatsApp users. |'
  prefs: []
  type: TYPE_TB
- en: The SD card is a treasure trove of WhatsApp data. The `/sdcard/WhatsApp/Media`
    folder contains a folder for each type of media (Audio, Calls, Images, Video,
    and Voice Notes), and stores all attachments of that type in the folder. Sent
    media is stored in a directory called, unimaginatively, `Sent`. Received media
    is simply stored in the root of the folder.
  prefs: []
  type: TYPE_NORMAL
- en: The `Databases` directory is an even greater source of information. WhatsApp
    makes a backup of `msgstore.db` nightly and stores the backups here. This allows
    an examiner to see historical data that may have been deleted. If I delete a chat
    today, but you look at a backup from yesterday, you would be able to access the
    data I deleted. The app is even kind enough to put the date in the filename, for
    example, `msgstore-2015-01-21.1.db`. The only catch is that these backups are
    encrypted!
  prefs: []
  type: TYPE_NORMAL
- en: Decrypting WhatsApp backups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Luckily, there is a tool available to decrypt the backups. It can be found here,
    along with detailed installation instructions at [http://forum.xda-developers.com/showthread.php?t=1583021](http://forum.xda-developers.com/showthread.php?t=1583021).
    Unfortunately, it hasn't been updated in some time and doesn't seem to work on
    newer versions of the app.
  prefs: []
  type: TYPE_NORMAL
- en: We are not aware of an easy, automated extraction tool for newer versions of
    WhatsApp. However, with the version of WhatsApp we tested, we had great success
    using the instructions at [http://forum.xda-developers.com/android/apps-games/how-to-decode-whatsapp-crypt8-db-files-t2975313](http://forum.xda-developers.com/android/apps-games/how-to-decode-whatsapp-crypt8-db-files-t2975313).
    Note that this must be done on a Linux computer. Once the steps have been successfully
    followed, the result should be a database identical to `msgstore.db` explained
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: This is possible because WhatsApp stores the decryption key on the device, in
    the `/files` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Data storage method 7 is using encrypted files.
  prefs: []
  type: TYPE_NORMAL
- en: Kik analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kik is a messaging app with over 50,000,000 downloads from the Play Store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Package name: `kik.android`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Version: 7.9.0'
  prefs: []
  type: TYPE_NORMAL
- en: 'Files of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/cache/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chatPicsBig/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contentpics/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`profPics/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/files/staging/thumbs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/shared_prefs/KikPreferences.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sdcard/Kik/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/databases/kikDatabase.db`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `chatPicsBig` and `contentpics` directories in `/cache` contain images that
    were sent and received with the application. The files in `contentpics` contain
    what appears to be Kik metadata embedded before the image. The `.jpg` has to be
    carved out of these files. In our testing, all of the files in `contentpics` were
    also stored in `chatPicsBig`, though this may change with more extensive app usage.
    The user's profile picture is found in the `/profPics` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Data storage method 8 is using basic steganography, which means, a file is stored
    within a larger file.
  prefs: []
  type: TYPE_NORMAL
- en: The `/files/staging/thumbs` directory contains thumbnails of images sent and
    received with the application. Our testing found the same images in this location
    as the `/cache` directories, but again, it is possible this would vary with more
    extensive application usage.
  prefs: []
  type: TYPE_NORMAL
- en: The `KikPreferences.xml` file in `/shared_prefs` shows the user's username and
    e-mail address used with the application. Interestingly, it also contains an unsalted
    SHA1 hash of the user's password.
  prefs: []
  type: TYPE_NORMAL
- en: The `/sdcard/Kik` directory contains full-sized images that were sent and received
    in the application. The filenames can be correlated with `messagesTable` in the
    `kikDatabase.db` database to identify which message contained the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `kikDatabase.db` database contains all of the messaging data from the application
    stored in the following tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Table | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `KIKContentTable` | This table contains metadata about sent and received
    images. Each message is assigned a unique `content_id` value that corresponds
    to the filenames in the `sdcard/Kik` directory. The preview and icon values for
    each image correspond to the filenames found at `/files/staging/thumbs`. Each
    image also contains a `file-URL` value. This is a public URL that can be accessed
    to view the file. |'
  prefs: []
  type: TYPE_TB
- en: '| `KIKcontactsTable` | This table shows the `user_name` and `display_name`
    values for each contact. The `in_roster` value appears to be set for contacts
    the user has specifically added (if it is set to `1`). Contacts with an `in_roster`
    value of `0` appear to be default contacts added automatically. The `jid` column
    is a unique value for each contact. |'
  prefs: []
  type: TYPE_TB
- en: '| `messagesTable` | This table contains all data for messages sent and received
    with the app. The `body` column shows the text data sent in a message. The `partner_jid`
    value can be correlated back to the `jid` column in `KIKcontactTable` to identify
    the remote user. The `was_me` column is used to indicate the direction of the
    message (`0` = sent, and `1` = received). The `read_state` column shows whether
    the message has been read or not; `500` = read and `400` = unread. The timestamp,
    yet again, is in the Linux epoch format. The `content_id` column is populated
    for message attachments and can be correlated back to `KIKContentTable` for more
    information. |'
  prefs: []
  type: TYPE_TB
- en: WeChat analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WeChat is a messaging app with over 100,000,000 downloads in the Play Store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Package name: `com.tencent.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Version: `6.0.2`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Files of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some of the following paths contain an asterisk (*). This is used to indicate
    a unique string that will differ for each account. Our device had `7f804fdbf79ba9e34e5359fc5df7f1eb`
    in place of the asterisk.
  prefs: []
  type: TYPE_NORMAL
- en: '`/files/host/*.getdns2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/shared_prefs/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`com.tencent.mm_preferences.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`system_config_prefs.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sdcard/tencent/MicroMsg/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`diskcache/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WeChat/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sdcard/tencent/MicroMsg/*/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`image2/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`video/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`voice2/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/MicroMsg/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CompatibleInfo.cfg`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*/EnMicroMsg.db`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `*.getdns2` files found in `/files/host` can be opened as text files or
    in a hex editor. There is a section called [`clientip`] that shows the IP address
    from which the user connected as well as the time of the connection in the Linux
    epoch format. Our device contained three of these files to show three different
    connections, though increased application usage may generate more than three of
    these files.
  prefs: []
  type: TYPE_NORMAL
- en: The `com.tencent.mm_preferences.xml` file in `/shared_prefs` records the device's
    phone number in the `login_user_name` field. The `system_config_prefs.xml` file
    contains the path to the user's profile picture on the device as well as a `default_uin`
    value that will be needed later.
  prefs: []
  type: TYPE_NORMAL
- en: The SD card contains a wealth of WeChat data. The `/tencent/MicroMsg/diskcache`
    directory contained an image that was never used with the application. We think
    it was put there when attaching a different image as WeChat loads a view of many
    images from the device's gallery. The `/WeChat` directory within `/sdcard/tencent/MicroMsg`
    contained images sent from the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `/video`, `/voice`, and `/voice2` folders within `/sdcard/tencent/MicroMsg/*`
    contain exactly what they say: video and voice files sent using the app.'
  prefs: []
  type: TYPE_NORMAL
- en: WeChat is fairly unique, in that, it does not utilize a `/databases` directory
    within the app's directory structure. `MicroMsg` is its equivalent. `CompatibleInfo.cfg`
    contains the device's IMEI, which will be useful later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `*` directory within `/MicroMsg` contains the `EnMicroMsg.db` database.
    There''s only one problem: the database is encrypted using **SQLCipher**! SQLCipher
    is an open source extension for SQLite that encrypts the entire database. Luckily,
    like other apps that use encryption that we''ve seen, the key to decrypting the
    file is on the device.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Data storage method 9 is using SQLCipher, which involves full-database encryption.
  prefs: []
  type: TYPE_NORMAL
- en: Decrypting the WeChat EnMicroMsg.db database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fortunately for us, Forensic Focus has an excellent article on doing exactly
    this at [http://articles.forensicfocus.com/2014/10/01/decrypt-wechat-enmicromsgdb-database/](http://articles.forensicfocus.com/2014/10/01/decrypt-wechat-enmicromsgdb-database/).
  prefs: []
  type: TYPE_NORMAL
- en: They even provide a Python script to do the work for us at [https://gist.github.com/fauzimd/8cb0ca85ecaa923df828/download#](https://gist.github.com/fauzimd/8cb0ca85ecaa923df828/download#).
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the Python script, simply put the EnMicroMsg.db file and the system_config_prefs.xml
    files in the same directory as the script and, in the command-line, type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The script will then prompt you for the **International Mobile Station Equipment
    Identity** (**IMEI**) of the device. This can be found in the `/MicroMsg/CompatibleInfo.cfg`
    file, printed somewhere on the device (behind the battery, on the SIM card tray
    or etched on the back of the device), or by typing `*#06#` in the phone dialer.
  prefs: []
  type: TYPE_NORMAL
- en: The script should run. Place a file called `EnMicroMsg-decrypted.db` in the
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can now examine the `EnMicroMsg-decrypted.db` database with respect
    to the following tables stored in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Table | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ImgInfo2` | This contains path information for sent and received images.
    The `bigImgPath` column contains the filename for the image. This can be searched
    on the SD card to find the picture. Alternatively, images are stored in the `/sdcard/tencent/MicroMsg/*/image2`
    directory in folders that correspond to the filename. For example, the file named
    `3b9edb119e04869ecd7d1b21a10aa59f.jpg` can be found in the `image2` directory
    in the `/3b/9e` path. The folders are broken down by the first 2 bytes of the
    name and then by the second 2 bytes of the name. The `thumbImgPath` column contains
    the name of thumbnails for the images. |'
  prefs: []
  type: TYPE_TB
- en: '| `message` | This contains all the message information for the app. The `isSend`
    column indicates the message direction (`0` = received, `1` = sent). The `createTime`
    table is the timestamp of the message, in the Linux epoch format. The `talker`
    column contains a unique ID for the remote user. This can be correlated with the
    `rcontact` table to identify the remote user. The `content` column shows the data
    of messages sent as text and identifies video calls as "voip_content_voice". The
    `imgPath` column contains the path to image thumbnails, which can be correlated
    with the `ImgInfo2` table to locate the full-sized images. It also includes filenames
    for audio files, which can be searched for or located in the `/sdcard/tencent/MicroMsg/*/voice2`
    directory. |'
  prefs: []
  type: TYPE_TB
- en: '| `rcontact` | This contains a list of contacts and includes many that are
    added by default by the app. The `username` column can be correlated with the
    `talker` column in the `message` table. The `nickname` column shows the user''s
    name. The `type` column is an indicator of whether the contact was added manually
    or automatically (`1` = device user, `3` = added by user, and `33` = added by
    app). The exception to this is the user "weixin", which is automatically added,
    but has a type value of `3`. |'
  prefs: []
  type: TYPE_TB
- en: '| `userinfo` | This table contains information about the user, including their
    name and phone number. |'
  prefs: []
  type: TYPE_TB
- en: Application reverse engineering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The vast majority of Android applications are written in Java. In order to truly
    reverse engineer Java code, one should generally be able to engineer Java code
    first. Teaching Java is well beyond the scope of this book. We will, however,
    show a few useful reversing methods that we think will be useful and can be done
    by an average mobile forensic examiner. Many hundreds of tutorials and guides
    have been written online for Android reversing, from the very basic to the highly
    advance.
  prefs: []
  type: TYPE_NORMAL
- en: Anyone looking for more information on the subject should easily be able to
    find what they are looking for. As always, [www.xda-developers.com](http://www.xda-developers.com)
    is an incredibly useful resource, and entire books have been dedicated to the
    subject. There is also an incredibly detailed, updated list of tools by Ashish
    Bhatia that can be found at [https://github.com/ashishb/android-security-awesome](https://github.com/ashishb/android-security-awesome).
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining the application's APK file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Applications are installed via `.apk` files. The APK file for an app is stored
    on the device, even after the application is installed (and is removed when an
    app is deleted). This APK contains the compiled Java code for the app, the icons
    and fonts used in the app, and an `AndroidManifest.xml` file that declares the
    permissions the application needs.
  prefs: []
  type: TYPE_NORMAL
- en: The `APK` file for applications that are installed through Google Play can be
    found in the `/data/app` directory. Another method to find the APK location is
    to use the `adb` shell `pm path <package_name>` command. The APK file for preinstalled
    system applications (that cannot be deleted without root) can be found in the
    /system/app directory. The APK file itself is stored in a directory named after
    its package name, followed by a dash and a number. For example, the package name
    for Kik is `kik.android`, and the APK in `/data/app` is stored as `inkik.android-1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the list of APK directories in `/data/app` for the device we tested:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Obtaining the application''s APK file](img/image00407.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note that every application we tested has an APK file in this directory, as
    well as many apps that we did not look at.
  prefs: []
  type: TYPE_NORMAL
- en: 'Obtaining the APK file is as simple as using the adb pull command. To pull
    the Kik APK, we will use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This should pull a `lib` directory and a `base.apk` file, which will be in
    the current directory the command was run from:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Obtaining the application''s APK file](img/image00408.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Disassembling an APK file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For starters, the APK file is actually just a ZIP compressed file. Renaming
    the extension to .zip will allow an examiner to open the container and browse
    the files contained in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Disassembling an APK file](img/image00409.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: However, you might not be able to view the AndroidManifest.xml file. There are
    many tools and methods to fully disassemble the APK, and these can be found in
    the list we linked to above. Our personal favorite tool, though, is one that allows
    you to simply right-click on the APK and disassemble it (on Windows only). The
    APK_OneClick tool can be found at [http://forum.xda-developers.com/showthread.php?t=873466](http://forum.xda-developers.com/showthread.php?t=873466).
  prefs: []
  type: TYPE_NORMAL
- en: The **Java Runtime Environment** (**JRE**) will have to be installed. It can
    be found at [http://www.oracle.com/technetwork/java/javase/downloads/jre8-downloads-2133155.html](http://www.oracle.com/technetwork/java/javase/downloads/jre8-downloads-2133155.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the tool and the JRE have been installed, an examiner can simply right-click
    on the APK and select **Disassemble APK and Decode Resources**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Disassembling an APK file](img/image00410.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'A pop-up window will appear to show the progress and will disappear if no problems
    are encountered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Disassembling an APK file](img/image00411.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If the disassembly ended successfully, there will now be a folder called `base-disasm`
    in the same directory as the APK. Browsing the directory will show many of the
    same files and folders we saw when the APK was renamed to a `.zip` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Disassembling an APK file](img/image00412.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Determining an application's permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Knowing what an app has permission for can be very useful for an examiner. For
    starters, it can help narrow down where data is stored. An app without permission
    to write data to the SD card, for example, won't store any data there. One of
    the most commonly heard defenses when a suspect is caught with illicit material
    is that, of course, the suspect has no idea how it got there and it was placed
    there by a virus. If he says a particular app put that data on his SD card, an
    examiner can show that the app couldn't have done that because it didn't have
    permission to write to the SD card. These are just a few basic examples, but again,
    this is very basic reverse engineering!
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AndroidManifest.xml` file from the disassembled APK discussed earlier
    will contain the app''s permissions. These are the equivalent of what the user
    is shown and has to approve when the app is installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Determining an application''s permissions](img/image00413.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: For the specifics of what each permission allows the app to do, Google maintains
    a list at [http://developer.android.com/reference/android/Manifest.permission.html](http://developer.android.com/reference/android/Manifest.permission.html).
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the application's code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To view the application''s code using the APK_OneClick tool, simply right-click
    on the APK and select **Browse Java Code of APK**. Again, a window will pop up
    temporarily showing progress and will disappear if no errors are encountered.
    Once it completes, a Java Decompiler window will appear, allowing the examiner
    to browse through the Java code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing the application''s code](img/image00414.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has been an in-depth study of specific Android applications, and
    how/where they store their data. We looked at 19 specific applications and discovered
    9 different methods of storing and obfuscating data. Knowing that applications
    store their data in a variety of ways should help an examiner have a better understanding
    of an app's data that they are examining. This knowledge should, hopefully, push
    them to look harder when they can't find data they expect the app to have. An
    examiner has to be able to adapt to the changing world of application analysis.
    As applications constantly update, an examiner has to be able to update their
    own methods and abilities in order to keep up.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will take a look at several free and open source tools to image
    and analyze Android devices and reverse engineer applications to discover where
    their data is stored.
  prefs: []
  type: TYPE_NORMAL
