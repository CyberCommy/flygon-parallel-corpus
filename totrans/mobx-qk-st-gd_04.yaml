- en: Crafting the Observable Tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Defining the reactive model of your application is usually the first step when
    working with MobX and React. We know very well that this is all in the realm of
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Observables, which represent the application state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actions, which mutate it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactions, which produce side effects by observing the changing observables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When defining the observable state, MobX gives you various tools to carefully
    control observability. In this chapter, we will explore this side of MobX and
    take a deeper look at *crafting the observable tree*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics that will be covered in this chapter are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The shape of data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling observability with various decorators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating computed properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modeling MobX stores with classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be required to have JavaScript programming language. Finally, to use
    the Git repository of this book, the user needs to install Git.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/MobX-Quick-Start-Guide/tree/master/src/Chapter04](https://github.com/PacktPublishing/MobX-Quick-Start-Guide/tree/master/src/Chapter04)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2uYmln9](http://bit.ly/2uYmln9)'
  prefs: []
  type: TYPE_NORMAL
- en: The shape of data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The data that we deal with within an application comes in all shapes and sizes.
    However, these different shapes are fairly limited and can be listed as:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Singular values**: These include primitives like numbers, booleans, strings,
    null, undefined, dates, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lists**: Your typical list of items where each item is one of a kind. It
    is generally a good practice to avoid putting items of different data types in
    the same list. This creates homogenous lists which are easy to reason about.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hierarchy**: Many of the structures we see in UI are hierarchical, like a
    hierarchy of files and f0lders, parent-child relationships, groups and items,
    and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composite**: A combination of some or all of the preceding shapes. Most real
    world data is in this form.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MobX gives us the API to model each of these shapes and we have already seen
    some examples of this in earlier chapters. However, MobX makes one distinction
    between singular values and other kinds like arrays and maps. This is reflected
    in the API as well, where `observable()` can *only* be used to create objects,
    arrays, and maps. Creating an observable out of a singular value requires us to
    box it with the `observable.box()` API.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling observability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MobX, by default, applies deep observability on your objects, arrays, and maps.
    This allows you to see changes happening at any level in the observable tree.
    Although this a great default to start with, at some point, you will have to pay
    more attention to limit the observability. Cutting down on the observability also
    improves performance as there are fewer things to track from the point of view
    of MobX.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two distinct ways in which you can control observability:'
  prefs: []
  type: TYPE_NORMAL
- en: By using the various `@decorators` inside classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using the `decorate()` API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using @decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Decorators are a syntactic feature that allow you to attach behavior to a class
    and its fields. We have already seen this in [Chapter 3](part0055.html#1KEEU0-58c2559ca4304cecab9bc46f496bc070),
    *A React App with MobX*, so the following code should be very familiar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Using the `@observable` decorator, you can make properties of a class into observables.
    This is the recommended approach to start modeling your observables. By default, `@observable`
    applies deep observability, but there are some specialized decorators that give
    you more control.
  prefs: []
  type: TYPE_NORMAL
- en: '`@observable` is a shorter form or an alias of `@observable.deep`, which is
    the default decorator. It applies *deep observability* at all levels of objects,
    arrays, and maps. However, the deep observation stops at places where the object
    has a *constructor or a prototype*. Such objects are usually instances of classes
    and are expected to have their own *observable properties*. MobX chooses to skip
    such objects during deep observation.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating shallow observables with @observable.shallow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This decorator prunes the observability to just the first level of the data,
    also called **one-level-deep** observation, and is particularly useful for observable
    arrays and maps. In the case of arrays, it will monitor a reference change (for
    example, assigning a new array) of the array itself, and the addition and removal
    of items in the array. If you have items in the array that have properties, they
    would not be considered in the shallow observation. Similarly, for maps, only
    the addition and removal of keys is considered, along with the reference change
    of the map itself. Values of the keys in the observable map are left as-is and
    not considered for observation.
  prefs: []
  type: TYPE_NORMAL
- en: The following snippet shows the application of the `@observable.shallow` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We chose to apply this decorator to the `results` property of the `BookSearchStore`.
    It is clear that that we are not particularly observing the properties of each
    individual result. In fact, they are read only objects that will never change
    values, so it makes sense that we prune the observability to just the addition
    and removal of items, and reference changes in the `results` array. Thus, `observable.shallow`
    is the right choice here.
  prefs: []
  type: TYPE_NORMAL
- en: A subtle point to remember here is that the `length` property of the array (`size`,
    in the case of maps) is also observable. Can you figure out why it is observable?
  prefs: []
  type: TYPE_NORMAL
- en: Creating reference-only observables with @observable.ref
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are *not* interested in any changes happening inside a data structure
    (object, array, map) and only in the *change in value*, `@observable.ref` is what
    you are looking for. It will only monitor reference changes to the observable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `validations` observable is always assigned a
    new value. Since we are never modifying the properties of this object, it is better
    to mark it as `@observable.ref`. This way, we only track reference changes to
    `validations` and nothing else.
  prefs: []
  type: TYPE_NORMAL
- en: Creating structural observables with @observable.struct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MobX has a built-in behavior to track changes in values and works well for primitives
    like strings, numbers, booleans, and so on. However, it becomes less than ideal
    when dealing with *objects*. Every time a new object is assigned to the observable,
    it will be considered as a change, and reactions will fire. What you really need
    is a *structural check* where the *properties* of your object are compared instead
    of the *object reference,* and then decide if there is a change. That is the purpose
    of `@observable.struct`.
  prefs: []
  type: TYPE_NORMAL
- en: It does a deep comparison based on *property values* rather then relying on
    the top-level reference. You can think of this as a refinement over the `observable.ref`
    decorator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following code, where we create an `@observable.struct`
    for the `location` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that `autorun()` fires once immediately and then does not react to the
    next location (`{ x: 0, y: 0}`). Since the structural value is the same `(0, 0)`,
    it is not treated as a change and hence no notifications are fired. It''s only
    when we set the location to a different `(x, y)` value that `autorun()` is triggered.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now represent the level of observability of the decorators, as in the
    following diagram. `@observable` (in this case, `@observable.deep`) is the most
    powerful, followed by `@observable.shallow`, `@observable.ref`, and finally `@observable.struct`.
    As you get more fine-grained with the observable decorators, you can prune the
    surface area to track in the observable tree. This is shown with the orange-colored
    shapes. The more observables there are, the greater the tracking area is for MobX:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using the decorate() API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The use of `@decorators` is definitely very convenient and readable, but it
    does require some setup with Babel (using *babel-plugin-transform-decorators-legacy*)
    or turning on the `experimentalDecorators` flag in the compiler options for TypeScript.
    With version 4, MobX introduced an *ES5* API for decorating the observable properties
    of an object or class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `decorate()` API, you can selectively target properties and specify
    the observability. The following code snippet should make this clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `target` can be an object prototype or a class type. The second argument
    is an object containing the target properties that you want to decorate.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, notice the way that we are applying the decorators
    to the class type. From a developer standpoint, it feels natural to use them when
    you don't have the syntax support of `@decorators`. In fact, the `decorate()`
    API can also be used for other kinds of decorators such as `action`, `action.bound`,
    and `computed`.
  prefs: []
  type: TYPE_NORMAL
- en: Decorating with observable()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `decorate()` style of the API also works when declaring observables using
    the `observable()` API.
  prefs: []
  type: TYPE_NORMAL
- en: '`observable(properties, decorators, options)`:Its arguments are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`properties`*:* Declare the properties of the observable object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decorators`: An object defining the decorators for the properties'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`options`: Options for setting default observability and a debug-friendly name
    (`{ deep: false|true, name: string }`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second argument to `observable()` is where you specify the decorators for
    various properties in your object. This works exactly like the `decorate()` call,
    as can be seen in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the second argument, we have applied the various decorators to control the
    *observability*, apply *actions,* and mark *computed properties*.
  prefs: []
  type: TYPE_NORMAL
- en: When using the `observable()` API, it is not required to mark the computed properties
    explicitly. MobX will convert any `getter` property of the passed in object into
    a computed property.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, for the `modified` property, there is actually no need to decorate
    since `observable()` by default makes everything deeply observable. We only have
    to specify the properties that need a different treatment. In other words, only
    specify decorators for the exceptional properties.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the observability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When modeling the client state, it is best to pre-define the observability we
    need in our reactive system. This bakes in all the constraints and scope of the
    observable data in your domain. However, the real world is always unforgiving
    and there will be times where you need runtime abilities to extend the observability.
    This is where the `extendObservable()` API comes in. It allows you to mix in additional
    properties at runtime and make them observable as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we are extending the observability of the `cart` for
    festive offers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The *first* argument to `extendObservable()` is the target object that we want
    to extend. The second argument is the list of observable properties and actions
    that will be mixed into the target object. The third argument is the list of decorators
    that will be applied to the properties.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we want to add more observables to the **cart** for
    tracking festive offers. This can only be done at runtime based on an active festive
    season. The `applyFestiveOffers()` function is called when that condition is met.
  prefs: []
  type: TYPE_NORMAL
- en: '`extendObservable()` is in fact the superset of `observable()`, and`observable.object()`. `observable()`
    is really `extendObservable({}, object)`. It is no coincidence that this looks
    similar to `decorate()`. MobX strives to keep the API consistent and intuitive.
    While `extendObservable()` takes an actual object in its first argument, `decorate()`
    requires it to be classes and object prototypes.'
  prefs: []
  type: TYPE_NORMAL
- en: '*[Fun Fact]* Before the introduction of `decorate()`, `extendObservable()`
    was used to extend `this` inside the *class constructor*: `extendObservable(this,
    { })`. Of course, now the recommended approach is to use `decorate()`, which can
    be applied directly on a class or object prototype.'
  prefs: []
  type: TYPE_NORMAL
- en: One point to ponder on is that an *observable Map* could also be used to add
    observable properties on the fly. However, they can only be *state carrying* properties
    and not *actions* or *computed-properties*. When you want to dynamically add *actions*
    and *computed properties* as well, go for `extendObservable()`.
  prefs: []
  type: TYPE_NORMAL
- en: Derived state with @computed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the core philosophies of MobX is that the observable state should be
    as minimal as possible. Everything else should be ***derived*** via computed properties.
    This perspective makes sense when we talk about state management in UI. The UI
    is always nuanced on the same observable state and needs different views of the
    state depending on the context and task. This means that there are many possibilities
    for deriving a view-centric state (or representation) within the same UI.
  prefs: []
  type: TYPE_NORMAL
- en: An example of such a view-centric state is a table view and a chart view of
    the same list of observables. Both are operating on the same state but need different
    representations to satisfy the UI (the view) needs. Such representations are prime
    candidates for state derivations. MobX recognizes this core requirement and provides
    ***computed properties***, which are specialized observables that derive their
    value from other dependent observables.
  prefs: []
  type: TYPE_NORMAL
- en: '*Computed properties* are very efficient and cache the computation. Although
    the computed property is re-evaluated whenever the dependent observables change,
    no notifications are fired if the new value matches the previously cached value.
    Additionally, computed properties also get garbage collected if there are no more
    observers of the computed property. This automatic cleanup also adds to the efficiency.
    *Caching* and *automatic clean-up* are the main reasons why MobX recommends liberal
    usage of computed properties.'
  prefs: []
  type: TYPE_NORMAL
- en: Using computed properties, we can create separate observables as needed by the
    UI. As your application grows in size, you will possibly need more derivations
    that depend on the core state. These derivations (computed properties) can be
    mixed in using `extendObservable()`, as and when needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'MobX offers three different ways in which you can create computed properties:
    using the `@computed` decorator, the `decorate()` API, or using the `computed()`
    function. These can be seen in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Using the `computed()` function directly has the feel of working with boxed
    observables. You have to use the `get()` method on the returned computed function
    to retrieve the value.
  prefs: []
  type: TYPE_NORMAL
- en: You also have the option of using the `observe()` method of the `computed()`
    function. By attaching an observer, you can get the changed value. This technique
    can also be used to handle side effects or reactions.
  prefs: []
  type: TYPE_NORMAL
- en: Both of these APIs can be seen in the preceding code snippet. This usage is
    not very common, but can be leveraged when dealing with boxed observables directly.
  prefs: []
  type: TYPE_NORMAL
- en: Structural equality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the return value of a computed property is a primitive, it is easy to know
    when there is a new value. MobX compares the previous value of the computed property
    with the newly evaluated value and then fires notifications if they differ. Thus,
    value comparisons become important to ensure notifications are fired only on a
    *real change*.
  prefs: []
  type: TYPE_NORMAL
- en: For objects, this is not straightforward. The default comparison is done based
    on reference checks (using the `===` operator). This treats the objects as being
    different even though the values within them are exactly the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the `metrics` computed property generates a new object
    every time the `start` or `end` properties change. Since the `autorun` (defined
    in the constructor) depends on `metrics`, it runs the side effect every time `metrics`
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'However, notice that `metrics` doesn''t really change, even though the `start` and `end` properties
    are changing. This can be seen with the *autorun* side effect, which keeps printing
    the same delta value. This happens because the `metrics` computed property is
    returning a new object on each evaluation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The way to fix this is to use the `@computed.struct` decorator, which does a
    deep comparison of the object structure. This ensures that no notifications are
    fired when a re-evaluation of the `metrics` property gives back the same structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is one way to safeguard a costly reaction that depends on such a computed
    observable. Decorate it with `computed.struct` to ensure only a real change in
    the object structure is considered for notification. Conceptually, it is very
    similar to the `observable.struct` decorator that we saw in the previous section
    of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In practice, it is rare to use the `computed.struct` observable. The computed
    value only changes when the dependent observables change. When any of the dependent
    observables change, a new, computed value has to be created, and in most real
    world apps, it is different most of the time. Thus, you don't really need to decorate
    with `computed.struct`, since most computed values will be very different from
    each other in successive evaluations.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling the stores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It can seem like a daunting task when you start to model the client state for
    your React Application with MobX. An idea that can help you on this journey is
    the simple realization that *your application is just a collection of features*,
    composed together to form a cohesive unit. By starting with the simplest feature,
    you can string the rest of the app together, one feature at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'This style of thinking guides you to model your feature-level-stores first.
    The app-level-store (also called the Root Store) is just a composition of these
    feature stores with a shared communication channel. In the MobX world, you start
    with a *class* to describe the feature store. Depending on the complexity, you
    can break the feature store into many sub stores. The feature store acts as the
    coordinator of all the sub stores. This is the classic *divide and conquer* approach
    to modeling software:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00024.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Let's take an example to illustrate this approach to modeling the reactive client
    state. In the *book-search* app that we built in the previous section, we want
    to add the ability to create wishlists. A wishlist can contain items that you
    would like to purchase in the future. You should be able to create as many wishlists
    as you want. Let's model the wishlist feature with MobX. We will not worry about
    the React side of things and instead just focus on using MobX to model the client
    state.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Wishlist feature**'
  prefs: []
  type: TYPE_NORMAL
- en: This adds the ability to create wishlists. A wishlist has a name and contains
    a list of items to be purchased in the future. One can create as many wishlists
    as needed. A wishlist item has the title of the item and a flag to track if it
    is purchased.
  prefs: []
  type: TYPE_NORMAL
- en: The first step in modeling with MobX is to identify the *observable state* and
    the *actions* that can mutate it. We are not going to worry about *reactions*
    (or *observers*) as of now.
  prefs: []
  type: TYPE_NORMAL
- en: Observable state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start with a *class*, `WishListStore`, to track all the details of
    the wishlist feature. This is our *feature-level-store* that contains the observable
    state for the entire feature. Based on the description we saw earlier, let''s
    distill the core observable state:'
  prefs: []
  type: TYPE_NORMAL
- en: An array of wishlists, where each item is an instance of a `WishList` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `WishList` has a *name* and contains an array of `WishListItem` instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each `WishListItem` has a *title* and a boolean *purchased* property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An interesting thing to note here is that we have extracted some vocabulary
    from the earlier description. This includes `WishListStore`, `WishList`, and `WishListItem`,
    which form the backbone of our feature. Identifying this vocabulary is the hard
    part and can take a few iterations to get to the right terms. It's no wonder that *naming
    things* is classified as one of the two hard problems in Computer Science!
  prefs: []
  type: TYPE_NORMAL
- en: 'In code, we can now capture this observable state as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the use of the `observable.shallow` decorator for arrays. We don''t
    need deep observation for them. The individual items (`WishListItem`) have their
    own observable properties. The wishlist feature is represented by the singleton
    instance of the `WishListStore` (`store`). Since we will be creating instances
    of `WishList` and `WishListItem`, we can add constructor functions to make this
    easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Derived state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the core observable state has been established, we can give some consideration
    to the derived state. Derived state (derivations) are computed properties that
    depend on other observables. It is helpful to think of the derivations in the
    context of how the core observable state is consumed.
  prefs: []
  type: TYPE_NORMAL
- en: 'One common use case when you have arrays is to think of the empty state. There
    is usually some visual indication that the list is empty. Rather than testing
    the `array.length`, which is quite low-level, it is better to expose a computed
    property called `isEmpty`. Such computed properties focus on the *semantics* of
    our store rather than dealing directly with the core observables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, if we want to know the purchased items from the `WishList`, there
    is no need to define any new observable state. It can be derived from the `items`
    by filtering the `purchased` property. That is the definition for the `purchasedItems` 
    *computed property*. I'll leave it as an exercise for the reader to define this
    computed property.
  prefs: []
  type: TYPE_NORMAL
- en: You should always think of the *observable state* as a combination of a minimal
    *core state* and a *derived state*. Think of the following equation to ensure
    that you are not putting too much into your core state. What can be derived should
    always lie in the *derived state:*
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00025.jpeg)In real-world apps, it is quite possible that a property
    being tracked in one store may move to another due to refactoring. For example,
    the `purchased` property of a `WishListItem` could be tracked by a separate store
    (for example, `ShoppingCartStore`). In such a case, the `WishListItem` can make
    it a *computed property* and depend on the external store to keep track of it.
    Doing so does not change anything on the UI since the way you read `purchased`
    still stays the same. Also, MobX makes it simple to keep the `purchased` property
    always up-to-date because of the implicit dependency created via the computed
    property.'
  prefs: []
  type: TYPE_NORMAL
- en: Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once the observable state is identified, it is natural to include the *actions*
    that can mutate it. These are the operations which will be invoked by the user,
    and exposed by the React interface. In the case of the wishlist feature, this
    includes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new `WishList`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting a wishlist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Renaming a wishlist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding items (`WishListItem`) to a wishlist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing items from a wishlist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Actions that add or remove wishlists go into the top-level, `WishListStore`,
    while actions concerning items in a wishlist will be placed in the `WishList`
    class. The renaming of a wishlist can also go into the `WishList` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: MobX gives a convenient API on *observable arrays* to remove items. Using the
    `remove()` method, you can remove items that match by value or reference. The
    method returns *true* if the item was found and removed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you make the broad cuts on the observable state, it is time to tailor
    it further with the observable decorators. This gives you better control of the
    observability and improves the performance of the MobX reactivity system. We have
    seen two different ways of doing this: one with the `@decorator` syntax and the
    other using the `decorate()` API.'
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to add new *observable properties* on the fly with `extendObservable()`.
    In fact, you can even add new *actions* and *computed properties* with `extendObservable()`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Observable State = Core State + Derived State*'
  prefs: []
  type: TYPE_NORMAL
- en: The *core state* and the *derived state* are two aspects of the *observable
    state* in MobX. This is easy to model with classes and decorators, as shown in
    the preceding sections. Once you identify the vocabulary of your feature, they
    become the class names that encapsulate the *observable state*. To handle the
    complexity of the feature, you can break it into smaller classes and compose them
    in the *feature store*. These *feature stores* are then composed in the top-level
    *root store*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a deeper understanding of defining and crafting the *observables*,
    it''s time we look at the other pillars of MobX: *actions* and *reactions*. That
    is where we are heading with the next chapter.'
  prefs: []
  type: TYPE_NORMAL
