- en: 13\. Enemy Artificial Intelligence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter begins with a brief recap of how the enemy AI will behave for the
    `SuperSideScroller` game. From there, you will learn about Controllers in the
    context of Unreal Engine 4 and learn how to create an AI Controller. Then, you
    will learn more about AI navigation in Unreal Engine 4 by adding a Nav Mesh to
    the main level of the game.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to create a navigable space where
    the enemy can move. You will also be able to create an enemy AI pawn and navigate
    it across locations using Blackboard and behavior trees. Lastly, you will know
    how to create and implement a player projectile class and add visual elements
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you added layered animations for the player character
    using Animation Blending with a combination of Anim Slots, Animation Blueprints,
    and blending functions such as Layered Blend per Bone.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to use a Nav Mesh to create a navigable
    space inside of the game world that the enemy can move in. Defining the navigable
    space of a level is crucial for allowing **artificial intelligence** (**AI**)
    to access and move to specific areas of your level.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will create an enemy AI pawn that can navigate between patrol point
    locations inside the game world using a combination of the AI tools present inside
    Unreal Engine 4, including *Blackboards* and *behavior trees*.
  prefs: []
  type: TYPE_NORMAL
- en: You will also learn how to use a Nav Mesh to create a navigable space inside
    the game world where the enemy can move. Defining the navigable space of a level
    is crucial for allowing the AI to access and move to specific areas of your level.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, you'll learn how to create a player projectile class in C++ and how
    to implement the `OnHit()` collision event function to recognize and log when
    the projectile hits an object in the game world. In addition to creating the class,
    you will then create a Blueprint of this player projectile class and add visual
    elements to the player projectile, such as a Static Mesh.
  prefs: []
  type: TYPE_NORMAL
- en: The `SuperSideScroller` game is finally coming together and you will be in a
    good position by the end of this chapter to move on to *Chapter 14*, *Spawning
    the Player Projectile*, where you will handle adding elements of polish to the
    game, such as SFX and VFX.
  prefs: []
  type: TYPE_NORMAL
- en: The primary focus of this chapter is to take the C++ enemy class you created
    in *Chapter 12*, *Animation Blending and Montages*, and bring this enemy to life
    using AI. Unreal Engine 4 uses many different tools to achieve AI such as AI Controllers,
    Blackboards, and behavior trees, all of which you will learn about and use in
    this chapter. Before you jump into these systems, let's take a moment to learn
    about how AI is used in games in recent history. AI has certainly evolved since
    the days of *Super Mario Bros*.
  prefs: []
  type: TYPE_NORMAL
- en: Enemy AI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is AI? This term can mean many things, depending on the field and context
    that it is used in, so let's define it in a way that makes sense regarding the
    subject of video games.
  prefs: []
  type: TYPE_NORMAL
- en: '**AI** is an entity that is aware of its environment and performs choices that
    will help optimally achieve its intended purpose. AI uses what are called **finite
    state machines** to switch between more than one state based on the input it receives
    from the user or its environment. For example, a video game AI can switch between
    an offensive state to a defensive state based on its current health.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In games such as *Hello Neighbor*, which was developed in Unreal Engine 4,
    and *Alien: Isolation*, the goal of the AI is to find the player as efficiently
    as possible, but also to follow some predetermined patterns defined by the developers
    to ensure that the player can outsmart it. *Hello Neighbor* adds a very creative
    element to its AI by having it learn from the players'' past actions and tries
    to outsmart the player based on the knowledge it learns.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find an informative breakdown of how the AI works in this video by
    the publishers of the game, *TinyBuild Games*, here: [https://www.youtube.com/watch?v=Hu7Z52RaBGk](https://www.youtube.com/watch?v=Hu7Z52RaBGk).'
  prefs: []
  type: TYPE_NORMAL
- en: Interesting and fun AI is crucial to any game, and depending on the game you
    are making, this can mean a very complex or very simplistic AI. The AI that you
    will be creating for the `SuperSideScroller` game will not be as sophisticated
    as those mentioned previously, but it will fill the needs of the game we are seeking
    to create.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s break down how the enemy will behave:'
  prefs: []
  type: TYPE_NORMAL
- en: The enemy will be a very simple enemy that has a basic back and forth movement
    pattern and will not support any attacks; only by colliding with the player character
    will they be able to inflict any damage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, we need to set the locations to move between for the enemy AI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we decide whether the AI should change locations, should constantly move
    between locations, or should there be a pause in between selecting a new location
    to move to?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fortunately for us, Unreal Engine 4 provides us with a wide array of tools that
    we can use to develop such complex AI. In the case of our project, however, we
    will use these tools to create a simplistic enemy type. Let's start by discussing
    what an AI Controller is in Unreal Engine 4.
  prefs: []
  type: TYPE_NORMAL
- en: AI Controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's discuss what the main difference is between a **Player Controller** and
    an **AI Controller**. Both of these actors derive from the base **Controller class**,
    and a Controller is used to take control of a **Pawn** or **Character** in order
    to control the actions of said pawn or character.
  prefs: []
  type: TYPE_NORMAL
- en: While a Player Controller relies on the input of an actual player, an AI Controller
    applies AI to the characters they possess and responds to the environment based
    on the rules set forth by the AI. By doing so, the AI can make intelligent decisions
    in response to the player and other external factors, without the actual player
    explicitly telling it to do so. Multiple instances of the same AI pawn can share
    the same AI Controller, and the same AI Controller can be used across different
    AI pawn classes. AI, like all actors inside Unreal Engine 4, are spawned through
    the `UWorld` class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You will be learning more about the `UWorld` class in *Chapter 14*, *Spawning
    the Player Projectile*, but as a reference, please read more here: [https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UWorld/index.html](https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UWorld/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: The most important aspect of both the Player Controller and the AI Controller
    is the pawns they will control. Let's learn more about how AI Controllers handle
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Auto Possess AI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like all Controllers, the AI Controller must possess a *pawn*. In C++, you
    can use the following function to possess a pawn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the following function to unpossess a pawn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There's also the `void AController::OnPossess(APawn* InPawn)` and `void AController::OnUnPossess()`
    functions, which are called whenever the `Possess()` and `UnPossess()` functions
    are called, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to AI, especially in the context of Unreal Engine 4, there are
    two methods in which AI Pawns or Characters can be possessed by an AI Controller.
    Let''s take a look at these options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Placed in World`: This first method is how you will be handling AI in this
    project; you will manually place these enemy actors into your game world, and
    the AI will take care of the rest once the game begins.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Spawned`: This second method is only a little more complicated because it
    requires an explicit function call, either in C++ or Blueprint, to `Spawn` an
    instance of a specified class. The `Spawn Actor` method requires a handful of
    parameters, including the `World` object and `Transform` parameters such as `Location`
    and `Rotation`, to ensure that the instance that is spawned is spawned correctly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Placed in World or Spawned`: If you are unsure of which method you want to
    use, a safe option would be `Placed in World or Spawned`; that way, both methods
    are supported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the purposes of the `SuperSideScroller` game, you will be using the `Placed
    In World` option because the AI you will create will be manually placed in the
    game level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.01: Implementing AI Controllers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before the enemy pawn can do anything, it needs to be possessed by an AI Controller.
    This also needs to happen before any logic can be performed by the AI. This exercise
    will be performed within the Unreal Engine 4 editor. By the end of this exercise,
    you will have created an AI Controller and applied it to the enemy that you created
    in the previous chapter. Let's begin by creating the AI Controller actor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Head to the `Content Browser` interface and navigate to the `Content/Enemy`
    directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Right-click* on the `Enemy` folder and select the `New Folder` option. Name
    this new folder `AI`. In the new `AI` folder directory, *right-click* and select
    the `Blueprint Class` option.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `Pick Parent Class` dialogue box, expand `All Classes` and manually
    search for the `AIController` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Left-click* this class option and then *left-click* on the green `Select`
    option at the bottom to create a new `Blueprint` from this class. Please refer
    to the following screenshot to know where to find the `AIController` class. Also,
    take note of the tooltip that appears when hovering over the class option; it
    contains useful information about this class from the developers:![Figure 13.1:
    The AIController asset class, as found in the Pick Parent Class dialogue box'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_13_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.1: The AIController asset class, as found in the Pick Parent Class
    dialogue box'
  prefs: []
  type: TYPE_NORMAL
- en: With this new `AIController Blueprint` created, name this asset `BP_AIControllerEnemy`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the AI Controller created and named, it's time to assign this asset to
    the first enemy Blueprint that you made in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the `/Enemy/Blueprints` directly to find `BP_Enemy`. *Double-click*
    to open this Blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Details` panel of the first enemy `Blueprint`, there is a section labeled
    `Pawn`. This is where you can set different parameters regarding the AI functionality
    of `Pawn` or `Character`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `AI Controller Class` parameter determines, as its name suggests, which
    AI Controller to use for this enemy. *Left-click* on the dropdown to find and
    select the AI Controller you made earlier; that is, `BP_AIController_Enemy`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this exercise complete, the enemy AI now knows which AI Controller to use.
    This is crucial because it is in the AI Controller where the AI will use and execute
    the behavior tree you will create later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The AI Controller is now assigned to the enemy, which means you are almost ready
    to start developing the actual intelligence for this AI. There is still one important
    topic to discuss before doing so, and that is the Navigation Mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Navigation Mesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most crucial aspects of any AI, especially in video games, is the
    ability to navigate the environment in a sophisticated manner. In Unreal Engine
    4, there is a way for the engine to tell the AI which parts of an environment
    navigable and which parts are not. This is done through a **Navigation Mesh**,
    or **Nav Mesh** for short.
  prefs: []
  type: TYPE_NORMAL
- en: The term Mesh is misleading here because it's implemented through a volume in
    the editor. We will need a Navigation Mesh in our level so that our AI can effectively
    navigate the playable bounds of the game world. We'll add one together in the
    following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Unreal Engine 4 also supports a `Dynamic Navigation Mesh`, which allows the
    Nav Mesh to update in real-time as dynamic objects move around the environment.
    This results in the AI recognizing these changes in the environment and updating
    their pathing/navigation appropriately. This book will not cover this, but you
    can access the configuration options via `Project Settings -> Navigation Mesh
    -> Runtime Generation`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.02: Implementing a Nav Mesh Volume for the AI Enemy'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will add a Navigation Mesh to `SideScrollerExampleMap`
    and explore how Navigation Meshes work in Unreal Engine 4\. You'll also learn
    how to parameterize this volume for the needs of your game. This exercise will
    be performed within the Unreal Engine 4 editor.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this exercise, you will have a stronger understanding of the Nav
    Mesh. You will also be able to implement this volume in your own level in the
    activity that follows this exercise. Let's begin by adding the Nav Mesh volume
    to the level.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: If you do not already have the map open, please open `SideScrollerExampleMap`
    by navigating to `File` and *left-clicking* on the `Open Level` option. From the
    `Open Level` dialogue box, navigate to `/SideScrollerCPP/Maps` to find `SideScrollerExampleMap`.
    Select this map with a *left-click* and then *left-click* `Open` at the bottom
    to open the map.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the map opened, navigate to the right-hand side to find the `Modes` panel.
    The `Modes` panel is a set of easily accessible actor types such as `Volumes`,
    `Lights`, `Geometry`, and others. Under the `Volumes` category, you will find
    the `Nav Mesh Bounds Volume` option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Left-click* and drag this volume into the map/scene. By default, you will
    see the outline of the volume in the editor. Press the `P` key to visualize the
    `Navigation` area that the volume encompasses, but make sure that the volume is
    intersecting with the ground geometry in order to see the green visualization,
    as shown in the following screenshot:![Figure 13.2: Areas outlined in green are
    perceived as navigable by the engine and the AI'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_13_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.2: Areas outlined in green are perceived as navigable by the engine
    and the AI'
  prefs: []
  type: TYPE_NORMAL
- en: With the `Nav Mesh` volume in place, let's adjust its shape so that the volume
    extends to the entire area of the level. After this, you'll learn how to adjust
    the parameters of the `Nav Mesh` volume for the purposes of the game.
  prefs: []
  type: TYPE_NORMAL
- en: '*Left-click* to select `NavMeshBoundsVolume` and navigate to its `Details`
    panel. There is a section labeled `Brush Settings` that allows you to adjust the
    shape and size of the volume. Find the values that fit best for you. Some suggested
    settings are `Brush Type: Additive`, `Brush Shape: Box`, `X: 3000.0`, `Y: 3000.0`,
    and `Z: 3000.0`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Notice that when the shape and dimensions of `NavMeshBoundsVolume` change,
    `Nav Mesh` will adjust and recalculate the navigable area. This can be seen in
    the following screenshot. You will also notice that the upper platforms are not
    navigable; you will fix this later:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3: Now, NavMeshBoundsVolume extends to the entire playable'
  prefs: []
  type: TYPE_NORMAL
- en: area of the example map
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_13_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.3: Now, NavMeshBoundsVolume extends to the entire playable area of
    the example map'
  prefs: []
  type: TYPE_NORMAL
- en: By completing this exercise, you have placed your first `NavMeshBoundsVolume`
    actor into the game world and, using the debug key, `'P'`, visualized the navigable
    area in the default map. Next, you will learn more about the `RecastNavMesh` actor,
    which is also created when placing `NavMeshBoundsVolume` into the level.
  prefs: []
  type: TYPE_NORMAL
- en: Recasting the Nav Mesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you added `NavMeshBoundsVolume`, you may have noticed that another actor
    was created automatically: a `RecastNavMesh` actor called `RecastNavMesh-Default`.
    This `RecastNavMesh` acts as the "brain" of the Nav Mesh because it contains the
    parameters needed to adjust the Nav Mesh that directly influences how the AI navigates
    the given area.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows this asset, as seen from the `World Outliner`
    tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4: The RecastNavMesh actor, as seen from the World Outliner tab'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_13_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.4: The RecastNavMesh actor, as seen from the World Outliner tab'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of parameters that exist in `RecastNavMesh`, and we will only
    be covering the important parameters in this book. For more information, check
    out [https://docs.unrealengine.com/en-US/API/Runtime/NavigationSystem/NavMesh/ARecastNavMesh/index.html](https://docs.unrealengine.com/en-US/API/Runtime/NavigationSystem/NavMesh/ARecastNavMesh/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are only two primary sections that are important to you right now:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Display`: The `Display` section, as the name suggests, only contains parameters
    that affect the visual debug display of the generated navigable area of `NavMeshBoundsVolume`.
    It is recommended that you try toggling each of the parameters under this category
    to see how it affects the display of the generated Nav Mesh.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Generation`: The `Generation` category contains a set of values that act as
    a rule set for how the Nav Mesh will generate and determine which areas of geometry
    are navigable, and which are not. There are many options here, which can make
    the concept very daunting, but let''s discuss just a handful of the parameters
    under this category:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Cell Size` refers to the accuracy in which the Nav Mesh can generate navigable
    space within an area. You will be updating this value in the next step of this
    exercise, so you''ll see how this affects the navigable area in real time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Agent Radius` refers to the radius of the actor that will be navigating this
    area. In the case of your game, the radius to set here is the radius of the collision
    component of the character with the largest radius.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Agent Height` refers to the height of the actor that will be navigating this
    area. In the case of your game, the height to set here is the Half Height of the
    collision component of the character with the largest Half Height. You can multiply
    it by `2.0f` to get the full height.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Agent Max Slope` refers to the slope angle for inclines that can exist in
    your game world. By default, the value is `44` degrees, and this is a parameter
    you will leave alone unless your game requires that it changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Agent Max Step Height` refers to the height of steps, regarding staircase
    steps, that can be navigated by the AI. Much like `Agent Max Slope`, this is a
    parameter that you will more than likely leave alone unless your game specifically
    requires this value to change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you have learned about the Recast Nav Mesh parameters, let's put this
    knowledge into practice with the next exercise, where will walk you through changing
    a few of these parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.03: Recasting Nav Mesh Volume Parameters'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you have the `Nav Mesh` volume in the level, it is time to change the
    parameters of the `Recast Nav Mesh` actor so that the Nav Mesh allows the enemy
    AI to navigate across platforms that are thinner than others. This exercise will
    be performed within the Unreal Engine 4 editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following step will help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will be updating `Cell Size` and `Agent Height` so that they fit the needs
    of your character and the accuracy needed for the Nav Mesh:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows that the upper platforms are now navigable because
    of the changes we made to `Cell Size`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5: Changing Cell Size from 19.0f to 5.0f allows for the narrow'
  prefs: []
  type: TYPE_NORMAL
- en: upper platforms to be navigable
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_13_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.5: Changing Cell Size from 19.0f to 5.0f allows for the narrow upper
    platforms to be navigable'
  prefs: []
  type: TYPE_NORMAL
- en: With `SuperSideScrollerExampleMap` set up with its own `Nav Mesh`, you can now
    move on and create the AI logic for the enemy. Before doing so, complete the following
    activity to create your own level, with its own unique layout and `NavMeshBoundsVolume`
    actor that you can use for the remainder of this project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 13.01: Creating a New Level'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you have added `NavMeshBoundsVolume` to the example map, it is time
    to create your own map for the purposes of the rest of the `Super SideScroller`
    game. By creating your own map, you will have a better understanding of how `NavMeshBoundsVolume`
    and the properties of `RecastNavMesh` affect the environment they are placed in.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving on to the solution for this activity, if you need an example
    level that will work for the remaining chapters of the `SuperSideScroller` game,
    then don''t worry – this chapter comes with the `SuperSideScroller.umap` asset,
    as well as a map called `SuperSideScroller_NoNavMesh`, which does not contain
    the `NavMeshBoundsVolume`. You can use `SuperSideScroller.umap` as a reference
    for how to create your own level, or to get ideas on how to improve your own level.
    You can download the map here: [https://packt.live/3lo7v2f](https://packt.live/3lo7v2f).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to create a simplistic map:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `New Level`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name this level `SuperSideScroller`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the static mesh assets provided by default in the `Content Browser` interface
    of this project, create an interesting space with different elevations to navigate.
    Add your player character `Blueprint` to the level, and make sure it is possessed
    by `Player Controller 0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `NavMeshBoundsVolume` actor to your level and adjust its dimensions
    so that it fits the space you created. In the example map provided for this activity,
    the dimensions set should be `1000.0`, `5000.0`, and `2000.0` in the *X*, *Y*,
    and *Z* axes, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure to enable debug visualization for `NavMeshBoundsVolume` by pressing
    the `P` key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adjust the parameters of the `RecastNavMesh` actor so that `NavMeshBoundsVolume`
    works well for your level. In the case of the provided example map, the `Cell
    Size` parameter is set to `5.0f`, `Agent Radius` is set to `42.0f`, and `Agent
    Height` is set to `192.0f`. Use these values as a reference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Expected Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6: SuperSideScroller map'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_13_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.6: SuperSideScroller map'
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this activity, you will have a level that contains the required
    `NavMeshBoundsVolume` and settings for the `RecastNavMesh` actor. This will allow
    the AI we'll develop in the upcoming exercises to function correctly. Again, if
    you are unsure of how the level should look, please refer to the provided example
    map, `SuperSideScroller.umap`. Now, it is time to jump into developing the AI
    for the `SuperSideScroller` game.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  prefs: []
  type: TYPE_NORMAL
- en: Behavior Trees and Blackboards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Behavior trees and Blackboards work together to allow our AI to follow different
    logical paths and make decisions based on a variety of conditions and variables.
  prefs: []
  type: TYPE_NORMAL
- en: A **behavior tree** (**BT**) is a visual scripting tool that allows you to tell
    a pawn what to do based on certain factors and parameters. For example, a BT can
    tell an AI to move to a certain location based on whether the AI can see the player.
  prefs: []
  type: TYPE_NORMAL
- en: To give an example of how BTs and Blackboards are used in games, let's look
    at the game *Gears of War 5*, which was developed with Unreal Engine 4\. The AI
    in Gears of War 5, and throughout the Gears of War series, always try to flank
    the player, or force the player out of cover. In order to do this, a key component
    of the AI logic is to know who the player is, and where the player is. A reference
    variable to the player, and a location vector to store the location of the player,
    exist in the Blackboard. The logic that determines how these variables are used
    and how the AI will use this information is performed inside the behavior tree.
  prefs: []
  type: TYPE_NORMAL
- en: The Blackboard is where you define the set of variables that are required in
    order to have the behavior tree perform actions and use those values for decision-making.
  prefs: []
  type: TYPE_NORMAL
- en: The behavior tree is where you create the Tasks that you want the AI to perform,
    such as moving to a location, or performing a custom Task that you create. Like
    many of the in-editor tools in Unreal Engine 4, behavior trees are, for the most
    part, a very visual scripting experience.
  prefs: []
  type: TYPE_NORMAL
- en: '**Blackboards** are where you define the variables, also known as **Keys**,
    that will then be referenced by the **behavior tree**. The Keys you create here
    can be used in **Tasks**, **Services**, and **Decorators** to serve different
    purposes based on how you want the AI to function. The following screenshot shows
    an example set of variable Keys that can be referenced by its associated behavior
    tree.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Without a Blackboard, behavior trees would have no way of passing and storing
    information across different Tasks, Services, or Decorators, rendering it useless:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7: An example set of variables inside a Blackboard that'
  prefs: []
  type: TYPE_NORMAL
- en: can be accessed in the behavior tree
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_13_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.7: An example set of variables inside a Blackboard that can be accessed
    in the behavior tree'
  prefs: []
  type: TYPE_NORMAL
- en: '**Behavior trees** are composed of a set of **objects** – that is, **Composites**,
    **Tasks**, **Decorators**, and **Services** – that work together to define how
    the AI will behave and respond based on the conditions and logic flow that you
    set. All behavior trees begin with what is called the Root where the logic flow
    begins; this cannot be modified and has only one execution branch. Let''s take
    a look at these objects in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: Composites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Composite nodes function as a means to tell the behavior tree how to go about
    performing Tasks and other actions. The following screenshot shows the full list
    of Composite nodes that Unreal Engine gives you by default: Selector, Sequence,
    and Simple Parallel.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Composite nodes can also have Decorators and Services attached to them in order
    to have optional conditions applied before a behavior tree branch is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.8: The full list of Composite nodes – Selector, Sequence, and Simple
    Parallel'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_13_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.8: The full list of Composite nodes – Selector, Sequence, and Simple
    Parallel'
  prefs: []
  type: TYPE_NORMAL
- en: '`Selector`: The Selector composite node executes its children from left to
    right and will stop executing when one of the children Tasks succeeds. Using the
    example shown in the following screenshot, if the `FinishWithResult` task is successful,
    the parent Selector succeeds, which will cause the Root to execute again and `FinishWithResult`
    to execute once more. This pattern will continue until `FinishWithResult` fails.
    The Selector will then execute `MakeNoise`. If `MakeNoise` fails, the `Selector`
    fails, and the Root will execute again. If the `MakeNoise` task succeeds, then
    the Selector will succeed, and the Root will execute again. Depending on the flow
    of the behavior tree, if the Selector fails or succeeds, the next composite branch
    will begin to execute. In the following screenshot, there are no other composite
    nodes, so if the Selector fails or succeeds, the Root node will be executed again.
    However, if there were a Sequence composite node with multiple Selector nodes
    underneath, each Selector would attempt to successfully execute its children.
    Regardless of success or failure, each Selector will attempt execution sequentially:![Figure
    13.9: An example of how a Selector Composite node can be used in a behavior tree'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '](img/B16183_13_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.9: An example of how a Selector Composite node can be used in a behavior
    tree'
  prefs: []
  type: TYPE_NORMAL
- en: Note that when adding Tasks and `Composite` nodes, you will notice numeric values
    on the top-right corners of each node. These numbers indicate the order in which
    these nodes will be executed. The pattern follows the *top* to *bottom*, *left*
    to *right*, paradigm, and these values help you keep track of the ordering. Any
    disconnected Task or `Composite` node will be given a value of `–1` to indicate
    that it is unused.
  prefs: []
  type: TYPE_NORMAL
- en: '`Sequence`: The `Sequence` composite node executes its children from left to
    right and will stop executing when one of the children Tasks fails. Using the
    example shown in the following screenshot, if the `Move To` task is successful,
    then the parent Sequence node will execute the `Wait` task. If the `Wait` task
    is successful, then the Sequence is successful, and `Root` will execute again.
    If the `Move To` task fails, however, the Sequence will fail and `Root` will execute
    again, causing the `Wait` task to never execute:![Figure 13.10: An example of
    how a Sequence Composite node'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: can be used in a behavior tree
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_13_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.10: An example of how a Sequence Composite node can be used in a
    behavior tree'
  prefs: []
  type: TYPE_NORMAL
- en: '`Simple Parallel`: The `Simple Parallel` composite node allows you to execute
    a `Task` and a new standalone branch of logic simultaneously. The following screenshot
    shows a very basic example of what this will look like. In this example, a task
    used to `Wait` for `5` seconds is being executed at the same time as a new `Sequence`
    of Tasks is being executed:![Figure 13.11: An example of how a Selector Composite
    node can be used in a behavior tree'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '](img/B16183_13_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.11: An example of how a Selector Composite node can be used in a
    behavior tree'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Simple Parallel` composite node is also the only `Composite` node that
    has a parameter in its `Details` panel, which is `Finish Mode`. There are two
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Immediate`: When set to `Immediate`, the Simple Parallel will finish successfully
    once the main Task finishes. In this case, after the `Wait` task finishes, the
    background tree Sequence will abort and the entire `Simple Parallel` will execute
    again.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Delayed`: When set to `Delayed`, the Simple Parallel will finish successfully
    once the background tree finishes its execution and the Task finishes. In this
    case, the `Wait` task will finish after `5` seconds, but the entire `Simple Parallel`
    will wait for the `Move To` and `PlaySound` Tasks to execute before restarting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These are Tasks that our AI can perform. Unreal provides us with built-in Tasks
    for us to use by default, but we can also create our own in both Blueprints and
    in C++. This includes Tasks such as telling our AI to `Move To` a specific location,
    `Rotate To a direction`, and even telling the AI to fire its weapon. It''s also
    important to know that you can create your own custom Tasks using Blueprints.
    Let''s briefly discuss two of the Tasks you will be using to develop the AI for
    the enemy character:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Move To Task`: This is one of the more commonly used Tasks in behavior trees,
    and you will be using this task in the upcoming exercises in this chapter. `Move
    To task` uses the navigation system to tell the AI how and where to move based
    on the location it is given. You will use this task to tell the AI enemy where
    to go.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Wait Task`: This is another commonly used task in behavior trees because it
    allows a delay in between task execution if the logic requires it. This can be
    used to allow the AI to wait a few seconds before moving to a new location.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decorators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Decorators` are conditions that can be added to Tasks or `Composite` nodes,
    such as a `Sequence` or `Selector`, that allows branching logic to occur. As an
    example, we can have a `Decorator` that checks whether or not the enemy knows
    the location of the player. If so, we can tell that enemy to move toward that
    last known location. If not, we can tell our AI to generate a new location and
    move there instead. It is also important to know that you can create your own
    custom Decorators using Blueprints.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's also briefly discuss the Decorator you will be using to develop the AI
    for the enemy character – the `Is At Location` decorator. This determines whether
    the controlled pawn is at the location specified in the Decorator itself. This
    will be useful to you to ensure that the behavior tree is not executing until
    you know the AI has reached its given location.
  prefs: []
  type: TYPE_NORMAL
- en: Services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Services` work a lot like Decorators because they can be linked with `Tasks`
    and `Composite` nodes. The main difference is that a `Service` allows us to execute
    a branch of nodes based on the interval defined in the Service. It also important
    to know that you can create your own custom Services using Blueprints.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.04: Creating the AI Behavior Tree and Blackboard'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you have had an overview of behavior trees and Blackboards, this exercise
    will guide you through creating these assets, telling the AI controller to use
    the behavior tree you created, and assigning the Blackboard to the behavior tree.
    The Blackboard and behavior tree assets you will create here will be used for
    the `SuperSideScroller` game. This exercise will be performed within the Unreal
    Engine 4 editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Within the `Content Browser` interface, navigate to the `/Enemy/AI` directory.
    This is the same directory where you created the AI Controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this directory, *right-click* within the blank area of the `Content Browser`
    interface, navigate to the `Artificial Intelligence` option, and select `Behavior
    Tree` to create the `Behavior Tree` asset. Name this asset `BT_EnemyAI`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the same directory as the previous step, *right-click* again within the blank
    area of the `Content Browser` interface, navigate to the `Artificial Intelligence`
    option, and select `Blackboard` to create the `Blackboard` asset. Name this asset
    `BB_EnemyAI`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before we move on to telling the AI controller to run this new behavior tree,
    let's first assign the Blackboard to this behavior tree so that they are properly connected.
  prefs: []
  type: TYPE_NORMAL
- en: Open `BT_EnemyAI` by *double-clicking* the asset in the `Content Browser` interface.
    Once opened, navigate to the `Details` panel on the right-hand side and find the
    `Blackboard Asset` parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Left-click* the dropdown menu on this parameter and find the `BB_EnemyAI`
    `Blackboard` asset you created earlier. Compile and save the behavior tree before
    closing it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, open the AI Controller `BP_AIController_Enemy` asset by *double-clicking*
    it inside the `Content Browser` interface. Inside the controller, *right-click*
    and search for the `Run Behavior Tree` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `Run Behavior Tree` function is very straightforward: you assign a `Behavior
    Tree` to the controller and the function returns whether the behavior tree successfully
    began its execution.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, connect the `Event BeginPlay` event node to the execution pin of the
    `Run Behavior Tree` function and assign `Behavior Tree asset BT_EnemyAI`, which
    you created earlier in this exercise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: .
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.12: Assigning the BT_EnemyAI behavior tree'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_13_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.12: Assigning the BT_EnemyAI behavior tree'
  prefs: []
  type: TYPE_NORMAL
- en: With this exercise complete, the enemy AI Controller now knows to run the `BT_EnemyAI`
    behavior tree, and this behavior tree knows to use the Blackboard asset called
    `BB_EnemyAI`. With this in place, you can begin to use the behavior tree logic
    to develop the AI so that the enemy character can move around the level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.05: Creating a New Behavior Tree Task'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The goal of this exercise is to develop an AI task for the enemy AI that will
    allow the character to find a random point to move to within the bounds of the
    `Nav Mesh` volume in your level.
  prefs: []
  type: TYPE_NORMAL
- en: Although the `SuperSideScroller` game will only allow two-dimensional movement,
    let's get the AI to move anywhere within the 3D space of the level that you created
    in *Activity 13.01*, *Creating a New Level*, and then work to constrain the enemy
    to two dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to create this new Task for the enemy:'
  prefs: []
  type: TYPE_NORMAL
- en: First, open the Blackboard asset you created in the previous exercise, `BB_EnemyAI`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Left-click* on the `New Key` option at the top-left of `Blackboard` and select
    the `Vector` option. Name this vector `MoveToLocation`. You will use this `vector`
    variable to track the next move for the AI as it decides where to move to.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the purposes of this enemy AI, you will need to create a new `Task` because
    the currently available Tasks inside Unreal do not fit the needs of the enemy behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to and open the `Behavior Tree` asset you created in the previous exercise,
    `BT_EnemyAI`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Left-click* on the `New Task` option on the top toolbar. When creating a new
    `Task`, it will automatically open the task asset for you. However, if you have
    already created a Task, a dropdown list of options will appear when selecting
    the `New Task` option. Before working on the logic of this `Task`, you will rename
    the asset.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the `Task` asset window and navigate to `/Enemy/AI/`, which is where the
    `Task` was saved to. By default, the name provided is `BTTask_BlueprintBase_New`.
    Rename this asset `BTTask_FindLocation`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the new `Task` asset named, *double-click* to open `Task Editor`. New Tasks
    will have their Blueprint graphs completely empty and will not provide you with
    any default events to use in the graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Right-click* within the graph and from the context-sensitive search, find
    the `Event Receive Execute AI` option.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Left-click* the `Event Receive Execute AI` option to create the event node
    in the `Task` graph, as shown in the following screenshot:![Figure 13.13: Event
    Receive Execute AI returns both the Owner'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Controller and the Controlled Pawn
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_13_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.13: Event Receive Execute AI returns both the Owner Controller and
    the Controlled Pawn'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `Event Receive Execute AI` event will give you access to both the **Owner
    Controller** and the **Controlled Pawn**. You will use the Controlled Pawn for
    this Task in the upcoming steps.
  prefs: []
  type: TYPE_NORMAL
- en: Each `Task` requires a call to the `Finish Execute` function so that the `Behavior
    Tree` asset knows when it can move onto the next `Task` or branches off the tree.
    *Right-click* in the graph and search for `Finish Execute` via the context-sensitive
    search.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Left-click* the `Finish Execute` option from the context-sensitive search
    to create the node inside the Blueprint graph of your `Task`, as shown in the
    following screenshot:![Figure 13.14: The Finish Execute function, which has a
    Boolean parameter that determines whether the Task is successful'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_13_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.14: The Finish Execute function, which has a Boolean parameter that
    determines whether the Task is successful'
  prefs: []
  type: TYPE_NORMAL
- en: The next function that you need is called `GetRandomLocationInNavigableRadius`.
    This function, as the name suggests, returns a random vector location within a
    defined radius of the navigable area. This will allow the enemy character to find
    random locations and move to those locations.
  prefs: []
  type: TYPE_NORMAL
- en: '*Right-click* in the graph and search for `GetRandomLocationInNavigableRadius`
    inside the context-sensitive search. *Left-click* the `GetRandomLocationInNavigableRadius`
    option to place this function inside the graph.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With these two functions in place, and with `Event Receive Execute AI` ready,
    it is time to obtain the random location for the enemy AI.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the `Controlled Pawn` output of `Event Receive Execute AI`, find the `GetActorLocation`
    function via the context-sensitive search:![Figure 13.15: The enemy pawn''s location
    will serve as the origin'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: of the random point selection
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_13_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.15: The enemy pawn''s location will serve as the origin of the random
    point selection'
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect the vector return value from `GetActorLocation` to the `Origin` vector
    input parameter of the `GetRandomLocationInNavigableRadius` function, as shown
    in the following screenshot. Now, this function will use the enemy AI pawn''s
    location as the origin for determining the next random point:![Figure 13.16: Now,
    the enemy pawn location will be used as the origin'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: of the random point vector search
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_13_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.16: Now, the enemy pawn location will be used as the origin of the
    random point vector search'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to tell the `GetRandomLocationInNavigableRadius` function the
    `Radius` in which to check for the random point in the navigable area of the level.
    Set this value to `1000.0f`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The remaining parameters, `Nav Data` and `Filter Class`, can remain as they
    are. Now that you are getting a random location from `GetRandomLocationInNavigableRadius`,
    you will need to be able to store this value in the `Blackboard` vector that you
    created earlier in this exercise.
  prefs: []
  type: TYPE_NORMAL
- en: To get a reference to the `Blackboard` vector variable, you need to create a
    new variable inside of this `Task` that's of the `Blackboard Key Selector` type.
    Create this new variable and name it `NewLocation`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You now need to make this variable a `Public` variable so that it can be exposed
    inside the behavior tree. *Left-click* on the 'eye' icon so that the eye is visible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the `Blackboard Key Selector` variable ready, *left-click* and drag out
    a `Getter` of this variable. Then, pull from this variable and search for `Set
    Blackboard Value as Vector`, as shown in the following screenshot:![Figure 13.17:
    Set Blackboard Value has a variety of different types to support the different
    variables that can exist inside the Blackboard'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_13_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.17: Set Blackboard Value has a variety of different types to support
    the different variables that can exist inside the Blackboard'
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect the `RandomLocation` output vector from `GetRandomLocationInNavigableRadius`
    to the `Value` vector input parameter of `Set Blackboard Value as Vector`. Then,
    connect the execution pins of these two function nodes. The result will look as
    follows:![Figure 13.18: Now, the Blackboard vector value is assigned this new
    random location'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_13_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.18: Now, the Blackboard vector value is assigned this new random
    location'
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, you will use the `Return Value` Boolean output parameter of the `GetRandomLocationInNavigableRadius`
    function as the means to determine whether the `Task` executes successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect the Boolean output parameter to the `Success` input parameter of the
    `Finish Execute` function and connect the execution pins of the `Set Blackboard
    Value as Vector` and `Finish Execute` function nodes. The following screenshot
    shows the final result of the `Task` logic:![Figure 13.19: The final setup for
    the Task'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_13_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.19: The final setup for the Task'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the preceding screenshot in full resolution for better viewing
    at the following link: [https://packt.live/3lmLyk5](https://packt.live/3lmLyk5).'
  prefs: []
  type: TYPE_NORMAL
- en: By completing this exercise, you have created your first custom `Task` using
    Blueprints in Unreal Engine 4\. You now have a task that finds a random location
    within the navigable bounds of the `Nav Mesh Volume` of your level using the enemy
    pawn as the origin of this search. In the next exercise, you will implement this
    new `Task` in the behavior tree and see the enemy AI move around your level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.06: Creating the Behavior Tree Logic'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The goal of this exercise is to implement the new `Task` you created in the
    previous exercise inside the behavior tree in order to have the enemy AI find
    a random location within the navigable space of your level and then move to this
    location. You will use a combination of the `Composite`, `Task`, and `Services`
    nodes to accomplish this behavior. This exercise will be performed within the
    Unreal Engine 4 editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: To start, open the behavior tree you created in *Exercise 13.04*, *Creating
    the AI Behavior Tree and Blackboard*, which is `BT_EnemyAI`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside this `Behavior Tree`, *left-click* and drag from the bottom of the `Root`
    node and select the `Sequence` node from the context-sensitive search. The result
    will be the `Root` that's connected to the `Sequence` composite node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, from the `Sequence` node, *left-click* and drag to bring up the context-sensitive
    menu. In this menu, search for the `Task` you created in the last previous, `BTTask_FindLocation`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, the `BTTask_FindLocation` task should automatically assign the `New
    Location` key selector variable to the `MovetoLocation` vector variable from `Blackboard`.
    If this doesn't happen, you can assign this selector manually in the `Details`
    panel of the Task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, `BTTask_FindLocation` will assign the `NewLocation` selector to the `MovetoLocation`
    vector variable from `Blackboard`. This means that the random location that's
    returned from the task will be assigned to the `Blackboard` variable and that
    you can reference this variable in other Tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you are finding a valid random location and assigning this location
    to the `Blackboard` variable, that is, `MovetoLocation`, you can use the `Move
    To` task to tell the AI to move to this location.
  prefs: []
  type: TYPE_NORMAL
- en: '*Left-click* and pull from the `Sequence` composite node. Then, from the context-sensitive
    search, find the `Move To` task. Your `Behavior Tree` will now look as follows:![Figure
    13.20: After selecting the random location, the Move To task'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: will let the AI move to this new location
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_13_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.20: After selecting the random location, the Move To task will let
    the AI move to this new location'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the `Move To` task should assign `MoveToLocation` as its `Blackboard
    Key` value. If it doesn't, select the task. In its `Details` panel, you will find
    the `Blackboard Key` parameter, which is where you can assign the variable. While
    in the `Details` panel, also set `Acceptable Radius` to `50.0f`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, the behavior tree finds the random location using the `BTTask_FindLocation`
    custom task and tells the AI to move to that location using the `MoveTo` task.
    These two Tasks communicate the location to each other by referencing the `Blackboard`
    vector variable called `MovetoLocation`.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing to do here is to add a `Decorator` to the `Sequence` composite
    node so that it ensures that the enemy character is not at a random location before
    executing the tree again to find and move to a new location.
  prefs: []
  type: TYPE_NORMAL
- en: '*Right-click* on the top area of the `Sequence` and select `Add Decorator`.
    From the dropdown, *left-click* and select `Is at Location`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since you already have a vector parameter inside `Blackboard`, this `Decorator`
    should automatically assign `MovetoLocation` as `Blackboard Key`. Verify this
    by selecting the `Decorator` and making sure `Blackboard Key` is assigned to `MovetoLocation`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the Decorator in place, you have completed the behavior tree. The final
    result will look as follows:![Figure 13.21: The final setup for the behavior tree
    for the AI enemy'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_13_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.21: The final setup for the behavior tree for the AI enemy'
  prefs: []
  type: TYPE_NORMAL
- en: This behavior tree is telling the AI to find a random location using `BTTask_FindLocation`
    and assign this location to the Blackboard value called `MovetoLocation`. When
    this task is successful, the behavior tree will execute the `MoveTo` task, which
    will tell the AI to move to this new random location. The Sequence is wrapped
    in a `Decorator` that ensures that the enemy AI is at `MovetoLocation` before
    executing again, just as a safety net for the AI.
  prefs: []
  type: TYPE_NORMAL
- en: Before you can test the new AI behavior, make sure to place a `BP_Enemy AI`
    into your level if one is not already there from previous exercises and activities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, if you use `PIE`, or `Simulate`, you will see the enemy AI run around
    the map and move to random locations within `Nav Mesh Volume`:![Figure 13.22:
    The enemy AI will now move from location to location'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_13_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.22: The enemy AI will now move from location to location'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There can be some cases where the enemy AI will not move. This can be caused
    by the `GetRandomLocationInNavigableRadius` function not returning `True`. This
    is a known issue, and if it occurs, please restart the editor and try again.
  prefs: []
  type: TYPE_NORMAL
- en: By completing this exercise, you have created a fully functional behavior tree
    that allows the enemy AI to find and move to a random location within the navigable
    bounds of your level using `Nav Mesh Volume`. The Task you created in the previous
    exercise allows you to find this random point, while the `Move To` task allows
    the AI character to move toward this new location.
  prefs: []
  type: TYPE_NORMAL
- en: Due to how the `Sequence` composite node works, each task must complete successfully
    before it can move on to the next task, so first, the enemy successfully finds
    a random location and then moves toward this location. Only when the `Move To`
    task completes will the entire behavior tree start over and choose a new random location.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can move on to the next activity, where you will add to this behavior
    tree in order to have the AI wait between selecting a new random point so that
    the enemy isn't constantly moving.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 13.02: AI Moving to the Player Location'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous exercise, you were able to have the AI enemy character move
    to random locations within the bounds of `Nav Mesh Volume` by using a custom `Task`
    and the `MoveTo` task together.
  prefs: []
  type: TYPE_NORMAL
- en: In this activity, you will continue from the previous exercise and update the
    behavior tree. You will take advantage of the `Wait` task by using a `Decorator`,
    and also create your own new custom task to have the AI follow the player character
    and update its position every few seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `BT_EnemyAI` behavior tree that you created in the previous exercise,
    you will continue from where you left off and create a new Task. Do this by selecting
    `New Task` from the toolbar and choosing `BTTask_BlueprintBase`. Name this new
    Task `BTTask_FindPlayer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `BTTask_FindPlayer` Task, create a new Event called `Event Receive Execute
    AI`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the `Get Player Character` function in order to get a reference to the
    player; make sure to use `Player Index 0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the player character, call the `Get Actor Location` function in order to
    find the players' current location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Blackboard Key `Selector` variable inside this Task. Name this
    variable `NewLocation`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Left-click* and drag the `NewLocation` variable into the graph. From this
    variable, search for the `Set Blackboard Value` function as `Vector`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect `Set Blackboard Value` as a `Vector` function to the execution pin of
    the Event's `Receive Execute AI` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `Finish Execute` function, ensuring that the Boolean `Success` parameter
    is `True`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, connect `Set Blackboard Value` as a `Vector` function to the `Finish
    Execute` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and compile the Task `Blueprint` and return to the `BT_EnemyAI` behavior
    tree.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the `BTTask_FindLocation` Task with the new `BTTask_FindPlayer` Task
    so that this new Task is now the first task underneath the `Sequence` composite
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new `PlaySound` task as the third task underneath the `Sequence` composite
    node by following the custom `BTTask_FindLocation` and `Move To` Tasks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Sound to Play` parameter, add the `Explosion_Cue SoundCue` asset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an `Is At Location` Decorator to the `PlaySound` Task and ensure that the
    `MovetoLocation` Key is assigned to this `Decorator`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new `Wait` Task as the fourth Task underneath the `Sequence` composite
    node following the `PlaySound` Tasks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `Wait` task to wait `2.0f` seconds before completing successfully.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.23: Enemy AI following the player and updating to the player'
  prefs: []
  type: TYPE_NORMAL
- en: location every 2 seconds
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_13_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.23: Enemy AI following the player and updating to the player location
    every 2 seconds'
  prefs: []
  type: TYPE_NORMAL
- en: The enemy AI character will move to the players' last known location in the
    navigable space of the level and pause for `2.0f` seconds between each player
    position.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  prefs: []
  type: TYPE_NORMAL
- en: With this activity complete, you have learned to create a new Task that allows
    the AI to find the player location and move to the player's last known position.
    Before moving onto the next set of exercises, remove the `PlaySound` task and
    replace the `BTTask_FindPlayer` task with the `BTTask_FindLocation` task you created
    in *Exercise 13.05*, *Creating a New Behavior Tree Task*. Please refer to *Exercise
    13.05,* *Creating a New Behavior Tree Task* and *Exercise 13.06*, *Creating the
    Behavior Tree Logic*, to ensure the Behavior Tree is returned correctly. You will
    be using the `BTTask_FindLocation` task in the upcoming exercises.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, you will address this issue by developing a new `Blueprint`
    actor that will allow you to set up specific positions that the AI can move toward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.07: Creating the Enemy Patrol Locations'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The current issue with the AI enemy character is that they can move freely
    around the 3D navigable space because the behavior tree allows them to find a
    random location within that space. Instead, the AI needs to be given patrol points
    that you can specify and change in the editor. It will then choose one of these
    patrol points at random to move to. This is what you will do for the `SuperSideScroller`
    game: create patrol points that the enemy AI can move to. This exercise will show
    you how to create these patrol points using a simple *Blueprint* actor. This exercise
    will be performed within the Unreal Engine 4 editor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: First, navigate to the `/Enemy/Blueprints/` directory. This is where you will
    create the new `Blueprint` actor that will be used for the AI patrol points.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this directory, *right-click* and choose the `Blueprint Class` option by
    *left-clicking* this option from the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the `Pick Parent Class` menu prompt, *left-click* the `Actor` option to
    create a new `Blueprint` based on the `Actor` class:![Figure 13.24: The Actor
    class is the base class for all objects that'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: can be placed or spawned in the game world
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_13_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.24: The Actor class is the base class for all objects that can be
    placed or spawned in the game world'
  prefs: []
  type: TYPE_NORMAL
- en: Name this new asset `BP_AIPoints` and open this `Blueprint` by *double-clicking*
    the asset in the `Content Browser` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The interface for `Blueprints` shares many of the same features and layouts
    as other systems, such as `Animation Blueprints` and `Tasks`, so this should all
    look familiar to you.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the `Variables` tab on the left-hand side of the Blueprint UI and
    *left-click* on the `+Variable` button. Name this variable `Points`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `Variable Type` dropdown, *left-click* and select the `Vector` option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you will need to make this vector variable an `Array` so that you can
    store multiple patrol locations. *Left-click* the yellow icon next to `Vector`
    and *left-click* to select the `Array` option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The last step for setting up the `Points` vector variable is to enable `Instance
    Editable` and `Show 3D Widget`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Instance Editable` parameter allows this vector variable to be publicly
    visible on the actor when placed in a level, allowing each instance of this actor
    to have this variable available to edit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Show 3D Widget` allows you to position the vector value by using a visible
    3D transform widget in the editor viewport. You will see what this means in the
    next steps of this exercise. It is also important to note that the `Show 3D Widget`
    option is only available for variables that involve an actor transform, such as
    `Vectors` and `Transforms`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the simple actor set up, it is time to place the actor into the level and
    begin setting up the *Patrol Point* locations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `BP_AIPoints` actor Blueprint into your level, as shown in the following screenshot:![Figure
    13.25: The BP_AIPoints actor now in the level'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_13_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.25: The BP_AIPoints actor now in the level'
  prefs: []
  type: TYPE_NORMAL
- en: With the `BP_AIPoints` actor selected, navigate to its `Details` panel and find
    the `Points` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, you can add a new element to the vector array by *left-clicking* on the
    `+` symbol, as shown here:![Figure 13.26: You can have many elements inside of
    an array, but the larger the array, the more memory is allocated'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_13_26.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.26: You can have many elements inside of an array, but the larger
    the array, the more memory is allocated'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you add a new element to the vector array, you will see a 3D widget appear
    that you can then *left-click* to select and move around the level, as shown here:![Figure
    13.27: The first Patrol Point vector location'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_13_27.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.27: The first Patrol Point vector location'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As you update the position of the 3D widget that represents the element of the
    vector array, the 3D coordinates will update in the `Details` panel for the `Points`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, add as many elements into the vector array as you would like for the
    context of your level. Keep in mind that the positions of these patrol points
    should line up so that they make a straight line along the horizontal axis, parallel
    to the direction in which the character will move. The following screenshot shows
    the setup in the example `SideScroller.umap` level included in this exercise:![Figure
    13.28: The example Patrol Point path, as seen'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: in the SideScroller.umap example level
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_13_28.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.28: The example Patrol Point path, as seen in the SideScroller.umap
    example level'
  prefs: []
  type: TYPE_NORMAL
- en: Continue to repeat the final step to create multiple patrol points and position
    the 3D widgets as you see fit. You can use the provided `SideScroller.umap` example
    level as a reference on how to set up these `Patrol Points`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By completing this exercise, you have created a new `Actor` Blueprint that contains
    a `Vector`array of positions that you can now manually set using a 3D widget in
    the editor. With the ability to manually set the *Patrol Point* positions, you
    have full control over where the AI can move to, but there is one problem. There
    is no functionality in place to choose a point from this array and to pass it
    to the behavior tree so that the AI can move between these *Patrol Points*. Before
    you set up this functionality, let's learn a bit more about Vectors and Vector
    Transformation, as this knowledge will prove useful in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Vector Transformation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you jump into the next exercise, it is important that you get to know
    about Vector Transformation and, more importantly, what the `Transform Location`
    function does. When it comes to an actor''s location, there are two ways of thinking
    of its position: in terms of world space and local space. An actor''s position
    in world space is its location relative to the world itself; in more simple terms,
    this is the location where you place the actual actor into the level. An actor''s
    local position is its location relative to either itself or a parent actor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the `BP_AIPoints` actor as an example of what world space and
    local space are. Each of the locations of the `Points` array are local-space Vectors
    because they are positions relative to the world-space position of the `BP_AIPoints`
    actor itself. The following screenshot shows the list of Vectors in the `Points`
    array, as shown in the previous exercise. These values are positions relative
    to the location of the `BP_AIPoints` actor in your level:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.29: The local-space position Vectors of the Points array, relative'
  prefs: []
  type: TYPE_NORMAL
- en: to the world-space position of the BP_AIPoints actor
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_13_29.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.29: The local-space position Vectors of the Points array, relative
    to the world-space position of the BP_AIPoints actor'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to have the enemy AI move to the correct world space location of these
    `Points`, you need to use a function called `Transform Location`. This function
    takes in two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`T`: This is the supplied `Transform` that you use to convert the vector location
    parameter from a local-space into a world-space value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Location`: This is the `location` that is to be converted from local space
    to world space.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result of this vector transformation is then returned as the Return Value
    of the function. You will use this function in the next exercise to return a randomly
    selected vector point from the `Points` array and convert that value from a local-space
    vector into a world-space vector. This new world-space vector will then be used
    to tell the enemy AI where to move relative to the world. Let's implement this
    now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.08: Selecting a Random Point in an Array'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you have more information about Vectors and Vector Transformation,
    you can move onto this exercise, where you will create a simple `Blueprint` function
    to select one of the *Patrol Point* vector locations and transform its vector
    from a local space value into a world space value using a built-in function called
    `Transform Location`. By returning the world space value of the vector position,
    you can then pass this value to the *behavior tree* so that the AI will move to
    the correct position. This exercise will be performed within the Unreal Engine
    4 editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise. Let''s start by creating
    the new function:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate back to the `BP_AIPoints` Blueprint and create a new function by *left-clicking*
    the `+` button next to the `Functions` category on the left-hand side of the Blueprint
    editor. Name this function `GetNextPoint`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before you add logic to this function, select this function by *left-clicking*
    it under the `Functions` category to access its `Details` panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Details` panel, enable the `Pure` parameter so that this function is
    labeled as a `Pure Function`. You learned about `Pure Functions` in *Chapter 11*,
    *Blend Spaces 1D, Key Bindings, and State Machines*, when working in the Animation
    Blueprint for the player character; the same thing is happening here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, the `GetNextPoint` function needs to return a vector that the behavior
    tree can use to tell the enemy AI where to move to. Add this new output by *left-clicking*
    on the `+` symbol under the `Outputs` category of the `Details` function. Make
    the variable of type `Vector` and give it the name `NextPoint`, as shown in the
    following screenshot:![Figure 13.30: Functions can return multiple variables of
    different types,'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: depending on the needs of your logic
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_13_30.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.30: Functions can return multiple variables of different types, depending
    on the needs of your logic'
  prefs: []
  type: TYPE_NORMAL
- en: 'When adding an `Output` variable, the function will automatically generate
    a `Return` node and place it into the function graph, as shown in the following
    screenshot. You will use this output to return the new vector patrol point for
    the enemy AI to move to:![Figure 13.31: The automatically generated Return Node
    for the function, including the NewPoint vector output variable'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_13_31.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.31: The automatically generated Return Node for the function, including
    the NewPoint vector output variable'
  prefs: []
  type: TYPE_NORMAL
- en: Now that the function groundwork is completed, let's start adding the logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to pick a random position, first, you need to find the length of the
    `Points` array. Create a `Getter` of the `Points` vector and from this vector
    variable, *left-click* and drag to search for the `Length` function, as shown
    in the following screenshot:![Figure 13.32: The Length function is a pure function
    that returns the length of the array'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_13_32.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.32: The Length function is a pure function that returns the length
    of the array'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the integer output of the `Length` function, *left-click* and drag out
    to use the context-sensitive search to find the `Random Integer` function, as
    shown in the following screenshot. The `Random Integer` function returns a random
    integer between `0` and `Max value`; in this case, this is the `Length` of the
    `Points` vector array:![Figure 13.33: Using Random Integer will allow the function
    to return'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a random vector from the Points vector array
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_13_33.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.33: Using Random Integer will allow the function to return a random
    vector from the Points vector array'
  prefs: []
  type: TYPE_NORMAL
- en: So far, you are generating a random integer between `0` and the Length of the
    `Points` vector array. Next, you need to find the element of the `Points` vector
    array at the index position of the returned `Random Integer`.
  prefs: []
  type: TYPE_NORMAL
- en: Do this by creating a new `Getter of the Points` vector array. Then, *left-click*
    and drag to search for the `Get (a copy)` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, connect the Return Value of the `Random Integer` function to the input
    of the `Get (a copy)` function. This will tell the function to choose a random
    integer and use that integer as the index to return from the `Points` vector array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that you are getting a random vector from the `Points` vector array, you
    need to use the `Transform Location` function in order to convert the location
    from a local space into a world space vector.
  prefs: []
  type: TYPE_NORMAL
- en: As you have learned already, the Vectors in the `Points` array are local space
    positions relative to the position of the `BP_AIPoints` actor in the level. As
    a result, you need to use the `Transform Location` function to convert the randomly
    selected local space vector into a world-space vector so that the AI enemy moves
    to the correct position.
  prefs: []
  type: TYPE_NORMAL
- en: '*Left-click* and drag from the vector output of the `Get (a copy)` function
    and via the context-sensitive search, find the `Transform Location` function.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the vector output of the `Get (a copy)` function to the `Location` input
    of the `Transform Location` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final step is to use the transform of the Blueprint actor itself as the
    `T` parameter of the `Transform Location` function. Do this by *right-clicking*
    inside the graph and via the context-sensitive search, find the `GetActorTransform`
    function and connect it to the `Transform Location` parameter, `T`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, connect the `Return Value` vector from the `Transform Location` function
    and connect it to the `NewPoint` vector output of the function:![Figure 13.34:
    The final logic set up for the GetNextPoint function'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_13_34.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.34: The final logic set up for the GetNextPoint function'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the preceding screenshot in full resolution for better viewing
    at the following link: [https://packt.live/35jlilb](https://packt.live/35jlilb).'
  prefs: []
  type: TYPE_NORMAL
- en: By completing this exercise, you have created a new Blueprint function inside
    the `BP_AIPoints` actor that takes a random index from the `Points` array variable,
    transforms it into a world space vector value using the `Transform Location` function,
    and returns this new vector value. You will use this function inside the `BTTask_FindLocation`
    task, inside the AI behavior tree, so that the enemy will move to one of the points
    you have set up. Before you can do this, the enemy AI needs a reference to the
    `BP_AIPoints` actor so that it knows which points it can select from and move
    to. We'll do this in the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.09: Referencing the Patrol Point Actor'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that the `BP_AIPoints` actor has a function that returns a random transformed
    location from its array of vector patrol points, you need to have the enemy AI
    reference this actor in the level so that it knows which patrol points to reference.
    To do this, you will add a new `Object Reference` variable to the enemy character
    Blueprint and assign the `BP_AIPoints` actor that you placed in your level earlier.
    This exercise will be performed within the Unreal Engine 4 editor. Let's get started
    by adding the *Object Reference*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: An `Object Reference Variable` stores a reference to a specific class object
    or actor. With this reference variable, you can get access to the publicly exposed
    variables, events, and functions that this class has available.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the `/Enemy/Blueprints/` directory and open the enemy character
    Blueprint `BP_Enemy` by *double-clicking* the asset from the `Content Browser`
    interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new variable of the `BP_AIPoints` type and make sure the variable type
    is of `Object Reference`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to reference the existing `BP_AIPoints` actor in your level, you need
    to make the variable from the previous step a `Public Variable` by enabling the
    `Instance Editable` parameter. Name this variable `Patrol Points`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that you have the object reference set, navigate to your level and select
    your enemy AI. The following screenshot shows the enemy AI placed in the provided
    example level; that is, `SuperSideScroller.umap`. If you don''t have an enemy
    placed in your level, please do so now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Placing an enemy into a level works the same as it does for any other actor
    in Unreal Engine 4\. *Left-click* and drag the enemy AI Blueprint from the Content
    Browser interface into the level.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.35: The enemy AI placed in the example level SuperSideScroller.umap'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_13_35.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.35: The enemy AI placed in the example level SuperSideScroller.umap'
  prefs: []
  type: TYPE_NORMAL
- en: From its `Details` panel, find the `Patrol Points` variable under the `Default`
    category. The last thing to do here is assign the `BP_AIPoints` actor we already
    placed in the level in *Exercise 13.07*, *Creating the Enemy Patrol Locations*.
    Do this by *left-clicking* the dropdown menu for the `Patrol Points` variable
    and finding the actor from the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this exercise complete, the enemy AI in your level now has a reference
    to the `BP_AIPoints` actor in your level. With a valid reference in place, the
    enemy AI can use this actor to determine which set of points to move between inside
    the `BTTask_FindLocation` task. All that is left to do now is update the `BTTask_FindLocation`
    task so that it uses these points instead of finding a random location.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.10: Updating BTTask_FindLocation'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final step in completing the enemy AI patrolling behavior is to replace
    the logic inside `BTTask_FindLocation` so that it uses the `GetNextPoint` function
    from the `BP_AIPoints` actor instead of finding a random location within the navigable
    space of your level. This exercise will be performed within the Unreal Engine
    4 editor.
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder, check back and see how the `BTTask_FindLocation` task looked
    at the end of *Exercise 13.05*, *Creating a New Behavior Tree Task*, before you
    start.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to do is take the returned `Controlled Pawn` reference from
    `Event Receive Execute AI` and cast it to `BP_Enemy`, as shown in the following
    screenshot. This way, you can access the `Patrol Points` object reference variable
    from the previous exercise:![Figure 13.36: Casting also ensures that the returned
    Controlled Pawn'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: is of the BP_Enemy class type
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_13_36.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.36: Casting also ensures that the returned Controlled Pawn is of
    the BP_Enemy class type'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can access the `Patrol Points` object reference variable by *left-clicking*
    and dragging from the `As BP Enemy` pin under the cast to `BP_Enemy`, and via
    the context-sensitive search, finding `Patrol Points`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `Patrol Points` reference, you can *left-click* and drag to search
    for the `GetNextPoint` function that you created in *Exercise 13.08*, *Selecting
    a Random Point in an Array*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, you can connect the `NextPoint` vector output parameter of the `GetNextPoint`
    function to the `Set Blackboard Value as Vector` function and connect the execution
    pins from the cast to the `Set Blackboard Value as Vector` function. Now, each
    time the `BTTask_FindLocation` task is executed, a new random patrol point will
    be set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, connect the `Set Blackboard Value as Vector` function to the `Finish
    Execute` function and manually set the `Success` parameter to `True` so that this
    task will always succeed if the cast is successful.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As a failsafe, create a duplicate of `Finish Execute` and connect to the `Cast
    Failed` execution pin of the `Cast` function. Then, set the `Success` parameter
    to `False`. This will act as a failsafe so that if, for any reason, `Controlled
    Pawn` is not of the `BP_Enemy` class, the task will fail. This is a good debugging
    practice to ensure the functionality of the task for its intended AI class:![Figure
    13.37: It is always good practice to account for any casting failures in your
    logic'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_13_37.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.37: It is always good practice to account for any casting failures
    in your logic'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the preceding screenshot in full resolution for better viewing
    at the following link: [https://packt.live/3n58THA](https://packt.live/3n58THA).'
  prefs: []
  type: TYPE_NORMAL
- en: With the `BTTask_FindLocation` task updated to use the random patrol point from
    the `BP_AIPoints` actor reference in the enemy, the enemy AI will now move between
    the patrol points at random.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.38: The enemy AI now moving between the patrol point locations
    in the level'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_13_38.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.38: The enemy AI now moving between the patrol point locations in
    the level'
  prefs: []
  type: TYPE_NORMAL
- en: With this exercise complete, the enemy AI now uses the reference to the `BP_AIPoints`
    actor in the level to find and move to the patrol points in the level. Each instance
    of the enemy character in the level can have its own reference to another unique
    instance of the `BP_AIPoints` actor or can share the same instance reference.
    It is up to you how you would like each enemy AI to move throughout the level.
  prefs: []
  type: TYPE_NORMAL
- en: Player Projectile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the last section of this chapter, you will focus on creating the base of
    the player projectile, which can be used to destroy enemies. The goal is to create
    the appropriate actor class, introduce the required collision and projectile movement
    components to the class, and set up the necessary parameters for the projectile's
    motion behavior.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of simplicity, the player projectile will not use gravity, will
    destroy enemies with one hit, and the projectile itself will be destroyed on hitting
    any surface; it will not bounce off walls, for example. The primary goal of the
    player projectile is to have a projectile that the player can spawn and use to
    destroy enemies throughout the level. In this chapter, you will set up the basic
    framework functionality, while in *Chapter 14*, *Spawning the Player Projectile*,
    you will add sound and visual effects. Let's get started by creating the player
    projectile class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.11: Creating the Player Projectile'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up until this point, we have been working on in the Unreal Engine 4 editor to
    create our enemy AI. For the player projectile, we will be using C++ and Visual
    Studio to create this new class. The player projectile will allow the player to
    destroy enemies that are placed in the level. This projectile will have a short
    lifespan, travel at a high speed, and will collide with both enemies and the environment.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this exercise is to set up the base actor class for the player projectile
    and begin outlining the functions and components needed in the header file for
    the projectile.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: First, you will need to create a new C++ class using the `Actor` class as the
    parent class for the player projectile. Next, name this new actor class `PlayerProjectile`
    and *left-click* on the `Create Class` option at the bottom-right of the menu
    prompt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After creating the new class, Visual Studio will generate the required source
    and header files for the class and open these files for you. The actor base class
    comes included with a handful of default functions that you will not need for
    the player projectile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the following lines of code inside the `PlayerProjectile.h` file and remove
    them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: These lines of code represent the declarations of the `Tick()` and `BeginPlay()`
    functions that are included in every Actor-based class by default. The `Tick()`
    function is called on every frame and allows you to perform logic on every frame,
    which can get expensive, depending on what you are trying to do. The `BeginPlay()`
    function is called when this actor is initialized and play has started. This can
    be used to perform logic on the actor as soon as it enters the world. These functions
    are being removed because they are not required for `Player Projectile` and will
    just clutter the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'After removing these lines from the `PlayerProjectile.h` header file, you can
    now remove the following lines from the `PlayerProjectile.cpp` source files as
    well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: These lines of code represent the function implementations of the two functions
    you removed in the previous step; that is, `Tick()` and `BeginPlay()`. Again,
    these are being removed because they serve no purposes for `Player Projectile`
    and just add clutter to the code. Additionally, without the declarations inside
    the `PlayerProjectile.h` header file, you would receive a compilation error if
    you were to try to compile this code as is. The only remaining function will be
    the constructor for the projectile class, which you will use to initialize the
    components of the projectile in the next exercise. Now that you have removed the
    unnecessary code from the `PlayerProjectile` class, let's add the functions and
    components required for the projectile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `PlayerProjectile.h` header file, add the following components.
    Let''s discuss these components in detail:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There are three different components you are adding here. The first is the collision
    component, which you will use for the projectile to recognize collisions with
    enemies and environment assets. The next component is the projectile movement
    component, which you should be familiar with from the last project. This will
    allow the projectile to behave like a projectile. The final component is the static
    mesh component. You will use this to give this projectile a visual representation
    so that it can be seen in-game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the following function signature code to the `PlayerProjectile.h`
    header file, under the `public` access modifier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This final event declaration will allow the player projectile to respond to
    `OnHit` events from the `CollisionComp` component you created in the previous
    step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in order to have this code compile, you will need to implement the function
    from the previous step in the `PlayerProjectile.cpp` source file. Add the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `OnHit` event provides you with a lot of information about the collision
    that takes place. The most important parameter that you will be working with in
    the next exercise is the `OtherActor` parameter. The `OtherActor` parameter will
    tell you the actor in which this `OnHit` event is responding to. This will allow
    you to know if this other actor was an enemy. You will use this information to
    destroy the enemies when the projectile hits them.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, navigate back into the Unreal Engine editor and *left-click* the `Compile`
    option to compile the new code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this exercise complete, you now have the framework ready for the `Player
    Projectile` class. The class has the required components for `Projectile Movement`,
    `Collision`, and `Static Mesh`, as well as the event signature ready for the `OnHit`
    collision so that the projectile can recognize collisions with other actors.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, you will continue to customize and enable parameters for
    `Player Projectile` so that it behaves the way you need it to for the `SuperSideScroller`
    project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.12: Initializing Player Projectile Settings'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that the framework of the `PlayerProjectile` class is in place, it's time
    to update the constructor of this class with the default settings needed for the
    projectile so that it moves and behaves as you want it to. In order to do this,
    you will need to initialize the `Projectile Movement`, `Collision`, and `Static
    Mesh` components.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio and navigate to the `PlayerProjectile.cpp` source file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before adding any code to the constructor, include the following files inside
    the `PlayerProjectile.cpp` source file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: These header files will allow you to initialize and update the parameters of
    the projectile movement component, the sphere collision component, and the static
    mesh component respectively. Without these files included, the `PlayerProjectile`
    class wouldn't know how to handle these components and how to access their functions
    and parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the `APlayerProjectile::APlayerProjectile()` constructor function
    includes the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This line of code can be removed entirely because it is not required in the
    player projectile.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `PlayerProjectile.cpp` source file, add the following lines to the `APlayerProjectile::APlayerProjectile()`
    constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line initializes the sphere collision component and assigns it to
    the `CollisionComp` variable you created in the previous exercise. `Sphere Collision
    Component` has a parameter called `InitSphereRadius`. This will determine the
    size, or radius, of the collision actor by default; in this case, a value of `15.0f`
    works well. Next, set `Collision Profile Name` for the collision component to
    `BlockAll` so that the collision profile is set to `BlockAll`, which means this
    collision component will respond to `OnHit` when it collides with other objects.
    Lastly, the last line you added allows the `OnComponentHit` event to respond with
    the function you created in the previous exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This means that when the collision component receives the `OnComponentHit` event
    from a collision event, it will respond with that function; however, this function
    is empty at the moment. You will add code to this function later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing to do with `Collision Component` is to set this component as
    the `root` component of the player projectile actor. Add the following line of
    code in the constructor, after the lines from *Step 4*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'With the collision component set up and ready, let''s move on to the `Projectile
    Movement` component. Add the following lines to the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This first line initializes `Projectile Movement Component` and assigns it to
    the `ProjectileMovement` variable you created in the previous exercise. Next,
    we set `CollisionComp` as the updated component of the projectile movement component.
    The reason we're doing this is because the `Projectile Movement` component will
    use the `root` component of the actor as the component to move. Then, you are
    setting the gravity scale of the projectile to `0.0f` because the player projectile
    should not be affected by gravity; the behavior should allow the projectile to
    travel at the same speed, at the same height, and not be influenced by gravity.
    Lastly, you are setting both the `InitialSpeed` and `MaxSpeed` parameters to `500.0f`.
    This will allow the projectile to instantly start moving at this speed and remain
    at this speed for the duration of its lifetime. The player projectile will not
    support any kind of acceleration motion.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the projectile movement component initialized and set up, it is time to
    do the same for `Static Mesh Component`. Add the following code after the lines
    from the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This first line initializes `Static Mesh Component` and assigns it to the `MeshComp`
    variable you created in the previous exercise. Then, you attach this static mesh
    component to `RootComponent` using a struct called `FAttachmentTransformRules`
    to ensure that the `Static Mesh Component` keeps its world transform during the
    attachment which is `CollisionComp` from *Step 5* of this exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more information about the `FAttachmentTransformRules` struct
    here: [https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/FAttachmentTransformRules/index.html](https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/FAttachmentTransformRules/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, let''s give `Player Projectile` an initial life span of `3` seconds
    so that the projectile will automatically be destroyed if it doesn''t collide
    with anything after this time. Add the following code to the end of the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, navigate back into the Unreal Engine editor and *left-click* the `Compile`
    option to compile the new code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By completing this exercise, you have set up the groundwork for `Player Projectile`
    so that it can be created as a *Blueprint* actor inside the editor. All three
    required components are initialized and contain the default parameters that you
    want for this projectile. All we need to do now is create the *Blueprint* from
    this class to see it in the level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 13.03: Creating the Player Projectile Blueprint'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To conclude this chapter, you will create the `Blueprint` actor from the new
    `PlayerProjectile` class and customize this actor so that it uses a placeholder
    shape for `Static Mesh Component` for debugging purposes. This allows you to view
    the projectile in the game world. Then, you will add a `UE_LOG()` function to
    the `APlayerProjectile::OnHit` function inside the `PlayerProjectile.cpp` source
    file so that you can ensure that this function is called when the projectile comes
    into contact with an object in the level. You will need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `Content Browser` interface, create a new folder called `Projectile`
    in the `/MainCharacter` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this directory, create a new Blueprint from the `PlayerProjectile` class,
    which you created in *Exercise 13.11*, *Creating the Player Projectile*. Name
    this Blueprint `BP_PlayerProjectile`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `BP_PlayerProjectile` and navigate to its components. Select the `MeshComp`
    component to access its settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `Shape_Sphere` mesh to the Static Mesh parameter of the `MeshComp `component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the Transform of `MeshComp` so that it fits the `Scale and Location
    of the CollisionComp` component. Use the following values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Compile and save the `BP_PlayerProjectile` Blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the `PlayerProjectile.cpp` source file in Visual Studio and find
    the `APlayerProjectile::OnHit` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the function, implement the `UE_LOG` call so that the logged line is
    of `LogTemp`, `Warning log level`, and displays the text `HIT`. `UE_LOG` was covered
    back in *Chapter 11*, *Blend Spaces 1D, Key Bindings, and State Machines*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile your code changes and navigate to the level where you placed the `BP_PlayerProjectile`
    actor in the previous exercise. If you don't have this actor added to the level,
    do so now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before testing, make sure to open the Output Log in the `Window` option. From
    the `Window` dropdown, hover over the `Developers Tools` option and *left-click*
    to select `Output Log`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `PIE` and watch out for the log warning inside `Output Log` when the projectile
    collides with something.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.39: Scale of the MeshComp better fits the size of the Collision
    Comp'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_13_39.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.39: Scale of the MeshComp better fits the size of the Collision Comp'
  prefs: []
  type: TYPE_NORMAL
- en: 'The log warning should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.40: When the projectile hits an object, the text HIT is shown in
    the Output Log'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_13_40.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.40: When the projectile hits an object, the text HIT is shown in
    the Output Log'
  prefs: []
  type: TYPE_NORMAL
- en: With this final activity complete, `Player Projectile` is ready for the next
    chapter, where you will spawn this projectile when the player uses the `Throw`
    action. You will update the `APlayerProjectile::OnHit` function so that it destroys
    the enemy that it collides with and becomes an effective offensive tool for the
    player to use against the enemies.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use the different aspects of the AI tools
    offered by Unreal Engine 4, including Blackboards, behavior trees, and AI Controllers.
    With a combination of both custom created Tasks and default Tasks provided by
    Unreal Engine 4, and with a Decorator, you were able to have the enemy AI navigate
    within the bounds of the Nav Mesh you added to your own level.
  prefs: []
  type: TYPE_NORMAL
- en: On top of this, you created a new Blueprint actor that allows you to add patrol
    points with the use of a `Vector` array variable. You then added a new function
    to this actor that selects one of these points at random, converts its location
    from local space into world space, and then returns this new value for use by
    the enemy character.
  prefs: []
  type: TYPE_NORMAL
- en: With the ability to randomly select a Patrol Point, you updated the custom `BTTask_FindLocation`
    task to find and move to the selected Patrol Point, allowing the enemy to move
    from each Patrol Point at random. This brought the enemy AI character to a whole
    new level of interaction with the player and the environment.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, you created the Player Projectile that the player will be able to use
    in order to destroy enemies within the environment. You took advantage of both
    `Projectile Movement Component` and `Sphere Component` to allow for both projectile
    movement and to recognize and respond to collisions within the environment.
  prefs: []
  type: TYPE_NORMAL
- en: With the Player Projectile in a functional state, it is time to move on to the
    next chapter, where you will use `Anim Notifies` to spawn the projectile when
    the player uses the `Throw` action.
  prefs: []
  type: TYPE_NORMAL
