- en: 13\. Enemy Artificial Intelligence
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13. 敌人人工智能
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter begins with a brief recap of how the enemy AI will behave for the
    `SuperSideScroller` game. From there, you will learn about Controllers in the
    context of Unreal Engine 4 and learn how to create an AI Controller. Then, you
    will learn more about AI navigation in Unreal Engine 4 by adding a Nav Mesh to
    the main level of the game.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以简要回顾《超级横向卷轴》游戏中敌人人工智能的行为方式开始。然后，你将学习虚幻引擎4中的控制器，并学习如何创建一个AI控制器。接着，你将学习如何通过在游戏的主要关卡中添加导航网格来更多地了解虚幻引擎4中的AI导航。
- en: By the end of this chapter, you will be able to create a navigable space where
    the enemy can move. You will also be able to create an enemy AI pawn and navigate
    it across locations using Blackboard and behavior trees. Lastly, you will know
    how to create and implement a player projectile class and add visual elements
    to it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章的学习，你将能够创建一个敌人可以移动的可导航空间。你还将能够创建一个敌人AI角色，并使用黑板和行为树在不同位置之间导航。最后，你将学会如何创建和实现一个玩家投射物类，并为其添加视觉元素。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, you added layered animations for the player character
    using Animation Blending with a combination of Anim Slots, Animation Blueprints,
    and blending functions such as Layered Blend per Bone.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你使用了动画混合、动画插槽、动画蓝图和混合函数（如每骨层混合）为玩家角色添加了分层动画。
- en: In this chapter, you will learn how to use a Nav Mesh to create a navigable
    space inside of the game world that the enemy can move in. Defining the navigable
    space of a level is crucial for allowing **artificial intelligence** (**AI**)
    to access and move to specific areas of your level.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用导航网格在游戏世界内创建一个可导航的空间，使敌人可以在其中移动。定义关卡的可导航空间对于允许人工智能访问和移动到关卡的特定区域至关重要。
- en: Next, you will create an enemy AI pawn that can navigate between patrol point
    locations inside the game world using a combination of the AI tools present inside
    Unreal Engine 4, including *Blackboards* and *behavior trees*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将创建一个敌人AI角色，使用虚幻引擎4中的*黑板*和*行为树*等AI工具在游戏世界内的巡逻点位置之间导航。
- en: You will also learn how to use a Nav Mesh to create a navigable space inside
    the game world where the enemy can move. Defining the navigable space of a level
    is crucial for allowing the AI to access and move to specific areas of your level.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将学习如何使用导航网格在游戏世界内创建一个可导航的空间，使敌人可以在其中移动。定义关卡的可导航空间对于允许AI访问和移动到关卡的特定区域至关重要。
- en: Lastly, you'll learn how to create a player projectile class in C++ and how
    to implement the `OnHit()` collision event function to recognize and log when
    the projectile hits an object in the game world. In addition to creating the class,
    you will then create a Blueprint of this player projectile class and add visual
    elements to the player projectile, such as a Static Mesh.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将学习如何在C++中创建一个玩家投射物类，以及如何实现`OnHit()`碰撞事件函数来识别并记录投射物击中游戏世界中的物体。除了创建类之外，你还将创建这个玩家投射物类的蓝图，并为玩家投射物添加视觉元素，如静态网格。
- en: The `SuperSideScroller` game is finally coming together and you will be in a
    good position by the end of this chapter to move on to *Chapter 14*, *Spawning
    the Player Projectile*, where you will handle adding elements of polish to the
    game, such as SFX and VFX.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 《超级横向卷轴》游戏终于要完成了，通过本章的学习，你将在很好的位置上，可以继续学习*第14章*《生成玩家投射物》，在那里你将处理游戏的一些细节，如音效和视觉效果。
- en: The primary focus of this chapter is to take the C++ enemy class you created
    in *Chapter 12*, *Animation Blending and Montages*, and bring this enemy to life
    using AI. Unreal Engine 4 uses many different tools to achieve AI such as AI Controllers,
    Blackboards, and behavior trees, all of which you will learn about and use in
    this chapter. Before you jump into these systems, let's take a moment to learn
    about how AI is used in games in recent history. AI has certainly evolved since
    the days of *Super Mario Bros*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要重点是使用人工智能使你在*第12章*《动画混合和蒙太奇》中创建的C++敌人类活灵活现。虚幻引擎4使用许多不同的工具来实现人工智能，如AI控制器、黑板和行为树，你将在本章中学习并使用这些工具。在你深入了解这些系统之前，让我们花一点时间了解近年来游戏中人工智能的使用方式。自从《超级马里奥兄弟》以来，人工智能显然已经发展了许多。
- en: Enemy AI
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敌人人工智能
- en: What is AI? This term can mean many things, depending on the field and context
    that it is used in, so let's define it in a way that makes sense regarding the
    subject of video games.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是人工智能？这个术语可以有很多不同的含义，取决于它所用于的领域和背景，因此让我们以一种对视频游戏主题有意义的方式来定义它。
- en: '**AI** is an entity that is aware of its environment and performs choices that
    will help optimally achieve its intended purpose. AI uses what are called **finite
    state machines** to switch between more than one state based on the input it receives
    from the user or its environment. For example, a video game AI can switch between
    an offensive state to a defensive state based on its current health.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**AI**是一个意识到自己环境并做出选择以最优化地实现其预期目的的实体。AI使用所谓的**有限状态机**根据其从用户或环境接收到的输入切换多个状态之间。例如，视频游戏中的AI可以根据其当前的健康状态在攻击状态和防御状态之间切换。'
- en: 'In games such as *Hello Neighbor*, which was developed in Unreal Engine 4,
    and *Alien: Isolation*, the goal of the AI is to find the player as efficiently
    as possible, but also to follow some predetermined patterns defined by the developers
    to ensure that the player can outsmart it. *Hello Neighbor* adds a very creative
    element to its AI by having it learn from the players'' past actions and tries
    to outsmart the player based on the knowledge it learns.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在《你好邻居》和《异形：孤立》等游戏中，AI的目标是尽可能高效地找到玩家，同时也遵循开发者定义的一些预定模式，以确保玩家可以智胜。《你好邻居》通过让AI从玩家过去的行为中学习并试图根据所学知识智胜玩家，为其AI添加了一个非常有创意的元素。
- en: 'You can find an informative breakdown of how the AI works in this video by
    the publishers of the game, *TinyBuild Games*, here: [https://www.youtube.com/watch?v=Hu7Z52RaBGk](https://www.youtube.com/watch?v=Hu7Z52RaBGk).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在游戏发布商*TinyBuild Games*的视频中找到有关AI如何工作的信息：[https://www.youtube.com/watch?v=Hu7Z52RaBGk](https://www.youtube.com/watch?v=Hu7Z52RaBGk)。
- en: Interesting and fun AI is crucial to any game, and depending on the game you
    are making, this can mean a very complex or very simplistic AI. The AI that you
    will be creating for the `SuperSideScroller` game will not be as sophisticated
    as those mentioned previously, but it will fill the needs of the game we are seeking
    to create.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣和有趣的AI对于任何游戏都至关重要，取决于您正在制作的游戏，这可能意味着非常复杂或非常简单的AI。您将为“SuperSideScroller”游戏创建的AI不会像之前提到的那些那样复杂，但它将满足我们希望创建的游戏的需求。
- en: 'Let''s break down how the enemy will behave:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分析一下敌人的行为方式：
- en: The enemy will be a very simple enemy that has a basic back and forth movement
    pattern and will not support any attacks; only by colliding with the player character
    will they be able to inflict any damage.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敌人将是一个非常简单的敌人，具有基本的来回移动模式，不会支持任何攻击；只有与玩家角色碰撞，它们才能造成伤害。
- en: However, we need to set the locations to move between for the enemy AI.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，我们需要设置敌人AI要移动的位置。
- en: Next, we decide whether the AI should change locations, should constantly move
    between locations, or should there be a pause in between selecting a new location
    to move to?
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们决定AI是否应该改变位置，是否应该在不同位置之间不断移动，或者在选择新位置移动之间是否应该有暂停？
- en: Fortunately for us, Unreal Engine 4 provides us with a wide array of tools that
    we can use to develop such complex AI. In the case of our project, however, we
    will use these tools to create a simplistic enemy type. Let's start by discussing
    what an AI Controller is in Unreal Engine 4.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，对于我们来说，虚幻引擎4为我们提供了一系列工具，我们可以使用这些工具来开发复杂的AI。然而，在我们的项目中，我们将使用这些工具来创建一个简单的敌人类型。让我们首先讨论一下虚幻引擎4中的AI控制器是什么。
- en: AI Controller
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AI控制器
- en: Let's discuss what the main difference is between a **Player Controller** and
    an **AI Controller**. Both of these actors derive from the base **Controller class**,
    and a Controller is used to take control of a **Pawn** or **Character** in order
    to control the actions of said pawn or character.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论**玩家控制器**和**AI控制器**之间的主要区别是什么。这两个角色都是从基本的**Controller类**派生出来的，控制器用于控制一个**Pawn**或**Character**的行动。
- en: While a Player Controller relies on the input of an actual player, an AI Controller
    applies AI to the characters they possess and responds to the environment based
    on the rules set forth by the AI. By doing so, the AI can make intelligent decisions
    in response to the player and other external factors, without the actual player
    explicitly telling it to do so. Multiple instances of the same AI pawn can share
    the same AI Controller, and the same AI Controller can be used across different
    AI pawn classes. AI, like all actors inside Unreal Engine 4, are spawned through
    the `UWorld` class.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家控制器依赖于实际玩家的输入，而AI控制器则将AI应用于他们所拥有的角色，并根据AI设置的规则对环境做出响应。通过这样做，AI可以根据玩家和其他外部因素做出智能决策，而无需实际玩家明确告诉它这样做。多个相同的AI
    pawn实例可以共享相同的AI控制器，并且相同的AI控制器可以用于不同的AI pawn类。像虚幻引擎4中的所有角色一样，AI是通过`UWorld`类生成的。
- en: Note
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You will be learning more about the `UWorld` class in *Chapter 14*, *Spawning
    the Player Projectile*, but as a reference, please read more here: [https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UWorld/index.html](https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UWorld/index.html).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在*第14章*“生成玩家投射物”中了解更多关于`UWorld`类的信息，但作为参考，请在这里阅读更多：[https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UWorld/index.html](https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UWorld/index.html)。
- en: The most important aspect of both the Player Controller and the AI Controller
    is the pawns they will control. Let's learn more about how AI Controllers handle
    this.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家控制器和AI控制器的最重要的方面是它们将控制的pawns。让我们更多地了解AI控制器如何处理这一点。
- en: Auto Possess AI
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动拥有AI
- en: 'Like all Controllers, the AI Controller must possess a *pawn*. In C++, you
    can use the following function to possess a pawn:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 像所有控制器一样，AI控制器必须拥有一个*pawn*。在C++中，您可以使用以下函数来拥有一个pawn：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can also use the following function to unpossess a pawn:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用以下功能取消拥有一个pawn：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There's also the `void AController::OnPossess(APawn* InPawn)` and `void AController::OnUnPossess()`
    functions, which are called whenever the `Possess()` and `UnPossess()` functions
    are called, respectively.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`void AController::OnPossess(APawn* InPawn)`和`void AController::OnUnPossess()`函数，分别在调用`Possess()`和`UnPossess()`函数时调用。
- en: 'When it comes to AI, especially in the context of Unreal Engine 4, there are
    two methods in which AI Pawns or Characters can be possessed by an AI Controller.
    Let''s take a look at these options:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在AI方面，特别是在虚幻引擎4的背景下，AI Pawns或Characters可以被AI Controller占有的方法有两种。让我们看看这些选项：
- en: '`Placed in World`: This first method is how you will be handling AI in this
    project; you will manually place these enemy actors into your game world, and
    the AI will take care of the rest once the game begins.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “放置在世界中”：这是您将在此项目中处理AI的第一种方法；一旦游戏开始，您将手动将这些敌人角色放置到游戏世界中，AI将在游戏开始后处理其余部分。
- en: '`Spawned`: This second method is only a little more complicated because it
    requires an explicit function call, either in C++ or Blueprint, to `Spawn` an
    instance of a specified class. The `Spawn Actor` method requires a handful of
    parameters, including the `World` object and `Transform` parameters such as `Location`
    and `Rotation`, to ensure that the instance that is spawned is spawned correctly.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “生成”：这是第二种方法，稍微复杂一些，因为它需要一个显式的函数调用，无论是在C++还是Blueprint中，都需要“生成”指定类的实例。`Spawn
    Actor`方法需要一些参数，包括`World`对象和`Transform`参数，如`Location`和`Rotation`，以确保正确生成实例。
- en: '`Placed in World or Spawned`: If you are unsure of which method you want to
    use, a safe option would be `Placed in World or Spawned`; that way, both methods
    are supported.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`放置在世界中或生成`：如果您不确定要使用哪种方法，一个安全的选项是`放置在世界中或生成`；这样两种方法都受支持。'
- en: For the purposes of the `SuperSideScroller` game, you will be using the `Placed
    In World` option because the AI you will create will be manually placed in the
    game level.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了`SuperSideScroller`游戏，您将使用`Placed In World`选项，因为您将手动放置游戏级别中的AI。
- en: 'Exercise 13.01: Implementing AI Controllers'
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.01：实现AI控制器
- en: Before the enemy pawn can do anything, it needs to be possessed by an AI Controller.
    This also needs to happen before any logic can be performed by the AI. This exercise
    will be performed within the Unreal Engine 4 editor. By the end of this exercise,
    you will have created an AI Controller and applied it to the enemy that you created
    in the previous chapter. Let's begin by creating the AI Controller actor.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在敌人pawn可以执行任何操作之前，它需要被AI控制器占有。这也需要在AI执行任何逻辑之前发生。这个练习将在虚幻引擎4编辑器中进行。完成这个练习后，您将创建一个AI控制器并将其应用于您在上一章中创建的敌人。让我们开始创建AI控制器角色。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成这个练习：
- en: Head to the `Content Browser` interface and navigate to the `Content/Enemy`
    directory.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`内容浏览器`界面，导航到`内容/Enemy`目录。
- en: '*Right-click* on the `Enemy` folder and select the `New Folder` option. Name
    this new folder `AI`. In the new `AI` folder directory, *right-click* and select
    the `Blueprint Class` option.'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键单击*`Enemy`文件夹，选择`新建文件夹`选项。将这个新文件夹命名为`AI`。在新的`AI`文件夹目录中，*右键单击*并选择`蓝图类`选项。'
- en: From the `Pick Parent Class` dialogue box, expand `All Classes` and manually
    search for the `AIController` class.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`选择父类`对话框中，展开`所有类`并手动搜索`AIController`类。
- en: '*Left-click* this class option and then *left-click* on the green `Select`
    option at the bottom to create a new `Blueprint` from this class. Please refer
    to the following screenshot to know where to find the `AIController` class. Also,
    take note of the tooltip that appears when hovering over the class option; it
    contains useful information about this class from the developers:![Figure 13.1:
    The AIController asset class, as found in the Pick Parent Class dialogue box'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*左键单击*此类选项，然后*左键单击*底部的绿色`选择`选项以从此类创建一个新的`蓝图`。请参考以下截图以了解在哪里找到`AIController`类。还要注意悬停在类选项上时出现的工具提示；它包含有关开发人员的有用信息：![图13.1：在选择父类对话框中找到的AIController资产类'
- en: '](img/B16183_13_01.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_01.jpg)'
- en: 'Figure 13.1: The AIController asset class, as found in the Pick Parent Class
    dialogue box'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1：在选择父类对话框中找到的AIController资产类
- en: With this new `AIController Blueprint` created, name this asset `BP_AIControllerEnemy`.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了这个新的`AIController蓝图`后，将此资产命名为`BP_AIControllerEnemy`。
- en: With the AI Controller created and named, it's time to assign this asset to
    the first enemy Blueprint that you made in the previous chapter.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: AI控制器已创建并命名，现在是将此资产分配给您在上一章中创建的第一个敌人蓝图的时候了。
- en: Navigate to the `/Enemy/Blueprints` directly to find `BP_Enemy`. *Double-click*
    to open this Blueprint.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 直接导航到`/Enemy/Blueprints`，找到`BP_Enemy`。*双击*打开此蓝图。
- en: In the `Details` panel of the first enemy `Blueprint`, there is a section labeled
    `Pawn`. This is where you can set different parameters regarding the AI functionality
    of `Pawn` or `Character`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个敌人`蓝图`的`详细信息`面板中，有一个标有`Pawn`的部分。这是您可以设置关于`Pawn`或`Character`的AI功能的不同参数的地方。
- en: The `AI Controller Class` parameter determines, as its name suggests, which
    AI Controller to use for this enemy. *Left-click* on the dropdown to find and
    select the AI Controller you made earlier; that is, `BP_AIController_Enemy`.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AI控制器类`参数确定了要为此敌人使用哪个AI控制器，*左键单击*下拉菜单以查找并选择您之前创建的AI控制器；即`BP_AIController_Enemy`。'
- en: With this exercise complete, the enemy AI now knows which AI Controller to use.
    This is crucial because it is in the AI Controller where the AI will use and execute
    the behavior tree you will create later in this chapter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个练习后，敌人AI现在知道要使用哪个AI控制器。这是至关重要的，因为在AI控制器中，AI将使用并执行您将在本章后面创建的行为树。
- en: The AI Controller is now assigned to the enemy, which means you are almost ready
    to start developing the actual intelligence for this AI. There is still one important
    topic to discuss before doing so, and that is the Navigation Mesh.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: AI控制器现在已分配给敌人，这意味着您几乎可以开始为这个AI开发实际的智能了。在这样做之前，还有一个重要的话题需要讨论，那就是导航网格。
- en: Navigation Mesh
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航网格
- en: One of the most crucial aspects of any AI, especially in video games, is the
    ability to navigate the environment in a sophisticated manner. In Unreal Engine
    4, there is a way for the engine to tell the AI which parts of an environment
    navigable and which parts are not. This is done through a **Navigation Mesh**,
    or **Nav Mesh** for short.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 任何AI的最关键方面之一，尤其是在视频游戏中，就是以复杂的方式导航环境。在虚幻引擎4中，引擎有一种方法告诉AI哪些环境部分是可导航的，哪些部分不是。这是通过**导航网格**或**Nav
    Mesh**来实现的。
- en: The term Mesh is misleading here because it's implemented through a volume in
    the editor. We will need a Navigation Mesh in our level so that our AI can effectively
    navigate the playable bounds of the game world. We'll add one together in the
    following exercise.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的Mesh一词有误导性，因为它是通过编辑器中的一个体积来实现的。我们需要在我们的级别中有一个导航网格，这样我们的AI才能有效地导航游戏世界的可玩范围。我们将在下面的练习中一起添加一个。
- en: Unreal Engine 4 also supports a `Dynamic Navigation Mesh`, which allows the
    Nav Mesh to update in real-time as dynamic objects move around the environment.
    This results in the AI recognizing these changes in the environment and updating
    their pathing/navigation appropriately. This book will not cover this, but you
    can access the configuration options via `Project Settings -> Navigation Mesh
    -> Runtime Generation`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.02: Implementing a Nav Mesh Volume for the AI Enemy'
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will add a Navigation Mesh to `SideScrollerExampleMap`
    and explore how Navigation Meshes work in Unreal Engine 4\. You'll also learn
    how to parameterize this volume for the needs of your game. This exercise will
    be performed within the Unreal Engine 4 editor.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this exercise, you will have a stronger understanding of the Nav
    Mesh. You will also be able to implement this volume in your own level in the
    activity that follows this exercise. Let's begin by adding the Nav Mesh volume
    to the level.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: If you do not already have the map open, please open `SideScrollerExampleMap`
    by navigating to `File` and *left-clicking* on the `Open Level` option. From the
    `Open Level` dialogue box, navigate to `/SideScrollerCPP/Maps` to find `SideScrollerExampleMap`.
    Select this map with a *left-click* and then *left-click* `Open` at the bottom
    to open the map.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the map opened, navigate to the right-hand side to find the `Modes` panel.
    The `Modes` panel is a set of easily accessible actor types such as `Volumes`,
    `Lights`, `Geometry`, and others. Under the `Volumes` category, you will find
    the `Nav Mesh Bounds Volume` option.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Left-click* and drag this volume into the map/scene. By default, you will
    see the outline of the volume in the editor. Press the `P` key to visualize the
    `Navigation` area that the volume encompasses, but make sure that the volume is
    intersecting with the ground geometry in order to see the green visualization,
    as shown in the following screenshot:![Figure 13.2: Areas outlined in green are
    perceived as navigable by the engine and the AI'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_13_02.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.2: Areas outlined in green are perceived as navigable by the engine
    and the AI'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: With the `Nav Mesh` volume in place, let's adjust its shape so that the volume
    extends to the entire area of the level. After this, you'll learn how to adjust
    the parameters of the `Nav Mesh` volume for the purposes of the game.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '*Left-click* to select `NavMeshBoundsVolume` and navigate to its `Details`
    panel. There is a section labeled `Brush Settings` that allows you to adjust the
    shape and size of the volume. Find the values that fit best for you. Some suggested
    settings are `Brush Type: Additive`, `Brush Shape: Box`, `X: 3000.0`, `Y: 3000.0`,
    and `Z: 3000.0`.'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Notice that when the shape and dimensions of `NavMeshBoundsVolume` change,
    `Nav Mesh` will adjust and recalculate the navigable area. This can be seen in
    the following screenshot. You will also notice that the upper platforms are not
    navigable; you will fix this later:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3: Now, NavMeshBoundsVolume extends to the entire playable'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: area of the example map
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_13_03.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.3: Now, NavMeshBoundsVolume extends to the entire playable area of
    the example map'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: By completing this exercise, you have placed your first `NavMeshBoundsVolume`
    actor into the game world and, using the debug key, `'P'`, visualized the navigable
    area in the default map. Next, you will learn more about the `RecastNavMesh` actor,
    which is also created when placing `NavMeshBoundsVolume` into the level.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Recasting the Nav Mesh
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you added `NavMeshBoundsVolume`, you may have noticed that another actor
    was created automatically: a `RecastNavMesh` actor called `RecastNavMesh-Default`.
    This `RecastNavMesh` acts as the "brain" of the Nav Mesh because it contains the
    parameters needed to adjust the Nav Mesh that directly influences how the AI navigates
    the given area.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows this asset, as seen from the `World Outliner`
    tab:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了此资产，从 `World Outliner` 选项卡中看到：
- en: '![Figure 13.4: The RecastNavMesh actor, as seen from the World Outliner tab'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.4：从世界大纲器选项卡中看到的 RecastNavMesh actor'
- en: '](img/B16183_13_04.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_04.jpg)'
- en: 'Figure 13.4: The RecastNavMesh actor, as seen from the World Outliner tab'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4：从世界大纲器选项卡中看到的 RecastNavMesh actor
- en: Note
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There are a lot of parameters that exist in `RecastNavMesh`, and we will only
    be covering the important parameters in this book. For more information, check
    out [https://docs.unrealengine.com/en-US/API/Runtime/NavigationSystem/NavMesh/ARecastNavMesh/index.html](https://docs.unrealengine.com/en-US/API/Runtime/NavigationSystem/NavMesh/ARecastNavMesh/index.html).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`RecastNavMesh` 中存在许多参数，我们只会在本书中涵盖重要的参数。有关更多信息，请查看 [https://docs.unrealengine.com/en-US/API/Runtime/NavigationSystem/NavMesh/ARecastNavMesh/index.html](https://docs.unrealengine.com/en-US/API/Runtime/NavigationSystem/NavMesh/ARecastNavMesh/index.html)。'
- en: 'There are only two primary sections that are important to you right now:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只有两个对您重要的主要部分：
- en: '`Display`: The `Display` section, as the name suggests, only contains parameters
    that affect the visual debug display of the generated navigable area of `NavMeshBoundsVolume`.
    It is recommended that you try toggling each of the parameters under this category
    to see how it affects the display of the generated Nav Mesh.'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Display`：`Display` 部分，顾名思义，只包含影响 `NavMeshBoundsVolume` 生成的可导航区域的可视化调试显示的参数。建议您尝试切换此类别下的每个参数，以查看它如何影响生成的
    Nav Mesh 的显示。'
- en: '`Generation`: The `Generation` category contains a set of values that act as
    a rule set for how the Nav Mesh will generate and determine which areas of geometry
    are navigable, and which are not. There are many options here, which can make
    the concept very daunting, but let''s discuss just a handful of the parameters
    under this category:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Generation`：`Generation` 类别包含一组值，作为 Nav Mesh 生成和确定哪些几何区域是可导航的，哪些不可导航的规则集。这里有很多选项，这可能使概念非常令人生畏，但让我们只讨论这个类别下的一些参数：'
- en: '`Cell Size` refers to the accuracy in which the Nav Mesh can generate navigable
    space within an area. You will be updating this value in the next step of this
    exercise, so you''ll see how this affects the navigable area in real time.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cell Size` 指的是 Nav Mesh 在区域内生成可导航空间的精度。您将在本练习的下一步中更新此值，因此您将看到这如何实时影响可导航区域。'
- en: '`Agent Radius` refers to the radius of the actor that will be navigating this
    area. In the case of your game, the radius to set here is the radius of the collision
    component of the character with the largest radius.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Agent Radius` 指的是将要在该区域导航的角色的半径。在您的游戏中，这里设置的半径是具有最大半径的角色的碰撞组件的半径。'
- en: '`Agent Height` refers to the height of the actor that will be navigating this
    area. In the case of your game, the height to set here is the Half Height of the
    collision component of the character with the largest Half Height. You can multiply
    it by `2.0f` to get the full height.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Agent Height` 指的是将要在该区域导航的角色的高度。在您的游戏中，这里设置的高度是具有最大 Half Height 的角色的碰撞组件的一半高度。您可以将其乘以
    `2.0f` 来获得完整的高度。'
- en: '`Agent Max Slope` refers to the slope angle for inclines that can exist in
    your game world. By default, the value is `44` degrees, and this is a parameter
    you will leave alone unless your game requires that it changes.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Agent Max Slope` 指的是游戏世界中可以存在的斜坡的坡度角度。默认情况下，该值为 `44` 度，这是一个参数，除非您的游戏需要更改，否则您将不会更改。'
- en: '`Agent Max Step Height` refers to the height of steps, regarding staircase
    steps, that can be navigated by the AI. Much like `Agent Max Slope`, this is a
    parameter that you will more than likely leave alone unless your game specifically
    requires this value to change.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Agent Max Step Height` 指的是 AI 可以导航的台阶的高度，关于楼梯台阶。与 `Agent Max Slope` 类似，这是一个参数，除非您的游戏明确需要更改此值，否则您很可能不会更改。'
- en: Now that you have learned about the Recast Nav Mesh parameters, let's put this
    knowledge into practice with the next exercise, where will walk you through changing
    a few of these parameters.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了 Recast Nav Mesh 参数，让我们将这些知识付诸实践，进行下一个练习，其中将指导您更改其中一些参数。
- en: 'Exercise 13.03: Recasting Nav Mesh Volume Parameters'
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 13.03：重新设置 Nav Mesh 体积参数
- en: Now that you have the `Nav Mesh` volume in the level, it is time to change the
    parameters of the `Recast Nav Mesh` actor so that the Nav Mesh allows the enemy
    AI to navigate across platforms that are thinner than others. This exercise will
    be performed within the Unreal Engine 4 editor.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您在关卡中有了 `Nav Mesh` 体积，是时候改变 `Recast Nav Mesh` actor 的参数，以便 Nav Mesh 允许敌人 AI
    在比其他平台更薄的平台上导航。这个练习将在虚幻引擎 4 编辑器中进行。
- en: 'The following step will help you complete this exercise:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成这个练习：
- en: 'You will be updating `Cell Size` and `Agent Height` so that they fit the needs
    of your character and the accuracy needed for the Nav Mesh:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将更新 `Cell Size` 和 `Agent Height`，使其适应您的角色的需求和 Nav Mesh 所需的精度：
- en: '[PRE2]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following screenshot shows that the upper platforms are now navigable because
    of the changes we made to `Cell Size`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了由于我们对 `Cell Size` 进行的更改，上层平台现在是可导航的：
- en: '![Figure 13.5: Changing Cell Size from 19.0f to 5.0f allows for the narrow'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.5：将 Cell Size 从 19.0f 更改为 5.0f，使狭窄的上层平台可导航'
- en: upper platforms to be navigable
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 上层平台可导航
- en: '](img/B16183_13_05.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_05.jpg)'
- en: 'Figure 13.5: Changing Cell Size from 19.0f to 5.0f allows for the narrow upper
    platforms to be navigable'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5：将 Cell Size 从 19.0f 更改为 5.0f，使狭窄的上层平台可导航
- en: With `SuperSideScrollerExampleMap` set up with its own `Nav Mesh`, you can now
    move on and create the AI logic for the enemy. Before doing so, complete the following
    activity to create your own level, with its own unique layout and `NavMeshBoundsVolume`
    actor that you can use for the remainder of this project.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为 `SuperSideScrollerExampleMap` 设置自己的 `Nav Mesh`，您现在可以继续并为敌人创建 AI 逻辑。在这样做之前，完成以下活动，创建您自己的关卡，具有独特的布局和
    `NavMeshBoundsVolume` actor，您可以在本项目的其余部分中使用。
- en: 'Activity 13.01: Creating a New Level'
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动13.01：创建新级别
- en: Now that you have added `NavMeshBoundsVolume` to the example map, it is time
    to create your own map for the purposes of the rest of the `Super SideScroller`
    game. By creating your own map, you will have a better understanding of how `NavMeshBoundsVolume`
    and the properties of `RecastNavMesh` affect the environment they are placed in.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经在示例地图中添加了`NavMeshBoundsVolume`，是时候为`Super SideScroller`游戏的其余部分创建你自己的地图了。通过创建自己的地图，你将更好地理解`NavMeshBoundsVolume`和`RecastNavMesh`的属性如何影响它们所放置的环境。
- en: Note
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Before moving on to the solution for this activity, if you need an example
    level that will work for the remaining chapters of the `SuperSideScroller` game,
    then don''t worry – this chapter comes with the `SuperSideScroller.umap` asset,
    as well as a map called `SuperSideScroller_NoNavMesh`, which does not contain
    the `NavMeshBoundsVolume`. You can use `SuperSideScroller.umap` as a reference
    for how to create your own level, or to get ideas on how to improve your own level.
    You can download the map here: [https://packt.live/3lo7v2f](https://packt.live/3lo7v2f).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续解决这个活动之前，如果你需要一个可以用于`SuperSideScroller`游戏剩余章节的示例级别，那就不用担心了——本章附带了`SuperSideScroller.umap`资源，以及一个名为`SuperSideScroller_NoNavMesh`的地图，不包含`NavMeshBoundsVolume`。你可以使用`SuperSideScroller.umap`作为创建自己级别的参考，或者获取如何改进自己级别的想法。你可以在这里下载地图：[https://packt.live/3lo7v2f](https://packt.live/3lo7v2f)。
- en: 'Perform the following steps to create a simplistic map:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤创建一个简单的地图：
- en: Create a `New Level`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`新级别`。
- en: Name this level `SuperSideScroller`.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个级别命名为`SuperSideScroller`。
- en: Using the static mesh assets provided by default in the `Content Browser` interface
    of this project, create an interesting space with different elevations to navigate.
    Add your player character `Blueprint` to the level, and make sure it is possessed
    by `Player Controller 0`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用该项目的`内容浏览器`界面中默认提供的静态网格资源，创建一个有不同高度的有趣空间以导航。将你的玩家角色`Blueprint`添加到级别中，并确保它由`Player
    Controller 0`控制。
- en: Add the `NavMeshBoundsVolume` actor to your level and adjust its dimensions
    so that it fits the space you created. In the example map provided for this activity,
    the dimensions set should be `1000.0`, `5000.0`, and `2000.0` in the *X*, *Y*,
    and *Z* axes, respectively.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`NavMeshBoundsVolume` actor添加到你的级别中，并调整其尺寸，使其适应你创建的空间。在为这个活动提供的示例地图中，设置的尺寸应分别为`1000.0`、`5000.0`和`2000.0`，分别对应*X*、*Y*和*Z*轴。
- en: Make sure to enable debug visualization for `NavMeshBoundsVolume` by pressing
    the `P` key.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保通过按下`P`键启用`NavMeshBoundsVolume`的调试可视化。
- en: Adjust the parameters of the `RecastNavMesh` actor so that `NavMeshBoundsVolume`
    works well for your level. In the case of the provided example map, the `Cell
    Size` parameter is set to `5.0f`, `Agent Radius` is set to `42.0f`, and `Agent
    Height` is set to `192.0f`. Use these values as a reference.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整`RecastNavMesh` actor的参数，使`NavMeshBoundsVolume`在你的级别中运行良好。在提供的示例地图中，`Cell
    Size`参数设置为`5.0f`，`Agent Radius`设置为`42.0f`，`Agent Height`设置为`192.0f`。使用这些值作为参考。
- en: 'Expected Output:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出：
- en: '![Figure 13.6: SuperSideScroller map'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.6：SuperSideScroller地图'
- en: '](img/B16183_13_06.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_06.jpg)'
- en: 'Figure 13.6: SuperSideScroller map'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6：SuperSideScroller地图
- en: By the end of this activity, you will have a level that contains the required
    `NavMeshBoundsVolume` and settings for the `RecastNavMesh` actor. This will allow
    the AI we'll develop in the upcoming exercises to function correctly. Again, if
    you are unsure of how the level should look, please refer to the provided example
    map, `SuperSideScroller.umap`. Now, it is time to jump into developing the AI
    for the `SuperSideScroller` game.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个活动的结束，你将拥有一个包含所需的`NavMeshBoundsVolume`和`RecastNavMesh` actor设置的级别。这将允许我们在接下来的练习中开发的AI能够正确运行。再次强调，如果你不确定级别应该是什么样子，请参考提供的示例地图`SuperSideScroller.umap`。现在，是时候开始开发`SuperSideScroller`游戏的AI了。
- en: Note
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在以下网址找到：[https://packt.live/338jEBx](https://packt.live/338jEBx)。
- en: Behavior Trees and Blackboards
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为树和黑板
- en: Behavior trees and Blackboards work together to allow our AI to follow different
    logical paths and make decisions based on a variety of conditions and variables.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 行为树和黑板共同工作，允许我们的AI遵循不同的逻辑路径，并根据各种条件和变量做出决策。
- en: A **behavior tree** (**BT**) is a visual scripting tool that allows you to tell
    a pawn what to do based on certain factors and parameters. For example, a BT can
    tell an AI to move to a certain location based on whether the AI can see the player.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**行为树**（**BT**）是一种可视化脚本工具，允许你根据特定因素和参数告诉一个角色该做什么。例如，一个行为树可以告诉一个AI根据AI是否能看到玩家而移动到某个位置。'
- en: To give an example of how BTs and Blackboards are used in games, let's look
    at the game *Gears of War 5*, which was developed with Unreal Engine 4\. The AI
    in Gears of War 5, and throughout the Gears of War series, always try to flank
    the player, or force the player out of cover. In order to do this, a key component
    of the AI logic is to know who the player is, and where the player is. A reference
    variable to the player, and a location vector to store the location of the player,
    exist in the Blackboard. The logic that determines how these variables are used
    and how the AI will use this information is performed inside the behavior tree.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明行为树和黑板在游戏中的使用，让我们看看使用虚幻引擎4开发的游戏*战争机器5*。战争机器5中的AI，以及整个战争机器系列，总是试图包抄玩家，或者迫使玩家离开掩体。为了做到这一点，AI逻辑的一个关键组成部分是知道玩家是谁，以及玩家在哪里。在黑板中存在一个对玩家的引用变量，以及一个用于存储玩家位置的位置向量。确定这些变量如何使用以及AI将如何使用这些信息的逻辑是在行为树中执行的。
- en: The Blackboard is where you define the set of variables that are required in
    order to have the behavior tree perform actions and use those values for decision-making.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 黑板是你定义的一组变量，这些变量是行为树执行动作和使用这些值进行决策所需的。
- en: The behavior tree is where you create the Tasks that you want the AI to perform,
    such as moving to a location, or performing a custom Task that you create. Like
    many of the in-editor tools in Unreal Engine 4, behavior trees are, for the most
    part, a very visual scripting experience.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '**Blackboards** are where you define the variables, also known as **Keys**,
    that will then be referenced by the **behavior tree**. The Keys you create here
    can be used in **Tasks**, **Services**, and **Decorators** to serve different
    purposes based on how you want the AI to function. The following screenshot shows
    an example set of variable Keys that can be referenced by its associated behavior
    tree.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'Without a Blackboard, behavior trees would have no way of passing and storing
    information across different Tasks, Services, or Decorators, rendering it useless:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7: An example set of variables inside a Blackboard that'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: can be accessed in the behavior tree
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_13_07.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.7: An example set of variables inside a Blackboard that can be accessed
    in the behavior tree'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '**Behavior trees** are composed of a set of **objects** – that is, **Composites**,
    **Tasks**, **Decorators**, and **Services** – that work together to define how
    the AI will behave and respond based on the conditions and logic flow that you
    set. All behavior trees begin with what is called the Root where the logic flow
    begins; this cannot be modified and has only one execution branch. Let''s take
    a look at these objects in more detail:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Composites
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Composite nodes function as a means to tell the behavior tree how to go about
    performing Tasks and other actions. The following screenshot shows the full list
    of Composite nodes that Unreal Engine gives you by default: Selector, Sequence,
    and Simple Parallel.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Composite nodes can also have Decorators and Services attached to them in order
    to have optional conditions applied before a behavior tree branch is executed:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.8: The full list of Composite nodes – Selector, Sequence, and Simple
    Parallel'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_13_08.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.8: The full list of Composite nodes – Selector, Sequence, and Simple
    Parallel'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '`Selector`: The Selector composite node executes its children from left to
    right and will stop executing when one of the children Tasks succeeds. Using the
    example shown in the following screenshot, if the `FinishWithResult` task is successful,
    the parent Selector succeeds, which will cause the Root to execute again and `FinishWithResult`
    to execute once more. This pattern will continue until `FinishWithResult` fails.
    The Selector will then execute `MakeNoise`. If `MakeNoise` fails, the `Selector`
    fails, and the Root will execute again. If the `MakeNoise` task succeeds, then
    the Selector will succeed, and the Root will execute again. Depending on the flow
    of the behavior tree, if the Selector fails or succeeds, the next composite branch
    will begin to execute. In the following screenshot, there are no other composite
    nodes, so if the Selector fails or succeeds, the Root node will be executed again.
    However, if there were a Sequence composite node with multiple Selector nodes
    underneath, each Selector would attempt to successfully execute its children.
    Regardless of success or failure, each Selector will attempt execution sequentially:![Figure
    13.9: An example of how a Selector Composite node can be used in a behavior tree'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '](img/B16183_13_09.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.9: An example of how a Selector Composite node can be used in a behavior
    tree'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Note that when adding Tasks and `Composite` nodes, you will notice numeric values
    on the top-right corners of each node. These numbers indicate the order in which
    these nodes will be executed. The pattern follows the *top* to *bottom*, *left*
    to *right*, paradigm, and these values help you keep track of the ordering. Any
    disconnected Task or `Composite` node will be given a value of `–1` to indicate
    that it is unused.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '`Sequence`: The `Sequence` composite node executes its children from left to
    right and will stop executing when one of the children Tasks fails. Using the
    example shown in the following screenshot, if the `Move To` task is successful,
    then the parent Sequence node will execute the `Wait` task. If the `Wait` task
    is successful, then the Sequence is successful, and `Root` will execute again.
    If the `Move To` task fails, however, the Sequence will fail and `Root` will execute
    again, causing the `Wait` task to never execute:![Figure 13.10: An example of
    how a Sequence Composite node'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`序列`：`序列`组合节点从左到右执行其子节点，并且当其中一个子任务失败时将停止执行。使用下面截图中显示的示例，如果`移动到`任务成功，那么父`序列`节点将执行`等待`任务。如果`等待`任务成功，那么序列成功，`根`将再次执行。然而，如果`移动到`任务失败，序列将失败，`根`将再次执行，导致`等待`任务永远不会执行：![图13.10：序列组合节点示例'
- en: can be used in a behavior tree
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在行为树中使用
- en: '](img/B16183_13_10.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_10.jpg)'
- en: 'Figure 13.10: An example of how a Sequence Composite node can be used in a
    behavior tree'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.10：序列组合节点在行为树中的使用示例
- en: '`Simple Parallel`: The `Simple Parallel` composite node allows you to execute
    a `Task` and a new standalone branch of logic simultaneously. The following screenshot
    shows a very basic example of what this will look like. In this example, a task
    used to `Wait` for `5` seconds is being executed at the same time as a new `Sequence`
    of Tasks is being executed:![Figure 13.11: An example of how a Selector Composite
    node can be used in a behavior tree'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`简单并行`：`简单并行`组合节点允许您同时执行`任务`和一个新的独立逻辑分支。下面的截图显示了这将是什么样子的一个非常基本的示例。在这个示例中，用于等待`5`秒的任务与执行一系列新任务的`序列`同时执行：![图13.11：选择器组合节点在行为树中的使用示例'
- en: '](img/B16183_13_11.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_11.jpg)'
- en: 'Figure 13.11: An example of how a Selector Composite node can be used in a
    behavior tree'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.11：选择器组合节点在行为树中的使用示例
- en: 'The `Simple Parallel` composite node is also the only `Composite` node that
    has a parameter in its `Details` panel, which is `Finish Mode`. There are two
    options:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`简单并行`组合节点也是唯一在其`详细信息`面板中具有参数的`组合`节点，即`完成模式`。有两个选项：'
- en: '`Immediate`: When set to `Immediate`, the Simple Parallel will finish successfully
    once the main Task finishes. In this case, after the `Wait` task finishes, the
    background tree Sequence will abort and the entire `Simple Parallel` will execute
    again.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`立即`：当设置为`立即`时，简单并行将在主任务完成后立即成功完成。在这种情况下，`等待`任务完成后，后台树序列将中止，整个`简单并行`将再次执行。'
- en: '`Delayed`: When set to `Delayed`, the Simple Parallel will finish successfully
    once the background tree finishes its execution and the Task finishes. In this
    case, the `Wait` task will finish after `5` seconds, but the entire `Simple Parallel`
    will wait for the `Move To` and `PlaySound` Tasks to execute before restarting.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`延迟`：当设置为`延迟`时，简单并行将在后台树完成执行并且任务完成后立即成功完成。在这种情况下，`等待`任务将在`5`秒后完成，但整个`简单并行`将等待`移动到`和`播放声音`任务执行后再重新开始。'
- en: Tasks
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务
- en: 'These are Tasks that our AI can perform. Unreal provides us with built-in Tasks
    for us to use by default, but we can also create our own in both Blueprints and
    in C++. This includes Tasks such as telling our AI to `Move To` a specific location,
    `Rotate To a direction`, and even telling the AI to fire its weapon. It''s also
    important to know that you can create your own custom Tasks using Blueprints.
    Let''s briefly discuss two of the Tasks you will be using to develop the AI for
    the enemy character:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们的AI可以执行的任务。虚幻引擎默认提供了内置任务供我们使用，但我们也可以在蓝图和C++中创建自己的任务。这包括任务，如告诉我们的AI`移动到`特定位置，`旋转到一个方向`，甚至告诉AI开火。还要知道，您可以使用蓝图创建自定义任务。让我们简要讨论一下您将用来开发敌人角色AI的两个任务：`
- en: '`Move To Task`: This is one of the more commonly used Tasks in behavior trees,
    and you will be using this task in the upcoming exercises in this chapter. `Move
    To task` uses the navigation system to tell the AI how and where to move based
    on the location it is given. You will use this task to tell the AI enemy where
    to go.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`移动到任务`：这是行为树中常用的任务之一，在本章的后续练习中将使用此任务。`移动到任务`使用导航系统告诉AI如何移动以及移动的位置。您将使用此任务告诉AI敌人要去哪里。'
- en: '`Wait Task`: This is another commonly used task in behavior trees because it
    allows a delay in between task execution if the logic requires it. This can be
    used to allow the AI to wait a few seconds before moving to a new location.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`等待任务`：这是行为树中另一个常用的任务，因为它允许在任务执行之间延迟。这可以用于允许AI在移动到新位置之前等待几秒钟。'
- en: Decorators
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器
- en: '`Decorators` are conditions that can be added to Tasks or `Composite` nodes,
    such as a `Sequence` or `Selector`, that allows branching logic to occur. As an
    example, we can have a `Decorator` that checks whether or not the enemy knows
    the location of the player. If so, we can tell that enemy to move toward that
    last known location. If not, we can tell our AI to generate a new location and
    move there instead. It is also important to know that you can create your own
    custom Decorators using Blueprints.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`装饰器`是可以添加到任务或`组合`节点（如`序列`或`选择器`）的条件，允许分支逻辑发生。例如，我们可以有一个`装饰器`来检查敌人是否知道玩家的位置。如果是，我们可以告诉敌人朝着上次已知的位置移动。如果不是，我们可以告诉我们的AI生成一个新位置并移动到那里。还要知道，您可以使用蓝图创建自定义装饰器。'
- en: Let's also briefly discuss the Decorator you will be using to develop the AI
    for the enemy character – the `Is At Location` decorator. This determines whether
    the controlled pawn is at the location specified in the Decorator itself. This
    will be useful to you to ensure that the behavior tree is not executing until
    you know the AI has reached its given location.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要讨论一下您将用来开发敌人角色AI的装饰器——`在位置`装饰器。这确定了受控棋子是否在装饰器本身指定的位置。这对您很有用，可以确保行为树在您知道AI已到达给定位置之前不执行。
- en: Services
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务
- en: '`Services` work a lot like Decorators because they can be linked with `Tasks`
    and `Composite` nodes. The main difference is that a `Service` allows us to execute
    a branch of nodes based on the interval defined in the Service. It also important
    to know that you can create your own custom Services using Blueprints.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`Services`与`Decorators`非常相似，因为它们可以与`Tasks`和`Composite`节点链接。主要区别在于`Service`允许我们根据服务中定义的间隔执行一系列节点。还要知道，您可以使用蓝图创建自定义服务。'
- en: 'Exercise 13.04: Creating the AI Behavior Tree and Blackboard'
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.04：创建AI行为树和黑板
- en: Now that you have had an overview of behavior trees and Blackboards, this exercise
    will guide you through creating these assets, telling the AI controller to use
    the behavior tree you created, and assigning the Blackboard to the behavior tree.
    The Blackboard and behavior tree assets you will create here will be used for
    the `SuperSideScroller` game. This exercise will be performed within the Unreal
    Engine 4 editor.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经对行为树和黑板有了概述，这个练习将指导您创建这些资产，告诉AI控制器使用您创建的行为树，并将黑板分配给行为树。您在这里创建的黑板和行为树资产将用于`SuperSideScroller`游戏。此练习将在虚幻引擎4编辑器中执行。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成此练习：
- en: Within the `Content Browser` interface, navigate to the `/Enemy/AI` directory.
    This is the same directory where you created the AI Controller.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Content Browser`界面中，导航到`/Enemy/AI`目录。这是您创建AI控制器的相同目录。
- en: In this directory, *right-click* within the blank area of the `Content Browser`
    interface, navigate to the `Artificial Intelligence` option, and select `Behavior
    Tree` to create the `Behavior Tree` asset. Name this asset `BT_EnemyAI`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此目录中，在`Content Browser`界面的空白区域*右键单击*，导航到`Artificial Intelligence`选项，并选择`Behavior
    Tree`以创建`Behavior Tree`资产。将此资产命名为`BT_EnemyAI`。
- en: In the same directory as the previous step, *right-click* again within the blank
    area of the `Content Browser` interface, navigate to the `Artificial Intelligence`
    option, and select `Blackboard` to create the `Blackboard` asset. Name this asset
    `BB_EnemyAI`.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一步的相同目录中，在`Content Browser`界面的空白区域再次*右键单击*，导航到`Artificial Intelligence`选项，并选择`Blackboard`以创建`Blackboard`资产。将此资产命名为`BB_EnemyAI`。
- en: Before we move on to telling the AI controller to run this new behavior tree,
    let's first assign the Blackboard to this behavior tree so that they are properly connected.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续告诉AI控制器运行这个新行为树之前，让我们首先将黑板分配给这个行为树，以便它们正确连接。
- en: Open `BT_EnemyAI` by *double-clicking* the asset in the `Content Browser` interface.
    Once opened, navigate to the `Details` panel on the right-hand side and find the
    `Blackboard Asset` parameter.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过*双击*`Content Browser`界面中的资产打开`BT_EnemyAI`。一旦打开，导航到右侧的`Details`面板，并找到`Blackboard
    Asset`参数。
- en: '*Left-click* the dropdown menu on this parameter and find the `BB_EnemyAI`
    `Blackboard` asset you created earlier. Compile and save the behavior tree before
    closing it.'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击此参数上的下拉菜单，并找到您之前创建的`BB_EnemyAI` `Blackboard`资产。在关闭之前编译和保存行为树。
- en: Next, open the AI Controller `BP_AIController_Enemy` asset by *double-clicking*
    it inside the `Content Browser` interface. Inside the controller, *right-click*
    and search for the `Run Behavior Tree` function.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过*双击*`Content Browser`界面内的AI控制器`BP_AIController_Enemy`资产来打开它。在控制器内，*右键单击*并搜索`Run
    Behavior Tree`函数。
- en: 'The `Run Behavior Tree` function is very straightforward: you assign a `Behavior
    Tree` to the controller and the function returns whether the behavior tree successfully
    began its execution.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`Run Behavior Tree`函数非常简单：您将行为树分配给控制器，函数返回行为树是否成功开始执行。'
- en: 'Lastly, connect the `Event BeginPlay` event node to the execution pin of the
    `Run Behavior Tree` function and assign `Behavior Tree asset BT_EnemyAI`, which
    you created earlier in this exercise:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将`Event BeginPlay`事件节点连接到`Run Behavior Tree`函数的执行引脚，并分配`Behavior Tree`资产`BT_EnemyAI`，这是您在此练习中创建的：
- en: .
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 。
- en: '![Figure 13.12: Assigning the BT_EnemyAI behavior tree'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.12：分配BT_EnemyAI行为树'
- en: '](img/B16183_13_12.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_12.jpg)'
- en: 'Figure 13.12: Assigning the BT_EnemyAI behavior tree'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.12：分配BT_EnemyAI行为树
- en: With this exercise complete, the enemy AI Controller now knows to run the `BT_EnemyAI`
    behavior tree, and this behavior tree knows to use the Blackboard asset called
    `BB_EnemyAI`. With this in place, you can begin to use the behavior tree logic
    to develop the AI so that the enemy character can move around the level.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此练习后，敌人AI控制器现在知道运行`BT_EnemyAI`行为树，并且此行为树知道使用名为`BB_EnemyAI`的黑板资产。有了这一点，您可以开始使用行为树逻辑来开发AI，以便敌人角色可以在级别中移动。
- en: 'Exercise 13.05: Creating a New Behavior Tree Task'
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.05：创建新的行为树任务
- en: The goal of this exercise is to develop an AI task for the enemy AI that will
    allow the character to find a random point to move to within the bounds of the
    `Nav Mesh` volume in your level.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习的目标是为敌人AI开发一个AI任务，使角色能够在您级别的`Nav Mesh`体积范围内找到一个随机点进行移动。
- en: Although the `SuperSideScroller` game will only allow two-dimensional movement,
    let's get the AI to move anywhere within the 3D space of the level that you created
    in *Activity 13.01*, *Creating a New Level*, and then work to constrain the enemy
    to two dimensions.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`SuperSideScroller`游戏只允许二维移动，让我们让AI在您在*Activity 13.01*中创建的级别的三维空间中移动，然后努力将敌人限制在二维空间内。
- en: 'Follow these steps to create this new Task for the enemy:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤为敌人创建新的任务：
- en: First, open the Blackboard asset you created in the previous exercise, `BB_EnemyAI`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开您在上一个练习中创建的黑板资产`BB_EnemyAI`。
- en: '*Left-click* on the `New Key` option at the top-left of `Blackboard` and select
    the `Vector` option. Name this vector `MoveToLocation`. You will use this `vector`
    variable to track the next move for the AI as it decides where to move to.'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Blackboard`的左上方*左键单击*`New Key`选项，并选择`Vector`选项。将此向量命名为`MoveToLocation`。您将使用此`vector`变量来跟踪AI的下一个移动位置。
- en: For the purposes of this enemy AI, you will need to create a new `Task` because
    the currently available Tasks inside Unreal do not fit the needs of the enemy behavior.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to and open the `Behavior Tree` asset you created in the previous exercise,
    `BT_EnemyAI`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Left-click* on the `New Task` option on the top toolbar. When creating a new
    `Task`, it will automatically open the task asset for you. However, if you have
    already created a Task, a dropdown list of options will appear when selecting
    the `New Task` option. Before working on the logic of this `Task`, you will rename
    the asset.'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the `Task` asset window and navigate to `/Enemy/AI/`, which is where the
    `Task` was saved to. By default, the name provided is `BTTask_BlueprintBase_New`.
    Rename this asset `BTTask_FindLocation`.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the new `Task` asset named, *double-click* to open `Task Editor`. New Tasks
    will have their Blueprint graphs completely empty and will not provide you with
    any default events to use in the graph.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Right-click* within the graph and from the context-sensitive search, find
    the `Event Receive Execute AI` option.'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Left-click* the `Event Receive Execute AI` option to create the event node
    in the `Task` graph, as shown in the following screenshot:![Figure 13.13: Event
    Receive Execute AI returns both the Owner'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Controller and the Controlled Pawn
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_13_13.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.13: Event Receive Execute AI returns both the Owner Controller and
    the Controlled Pawn'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: The `Event Receive Execute AI` event will give you access to both the **Owner
    Controller** and the **Controlled Pawn**. You will use the Controlled Pawn for
    this Task in the upcoming steps.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Each `Task` requires a call to the `Finish Execute` function so that the `Behavior
    Tree` asset knows when it can move onto the next `Task` or branches off the tree.
    *Right-click* in the graph and search for `Finish Execute` via the context-sensitive
    search.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Left-click* the `Finish Execute` option from the context-sensitive search
    to create the node inside the Blueprint graph of your `Task`, as shown in the
    following screenshot:![Figure 13.14: The Finish Execute function, which has a
    Boolean parameter that determines whether the Task is successful'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_13_14.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.14: The Finish Execute function, which has a Boolean parameter that
    determines whether the Task is successful'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: The next function that you need is called `GetRandomLocationInNavigableRadius`.
    This function, as the name suggests, returns a random vector location within a
    defined radius of the navigable area. This will allow the enemy character to find
    random locations and move to those locations.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '*Right-click* in the graph and search for `GetRandomLocationInNavigableRadius`
    inside the context-sensitive search. *Left-click* the `GetRandomLocationInNavigableRadius`
    option to place this function inside the graph.'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With these two functions in place, and with `Event Receive Execute AI` ready,
    it is time to obtain the random location for the enemy AI.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'From the `Controlled Pawn` output of `Event Receive Execute AI`, find the `GetActorLocation`
    function via the context-sensitive search:![Figure 13.15: The enemy pawn''s location
    will serve as the origin'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: of the random point selection
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_13_15.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.15: The enemy pawn''s location will serve as the origin of the random
    point selection'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect the vector return value from `GetActorLocation` to the `Origin` vector
    input parameter of the `GetRandomLocationInNavigableRadius` function, as shown
    in the following screenshot. Now, this function will use the enemy AI pawn''s
    location as the origin for determining the next random point:![Figure 13.16: Now,
    the enemy pawn location will be used as the origin'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: of the random point vector search
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_13_16.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.16: Now, the enemy pawn location will be used as the origin of the
    random point vector search'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to tell the `GetRandomLocationInNavigableRadius` function the
    `Radius` in which to check for the random point in the navigable area of the level.
    Set this value to `1000.0f`.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The remaining parameters, `Nav Data` and `Filter Class`, can remain as they
    are. Now that you are getting a random location from `GetRandomLocationInNavigableRadius`,
    you will need to be able to store this value in the `Blackboard` vector that you
    created earlier in this exercise.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: To get a reference to the `Blackboard` vector variable, you need to create a
    new variable inside of this `Task` that's of the `Blackboard Key Selector` type.
    Create this new variable and name it `NewLocation`.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You now need to make this variable a `Public` variable so that it can be exposed
    inside the behavior tree. *Left-click* on the 'eye' icon so that the eye is visible.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the `Blackboard Key Selector` variable ready, *left-click* and drag out
    a `Getter` of this variable. Then, pull from this variable and search for `Set
    Blackboard Value as Vector`, as shown in the following screenshot:![Figure 13.17:
    Set Blackboard Value has a variety of different types to support the different
    variables that can exist inside the Blackboard'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_13_17.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.17: Set Blackboard Value has a variety of different types to support
    the different variables that can exist inside the Blackboard'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect the `RandomLocation` output vector from `GetRandomLocationInNavigableRadius`
    to the `Value` vector input parameter of `Set Blackboard Value as Vector`. Then,
    connect the execution pins of these two function nodes. The result will look as
    follows:![Figure 13.18: Now, the Blackboard vector value is assigned this new
    random location'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_13_18.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.18: Now, the Blackboard vector value is assigned this new random
    location'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, you will use the `Return Value` Boolean output parameter of the `GetRandomLocationInNavigableRadius`
    function as the means to determine whether the `Task` executes successfully.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect the Boolean output parameter to the `Success` input parameter of the
    `Finish Execute` function and connect the execution pins of the `Set Blackboard
    Value as Vector` and `Finish Execute` function nodes. The following screenshot
    shows the final result of the `Task` logic:![Figure 13.19: The final setup for
    the Task'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_13_19.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.19: The final setup for the Task'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the preceding screenshot in full resolution for better viewing
    at the following link: [https://packt.live/3lmLyk5](https://packt.live/3lmLyk5).'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: By completing this exercise, you have created your first custom `Task` using
    Blueprints in Unreal Engine 4\. You now have a task that finds a random location
    within the navigable bounds of the `Nav Mesh Volume` of your level using the enemy
    pawn as the origin of this search. In the next exercise, you will implement this
    new `Task` in the behavior tree and see the enemy AI move around your level.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.06: Creating the Behavior Tree Logic'
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The goal of this exercise is to implement the new `Task` you created in the
    previous exercise inside the behavior tree in order to have the enemy AI find
    a random location within the navigable space of your level and then move to this
    location. You will use a combination of the `Composite`, `Task`, and `Services`
    nodes to accomplish this behavior. This exercise will be performed within the
    Unreal Engine 4 editor.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: To start, open the behavior tree you created in *Exercise 13.04*, *Creating
    the AI Behavior Tree and Blackboard*, which is `BT_EnemyAI`.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside this `Behavior Tree`, *left-click* and drag from the bottom of the `Root`
    node and select the `Sequence` node from the context-sensitive search. The result
    will be the `Root` that's connected to the `Sequence` composite node.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, from the `Sequence` node, *left-click* and drag to bring up the context-sensitive
    menu. In this menu, search for the `Task` you created in the last previous, `BTTask_FindLocation`.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从“Sequence”节点*左键单击*并拖动以打开上下文敏感菜单。在此菜单中，搜索您在上一个任务中创建的“任务”，即“BTTask_FindLocation”。
- en: By default, the `BTTask_FindLocation` task should automatically assign the `New
    Location` key selector variable to the `MovetoLocation` vector variable from `Blackboard`.
    If this doesn't happen, you can assign this selector manually in the `Details`
    panel of the Task.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，“BTTask_FindLocation”任务应自动将“New Location”键选择器变量分配给“Blackboard”的“MovetoLocation”向量变量。如果没有发生这种情况，您可以在任务的“详细信息”面板中手动分配此选择器。
- en: Now, `BTTask_FindLocation` will assign the `NewLocation` selector to the `MovetoLocation`
    vector variable from `Blackboard`. This means that the random location that's
    returned from the task will be assigned to the `Blackboard` variable and that
    you can reference this variable in other Tasks.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，“BTTask_FindLocation”将把“NewLocation”选择器分配给“Blackboard”的“MovetoLocation”向量变量。这意味着从任务返回的随机位置将被分配给“Blackboard”变量，并且您可以在其他任务中引用此变量。
- en: Now that you are finding a valid random location and assigning this location
    to the `Blackboard` variable, that is, `MovetoLocation`, you can use the `Move
    To` task to tell the AI to move to this location.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您正在查找有效的随机位置并将此位置分配给“Blackboard”变量，即“MovetoLocation”，您可以使用“Move To”任务告诉AI移动到此位置。
- en: '*Left-click* and pull from the `Sequence` composite node. Then, from the context-sensitive
    search, find the `Move To` task. Your `Behavior Tree` will now look as follows:![Figure
    13.20: After selecting the random location, the Move To task'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*左键单击*并从“Sequence”复合节点中拖动。然后，在上下文敏感搜索中找到“Move To”任务。您的“行为树”现在将如下所示：![图13.20：选择随机位置后，移动任务'
- en: will let the AI move to this new location
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 将让AI移动到这个新位置
- en: '](img/B16183_13_20.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_20.jpg)'
- en: 'Figure 13.20: After selecting the random location, the Move To task will let
    the AI move to this new location'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.20：选择随机位置后，移动任务将让AI移动到这个新位置
- en: By default, the `Move To` task should assign `MoveToLocation` as its `Blackboard
    Key` value. If it doesn't, select the task. In its `Details` panel, you will find
    the `Blackboard Key` parameter, which is where you can assign the variable. While
    in the `Details` panel, also set `Acceptable Radius` to `50.0f`.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，“Move To”任务应将“MoveToLocation”分配为其“Blackboard Key”值。如果没有，请选择任务。在其“详细信息”面板中，您将找到“Blackboard
    Key”参数，您可以在其中分配变量。在“详细信息”面板中，还将“可接受半径”设置为“50.0f”。
- en: Now, the behavior tree finds the random location using the `BTTask_FindLocation`
    custom task and tells the AI to move to that location using the `MoveTo` task.
    These two Tasks communicate the location to each other by referencing the `Blackboard`
    vector variable called `MovetoLocation`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，行为树使用“BTTask_FindLocation”自定义任务找到随机位置，并使用“MoveTo”任务告诉AI移动到该位置。这两个任务通过引用名为“MovetoLocation”的“Blackboard”向量变量相互通信位置。
- en: The last thing to do here is to add a `Decorator` to the `Sequence` composite
    node so that it ensures that the enemy character is not at a random location before
    executing the tree again to find and move to a new location.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要做的最后一件事是向“Sequence”复合节点添加一个“Decorator”，以确保敌人角色在再次执行树以查找并移动到新位置之前不处于随机位置。
- en: '*Right-click* on the top area of the `Sequence` and select `Add Decorator`.
    From the dropdown, *left-click* and select `Is at Location`.'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键单击*“Sequence”的顶部区域，然后选择“添加装饰者”。从下拉菜单中*左键单击*并选择“在位置”。'
- en: Since you already have a vector parameter inside `Blackboard`, this `Decorator`
    should automatically assign `MovetoLocation` as `Blackboard Key`. Verify this
    by selecting the `Decorator` and making sure `Blackboard Key` is assigned to `MovetoLocation`.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于您已经在“Blackboard”中有一个向量参数，“Decorator”应自动将“MovetoLocation”分配为“Blackboard Key”。通过选择“Decorator”并确保“Blackboard
    Key”分配给“MovetoLocation”来验证这一点。
- en: 'With the Decorator in place, you have completed the behavior tree. The final
    result will look as follows:![Figure 13.21: The final setup for the behavior tree
    for the AI enemy'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了装饰者，您已经完成了行为树。最终结果将如下所示：![图13.21：AI敌人行为树的最终设置
- en: '](img/B16183_13_21.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_21.jpg)'
- en: 'Figure 13.21: The final setup for the behavior tree for the AI enemy'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.21：AI敌人行为树的最终设置
- en: This behavior tree is telling the AI to find a random location using `BTTask_FindLocation`
    and assign this location to the Blackboard value called `MovetoLocation`. When
    this task is successful, the behavior tree will execute the `MoveTo` task, which
    will tell the AI to move to this new random location. The Sequence is wrapped
    in a `Decorator` that ensures that the enemy AI is at `MovetoLocation` before
    executing again, just as a safety net for the AI.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这个行为树告诉AI使用“BTTask_FindLocation”找到一个随机位置，并将此位置分配给名为“MovetoLocation”的Blackboard值。当此任务成功时，行为树将执行“MoveTo”任务，该任务将告诉AI移动到这个新的随机位置。序列包含一个“Decorator”，它确保敌方AI在再次执行之前处于“MovetoLocation”，就像AI的安全网一样。
- en: Before you can test the new AI behavior, make sure to place a `BP_Enemy AI`
    into your level if one is not already there from previous exercises and activities.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试新的AI行为之前，确保将“BP_Enemy AI”放入您的级别中，如果之前的练习和活动中没有的话。
- en: 'Now, if you use `PIE`, or `Simulate`, you will see the enemy AI run around
    the map and move to random locations within `Nav Mesh Volume`:![Figure 13.22:
    The enemy AI will now move from location to location'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果您使用“PIE”或“模拟”，您将看到敌方AI在“Nav Mesh Volume”内围绕地图奔跑并移动到随机位置：![图13.22：敌方AI现在将从一个位置移动到另一个位置
- en: '](img/B16183_13_22.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_22.jpg)'
- en: 'Figure 13.22: The enemy AI will now move from location to location'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.22：敌方AI现在将从一个位置移动到另一个位置
- en: Note
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There can be some cases where the enemy AI will not move. This can be caused
    by the `GetRandomLocationInNavigableRadius` function not returning `True`. This
    is a known issue, and if it occurs, please restart the editor and try again.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: By completing this exercise, you have created a fully functional behavior tree
    that allows the enemy AI to find and move to a random location within the navigable
    bounds of your level using `Nav Mesh Volume`. The Task you created in the previous
    exercise allows you to find this random point, while the `Move To` task allows
    the AI character to move toward this new location.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Due to how the `Sequence` composite node works, each task must complete successfully
    before it can move on to the next task, so first, the enemy successfully finds
    a random location and then moves toward this location. Only when the `Move To`
    task completes will the entire behavior tree start over and choose a new random location.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can move on to the next activity, where you will add to this behavior
    tree in order to have the AI wait between selecting a new random point so that
    the enemy isn't constantly moving.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 13.02: AI Moving to the Player Location'
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous exercise, you were able to have the AI enemy character move
    to random locations within the bounds of `Nav Mesh Volume` by using a custom `Task`
    and the `MoveTo` task together.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: In this activity, you will continue from the previous exercise and update the
    behavior tree. You will take advantage of the `Wait` task by using a `Decorator`,
    and also create your own new custom task to have the AI follow the player character
    and update its position every few seconds.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this activity:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `BT_EnemyAI` behavior tree that you created in the previous exercise,
    you will continue from where you left off and create a new Task. Do this by selecting
    `New Task` from the toolbar and choosing `BTTask_BlueprintBase`. Name this new
    Task `BTTask_FindPlayer`.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `BTTask_FindPlayer` Task, create a new Event called `Event Receive Execute
    AI`.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the `Get Player Character` function in order to get a reference to the
    player; make sure to use `Player Index 0`.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the player character, call the `Get Actor Location` function in order to
    find the players' current location.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Blackboard Key `Selector` variable inside this Task. Name this
    variable `NewLocation`.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Left-click* and drag the `NewLocation` variable into the graph. From this
    variable, search for the `Set Blackboard Value` function as `Vector`.'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect `Set Blackboard Value` as a `Vector` function to the execution pin of
    the Event's `Receive Execute AI` node.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `Finish Execute` function, ensuring that the Boolean `Success` parameter
    is `True`.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, connect `Set Blackboard Value` as a `Vector` function to the `Finish
    Execute` function.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and compile the Task `Blueprint` and return to the `BT_EnemyAI` behavior
    tree.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the `BTTask_FindLocation` Task with the new `BTTask_FindPlayer` Task
    so that this new Task is now the first task underneath the `Sequence` composite
    node.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new `PlaySound` task as the third task underneath the `Sequence` composite
    node by following the custom `BTTask_FindLocation` and `Move To` Tasks.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Sound to Play` parameter, add the `Explosion_Cue SoundCue` asset.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an `Is At Location` Decorator to the `PlaySound` Task and ensure that the
    `MovetoLocation` Key is assigned to this `Decorator`.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new `Wait` Task as the fourth Task underneath the `Sequence` composite
    node following the `PlaySound` Tasks.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `Wait` task to wait `2.0f` seconds before completing successfully.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.23: Enemy AI following the player and updating to the player'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: location every 2 seconds
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_13_23.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.23: Enemy AI following the player and updating to the player location
    every 2 seconds'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: The enemy AI character will move to the players' last known location in the
    navigable space of the level and pause for `2.0f` seconds between each player
    position.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: With this activity complete, you have learned to create a new Task that allows
    the AI to find the player location and move to the player's last known position.
    Before moving onto the next set of exercises, remove the `PlaySound` task and
    replace the `BTTask_FindPlayer` task with the `BTTask_FindLocation` task you created
    in *Exercise 13.05*, *Creating a New Behavior Tree Task*. Please refer to *Exercise
    13.05,* *Creating a New Behavior Tree Task* and *Exercise 13.06*, *Creating the
    Behavior Tree Logic*, to ensure the Behavior Tree is returned correctly. You will
    be using the `BTTask_FindLocation` task in the upcoming exercises.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, you will address this issue by developing a new `Blueprint`
    actor that will allow you to set up specific positions that the AI can move toward.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.07: Creating the Enemy Patrol Locations'
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The current issue with the AI enemy character is that they can move freely
    around the 3D navigable space because the behavior tree allows them to find a
    random location within that space. Instead, the AI needs to be given patrol points
    that you can specify and change in the editor. It will then choose one of these
    patrol points at random to move to. This is what you will do for the `SuperSideScroller`
    game: create patrol points that the enemy AI can move to. This exercise will show
    you how to create these patrol points using a simple *Blueprint* actor. This exercise
    will be performed within the Unreal Engine 4 editor.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: First, navigate to the `/Enemy/Blueprints/` directory. This is where you will
    create the new `Blueprint` actor that will be used for the AI patrol points.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this directory, *right-click* and choose the `Blueprint Class` option by
    *left-clicking* this option from the menu.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the `Pick Parent Class` menu prompt, *left-click* the `Actor` option to
    create a new `Blueprint` based on the `Actor` class:![Figure 13.24: The Actor
    class is the base class for all objects that'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: can be placed or spawned in the game world
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_13_24.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.24: The Actor class is the base class for all objects that can be
    placed or spawned in the game world'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Name this new asset `BP_AIPoints` and open this `Blueprint` by *double-clicking*
    the asset in the `Content Browser` interface.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: The interface for `Blueprints` shares many of the same features and layouts
    as other systems, such as `Animation Blueprints` and `Tasks`, so this should all
    look familiar to you.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the `Variables` tab on the left-hand side of the Blueprint UI and
    *left-click* on the `+Variable` button. Name this variable `Points`.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `Variable Type` dropdown, *left-click* and select the `Vector` option.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you will need to make this vector variable an `Array` so that you can
    store multiple patrol locations. *Left-click* the yellow icon next to `Vector`
    and *left-click* to select the `Array` option.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The last step for setting up the `Points` vector variable is to enable `Instance
    Editable` and `Show 3D Widget`:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Instance Editable` parameter allows this vector variable to be publicly
    visible on the actor when placed in a level, allowing each instance of this actor
    to have this variable available to edit.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Show 3D Widget` allows you to position the vector value by using a visible
    3D transform widget in the editor viewport. You will see what this means in the
    next steps of this exercise. It is also important to note that the `Show 3D Widget`
    option is only available for variables that involve an actor transform, such as
    `Vectors` and `Transforms`.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the simple actor set up, it is time to place the actor into the level and
    begin setting up the *Patrol Point* locations.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `BP_AIPoints` actor Blueprint into your level, as shown in the following screenshot:![Figure
    13.25: The BP_AIPoints actor now in the level'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_13_25.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.25: The BP_AIPoints actor now in the level'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: With the `BP_AIPoints` actor selected, navigate to its `Details` panel and find
    the `Points` variable.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, you can add a new element to the vector array by *left-clicking* on the
    `+` symbol, as shown here:![Figure 13.26: You can have many elements inside of
    an array, but the larger the array, the more memory is allocated'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_13_26.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.26: You can have many elements inside of an array, but the larger
    the array, the more memory is allocated'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'When you add a new element to the vector array, you will see a 3D widget appear
    that you can then *left-click* to select and move around the level, as shown here:![Figure
    13.27: The first Patrol Point vector location'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_13_27.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.27: The first Patrol Point vector location'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: As you update the position of the 3D widget that represents the element of the
    vector array, the 3D coordinates will update in the `Details` panel for the `Points`
    variable.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, add as many elements into the vector array as you would like for the
    context of your level. Keep in mind that the positions of these patrol points
    should line up so that they make a straight line along the horizontal axis, parallel
    to the direction in which the character will move. The following screenshot shows
    the setup in the example `SideScroller.umap` level included in this exercise:![Figure
    13.28: The example Patrol Point path, as seen'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: in the SideScroller.umap example level
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_13_28.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.28: The example Patrol Point path, as seen in the SideScroller.umap
    example level'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Continue to repeat the final step to create multiple patrol points and position
    the 3D widgets as you see fit. You can use the provided `SideScroller.umap` example
    level as a reference on how to set up these `Patrol Points`.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By completing this exercise, you have created a new `Actor` Blueprint that contains
    a `Vector`array of positions that you can now manually set using a 3D widget in
    the editor. With the ability to manually set the *Patrol Point* positions, you
    have full control over where the AI can move to, but there is one problem. There
    is no functionality in place to choose a point from this array and to pass it
    to the behavior tree so that the AI can move between these *Patrol Points*. Before
    you set up this functionality, let's learn a bit more about Vectors and Vector
    Transformation, as this knowledge will prove useful in the next exercise.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Vector Transformation
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you jump into the next exercise, it is important that you get to know
    about Vector Transformation and, more importantly, what the `Transform Location`
    function does. When it comes to an actor''s location, there are two ways of thinking
    of its position: in terms of world space and local space. An actor''s position
    in world space is its location relative to the world itself; in more simple terms,
    this is the location where you place the actual actor into the level. An actor''s
    local position is its location relative to either itself or a parent actor.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the `BP_AIPoints` actor as an example of what world space and
    local space are. Each of the locations of the `Points` array are local-space Vectors
    because they are positions relative to the world-space position of the `BP_AIPoints`
    actor itself. The following screenshot shows the list of Vectors in the `Points`
    array, as shown in the previous exercise. These values are positions relative
    to the location of the `BP_AIPoints` actor in your level:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.29: The local-space position Vectors of the Points array, relative'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: to the world-space position of the BP_AIPoints actor
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_13_29.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.29: The local-space position Vectors of the Points array, relative
    to the world-space position of the BP_AIPoints actor'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to have the enemy AI move to the correct world space location of these
    `Points`, you need to use a function called `Transform Location`. This function
    takes in two parameters:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使敌人AI移动到这些`Points`的正确世界空间位置，您需要使用一个名为`Transform Location`的函数。这个函数接受两个参数：
- en: '`T`: This is the supplied `Transform` that you use to convert the vector location
    parameter from a local-space into a world-space value.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T`：这是您用来将向量位置参数从局部空间转换为世界空间值的提供的`Transform`。'
- en: '`Location`: This is the `location` that is to be converted from local space
    to world space.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`位置`：这是要从局部空间转换为世界空间的`位置`。'
- en: The result of this vector transformation is then returned as the Return Value
    of the function. You will use this function in the next exercise to return a randomly
    selected vector point from the `Points` array and convert that value from a local-space
    vector into a world-space vector. This new world-space vector will then be used
    to tell the enemy AI where to move relative to the world. Let's implement this
    now.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将向量转换的结果作为函数的返回值。您将在下一个练习中使用此函数，从`Points`数组中返回一个随机选择的向量点，并将该值从局部空间向量转换为世界空间向量。然后，将使用这个新的世界空间向量来告诉敌人AI在世界中如何移动。让我们现在实现这个。
- en: 'Exercise 13.08: Selecting a Random Point in an Array'
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.08：在数组中选择一个随机点
- en: Now that you have more information about Vectors and Vector Transformation,
    you can move onto this exercise, where you will create a simple `Blueprint` function
    to select one of the *Patrol Point* vector locations and transform its vector
    from a local space value into a world space value using a built-in function called
    `Transform Location`. By returning the world space value of the vector position,
    you can then pass this value to the *behavior tree* so that the AI will move to
    the correct position. This exercise will be performed within the Unreal Engine
    4 editor.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对向量和向量转换有了更多的了解，您可以继续进行这个练习，在这个练习中，您将创建一个简单的`蓝图`函数，选择一个*巡逻点*向量位置中的一个，并使用名为`Transform
    Location`的内置函数将其向量从局部空间值转换为世界空间值。通过返回向量位置的世界空间值，然后将这个值传递给*行为树*，使得AI将移动到正确的位置。这个练习将在虚幻引擎4编辑器中进行。
- en: 'The following steps will help you complete this exercise. Let''s start by creating
    the new function:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成这个练习。让我们从创建新函数开始：
- en: Navigate back to the `BP_AIPoints` Blueprint and create a new function by *left-clicking*
    the `+` button next to the `Functions` category on the left-hand side of the Blueprint
    editor. Name this function `GetNextPoint`.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航回`BP_AIPoints`蓝图，并通过*左键单击*蓝图编辑器左侧的`函数`类别旁边的`+`按钮来创建一个新函数。将此函数命名为`GetNextPoint`。
- en: Before you add logic to this function, select this function by *left-clicking*
    it under the `Functions` category to access its `Details` panel.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在为这个函数添加逻辑之前，通过*左键单击*`函数`类别下的函数来选择此函数，以访问其`详细信息`面板。
- en: In the `Details` panel, enable the `Pure` parameter so that this function is
    labeled as a `Pure Function`. You learned about `Pure Functions` in *Chapter 11*,
    *Blend Spaces 1D, Key Bindings, and State Machines*, when working in the Animation
    Blueprint for the player character; the same thing is happening here.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“详细信息”面板中，启用“Pure”参数，以便将此函数标记为“纯函数”。在*第11章*中，*混合空间1D，键绑定和状态机*中，当在玩家角色的动画蓝图中工作时，您了解了“纯函数”；在这里也是一样的。
- en: 'Next, the `GetNextPoint` function needs to return a vector that the behavior
    tree can use to tell the enemy AI where to move to. Add this new output by *left-clicking*
    on the `+` symbol under the `Outputs` category of the `Details` function. Make
    the variable of type `Vector` and give it the name `NextPoint`, as shown in the
    following screenshot:![Figure 13.30: Functions can return multiple variables of
    different types,'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，`GetNextPoint`函数需要返回一个向量，行为树可以用来告诉敌人AI要移动到哪里。通过*左键单击*`详细信息`函数类别下的`+`符号来添加这个新的输出。将变量类型设置为`Vector`，并将其命名为`NextPoint`，如下面的屏幕截图所示：![图13.30：函数可以返回不同类型的多个变量，
- en: depending on the needs of your logic
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的逻辑需求
- en: '](img/B16183_13_30.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_30.jpg)'
- en: 'Figure 13.30: Functions can return multiple variables of different types, depending
    on the needs of your logic'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.30：函数可以返回不同类型的多个变量，根据您的逻辑需求
- en: 'When adding an `Output` variable, the function will automatically generate
    a `Return` node and place it into the function graph, as shown in the following
    screenshot. You will use this output to return the new vector patrol point for
    the enemy AI to move to:![Figure 13.31: The automatically generated Return Node
    for the function, including the NewPoint vector output variable'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加`输出`变量时，函数将自动生成一个`Return`节点并将其放入函数图中，如下面的屏幕截图所示。您将使用这个输出来返回敌人AI移动到的新向量巡逻点：![图13.31：函数的自动生成返回节点，包括NewPoint向量输出变量
- en: '](img/B16183_13_31.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_31.jpg)'
- en: 'Figure 13.31: The automatically generated Return Node for the function, including
    the NewPoint vector output variable'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.31：函数的自动生成返回节点，包括NewPoint向量输出变量
- en: Now that the function groundwork is completed, let's start adding the logic.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在函数的基础工作已经完成，让我们开始添加逻辑。
- en: 'In order to pick a random position, first, you need to find the length of the
    `Points` array. Create a `Getter` of the `Points` vector and from this vector
    variable, *left-click* and drag to search for the `Length` function, as shown
    in the following screenshot:![Figure 13.32: The Length function is a pure function
    that returns the length of the array'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了选择一个随机位置，首先需要找到`Points`数组的长度。创建`Points`向量的`Getter`，从这个向量变量中*左键单击*并拖动以搜索`Length`函数，如下面的屏幕截图所示：![图13.32：Length函数是一个纯函数，返回数组的长度
- en: '](img/B16183_13_32.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_32.jpg)'
- en: 'Figure 13.32: The Length function is a pure function that returns the length
    of the array'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.32：Length函数是一个纯函数，返回数组的长度
- en: 'With the integer output of the `Length` function, *left-click* and drag out
    to use the context-sensitive search to find the `Random Integer` function, as
    shown in the following screenshot. The `Random Integer` function returns a random
    integer between `0` and `Max value`; in this case, this is the `Length` of the
    `Points` vector array:![Figure 13.33: Using Random Integer will allow the function
    to return'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a random vector from the Points vector array
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_13_33.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.33: Using Random Integer will allow the function to return a random
    vector from the Points vector array'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: So far, you are generating a random integer between `0` and the Length of the
    `Points` vector array. Next, you need to find the element of the `Points` vector
    array at the index position of the returned `Random Integer`.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Do this by creating a new `Getter of the Points` vector array. Then, *left-click*
    and drag to search for the `Get (a copy)` function.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, connect the Return Value of the `Random Integer` function to the input
    of the `Get (a copy)` function. This will tell the function to choose a random
    integer and use that integer as the index to return from the `Points` vector array.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that you are getting a random vector from the `Points` vector array, you
    need to use the `Transform Location` function in order to convert the location
    from a local space into a world space vector.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: As you have learned already, the Vectors in the `Points` array are local space
    positions relative to the position of the `BP_AIPoints` actor in the level. As
    a result, you need to use the `Transform Location` function to convert the randomly
    selected local space vector into a world-space vector so that the AI enemy moves
    to the correct position.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '*Left-click* and drag from the vector output of the `Get (a copy)` function
    and via the context-sensitive search, find the `Transform Location` function.'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the vector output of the `Get (a copy)` function to the `Location` input
    of the `Transform Location` function.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final step is to use the transform of the Blueprint actor itself as the
    `T` parameter of the `Transform Location` function. Do this by *right-clicking*
    inside the graph and via the context-sensitive search, find the `GetActorTransform`
    function and connect it to the `Transform Location` parameter, `T`.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, connect the `Return Value` vector from the `Transform Location` function
    and connect it to the `NewPoint` vector output of the function:![Figure 13.34:
    The final logic set up for the GetNextPoint function'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_13_34.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.34: The final logic set up for the GetNextPoint function'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the preceding screenshot in full resolution for better viewing
    at the following link: [https://packt.live/35jlilb](https://packt.live/35jlilb).'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: By completing this exercise, you have created a new Blueprint function inside
    the `BP_AIPoints` actor that takes a random index from the `Points` array variable,
    transforms it into a world space vector value using the `Transform Location` function,
    and returns this new vector value. You will use this function inside the `BTTask_FindLocation`
    task, inside the AI behavior tree, so that the enemy will move to one of the points
    you have set up. Before you can do this, the enemy AI needs a reference to the
    `BP_AIPoints` actor so that it knows which points it can select from and move
    to. We'll do this in the following exercise.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.09: Referencing the Patrol Point Actor'
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that the `BP_AIPoints` actor has a function that returns a random transformed
    location from its array of vector patrol points, you need to have the enemy AI
    reference this actor in the level so that it knows which patrol points to reference.
    To do this, you will add a new `Object Reference` variable to the enemy character
    Blueprint and assign the `BP_AIPoints` actor that you placed in your level earlier.
    This exercise will be performed within the Unreal Engine 4 editor. Let's get started
    by adding the *Object Reference*.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: An `Object Reference Variable` stores a reference to a specific class object
    or actor. With this reference variable, you can get access to the publicly exposed
    variables, events, and functions that this class has available.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the `/Enemy/Blueprints/` directory and open the enemy character
    Blueprint `BP_Enemy` by *double-clicking* the asset from the `Content Browser`
    interface.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new variable of the `BP_AIPoints` type and make sure the variable type
    is of `Object Reference`.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to reference the existing `BP_AIPoints` actor in your level, you need
    to make the variable from the previous step a `Public Variable` by enabling the
    `Instance Editable` parameter. Name this variable `Patrol Points`.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that you have the object reference set, navigate to your level and select
    your enemy AI. The following screenshot shows the enemy AI placed in the provided
    example level; that is, `SuperSideScroller.umap`. If you don''t have an enemy
    placed in your level, please do so now:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Placing an enemy into a level works the same as it does for any other actor
    in Unreal Engine 4\. *Left-click* and drag the enemy AI Blueprint from the Content
    Browser interface into the level.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.35: The enemy AI placed in the example level SuperSideScroller.umap'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_13_35.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.35: The enemy AI placed in the example level SuperSideScroller.umap'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: From its `Details` panel, find the `Patrol Points` variable under the `Default`
    category. The last thing to do here is assign the `BP_AIPoints` actor we already
    placed in the level in *Exercise 13.07*, *Creating the Enemy Patrol Locations*.
    Do this by *left-clicking* the dropdown menu for the `Patrol Points` variable
    and finding the actor from the list.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this exercise complete, the enemy AI in your level now has a reference
    to the `BP_AIPoints` actor in your level. With a valid reference in place, the
    enemy AI can use this actor to determine which set of points to move between inside
    the `BTTask_FindLocation` task. All that is left to do now is update the `BTTask_FindLocation`
    task so that it uses these points instead of finding a random location.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.10: Updating BTTask_FindLocation'
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final step in completing the enemy AI patrolling behavior is to replace
    the logic inside `BTTask_FindLocation` so that it uses the `GetNextPoint` function
    from the `BP_AIPoints` actor instead of finding a random location within the navigable
    space of your level. This exercise will be performed within the Unreal Engine
    4 editor.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder, check back and see how the `BTTask_FindLocation` task looked
    at the end of *Exercise 13.05*, *Creating a New Behavior Tree Task*, before you
    start.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to do is take the returned `Controlled Pawn` reference from
    `Event Receive Execute AI` and cast it to `BP_Enemy`, as shown in the following
    screenshot. This way, you can access the `Patrol Points` object reference variable
    from the previous exercise:![Figure 13.36: Casting also ensures that the returned
    Controlled Pawn'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: is of the BP_Enemy class type
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_13_36.jpg)'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.36: Casting also ensures that the returned Controlled Pawn is of
    the BP_Enemy class type'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can access the `Patrol Points` object reference variable by *left-clicking*
    and dragging from the `As BP Enemy` pin under the cast to `BP_Enemy`, and via
    the context-sensitive search, finding `Patrol Points`.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `Patrol Points` reference, you can *left-click* and drag to search
    for the `GetNextPoint` function that you created in *Exercise 13.08*, *Selecting
    a Random Point in an Array*.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, you can connect the `NextPoint` vector output parameter of the `GetNextPoint`
    function to the `Set Blackboard Value as Vector` function and connect the execution
    pins from the cast to the `Set Blackboard Value as Vector` function. Now, each
    time the `BTTask_FindLocation` task is executed, a new random patrol point will
    be set.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, connect the `Set Blackboard Value as Vector` function to the `Finish
    Execute` function and manually set the `Success` parameter to `True` so that this
    task will always succeed if the cast is successful.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As a failsafe, create a duplicate of `Finish Execute` and connect to the `Cast
    Failed` execution pin of the `Cast` function. Then, set the `Success` parameter
    to `False`. This will act as a failsafe so that if, for any reason, `Controlled
    Pawn` is not of the `BP_Enemy` class, the task will fail. This is a good debugging
    practice to ensure the functionality of the task for its intended AI class:![Figure
    13.37: It is always good practice to account for any casting failures in your
    logic'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_13_37.jpg)'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.37: It is always good practice to account for any casting failures
    in your logic'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the preceding screenshot in full resolution for better viewing
    at the following link: [https://packt.live/3n58THA](https://packt.live/3n58THA).'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: With the `BTTask_FindLocation` task updated to use the random patrol point from
    the `BP_AIPoints` actor reference in the enemy, the enemy AI will now move between
    the patrol points at random.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.38: The enemy AI now moving between the patrol point locations
    in the level'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_13_38.jpg)'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.38: The enemy AI now moving between the patrol point locations in
    the level'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: With this exercise complete, the enemy AI now uses the reference to the `BP_AIPoints`
    actor in the level to find and move to the patrol points in the level. Each instance
    of the enemy character in the level can have its own reference to another unique
    instance of the `BP_AIPoints` actor or can share the same instance reference.
    It is up to you how you would like each enemy AI to move throughout the level.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: Player Projectile
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the last section of this chapter, you will focus on creating the base of
    the player projectile, which can be used to destroy enemies. The goal is to create
    the appropriate actor class, introduce the required collision and projectile movement
    components to the class, and set up the necessary parameters for the projectile's
    motion behavior.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of simplicity, the player projectile will not use gravity, will
    destroy enemies with one hit, and the projectile itself will be destroyed on hitting
    any surface; it will not bounce off walls, for example. The primary goal of the
    player projectile is to have a projectile that the player can spawn and use to
    destroy enemies throughout the level. In this chapter, you will set up the basic
    framework functionality, while in *Chapter 14*, *Spawning the Player Projectile*,
    you will add sound and visual effects. Let's get started by creating the player
    projectile class.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.11: Creating the Player Projectile'
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up until this point, we have been working on in the Unreal Engine 4 editor to
    create our enemy AI. For the player projectile, we will be using C++ and Visual
    Studio to create this new class. The player projectile will allow the player to
    destroy enemies that are placed in the level. This projectile will have a short
    lifespan, travel at a high speed, and will collide with both enemies and the environment.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this exercise is to set up the base actor class for the player projectile
    and begin outlining the functions and components needed in the header file for
    the projectile.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: First, you will need to create a new C++ class using the `Actor` class as the
    parent class for the player projectile. Next, name this new actor class `PlayerProjectile`
    and *left-click* on the `Create Class` option at the bottom-right of the menu
    prompt.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After creating the new class, Visual Studio will generate the required source
    and header files for the class and open these files for you. The actor base class
    comes included with a handful of default functions that you will not need for
    the player projectile.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the following lines of code inside the `PlayerProjectile.h` file and remove
    them:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These lines of code represent the declarations of the `Tick()` and `BeginPlay()`
    functions that are included in every Actor-based class by default. The `Tick()`
    function is called on every frame and allows you to perform logic on every frame,
    which can get expensive, depending on what you are trying to do. The `BeginPlay()`
    function is called when this actor is initialized and play has started. This can
    be used to perform logic on the actor as soon as it enters the world. These functions
    are being removed because they are not required for `Player Projectile` and will
    just clutter the code.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: 'After removing these lines from the `PlayerProjectile.h` header file, you can
    now remove the following lines from the `PlayerProjectile.cpp` source files as
    well:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: These lines of code represent the function implementations of the two functions
    you removed in the previous step; that is, `Tick()` and `BeginPlay()`. Again,
    these are being removed because they serve no purposes for `Player Projectile`
    and just add clutter to the code. Additionally, without the declarations inside
    the `PlayerProjectile.h` header file, you would receive a compilation error if
    you were to try to compile this code as is. The only remaining function will be
    the constructor for the projectile class, which you will use to initialize the
    components of the projectile in the next exercise. Now that you have removed the
    unnecessary code from the `PlayerProjectile` class, let's add the functions and
    components required for the projectile.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `PlayerProjectile.h` header file, add the following components.
    Let''s discuss these components in detail:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There are three different components you are adding here. The first is the collision
    component, which you will use for the projectile to recognize collisions with
    enemies and environment assets. The next component is the projectile movement
    component, which you should be familiar with from the last project. This will
    allow the projectile to behave like a projectile. The final component is the static
    mesh component. You will use this to give this projectile a visual representation
    so that it can be seen in-game.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the following function signature code to the `PlayerProjectile.h`
    header file, under the `public` access modifier:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This final event declaration will allow the player projectile to respond to
    `OnHit` events from the `CollisionComp` component you created in the previous
    step.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in order to have this code compile, you will need to implement the function
    from the previous step in the `PlayerProjectile.cpp` source file. Add the following
    code:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `OnHit` event provides you with a lot of information about the collision
    that takes place. The most important parameter that you will be working with in
    the next exercise is the `OtherActor` parameter. The `OtherActor` parameter will
    tell you the actor in which this `OnHit` event is responding to. This will allow
    you to know if this other actor was an enemy. You will use this information to
    destroy the enemies when the projectile hits them.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, navigate back into the Unreal Engine editor and *left-click* the `Compile`
    option to compile the new code.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this exercise complete, you now have the framework ready for the `Player
    Projectile` class. The class has the required components for `Projectile Movement`,
    `Collision`, and `Static Mesh`, as well as the event signature ready for the `OnHit`
    collision so that the projectile can recognize collisions with other actors.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, you will continue to customize and enable parameters for
    `Player Projectile` so that it behaves the way you need it to for the `SuperSideScroller`
    project.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.12: Initializing Player Projectile Settings'
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that the framework of the `PlayerProjectile` class is in place, it's time
    to update the constructor of this class with the default settings needed for the
    projectile so that it moves and behaves as you want it to. In order to do this,
    you will need to initialize the `Projectile Movement`, `Collision`, and `Static
    Mesh` components.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio and navigate to the `PlayerProjectile.cpp` source file.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before adding any code to the constructor, include the following files inside
    the `PlayerProjectile.cpp` source file:'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These header files will allow you to initialize and update the parameters of
    the projectile movement component, the sphere collision component, and the static
    mesh component respectively. Without these files included, the `PlayerProjectile`
    class wouldn't know how to handle these components and how to access their functions
    and parameters.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the `APlayerProjectile::APlayerProjectile()` constructor function
    includes the following line:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This line of code can be removed entirely because it is not required in the
    player projectile.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `PlayerProjectile.cpp` source file, add the following lines to the `APlayerProjectile::APlayerProjectile()`
    constructor:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The first line initializes the sphere collision component and assigns it to
    the `CollisionComp` variable you created in the previous exercise. `Sphere Collision
    Component` has a parameter called `InitSphereRadius`. This will determine the
    size, or radius, of the collision actor by default; in this case, a value of `15.0f`
    works well. Next, set `Collision Profile Name` for the collision component to
    `BlockAll` so that the collision profile is set to `BlockAll`, which means this
    collision component will respond to `OnHit` when it collides with other objects.
    Lastly, the last line you added allows the `OnComponentHit` event to respond with
    the function you created in the previous exercise:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This means that when the collision component receives the `OnComponentHit` event
    from a collision event, it will respond with that function; however, this function
    is empty at the moment. You will add code to this function later in this chapter.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing to do with `Collision Component` is to set this component as
    the `root` component of the player projectile actor. Add the following line of
    code in the constructor, after the lines from *Step 4*:'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With the collision component set up and ready, let''s move on to the `Projectile
    Movement` component. Add the following lines to the constructor:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This first line initializes `Projectile Movement Component` and assigns it to
    the `ProjectileMovement` variable you created in the previous exercise. Next,
    we set `CollisionComp` as the updated component of the projectile movement component.
    The reason we're doing this is because the `Projectile Movement` component will
    use the `root` component of the actor as the component to move. Then, you are
    setting the gravity scale of the projectile to `0.0f` because the player projectile
    should not be affected by gravity; the behavior should allow the projectile to
    travel at the same speed, at the same height, and not be influenced by gravity.
    Lastly, you are setting both the `InitialSpeed` and `MaxSpeed` parameters to `500.0f`.
    This will allow the projectile to instantly start moving at this speed and remain
    at this speed for the duration of its lifetime. The player projectile will not
    support any kind of acceleration motion.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: 'With the projectile movement component initialized and set up, it is time to
    do the same for `Static Mesh Component`. Add the following code after the lines
    from the previous step:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This first line initializes `Static Mesh Component` and assigns it to the `MeshComp`
    variable you created in the previous exercise. Then, you attach this static mesh
    component to `RootComponent` using a struct called `FAttachmentTransformRules`
    to ensure that the `Static Mesh Component` keeps its world transform during the
    attachment which is `CollisionComp` from *Step 5* of this exercise.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more information about the `FAttachmentTransformRules` struct
    here: [https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/FAttachmentTransformRules/index.html](https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/FAttachmentTransformRules/index.html).'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, let''s give `Player Projectile` an initial life span of `3` seconds
    so that the projectile will automatically be destroyed if it doesn''t collide
    with anything after this time. Add the following code to the end of the constructor:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Lastly, navigate back into the Unreal Engine editor and *left-click* the `Compile`
    option to compile the new code.
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By completing this exercise, you have set up the groundwork for `Player Projectile`
    so that it can be created as a *Blueprint* actor inside the editor. All three
    required components are initialized and contain the default parameters that you
    want for this projectile. All we need to do now is create the *Blueprint* from
    this class to see it in the level.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 13.03: Creating the Player Projectile Blueprint'
  id: totrans-470
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To conclude this chapter, you will create the `Blueprint` actor from the new
    `PlayerProjectile` class and customize this actor so that it uses a placeholder
    shape for `Static Mesh Component` for debugging purposes. This allows you to view
    the projectile in the game world. Then, you will add a `UE_LOG()` function to
    the `APlayerProjectile::OnHit` function inside the `PlayerProjectile.cpp` source
    file so that you can ensure that this function is called when the projectile comes
    into contact with an object in the level. You will need to perform the following steps:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `Content Browser` interface, create a new folder called `Projectile`
    in the `/MainCharacter` directory.
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this directory, create a new Blueprint from the `PlayerProjectile` class,
    which you created in *Exercise 13.11*, *Creating the Player Projectile*. Name
    this Blueprint `BP_PlayerProjectile`.
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `BP_PlayerProjectile` and navigate to its components. Select the `MeshComp`
    component to access its settings.
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `Shape_Sphere` mesh to the Static Mesh parameter of the `MeshComp `component.
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the Transform of `MeshComp` so that it fits the `Scale and Location
    of the CollisionComp` component. Use the following values:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Compile and save the `BP_PlayerProjectile` Blueprint.
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the `PlayerProjectile.cpp` source file in Visual Studio and find
    the `APlayerProjectile::OnHit` function.
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the function, implement the `UE_LOG` call so that the logged line is
    of `LogTemp`, `Warning log level`, and displays the text `HIT`. `UE_LOG` was covered
    back in *Chapter 11*, *Blend Spaces 1D, Key Bindings, and State Machines*.
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile your code changes and navigate to the level where you placed the `BP_PlayerProjectile`
    actor in the previous exercise. If you don't have this actor added to the level,
    do so now.
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before testing, make sure to open the Output Log in the `Window` option. From
    the `Window` dropdown, hover over the `Developers Tools` option and *left-click*
    to select `Output Log`.
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `PIE` and watch out for the log warning inside `Output Log` when the projectile
    collides with something.
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the expected output:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.39: Scale of the MeshComp better fits the size of the Collision
    Comp'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_13_39.jpg)'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.39: Scale of the MeshComp better fits the size of the Collision Comp'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: 'The log warning should be as follows:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.40: When the projectile hits an object, the text HIT is shown in
    the Output Log'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_13_40.jpg)'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.40: When the projectile hits an object, the text HIT is shown in
    the Output Log'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: With this final activity complete, `Player Projectile` is ready for the next
    chapter, where you will spawn this projectile when the player uses the `Throw`
    action. You will update the `APlayerProjectile::OnHit` function so that it destroys
    the enemy that it collides with and becomes an effective offensive tool for the
    player to use against the enemies.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-495
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use the different aspects of the AI tools
    offered by Unreal Engine 4, including Blackboards, behavior trees, and AI Controllers.
    With a combination of both custom created Tasks and default Tasks provided by
    Unreal Engine 4, and with a Decorator, you were able to have the enemy AI navigate
    within the bounds of the Nav Mesh you added to your own level.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: On top of this, you created a new Blueprint actor that allows you to add patrol
    points with the use of a `Vector` array variable. You then added a new function
    to this actor that selects one of these points at random, converts its location
    from local space into world space, and then returns this new value for use by
    the enemy character.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: With the ability to randomly select a Patrol Point, you updated the custom `BTTask_FindLocation`
    task to find and move to the selected Patrol Point, allowing the enemy to move
    from each Patrol Point at random. This brought the enemy AI character to a whole
    new level of interaction with the player and the environment.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, you created the Player Projectile that the player will be able to use
    in order to destroy enemies within the environment. You took advantage of both
    `Projectile Movement Component` and `Sphere Component` to allow for both projectile
    movement and to recognize and respond to collisions within the environment.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: With the Player Projectile in a functional state, it is time to move on to the
    next chapter, where you will use `Anim Notifies` to spawn the projectile when
    the player uses the `Throw` action.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
