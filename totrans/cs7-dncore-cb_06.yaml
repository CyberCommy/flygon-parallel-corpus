- en: Working with Files, Streams, and Serialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Working with files, streams, and serialization is something you as a developer
    will do many times. Creating import files, exporting data to a file, persisting
    an application state, using a file definition to build a file, and many other
    scenarios will present themselves at some point during your career. In this chapter,
    we will look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating and extracting ZIP archives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In-memory stream compression and decompression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Async and await file processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to make a custom type serializable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ISerializable for custom serialization to a FileStream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using XmlSerializer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON serializers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to work with files will definitely give you an edge as a developer.
    There are so many frameworks for working with files available to developers today,
    that one tends to forget that some of the functionality you want is already rolled
    up into the .NET Framework itself. Let's look at what exactly we can do with files.
  prefs: []
  type: TYPE_NORMAL
- en: If you ever find that you need to create Excel files in ASP.NET applications,
    do have a look at the excellent EPPlus .NET library available on CodePlex. At
    the time of writing, the URL was: [https://epplus.codeplex.com/](https://epplus.codeplex.com/)
    and is licensed under the GNU **Library General Public License** (**LGPL**). Also
    consider donating to EPPlus. These folks wrote an incredible library that is very
    easy to use and well documented.
  prefs: []
  type: TYPE_NORMAL
- en: On March 31, 2017 it was announced that CodePlex would be shut down completely
    on December 15, 2017\. According to the DISCUSSIONS tab on the EPPlus CodePlex
    page ([https://epplus.codeplex.com/discussions/662424](https://epplus.codeplex.com/discussions/662424))
    the source code will be moved to GitHub before CodePlex goes into read-only mode
    in October 2017.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and extracting ZIP archives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most basic things you can do is work with ZIP files. The .NET Framework
    does an excellent job at providing this functionality right out of the box. You
    might need to provide ZIP functionality in an application that needs to upload
    several files to a network share. Being able to ZIP several files and upload a
    single ZIP file makes more sense than having to upload several smaller files.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a console application and call it `FilesExample`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Right-click on the References node and select Add Reference... from the context
    menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_02.png)'
  prefs: []
  type: TYPE_IMG
- en: In the Reference Manager, search for the word `compression`. Add a reference
    to System.IO.Compression and System.IO.Compression.FileSystem to your project
    and click on the OK button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the time of writing, there was a System.IO.Compression version 4.1.0.0 and
    System.IO.Compression version 4.0.0.0 available from the Reference Manager. The
    example I created just used version 4.1.0.0.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_07_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When you have added your references, your solution should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_04-1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a folder called `Documents` in your `temp` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Inside this folder, create a few files of varying sizes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_06.png)'
  prefs: []
  type: TYPE_IMG
- en: You are now ready to write some code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add the following `using` statements to the top of your `Program.cs` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a method called `ZipIt()` and add the code to it to ZIP the `Documents`
    directory. The code is pretty straightforward to understand. I want to, however,
    highlight the use of the `CreateFromDirectory()` method. Notice that we have set
    the compression level to `CompressionLevel.Optimal` and set the `includeBaseDirectory`
    parameter to `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Run your console application and look at the `temp` folder again. You will
    see the following ZIP file created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Viewing the contents of the ZIP file will display the files contained in the
    `Documents` folder that we saw earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Viewing the properties of the ZIP file, you will see that it has been compressed
    to 36 KB:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Extracting a ZIP file is just as easy to do. Create a method called `UnZipIt()`
    and pass the path to the `temp` folder to it. Then, specify the directory to unzip
    the files to and set the variable called `destinationDirectory`. Call the `ExtractToDirectory()`
    method and pass it the `archiveName` and `destinationDirectory` variables as parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Run your console application and view the output folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Viewing the extracted files in the `DocumentsUnzipped` folder, you will see
    the original files we started off with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_11.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with ZIP files in .NET is really as easy as it gets. The .NET Framework
    does a lot of the heavy lifting for mundane tasks such as creating archives. It
    also allows developers to maintain a certain standard of code without having to
    "roll their own" archiving methods.
  prefs: []
  type: TYPE_NORMAL
- en: In-memory stream compression and decompression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you need to perform some in-memory compression of a large amount
    of text. You might want to write this to a file or a database. Perhaps you need
    to e-mail the text as an attachment that another system will pick up and then
    decompress. Whatever the reason, in-memory compression and decompression is a
    very useful feature to have around. The best way to do this is to use extension
    methods. If you haven't figured this out by now, I quite like using extension
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code is very straightforward. There is not much you will need to get ready
    beforehand. Just make sure that you include the following `using` statements in your
    project and that you have a file containing text called `file 3.txt` at the following
    path `C:\temp\Documents\file 3.txt`. You can continue using the console application
    created in the preceding recipe.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a class called `ExtensionMethods` that will contain two extension methods
    called `CompressStream()` and `DecompressStream()`. Both these extension methods
    will act on a byte array and return a byte array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at the `CompressStream()` extension method, you need to create a new
    `MemoryStream` to return to the calling code. Make use of the `using` statement
    so that objects are properly disposed of when they move out of scope. Next, add
    a `new GZipStream` object that will compress whatever we give it into the `outStream`
    object. You will notice that  `CompressionMode.Compress` is passed as a parameter
    to the `GZipStream` object. Lastly, write `originalSource` to the `GZipStream`
    object, compressing it and returning it to the calling method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Turn your attention to the `DecompressStream()` extension method next. The
    process is actually really simple. Create a new `MemoryStream` from `originalSource`
    and call it `sourceStream`. Create another `MemoryStream` called `outStream` to
    return to the calling code. Next, create a new `GZipStream` object and pass it
     `sourceStream` while setting the `CompressionMode.Decompress` value. Copy the
    decompressed stream to  `outStream` and return it to the calling code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'I created a method called `InMemCompressDecompress()` to illustrate the use
    of in-memory compression and decompression. I''m reading the contents of the file
    at `C:tempDocumentsfile 3.txt` into a variable called `inputString`. I then  use
    the default encoding to get the bytes, the original length, compressed length,
    and decompressed length. If you want to get the original text back, be sure to
    include the line `newString = Encoding.Default.GetString(newFromCompressed);`
    in your code and output that to the console window. A word of warning, though:
    if you are reading a lot of text, it''s probably not going to make much sense
    to display that in the console window. Write it to a file instead to check if
    the text is the same as what was compressed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure that you have a file called `File 3.txt` in the correct directory, as
    stated previously. Also, ensure that the file contains some text. You can see
    that the file I am going to compress in-memory is about 1.8 MB in size:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Running your console application will display the original length of the file,
    the compressed length and then the decompressed length. As would be expected,
    the decompressed length is the same length as the original string length:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_12-1.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In-memory compression and decompression allows developers to use on-the-fly
    compression and decompression when working with objects containing large data.
    This can be useful for when you need to read and write log information to a database,
    for example. This is another example of how the .NET Framework provides developers
    with the perfect platform to build world-class solutions on.
  prefs: []
  type: TYPE_NORMAL
- en: Async and await file processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With acync and await, developers can keep their applications fully responsive
    while performing intensive tasks such as file processing. This makes a perfect
    candidate for using asynchronous code. If you have several large files that need
    copying, an async and await method would be a perfect solution for keeping your
    form responsive.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ensure that you have added the following `using` statements to the top of your
    code file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: For asynchronous code to work, we need to include the threading namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create two folders called `AsyncDestination` and `AsyncSource`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To the `AsyncSource` folder, add a couple of large files to process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_14-1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a new WinForms application and add a forms times control, a button,
    and a label called `lblTimer` to the form. Call the timer asyncTimer and set its
    Interval to `1000` milliseconds (1 second):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the code above the constructor, add the `CancellationTokenSource` object
    and the `elapsedTime` variable to the `Form1` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constructor, set the timer label text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the button click event handler, add two if conditions. The first will run
    when the button is clicked first. The second will be run when the button is clicked
    again to cancel the process. Take note that this is an `async` event handler for
    `btnCopyFileAsync`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `Tick` event for the timer and update the timer label text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Have a look at the second `if` condition inside the button click. Set the button
    text back to what it was, and then call the `Cancel()` method of the `CancellationTokenSource`
    object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first `if` statement, set the source and destination directory. Also
    update the button text so that when it is clicked again, it will run the cancel
    logic. Instantiate  `CancellationTokenSource`, set the `elapsedTime` variable
    to `0` and then start the timer. We can now start enumerating the files in the
    source folder and store the result in the `fileEntries` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Start by iterating over the files in the source folder and copying the file
    from the source folder to the destination folder asynchronously. This can be seen
    in the line of code `await sfs.CopyToAsync(dfs, 81920, cts.Token);`. The value
    `81920` is just the buffer size and the cancellation token `cts.Token` is passed
    to the async method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, if the token isn''t canceled, stop the timer and update the timer label:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Putting the code all together, you will see how this all fits together:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the Windows form opens up for the first time, you will see that the timer
    label defaults to Timer Stopped. Click on the Copy Files Async button to start
    the copy process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_07_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the application has finished processing, you will see that the large files
    have been copied to the destination folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_07_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'While the copy process is running, your Windows form remains active and responsive.
    The timer label also continues to count. Usually, with processes such as these,
    the form would be unresponsive:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_07_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the files have finished copying, the timer label will display the duration
    of the async copy process. A fun experiment is to play around with this code to
    see how much you can optimize it to improve the copy speed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_07_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Windows form not only remains responsive, but also allows you to cancel
    the process whenever you like. When you click on the Copy Files Async button,
    the text changes to Cancel Async Copy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_07_20.png)'
  prefs: []
  type: TYPE_IMG
- en: Clicking on the Cancel button or sets the `CancellationTokenSource` object to
    canceled, which in turns stops the async file copy process.
  prefs: []
  type: TYPE_NORMAL
- en: How to make a custom type serializable?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Serialization is the process by which an object''s state is transformed into
    a set of bytes (depending on the serialization type used, it could be XML, binary,
    JSON), which can then be saved in a stream (think `MemoryStream` or `FileStream`)
    or transmitted via WCF or Web API. Making a custom type serializable means that
    you can apply serialization to custom types by adding the `System.SerializableAttribute`.
    Examples of custom types are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Classes and generic classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enums
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A real-world example of serialization could be to create a recovery mechanism
    for a specific object. Think of a workflow scenario. At some point in time, the
    state of the workflow needs to be persisted. You can serialize the state of that
    object and store this in a database. When the workflow needs to continue at a
    future point in time, you can read the object from the database and deserialize
    it to the exact state as it was before it was persisted to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Trying to serialize a non-serializable type will result in your code throwing
    a `SerializationException`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are running this example from your console application, ensure that the
    console application imports the `System` namespace by adding `using System` to
    the top of your `Program.cs` file. Also ensure that `using System.Runtime.Serialization.Formatters.Binary`
    is added.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Start by adding an abstract class called `Cat`. This class simply defines fields
    for `Weight` and `Age`. Note that in order to make your class serializable, you
    need to add the `[Serializable]` attribute to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a class called `Tiger` that is derived from the `Cat` class. Note
    that the `Tiger` class must also have the `[Serializable]` attribute added. This
    is because the serialization isn''t inherited from the base class. Each derived
    class must implement serialization on its own:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to create a method to serialize the `Tiger` class. Create a new
    object of type `Tiger` and set some values to it. We then use a `BinaryFormatter`
    to serialize the `Tiger` class into a `stream` and return it to the calling code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Deserialization is even easier. We create a `DeserializeTiger` method and pass
    the `stream` to it. We then use the `BinaryFormatter` again to deserialize the
    `stream` into an object of type `Tiger`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the results of our serialization and deserialization, read the result
    from the `SerializeTiger()` method into a new `Stream` and display it in the console
    window. Then, call the `DeserializeTiger()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the serialized data is written to the console window, you will see some
    identifying information. Most of it will, however, look jumbled up. This is because
    it's binary serialized data that is being displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_07_21.png)'
  prefs: []
  type: TYPE_IMG
- en: When this serialized data is deserialized, it is cast back to an object of the
    type `Tiger`. You can clearly see how the original values of the fields are visible
    in the deserialized object.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_07_22.png)'
  prefs: []
  type: TYPE_IMG
- en: Using ISerializable for custom serialization to a FileStream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want more control over what is serialized, you should implement `ISerializable`
    on your object. This gives a developer complete control over what is serialized.
    Note that you still need to add the `[ISerializable]` attribute to your object.
    Lastly, the developer also needs to implement a deserialization constructor. Using
    `ISerializable`, however, does have a caveat. According to the MSDN, the forward
    compatibility of your object with newer versions of the .NET Framework and any
    improvements made to the serialization framework might not be applicable on your
    object. You also need to implement `ISerializable` on all the derived types of
    your object.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create a new class that wants to control its own serialization using
    `ISerializable`. Ensure that your application has the `using System.Runtime.Serialization;`
    added to the `using` statements.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a class called `Vehicle`. You will notice that this class implements
    `ISerializable` while still having the `[Serializable]` attribute. You must do
    this so that the Common Language Runtime can identify this class as serializable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To this class, add the following fields and the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'When you implement `ISerilizable` on your `Vehicle` class, Visual Studio will
    alert you that the `ISerializable` interface has not been implemented inside your
    class. Add the implementation by clicking on the lightbulb next to the underlined
    interface name and accepting the correction. Visual Studio will now add the `GetObjectData()`
    method inside your class. Note that the method is added with an exception that
    will throw a `NotImplementedException` if you don''t add some code to the method.
    Add very basic code here that simply adds the values of the fields to the `SerializationInfo`
    object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned previously, we need to add the deserialization constructor that
    will deserialize the fields. This, you add manually:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding all the code, your class should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We are simply going to write the serialized class to a file. For the purposes
    of this recipe, simply hardcode an output path for the file. Next, create a new
    instance of the `Vehicle` class and set some values to the fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Also be sure to add the `VehicleTypes` enumerator to the top of your class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We then add the code that will serialize the class to the file you specified
    in the hardcoded path. To do this, we add a `FileStream` and a `BinaryFormatter`
    object to serialize the `vehicle` to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we add the code to read the file containing the serialized data and
    create the `Vehicle` object containing the state of the `Vehicle` at the time
    it was serialized. While the deserialize code runs immediately after the serialize
    code, note that this is just for demonstration purposes. The `Vehicle` deserialization
    could occur at any future point in time by reading from the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After you run your code, you will find that the `vehicleInfo.dat` file has
    been created at the path you specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_07_23.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Opening the file in a text editor will show the serialized information.  As
    you may notice, some of the class information is still visible:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_07_24.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we add a breakpoint in the deserialization code and inspect the created
    `deserializedVehicle` object, you will see that the `Vehicle` state has been *rehydrated*
    to the state it was before serialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_07_25.png)'
  prefs: []
  type: TYPE_IMG
- en: Using XmlSerializer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the name you probably guessed that the`XmlSerializer` serializes data into
    XML. It gives you more control over the XML structure of the serialized data.
    Typical real-world examples for using this serializer would be to maintain compatibility
    with XML web services. It is also an easy medium to use when transmitting data
    using some type of message queuing (such as MSMQ or RabbitMQ).
  prefs: []
  type: TYPE_NORMAL
- en: The default behavior of  `XmlSerializer` is to serialize public fields and properties.
    Using attributes from the `System.Xml.Serialization` namespace, you can control
    the structure of your XML.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we are going to use  `List<>` in this example, ensure that you have added
    the `using System.Collections.Generic;` namespace. We also want to have more control
    over the structure of the XML, so also include the using `System.Xml.Serialization;`
    namespace so that we can use the appropriate attributes. Lastly, for the LINQ
    query, you will need to add the `using System.Linq;` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Start off by creating a `Student` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a class for a subject called `FundamentalProgramming`. Several
    attributes have been applied to the fields of this class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`XmlRoot`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XmlElement`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XmlIgnore`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XmlAttribute`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XmlArray`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can see that the `XmlRoot` attribute specifies that `ElementName` be called
    `FundamentalsOfProgramming`. This attribute thus defines the root of your generated
    XML. The `XmlElement` specifies an element called `LecturerFullName` instead of
    `Lecturer`.  `XmlIgnore` attribute will cause  `XmlSerializer` to ignore this
    field during serialization, while  `XmlAttribute` will create an attribute on
    the root element of the generated XML. Lastly, we are serializing the `List<Student>`
    collection with the `XmlArray` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In the calling code, set up the `Student` objects and add them to the `List<Student>`
    object `students`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we create our `FundementalProgramming` class and populate the fields. The
    reason why `ClassAverage` is ignored is because we will always calculate this
    field value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to serialize the `subject` object, taking note to pass
    the type of object to  `XmlSerializer` as `typeof(FundamentalProgramming)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, add the code to deserialize the XML back into the `FundamentalProgramming`
    object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you run the console application, you will find that it creates an XML document
    at the path you specified in the code. Viewing this XML document, you can see
    that the XML elements are defined exactly as we specified on the class by using
    the attributes. Note that the `FundamentalsOfProgramming` root element has the
    `RoomNumber` field as an attribute. The field `ClassAverage` has been ignored
    and is not present in the XML. Lastly, you can see how nicely the `List<Student>`
    object has been serialized to the XML file.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_07_26-2.png)'
  prefs: []
  type: TYPE_IMG
- en: On deserialization of the XML, you will notice that the serialized values are
    displayed. `ClassAverage`; however, does not have a value as it was never serialized
    to begin with.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_07_27-1.png)'
  prefs: []
  type: TYPE_IMG
- en: JSON serializers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike `BinaryFormatter`, JSON serialization serializes data in a human-readable
    format. Using `XmlSerializer` also produces XML that is human-readable, but JSON
    serialization produces a smaller data size than `XmlSerializer`. JSON is primarily
    used to exchange data and can be used with many different programming languages
    (as can XML).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the Tools menu, go to NuGet Package Manager and click on the Manage NuGet
    Packages for Solution... menu. In the Browse tab, search for Newtonsoft.Json and
    install the NuGet package. Newtonsoft.Json is a high-performance JSON framework
    for .NET. Once it is installed, you will see that the reference Newtonsoft.Json
    has been added to your project, References.
  prefs: []
  type: TYPE_NORMAL
- en: In the `using` statements for your class, add the following namespaces `using
    Newtonsoft.Json;` and `using Newtonsoft.Json.Linq;` to your code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start off by creating the `FundamentalProgramming` and `Student` classes we
    used before for  `XmlSerializer`. This time, remove all the attributes to produce
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In the calling code, set up the `Student` object, as previously and add them
    to  `List<Student>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `subject` object of type `FundamentalProgramming` and assign the
    values to the fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `JsonSerializer` object to your code and set the formatting to indented.
    Using a `JsonWriter`, serialize the `subject` to the `serializationPath` to the
    file `classInfo.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The next section of code will read the text from the file `classInfo.txt` created
    previously and create a `JObject` called `jobj` that uses the `Newtonsoft.Json.Linq`
    namespace to query JSON objects. Use `JObject` to parse the string returned from
    the file. This is where the power of using the `Newtonsoft.Json.Linq` namespace
    becomes evident. I can query the `jobj` object using LINQ to return the student
    marks and calculate an average:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to deserialize the JSON object, the deserializer logic is quite
    easy to implement. We use a `JsonReader` to get the text from the file and deserialize
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After you run your console application, you can view the file created by the
    JSON serializer.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_07_28.png)'
  prefs: []
  type: TYPE_IMG
- en: The results of the class average calculation on the class and from the LINQ
    query on the JSON object are exactly the same.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_07_29.png)'
  prefs: []
  type: TYPE_IMG
- en: Lastly, the deserialized object from the JSON text in the file can be seen when
    adding a break point to the code and inspecting the `funProg` object. As you can
    see, the object state is the same as before it was serialized to the file.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_07_30.png)'
  prefs: []
  type: TYPE_IMG
- en: Do you remember at the beginning of this recipe I mentioned that JSON produces
    much less data than XML? I created the `Student` class containing 10,000 students
    in  `List<Student>` and serialized using XML and JSON. The comparison between
    the two file sizes is quite stunning. JSON clearly produces a much smaller file.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_07_31.png)'
  prefs: []
  type: TYPE_IMG
