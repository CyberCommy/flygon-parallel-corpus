- en: Working with Files, Streams, and Serialization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Working with files, streams, and serialization is something you as a developer
    will do many times. Creating import files, exporting data to a file, persisting
    an application state, using a file definition to build a file, and many other
    scenarios will present themselves at some point during your career. In this chapter,
    we will look at the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Creating and extracting ZIP archives
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In-memory stream compression and decompression
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Async and await file processing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to make a custom type serializable
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ISerializable for custom serialization to a FileStream
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using XmlSerializer
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON serializers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to work with files will definitely give you an edge as a developer.
    There are so many frameworks for working with files available to developers today,
    that one tends to forget that some of the functionality you want is already rolled
    up into the .NET Framework itself. Let's look at what exactly we can do with files.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: If you ever find that you need to create Excel files in ASP.NET applications,
    do have a look at the excellent EPPlus .NET library available on CodePlex. At
    the time of writing, the URL was: [https://epplus.codeplex.com/](https://epplus.codeplex.com/)
    and is licensed under the GNU **Library General Public License** (**LGPL**). Also
    consider donating to EPPlus. These folks wrote an incredible library that is very
    easy to use and well documented.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: On March 31, 2017 it was announced that CodePlex would be shut down completely
    on December 15, 2017\. According to the DISCUSSIONS tab on the EPPlus CodePlex
    page ([https://epplus.codeplex.com/discussions/662424](https://epplus.codeplex.com/discussions/662424))
    the source code will be moved to GitHub before CodePlex goes into read-only mode
    in October 2017.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Creating and extracting ZIP archives
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most basic things you can do is work with ZIP files. The .NET Framework
    does an excellent job at providing this functionality right out of the box. You
    might need to provide ZIP functionality in an application that needs to upload
    several files to a network share. Being able to ZIP several files and upload a
    single ZIP file makes more sense than having to upload several smaller files.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a console application and call it `FilesExample`:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_01.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: 'Right-click on the References node and select Add Reference... from the context
    menu:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_02.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: In the Reference Manager, search for the word `compression`. Add a reference
    to System.IO.Compression and System.IO.Compression.FileSystem to your project
    and click on the OK button.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the time of writing, there was a System.IO.Compression version 4.1.0.0 and
    System.IO.Compression version 4.0.0.0 available from the Reference Manager. The
    example I created just used version 4.1.0.0.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_07_03.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: 'When you have added your references, your solution should look as follows:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_04-1.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: 'Create a folder called `Documents` in your `temp` folder:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_05.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
- en: 'Inside this folder, create a few files of varying sizes:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_06.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
- en: You are now ready to write some code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add the following `using` statements to the top of your `Program.cs` file:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a method called `ZipIt()` and add the code to it to ZIP the `Documents`
    directory. The code is pretty straightforward to understand. I want to, however,
    highlight the use of the `CreateFromDirectory()` method. Notice that we have set
    the compression level to `CompressionLevel.Optimal` and set the `includeBaseDirectory`
    parameter to `false`:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Run your console application and look at the `temp` folder again. You will
    see the following ZIP file created:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_07.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
- en: 'Viewing the contents of the ZIP file will display the files contained in the
    `Documents` folder that we saw earlier:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_08.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
- en: 'Viewing the properties of the ZIP file, you will see that it has been compressed
    to 36 KB:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_09.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
- en: 'Extracting a ZIP file is just as easy to do. Create a method called `UnZipIt()`
    and pass the path to the `temp` folder to it. Then, specify the directory to unzip
    the files to and set the variable called `destinationDirectory`. Call the `ExtractToDirectory()`
    method and pass it the `archiveName` and `destinationDirectory` variables as parameters:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Run your console application and view the output folder:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_10.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
- en: 'Viewing the extracted files in the `DocumentsUnzipped` folder, you will see
    the original files we started off with:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_11.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with ZIP files in .NET is really as easy as it gets. The .NET Framework
    does a lot of the heavy lifting for mundane tasks such as creating archives. It
    also allows developers to maintain a certain standard of code without having to
    "roll their own" archiving methods.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: In-memory stream compression and decompression
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you need to perform some in-memory compression of a large amount
    of text. You might want to write this to a file or a database. Perhaps you need
    to e-mail the text as an attachment that another system will pick up and then
    decompress. Whatever the reason, in-memory compression and decompression is a
    very useful feature to have around. The best way to do this is to use extension
    methods. If you haven't figured this out by now, I quite like using extension
    methods.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code is very straightforward. There is not much you will need to get ready
    beforehand. Just make sure that you include the following `using` statements in your
    project and that you have a file containing text called `file 3.txt` at the following
    path `C:\temp\Documents\file 3.txt`. You can continue using the console application
    created in the preceding recipe.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How to do it...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a class called `ExtensionMethods` that will contain two extension methods
    called `CompressStream()` and `DecompressStream()`. Both these extension methods
    will act on a byte array and return a byte array:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Looking at the `CompressStream()` extension method, you need to create a new
    `MemoryStream` to return to the calling code. Make use of the `using` statement
    so that objects are properly disposed of when they move out of scope. Next, add
    a `new GZipStream` object that will compress whatever we give it into the `outStream`
    object. You will notice that  `CompressionMode.Compress` is passed as a parameter
    to the `GZipStream` object. Lastly, write `originalSource` to the `GZipStream`
    object, compressing it and returning it to the calling method:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Turn your attention to the `DecompressStream()` extension method next. The
    process is actually really simple. Create a new `MemoryStream` from `originalSource`
    and call it `sourceStream`. Create another `MemoryStream` called `outStream` to
    return to the calling code. Next, create a new `GZipStream` object and pass it
     `sourceStream` while setting the `CompressionMode.Decompress` value. Copy the
    decompressed stream to  `outStream` and return it to the calling code:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'I created a method called `InMemCompressDecompress()` to illustrate the use
    of in-memory compression and decompression. I''m reading the contents of the file
    at `C:tempDocumentsfile 3.txt` into a variable called `inputString`. I then  use
    the default encoding to get the bytes, the original length, compressed length,
    and decompressed length. If you want to get the original text back, be sure to
    include the line `newString = Encoding.Default.GetString(newFromCompressed);`
    in your code and output that to the console window. A word of warning, though:
    if you are reading a lot of text, it''s probably not going to make much sense
    to display that in the console window. Write it to a file instead to check if
    the text is the same as what was compressed:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Ensure that you have a file called `File 3.txt` in the correct directory, as
    stated previously. Also, ensure that the file contains some text. You can see
    that the file I am going to compress in-memory is about 1.8 MB in size:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_06.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
- en: 'Running your console application will display the original length of the file,
    the compressed length and then the decompressed length. As would be expected,
    the decompressed length is the same length as the original string length:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_12-1.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In-memory compression and decompression allows developers to use on-the-fly
    compression and decompression when working with objects containing large data.
    This can be useful for when you need to read and write log information to a database,
    for example. This is another example of how the .NET Framework provides developers
    with the perfect platform to build world-class solutions on.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Async and await file processing
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With acync and await, developers can keep their applications fully responsive
    while performing intensive tasks such as file processing. This makes a perfect
    candidate for using asynchronous code. If you have several large files that need
    copying, an async and await method would be a perfect solution for keeping your
    form responsive.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ensure that you have added the following `using` statements to the top of your
    code file:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For asynchronous code to work, we need to include the threading namespaces.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create two folders called `AsyncDestination` and `AsyncSource`:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_13.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
- en: 'To the `AsyncSource` folder, add a couple of large files to process:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_14-1.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
- en: 'Create a new WinForms application and add a forms times control, a button,
    and a label called `lblTimer` to the form. Call the timer asyncTimer and set its
    Interval to `1000` milliseconds (1 second):'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_15.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: 'In the code above the constructor, add the `CancellationTokenSource` object
    and the `elapsedTime` variable to the `Form1` class:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the constructor, set the timer label text:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the button click event handler, add two if conditions. The first will run
    when the button is clicked first. The second will be run when the button is clicked
    again to cancel the process. Take note that this is an `async` event handler for
    `btnCopyFileAsync`:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add a `Tick` event for the timer and update the timer label text:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Have a look at the second `if` condition inside the button click. Set the button
    text back to what it was, and then call the `Cancel()` method of the `CancellationTokenSource`
    object:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the first `if` statement, set the source and destination directory. Also
    update the button text so that when it is clicked again, it will run the cancel
    logic. Instantiate  `CancellationTokenSource`, set the `elapsedTime` variable
    to `0` and then start the timer. We can now start enumerating the files in the
    source folder and store the result in the `fileEntries` variable:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Start by iterating over the files in the source folder and copying the file
    from the source folder to the destination folder asynchronously. This can be seen
    in the line of code `await sfs.CopyToAsync(dfs, 81920, cts.Token);`. The value
    `81920` is just the buffer size and the cancellation token `cts.Token` is passed
    to the async method:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Lastly, if the token isn''t canceled, stop the timer and update the timer label:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Putting the code all together, you will see how this all fits together:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the Windows form opens up for the first time, you will see that the timer
    label defaults to Timer Stopped. Click on the Copy Files Async button to start
    the copy process:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_07_16.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
- en: 'When the application has finished processing, you will see that the large files
    have been copied to the destination folder:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_07_17.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
- en: 'While the copy process is running, your Windows form remains active and responsive.
    The timer label also continues to count. Usually, with processes such as these,
    the form would be unresponsive:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_07_18.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
- en: 'When the files have finished copying, the timer label will display the duration
    of the async copy process. A fun experiment is to play around with this code to
    see how much you can optimize it to improve the copy speed:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_07_19.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
- en: 'The Windows form not only remains responsive, but also allows you to cancel
    the process whenever you like. When you click on the Copy Files Async button,
    the text changes to Cancel Async Copy:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_07_20.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: Clicking on the Cancel button or sets the `CancellationTokenSource` object to
    canceled, which in turns stops the async file copy process.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: How to make a custom type serializable?
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Serialization is the process by which an object''s state is transformed into
    a set of bytes (depending on the serialization type used, it could be XML, binary,
    JSON), which can then be saved in a stream (think `MemoryStream` or `FileStream`)
    or transmitted via WCF or Web API. Making a custom type serializable means that
    you can apply serialization to custom types by adding the `System.SerializableAttribute`.
    Examples of custom types are as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Classes and generic classes
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structs
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enums
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A real-world example of serialization could be to create a recovery mechanism
    for a specific object. Think of a workflow scenario. At some point in time, the
    state of the workflow needs to be persisted. You can serialize the state of that
    object and store this in a database. When the workflow needs to continue at a
    future point in time, you can read the object from the database and deserialize
    it to the exact state as it was before it was persisted to the database.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Trying to serialize a non-serializable type will result in your code throwing
    a `SerializationException`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are running this example from your console application, ensure that the
    console application imports the `System` namespace by adding `using System` to
    the top of your `Program.cs` file. Also ensure that `using System.Runtime.Serialization.Formatters.Binary`
    is added.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Start by adding an abstract class called `Cat`. This class simply defines fields
    for `Weight` and `Age`. Note that in order to make your class serializable, you
    need to add the `[Serializable]` attribute to it.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, create a class called `Tiger` that is derived from the `Cat` class. Note
    that the `Tiger` class must also have the `[Serializable]` attribute added. This
    is because the serialization isn''t inherited from the base class. Each derived
    class must implement serialization on its own:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we need to create a method to serialize the `Tiger` class. Create a new
    object of type `Tiger` and set some values to it. We then use a `BinaryFormatter`
    to serialize the `Tiger` class into a `stream` and return it to the calling code:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Deserialization is even easier. We create a `DeserializeTiger` method and pass
    the `stream` to it. We then use the `BinaryFormatter` again to deserialize the
    `stream` into an object of type `Tiger`:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To see the results of our serialization and deserialization, read the result
    from the `SerializeTiger()` method into a new `Stream` and display it in the console
    window. Then, call the `DeserializeTiger()` method:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the serialized data is written to the console window, you will see some
    identifying information. Most of it will, however, look jumbled up. This is because
    it's binary serialized data that is being displayed.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_07_21.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
- en: When this serialized data is deserialized, it is cast back to an object of the
    type `Tiger`. You can clearly see how the original values of the fields are visible
    in the deserialized object.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_07_22.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
- en: Using ISerializable for custom serialization to a FileStream
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want more control over what is serialized, you should implement `ISerializable`
    on your object. This gives a developer complete control over what is serialized.
    Note that you still need to add the `[ISerializable]` attribute to your object.
    Lastly, the developer also needs to implement a deserialization constructor. Using
    `ISerializable`, however, does have a caveat. According to the MSDN, the forward
    compatibility of your object with newer versions of the .NET Framework and any
    improvements made to the serialization framework might not be applicable on your
    object. You also need to implement `ISerializable` on all the derived types of
    your object.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create a new class that wants to control its own serialization using
    `ISerializable`. Ensure that your application has the `using System.Runtime.Serialization;`
    added to the `using` statements.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a class called `Vehicle`. You will notice that this class implements
    `ISerializable` while still having the `[Serializable]` attribute. You must do
    this so that the Common Language Runtime can identify this class as serializable:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To this class, add the following fields and the constructor:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When you implement `ISerilizable` on your `Vehicle` class, Visual Studio will
    alert you that the `ISerializable` interface has not been implemented inside your
    class. Add the implementation by clicking on the lightbulb next to the underlined
    interface name and accepting the correction. Visual Studio will now add the `GetObjectData()`
    method inside your class. Note that the method is added with an exception that
    will throw a `NotImplementedException` if you don''t add some code to the method.
    Add very basic code here that simply adds the values of the fields to the `SerializationInfo`
    object:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As mentioned previously, we need to add the deserialization constructor that
    will deserialize the fields. This, you add manually:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After adding all the code, your class should look as follows:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We are simply going to write the serialized class to a file. For the purposes
    of this recipe, simply hardcode an output path for the file. Next, create a new
    instance of the `Vehicle` class and set some values to the fields:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Also be sure to add the `VehicleTypes` enumerator to the top of your class:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We then add the code that will serialize the class to the file you specified
    in the hardcoded path. To do this, we add a `FileStream` and a `BinaryFormatter`
    object to serialize the `vehicle` to the file:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Lastly, we add the code to read the file containing the serialized data and
    create the `Vehicle` object containing the state of the `Vehicle` at the time
    it was serialized. While the deserialize code runs immediately after the serialize
    code, note that this is just for demonstration purposes. The `Vehicle` deserialization
    could occur at any future point in time by reading from the file:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After you run your code, you will find that the `vehicleInfo.dat` file has
    been created at the path you specified:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_07_23.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: 'Opening the file in a text editor will show the serialized information.  As
    you may notice, some of the class information is still visible:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_07_24.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
- en: 'If we add a breakpoint in the deserialization code and inspect the created
    `deserializedVehicle` object, you will see that the `Vehicle` state has been *rehydrated*
    to the state it was before serialization:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_07_25.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
- en: Using XmlSerializer
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the name you probably guessed that the`XmlSerializer` serializes data into
    XML. It gives you more control over the XML structure of the serialized data.
    Typical real-world examples for using this serializer would be to maintain compatibility
    with XML web services. It is also an easy medium to use when transmitting data
    using some type of message queuing (such as MSMQ or RabbitMQ).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: The default behavior of  `XmlSerializer` is to serialize public fields and properties.
    Using attributes from the `System.Xml.Serialization` namespace, you can control
    the structure of your XML.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we are going to use  `List<>` in this example, ensure that you have added
    the `using System.Collections.Generic;` namespace. We also want to have more control
    over the structure of the XML, so also include the using `System.Xml.Serialization;`
    namespace so that we can use the appropriate attributes. Lastly, for the LINQ
    query, you will need to add the `using System.Linq;` namespace.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Start off by creating a `Student` class.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, create a class for a subject called `FundamentalProgramming`. Several
    attributes have been applied to the fields of this class:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`XmlRoot`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XmlElement`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XmlIgnore`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XmlAttribute`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XmlArray`'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can see that the `XmlRoot` attribute specifies that `ElementName` be called
    `FundamentalsOfProgramming`. This attribute thus defines the root of your generated
    XML. The `XmlElement` specifies an element called `LecturerFullName` instead of
    `Lecturer`.  `XmlIgnore` attribute will cause  `XmlSerializer` to ignore this
    field during serialization, while  `XmlAttribute` will create an attribute on
    the root element of the generated XML. Lastly, we are serializing the `List<Student>`
    collection with the `XmlArray` attribute:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the calling code, set up the `Student` objects and add them to the `List<Student>`
    object `students`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now we create our `FundementalProgramming` class and populate the fields. The
    reason why `ClassAverage` is ignored is because we will always calculate this
    field value:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Add the following code to serialize the `subject` object, taking note to pass
    the type of object to  `XmlSerializer` as `typeof(FundamentalProgramming)`:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Lastly, add the code to deserialize the XML back into the `FundamentalProgramming`
    object:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works...
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you run the console application, you will find that it creates an XML document
    at the path you specified in the code. Viewing this XML document, you can see
    that the XML elements are defined exactly as we specified on the class by using
    the attributes. Note that the `FundamentalsOfProgramming` root element has the
    `RoomNumber` field as an attribute. The field `ClassAverage` has been ignored
    and is not present in the XML. Lastly, you can see how nicely the `List<Student>`
    object has been serialized to the XML file.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_07_26-2.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
- en: On deserialization of the XML, you will notice that the serialized values are
    displayed. `ClassAverage`; however, does not have a value as it was never serialized
    to begin with.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_07_27-1.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
- en: JSON serializers
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike `BinaryFormatter`, JSON serialization serializes data in a human-readable
    format. Using `XmlSerializer` also produces XML that is human-readable, but JSON
    serialization produces a smaller data size than `XmlSerializer`. JSON is primarily
    used to exchange data and can be used with many different programming languages
    (as can XML).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the Tools menu, go to NuGet Package Manager and click on the Manage NuGet
    Packages for Solution... menu. In the Browse tab, search for Newtonsoft.Json and
    install the NuGet package. Newtonsoft.Json is a high-performance JSON framework
    for .NET. Once it is installed, you will see that the reference Newtonsoft.Json
    has been added to your project, References.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: In the `using` statements for your class, add the following namespaces `using
    Newtonsoft.Json;` and `using Newtonsoft.Json.Linq;` to your code.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start off by creating the `FundamentalProgramming` and `Student` classes we
    used before for  `XmlSerializer`. This time, remove all the attributes to produce
    the following code:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the calling code, set up the `Student` object, as previously and add them
    to  `List<Student>`:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create the `subject` object of type `FundamentalProgramming` and assign the
    values to the fields:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Add a `JsonSerializer` object to your code and set the formatting to indented.
    Using a `JsonWriter`, serialize the `subject` to the `serializationPath` to the
    file `classInfo.txt`:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向您的代码添加一个`JsonSerializer`对象，并将格式设置为缩进。使用`JsonWriter`，将`subject`序列化到`serializationPath`文件`classInfo.txt`中：
- en: '[PRE41]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The next section of code will read the text from the file `classInfo.txt` created
    previously and create a `JObject` called `jobj` that uses the `Newtonsoft.Json.Linq`
    namespace to query JSON objects. Use `JObject` to parse the string returned from
    the file. This is where the power of using the `Newtonsoft.Json.Linq` namespace
    becomes evident. I can query the `jobj` object using LINQ to return the student
    marks and calculate an average:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码的下一部分将从之前创建的`classInfo.txt`文件中读取文本，并创建一个名为`jobj`的`JObject`，该对象使用`Newtonsoft.Json.Linq`命名空间来查询JSON对象。使用`JObject`来解析从文件返回的字符串。这就是使用`Newtonsoft.Json.Linq`命名空间的强大之处。我可以使用LINQ查询`jobj`对象来返回学生的分数并计算平均值：
- en: '[PRE42]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If you need to deserialize the JSON object, the deserializer logic is quite
    easy to implement. We use a `JsonReader` to get the text from the file and deserialize
    it:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要对JSON对象进行反序列化，反序列化逻辑非常容易实现。我们使用`JsonReader`从文件中获取文本并进行反序列化：
- en: '[PRE43]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works...
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: After you run your console application, you can view the file created by the
    JSON serializer.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 运行控制台应用程序后，您可以查看JSON序列化器创建的文件。
- en: '![](img/B06434_07_28.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_07_28.png)'
- en: The results of the class average calculation on the class and from the LINQ
    query on the JSON object are exactly the same.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 班级平均值计算的结果和对JSON对象的LINQ查询结果完全相同。
- en: '![](img/B06434_07_29.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_07_29.png)'
- en: Lastly, the deserialized object from the JSON text in the file can be seen when
    adding a break point to the code and inspecting the `funProg` object. As you can
    see, the object state is the same as before it was serialized to the file.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可以在代码中添加断点并检查`funProg`对象，从文件中的JSON文本中反序列化的对象可以看到。如您所见，对象状态与序列化到文件之前的状态相同。
- en: '![](img/B06434_07_30.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_07_30.png)'
- en: Do you remember at the beginning of this recipe I mentioned that JSON produces
    much less data than XML? I created the `Student` class containing 10,000 students
    in  `List<Student>` and serialized using XML and JSON. The comparison between
    the two file sizes is quite stunning. JSON clearly produces a much smaller file.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得在本教程开始时我提到过JSON产生的数据比XML少得多吗？我创建了包含10,000名学生的`Student`类，使用XML和JSON进行了序列化。两个文件大小的比较非常惊人。显然，JSON产生了一个更小的文件。
- en: '![](img/B06434_07_31.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_07_31.png)'
