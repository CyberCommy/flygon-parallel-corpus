- en: Chapter 7. Introduction to Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last piece of the MEAN puzzle is, of course, Angular. Back in 2009, while
    building their JSON as platform service, developers Miško Hevery and Adam Abrons
    noticed that the common JavaScript libraries weren''t enough. The nature of their
    rich web applications raised the need for a more structured framework that would
    reduce redundant work and keep the project code organized. Abandoning their original
    idea, they decided to focus on the development of their framework, naming it AngularJS
    and releasing it under an open source license. The idea was to bridge the gap
    between JavaScript and HTML and help popularize single-page application development.
    In the years to come, AngularJS—now referred to as Angular—became one of the most
    popular frameworks in the JavaScript ecosystem, and it completely changed the
    frontend development world. However, in the past few years, there were a few major
    paradigm shifts. So, when the Google-sponsored team decided to work on Angular''s
    next version, they introduced a whole set of new ideas. In this chapter, we''ll
    cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing TypeScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Angular 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the building blocks of Angular 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and configuring TypeScript and Angular 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and organizing the Angular 2 application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing Angular's components architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the `Authentication` component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Angular 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AngularJS was a frontend JavaScript framework designed to build single-page
    applications using an MVC-like architecture. The Angular approach was to extend
    the functionality of HTML using special attributes that bind JavaScript logic
    with HTML elements. AngularJS's ability to extend HTML allowed cleaner DOM manipulation
    through client-side templating and two-way data binding that seamlessly synchronized
    between models and views. AngularJS also improved the application's code structure
    and testability using MVC and dependency injection. AngularJS 1 was and still
    is a great framework, but it was built with the concepts of ES5 in mind, and with
    the huge improvements brought by the new ES2015 specification coming up, the team
    had to rethink the entire approach.
  prefs: []
  type: TYPE_NORMAL
- en: From Angular 1.x to Angular 2.x
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you''re already familiar with Angular 1, moving to Angular 2 might seem
    like a big step. However, the Angular team made sure to keep the good parts of
    Angular 1 while leveraging ES2015''s new capabilities and maintaining a clearer
    path toward an improved framework. Here''s a quick summary of the changes made
    from Angular 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Syntax**: Angular 2 relies on the new ECMAScript specification formerly known
    as ES6 and now renamed ES2015\. However, the specification is still a work in
    progress and browser support is still lacking. To overcome this issue, the Angular
    2 team decided to use TypeScript.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TypeScript**: TypeScript is a superset of ES2015, which means that it allows
    you to write strongly typed ES2015 code, which will later be compiled into the
    ES5 or ES2015 source depending on your needs and platform support. Angular 2 is
    pushing hard for TypeScript usage in their documentation and code examples, and
    so will we. Don''t worry, though; as vast and terrifying as TypeScript might seem,
    by the end of this chapter, you''ll be able to use it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modules**: Angular 1 introduced a modular architecture that required the
    usage of the `angular#module()` custom method. However, ES2015 introduced a built-in
    module system very similar to the one used in Node.js. So Angular 2 modules are
    much easier to create and use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controllers**: Angular 1 was all about controllers. In the first version
    of this book, this chapter was mainly focused on the Angular 1 MVC approach, but
    in Angular 2, the basic building block is components. This shift also represents
    a bigger shift in the JavaScript ecosystem, especially regarding web components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scopes**: The famous `$scope` object is now obsolete. In Angular 2, the component
    model is cleaner and more readable. Generally, the introduction of classes in
    ES2015 and its support in TypeScript allows better design patterns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decorators**: Decorators is a design feature implemented in TypeScript and
    is probably going to be implemented in ES2016(ES7). Decorators allow developers
    to annotate classes and members in order to add features or data while not extending
    the entity. Angular 2 relies on decorators to implement certain features, and
    you''re going to deal with them later in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency Injection**: Angular 1 used the Dependency Injection paradigm
    quite intensively. Angular 2 made Dependency Injection simpler and now supports
    multiple injectors instead of one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these features mark a new era for Angular and JavaScript in general and
    it all starts with TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript is a typed programming language created by Microsoft, which uses
    the object-oriented foundations of C#, Java, and now ES2015\. Code written in
    TypeScript is transpiled into JavaScript code either in ES3, ES5 or ES2015 and
    can be run on any of the modern web browsers. It is also a superset of ES2015,
    so basically, any JavaScript code is valid TypeScript code. The idea behind this
    was to create a strongly typed programming language for big projects that will
    allow big teams to better communicate the interface between their software components.
    As derived from its name, TypeScript has an optional type system that allows developers
    to enforce limits on their code in order to have better clarity. Since a lot of
    the features in TypeScript were already implemented in ES2015, we'll touch a few
    basic features that we'll need and didn't get in the current specifications.
  prefs: []
  type: TYPE_NORMAL
- en: Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Types are a major part of every programming language, including JavaScript.
    Unfortunately, static typing was not introduced in ES2015; however, TypeScript
    support the basic JavaScript types and also allows developers to create and use
    their own types.
  prefs: []
  type: TYPE_NORMAL
- en: Basic types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Types can be JavaScript primitive types, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, TypeScript also allows you to work with arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Both ways are then transpiled into the familiar JavaScript array declaration.
  prefs: []
  type: TYPE_NORMAL
- en: The any type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `any` type represents any freeform JavaScript value. The value of `any`
    will go through a minimal static type checking by the transpiler and will support
    all operations as a JavaScript value. All properties on an `any` value can be
    accessed, and an `any` value can also be called as a function with an argument
    list. Actually, `any` is a supertype of all types, and whenever TypeScript cannot
    infer a type, the `any` type will be used. You''ll be able to use the `any` type
    either explicitly or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As TypeScript is about keeping the structure of your project, highly important
    parts of the language are interfaces. An interface allows you shape your objects
    and keep your code solid and clear. Classes can implement interfaces, which means
    that they will have to conform to the properties or methods declared in the interface.
    Interfaces can also inherit from other interfaces, which means that their implementing
    classes will be able to implement the extended interfaces. An example TypeScript
    interface will look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have an `IVehicle` interface with two properties and one method. An
    implementing class would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `Car` class implements the `IVehicle` interface and follows
    the structure set by it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Interfaces are a powerful feature of TypeScript and are an important part of
    OOP. It is recommended that you continue reading about them here: [https://www.typescriptlang.org/docs/handbook/interfaces.html](https://www.typescriptlang.org/docs/handbook/interfaces.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Decorators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While it''s still in the proposal stage for the new ES7 specifications, Angular
    2 relies heavily on decorators. A decorator is a special kind of declaration that
    can be attached to various entities, such as classes, methods, or properties.
    Decorators provide developers with a reusable way to annotate and modify classes
    and members. A decorator uses the `@decoratorName` form, where the `decoratorName`
    parameter must be a function that will be called at runtime with the decorated
    entity. A simple decorator would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'At runtime, the decorator will be executed with the target parameter populated
    with the `MyClass` constructor. Moreover, the decorator can also have arguments
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This pattern is also know as a decorator factory. Decorators may seem a bit
    odd, but as soon as we dive into Angular 2, you'll begin to understand their robustness.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TypeScript has been around for years and is being developed by a very strong
    team. This means that we've barely scratched the surface of its endless features
    and abilities. However, this introduction will provide us with the skills and
    knowledge required for diving into the great framework that Angular 2 is.
  prefs: []
  type: TYPE_NORMAL
- en: Angular 2 Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The goal of Angular 2 is simple: bring HTML and JavaScript together in a manageable
    and scalable way in order to build a client application. To do that, Angular 2
    uses a component-based approach with supporting entities, such as services and
    directives being injected into the components at runtime. This approach may seem
    a bit odd at first, but it allows us to keep a clear separation of concerns and
    generally maintain a clearer project structure. In order to understand the basics
    of Angular 2, take a look at the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Angular 2 Architecture](img/B05071_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding figure presents a simplistic architecture for an Angular 2 application
    consisting of two components. The center entities are the components. Each component
    performs data binding and event handling with its template in order to present
    the user with an interactive UI. Services are created for any other task, such
    as loading data, performing calculations, and so on. The services are then consumed
    by the components that delegate these tasks. Directives are the instructions for
    the rendering of the component's templates. In order to understand this better,
    let's dive in a little deeper.
  prefs: []
  type: TYPE_NORMAL
- en: Angular 2 Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Angular 2 applications are usually modular applications. This means that an
    Angular 2 application consists of multiple modules, and each one is a piece of
    code usually dedicated to a single task. In fact, the entire framework is built
    in a modular way that allows developer to import only the features they need.
    Fortunately, Angular 2 uses the ES2015 module syntax we covered earlier. Our application
    will be built of custom modules as well, and a sample application module would
    look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we use the `@NgModule` decorator to create the application
    module, which uses the application component and routes to bootstrap our application.
    To understand this better, let''s take a look at the first and foremost building
    block of an Angular 2 application: the component.'
  prefs: []
  type: TYPE_NORMAL
- en: Angular 2 Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A component is the essential building block of an Angular 2 application. Its
    job is to control a dedicated part of a user interface usually referred to as
    a view. Most applications will consist of at least one root application component
    and, usually, multiple components that control different views. Components are
    usually defined as a regular ES2015 class with a `@Component` decorator that defines
    it as a component and includes the component metadata. The component class is
    then exported as a module that can be imported and used in other parts of your
    application. A simple application component will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note how we import the `@Component` decorator from the `@angular/core` module
    library and then use it to define our component DOM selector and the template
    we want to use. In the end, we export a class called `AppComponent`. Components
    are one side of the view management, and we have the template on the other side.
  prefs: []
  type: TYPE_NORMAL
- en: Angular 2 Templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Templates are used by the components to render a component view. They are formed
    from a mix of basic HTML combined with Angular-dedicated annotations, which tells
    the component how to render the final view. In the previous example, you can see
    that a simple template is passed directly to the `AppComponent` class. However,
    you can also save your template in an external template file and change your component
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see here, our current template is static, so in order to create more
    useful templates, it's time to discuss data binding.
  prefs: []
  type: TYPE_NORMAL
- en: Angular 2 data binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of Angular's greatest features is its sophisticated data binding abilities.
    If you're used to working outside a framework, you know the nightmare that it
    is to manage data updates between the view and your data model. Luckily, Angular's
    data binding provides you with a straightforward way of managing the binding between
    your component class and the rendered view.
  prefs: []
  type: TYPE_NORMAL
- en: Interpolation binding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The simplest way of binding data from your component class to your template
    is called interpolation. An interpolation binds a value of the class property
    with your template using the double curly brackets syntax. A simple example of
    this mechanism will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note how we bind the `title` property of our `AppComponent` class inside the
    template HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Property binding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another example of one-way data binding would be property binding, which allows
    you to bind an HTML element property value with a component property value or
    any other template expression. This is done using square brackets, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, Angular will render the button as disabled since we set the
    `isButtonDisabled` property to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Event binding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order for your component to respond to the DOM event generated from the
    view, Angular 2 provides you with the mechanism of event binding. To bind a DOM
    event to a component method, all you have to do is set the event name inside round
    brackets, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this example, a click event of the view button will call the `showMessage()`
    method inside our `AppComponent` class.
  prefs: []
  type: TYPE_NORMAL
- en: Two-way binding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Up until now, we''ve only discussed one-way data binding where either the view
    calls a component function or the component changes the view. However, when dealing
    with user inputs, we''ll need to be able to do two-way data binding in a seamless
    way. This can be done by adding the `ngModel` property to your input HTML element
    and binding it to a component property. To do that, we''ll need to use a combination
    syntax of round and square brackets, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this example, a user will see a title element that will be updated live according
    to the input. The input binds the name property both ways, so every change to
    the input value will be updated in the `AppComponent` class and rendered into
    the view. The `ngModel` property we used here is called a directive, so naturally,
    it's time to discuss directives.
  prefs: []
  type: TYPE_NORMAL
- en: Angular 2 Directives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Angular's basic operation is to transform our dynamic templates into views using
    a set of instructions that are usually directives. There are several types of
    directives, but the most basic and surprising one is the component. The `@Component`
    decorator actually extends the `@Directive` decorator by adding a template to
    it. Remember the selector property in previous examples? If you use this selector
    as a tag inside another component, it will render our component inside. But this
    is just one type of a directive; the other would be our `ngModel` directive in
    the previous example. All in all, we have three types of directives.
  prefs: []
  type: TYPE_NORMAL
- en: Attribute directives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Attribute directives change the behavior or appearance of a DOM element. We
    use these directives as HTML attributes on the given DOM element that we want
    to change. Angular 2 comes with several prebuilt attribute directives, such as
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ngClass`: Provides a way to bind singular or multiple classes to an element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngStyle`: Provides a way to bind singular or multiple inline styles to an
    element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngModel`: Creates a two-way data binding over form elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are just a few examples, but you should keep in mind that you can and
    should write your own custom directives.
  prefs: []
  type: TYPE_NORMAL
- en: Structural directives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Structural directives change our application''s DOM layout by removing and
    adding DOM elements. Angular 2 contains three major structural directives you
    should know about:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ngIf`: Provides a way to add or remove elements according to the condition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngFor`: Provides a way to create copies of an element based on a list of objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngSwitch`: Provides a way to display a single element out of a list of elements
    based on a property value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All structural directives use a mechanism called the HTML5 template, which allows
    our DOM to hold an HTML template without rendering using the template tag. This
    has a consequence that we'll discuss when we use these directives.
  prefs: []
  type: TYPE_NORMAL
- en: Component directives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As described previously, every component is basically a directive. For instance,
    let''s say we have component called `SampleComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use it as a directive in our `AppComponent` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we use the sample-component tag and include our `SampleComponent`
    module in the `AppComponent` list of directives.
  prefs: []
  type: TYPE_NORMAL
- en: To conclude, directives used to be a frightening concept for many Angular 1
    developers, but now they're simple, easy to understand, and fun to use. Later
    in this book, you'll learn how to use the majority of the concepts presented in
    this section.
  prefs: []
  type: TYPE_NORMAL
- en: Angular 2 Services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Services are an essential part of Angular 2\. They are basically just classes
    that a single purpose or feature needs in the application. Since we want to keep
    our components clean and focused on the user experience, services come with pretty
    much everything else. For instance, any data management, logging, application
    configuration, or otherwise a functionality that does not belong in a component
    will be implemented as a service. It is also worth noting that there is absolutely
    nothing special about Angular 2 services; they are just plain classes with a defined
    functionality. What is special about them is that we can make these services available
    for components using a mechanism called Dependency Injection.
  prefs: []
  type: TYPE_NORMAL
- en: Angular 2 Dependency Injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A Dependency Injection is a software design pattern popularized by a software
    engineer named Martin Fowler. The main principle behind Dependency Injection is
    the inversion of control in a software development architecture. To understand
    this better, let''s take a look at the following `notifier` example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `Notifier` class creates an instance of `userService`, and when the `notify()`
    method is called, it alerts a different message based on the user role. Now this
    can work pretty well, but what happens when you want to test your `Notifier` class?
    You will create a `Notifier` instance in your test, but you won''t be able to
    pass a mock `userService` object to test the different results of the `notify`
    method. Dependency injection solves this by moving the responsibility of creating
    the `userService` object to the creator of the `Notifier` instance, whether it
    is another object or a test. This creator is often referred to as the injector.
    A revised, injection-dependent version of this example will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now whenever you create an instance of the `Notifier` class, the injector will
    be responsible for injecting a `userService` object into the constructor, making
    it possible to control the behavior of the `Notifier` instance outside of its
    constructor, a design often described as the inversion of control.
  prefs: []
  type: TYPE_NORMAL
- en: Using Dependency Injection in Angular 2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Angular 2, Dependency Injection is used to inject services into components.
    Services are injected in the constructor function of the components, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: When Angular 2 creates an instance of a component class, it will first request
    an injector that will resolve the needed services to call the constructor function.
    If an Injector contains a previous instance of the service, it will provide it;
    otherwise, the Injector will create a new instance. To do that, you'll need to
    provide the component injector with the service provider. This is why we add the
    `providers` property to the `@Component` decorator. Furthermore, we can register
    providers at any level of our component tree, and a common pattern is to register
    providers at the root level when the application is being bootstrapped, so the
    same instance of the service will be available throughout the application component
    tree.
  prefs: []
  type: TYPE_NORMAL
- en: Angular 2 Routing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our last topic before we set out to implement our application would be navigation
    and routing. Using web applications, users expect a certain type of URL routing.
    For this purpose, the Angular team created a module called the component router.
    The component router interprets the browser URL and then looks up in its definition
    to find and load a component view. Supporting the modern browser's history API,
    the router will respond to any URL change whether it's coming from the browser
    URL bar or a user interaction. So let's see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the Angular 2 team is focused on the modular approach, you'll need to
    load the router file separately—either from a local file or using a CDN. Furthermore,
    you'll also have to set up the `<base href="/">` tag inside the head section of
    your main HTML file. But don't worry about it for now. We'll take care of these
    changes in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Routes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every application will have one router, so when a URL navigation occurs, the
    router will look for the routing configuration made inside the application in
    order to determine which component to load. In order to configure the application
    routing, Angular provides a special array class called `Routes`, which includes
    a list mapping between URLs and components. An example for this mechanism is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Router outlet
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The component router uses a hierarchical component structure which means that
    every component decorated and loaded by the component router can have child paths
    configured. So, the root component is loaded, and it renders its view in the main
    application tag; however, when child components are loaded, how and where are
    they going to be rendered? To solve this, the router module includes a directive
    called `RouterOutlet`. To render your child components, all you have to do is
    include the `RouterOutlet` directive inside your parent component''s template.
    An example component is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `router-outlet` tag will be replaced with your child component's
    view.
  prefs: []
  type: TYPE_NORMAL
- en: Router links
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After we configure our application routes, we''ll be able to navigate through
    our application either by changing the browser URL or using the `RouterLink` directive
    to generate anchor tags pointing to a link inside our app. The `RouterLink` directive
    uses an array of link parameters, which the router will later resolve into a URL
    matching a component mapping. An example anchor with the `RouterLink` directive
    will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we've progressed in this chapter, we've learned about TypeScript and Angular
    2\. We've now covered everything we need in order create an Angular application
    inside our MEAN application. So let's start by setting up our project.
  prefs: []
  type: TYPE_NORMAL
- en: The project setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to use Angular in our project, we'll need to install both TypeScript
    and Angular. We'll need to use the TypeScript transpiler to convert our TypeScript
    files into valid ES5 or ES6 JavaScript files. Furthermore, since Angular is a
    frontend framework, installing it requires the inclusion of JavaScript files in
    the main page of your application. This can be done in various ways, and the easiest
    one would be to download the files you need and store them in the `public` folder.
    Another approach is to use Angular's CDN and load the files directly from the
    CDN server. While these two approaches are simple and easy to understand, they
    both have a strong flaw. Loading a single third-party JavaScript file is readable
    and direct, but what happens when you start adding more vendor libraries to your
    project? More importantly, how can you manage your dependencies' versions?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer to all of these questions is NPM! NPM will allow us to install all
    of our dependencies and run the TypeScript transpiler while we develop our application.
    In order to do that, you''ll need to change your `package.json` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In our new `package.json` file, we did a few things; first, we added our project''s
    Angular dependencies, including a few supportive libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CoreJS**: This will provide us with some ES6 polyfills'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ReflectMetadata**: This will provide us with some a metadata reflection polyfill'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rx.JS**: This is a Reactive framework that we''ll use later'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SystemJS**: This will help with loading our application modules'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zone.js**: This allows the creation of different execution context zones
    and is used by the Angular library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concurrently**: This will allow us to run both the TypeScript transplier
    and our server concurrently'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Typings**: This will help us with downloading predefined TypeScript definitions
    for our external libraries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the top, we added a scripts property, where we defined different scripts
    we would like npm to run for us. For instance, we have a script that installs
    our typings for third-party libraries, another one that runs the TypeScript compiler
    called `tsc`, a script called `app` that we use to run our node server, and one
    called `start` to run both of these scripts together using the concurrency tool.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we're going to configure the way we want the TypeScript compiler to run.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring TypeScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to configure the way TypeScript works, we''ll need to add a new file
    called `tsconfig.json` to our application''s root folder. In your new file, paste
    the following JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `tsconfig.json` file, we configured the TypeScript compiler to:'
  prefs: []
  type: TYPE_NORMAL
- en: Compile our TypeScript code into ES5 code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compile our modules into a system module pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Node for module resolution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate source maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Include decorators and emit their metadata
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep comments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cancel the error for any implicit declarations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not include the `node_modules` folder and typings files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we run our application, the TypeScript will use the `tsconfig.json` configuration
    file by default. Next, you''ll need to add a new file called `typings.json` to
    your application''s root folder. In your new file, paste the following JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we''ve added all third-party libraries we need in order for
    the TypeScript transpiler to compile our code properly. Once you''re done, go
    ahead and install your new dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: All the packages we need will be installed along with external type definitions
    we'll need in order to support the TypeScript compiling. Now that we have installed
    our new packages and configured our TypeScript implementation, it is time to set
    up Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is recommended that you continue reading about Typings at the official documentation
    at [https://github.com/typings/typings](https://github.com/typings/typings).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Express
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start using Angular, you will need to include the new JavaScript library
    files in our main EJS view. So, we will use the `app/views/index.ejs` file as
    the main application page. However, NPM installed all of our dependencies in the
    `node_module` folder, which is not accessible to our client side. To solve this
    issue, we''ll have to change our `config/express.js` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'A major change here involves the creation of a `/lib` static route that directs
    to our `node_modules` folder. While we were here, we also switched the order of
    the routes users and index routes. This will come in handy when we start dealing
    with Angular''s routing mechanism. In this regard, there is one more thing we
    have to do, and that is making sure our Express application always return the
    main application view when receiving routes that are not defined. This is for
    the case where the browser''s initial request is made using a URL that was generated
    by the Angular Router and is not supported by our Express configuration. To do
    this, go back to the `app/routes/index.server.routes.js` file, and change it as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now, that we have configured TypeScript and Express, it is time to set up Angular,
    but before we do that, let's talk a bit about our application structure.
  prefs: []
  type: TYPE_NORMAL
- en: Restructuring the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you might remember from [Chapter 3](ch03.html "Chapter 3. Building an Express
    Web Application"), *Building an Express Web Application*, your application's structure
    depends on the complexity of your application. We previously decided to use the
    horizontal approach for the entire MEAN application; however, as we stated earlier,
    MEAN applications can be constructed in various ways, and an Angular application
    structure is a different topic, which is often discussed by the community and
    the Angular development team. There are many doctrines for different purposes,
    some of which are a bit more complicated, while others offer a simpler approach.
    In this section, we'll introduce a recommended structure. With the move from Angular
    1 to Angular 2, this discussion is now even more complicated. For us, the easiest
    approach would be to start by using the `public` folder of our Express application
    as the root folder for the Angular application so that every file is available
    statically.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several options to structure your application according to its complexity.
    A simple application can have a horizontal structure where entities are arranged
    in folders according to their type, and a main application file is placed at the
    root folder of the application. An example application structure of this kind
    can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Restructuring the application](img/B05071_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, this is a very comfortable solution for small applications
    with a few entities. However, your application might be more complex with several
    different features and many more entities. This structure cannot handle an application
    of this sort since it obfuscates the behavior of each application file, will have
    a bloated folder with too many files, and will generally be very difficult to
    maintain. For this purpose, there is a different approach to organizing your files
    in a vertical manner. A vertical structure positions every file according to its
    functional context, so different types of entities can be sorted together according
    to their role in a feature or a section. This is similar to the vertical approach
    we introduced in [Chapter 3](ch03.html "Chapter 3. Building an Express Web Application"),
    *Building an Express Web Application*. However, the difference is that only Angular''s
    logical units will have a standalone module folder structure, usually with a component
    and a template files. An example of an Angular application vertical structure
    can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Restructuring the application](img/B05071_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, each module has its own folder structure, which allows you to
    encapsulate each component. We're also using the file naming convention that we
    introduced in [Chapter 3](ch03.html "Chapter 3. Building an Express Web Application"),
    *Building an Express Web Application*.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know the basic best practices of naming and structuring your application,
    let's continue and create the application module.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the application module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin, clear the contents of the `public` folder and create the folder named
    `app` inside it. Inside your new folder, create a file named `app.module.ts`.
    In your file, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we basically just created a simple module that declares the
    application component and uses it for bootstrapping. Next we'll need to create
    the application component.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the application component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inside your `public/app` folder, create a new file named `app.component.ts`.
    In your file, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we basically just created the simplest component. Next we'll
    learn how to bootstrap our `AppModule` class.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping the application module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To bootstrap your application module, go to your `app` folder and create a
    new file named `bootstrap.ts`. In your file, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Basically, this code is using the browser platform module to bootstrap the application
    module for browsers. Once we have these configured, it's time to learn how to
    load our bootstrap code using the SystemJS module loader.
  prefs: []
  type: TYPE_NORMAL
- en: Starting your Angular application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use SystemJS as our module loader, we''ll create a new file named `systemjs.config.js`
    inside our `public` folder. In your new file, paste the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In this file, we''re telling SystemJS about our application package and from
    where to load the Angular and Rx modules. We then describe the main file for each
    package of Angular; in this case, we ask it to load the UMD file of each package.
    We then use the `System.config` method to configure SystemJS. Finally, we revisit
    our `app/views/index.ejs` file and change it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we're loading our module files directly from the `node_modules`
    package folder and include our SystemJS configuration file. The last script tells
    SystemJS to load the application package we defined in the configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn more about SystemJS, it is recommended that you visit the official
    documentation at [https://github.com/systemjs/systemjs](https://github.com/systemjs/systemjs).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all you have left to do is run your application by invoking the following
    command in your command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: When your application is running, use your browser and open your application
    URL at `http://localhost:3000`. You should see a header tag saying `Hello World`
    being rendered. Congratulations! You've created your first Angular 2 module and
    component and successfully bootstrapped your application. Next, we'll refactor
    the authentication part of our application and create a new authentication module.
  prefs: []
  type: TYPE_NORMAL
- en: Managing authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing an Angular application authentication is a complex issue. The problem
    is that while the server holds the information about the authenticated user, the
    Angular application is not aware of that information. One solution is to use a
    service and ask the server about the authentication status; however, this solution
    is flawed since all the Angular components will have to wait for the response
    to return, causing inconsistencies and development overhead. This can be solved
    using an advanced Angular router object; however, a simpler solution would be
    to make the Express application render the `user` object directly in the EJS view
    and then use an Angular service to serve the object.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering the user object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To render the authenticated `user` object, you''ll have to make several changes.
    Let''s begin by changing the `app/controllers/index.server.controller.js` file,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, go to your `app/views/index.ejs` file and make the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This will render the user object as a JSON representation right in your main
    view application. When the Angular application bootstraps, the authentication
    state will already be available. If the user is authenticated, the `user` object
    will become available; otherwise, the `user` object will be Null.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the users' server controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To support our authentication refactoring, we''ll need to make sure our user''s
    server controller is able to process the Angular service requests. To do that,
    you''ll need to change the code in your `app/controllers/users.server.controller.js`
    file to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We basically just encapsulated the authentication logic inside two methods
    that can accept and respond with a JSON object. Now let''s go ahead and change
    the `app/routes/users.server.routes.js` directory as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note how we removed the routes that we used to render our authentication views.
    More importantly, look at the way in which we added an `/api` prefix for all the
    routes. It is a very good practice to keep all your routes under one prefix, since
    we want the Angular router to be able to have routes that do not interfere with
    our server routes. Now that we have our server side ready, it's time to create
    our Angular authentication module.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the authentication module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we''re done with laying the ground for our Angular application, we
    can move forward and refactor our authentication logic into a cohesive authentication
    module. To do that, we''ll begin by creating a new folder inside our `public/app`
    folder, called `authentication`. In our new folder, create a file named `authentication.module.ts`
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Our module consists of three components:'
  prefs: []
  type: TYPE_NORMAL
- en: An authentication component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A signup component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A signin component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also included an authentication routing configuration and the Angular's Forms
    module to support our signin and signup forms. Let's begin by implementing the
    base authentication component.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the authentication component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ll begin by creating our authentication component hierarchy. Then, we will
    convert our server signin and signup views into Angular templates, add the authentication
    functionality to `AuthenticationService`, and refactor our server logic. Let''s
    start by creating a file named `authentication.component.ts` inside our `public/app/authentication`
    folder. In the new file, paste the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we implement our new authentication component. We begin by importing
    the authentication service and a signup and signin component, all of which we
    haven't created yet. Another thing to notice is that this time, we used an external
    template file for our component. We'll continue by creating a routing configuration
    for our authentication module.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the authentication routes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To do that, create a new file named `authentication.routes.ts` inside our `public/app/authentication`
    folder. In the new file, paste the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we create a new `Routes` instance with a parent route of `authentication`
    and two child routes for the `signin` and `signup` components. We''ll continue
    by creating the template file named `authentication.template.html` inside our
    component''s folder. In the new file, paste the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note how we used the `RouterOutlet` directive inside our code. This is where
    our subcomponents will be rendered. We'll continue with creating these subcomponents.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the signin component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To implement the `signin` component, create a new folder named `signin` inside
    your `public/app/authentication` folder. Inside your new folder, create a new
    file named `signin.component.ts` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how our `signin` component uses the authentication service in order to
    perform a `signin` action. Don''t worry; we''ll implement this in the next section.
    Next, you''ll need to create a file named `signin.template.html` in the same folder
    as your component. In your new file, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We've just created a new component to handle our authentication signin operation!
    The signup component will look quite similar.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the signup component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To implement the signup component, create a new folder named `signup` inside
    your `public/app/authentication` folder. Inside your new folder, create a new
    file named `signup.component.ts` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how our signup component uses the authentication service in order to perform
    a `signup` action. Next, you''ll need to create a file named `signup.template.html`
    in the same folder as your component. In your new file, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our authentication components in place, let's go back and handle
    the authentication service.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the authentication service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to support our new components, we would need to create an authentication
    service to provide them with the needed functionality. To do that, create a new
    file named `authentication.service.ts` inside your `public/app/authentication`
    folder. In your new file, paste the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Note how we decorated the `AuthenticationService` class with an `@Injectable`
    decorator. While that's not needed in this case, it is a good practice to decorate
    your services that way. The reason is that if you'd like to inject a service with
    another service, you'll need to use this decorator, so for the sake of uniformity,
    it is better to stay safe and decorate all your services. Another thing to note
    is the way we get our user object from the window object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also added three methods to our service: one that handles signin, another
    that handles signup, and a last one for error handling. Inside our methods, we
    use the HTTP module provided by Angular to call our server endpoints. In the next
    chapter, we''ll elaborate further on this module, but in the meantime, all you
    need to know is that we just used it to send POST a request to our server. To
    finish up the Angular part, our application will need to modify our application
    module and add a simple home component.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the home module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To extend our simple example, we''ll need to have a home component that will
    provide the view for our base root and will present different information for
    the logged-in and logged-out users. To do that, create a folder named `home` inside
    your `public/app` folder. Then, create a file inside this folder called `home.module.ts`,
    which contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: As you may have probably noticed, our module is only importing a new home component
    and the routing configuration. Let's continue by creating our home component.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the home component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we''ll create our home component. To do that, go to your `public/app/home`
    folder and create a new file called `home.component.ts` containing the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this is just a simple component, which has the authentication
    service injected and which is used to provide the component with the user object.
    Next, we''ll need to create our home component template. To do that, go to your
    `public/app/home` folder and create a file named `home.template.html` with the
    following code inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This template's code nicely demonstrates a few of the topics we previously discussed.
    Note the use of the `ngIf` and `routerLink` directives we talked about earlier
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the home routes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To finish with our module, we''ll need to create a routing configuration for
    our home component. To do that, create a new file named `home.routes.ts` inside
    your `public/app/home` folder. In your new file, paste the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is just a simple component routing. To complete our implementation,
    we'll need to modify our application module a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the application module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To include our authentication and home component modules, we''ll need to change
    our `app.module.ts` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is quite a big change to our application module. First,
    we imported the HTTP module and our new home and authentication modules along
    with our new Application routing configuration. We injected the authentication
    service in the `providers` property so that it is available for all of our submodules.
    The last thing we have to do is implement our application routing configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the application routes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To configure our application routes, we''ll need to create a new file named
    `app.routes.ts` inside the `public/app` folder. In the new file, paste the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, our application consists of a very simple, single configuration,
    which redirects any unknown routing requests to our home component.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is it. Your application is ready for use! All you need to do is to run
    it by invoking the following command in your command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: When your application is running, use your browser and open your application
    URL at `http://localhost:3000`. You should see two links for signing up and signing
    in. Use them and see what happens. Try to refresh your application and see how
    it keeps its state and route.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the basic principles of TypeScript. You went
    through Angular's building blocks and learned how they fit in the architecture
    of an Angular 2 application. You also learned how to use NPM to install frontend
    libraries and how to structure and bootstrap your application. You discovered
    Angular's entities and how they work together. You also used Angular's Router
    to configure your application routing scheme. Near the end of this chapter, we
    made use of all of this in order to refactor our authentication module. In the
    next chapter, you'll connect everything you learned so far to create your first
    MEAN CRUD module.
  prefs: []
  type: TYPE_NORMAL
