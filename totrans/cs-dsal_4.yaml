- en: Dictionaries and Sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The current chapter will focus on data structures related to dictionaries and
    sets. A proper application of these data structures makes it possible to map keys
    to values and perform fast lookup, as well as make various operations on sets.
    To simplify the understanding of dictionaries and sets, this chapter will contain
    illustrations and code snippets.
  prefs: []
  type: TYPE_NORMAL
- en: In the first parts of this chapter, you will learn both non-generic and generic
    versions of a dictionary, that is, a collection of pairs, each consisting of a
    key and a value. Then, a sorted variant of a dictionary will be presented, as
    well. You will also see some similarities between dictionaries and lists.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining part of the chapter will show you how to use hash sets, together
    with the variant, which is named a "sorted" set. Is it possible to have a "sorted"
    set? You will get to know how to understand this topic while reading the last
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, the following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Hash tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorted dictionaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"Sorted" sets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with the first data structure, which is a **hash table**, also
    known as a **hash map**. It allows **mapping** keys to particular values, as shown
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e874bb03-d53d-432d-a1b6-cfb25bae7204.png)'
  prefs: []
  type: TYPE_IMG
- en: One of the most important assumptions of the hash table is the possibility of
    very fast lookup for a **Value** based on the **Key**, which should be the *O(1)*
    operation. To achieve this goal, the **Hash function** is used. It takes the **Key**
    to generate an index of a bucket, where the **Value** can be found.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, if you need to find a value of the key, you do not need to
    iterate through all items in the collection, because you can just use the hash
    function to easily locate a proper bucket and get the value. Due to the great
    performance of the hash table, such a data structure is frequently used in many
    real-world applications, such as for associative arrays, database indices, or
    cache systems.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the role of the hash function is critical and ideally it should
    generate a unique result for all keys. However, it is possible that the same result
    is generated for different keys. Such a situation is called a **hash collision**
    and should be dealt with.
  prefs: []
  type: TYPE_NORMAL
- en: The topic of hash table implementation from scratch seems to be quite difficult,
    especially when it comes to using the hash function, handling hash collisions,
    as well as assigning particular keys to buckets. Fortunately, a suitable implementation
    is available while developing applications in the C# language, and its usage is
    very simple.
  prefs: []
  type: TYPE_NORMAL
- en: There are two variants of the hash table-related classes, namely non-generic
    (`Hashtable`) and generic (`Dictionary`). The first is described in this section,
    while the other is described in the following section. If you can use the strongly-typed
    generic version, I strongly recommend using it.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the `Hashtable` class from the `System.Collections` namespace.
    As already mentioned, it stores a collection of pairs, where each contains a key
    and a value. A pair is represented by the `DictionaryEntry` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily get access to a particular element using the indexer. As the
    `Hashtable` class is a non-generic variant of hash table-related classes, you
    need to cast the returned result to the proper type (for example, `string`), as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In a similar way, you can set the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It is worth mentioning that the `null` value is incorrect for a `key` of an
    element, but it is acceptable for `value` of an element.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the indexer, the class is equipped with a few properties, which makes
    it possible to get the number of stored elements (`Count`), as well as return
    the collection of keys or values (`Keys` and `Values`, respectively). Moreover,
    you can use some available methods, such as to add a new element (`Add`), to remove
    an element (`Remove`), to remove all elements (`Clear`), as well as to check whether
    the collection contains a particular key (`Contains` and `ContainsKey`) or a given
    value (`ContainsValue`).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to get all entries from the hash table, you can use the `foreach`
    loop to iterate through all pairs stored in the collection, as presented here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The variable used in the loop has the `DictionaryEntry` type. Therefore, you
    need to use its `Key` and `Value` properties to access the key and the value,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about the `Hashtable` class at [https://msdn.microsoft.com/library/system.collections.hashtable.aspx](https://msdn.microsoft.com/library/system.collections.hashtable.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: After this short introduction, it is now time to take a look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: Example – phone book
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As an example, you will create an application for a phone book. The `Hashtable`
    class will be used to store entries where the person name is a key and the phone
    number is a value, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b596dbfa-5ace-48a2-be5f-68657c98bb64.png)'
  prefs: []
  type: TYPE_IMG
- en: The program will demonstrate how to add elements to the collection, check the
    number of stored items, iterate through all of them, check whether an element
    with a given key exists, as well as how to get a value based on the key.
  prefs: []
  type: TYPE_NORMAL
- en: 'The whole code presented here should be placed in the body of the `Main` method
    in the `Program` class. At the beginning, let''s create a new instance of the
    `Hashtable` class, as well as initialize it with some entries, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can add elements to the collection in various ways, such as while creating
    a new instance of the class (phone numbers for `Marcin Jamro` and `John Smith`
    in the preceding example), by using the indexer (`Lily Smith`), and using the
    `Add` method (`Mary Fox`), as shown in the following part of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the call of the `Add` method is placed within the `try-catch`
    statement. Why? The answer is very simple—you cannot add more than one element
    with the same key, and in such a scenario, `ArgumentException` is thrown. To prevent
    the application from crashing, the `try-catch` statement is used and a proper
    message is shown in the console to inform the user about the situation.
  prefs: []
  type: TYPE_NORMAL
- en: When you use the indexer to set a value for a particular key, it will not throw
    any exception when there is already an item with the given key. In such a situation,
    a value of this element will be updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following part of the code, you iterate through all pairs from the collection
    and present the results in the console. When there are no items, the additional
    information will be presented to the user, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can check whether there are no elements in the collection using the `Count`
    property and comparing its value with `0`. The way of iterating through all pairs
    is simplified by the availability of the `foreach` loop. However, you need to
    remember that a single pair from the `Hashtable` class is represented by the `DictionaryEntry`
    instance and you can access its key and value using the `Key` and `Value` properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end, let''s see how to check whether a specific key exists in the collection,
    as well as how to get its value. The first task can be accomplished just by calling
    the `Contains` method, which returns a value indicating whether a suitable element
    exists (`true`) or not (`false`). The other job (getting a value), uses the indexer
    and is required to cast the returned value to a suitable type (`string` in this
    example). This requirement is caused by the non-generic version of the hash table-related
    class. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Your first program using the hash table is ready! After launching it, you will
    receive a result similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It is worth noting that the order of pairs stored using the `Hashtable` class
    is not consistent with the order of their addition or keys. For this reason, if
    you need to present the sorted results, you need to sort the elements on your
    own or use another data structure, namely `SortedDictionary`, which is described
    later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: However, for now, let's take a look at one of the most common classes used while
    developing in C#, namely `Dictionary`, which is a generic version of hash table-related
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, you got to know the `Hashtable` class as a non-generic
    variant of the hash table-related classes. However, it has a significant limitation,
    because it does not allow you to specify a type of a key and a value. Both the `Key`
    and `Value` properties of the `DictionaryEntry` class are of the `object` type.
    Therefore, you need to perform boxing and unboxing operations, even if all keys
    and values have the same type.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to benefit from the strongly typed variant, you can use the `Dictionary`
    generic class, which is the main subject of this section of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, you should specify two types namely, a type of a key and a value,
    while creating an instance of the `Dictionary` class. Moreover, it is possible
    to define initial content of the dictionary using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, a new instance of the `Dictionary` class is created.
    It stores `string`-based keys and values. By default, two entries exist in the
    dictionary, namely the keys `Key 1` and `Key 2`. Their values are `Value 1` and
    `Value 2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the `Hashtable` class, here you can also use the indexer to get
    access to a particular element within the collection, as shown in the following
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It is worth noting that casting to the `string` type is unnecessary, because
    `Dictionary` is the strongly typed version of the hash table-related classes.
    Therefore, the returned value already has the proper type.
  prefs: []
  type: TYPE_NORMAL
- en: 'If an element with the given key does not exist in the collection, `KeyNotFoundException`
    is thrown. To avoid problems, you can do one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Place the line of code in the `try-catch` block
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check whether the element exists (by calling `ContainsKey`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `TryGetValue` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can add a new element or update a value of the existing one using the indexer,
    as shown in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the non-generic variant, the `key` cannot be equal to `null`, but
    a `value` can be, of course, if it is allowed by the type of values stored in
    the collection. Moreover, the performance of getting a value of an element, adding
    a new element, or updating an existing one, is approaching the *O(1)* operation.
  prefs: []
  type: TYPE_NORMAL
- en: The `Dictionary` class is equipped with a few properties, which makes it possible
    to get the number of stored elements (`Count`), as well as return the collection
    of keys or values (`Keys` and `Values`, respectively). Moreover, you can use the
    available methods, such as for adding a new element (`Add`), removing an item
    (`Remove`), removing all elements (`Clear`), as well as checking whether the collection
    contains a particular key (`ContainsKey`) or a given value (`ContainsValue`).
    You can also use the `TryGetValue` method to try to get a value for a given key
    and return it (if the element exists) or return `null` (otherwise).
  prefs: []
  type: TYPE_NORMAL
- en: While scenarios of returning a value by a given key (using an indexer or `TryGetValue`)
    and checking whether the given key exists (`ContainsKey`) are approaching the
    *O(1)* operation, the process of checking whether the collection contains a given
    value (`ContainsValue`) is the *O(n)* operation and requires you to search the
    entire collection for the particular value.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to iterate through all pairs stored in the collection, you can
    use the `foreach` loop. However, the variable used in the loop is an instance
    of the `KeyValuePair` generic class with `Key` and `Value` properties, allowing
    you to access the key and the value. The `foreach` loop is shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Do you remember the thread-safe versions of some classes from the previous chapter?
    If so, the situation looks quite similar in the case of the `Dictionary` class,
    because the `ConcurrentDictionary` class (from the `System.Collections.Concurrent`
    namespace) is available. It is equipped with a set of methods, such as `TryAdd`,
    `TryUpdate`, `AddOrUpdate`, and `GetOrAdd`.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about the `Dictionary` generic class at [https://msdn.microsoft.com/library/xfhwa508.aspx](https://msdn.microsoft.com/library/xfhwa508.aspx),
    while details of the thread-safe alternative, namely `ConcurrentDictionary`, are
    shown at [https://msdn.microsoft.com/library/dd287191.aspx](https://msdn.microsoft.com/library/dd287191.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: Let's start coding! In the following sections, you will find two examples presenting
    dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: Example – product location
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first example is the application that helps employees of a shop to find
    the location of where a product should be placed. Let's imagine that each employee
    has a phone with your application, which is used to scan the code of the product
    and the application tells them that the product should be located in area **A1**
    or **C9**. Sounds interesting, doesn't it?
  prefs: []
  type: TYPE_NORMAL
- en: 'As the number of products in the shop is often very high, it is necessary to
    find results quickly. For this reason, the data of products together with their
    locations will be stored in the hash table, using the generic `Dictionary` class.
    The key will be the barcode, while the value will be the area code, as shown in
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/47f0b01a-098f-4b52-b227-d3d1daf4b0ce.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a look at the code, which should be added to the `Main` method
    in the `Program` class. At the beginning, you need to create a new collection,
    as well as add some data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The code shows two ways of adding elements to the collection, namely by passing
    their data while creating a new instance of the class and by using the indexer.
    A third solution also exists and uses the `Add` method, as shown in the following
    part of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned in the case of the `Hashtable` class, `ArgumentException` is thrown
    if you want to add the element with the same key as the one already existing in
    the collection. You can prevent the application from crashing by using the `try-catch`
    block.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following part of the code, you present the data of all products available
    in the system. To do so, you use the `foreach` loop, but before that you check
    whether there are any elements in the dictionary. If not, the proper message is
    presented to the user. Otherwise, keys and values from all pairs are presented
    in the console. It is worth mentioning that a type of the variable within the
    `foreach` loop is `KeyValuePair<string, string>`, thus its `Key` and `Value` properties
    are of the `string` type, not `object`, as in the case of the non-generic variant.
    The code is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end, let''s take a look at the part of the code that makes it possible
    to find a location for the product by its barcode. To do so, you use `TryGetValue`
    to check whether the element exists. If so, a message with the target location
    is presented in the console. Otherwise, other information is shown. What is important
    is that the `TryGetValue` method uses the `out` parameter to return the found
    value of the element. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the program, you will see the list of all products in the shop
    and the program will ask you to enter the barcode. After typing it, you will receive
    the message with the area code. The result shown in the console will be similar
    to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You have just completed the first example! Let's proceed to the next one.
  prefs: []
  type: TYPE_NORMAL
- en: Example – user details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second example will show you how to store more complex data in the dictionary.
    In this scenario, you will create an application that shows details of a user
    based on him or her identifier, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12009a61-2e0f-4ab3-9a8a-de5495759aff.png)'
  prefs: []
  type: TYPE_IMG
- en: The program should start with the data of three users. You should be able to
    enter the identifier and see details of the found user. Of course, the situation
    of non-existence of a given user should be handled by presenting the proper information
    in the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the beginning, let''s add the `Employee` class that just stores the data
    of an employee, namely first name, last name, and phone number. The code is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The next modifications will be performed in the `Main` method in the `Program`
    class. Here, you create a new instance of the `Dictionary` class and add the data
    of three employees, using the `Add` method, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The most interesting operations are performed in the following `do-while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: First, the user is asked to enter the identifier of the employee, which is then
    parsed to the integer value. If this operation is completed successfully, the
    `TryGetValue` method is used to try to get details of the user. If the user is
    found, that is, `TryGetValue` returns `true`, the details are presented in the
    console. Otherwise, `"The employee with the given identifier does not exist."` message
    is shown. The loop is executed until the provided identifier cannot be parsed
    to the integer value.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the application and enter some data, you will receive the following
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: That's all! You have just completed two examples showing how to use dictionaries
    while developing applications in the C# language.
  prefs: []
  type: TYPE_NORMAL
- en: However, another kind of dictionary has been mentioned in the section regarding
    the `Hashtable` class, namely a sorted dictionary. Are you interested in finding
    out what it does and how you can use it in your programs? If so, let's proceed
    to the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Sorted dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both non-generic and generic variants of the hash table-related classes do not
    keep the order of the elements. For this reason, if you need to present data from
    the collection sorted by keys, you need to sort them prior to presentation. However,
    you can use another data structure, the **sorted dictionary,** to solve this problem
    and keep keys sorted all the time. Therefore, you can easily get the sorted collection
    whenever necessary.
  prefs: []
  type: TYPE_NORMAL
- en: The sorted dictionary is implemented as the `SortedDictionary` generic class,
    available in the `System.Collections.Generic` namespace. You can specify types
    for keys and values while creating a new instance of the `SortedDictionary` class.
    Moreover, the class contains similar properties and methods to `Dictionary`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, you can use the indexer to get access to a particular element
    within the collection, as shown in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You should ensure that the element exists in the collection. Otherwise, `KeyNotFoundException`
    is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add a new element or update a value of the existing one, as shown in
    the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the `Dictionary` class, a key cannot be equal to `null`, but value can
    be, of course, if it is allowed by the type of values stored in the collection.
  prefs: []
  type: TYPE_NORMAL
- en: The class is equipped with a few properties, which makes it possible to get
    the number of stored elements (`Count`), as well as return the collection of keys
    and values (`Keys` and `Values`, respectively). Moreover, you can use the available
    methods, such as for adding a new element (`Add`), removing an item (`Remove`),
    removing all elements (`Clear`), as well as checking whether the collection contains
    a particular key (`ContainsKey`) or a given value (`ContainsValue`). You can use
    the `TryGetValue` method to try to get a value for a given key and return it (if
    the element exists) or return `null` (otherwise).
  prefs: []
  type: TYPE_NORMAL
- en: If you want to iterate through all pairs stored in the collection, you can use
    the `foreach` loop. The variable used in the loop is an instance of the `KeyValuePair`
    generic class with `Key` and `Value` properties, allowing you to access the key
    and the value.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the automatic sorting advantages, the `SortedDictionary` class has some
    performance drawbacks in comparison with `Dictionary`, because retrieval, insertion,
    and removal are the *O(log n)* operations, where *n* is the number of elements
    in the collection, instead of *O(1)*. Moreover, `SortedDictionary` is quite similar
    to `SortedList`, described in [Chapter 2](f285d687-6495-4d5e-a2b0-6f0b4af46096.xhtml),
    *Arrays and Lists*. However, it differs in memory-related and performance-related
    results. The retrieval for both these classes is the *O(log n)* operation, but
    insertion and removal for unsorted data is *O(log n)* for `SortedDictionary` and
    *O(n)* for `SortedList`. Of course, more memory is necessary for `SortedDictionary`
    than for `SortedList`. As you can see, choosing a proper data structure is not
    an easy task and you should think carefully about the scenarios in which particular
    data structures will be used and take into account the both pros and cons.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about the `SortedDictionary` generic class at
    [https://msdn.microsoft.com/library/f7fta44c.aspx](https://msdn.microsoft.com/library/f7fta44c.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: Let's see the sorted dictionary in action by creating an example.
  prefs: []
  type: TYPE_NORMAL
- en: Example – definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As an example, you will create a simple encyclopedia, where you can add entries,
    as well as show its full content. The encyclopedia can contain millions of entries,
    so it is crucial to provide its users with the possibility of browsing entries
    in the correct order, alphabetically by keys, as well as finding entries quickly.
    For this reason, the sorted dictionary is a good choice in this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea of the encyclopedia is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9915bf6c-68cd-49a8-8a8b-98078a4c5462.png)'
  prefs: []
  type: TYPE_IMG
- en: When the program is launched, it presents a simple menu with two options, namely
    `[a] - add` and `[l] - list`. After pressing the *A* key, the application asks
    you to enter the name and explanation for the entry. If the provided data are
    correct, a new entry is added to the encyclopedia. If the user presses the *L* key,
    the data of all entries, sorted by keys, are presented in the console. When any
    other key is pressed, the additional confirmation is shown and, if confirmed,
    the program exits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the code, which should be placed as the body of the `Main`
    method in the `Program` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: At the beginning, a new instance of the `SortedDictionary` class is created,
    which represents a collection of pairs with `string`-based keys and `string`-based
    values. Then, the infinite `do-while` loop is used. Within it, the program waits
    until the user presses any key. If it is the *A* key, a name and explanation for
    the entry are obtained from the values entered by the user. Then, a new entry
    is added to the dictionary using the indexer. Thus, if the entry with the same
    key already exists, it will be updated. In the case of pressing the *L* key, the
    `foreach` loop is used to show all entered entries. When any other key is pressed,
    another question is presented to the user and the program waits for confirmation.
    If the user presses *Y*, you break out of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the program, you can enter a few entries, as well as present them.
    The result from the console is shown in the following block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: So far, you have learned three dictionary-related classes, namely `Hashtable`,
    `Dictionary`, and `SortedDictionary`. All of them have some specific advantages
    and they can be used in various scenarios. To make understanding them easier,
    a few examples have been presented, together with a detailed explanation.
  prefs: []
  type: TYPE_NORMAL
- en: However, do you know that there are also some other data structures that store
    just keys, without values? Do you want to learn more about them? If so, let's
    proceed to the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Hash sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some algorithms, it is necessary to perform operations on sets with various
    data. However, what is a **set**? A set is a collection of distinct objects without
    duplicated elements and without a particular order. Therefore, you can only get
    to know whether a given element is in the set or not. The sets are strictly connected
    with the mathematical models and operations, such as union, intersection, subtraction,
    and symmetric difference.
  prefs: []
  type: TYPE_NORMAL
- en: A set can store various data, such as integer or string values, as shown in
    the following diagram. Of course, you can also create a set with instances of
    a user-defined class, as well as add and remove elements from the set at any time.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/711ea288-1b69-41e1-bc10-ce9441ca8978.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Before seeing sets in action, it is a good idea to remind you of some basic
    operations that can be performed on two sets, named **A** and **B**. Let''s start
    with the union and intersection, as shown in the following illustration. As you
    can see, the **union** (shown on the left as **A∪B**) is a set with all elements
    that belong to **A** or **B**. The **intersection** (presented on the right as
    **A∩B**) contains only the elements that belong to both **A** and **B**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5053aab-bdec-4534-a3a4-65677880f858.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Another common operation is the **set subtraction**. The result set of **A
    \ B** contains elements which are the members of **A** and not the members of
    **B**. In the following illustration, two examples are presented, namely **A \
    B** and **B \ A**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7c8d365f-f84c-4d1c-abaf-abe4805fad0e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'While performing operations on sets, it is also worth mentioning the **symmetric
    difference**, which is presented on the left-hand side of the following illustration,
    as **A ∆ B**. The final set can be interpreted as a union of two sets, namely
    (**A \ B**) and (**B \ A**). Therefore, it contains elements that belong to only
    one set, either **A** or **B**. The elements that belong to both sets are excluded
    from the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba83077a-cb31-42c0-bc5b-2df29ff3445e.png)'
  prefs: []
  type: TYPE_IMG
- en: Another important topic is the **relationship** between sets. If every element
    of **B** belongs also to **A**, it means that **B** is a **subset** of **A**,
    as shown in the preceding diagram, on the right. At the same time, **A** is a
    **superset** of **B**. Moreover, if **B** is a subset of **A**, but **B** is not
    equal to **A**, **B** is a **proper subset** of **A**, and **A** is a **proper
    superset** of **B**.
  prefs: []
  type: TYPE_NORMAL
- en: While developing applications in the C# language, you can benefit from high-performance
    operations provided by the `HashSet` class from the `System.Collections.Generic`
    namespace. The class contains a few properties, including `Count` that returns
    the number of elements in the set. Moreover, you can use many methods to perform
    operations of sets, as explained next.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first group of methods makes it possible to modify the current set (on
    which the method is called) to create the following, with the set passed as the
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: The union (`UnionWith`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The intersection (`IntersectWith`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The subtraction (`ExceptWith`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The symmetric difference (`SymmetricExceptWith`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also check the relationships between two sets, such as checking whether
    the current set (on which the method is called) is:'
  prefs: []
  type: TYPE_NORMAL
- en: A subset (`IsSubsetOf`) of the set passed as the parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A superset (`IsSupersetOf`) of the set passed as the parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A proper subset (`IsProperSubsetOf`) of the set passed as the parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A proper superset (`IsProperSupersetOf`) of the set passed as the parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Furthermore, you can verify whether two sets contain the same elements (`SetEquals`)
    or whether two sets have at least one common element (`Overlaps`).
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the mentioned operations, you can add a new element to the set (`Add`),
    remove a particular element (`Remove`), or remove all elements (`Clear`), as well
    as check whether the given element exists in the set (`Contains`).
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about the `HashSet` generic class at [https://msdn.microsoft.com/library/bb359438.aspx](https://msdn.microsoft.com/library/bb359438.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: After this introduction, it is a good idea to try to put the learned information
    into practice. Thus, let's proceed to two examples that will show you how you
    can apply hash sets in your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Example – coupons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first example represents the system that checks whether a one-time coupon
    has already been used. If so, a suitable message should be presented to the user.
    Otherwise, the system should inform the user that the coupon is valid and it should
    be marked as used and cannot be used again. Due to the high number of coupons,
    it is necessary to choose a data structure that allows for quickly checking whether
    an element exists in some collection. For this reason, the hash set is chosen
    as a data structure for storing identifiers of the used coupons. Therefore, you
    just need to check whether an entered identifier exists in the set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the code, which should be added to the `Main` method
    in the `Program` class. The first part is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: At the beginning, a new instance of the `HashSet` generic class, storing integer
    values, is created. Then, the majority of the operations are performed within
    the `do-while` loop. Here, the program waits until the user enters the coupon
    identifier. If it cannot be parsed to the integer value, you break out of the
    loop. Otherwise, it is checked whether the set already contains an element equal
    to the identifier of the coupon (using the `Contains` method). If so, the suitable
    warning information is presented. However, if it does not exist, you add it to
    the collection of used coupons (using the `Add` method) and inform the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you break out of the loop, you just need to show the complete list of
    identifiers of the used coupons. You can achieve this goal using the `foreach`
    loop, iterating over the set, and writing its elements in the console, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can launch the application, enter some data, and see how it works.
    The result written in the console is presented here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This is the end of the first example. Let's proceed to the next one, where you
    will see a more complex solution that uses the hash set.
  prefs: []
  type: TYPE_NORMAL
- en: Example – swimming pools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This example presents the system for a SPA center with four swimming pools,
    namely recreation, competition, thermal, and for kids. Each visitor receives a
    special wrist band that allows one to enter all the pools. However, it is necessary
    to scan the wrist band while entering any pool and your program can use such data
    for creating various statistics.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the hash set is chosen as a data structure for storing unique
    numbers of wrist bands that have been scanned in the entrance to each swimming
    pool. Four sets will be used, one per each pool, as shown in the following diagram.
    Moreover, they will be grouped in the dictionary to simplify and shorten the code,
    as well as make future modifications easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5e73a997-35ca-427f-8258-207a9986b8a1.png)'
  prefs: []
  type: TYPE_IMG
- en: To simplify testing the application, the initial data will be set randomly.
    Thus, you just need to create statistics, namely the number of visitors by a pool
    type, the most popular pool, the number of people who visited at least one pool,
    and the number of people who visited all the pools. All the statistics will use
    sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the `PoolTypeEnum` enumeration (declared in the `PoolTypeEnum.cs`
    file), which represents possible types of swimming pools, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the `random` private static field to the `Program` class. It will
    be used to fill the hash set with some random values. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, declare the `GetRandomBoolean` static method in the `Program` class to
    return the `true` or `false` value, according to the random value. The code is
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The next changes are necessary only in the `Main` method. The first part is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here, you create a new instance of `Dictionary`. It contains four entries. Each
    key is of the `PoolTypeEnum` type and each value of the `HashSet<int>` type, that
    is, a set with integer values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next part, you fill the sets with random values, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: To do so, you use two loops, namely `for` and `foreach`. The first iterates
    100 times and simulates 100 wrist bands. Within it there is the `foreach` loop
    that iterates through all available pool types. For each of them, you randomly
    check whether a visitor entered a particular swimming pool. It is checked by getting
    a random Boolean value. If `true` is received, an identifier is added to the proper
    set. The `false` value indicates that the user with the given number of wrist
    band (`i`) has not entered the current swimming pool.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining code is related to generating various statistics. First, let''s
    present the number of visitors by a pool type. Such a task is very easy, because
    you just need to iterate through the dictionary, as well as write the pool type
    and the number of elements in the set (using the `Count` property), as shown in
    the following part of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The next part finds the swimming pool with the maximum number of visitors.
    It is performed using LINQ and its methods, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OrderByDescending` to order elements by the number of elements in the set,
    in descending order'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Select` to choose only a pool type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FirstOrDefault` to take the first result'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, you just present the result. The code for doing this is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you need to get the number of people who have visited at least one pool.
    You can perform this task by creating the union of all the sets and getting the
    count of the final set. At the beginning, you create a new set and fill it with
    identifiers regarding the recreation swimming pool. In the following lines of
    code, you call the `UnionWith` method to create a union with the following three
    sets. This part of the code is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The last statistic is the number of people who have visited all the pools during
    one visit in the SPA center. To perform such a calculation, you just need to create
    the intersection of all the sets and get the count of the final set. To do so,
    let''s create a new set and fill it with identifiers regarding the recreation
    swimming pool. Then, call the `IntersectWith` method to create an intersection
    with the following three sets. At the end, get the number of elements in the set
    using the `Count` property and present the results, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'And that''s all! When you run the application, you may receive a result similar
    to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: You have just completed two examples regarding the hash sets. It is a good idea
    to try to modify the code and add new features to learn more about such a data
    structure. When you are ready to learn the next data structure, let's continue
    reading.
  prefs: []
  type: TYPE_NORMAL
- en: '"Sorted" sets'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previously described class, `HashSet`, can be understood as a dictionary
    that stores only keys, without values. So, if there is the `SortedDictionary`
    class, maybe there is also the `SortedSet` class? Indeed, there is! However, can
    a set be "sorted"? Why is the "sorted" word written with quotation marks? The
    answer is simple—by definition, a set stores a collection of distinct objects
    without duplicated elements and without a particular order. If a set does not
    support order, how can it be "sorted"? For this reason, a "sorted" set can be
    understood as a combination of `HashSet` and `SortedList`, not a set itself.
  prefs: []
  type: TYPE_NORMAL
- en: The "sorted" set can be used if you want to have a sorted collection of distinct
    objects without duplicated elements. The suitable class is named `SortedSet` and
    is available in the `System.Collections.Generic` namespace. It has a set of methods,
    similar to those already described in the case of the `HashSet` class, such as
    `UnionWith`, `IntersectWith`, `ExceptWith`, `SymmetricExceptWith`, `Overlaps`,
    `IsSubsetOf`, `IsSupersetOf`, `IsProperSubsetOf`, and `IsProperSupersetOf`. However,
    it contains additional properties for returning the minimum and maximum values
    (`Min` and `Max`, respectively). It is worth mentioning also the `GetViewBetween`
    method that returns a `SortedSet` instance with values from the given range.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about the `SortedSet` generic class at [https://msdn.microsoft.com/library/dd412070.aspx](https://msdn.microsoft.com/library/dd412070.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: Let's proceed to a simple example to see how to use the "sorted" set in the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Example – removing duplicates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As an example, you will create a simple application that removes duplicates
    from the list of names. Of course, the comparison of names should be case-insensitive,
    thus it is not allowed to have both `"Marcin"` and `"marcin"` in the same collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how to perform this goal, let''s add the following code as the body
    of the `Main` method in the `Program` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: At the beginning, a list of names is created and initialized with nine elements,
    including `"Marcin"` and `"marcin"`. Then, you create a new instance of the `SortedSet`
    class, passing two parameters, namely the list of names and the case-insensitive
    comparer. At the end, you just iterate through the collection to write names in
    the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the application, you will see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This is the last example shown in this chapter. Thus, let's proceed to the summary.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This fourth chapter of the book focused on hash tables, dictionaries, and sets.
    All of these collections are interesting data structures that can be used in various
    scenarios. By presenting such collections with detailed descriptions and examples,
    you have seen that choosing a proper data structure is not a trivial task and
    requires analysis of performance-related topics, because some of them operate
    better in retrieving values and some promote the addition and removal of data.
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning, you have learned how to use two variants of a hash table,
    namely non-generic (the `Hashtable` class) and generic (`Dictionary`). The huge
    advantage of these is the very fast lookup for a value based on the key, which
    is the close *O(1)* operation. To achieve this goal, the hash function is used.
    Moreover, the sorted dictionary has been introduced as an interesting solution
    to solve the problem of unsorted items in the collection and to keep keys sorted
    all the time.
  prefs: []
  type: TYPE_NORMAL
- en: Afterwards, the high-performance solution to set operations was presented. It
    uses the `HashSet` class, which represents a collection of distinct objects without
    duplicated elements and without particular order. The class makes it possible
    to perform various operations on sets, such as union, intersection, subtraction,
    and symmetric difference. Then, the concept of the "sorted" set (the `SortedSet`
    class), has been introduced as a sorted collection of distinct objects without
    duplicated elements.
  prefs: []
  type: TYPE_NORMAL
- en: Do you want to dive deeper into the topic of data structures and algorithms,
    while developing applications in the C# language? If so, let's proceed to the
    next chapter where trees are presented.
  prefs: []
  type: TYPE_NORMAL
