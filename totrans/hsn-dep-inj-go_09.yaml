- en: Just-in-Time Dependency Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With *traditional* **dependency injection** (**DI**) methods, the parent or
    calling object supplies the dependencies to the child class. However, there are
    many cases where the dependencies have a single implementation. In these cases,
    a pragmatic approach would be to ask yourself, why inject the dependency at all?
    In this chapter, we will examine **just-in-time** (**JIT**) dependency injection,
    a strategy that gives us many of the benefits of DI, like decoupling and testability,
    without adding parameters to our constructors or methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: JIT injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantages of JIT injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying JIT injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disadvantages of JIT injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It would be beneficial to be familiar with the code for our service we introduced
    in [Chapter 4](9b5a6d56-9d43-4a12-a580-6ca8b13b9201.xhtml), *Introduction to the
    ACME Registration Service*. This chapter also assumes that you have read [Chapter
    6](89c75571-2952-40fc-ba19-221b3114461b.xhtml), *Dependency Injection with Constructor
    Injection*, and, to a lesser extent, [Chapter 5](5b999adb-130a-49ed-9294-841c5a1b8181.xhtml), *Dependency
    Injection with Monkey Patching*.
  prefs: []
  type: TYPE_NORMAL
- en: You might also find it useful to read and run the full version of the code for
    this chapter, which is available at [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch09](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch09).
  prefs: []
  type: TYPE_NORMAL
- en: Instructions to obtain the code and configure the sample service are available
    in the README section here: [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/).
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code for our service, with the changes from this chapter already
    applied, in `ch09/acme`.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be using mockery ([https://github.com/vektra/mockery](https://github.com/vektra/mockery))
    to generate mock implementations of our interfaces and also introducing a new
    tool called **package coverage** ([https://github.com/corsc/go-tools/tree/master/package-coverage)](https://github.com/corsc/go-tools/tree/master/package-coverage).
  prefs: []
  type: TYPE_NORMAL
- en: JIT injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Have you ever written an object and injected a dependency that you knew was
    only going to have one implementation? Perhaps you have injected the database
    handling code into the business logic layer, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Have you ever added a dependency to your constructor for the sole purpose of
    mocking it out during testing? This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'These kinds of things can feel like unnecessary extra work, and they definitely
    degrade the UX of the code. JIT injection allows us a comfortable middle ground.
    JIT injection is perhaps best explained by working through some examples. Let''s
    take a look at our first example with JIT injection applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have changed the direct references from `m.dataSource` to
    `m.getDataSource()` by adding a `getter` function, `getDataSource()`. In `getDataSource()`,
    we are performing a simple and efficient check to see whether the dependency already
    exists and when it doesn't, we create it. This is where we get the name *just-in-time
    injection*.
  prefs: []
  type: TYPE_NORMAL
- en: So, if we are not going to inject the dependency, then why do we need the injection?
    The simple answer is testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our original example, we were able to *swap out* our dependency with a mock
    implementation during testing, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'With JIT injection, we can still supply a mock implementation, but instead
    of supplying it via the constructor, we inject it directly into the private member
    variable, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You may have also noticed that in this example we dropped the use of a constructor.
    This is not necessary and will not always be the case. Applying JIT injection
    improves the usability of the object by reducing the number of parameters. In
    our example, there were no parameters left so dropping the constructor seemed
    appropriate as well.
  prefs: []
  type: TYPE_NORMAL
- en: JIT injection has allowed us to bend the traditional rules of DI by giving the
    object the ability to create its own dependencies when needed. While this is strictly
    speaking a violation of the *Single responsibility principle* section, as discussed
    in [Chapter 2](53a15217-38a7-4622-9242-a57fe46335ec.xhtml), *SOLID Design Principles
    for Go*, the improvements in usability are significant.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of JIT injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This method was designed to address some of the pain points of traditional DI.
    The advantages listed here are specific to this method and in contrast to other
    forms of dependency injection. Benefits specific to this method include the following.
  prefs: []
  type: TYPE_NORMAL
- en: '**Better User Experience (UX) due to fewer inputs**—I know I have raised this
    point a lot, but code that is easier to understand is also easier to maintain
    and extend. When a function has fewer parameters, it''s inherently easier to understand.
    Compare the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'With this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we removed all of the dependencies that had only one live implementation
    and replaced them with JIT injection. Now, users of this function just need to
    supply the one dependency that can change.
  prefs: []
  type: TYPE_NORMAL
- en: '**It''s perfect for optional dependencies**—Similar to the previous point regarding
    UX, optional dependencies can bloat a function''s parameter list. Additionally,
    it is not immediately apparent that the dependency is optional. Moving the dependency
    to a public member variable allows users to supply it only when needed. Applying
    JIT injection then allows the object to instantiate a copy of the default dependency.
    This simplifies the code inside the object significantly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code, which does not use JIT injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Applying JIT injection, this becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The function is now more concise and more straightforward to read. We will discuss
    using JIT injection with optional dependencies more in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '**Better encapsulation of the implementation details**—One of the counter-arguments
    to typical DI (that is, constructor or parameter injection) is that by exposing
    one object''s dependence on another, you are leaking implementation details. Consider
    the following constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, put yourself in the position of the user of `MyLoader`, without knowing
    its implementation. Does it matter to you that `MyLoader` uses a database or a
    cache? If you don't have multiple implementations or configurations to use, would
    it be easier just to let the author of `MyLoader` handle it for you?
  prefs: []
  type: TYPE_NORMAL
- en: '**Reduction in test-induced damage**—Another frequent complaint of those against
    DI is that dependencies are added to the constructor for the sole purpose of replacing
    them during testing. This position is well-founded; it''s something you will see
    quite often and one of the more common forms of test-induced damage. JIT injection
    alleviates this by changing the relationship to a private member variable and
    removing it from the public API. This still allows us to replace the dependency
    during testing, but with no public damage.'
  prefs: []
  type: TYPE_NORMAL
- en: In case you were wondering, the choice of a private member variable and not
    public is intentional and intentionally limiting. Being private, we are able to
    access and replace the dependency only during testing within the same package.
    Tests outside the package intentionally have no access. The first reason for this
    is encapsulation. We want to hide the implementation details from other packages
    so that they do not become coupled with our package. Any such coupling would make
    it harder to make changes to our implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The second reason is API pollution. If we made the member variable public, it
    would be accessible not only to the tests but to everyone, thereby opening the
    possibility of unexpected, invalid, or dangerous use of our internals.
  prefs: []
  type: TYPE_NORMAL
- en: '**It''s a great alternative to monkey patching**—As you may remember from [Chapter
    5](4195d787-7029-4d99-aba4-ed93e8a30fda.xhtml), *Dependency Injection with Monkey
    Patching*, one of the most significant problems with monkey patching is concurrency
    during testing. By patching the single global variable to suit the current test,
    any other test that is using that variable will be impacted and likely broken.
    It is possible to use JIT injection to avoid this problem. Consider the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As is, the global variable storage is going to need to be monkey patched during
    testing. But look what happens when we apply JIT injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'With all access to the global variable now going via `getStorage()`, we are
    able to use JIT injection to *swap out* the `storage` member variable instead
    of monkey patching the global (and shared) variable, as seen in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned test, there are no more data races on the global variable.
  prefs: []
  type: TYPE_NORMAL
- en: '**It''s excellent for layering code**—When applying dependency injection to
    an entire project, it is not uncommon to see a large swath of objects being created
    early on in the application''s execution. For example, our minimal example service
    already has four objects being built in `main()`. Four might not sound like a
    lot, but we haven''t applied DI to all our packages, and so far we only have three
    endpoints.'
  prefs: []
  type: TYPE_NORMAL
- en: For our service, we have three layers of code, REST, business logic, and data.
    The relationships between the layers are straightforward. One object in the REST
    layer calls its partner object in the business logic layer, which in turns calls
    the data layer. Other than for testing, we are always injecting the same dependencies.
    Applying JIT injection would allow us to remove these dependencies from the constructors
    and make the code more comfortable to use.
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation cost is low**—As we saw in the previous monkey patching example,
    applying JIT injection is very easy. Additionally, the changes are confined to
    a tiny area.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, applying JIT injection to code that does not already have any form
    of DI is also cheap. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If we decide to decouple `Car` from `Engine` then we will only need to define
    the abstracted interaction as an interface and then change all direct access to
    `c.engine` to use a `getter` function, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Consider what the process would have been to apply constructor injection. In
    what kinds of places would we have had to make changes?
  prefs: []
  type: TYPE_NORMAL
- en: Applying JIT injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous sections, I alluded to the fact that JIT injection can be used with
    private and public dependencies, two very different use cases. In this section,
    we will apply both options to achieve very different results.
  prefs: []
  type: TYPE_NORMAL
- en: Unit test coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Go, test coverage is calculated by adding a `-cover` flag along with a call
    to a regular call to go test. As this only works for one package at a time, I
    find this inconvenient. So we are going to use a tool that recursively calculates
    test coverage for all the packages in a directory tree. This tool is called **package-coverage**
    and is available from GitHub ([https://github.com/corsc/go-tools/tree/master/package-coverage](https://github.com/corsc/go-tools/tree/master/package-coverage)).
  prefs: []
  type: TYPE_NORMAL
- en: 'To calculate the coverage using `package-coverage`, we use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: I have intentionally used the code from [Chapter 8](a830a2d7-1e66-48eb-90d2-5b8f66dc40fe.xhtml),
    *Dependency Injection by Config*, so the coverage numbers are before any changes
    we might make in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: So, what can we infer from these numbers?
  prefs: []
  type: TYPE_NORMAL
- en: The code coverage is reasonable. It could be better but other than the big fat
    0 on the `logging` package, almost all the packages have 50% plus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The statement (`stmts`) counts are interesting. Statements are roughly equivalent
    to *lines of code*, and therefore the numbers indicate which packages have more
    or less code. We can see that the `rest`, `data`, and `exchange` packages are
    the largest.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can infer from the amount of code in a package that the more code a package
    has, the more responsibilities and more complexity it has. By extension, the more
    risk this package poses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given that the two largest, riskiest packages, `rest` and `data`, both have
    good test coverage, we still have nothing that indicates it needs urgent attention.
    But what happens if we consider the test coverage and dependency graph together?
  prefs: []
  type: TYPE_NORMAL
- en: Private dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many places we could improve our service by applying JIT injection.
    So, how do we decide? Let''s see what our dependency graph has to say:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aeec3c06-de6a-41e5-89e3-56c80332a557.png)'
  prefs: []
  type: TYPE_IMG
- en: There are lots of connections going into the logging package. But we have already
    decoupled that a reasonable amount in [Chapter 8](a830a2d7-1e66-48eb-90d2-5b8f66dc40fe.xhtml),
    *Dependency Injection by Config*.
  prefs: []
  type: TYPE_NORMAL
- en: The next package with the most users is the `data` package. We worked on that
    back in [Chapter 5](5b999adb-130a-49ed-9294-841c5a1b8181.xhtml), *Dependency Injection
    with Monkey Patching*, but maybe it's time to revisit it and see if we can improve
    it even more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we decide, I will introduce you to another way to get a sense of the
    health of the code and where our efforts might be best spent: unit test coverage.
    Like the dependency graph, it cannot provide a definitive indicator, but only
    give you a hint.'
  prefs: []
  type: TYPE_NORMAL
- en: Coverage and dependency graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The dependency graph told us that the `data` package had lots of users. The
    test coverage told us that it was also one of the biggest packages we had. We
    can, therefore, infer that if we wanted to make improvements, this might be the
    right place to start.
  prefs: []
  type: TYPE_NORMAL
- en: As you may remember from earlier chapters, the `data` package uses functions
    and a global singleton pool, both of which caused us inconvenience. So, let's
    see if we can use JIT injection to get rid of these pain points.
  prefs: []
  type: TYPE_NORMAL
- en: Chasing away the monkeys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is how the `get` package currently uses the `data` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Our first change will be to define an interface that will replace our `loader`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed we dropped the config parameter. By the time we are done,
    we will not have to pass this in with every call. I have also added a `go generate`
    comment, which will create a mock that we will use later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we add this dependency as a private member variable and update our `Do()`
    method to use JIT injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'But what will our JIT injection `getter` method look like? The basic structure
    will be standard, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Because the `data` package was implemented as functions, we currently don't
    have anything that implements our `loader` interface. Our code and unit tests
    are now broken, so we are going to have to fly blind for a little bit while we
    get them working again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The shortest path to getting our code working again is to define ourselves
    a **data access object** (**DAO**). This will replace the functions in our `data`
    package with a struct and give us something that implements our `myLoader` interface.
    To make the minimum number of changes, we will have the DAO methods call the existing
    functions as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Even after adding the DAO into our `getLoader()` function, our tests are still
    not restored. Our tests are still using monkey patching so we will need to remove
    that code and replace it with a mock, giving us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, our tests are working again. With these refactorings, we have also
    achieved a few other improvements:'
  prefs: []
  type: TYPE_NORMAL
- en: Our `get` package tests no longer use monkey patching; this means we can be
    sure there are no monkey patching related concurrency issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other than the data struct (`data.Person`), the `get` package tests no longer
    use the `data` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perhaps most significantly, the `get` package tests no longer require the database
    to be configured
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With our planned changes to the `get` package complete, we can move over to
    the `data` package.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, we defined a DAO where our `Load()` method called the existing `Load()`
    function. As there are no more users of the `Load()` function, we can simply copy
    the code over and update the corresponding tests.
  prefs: []
  type: TYPE_NORMAL
- en: After repeating this simple process for the rest of the `data` package and its
    users, we are able to successfully migrate away from a function-based package
    to an object-based one.
  prefs: []
  type: TYPE_NORMAL
- en: Optional public dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've applied JIT dependency injection to private dependencies with
    the goal of reducing the parameters and making our `data` package more straightforward
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: There is another way to use JIT injection—optional public dependencies. These
    dependencies are public as we want users to be able to change them but we do not
    make them, part of the constructor because they are optional. Doing so would detract
    from the UX, especially in cases where the optional dependency is seldom used.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine we were having a performance problem with the *Load all registrations* endpoint
    of our service and we suspected the problem was related to the responsiveness
    of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Faced with such a problem, we decide that we need to track how long these queries
    took by adding some instrumentation. To ensure that we are able to turn this tracker
    on and off easily, we could make it an optional dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first step would be to define our `tracker` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We have a decision to make. The use of `QueryTracker` is optional, and this
    means that users are not guaranteed to have injected the dependency.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid guard clauses wherever `QueryTracker` is used, we are going to introduce
    a NO-OP implementation that can be used when the user did not supply one. A NO-OP
    implementation, sometimes called a **null object**, is an object that implements
    an interface but where all the methods intentionally do nothing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the NO-OP implementation of `QueryTracker`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can introduce it to our DAO as a public member variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can use JIT injection to access the tracker, which defaults to the NO-OP
    version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that everything is in place, we can add the following lines to the beginning
    of any method we want to track:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: An interesting thing to note here is the use of `defer`. Basically, `defer`
    has two significant features that we are using here. Firstly, it will be called
    whenever the function exits, allowing us to add the tracker once, instead of next
    to every return statement. Secondly, the parameters of `defer` are determined
    at the time the line is encountered, and not the time they are executed. This
    means the value of `time.Now()` will be called at the start of the function we
    are tracking and not when the `Track()` function returns.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our tracker to be of use, we need to provide an implementation other than
    the NO-OP. We could push these values to an external system like StatsD or Graphite,
    but for simplicity we will output the results to the log. The code for this is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can temporarily update our DAO usage from this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'And update it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Yes, the line is kind of ugly, but luckily it's only temporary. If we decided
    to make our QueryTracker permanent or found ourselves using it most of the time,
    then we could switch over to constructor injection pretty easily.
  prefs: []
  type: TYPE_NORMAL
- en: Disadvantages of JIT injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While JIT injection can be handy, it cannot be used in all scenarios, and there
    are a few gotchas to be wary of. These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Can only be applied to static dependencies**—The first and perhaps most significant
    disadvantage is that this method can only be applied to dependencies that only
    change during testing. We cannot use it to replace parameter injection or config
    injection. This is caused by the fact that dependency instantiation happens inside
    a private method and only on the first attempt to access the variable.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dependency and user life cycles are not separated**—When using constructor
    injection or parameter injection, it''s often safe to assume the dependency being
    injected is fully initialized and ready for use. Any costs or delays, like those
    related to creating resource pools or preloading data, will have already been
    paid. With JIT injection, the dependency is created immediately before the first
    use. As such, any initialization cost has to be paid by that first request. The
    following diagram shows a typical interaction between three objects (a caller,
    a callee, and a data store):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8535fb3c-c845-4c66-bace-3e0bd77e620c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, compare that with the interaction when the data store object is created
    during the call:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e1e57d5a-3105-447a-bbb5-04443b79754d.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see the additional time (cost) that is incurred in the second diagram.
    These costs do not happen in most cases as creating objects in Go is fast. However,
    when they do exist, they can cause some unintended or inconvenient behavior during
    application startup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another downside in cases like the one previously mentioned, where the state
    of the dependency is uncertain, exists in the resulting code. Consider the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare the previous code with the same code where the dependency is guaranteed
    to be in a *ready* state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This is only a few lines of code, sure, but it's vastly simpler to read and
    therefore maintain. It was also a lot easier to implement and test.
  prefs: []
  type: TYPE_NORMAL
- en: '**Potential data and initialization races**—Similar to the previous point,
    this one also revolves around the initialization of the dependency. In this case,
    however, the issues are related to accessing the dependency itself. Let''s return
    to our earlier example of a connection pool but change how the instantiation occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this constructor of the connection pool will not return until
    after the pool is fully initialized. So, what happens when another call to the
    `getConnectionPool()` occurs while the initialization is happening?
  prefs: []
  type: TYPE_NORMAL
- en: 'We could end up creating two connection pools. This diagram shows this interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e44b2f3-dba6-4ff4-9b04-6ab877ba0f3e.png)'
  prefs: []
  type: TYPE_IMG
- en: So, what happens to the other connection pool? It will be orphaned. All CPU
    spent on creating it is wasted, and it’s even possible that it does not get cleaned
    up properly by the garbage collector; so any resources such as memory, file handles,
    or network ports could be lost.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a simple way to ensure that this issue is avoided but it comes with
    a very minor cost. We can use the sync package from the `standard` library. There
    are several nice options from this package, but in this case I recommend `Once()`.
    By adding `Once()` to our `getConnectionPool()` method, we get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: There are two minor costs associated with this approach. The first is the added
    complexity to the code; it's minor, but it does exist.
  prefs: []
  type: TYPE_NORMAL
- en: The second is that every call to `getConnectionPool()`, of which there could
    be many, will check `Once()` to see whether it is the first call. This is an incredibly
    small cost, but, depending on your performance requirements, it could be inconvenient.
  prefs: []
  type: TYPE_NORMAL
- en: '**Objects are not entirely decoupled**—Throughout this book, we''ve used the
    dependency graph to identify potential issues, particularly regarding the relationships
    between packages, and in some cases the over-dependence on particular packages.
    While we can and should still use the *Dependency inversion principle* section
    from [Chapter 2](53a15217-38a7-4622-9242-a57fe46335ec.xhtml), *SOLID Design Principles
    for Go*, and define our dependency as a local interface, by including the dependency''s
    creation in our code, the dependency graph will still show the relationship between
    our package and the dependency. In a way, our object is still somewhat coupled
    to our dependency.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we used JIT injection, a somewhat unusual DI method, to remove
    some of the monkey patching from earlier chapters.
  prefs: []
  type: TYPE_NORMAL
- en: We also used a different form of JIT injection to add an optional dependency,
    without detracting from the UX of our code.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we examined how JIT injection can also be used to reduce test-induced
    damage, without sacrificing our ability to use mocks and stubs in our tests.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will examine the last DI method in the book, off-the-shelf
    injection. We will discuss the general advantages and disadvantages of adopting
    a DI framework, and for our examples we will use Google's Wire framework.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How does JIT injection differ from constructor injection?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When working with optional dependencies, why is using a NO-OP implementation
    important?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the ideal use cases for JIT injection?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
