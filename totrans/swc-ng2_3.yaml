- en: Chapter 3. TypeScript Crash Course
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to start working with TypeScript, the language
    Angular 2 recommends for scripting. All the features ECMAScript 2015 and respectively
    ECMAScript 2016 provides, such as functions, classes, modules, and decorators,
    are already implemented in or added to the roadmap of TypeScript. Because of the
    extra type annotations, there are some syntactical additions compared to JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: For smoother transition from the language we already know - ES5, we will start
    with some common features between ES2016 and TypeScript. Where there are differences
    between the ES syntax and TypeScript, we'll explicitly mention it. In the second
    half of the chapter, we'll add the type annotations to everything we've learned
    until this point.
  prefs: []
  type: TYPE_NORMAL
- en: Later in the chapter, we will explain the extra features TypeScript provides,
    such as static typing and extended syntax. We will discuss the different consequences
    based on these features, which will help us be more productive and less error-prone.
    Let's get going!
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript is an open source programming language that is developed and maintained
    by Microsoft. Its initial public release was in October 2012\. TypeScript is a
    superset of ECMAScript, supporting all of the syntax and semantics of JavaScript
    with some extra features on top, such as static typing and richer syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '*Fig. 1* shows the relationship between ES5, ES2015, ES2016, and TypeScript.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to TypeScript](../images/00009.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 1
  prefs: []
  type: TYPE_NORMAL
- en: Because TypeScript is statically typed, it can provide a number of benefits
    to us as JavaScript developers. Let's have a quick look at those benefits now.
  prefs: []
  type: TYPE_NORMAL
- en: Compile-time type checking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some of the most common mistakes we make while writing JavaScript code is to
    misspell a property or a method name. We'll find out about the mistake when we
    get a runtime error. This can happen during development as well as in production.
    Hoping we will know about the error before we deploy our code to production environment
    isn't a comfortable feeling! However, this is not a problem specific to JavaScript;
    it is something common to all the dynamic languages. Even with lots of unit tests,
    these errors can slip by.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript provides a compiler, which takes care of such mistakes for us by
    using static code analysis. If we take advantage of static typing, TypeScript
    will be aware of the existing properties a given object has, and if we misspell
    any of them, the compiler will warn us with a compile-time error.
  prefs: []
  type: TYPE_NORMAL
- en: Another great benefit of TypeScript is that it allows large teams to collaborate,
    since it provides formal, verifiable naming. This way, it allows us to write easy-to-understand
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Better support by text editors and IDEs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a number of tools, such as **Tern** or **Google** **Closure Compiler**,
    that are trying to bring better autocompletion support for JavaScript in text
    editors and IDEs. However, as JavaScript is a dynamic language, it is impossible
    for the IDEs and text editors to make sophisticated suggestions without any metadata.
  prefs: []
  type: TYPE_NORMAL
- en: Annotating the code with such metadata is a built-in feature of TypeScript known
    as type annotations. Based on them, text editors and IDEs can perform better static
    analysis over our code. This provides better refactoring tools and autocompletion,
    which increases our productivity and allows us to make fewer mistakes while writing
    the source code for our applications.
  prefs: []
  type: TYPE_NORMAL
- en: There's even more to TypeScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TypeScript by itself has a number of other benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**It is a superset of JavaScript**: All JavaScript (ES5 and ES2015) programs
    are already valid TypeScript ones. In essence, you have already been writing TypeScript
    code. Since it is based on the latest version of the ECMAScript standard, it allows
    us to take advantage of the latest bleeding edge syntax provided by the language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Supports optional type checking**: If, for any reason, we decide that we
    don''t want to explicitly define the type of a variable or a method, we can just
    skip the type definition. However, we should be aware that this means we are no
    longer taking advantage of the static typing, so we are giving up on all the benefits
    mentioned earlier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Developed and maintained by Microsoft**: The quality of the implementation
    of the language is very high and it is unlikely that support will be dropped unexpectedly.
    TypeScript is based on the work of some of the world''s best experts in programming
    language development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It is open source**: This allows the community to freely contribute to the
    language and suggest features, which are discussed in an open manner. The fact
    that TypeScript is open source allows for the easier development of third-party
    extensions and tools, which extends further the scope of its usage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since modern browsers do not support TypeScript natively, there is a compiler
    that translates the TypeScript code we write into readable JavaScript in a predefined
    target version of ECMAScript. Once the code is compiled, all the type annotations
    are removed.
  prefs: []
  type: TYPE_NORMAL
- en: Using TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start writing some TypeScript!
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we are going to take a look at different snippets
    showing some of the features of TypeScript. In order to be able to run the snippets
    and play with them yourself, you'll need to install the TypeScript compiler on
    your computer. Let's take a look at how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript is best installed using **Node Package Manager** (**npm**). I'd recommend
    you to use npm Version 3.0.0 or newer. If you don't have node.js and npm installed
    already, you can visit [https://nodejs.org](https://nodejs.org) and follow the
    instructions there.
  prefs: []
  type: TYPE_NORMAL
- en: Installing TypeScript with npm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have npm installed and running, verify that you have the latest version
    by opening your terminal window and running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to install TypeScript 1.8, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will install the TypeScript compiler and add its executable
    (`tsc`) as global to your path.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to verify that everything works properly, you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The output should be similar to the preceding one, though possibly with a different
    version.
  prefs: []
  type: TYPE_NORMAL
- en: Running our first TypeScript program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code for this book on the following URL: [https://github.com/mgechev/switching-to-angular2](https://github.com/mgechev/switching-to-angular2).
    As a comment in most code snippets you''ll find a relative to the `app` directory
    file path where you can find them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s compile our first TypeScript program! Create a file called `hello.ts`
    and enter the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Since you''ve already installed the TypeScript compiler, you should have a
    global executable command called `tsc`. You can use it in order to compile the
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you should see the file `hello.js` in the same directory where `hello.ts`
    is. `hello.js` is the output of the TypeScript compiler; it contains the JavaScript
    equivalent to the TypeScript you wrote. You can run this file using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you''ll see the string `Hello world!` printed on the screen. In order
    to combine the process of compiling and running the program, you can use the package
    `ts-node`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You should see the same result, but without the `ts-node` file stored on the
    disk.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript syntax and features introduced by ES2015 and ES2016
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As TypeScript is a superset of JavaScript, before we start learning about its
    syntax, it's a little easier to start by introducing some of the bigger changes
    in ES2015 and ES2016; to understand TypeScript, we first must understand ES2015
    and ES2016\. We're going to have a whistle-stop tour through these changes before
    diving in to TypeScript proper later.
  prefs: []
  type: TYPE_NORMAL
- en: 'A detailed explanation of ES2015 and ES2016 is outside the scope of this book.
    In order to get familiar with all the new features and syntaxes, I strongly recommend
    you to take a look at *Exploring ES6: upgrade to the next version of JavaScript*
    by *Dr. Axel Rauschmayer*.'
  prefs: []
  type: TYPE_NORMAL
- en: The next couple of pages will introduce new standards and allow you to take
    advantage of most of the features you're going to need in the development of Angular
    2 applications.
  prefs: []
  type: TYPE_NORMAL
- en: ES2015 arrow functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript has first class functions, which means that they can be passed around
    like any other value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This syntax is great; however, it is a bit too verbose. ES2015 introduced a
    new syntax to define anonymous functions called the arrow function syntax. Using
    it, we can create anonymous functions, as seen in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the first example, we got the total sum of the elements in the array `[1,
    2, 3]`. In the second example, we got all the even numbers inside the array `[3,
    1, 56, 7]`. In the third example, we sorted an array by the properties' `price`
    and `total` in the ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Arrow functions have a few more features that we need to look at. The most
    important one of them is that they keep the context (`this`) from the surrounding
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: For example, when we invoke the function `MyComponent` with the operator `new`,
    this will point to the new object instantiated by the call. The arrow function
    will keep the context (`this`), in the callback of `setTimeout`, and print **43**
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: This is extremely useful in Angular 2, since the binding context for a given
    component is its instance (that is, its `this`). If we define `MyComponent` as
    an Angular 2 component and we have a binding to the `age` property, the preceding
    code will be valid and all the bindings will work (notice that we don't have scope,
    neither do we have explicit calls to the `$digest` loop although we have called
    `setTimeout` directly).
  prefs: []
  type: TYPE_NORMAL
- en: Using the ES2015 and ES2016 classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When developers new to JavaScript hear that the language empowers the **object-oriented**
    (**OO**) paradigm, they're normally confused when they discover that there's no
    syntax for the definition of classes. This perception was born by the fact that
    some of the most popular programming languages, such as Java, C#, and C++, have
    the concept of classes used for the construction of objects. However, JavaScript
    implements the OO paradigm differently. JavaScript has a prototype-based, object-oriented
    programming model, where we can instantiate objects using the object literal syntax
    or functions (also known as the constructor functions) and we can take advantage
    of the inheritance using the so-called prototype chain.
  prefs: []
  type: TYPE_NORMAL
- en: Though this is a valid way to implement the OO paradigm and the semantics are
    similar to the one in the classical object-oriented model, it is confusing for
    inexperienced JavaScript developers who are not sure how to process this properly.
    This is one of the reasons TC39 decided to provide an alternative syntax to exploit
    the object-oriented paradigm in the language. Behind the scenes, the new syntax
    has the same semantics as the one we're used to, like using the constructor functions
    and the prototype-based inheritance. However, it provides a more convenient syntax
    to empower the OO paradigm's features with less boilerplate.
  prefs: []
  type: TYPE_NORMAL
- en: ES2016 adds some extra syntax to the ES2015 classes, such as static and instance
    property declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that demonstrates the syntax used to define the classes
    in ES2016:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In ES2015, the explicit declaration of the `_name` property is not required;
    however, since the TypeScript compiler should be aware during compile-time of
    the existing properties of the instances of a given class, we would need to add
    the declaration of the property to the class declaration itself.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding snippet is both a valid TypeScript and JavaScript code. In it,
    we defined a class called `Human`, which adds a single property to the objects
    instantiated by it. It does this by setting its value to the parameter name passed
    to its constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the `ch3/es6-classes/sample-classes.ts` file and play around with
    it! You can create different instances of the classes the same way you create
    objects using constructor functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to execute the code, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Classes are commonly used in Angular 2\. You can use them to define your components,
    directives, services, and pipes. However, you can also use the alternative ES5
    syntax, which takes advantage of the constructor functions. Under the hood, once
    the TypeScript code is compiled, there would be no such significant difference
    between both the syntaxes, because the ES2015 classes are being transpiled to
    constructor functions anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Defining variables with block scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another confusing point of JavaScript for developers with a different background
    is the variable scope in the language. In Java and C++, for example, we're used
    to the block lexical scope. This means that a given variable defined inside a
    specific block will be visible only inside that block and all of the nested blocks
    inside of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in JavaScript, things are a little bit different. ECMAScript defines
    a functional lexical scope that has similar semantics to the block lexical scope,
    but it uses functions instead of blocks. This means that we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This has some weird implications. Once the code has been executed, it will log
    five times the number `5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES2015 added a new syntax to define the variables with block-scope visibility.
    The syntax is similar to the current one. However, instead of `var`, it uses the
    keyword `let`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Meta-programming with ES2016 decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JavaScript is a dynamic language that allows us to easily modify and/or alter
    the behavior to suit the programs we write. Decorators are a proposal to ES2016,
    which according to the design document [https://github.com/wycats/javascript-decorators](https://github.com/wycats/javascript-decorators):'
  prefs: []
  type: TYPE_NORMAL
- en: '*"…make it possible to annotate and modify classes and properties at design
    time."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Their syntaxes are quite similar to the annotations in Java, and they are even
    closer to the decorators in Python. ES2016 decorators are used commonly in Angular
    2 to define components, directives, and pipes, and to take advantage of the dependency
    injection mechanism of the framework. Essentially, most use cases of decorators
    involve altering the behavior to predefined logic or adding some metadata to different
    constructs.
  prefs: []
  type: TYPE_NORMAL
- en: ES2016 decorators allow us to do a lot of fancy things by changing the behavior
    of our programs. Typical use cases could be to annotate the given methods or properties
    as deprecated or read-only. A set of predefined decorators that can improve the
    readability of the code we produce can be found in a project by *Jay Phelps* called
    *core-decorators.js*. Another use case is taking advantage of the proxy-based
    aspect-oriented programming using a declarative syntax. The library providing
    this functionality is `aspect.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, ES2016 decorators are just another syntax sugar, which translates
    to the code we''re already familiar with from the previous versions of JavaScript.
    Let''s take a look at a simple example from the proposal''s draft:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we have an ES2015 class called `Person` with a single getter
    called `kidCount`. Over the `kidCount` getter, we have applied the `nonenumerable`
    decorator. The decorator is a function that accepts a target (the `Person` class),
    the name of the target property we intend to decorate (`kidCount`), and the descriptor
    of the `target` property. After we change the descriptor, we need to return it
    in order to apply the modification. Basically, the decorator''s application could
    be translated into ECMAScript 5 in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Using configurable decorators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is an example on using the decorators defined by Angular 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When decorators accept arguments (just like `Component`, `RouteConfig`, and
    `View` in the preceding example), they need to be defined as functions that accept
    arguments and return the actual decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we defined a configurable decorator called `Component` that
    accepts a single argument called `config` and returns a decorator.
  prefs: []
  type: TYPE_NORMAL
- en: Writing modular code with ES2015
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another problem that JavaScript professionals have experienced along the years
    is the lack of a module system in the language. Initially, the community developed
    different patterns, aiming to enforce the modularity and the encapsulation of
    the software we produce. Such patterns included the module pattern, which takes
    advantage of the functional lexical scope and closures. Another example is the
    namespace pattern, which represents the different namespaces as nested objects.
    AngularJS 1.x introduced its own module system that unfortunately doesn't provide
    features like lazy module loading. However, these patterns were more like workarounds
    rather than real solutions.
  prefs: []
  type: TYPE_NORMAL
- en: '**CommonJS** (used in node.js) and **AMD** (**Asynchronous Module Definition**)
    were later invented. They are still in wide use today and provide features, such
    as handling of circular dependencies, asynchronous module loading (in AMD), and
    so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'TC39 took the best of the existing module systems and introduced this concept
    on a language level. ES2015 provides two APIs to define and consume modules. They
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Declarative API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imperative API using the module loader.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular 2 takes full advantage of the ES2015 module system, so let's dive into
    it! In this section, we are going to take a look at the syntax used for the declarative
    definition and consumption of modules. We are also going to peek at the module
    loader's API in order to see how we can programmatically load modules in an explicit
    asynchronous manner.
  prefs: []
  type: TYPE_NORMAL
- en: Using the ES2015 module syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we defined a simple ES2015 module in the file `math.ts`.
    We can think of it as a sample math Angular 2 utility module. Inside it, we defined
    and exported the functions `square` and `log10`, and the constant `PI`. The `const`
    keyword is another keyword brought by ES2015 that is used to define constants.
    As you can see, what we do is nothing more than prefixing the function''s definitions
    with the keyword `export`. If we want to export the entire functionality in the
    end and skip the duplicate explicit usage of `export`, we can:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax on the last line is nothing more than an enhanced object literal
    syntax, introduced by ES2015\. Now, let''s take a look at how we can consume this
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As an identifier of the module, we used its relative path to the current file.
    By using destructuring, we imported the required functions—in this case, `square`
    and `log10`.
  prefs: []
  type: TYPE_NORMAL
- en: Taking advantage of the implicit asynchronous behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important to note that the ES2015 module syntax has implicit asynchronous
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say we have modules `A`, `B`, and `C`. Module `A` uses modules `B` and
    `C`, so it depends on them. Once the user requires module `A`, the JavaScript
    module loader would need to load modules `B` and `C` before being able to invoke
    any of the logic that resides in module `A` because of the dependencies we have.
    However, modules `B` and `C` will be loaded asynchronously. Once they are loaded
    completely, the JavaScript virtual machine will be able to execute module `A`.
  prefs: []
  type: TYPE_NORMAL
- en: Using aliases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another typical situation is when we want to use an alias for a given export.
    For example, if we use a third-party library, we may want to rename any of its
    exports in order to escape name collisions or just to have a more convenient naming:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Importing all the module exports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can import the entire `math` module using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The semantics behind this syntax is quite similar to CommonJS, although in the
    browser, we have implicit asynchronous behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Default exports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If a given module defines an export, which would quite likely be used by any
    of its consumer modules, we can take advantage of the default export syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to consume this module, we can use the following `app.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if we want to import the default export as well as some other exports,
    we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In general, the default export is nothing more than a named export named with
    the reserved word `default`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: ES2015 module loader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The new version of the standard defines a programmatic API to work with modules.
    This is the so-called module loader API. It allows us to define and import modules,
    or configure the module loading.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s suppose we have the following module definition in the file `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'From the file `init.js`, we can programmatically load the `app` module and
    invoke its `main` function using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The global object `System` has a method called `import` that allows us to import
    modules using their identifier. In the preceding snippet, we imported the module
    `app` defined in `app.js`. `System.import` returns a promise that could be resolved
    on success or rejected in case of an error. Once the promise is resolved as the
    first parameter of the callback passed to `then`, we will get the module itself.
    The first parameter of the callback registered in case of rejection is the error
    that happened.
  prefs: []
  type: TYPE_NORMAL
- en: The code from the last snippet does not exist in the GitHub repository, since
    it requires some additional configuration. We are going to apply the module loader
    more explicitly in the Angular 2 examples in the next chapters of the book.
  prefs: []
  type: TYPE_NORMAL
- en: ES2015 and ES2016 recap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations! We're more than halfway toward learning TypeScript. All the
    features we've just seen are a part of TypeScript, since it implements a superset
    of JavaScript and since all these features are an upgrade on top of the current
    syntax, they are easy to grasp by experienced JavaScript developers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next sections, we will describe all the amazing features of TypeScript
    that are outside the intersection with ECMAScript.
  prefs: []
  type: TYPE_NORMAL
- en: Taking advantage of static typing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Static typing is what can provide better tooling for our development process.
    While writing JavaScript, the most that IDEs and text editors can do is syntax
    highlighting and providing some basic autocompletion suggestions based on the
    sophisticated static analysis of our code. This means that we can only verify
    that we haven't made any typos by running the code.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous sections, we described only the new features provided by ECMAScript
    expected to be implemented by browsers in the near future. In this section, we
    will take a look at what TypeScript provides in order to help us be less error-prone
    and more productive. At the time of this writing, there're no plans to implement
    built-in support for static typing in the browsers.
  prefs: []
  type: TYPE_NORMAL
- en: The TypeScript code goes through intermediate preprocessing that performs the
    type checking and drops all the type annotations in order to provide valid JavaScript
    supported by modern browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Using explicit type definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like Java and C++, TypeScript allows us to explicitly declare the type
    of the given variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line defines the variable `foo` in the current block using the
    `let` syntax. We explicitly declare that we want `foo` to be of the type `number`
    and we set the value of `foo` to `42`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s try to change the value of `foo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, after the declaration of `foo`, we will set its value to the string `''42''`.
    This is a perfectly valid JavaScript code; however, if we compile it using the
    TypeScript''s compiler, we will get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Once `foo` has been associated with the given type, we cannot assign it values
    belonging to different types. This is one of the reasons we can skip the explicit
    type definition in case we assign a value to the given variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The semantics behind this code will be the same as the one with the explicit
    type definition because of the type inference of TypeScript. We'll further take
    a look at it at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The type any
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All the types in TypeScript are subtypes of a type called `any`. We can declare
    variables belonging to the `any` type by using the `any` keyword. Such variables
    can hold the value of `any` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is a valid TypeScript, and it will not throw any error during
    compilation or runtime. If we use the type `any` for all of our variables, we
    will be basically writing the code with dynamic typing, which drops all the benefits
    of the TypeScript's compiler. That's why we have to be careful with `any` and
    use it only when it is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the other types in TypeScript belong to one of the following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Primitive types**: This includes Number, String, Boolean, Void, Null, Undefined,
    and Enum types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Union types**: Union types are out of the scope of this book. You can take
    a look at them in the specification of TypeScript.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Object types**: This includes Function types, classes and interface type
    references, array types, tuple types, function types, and constructor types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type parameters**: This includes Generics that are going to be described
    in the *Writing generic code by using type parameters* section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Primitive types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most of the primitive types in TypeScript are the ones we are already familiar
    with in JavaScript: Number, String, Boolean, Null, and Undefined. So, we are going
    to skip their formal explanation here. Another set of types that is handy while
    developing Angular 2 applications is the Enum types defined by users.'
  prefs: []
  type: TYPE_NORMAL
- en: The Enum types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Enum types are primitive user-defined types that, according to the specification,
    are subclasses of Number. The concept of `enums` exists in the Java, C++, and
    C# languages, and it has the same semantics in TypeScript—user-defined types consisting
    of sets of named values called elements. In TypeScript, we can define `enum` using
    the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This is going to be translated to the following JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `enum` type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Understanding the Object types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we're going to take a look at the Array types and Function
    types, which belong to the more generic class of Object types. We will also explore
    how we can define classes and interfaces. Tuple types were introduced by TypeScript
    1.3, and their main purpose is to allow the language to begin typing the new features
    introduced by ES2015, such as destructuring. We will not describe them in this
    book. For further reading you can take a look at the language's specification
    at [http://www.typescriptlang.org](http://www.typescriptlang.org).
  prefs: []
  type: TYPE_NORMAL
- en: The Array types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In TypeScript, arrays are JavaScript arrays with a common element type. This
    means that we cannot have elements from different types in a given array. We have
    different array types for all the built-in types in TypeScript, plus all the custom
    types that we define.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define an array of numbers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to have an array, which seems heterogeneous, similar to the arrays
    in JavaScript, we can use the type reference to `any`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This is possible, since the types of all the values we're pushing to the array
    are subtypes of the `any` type and the array we've declared contains values of
    the type `any`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the array methods we''re familiar with in JavaScript with all the
    TypeScript Array types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have the square-brackets operator that gives us random access to the
    array''s elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The Function types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The function types are a set of all the functions with different signatures,
    including the different number of arguments, different arguments' types, or different
    types of the return result.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re already familiar with how to create a new function in JavaScript. We
    can use function expression or function declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we can use the new arrow function syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The only thing TypeScript alters is the feature to define the types of the
    function''s arguments and the type of its return result. After the compiler of
    the language performs its type checking and transpilation, all the type annotations
    will be removed. If we use function expression and we assign a function to a variable,
    we will be able to define the variable type in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In case of `function declaration`, we''ll have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to define a method in a object literal, we can process it in the
    following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we defined an object literal using the ES2015 syntax
    that defines the method `squareRoot`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In case we want to define a function that produces some side effects instead
    of returning a result, we can define it as a `void` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Defining classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TypeScript classes are similar to what ES2015 offers. However, it alters the
    type declarations and creates more syntax sugar. For example, let''s take the
    `Human` class we defined earlier and make it a valid TypeScript class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no difference between the current TypeScript definition with the one
    we already introduced, however, in this case the declaration of the `_name` property
    is mandatory. Here is how we can use the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Using access modifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similarly, for most conventional object-oriented languages that support classes,
    TypeScript allows definition of access modifiers. In order to deny direct access
    to the `_name` property outside the class it is defined in, we can declare it
    as private:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The supported access modifiers by TypeScript are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Public**: All the properties and methods declared as public could be accessed
    anywhere.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Private**: All the properties and methods declared as private can be accessed
    only from inside the class'' definition itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protected**: All the properties and methods declared as protected can be
    accessed from inside the class'' definition or the definition of any other class
    extending the one that owns the property or the method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Access modifiers are a great way to implement Angular 2 services with good
    encapsulation and a well-defined interface. In order to understand it better,
    let''s take a look at an example using the class'' hierarchy defined earlier,
    which is ported to TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Just like ES2015, TypeScript supports the `extends` keyword and desugars it
    to the prototypal JavaScript inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, we set the access modifiers of the `name` and `age`
    properties directly inside the constructor function. The semantics behind this
    syntax differs from the one used in the previous example. It has the following
    meaning: define a protected property called `name` of the type `string` and assign
    the first value passed to the constructor call to it. It is the same for the private
    `age` property. This saves us from explicitly setting the value in the constructor
    itself. If we take a look at the constructor of the `Developer` class, we can
    see that we can use the mixture between these syntaxes. We can explicitly define
    the property in the constructor''s signature or we can only define that the constructor
    accepts the parameters of the given types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create a new instance of the `Developer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'During compilation, TypeScript will throw an error telling us that **Property
    languages is private and only accessible inside class "Developer"**. Now, let''s
    see what''s going to happen if we create a new `Human` class and try to access
    its properties from outside its definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we''ll get the following two errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Property age is private and is only accessible inside class "Human"** and
    the **Property name is a protected and only accessible inside class "Human" and
    its subclasses**.'
  prefs: []
  type: TYPE_NORMAL
- en: However, if we try to access the `_name` property from inside the definition
    of `Developer`, the compiler won't throw any errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to get a better sense of what the TypeScript compiler will produce
    out of a type annotated class, let''s take a look at the JavaScript produced by
    the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting ECMAScript 5 will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The defined property is added directly to the objects instantiated by calling
    the constructor function with the operator `new`. This means that once the code
    is compiled, we can directly access the private members of the created objects.
    In order to wrap this up, access modifiers are added in the language in order
    to help us enforce better encapsulation and get compile-time errors in case we
    violate it.
  prefs: []
  type: TYPE_NORMAL
- en: Defining interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Subtyping** in programming languages allows us to treat objects in the same
    way based on the observation that they are specialized versions of a generic object.
    This doesn''t mean that they have to be instances of the same class of objects,
    or that they have complete intersection between their interfaces. The objects
    might have only a few common properties and still be treated the same way in a
    specific context. In JavaScript, we usually use duck typing. We may invoke specific
    methods for all the objects passed to a function based on the assumption that
    these methods exist. However, all of us have experienced the *undefined is not
    a function* error thrown by the JavaScript interpreter.'
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented programming and TypeScript come with a solution. They allow
    us to make sure our objects have similar behavior if they implement interfaces
    that declare the subset of the properties they own.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can define our interface `Accountable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can make sure both `Individual` and `Firm` implement this interface
    by doing as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In case we implement a given interface, we need to provide implementation for
    all the methods defined inside it, otherwise the TypeScript compiler will throw
    an error. The methods we implement must have the same signature as the ones declared
    in the interface definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript interfaces also support properties. In the `Accountable` interface,
    we can include a field called `accountNumber` with a type of string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We can define it in our class as a field or a getter.
  prefs: []
  type: TYPE_NORMAL
- en: Interface inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Interfaces may also extend each other. For example, we may turn our `Individual`
    class into an interface that has a social security number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Since interfaces support multiple inheritances, `Individual` may also extend
    the interface `Human` that has the `name` and `age` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Implementing multiple interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In case the class''s behavior is a union of the properties defined in a couple
    of interfaces, it may implement all of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we need to provide the implementation of all the methods declared
    inside the interfaces our class implements, otherwise the compiler will throw
    a compile-time error.
  prefs: []
  type: TYPE_NORMAL
- en: Further expressiveness with TypeScript decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In ES2015, we are able to decorate only classes, properties, methods, getters,
    and setters. TypeScript takes this further by allowing us to decorate functions
    or method parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: However, the parameter decorators should not alter any additional behavior.
    Instead, they are used to generate metadata. The most typical use case of these
    decorators is the dependency injection mechanism of Angular 2.
  prefs: []
  type: TYPE_NORMAL
- en: Writing generic code by using type parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the beginning of the section on using static typing, we mentioned the type
    parameters. In order to get a better understanding of them, let''s begin with
    an example. Let''s suppose we want to implement the classical data-structure `BinarySearchTree`.
    Let''s define its interface using a class without applying any method implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we defined a class called `Node`. The instances of
    this class represent the individual nodes in our tree. Each `node` has a left
    and a right child node and a value of the type `any`; we use `any` in order to
    be able to store data of `any` type inside our nodes and respectively inside `BinarySearchTree`.
  prefs: []
  type: TYPE_NORMAL
- en: Although the earlier implementation looks reasonable, we're giving up on using
    the most important feature that TypeScript provides—static typing. By using `any`
    as a type of the value field inside the `Node` class, we can't take complete advantage
    of the compile-time type checking. This also limits the features that IDEs and
    text editors provide when we access the `value` property of the instances of the
    `Node` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript comes with an elegant solution that is already widely popular in
    the world of static typing—type parameters. Using generics, we can parameterize
    the classes we create with the type parameters. For example, we can turn our `Node`
    class into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '`Node<T>` indicates that this class has a single type parameter called `T`
    that is used somewhere inside the class''s definition. We can use `Node` by doing
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we created three nodes: `numberNode`, `stringNode`,
    and another node of the type `Node<number>`, assigning its value to the right
    child of `numberNode`. Notice that since `numberNode` is of the type `Node<number>`,
    we can set its value to `42`, but we can''t use the string `"42"`. The same is
    applicable to its left child. In the definition, we''ve explicitly declared that
    we want the left and right children to be of the type `Node<number>`. This means
    that we cannot assign values of the type `Node<string>` to them; that''s why we
    get the second compile-time error.'
  prefs: []
  type: TYPE_NORMAL
- en: Using generic functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another typical use of generics is for defining functions that operate over
    a set of types. For example, we may define an `identity` function that accepts
    an argument of type `T` and returns it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'However, in some cases, we may want to use only the instances of the types
    that have some specific properties. For achieving this, we can use an extended
    syntax that allows us to declare subtypes of the types that should be the type
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: For example, here, we defined an interface called `Comparable`. It has a single
    operation called `compare`. The classes that implement the interface `Comparable`
    need to implement the operation `compare`. When `compare` is called with a given
    argument, it returns `1` if the target object is bigger than the passed argument,
    `0` if they are equal, and `-1` if the target object is smaller than the passed
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: Having multiple type parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TypeScript allows us to use multiple type parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we can create an instance of the class `Pair<K, V>` using the
    following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Writing less verbose code with TypeScript's type inference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Static typing has a number of benefits; however, it makes us write a more verbose
    code by adding all the required type annotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, the TypeScript''s compiler is able to guess the types of expressions
    inside our code, for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we defined a variable `answer` and we assigned the
    value `42` to it. Since TypeScript is statically typed and the type of a variable
    cannot change once declared, the compiler is smart enough to guess that the type
    of `answer` is `number`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we don''t assign a value to a variable within its definition, the compiler
    will set its type to `any`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet will compile without any compile-time errors.
  prefs: []
  type: TYPE_NORMAL
- en: Best common type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, the type inference could be a result of several expressions. Such
    is the case when we assign a heterogeneous array to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the type of `x` will be `any[]`. However, suppose we have the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The type of `x` will then be `number[]`, since the type `Number` is a subtype
    of `Null`.
  prefs: []
  type: TYPE_NORMAL
- en: Contextual type inference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Contextual typing occurs when the type of an expression is implied from its
    location, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the type of the argument of the callback `e` is *guessed* by the
    compiler based on the context in which it is used. The compiler understands what
    the type of `e` is based on the call of `addEventListener` and the arguments passed
    to the method. In case we were using a keyboard event (`keydown`, for example),
    TypeScript would have been aware that `e` is of the type `KeyboardEvent`.
  prefs: []
  type: TYPE_NORMAL
- en: Type inference is a mechanism that allows us to write less verbose code by taking
    advantage of the static analysis performed by TypeScript. Based on the context,
    TypeScript's compiler is able to guess the type of a given expression without
    explicit definition.
  prefs: []
  type: TYPE_NORMAL
- en: Using ambient type definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although static typing is amazing, most of the frontend libraries we use are
    built with JavaScript, which is dynamically typed. Since we'd want to use TypeScript
    in Angular 2, not having compile-typing in the code that uses external libraries
    is a big issue; it prevents us from taking advantage of the compile-time type-checking.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript was built keeping these points in mind. In order to allow the TypeScript
    compiler to take care of what it does best, we can use the so-called ambient type
    definitions. They allow us to provide external type definitions of the existing
    JavaScript libraries. This way, they provide hints to the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Using predefined ambient type definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Fortunately, we don''t have to create ambient type definitions for all JavaScript
    libraries and frameworks we use. The community and/or the authors of these libraries
    have already published such definitions online; the biggest repository resides
    at: [https://github.com/DefinitelyTyped/DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped).
    There''s also a tool for managing them called **typings**. We can install it using
    `npm` by the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The configuration of typings is defined in a file called `typings.json` and
    all installed ambient typings, by default, will be in the directory`./typings`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to create `typings.json` file with basic configuration use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'We can install new type definition using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will download the type definitions for AngularJS 1.x and
    save them in both `browser/ambient/angular/angular.d.ts` and `main/ambient/angular/angular.d.ts`
    under the `typings` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having both `main/ambient` and `browser/ambient` directories is due to preventing
    type collisions. For instance, if we use TypeScript in both the `backend/build`
    of our project, and its frontend there could be introduced duplications of type
    definitions which will lead to compile-time errors. By having two directories
    for the ambient typings of the individual parts of the project, we can include
    only one of them using respectively `main.d.ts` and `browser.d.ts`. For further
    information on typings you can visit the official repository of the project on
    GitHub [https://github.com/typings/typings](https://github.com/typings/typings).
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to download a type definition and add entry for it inside `typings.json`
    you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the preceding command your `typings.json` file should look similar
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in order to use AngularJS 1.x with TypeScript create `app.ts` and enter
    the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile `app.ts` use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The TypeScript compile will output the compiled content into `app.js`. In order
    to add extra automation and invoke the TypeScript compiler each time you change
    any of the files in your project, you can use a task runner like gulp or grunt,
    or pass the `-w` option to `tsc`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since using the reference element for including type definitions is considered
    bad practice we can use a `tsconfig.json` file instead. There we can configure
    which directories need to be included in the compilation process by `tsc`. For
    more information visit [https://github.com/Microsoft/TypeScript/wiki/tsconfig.json](https://github.com/Microsoft/TypeScript/wiki/tsconfig.json).
  prefs: []
  type: TYPE_NORMAL
- en: Custom ambient type definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how everything works together, let''s take a look at an example.
    Suppose we have the following interface of a JavaScript library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'We have an object literal assigned to a variable called `DOM`. The object has
    the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`selectElements`: Accepts a single argument with type string and returns a
    set of DOM elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hide`: Accepts a DOM node as an argument and returns nothing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`show`: Accepts a `DOM` node as an argument and returns nothing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In TypeScript, the preceding definition would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that we can define our library''s interface as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Defining ts.d files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After we have the interface of our library, it will be easy to create the ambient
    type definition; we just have to create a file with an extension `ts.d` called
    `dom` and enter the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we defined the interface called `DOMLibraryInterface`
    and declared the variable `DOM` of the type `DOMLibraryInterface`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only thing left before being able to exploit static typing with our JavaScript
    library is including the external type definition in the script files we want
    to use our library in. We can do it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet hints the compiler on where to find the ambient type definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we peeked at the TypeScript language that is used for the implementation
    of Angular 2\. Although we can develop our Angular 2 applications using ECMAScript
    5, Google's recommendation is to use TypeScript in order to take advantage of
    the static typing it provides.
  prefs: []
  type: TYPE_NORMAL
- en: While exploring the language, we looked at some of the core features of ES2015
    and ES2016\. We explained the ES2015 and ES2016 classes, arrow functions, block
    scope variable definitions, destructuring, and modules. Since Angular 2 takes
    advantage of the ES2016 decorators and more accurately their extension in TypeScript,
    a section was dedicated to them.
  prefs: []
  type: TYPE_NORMAL
- en: After this, we took a look at how we can take advantage of static typing by
    using explicit type definitions. We described some of the built-in types in TypeScript
    and how we can define classes in the language by specifying access modifiers for
    their members. Our next stop was the interfaces. We ended our adventures in TypeScript
    by explaining the type parameters and the ambient type definitions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to start exploring Angular 2 in depth by using
    the framework's components and directives.
  prefs: []
  type: TYPE_NORMAL
