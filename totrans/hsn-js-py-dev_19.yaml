- en: Enter Webpack
  prefs: []
  type: TYPE_NORMAL
- en: So, you now have beautiful frontend and backend code. Great! It looks so pretty
    sitting there on your laptop… so what's the next step? Publishing it to the world!
    It sounds easy, but when we have advanced JavaScript usage, such as with React,
    there are a couple more steps we might want to take to ensure our code is running
    at peak efficiency, all dependencies are resolved, and everything is compatible
    with modern technologies. Additionally, download size is a major consideration,
    so let's explore webpack, a tool to help mitigate these concerns.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following points in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The need for bundling and modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using webpack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Be prepared to work with the code provided in the `Chapter-16` directory of
    the repository: [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-16](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-16).
    As we'll be working with command-line tools, also have your terminal or command-line
    shell available. We'll need a modern browser and a local code editor.
  prefs: []
  type: TYPE_NORMAL
- en: The need for bundling and modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ideally, everything will work seamlessly on a website, without the need for
    any additional steps to be taken. You take your source files, drop them on a web
    server, and voilà: a site. However, this isn''t always the case. For example,
    with React, we need to run `npm run build` to generate an output distribution
    directory for our project. We might also have other types of non-source files,
    such as SASS or TypeScript, which need to be converted into native file formats
    that the browser can understand.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what is a *module*? There''s the concept of **modular programming**, which
    takes large programs and separates them by concern and encapsulation (scope) into
    smaller, contained chunks called modules. The ideas behind modular programming
    are many: scope, abstraction, logical design, testing, and debugging. Similarly,
    a bundle is a chunk of code that a browser can easily use, usually constructed
    from one or more modules.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now here''s the fun part: *we''ve already worked with modules*! Let''s take
    a look at some Node.js code we wrote in [Chapter 11](cc19c3b4-fb3d-402d-8931-581def8a75e4.xhtml), *What
    is Node.js?:*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'On that very first line, we''re using a module called `readline`, which, if
    you recall from our program, will be used to take user input from the command
    line. We''ve also used them in React—any time we''ve needed to use `npm install`,
    we''re using the concept of modules. So why is this important? Let''s consider
    a standard `create-react-app` installation from scratch:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `npx` to create a new React project: `npx create-react-app sample-project`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Navigate into the directory and install the dependencies: `cd sample-project
    ; npm install`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the project with `npm start`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you remember, this gives us a very interesting start page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/321bf6f9-5ab4-4f32-80a8-923a814c5cbd.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.1 – The React start page
  prefs: []
  type: TYPE_NORMAL
- en: 'What are we really getting when we run `npm install`? Let''s take a look at
    our file structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Simple enough so far. However, in this listing, I''ve purposely excluded the
    `node_modules` directory. This has 18 files. Try running this command at the root
    directory of our project, which does not exclude that directory: `tree`. Enjoy
    watching the flurry of lines—32,418 files! Where did all of those come from? Our
    friend, `npm install`!'
  prefs: []
  type: TYPE_NORMAL
- en: package.json
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our project''s structure is controlled, in part, by our `package.json` file
    to manage dependencies. Most bundlers, such as webpack, will leverage the information
    in this file to create our dependency graphs and bite-sized modules. Let''s take
    a look at it:'
  prefs: []
  type: TYPE_NORMAL
- en: '*package.json*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a standard, basic package file; it only contains six dependencies:
    half for testing and half for React. Now, here''s the fun part: each of those
    dependencies in turn has its own dependencies, which is how we end up with 32,400
    files in our `node_modules` directory alone. By using modules, we don''t have
    to hand-construct or manage dependencies; we can follow the DRY principles and
    leverage existing code that others (or we) have written in the form of modules.
    As we discussed when comparing Python and Node.js, `npm install` is similar to
    `pip install` in that we use packages in our Python program with the `import`
    keyword, while we use `require` in Node.js.'
  prefs: []
  type: TYPE_NORMAL
- en: When we use `npm install` to install a new package into our project, it will
    add an entry into `package.json`. This is a file where you'll want to be very
    careful if you make any edits. In general, you shouldn't need to make too many
    changes, and you especially should avoid making substantial changes to the dependencies.
    Leverage the `install` command for that.
  prefs: []
  type: TYPE_NORMAL
- en: Build pipelines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at what happens when we prepare our React project for deployment.
    Run `npm run build` and observe the output. You should see an output similar to
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you take a look inside your build directory, you''ll see nicely minified
    JavaScript files, packaged for efficient deployment. Here''s the fun part: `npm
    run build` *from* `create-react-app` *uses webpack under the hood!* The `create-react-app`
    setup handles these pieces for us. It''s a bit tricky to modify the innards of
    the `create-react-app` webpack setup, so let''s now look at using webpack directly
    beyond the use case of React.'
  prefs: []
  type: TYPE_NORMAL
- en: Using webpack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, webpack is one of many modular tools that can be used in your program.
    Additionally, unlike React scripts, it has use outside of React: it can be used
    as a bundler for many different types of applications. To get our hands dirty,
    let''s create a small, useless sample project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new directory and navigate into it: `mkdir webpack-example ; cd webpack-example`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ll be using NPM, so we need to initialize it. We''ll also accept the defaults:
    `npm init -y`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have to then install webpack: `npm install webpack webpack-cli --save-dev`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that we're using `--save-dev` here because we don't need webpack to be
    built into our production-level files. By using dev dependencies, we can help
    reduce our bundle size, a factor that can slow down applications if it bloats.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look in the `node_modules` directory here, you''ll see that we''ve already
    installed over 3.5 thousand files from our dependencies. Our project is fairly
    boring as it stands: we don''t have any content! Let''s fix that and make some
    files, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*src/index.html*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*src/index.js*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, very exciting and useful, right? If you open our index page in a browser,
    you''ll see what you would expect in the console. We''ll now introduce webpack
    into the mix:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the `package.json` `scripts` node to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Run `npm run dev`. You should see an output like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now go ahead and look in your newly created `dist` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you open `main.js`, you'll find it looks *quite* different than our `index.js`!
    That's webpack doing some under-the-hood work to make our first steps into modularization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wait. We went from one line of code to 100\. Why on earth is this better? Well,
    for this simple of an example it may not be, but humor me for a while longer.
    Let''s try `npm run build` and compare the output: `main.js` is now one line,
    minified.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking a look at our `package.json` file, we''ll see a few noteworthy pieces
    apart from the script node we manipulated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We see a `"main"` node that specifies an `index.js` to be used for our main
    entry point, or where webpack begins looking to catalog its dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three main concepts that are important to understand when using webpack:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Entry**: The place where webpack starts its work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Output**: The place where webpack will spit out its finished product. If
    we look at the output of the preceding test, we''ll see `main.js  3.79 KiB   
    main  [emitted]  main`. Instead of the phrase "spits out," webpack much more elegantly
    defines it as "emitting" its bundles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Loaders**: As mentioned, webpack can be used for a variety of different purposes;
    however, by default, webpack only really processes JavaScript and JSON files.
    So, we use *loaders* to do more work. We''ll use one in a minute to manipulate
    the `index.html` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The concepts of mode and plugins are also important, though a bit more self-explanatory:
    mode, as we saw when we added our scripts to `package.json`, defines whether we
    want development, production, or "none" for our environment optimizations. There''s
    more to mode than that, but for now, we won''t go crazy—webpack is quite complex,
    so a surface-level understanding is a good place to begin. Plugins basically do
    what loaders can''t. We''ll keep it simple, though, and now we''ll add a loader
    that understands HTML files. Brace yourself… the output isn''t *quite* what you''re
    thinking it will be:'
  prefs: []
  type: TYPE_NORMAL
- en: Run `npm install html-loader --save-dev`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We've now arrived at the point where we need a configuration file, so create
    `webpack.config.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter this inside `webpack.config.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify `index.js`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify `index.html` by changing the script tag as follows: `<script src="../dist/main.js"></script>`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Re-run `npm run dev` and then open that page in a browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we look at our console, we''ll see our HTML! Woo! Everything''s pretty much
    there, except our `<script>` tag says `"[Object object]"` in the `src`. Now you
    should be asking yourself: "what on earth did we just accomplish?".'
  prefs: []
  type: TYPE_NORMAL
- en: 'As it turns out, a loader *isn''t* what we want! It''s a common mistake to
    work with loaders when you want plugins, and vice versa. Let''s now unwind what
    we did and install an HTML plugin that *will* do what we expect: insert `index.html`
    into the `dist` directory with an optimized `main.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t actually want or need the HTML loader for this task: `npm uninstall
    html-loader`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install the right plugin: `npm install html-webpack-plugin --save-dev`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Completely replace the contents of `webpack.config.js` with this configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify `index.js` back to its original one line: `console.log(''hello'')`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the `<script>` tag from `src/index.html`. It will be built for us.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute `npm run dev`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, open `dist/index.html` in a browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That should be more to your liking and what you would expect by using webpack.
    Now, however, this is a very basic example, so let''s see whether we can do something
    fancier. Edit the files as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*src/index.html*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*src/index.js*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'For this example, we''re using Highcharts, a charting library. This is their
    boilerplate example, taken directly from their site; I haven''t done anything
    fancy with it except modified line 1 to `import Highcharts from ''highcharts''`.
    That implies we''re going to use a module, so let''s install it—`npm install highcharts`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this script to your `package.json` `scripts` node: `"watch": "webpack --watch
    -- mode development"`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `npm run watch`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Load `dist/index.html` in the browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/545d6bee-e61b-4a14-9ece-2c6a2a77a748.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.2 – Webpack with Highcharts
  prefs: []
  type: TYPE_NORMAL
- en: Much more interesting, don't you think? Also, take a moment to look at the `index_bundle.js`
    file and note the much larger file and minified code. If you edit a file in `src`,
    with `watch`, webpack will repackage the files on the fly for you. If you're using
    a live server that does hot reloads, such as with Visual Studio Code, it'll also
    refresh the page for you—handy for rapid development!
  prefs: []
  type: TYPE_NORMAL
- en: It's time to finally try what we've been building. Let's try building our project
    for deployment next.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying our project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve done a lot of development work so far, and now it''s time to try a production
    build of our project. Run `npm run build` and, well, it''s not quite so happy,
    is it? You should get some warnings like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: So, what is this trying to tell us? Remember when I was talking about bundle
    size impacting performance? Let's try to optimize this so that we no longer get
    these messages. We'll investigate a few development techniques to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Chunking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Simply put, chunking is the method of taking large files and splitting them
    apart into smaller chunks. We can do this part easily by adding this to our `webpack.config.js` file
    after our plugins node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, go ahead and build; it''ll be a *little* happier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It's still going to complain, unfortunately. We shaved 1.74 KB into a separate
    file, but we still have our `vendors` bundle sitting at 262 KB. If you look in
    `dist`, you'll now see the two `js` files as well as two `<script>` tags in the
    HTML.
  prefs: []
  type: TYPE_NORMAL
- en: The reason it's not splitting it further is that the vendor (Highcharts) bundle
    is pretty self-contained already, so we need to explore other ways to accomplish
    what we need. If we had a lot of our own code, however, it would probably be splitting
    it further into multiple chunks.
  prefs: []
  type: TYPE_NORMAL
- en: So, what's our next option? We tweak the optimization!
  prefs: []
  type: TYPE_NORMAL
- en: 'Try this one on for size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If you note, the options in this are much more explicit, including a maximum
    size for the chunks, reusing existing vendor chunks, and a minimum number of chunks.
    Let's try it.
  prefs: []
  type: TYPE_NORMAL
- en: No change, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try something different: modify `index.js` to use promises and **webpack
    hints** to break the Highcharts dependency into its own bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Our output from `npm run build` should now look more like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Well… that *still* didn't do what we wanted! While we have a separate chunk
    for Highcharts, it's still a large, monolithic file. So, what do we do?
  prefs: []
  type: TYPE_NORMAL
- en: Surrender
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Raise the white flag. Admit defeat.
  prefs: []
  type: TYPE_NORMAL
- en: Almost.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s where each vendor package may differ and each import will be unique;
    what we want to do is try to find the *smallest chunk* of our vendor library that
    suits our needs. In this case, importing all of Highcharts is creating a massive
    file. However, let''s take a look at `node_modules/highcharts`. Inside the `es-modules`
    directory, there''s an interesting file: `highcharts.src.js`. This is a more modular
    file of what we want, so let''s try importing it instead of the whole library
    at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now see what happens if we use `npm run build`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Aha! Much nicer! So, in this case, the answer was obtuse. Highcharts bundling
    can be unwound in order to add only specific pieces of the code. This *will not*
    work in all cases, especially where the source is not included; however, this
    is a course of approach for us at this time: pare down the included packages to
    the smallest needed set. Remember when we selectively included parts of libraries
    in React? The same idea holds true here.'
  prefs: []
  type: TYPE_NORMAL
- en: Deployment, finished
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now what do we do? All you really have to do is take the contents of your `dist`
    directory and put it on a web server for the world to see! Let your hard work
    be shown.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Webpack is our friend. It modularizes, minifies, chunks, and makes our code
    more efficient, as well as warning us when certain pieces aren't properly optimized.
    There are ways to silence these alerts, but in general, it's a good idea to listen
    to them and at least *try* to resolve them.
  prefs: []
  type: TYPE_NORMAL
- en: 'One burning question, though, that remains unanswered: doesn''t increasing
    the number of files downloaded increase the load time? This is a common misconception
    that''s hung around from the early days of the web: more files == more load time.
    The fact is, however, that multiple browsers can open many non-blocking streams
    simultaneously, allowing for a *more* efficient download than one huge file. Is
    this a solution for all multiple files? No: a CSS image sprite, for example, is
    still a more efficient use of image resources. For performance, we must toe a
    fine line on how to provide the best user experience, while combining that with
    the best developer experience. Entire books are written on this topic alone, so
    I won''t try to give you all the answers. I''ll just leave you with this:'
  prefs: []
  type: TYPE_NORMAL
- en: Optimize, optimize, optimize.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we''ll deal with a very important topic for all parts
    of programming: security.'
  prefs: []
  type: TYPE_NORMAL
