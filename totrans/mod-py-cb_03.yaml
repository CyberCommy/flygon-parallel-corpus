- en: Chapter 3. Function Definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll look at the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing functions with optional parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using super flexible keyword parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forcing keyword-only arguments with the * separator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing explicit types on function parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Picking an order for parameters based on partial functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing clear documentation strings with RST markup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing recursive functions around Python's stack limits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing reusable scripts with the script library switch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Function definitions are a way to decompose a large problem into smaller problems.
    Mathematicians have been doing this for centuries. It's also a way to package
    our Python programming into intellectually manageable chunks.
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at a number of function definition techniques in these recipes. This
    will include ways to handle flexible parameters and ways to organize the parameters
    based on some higher-level design principles.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also look at the Python 3.5 typing module and how we can create more formal
    annotations for our functions. We can start down the road toward using the `mypy`
    project for making more formal assertions about the data types in use.
  prefs: []
  type: TYPE_NORMAL
- en: Designing functions with optional parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we define a function, we often have a need for optional parameters. This
    allows us to write functions which are more flexible, and can be used in more
    situations.
  prefs: []
  type: TYPE_NORMAL
- en: We can also think of this as a way to create a family of closely-related functions,
    each with a slightly different collection of parameters – called the **signature**
    – but all sharing the same simple name. The idea of many functions sharing the
    same name can be a bit confusing. Therefore, we'll focus more on the idea of optional
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of optional parameters is the `int()` function. This has two forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int(str)` : For example, the value of `int(''355'')` has a value of `355`
    . In this case, we didn''t provide a value for the optional `base` parameter;
    the default value of `10` was used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int(str, base)` : For example, the value of `int(''0x163'', 16)` is `355`
    . In this case, we provided a value for the `base` parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A great many games rely on collections of dice. The casino game of *Craps* uses
    two dice. A game like *Zilch* (or *Greed* or *Ten Thousand* ) uses six dice. Variations
    on the game may use more.
  prefs: []
  type: TYPE_NORMAL
- en: It's handy to have a dice-rolling function that can handle all of these variations.
    How can we write a dice-simulator that works for any number of dice, but will
    use two as a handy default value?
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have two approaches to designing a function with optional parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**General to Particular** : We start by designing the most general solution
    and provide handy defaults for the most common case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Particular to General** : We start by designing several related functions.
    We then merge them into one general function that covers all of the cases, singling
    out one of the original functions to be the default behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Particular to General Design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When following the Particular to General strategy, we''ll design several individual
    functions and look for common features:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write one version of the function. We''ll start with the *Craps* game because
    it seems simplest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We defined a handy helper function, `die()` , which encapsulates a basic fact
    about what are sometimes called standard dice. There are five platonic solids
    that can be pressed into service, yielding four-sided, six-sided, eight-sided,
    twelve-sided, and twenty-sided dice. The six-sided die has a long history, starting
    as *Astragali* bones, which were easily trimmed into a six-sided cube.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of the underlying `die()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We've rolled two dice to show how the values combine for rolling larger piles
    of dice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our function for the game of *Craps* looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This shows some two-dice rolls for the game of *Craps* .
  prefs: []
  type: TYPE_NORMAL
- en: 'Write another version of the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We've used a generator expression to create a tuple object with six dice. We'll
    look at generator expressions in depth in [Chapter 8](text00088.html#page "Chapter 8. Functional
    and Reactive Programming Features") , *Functional And Reactive Programming Features*
    .
  prefs: []
  type: TYPE_NORMAL
- en: Our generator expression has a variable, `x` , which is ignored. It's also common
    to see this written as `tuple(die() for _ in range(6))` . The variable `_` is
    a valid Python variable name; this name can be used as a hint that we don't ever
    want to see the value of this variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of using the `zonk()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This shows us a roll of six individual dice. There's a short straight (1-5)
    as well as a pair of ones. In some versions of the game, this is a good scoring
    hand.
  prefs: []
  type: TYPE_NORMAL
- en: Locate the common features in the two functions. This may require some rewriting
    of the various functions to locate a common design. In many cases, we'll wind
    up introducing additional variables to replace constants or other assumptions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this case, we can generalize the creation of the two-tuple. Rather than
    hardwiring two evaluations of the `die()` function, we can introduce a generator
    expression based on `range(2)` that will evaluate the `die()` function twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This seems like more code than required for solving the specific two-dice problem.
    In the long run, using a single general function means that we can eliminate a
    number of specific functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Merge the two functions. This will often involve exposing a variable that had
    previously been a constant or other hardwired assumption:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This provides a general function that covers the needs of both *Craps* and
    *Zonk* :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Identify the most common use case, and make this the default value for any
    parameters that were introduced. If our most common simulation was *Craps* , we
    might do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now we can simply use `dice()` for *Craps* . We'll need to use `dice(6)` for
    *Zonk* .
  prefs: []
  type: TYPE_NORMAL
- en: General to Particular design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When following the General to Particular strategy, we''ll identify all of the
    needs first. We''ll often do this by introducing variables into the requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Summarize the requirements for dice-rolling. We might have a list like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Craps* : two dice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First roll in *Zonk* : six dice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Subsequent rolls in *Zonk* : one to six dice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This list of requirements shows a common theme of rolling *n* dice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rewrite the requirements with an explicit parameter in place of any literal
    value. We''ll replace all of our numbers with a parameter, *n* , and show the
    values for this new parameter that we''ve introduced:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Craps* : *n* dice, where *n = 2* .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First roll in *Zonk* : *n* dice, where *n = 6* .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Subsequent rolls in *Zonk* : *n* dice, where *1 ≤ n ≤ 6* .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The goal here is to be absolutely sure that all of the variations really have
    a common abstraction. In more complex problems, something that seems similar may
    not have a common specification.
  prefs: []
  type: TYPE_NORMAL
- en: We want to be sure, also, that we've properly parameterized each of the various
    functions. In more complex cases, we may have values that don't really need to
    be parameterized; they can remain as constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the function that fits the general pattern:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the third case – subsequent rolls in *Zonk*  – we identified a constraint
    of *1 ≤ n ≤ 6* . We need to determine if this is a constraint that's part of our
    `dice()` function, or if this constraint is imposed on the dice by the simulation
    application that uses the `dice` function.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the constraint is incomplete. The rules for *Zonk* require that
    the dice which are not being rolled form some kind of scoring pattern. The constraint
    isn't merely that the number of dice is between one and six; the constraint is
    tied to the game state. There doesn't seem to be a good reason to tie the `dice()`
    function to the game state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Provide a default value for the most common use case. If our most common simulation
    was *Craps* , we might do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now we can simply use `dice()` for *Craps* . We'll need to use `dice(6)` for
    *Zonk* .
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python''s rules for providing parameter values are very flexible. There are
    several ways to assure that each parameter has a value. We can think of it working
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Set each parameter to any provided default value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For arguments without names, the argument values are assigned to the parameters
    by position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For arguments with names – for example, `dice(n=2)`  – the parameter values
    are assigned using the name. It's an error to assign a parameter both by position
    and by name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If any parameter doesn't have a value, this is an error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These rules allow us to provide defaults as needed. They also allow us to mix
    positional values with named values. The presence of a default value is what makes
    a parameter optional.
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of optional parameters stems from two considerations:'
  prefs: []
  type: TYPE_NORMAL
- en: Can we parameterize the processing?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What's the most common argument value for that parameter?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing parameters into a process definition can be challenging. In some
    cases, it helps to have code so that we can replace literal values (such as 2
    or 6) with a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, however, the literal value doesn't need to be replaced with a
    parameter. It can be left as a literal value. We don't always want to replace
    every literal with a parameter. Our `die()` function, for example, has a literal
    value of 6 because we're only interested in standard, cubic dice. This isn't a
    parameter because we don't see a need to make a more general kind of die.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we want to be very thorough, we can write functions that are specialized
    versions of our more generalized function. These functions can simplify an application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Our application features – `craps()` and `zonk()` – depend on a general function,
    `dice()` . This, in turn, depends on another function, `die()` . We'll revisit
    this idea in the *Picking an order for parameters based on partial functions*
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Each layer in this stack of dependencies introduces a handy abstraction that
    saves us from having to understand too many details. This idea of layered abstractions
    is sometimes called **chunking** . It's a way of managing complexity by isolating
    the details.
  prefs: []
  type: TYPE_NORMAL
- en: A common extension to this design pattern is to provide parameters at multiple
    levels in this hierarchy of functions. If we want to parameterize the `die()`
    function, we'll be providing parameters to both `dice()` and `die()` .
  prefs: []
  type: TYPE_NORMAL
- en: 'For this more complex parameterization, we''ll need to introduce more parameters
    with default values into our hierarchy. We''ll start by adding a parameter to
    `die()` . This parameter must have a default value so that we don''t break any
    of our existing test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After introducing this parameter at the bottom of the stack of abstractions,
    we''ll need to provide this parameter to higher-level functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have many ways of using the `dice()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'All default values: `dice()` covers *Craps* nicely.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All positional arguments: `dice(6, 6)` would cover *Zonk* .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A mixture of positional and named arguments: The positional values must be
    provided first because the order matters. For example, `dice(2, sides=8)` would
    cover a game that uses two eight-sided dice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All named arguments: `dice(sides=4, n=4)` this would handle the case where
    we needed to emulate rolling four tetrahedral dice. When using all named arguments,
    order doesn''t matter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this example, our stack of functions only has two layers. In a more complex
    application, we may have to introduce parameters at many layers in a hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll extend some of these ideas in the *Picking an order for parameters based
    on partial functions* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've made use of optional parameters that involve immutable objects. In this
    recipe, we focused on numbers. In [Chapter 4](text00048.html#page "Chapter 4. Built-in
    Data Structures – list, set, dict") , *Built-in Data Structures – list, set, dict*
    , we'll look at mutable objects, which have an internal state that can be changed.
    In the *Avoiding mutable default values for function parameters* recipe, we'll
    look at some additional considerations that are important for designing functions
    that have optional values that are mutable objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using super flexible keyword parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some design problems involve solving a simple equation for one unknown given
    enough known values. For example, rate, time, and distance have a simple linear
    relationship. We can solve for any one given the other two. Here are the three
    rules that we can use as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '*d = r* × *t*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*r = d / t*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*t = d / r*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When designing electrical circuits, for example, a similar set of equations
    is used based on Ohm's Law. In that case, the equations tie together resistance,
    current, and voltage.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, we want to provide a simple, high-performance software implementation
    that can perform any of the three different calculations based on what's known
    and what's unknown. We don't want to use a general algebraic framework; we want
    to bundle the three solutions into a simple, efficient function.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll build a single function that can solve a **Rate-Time-Distance** ( **RTD**
    ) calculation by embodying all three solutions given any two known values. With
    minor variable name changes, this applies to a surprising number of real-world
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: There's a trick here. We don't necessarily want a single value answer. We can
    slightly generalize this by creating a small Python dictionary with the three
    values in it. We'll look more at dictionaries in [Chapter 4](text00048.html#page
    "Chapter 4. Built-in Data Structures – list, set, dict") , *Built-in Data Structures –
    list, set, dict* .
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use the `warnings` module instead of raising an exception when there''s
    a problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes it is more helpful to produce a result that is doubtful than to stop
    processing.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Solve the equation for each of the unknowns. We''ve shown that previously for
    *d = r * t* , the RTD calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads to three separate expressions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: distance = rate * time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: rate = distance / time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: time = distance / rate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Wrap each expression in an `if` statement based on one of the values being
    `None` when it''s unknown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Refer to the *Designing complex if...elif chains* recipe from [Chapter 2](text00027.html#page
    "Chapter 2. Statements and Syntax") , *Statements and Syntax* , for guidance on
    designing these complex `if...elif` chains. Include a variation on the `else`
    crash option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Build the resulting dictionary object. In simple cases, we can use the `vars()`
    function to simply emit all of the local variables as a resulting dictionary.
    In some cases, we may have local variables we don''t want to include; in that
    case, we''ll need to build the dictionary explicitly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Wrap all of this as a function using keyword parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the resulting function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This shows us that going 31.2 nautical miles at a rate of 6 knots will take
    5.2 hours.
  prefs: []
  type: TYPE_NORMAL
- en: 'For nicely formatted output, we might do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: To break up the long string, we used the *Designing complex if...elif chains*
    recipe from [Chapter 2](text00027.html#page "Chapter 2. Statements and Syntax")
    , *Statements and Syntax* .
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because we've provided default values for all of the parameters, we can provide
    argument values for two of the three parameters, and the function can then solve
    for the third parameter. This saves us from having to write three separate functions.
  prefs: []
  type: TYPE_NORMAL
- en: Returning a dictionary as the final result isn't essential to this. It's simply
    handy. It allows us to have a uniform result no matter which parameter values
    were provided.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have an alternative formulation for this, one that involves more flexibility.
    Python functions have an *all other keywords* parameter, prefixed with `**` .
    It is often shown like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Any additional keyword arguments are collected into a dictionary that is provided
    to the `**keywords` parameter. We can then call this function with extra parameters.
    Evaluate this function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll then see that the value of the `keywords` parameter is a dictionary
    object with the value of `{''something_else'': 60}` . We can then use ordinary
    dictionary processing techniques on this structure. The keys and values in this
    dictionary are the names and values provided when the function was evaluated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can leverage this and insist that all arguments be provided with keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This version uses the dictionary `get()` method to find a given key in the dictionary.
    If the key is not present, a default value of `None` is provided.
  prefs: []
  type: TYPE_NORMAL
- en: (Returning a default of `None` is the default behavior of the `get()` method.
    Our example contains some redundancy to clarify the processing. For some very
    complex situations, we might have defaults other than `None` .)
  prefs: []
  type: TYPE_NORMAL
- en: This has the potential advantage of being slightly more flexible. It has the
    potential disadvantage of making the actual parameter names very hard to discern.
  prefs: []
  type: TYPE_NORMAL
- en: We can follow the *Writing Clear documentation strings with RST markup* recipe
    and provide a good docstring. It seems somehow better, though, to provide the
    parameter names explicitly as part of the Python code rather than implicitly through
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll look at documentation of functions in the *Writing* *Clear documentation
    strings with RST markup* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](image/614271.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Forcing keyword-only arguments with the * separator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some situations where we have a large number of positional parameters
    to a function. Perhaps we've followed the *Designing functions with optional parameters*
    recipe and this leads us to design a function with so many parameters that it
    gets confusing.
  prefs: []
  type: TYPE_NORMAL
- en: Pragmatically, a function with more than about three parameters can be confusing.
    A great deal of conventional mathematics seems to focus on one and two parameter
    functions. There don't seem to be too many common mathematical operators that
    involve three or more operands.
  prefs: []
  type: TYPE_NORMAL
- en: When it gets difficult to remember the required order for the parameters, there
    are too many parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll look at a function that has a large number of parameters. We'll use a
    function which prepares a wind-chill table and writes the data to a CSV format
    output file.
  prefs: []
  type: TYPE_NORMAL
- en: We need to provide a range of temperatures, a range of wind speeds, and information
    on the file we'd like to create. This is a lot of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic formula is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*T[wc]* ( *T[a] , V* ) = 13.12 + 0.6215 *T[a]* - 11.37 *V* ^(0.16) + 0.3965
    *T[a] V* ^(0.16)'
  prefs: []
  type: TYPE_NORMAL
- en: The wind chill temperature, *T[wc]* , is based on the air temperature, *T[a]*
    , in degrees *C* , and the wind speed, *V* , in KPH.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Americans, this requires some conversions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Convert from °F to °C: *C* = 5( *F* -32) / 9'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Convert windspeed from MPH, *V[m]* , to KPH, *V[k]* : *V[k] = V[m]* × 1.609344'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The result needs to be converted from °C back to °F: *F* = 32 + *C* (9/5)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We won't fold these into this solution. We'll leave that as an exercise for
    the reader.
  prefs: []
  type: TYPE_NORMAL
- en: 'One approach for creating a wind-chill table is to create something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We've opened an output file using the `with` context. This follows the *Managing
    a context using the with statement* recipe in [Chapter 2](text00027.html#page
    "Chapter 2. Statements and Syntax") , *Statements and Syntax* . Within this context,
    we've created a write for the CSV output file. We'll look at this in more depth
    in [Chapter 9](text00099.html#page "Chapter 9. Input/Output, Physical Format,
    and Logical Layout") , *Input/Output, Physical Format, Logical Layout* .
  prefs: []
  type: TYPE_NORMAL
- en: We've used an expression, `[None]+list(range(start_T, stop_T, step_T))` , to
    create a heading row. This expression includes a list literal and a generator
    expression that builds a list. We'll look at lists in [Chapter 4](text00048.html#page
    "Chapter 4. Built-in Data Structures – list, set, dict") , *Built-in Data Structures –
    list, set, dict* . We'll look at the generator expression in [Chapter 8](text00088.html#page
    "Chapter 8. Functional and Reactive Programming Features") , *Functional and Reactive
    Programming Features* .
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, each cell of the table is built by a generator expression, `[Twc(T,
    V) for T in range(start_T, stop_T, step_T)]` . This is a comprehension that builds
    a list object. The list consists of values computed by the wind-chill function,
    `Twc()` . We provide the wind velocity based on the row in the table. We provide
    a temperature based on the column in the table.
  prefs: []
  type: TYPE_NORMAL
- en: While the details involve forward-looking sections, the `def` line presents
    a problem. This `def` line is very complex.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem with this design is that the `wind_chill()` function has seven
    positional parameters. When we try to use this function, we wind up with code
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: What are all those numbers? Is there something we can do to help explain what
    this line of code means?
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we have a large number of parameters, it helps to use keyword arguments
    instead of positional arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python 3, we have a technique that mandates the use of keyword arguments.
    We can use the `*` as a separator between two groups of parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: Before the `*` , we list the argument values that can be *either* positional
    or named by keyword. In this example, we don't have any of these parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the `*` , we list the argument values that must be given with a keyword.
    For our example, this is all of the parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For our example, the resulting function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'When we try to use the confusing positional parameters, we''ll see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We must use the function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This use of mandatory keyword parameters forces us to write a clear statement
    each time we use this complex function.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `*` character has two meanings in the definition of a function:'
  prefs: []
  type: TYPE_NORMAL
- en: It's used as a prefix for a special parameter that receives all the unmatched
    positional arguments. We often use `*args` to collect all of the positional arguments
    into a single parameter named `args` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's used by itself, as a separator between parameters that may be applied positionally
    and parameters which must be provided by keyword.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `print()` function exemplifies this. It has three keyword-only parameters
    for the output file, the field separator string, and the line end string.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can, of course, combine this technique with default values for the various
    parameters. We might, for example, make a change to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use this function in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a way to print the table on the console:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a way to write to a file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We've changed the approach here, to one which is slightly more generalized.
    This follows the *Designing functions with optional parameters* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Picking an order for parameters based on partial functions*  recipe
    for another application of this technique
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing explicit types on function parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Python language allows us to write functions (and classes) which are entirely
    generic with respect to data type. Consider this function as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This follows three recipes shown earlier: *Using super flexible keyword parameters*
    , *Forcing keyword-only arguments with the * separator* from this chapter, and
    *Designing complex if...elif chains* from [Chapter 2](text00027.html#page "Chapter 2. Statements
    and Syntax") , *Statements and Syntax* .'
  prefs: []
  type: TYPE_NORMAL
- en: This function will work for argument values of any numeric type. Indeed, it
    will work for any data structure that implements the `+` , `-` , `*` , and `/`
    operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are times when we do not want our functions to be completely generic.
    In some cases, we would like to make some stronger assertions about data types.
    While we sometimes care about the data type, we do not want to write a lot of
    code that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This introduces performance overhead of an extra `assert` statement. It also
    clutters our programs with a statement that – generally – should be restating
    the obvious.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we can''t rely on docstrings for testing purposes. Here''s the
    recommended style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The docstring doesn't allow any automated testing to confirm that the documentation
    actually matches the code. The two could disagree with each other.
  prefs: []
  type: TYPE_NORMAL
- en: What we want are hints about the type of data involved that can be used for
    testing and confirmation, but don't interfere with performance. How can we provide
    meaningful type hints?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll implement a version of the `temperature()` function. We''ll need two
    modules that will help us provide hints regarding the data types for parameters
    and return values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We've opted to import all of the names from the `typing` module. If we're going
    to supply type hints, we want them to be terse. It's awkward having to write `typing.List[str]`
    . We prefer to omit the module name.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also need to install the latest version of `mypy` . This project is undergoing
    rapid development. Rather than use the `pip` program to get a copy from PyPI,
    it's better to download the latest version directly from the GitHub repository,
    [https://github.com/JukkaL/mypy](https://github.com/JukkaL/mypy) .
  prefs: []
  type: TYPE_NORMAL
- en: The instructions say that, *Currently, the version of mypy on PyPI is not compatible
    with Python 3.5\. If you run Python 3.5 install directly from git* .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `mypy` tool can be used to analyze our Python programs to determine if the
    type hints match the actual code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python 3.5 introduces type hints to the language. We can use them in three
    places: function parameters, function returns, and type hint comments:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a handy type for a variety of numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Ideally, we'd like to use the abstract `Number` class in the numbers module.
    Currently, this module doesn't have a formal type specification available, so
    we'll define our own expectation for `Number` . This definition is a union of
    several numeric types. Ideally, a future release of `mypy` or Python will include
    the needed definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Annotate arguments to functions like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We've added `:` and a type hint as part of the parameter. In this case, we're
    using our own type definition of `Number` to state that any number is allowed
    here. We've wrapped this with the `Optional[]` type operation to state that the
    argument value can be either a `Number` or `None` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Annotate return values from functions like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We've added `->` and a type hint for the return value of this function. In this
    case, we've stated that the result will be a dictionary object with keys that
    are strings, `str` , and values that are numbers using our type definition of
    `Number` .
  prefs: []
  type: TYPE_NORMAL
- en: The `typing` module introduces the type hint names such as `Dict` that we use
    to explain the results of a function. This is different from the `dict` class
    which actually builds objects. The `typing.Dict` is merely a hint.
  prefs: []
  type: TYPE_NORMAL
- en: 'If necessary, we can add type hints as comments in assignment and `with` statements.
    These are rarely needed, but may clarify a long, complex series of statements.
    If we wanted to add them, the annotations could look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve added `# type: Dict[str, Number]` on the statement that builds the final
    dictionary object.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The type information we've added are called **hints** . They're not requirements
    that are somehow checked by the Python compiler. They're not checked at runtime
    either.
  prefs: []
  type: TYPE_NORMAL
- en: The type hints are used by a separate program, `mypy` . See [http://mypy-lang.org](http://mypy-lang.org)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: The `mypy` program examines the Python code, including the type hints. It applies
    some formal reasoning and inference techniques to determine if the various type
    hints will be `true` for any data that the Python program can process.
  prefs: []
  type: TYPE_NORMAL
- en: For larger and more complex programs, the output from `mypy` will include warnings
    and errors that describe potential problems with either the code itself, or the
    type hints decorating the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here''s a mistake that''s easy to make. We''ve assumed that our
    function returns a single number. Our return statement, however, doesn''t match
    our expectation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run `mypy` , we''ll see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We can see our `Number` type name was expanded to `Union[builtins.int, builtins.float,
    builtins.complex, decimal.Decimal]` in the error message. More importantly, we
    can see that line 37, the `return` statement, doesn't match the function definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given this error, we need to either fix the return or the definition to be
    sure that the expected type and the actual type match. It''s not clear which is
    *right* . Either of these could be the intent:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Compute and return a single value: This means that there would need to be two
    `return` statements depending on which value was computed. In this case, there''s
    no reason to build the `result` dictionary object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Return the dictionary object: This means we need to correct the `def` statement
    to have the proper return type. Changing this may spread ripples of change to
    other functions that expect `temperature` to return a instance of `Number` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The extra syntax for parameters and return values has no real impact on runtime,
    and only a very small cost when the source code is first compiled into byte code.
    They are—after all—merely hints.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When using built-in types, we can often create elaborate structures. We might,
    for example, have a dictionary that maps tuples of three integers to lists of
    strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: If this is the result of a function, how do we describe this?
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll be creating a fairly complex type expression that summarizes each layer
    of the structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We've summarized a dictionary that maps one type, `Tuple[int, int, int]` , as
    the key to another type, `List[str]` , as the value. This captures how several
    built-in types can be combined to build complex data structures.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we've treated the tuple of three integers as an otherwise anonymous
    tuple. In many cases, it's not merely a generic tuple, it's actually an RGB color
    which is modeled as a tuple. Perhaps the list of strings is really a line of text
    from a longer document that's been split on spaces into words.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we should do something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Creating our own application-specific type names can greatly clarify the processing
    that's being performed using the built-in collection types.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [https://www.python.org/dev/peps/pep-0484/](https://www.python.org/dev/peps/pep-0484/)
    for more information on type hints.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See [https://github.com/JukkaL/mypy](https://github.com/JukkaL/mypy) for the
    current `mypy` project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See [http://www.mypy-lang.org](http://www.mypy-lang.org) for documentation on
    how `mypy` works with Python 3.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Picking an order for parameters based on partial functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we look at complex functions, we'll sometimes see a pattern to the ways
    we use the function. We might, for example, evaluate a function many times with
    some argument values that are fixed by context, and other argument values that
    are changing with the details of the processing.
  prefs: []
  type: TYPE_NORMAL
- en: It can simplify our programming if our design reflects this concern. We'd like
    to provide a way to make the common parameters slightly easier to work with than
    the uncommon parameters. We'd also like to avoid having to repeat the parameters
    that are part of a larger context.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll look at a version of the haversine formula. This computes distances
    between points on the surface of the Earth, using the latitude and longitude coordinates
    of that point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](Image00005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*c* = 2 *arc sin(√a)*'
  prefs: []
  type: TYPE_NORMAL
- en: The essential calculation yields the central angle, *c* , between two points.
    The angle is measured in radians. We convert it into distance by multiplying by
    the Earth's mean radius in some units. If we multiply the angle *c* by a radius
    of 3,959 miles, the distance, we'll convert the angle to miles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an implementation of this function. We''ve included type hints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note on the doctest example:'
  prefs: []
  type: TYPE_NORMAL
- en: The doctest example uses an earth radius with an extra decimal point that's
    not used elsewhere. This is so that this example matches other examples online.
  prefs: []
  type: TYPE_NORMAL
- en: The earth isn't spherical. Around the equator, a more accurate radius is 6378.1370
    km. Across the poles, the radius is 6356.7523 km. We're using common approximations
    in the constants.
  prefs: []
  type: TYPE_NORMAL
- en: The problem we often have is that we're generally working in a single context,
    and we will be providing the same value for `R` all the time. If, for example,
    we're working in a marine environment, we'd always be using `R = NM` to get nautical
    miles.
  prefs: []
  type: TYPE_NORMAL
- en: There are two common approaches to providing a consistent value for an argument.
    We'll look at both.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In some cases, an overall context will establish a variable for a parameter.
    The value will rarely change. There are several common approaches to providing
    a consistent value for an argument. These involve wrapping the function in another
    function. There are several approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: Wrap the function in a new function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a partial function. This has two further refinements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can provide keyword parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Or we can provide positional parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll look at each of these in separate variations in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping a function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can provide contextual values by wrapping a general function in a context-specific
    wrapper function:'
  prefs: []
  type: TYPE_NORMAL
- en: Make some parameters positional and some parameters keywords. We want the contextual
    features—the ones which change rarely—to be keywords. The parameters which change
    more frequently should be left as positional. We can follow the *Forcing keyword-only
    arguments with the * separator* recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We might change the basic haversine function to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We inserted the `*` to separate parameters into two groups. The first group
    can have arguments supplied either by position or by keyword. The second group,
    – `R` , in this case – must be given by keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then write a wrapper function the will apply all of the positional arguments
    unmodified. It will supply the additional keyword argument as part of the long-running
    context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We've the `*args` construct in the function declaration to accept all positional
    argument values in a single tuple, `args` . We've also `*args` when evaluating
    the `haversine()` function to expand the tuple into all of the positional argument
    values to this function.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a partial function with keyword parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A partial function is a function which has some of the argument values supplied.
    When we evaluate a partial function, we''re mixing the previously supplied parameters
    with additional parameters. One approach is to use keyword parameters, similar
    to wrapping a function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can follow the *Forcing keyword-only arguments with the * separator* recipe.
    We might change the basic haversine function to look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a partial function using the keyword parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `partial()` function builds a new function from an existing function and
    a concrete set of argument values. The `nm_haversine()` function has a specific
    value for `R` provided when the partial was built.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this like we''d use any other function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We get an answer in nautical miles, allowing us to do boating-related calculations
    without having to patiently check that each time we used the `haversine()` function
    it had `R=NM` as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a partial function with positional parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A partial function is a function which has some of the argument values supplied.
    When we evaluate a partial function, we're supplying additional parameters. An
    alternative approach is to use positional parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to use `partial()` with positional arguments, we''re constrained
    to providing the leftmost parameter values in the partial definition. This leads
    us to think of the first few arguments to a function as candidates for being hidden
    by a partial function or a wrapper:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We might change the basic `haversine` function to look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a partial function using the positional parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The `partial()` function builds a new function from an existing function and
    a concrete set of argument values. The `nm_haversine()` function has a specific
    value for the first parameter, `R` , provided when the partial was built.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this like we''d use any other function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We get an answer in nautical miles, allowing us to do boating-related calculations
    without having to patiently check that each time we used the `haversine()` function
    it had `R=NM` as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The partial function is—essentially—identical to the wrapper function. While
    it saves us a line of code, it has a more important purpose. We can build partials
    freely in the middle of other, more complex pieces of a program. We don't need
    to use a `def` statement for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that creating partial functions leads to a few additional considerations
    when looking at the order for positional parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: When we use `*args` , it must be last. This is a language requirement. It means
    that the parameters in front of this can be identified specifically, all the rest
    become anonymous and can be passed – *en masse* – to the wrapped function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The leftmost positional parameters are easiest to provide a value when creating
    a partial function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These two considerations lead us to look at the leftmost argument as being
    more of a context: these are expected to change rarely. The rightmost parameters
    provide details and change frequently.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There''s a third way to wrap a function—we can also build a `lambda` object.
    This will also work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that a `lambda` object is a function that''s been stripped of name and
    body. It''s reduced to just two essentials:'
  prefs: []
  type: TYPE_NORMAL
- en: The parameter list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single expression that is the result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `lambda` cannot have any statements. If we need statements, we need to use
    the `def` statement to create a definition that includes a name and a body with
    multiple statements.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll also look at further extending this design in the *Writing reusable scripts
    with the script library switch * recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing clear documentation strings with RST markup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we clearly document what a function does? Can we provide examples? Of
    course we can, and we really should. In the *Including descriptions and documentation*
     in [Chapter 2](text00027.html#page "Chapter 2. Statements and Syntax") , *Statements
    and Syntax* and *Writing clear documentation strings with RST markup*  recipes,
    we looked at some essential documentation techniques. Those recipes introduced
    **ReStructuredText** ( **RST** ) for module docstrings.
  prefs: []
  type: TYPE_NORMAL
- en: We'll extend those techniques to write RST for function docstrings. When we
    use a tool such as Sphinx, the docstrings from our function will become elegant-looking
    documentation that describes what our function does.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Forcing keyword-only arguments with the * separator* recipe, we looked
    at a function that had a large number of parameters and another function that
    had only two parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a slightly different version of one of those functions, `Twc()` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We need to annotate this function with some more complete documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, we've got Sphinx installed to see the fruits of our labor. See [http://www.sphinx-doc.org](http://www.sphinx-doc.org)
    .
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll generally write the following things for a function description:'
  prefs: []
  type: TYPE_NORMAL
- en: Synopsis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anything else that seems meaningful
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s how we''ll create nice documentation for a function. We can apply a
    similar recipe for a function, or even a module:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the synopsis: A proper subject isn''t required—we don''t write *This
    function computes...* ; we start with *Computes...* . There''s no reason to overstate
    the context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the description with details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we used a little block of typeset math in our description. The
    `:math:` interpreted text role uses LaTeX math typesetting. If you have LaTeX
    installed, Sphinx will use that to prepare a little `.png` file with the math.
    If you want, Sphinx can use MathJax or JSMath to do JavaScript math typesetting
    instead of creating a `.png` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Describe the parameters: For positional parameters, it''s common to use `:param
    name: description` . Sphinx will tolerate a number of variations, but this is
    common.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For parameters which must be keywords, it''s common to use `:key name: description`
    . The word `key` instead of `param` shows that it''s a keyword-only parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two ways to include type information:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Python 3 type hints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using RST `:type name:` markup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We generally don't use both techniques. Type hints are a better idea than the
    RST `:type:` markup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Describe the return value using `:returns:` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two ways to include return type information:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Python 3 type hints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using RST `:rtype:` markup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We generally don't use both techniques. The RST `:rtype:` markup has been superseded
    by type hints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Identify the important exceptions that might be raised. Use the `:raises exception:`
    reason markup. There are several possible variations, but `:raises exception:`
    seems to be most popular:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Include a doctest test case, if possible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Write any additional notes and helpful information. We could add the following
    to the docstring:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: We've included a reference to a Wikipedia page that summarizes wind-chill calculations
    and has links to more detailed information.
  prefs: []
  type: TYPE_NORMAL
- en: We've also included a `.. math::` directive with the LaTeX formula that's used
    in the function. This will typeset nicely, providing a very readable version of
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information on docstrings, see the *Including descriptions and documentation*
     recipe in [Chapter 2](text00027.html#page "Chapter 2. Statements and Syntax")
    , *Statements and Syntax* . While Sphinx is popular, it isn't the only tool that
    can create documentation from the docstring comments. The pydoc utility that's
    part of the Python Standard Library can also produce good looking documentation
    from the docstring comments.
  prefs: []
  type: TYPE_NORMAL
- en: The Sphinx tool relies on the core features of RST processing in the `docutils`
    package. See [https://pypi.python.org/pypi/docutils](https://pypi.python.org/pypi/docutils)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: The RST rules are relatively simple. Most of the additional features in this
    recipe leverage the *interpreted text roles* of RST. Each of our `:param T:` ,
    `:returns:` , and `:raises ValueError:` constructs is a text role. The RST processor
    can use this information to decide on style and structure for the content. The
    style usually includes a distinctive font. The context might be an HTML **definition
    list** format.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In many cases, we'll also need to include cross-references among functions and
    classes. For example, we might have a function that prepares a wind-chill table.
    This function might have documentation that includes a reference to the `Twc()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sphinx will generate these cross-references using a special `:func:` text role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: We've used the `:func:`Twc`` to cross-reference one function in the RST documentation
    for a different function. Sphinx will turn these into proper hyperlinks.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the  *Including descriptions and documentation* and *Writing better RST
    markup in docstrings*  recipes in [Chapter 2](text00027.html#page "Chapter 2. Statements
    and Syntax") , *Statements and Syntax* ,  for other recipes that show how RST
    works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing recursive functions around Python's stack limits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some functions can be defined clearly and succinctly using a recursive formula.
    There are two common examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The factorial function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing recursive functions around Python''s stack limits](Image00006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The rule for computing Fibonacci numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing recursive functions around Python''s stack limits](Image00007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each of these involves a case that has a simple defined value and a case that
    involves computing the function's value based on other values of the same function.
  prefs: []
  type: TYPE_NORMAL
- en: The problem we have is that Python imposes a limitation on the upper limit for
    these kinds of recursive function definitions. While Python's integers can easily
    represent *1000!* , the stack limit prevents us from doing this casually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Computing *F[n]* Fibonacci numbers involves an additional problem. If we''re
    not careful, we''ll compute a lot of values more than once:'
  prefs: []
  type: TYPE_NORMAL
- en: '*F[5] = F[4] + F[3]*'
  prefs: []
  type: TYPE_NORMAL
- en: '*F[5] = (F[3] + F[2] ) + (F[2] + F[1] )*'
  prefs: []
  type: TYPE_NORMAL
- en: And so on.
  prefs: []
  type: TYPE_NORMAL
- en: To compute *F[5]* , we'll compute *F[3]* twice, and *F[2]* three times. This
    is extremely costly.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many recursive function definitions follow the pattern set by the factorial
    function. This is sometimes called **tail recursion** because the recursive case
    can be written at the tail of the function body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The last expression in the function refers back to the function with a different
    argument value.
  prefs: []
  type: TYPE_NORMAL
- en: We can restate this, avoiding the recursion limits in Python.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A tail recursion can also be described as a **reduction** . We''re going to
    start with a collection of values, and then reduce them to a single value:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Expand the rule to show all of the details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*n! = n* x *(n-* 1 *)* × *(n-* 2 *)* × *(n-* 3 *)...* × 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write a loop that enumerates all the values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*N =* { *n, n-* 1 *, n-* 2 *, ...,* 1}In Python, it''s simply this: `range(1,
    n+1)` . In some cases, though, we might have to apply some transformation function
    to the base values:'
  prefs: []
  type: TYPE_NORMAL
- en: '*N =* { *f(i):* 1 *≤ i < n* +1}If we had to perform some kind of transformation,
    it might look like this in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Incorporate the reduction function. In this case, we're computing a large product,
    using multiplication. We can summarize this using ![How to do it...](Image00008.jpg)   *x*  notation.
    For this example, we're only imposing a simple boundary on the values computed
    in the product:![How to do it...](Image00009.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s the implementation in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We can restate this into a solution like this. This uses higher-level functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This works nicely. We've optimized the first solution to combine the `prod()`
    and `fact()` functions into a single function. It turns out that doing that optimization
    doesn't actually shave much time off the operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the comparisons, run using the `timeit` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Simple** | **4.7766** |'
  prefs: []
  type: TYPE_TB
- en: '| Optimized | 4.6901 |'
  prefs: []
  type: TYPE_TB
- en: This is in the order of a 2% performance improvement. Not a significant change.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the Python 3 `range` object is lazy—it doesn't create a big `list`
    object, it returns values as they are requested by the `prod()` function. This
    is different from Python 2, where the `range()` function eagerly created a big
    `list` object with all of the values, and the `xrange()` function was lazy.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A tail recursion definition is handy because it's short and easy to remember.
    Mathematicians like this because it can help clarify what a function means.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many static, compiled languages are optimized in a manner similar to the technique
    we''ve shown. There are two parts to this optimization:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use relatively simple algebraic rules to reorder the statements so that the
    recursive clause is actually last. The `if` clauses can be reorganized into a
    different physical order so that the `return fact(n-1) * n` is last. This rearrangement
    is necessary for code organized like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Inject a special instruction into the virtual machine''s byte code—or the actual
    machine code—that re-evaluates the function without creating a new stack frame.
    Python doesn''t have this feature. In effect, this special instruction transforms
    the recursion into a kind of `while` statement:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This purely mechanical transformation leads to rather ugly code. In Python,
    it may also be remarkably slow. In other languages, the presence of the special
    byte code instruction will lead to code that runs quickly.
  prefs: []
  type: TYPE_NORMAL
- en: We prefer not to do this kind of mechanical optimization. First, it leads to
    ugly code. More importantly – in Python – it tends to create code that's actually
    slower than the alternative developed above.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Fibonacci problem involves two recursions. If we write it naively as a
    recursion, it might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: It's difficult to do a simple mechanical transformation into a tail recursion.
    A problem with multiple recursions like this requires some more careful design.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two ways to reduce the computation complexity of this:'
  prefs: []
  type: TYPE_NORMAL
- en: Use memoization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restate the problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **memoization** technique is easy to apply in Python. We can use the `functools.lru_cache()`
    as a decorator. This function will cache previously computed values. This means
    that we'll only compute a value once; every other time, the `lru_cache` will return
    the previously computed value.
  prefs: []
  type: TYPE_NORMAL
- en: 'It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Adding a decorator is a simple way to optimize a more complex multi-way recursion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Restating the problem means looking at it from a new perspective. In this case,
    we can think of computing all Fibonacci numbers up to and including *F[n]* . We
    only want the last value in this sequence. We compute all the intermediates because
    it''s more efficient to do it that way. Here''s a generator function that does
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This function is an infinite iteration of Fibonacci numbers. It uses Python's
    `yield` so that it emits values in a lazy fashion. When a client function uses
    this iterator, the next number in the sequence is computed as each number is consumed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a function that consumes the values and also imposes an upper limit
    on the otherwise infinite iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: This function consumes each value from the `fibo_iter()` iterator. When the
    desired number has been reached, the `break` statement ends the `for` statement.
  prefs: []
  type: TYPE_NORMAL
- en: When we look back at the *Designing a while statement which terminates properly*
    recipe in [Chapter 2](text00027.html#page "Chapter 2. Statements and Syntax")
    , *Statements and Syntax* , we noted that a `while` statement with a `break` may
    have multiple reasons for terminating. In this example, there is only one way
    to end the `for` statement.
  prefs: []
  type: TYPE_NORMAL
- en: We can always assert that `i == n` at the end of the loop. This simplifies the
    design of the function.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Designing a while statement which terminates properly* recipe in [Chapter
    2](text00027.html#page "Chapter 2. Statements and Syntax") , *Statements and Syntax*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing reusable scripts with the script library switch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's common to create small scripts which we want to combine into a larger script.
    We don't want to copy and paste the code. We want to leave the working code in
    one file and use it in multiple places. Often we want to combine elements from
    multiple files to create more sophisticated scripts.
  prefs: []
  type: TYPE_NORMAL
- en: The problem we have is that when we import a script it actually starts running.
    This is generally not what we expect when we import a script so that we can reuse
    it.
  prefs: []
  type: TYPE_NORMAL
- en: How can we import the functions (or classes) from a file without having the
    script start doing something?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's say that we have a handy implementation of the haversine distance function
    called `haversine()` , and it's in a file named `ch03_r08.py` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, the file might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: We've omitted the body of the `haversine()` function, showing only `... and
    more...` , since it's shown in the *Picking an order for parameters based on partial
    functions*  recipe. We've focused on the context in which the function is in a
    Python script that also opens a file, `wapypoints.csv` , and does some processing
    on that file.
  prefs: []
  type: TYPE_NORMAL
- en: How can we import this module without it printing a display of distances between
    waypoints in our `waypoints.csv` file?
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python scripts can be simple to write. Indeed, it''s often too simple to create
    a working script. Here''s how we transform a simple script into a reusable library:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Identify the statements that do the work of the script: we''ll distinguish
    between *definition* and *action* . Statements such as `import` , `def` , and
    `class` are clearly definitional—they support the work but they don''t do the
    work. Almost all other statements take action.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our example, we have four assignment statements that are more definition
    than action. The distinction is entirely one of intent. All statements, by definition,
    take an action. These actions, though, are more like the action of the `def` statement
    than they are like the action of the `with` statement later in the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the generally definitional statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The rest of the statements clearly take an action toward producing the printed
    results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wrap the actions into a function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Where possible, extract literals and make them into parameters. This is often
    a simple movement of the literal to a parameter with a default value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'To this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: This makes the script reusable because the path is now a parameter instead of
    an assumption.
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the following as the only high-level action statements in the script
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: We've packaged the action of the script as a function. The top-level action
    script is now wrapped in an `if` statement so that it isn't executed during import.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most important rule for Python is that an `import` of a module is essentially
    the same as running the module as a script. The statements in the file are executed
    in order from top to bottom.
  prefs: []
  type: TYPE_NORMAL
- en: When we import a file, we're generally interested in executing the `def` and
    `class` statements. We might be interested in some assignment statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'When Python runs a script, it sets a number of built-in special variables.
    One of these is `__name__` . This variable has two different values, depending
    on the context in which the file is being executed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The top-level script, executed from the command line: In this case, the value
    of the built-in special name of `__name__` is set to `__main__` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A file being executed because of an import statement: In this case, the value
    of `__name__` is the name of the module being created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The standard name of `__main__` may seem a little odd at first. Why not use
    the filename in all cases? This special name is assigned because a Python script
    can be read from one of many sources. It can be a file. Python can also be read
    from the `stdin` pipeline, or it can be provided on the Python command line using
    the `-c` option.
  prefs: []
  type: TYPE_NORMAL
- en: When a file is being imported, however, the value of `__name__` is set to the
    name of the module. It will not be `__main__` . In our example, the value `__name__`
    during `import` processing will be `ch03_r08` .
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can now build useful work around a reusable library. We might make several
    files that look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'File `trip_1.py` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Or perhaps something even more complex:'
  prefs: []
  type: TYPE_NORMAL
- en: 'File `all_trips.py` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The goal is to decompose a practical solution into two collections of features:'
  prefs: []
  type: TYPE_NORMAL
- en: The definition of classes and functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A very small action-oriented script that uses the definitions to do useful work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To get to this goal, we'll often start with a script that conflates both sets
    of features. This kind of script can be viewed as a **spike solution** . Our spike
    solution should evolve towards a more refined solution as soon as we're sure that
    it works.
  prefs: []
  type: TYPE_NORMAL
- en: A *spike* or *piton* is a piece of removable mountain-climbing gear that doesn't
    get us any higher on the route, but it enables us to climb safely.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 6](text00070.html#page "Chapter 6. Basics of Classes and Objects")
    , *Basics of Classes and Objects* , we'll look at class definitions. These are
    another kind of widely used definitional statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
