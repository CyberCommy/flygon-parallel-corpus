- en: React Hooks
  prefs: []
  type: TYPE_NORMAL
- en: React is evolving really quickly and since React 16.8, the new React Hooks have
    been introduced, which are a game-changer as regards React development in that
    they will boost the speed of coding and improve the performance of our applications.
    React enables us to write React applications using only functional components,
    meaning there is no longer any need to use class components.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The new React Hooks and how to use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rules of the Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to migrate a class component to React Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the component life cycle with Hooks and effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to fetch data with Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to memorize components, values, and functions with `memo`, `useMemo`, and
    `useCallback`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement `useReducer`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete this chapter, you will require the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js 12+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the code for this chapter in the book's GitHub repository at [https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter03](https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter03).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing React Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Hooks are a new addition in React 16.8\. They let you use state and other
    React features without writing a React class component. React Hooks are also backward-compatible,
    which means it does not contain any breaking change and it does not replace your
    knowledge of React concepts. Over the course of this chapter, we will see an overview
    of Hooks for experienced React users, and we are also going to learn some of the
    most common React Hooks such as `useState`, `useEffect`, `useMemo`, `useCallback`
    and `memo`.
  prefs: []
  type: TYPE_NORMAL
- en: No breaking changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many people think that with the new React Hooks, class components are now obsolete
    in React, but this statement is incorrect. There are no plans to remove classes
    from React. The Hooks don't replace your knowledge of React concepts. Instead,
    Hooks provide a more direct API to the React concepts, such as props, state, context,
    refs, and life cycle, which you already know.
  prefs: []
  type: TYPE_NORMAL
- en: Using the State Hook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You probably know how to use the component state by using it in a class with
    `this.setState`. Now you can use the component state by using the new React `useState`
    Hook.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to extract the `useState` Hook from React:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Since React 17, the React object is no longer required to render JSX code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then you need to declare the state you want to use by defining the state and
    the setter for this specific state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are declaring the counter state with the `setCounter` setter
    and we are specifying that we will only accept numbers, and finally, we set the
    initial value with zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to test our state, we need to create a method that will be triggered
    by the `onClick` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can render the `counter` state and some buttons to increase or
    decrease the `counter` state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you click on the + Add button one time, you should see 1 for Counter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/266d444a-ec32-44c6-bff3-29f4d5ab4d4b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And if you click the - Subtract button twice, then you should see -1 for Counter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/56a2e476-d287-46d0-80b9-7956e95c8c4c.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the `useState` Hook is a game-changer in React and makes it
    very easy to handle the state in a functional component.
  prefs: []
  type: TYPE_NORMAL
- en: Rules of Hooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'React Hooks are basically JavaScript functions, but there are two rules that
    you need to follow in order to use them. React provides a linter plugin to enforce
    those rules for you, which you can install by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Let's look at these two rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rule 1: Only call Hooks at the top level'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From the official React documentation ([https://reactjs.org/docs/hooks-rules.html](https://reactjs.org/docs/hooks-rules.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: '"**Donâ€™t call Hooks inside loops, conditions, or nested functions**. Instead,
    always use Hooks at the top level of your React function. By following this rule,
    you ensure that Hooks are called in the same order each time a component renders.
    That''s what allows React to correctly preserve the state of Hooks between multiple
    useState and useEffect calls."'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rule 2: Only call Hooks from React Functions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From the official React documentation ([https://reactjs.org/docs/hooks-rules.html](https://reactjs.org/docs/hooks-rules.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: '"Don''t call Hooks from regular JavaScript functions. Instead, you can:'
  prefs: []
  type: TYPE_NORMAL
- en: Call Hooks from React function components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call Hooks from custom Hooks (we'll learn about them on the next page).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By following this rule, you ensure that all stateful logic in a component is
    clearly visible from its source code."
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to migrate a class component to use the
    new React Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating a class component to React Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's transform a code that is currently using class components and is also
    using some life cycle methods. In this example, we are fetching the issues from
    a GitHub repository and listing them.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, you will need to install `axios` to perform the fetch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the class component version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you render this component, you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b0280137-c6aa-43cb-aae0-b6f5fd070592.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s transform our code to be a functional component using React Hooks.
    The first thing we need to do is to import some React functions and types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can remove the `Props` and `State` types we created previously and just
    leave the `Issue` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, you can change the class definition to use a functional component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FC` type is used to define a **Functional Component** in React. If you
    need to pass some props to the component, you can pass them like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing we need to do is to replace our constructor and our state definition
    by using the `useState` Hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We have used the life cycle method called `componentDidMount` before, which
    is executed when the component is mounted and is going to run just once. The new
    React Hook, called `useEffect`, will now handle all the life cycle methods using
    different syntax for each one, but for now, let''s see how we can get the same
    *effect* of `componentDidMount` into our new functional component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we just render our JSX code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the new Hooks help us to simplify our code a lot and makes more
    sense. Also, we reduced our code by 10 lines (the class component code has 53
    lines and the functional component has 43 lines).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding React effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn the difference between the component life cycle
    methods that we used on class components and the new React effects. Even if you
    have read in other places that they are the same, just with a different syntax,
    this is not correct.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding useEffect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you work with `useEffect`, you need to *think in effects*. If you want
    to perform the equivalent method of `componentDidMount` using `useEffect`, you
    can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter is the callback of the effect that you want to execute,
    and the second parameter is the dependencies array. If you pass an empty array
    (`[]`) on the dependencies, the state and props will have their original initial
    values.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is important to mention that even though this is the closest equivalent
    for `componentDidMount`, it does not have the same behavior. Unlike `componentDidMount`
    and `componentDidUpdate`, the function that we pass to `useEffect` fires after
    layout and paint, during a deferred event. This normally works for many common
    side effects, such as setting up subscriptions and event handlers, because most
    types of work shouldn't block the browser from updating the screen.
  prefs: []
  type: TYPE_NORMAL
- en: However, not all effects can be deferred. For example, you would get a blink
    if you need to mutate the **Document Object Model** (**DOM**). This is the reason
    why you must fire the event synchronously before the next paint. React provides
    one Hook called `useLayoutEffect`, which works in the exact same way as `useEffect`.
  prefs: []
  type: TYPE_NORMAL
- en: Firing an effect conditionally
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you need to fire an effect conditionally, then you should add a dependency
    to the array of dependencies, otherwise, you will execute the effect multiple
    times and this may cause an infinite loop. If you pass an array of dependencies,
    the `useEffect` Hook will only run if one of those dependencies changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If you understand how the React class life cycle methods works, basically, `useEffect`
    behaves in the same way as `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount`
    combined.
  prefs: []
  type: TYPE_NORMAL
- en: The effects are very important, but let's also explore some other important
    new Hooks, including `useCallback`, `useMemo`, and `memo`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding useCallback, useMemo, and memo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to understand the difference between `useCallback`, `useMemo` and
    `memo`, we will do a to-do list example. You can create a basic application by
    using `create-react-app` and typescript as a template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Right after that, you can remove all the extra files (`App.css`, `App.test.ts`,
    `index.css`, `logo.svg`, `reportWebVitals.ts`, and `setupTests.ts`). You just
    need to keep the `App.tsx` file, which will contain the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Basically, we are defining some initial tasks and creating the `todoList` state,
    which we will pass to the list component. Then you need to create the `List.tsx`
    file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are rendering each task of the `todoList` array by using
    the `Task` component and we pass `task` as a prop. I also added a `useEffect`
    Hook to see how many renders we are performing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we create our `Task.tsx` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how we should see the to-do list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/aebfa2b0-1b3f-4145-b7f3-366ce9252c7f.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, when we render our to-do list, by default, we are performing
    two renders of the `Task` component, one render for `List`, and the other for
    the `App` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we try to write a new task in the input, we can see that for each letter
    we write, we will again see all of those renders:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/32dd8a44-a55b-4886-b827-2ab09b1a1a41.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, by just writing `Go`, we have two new batches of renders, so
    we can determine that this component does not have good performance, and this
    is where `memo` can help us to improve performance. In the next sections, we are
    going to learn how to implement `memo`, `useMemo`, and `useCallback` to memoize
    a component, a value, and a function.
  prefs: []
  type: TYPE_NORMAL
- en: Memoizing a component with memo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `memo` **High Order Component (HOC)** is similar to `PureComponent` of a
    React class because it performs a shallow comparison of the props (meaning a superficial
    check), so if we try to render a component with the same props all the time, the
    component will render just once and will memorize. The only way to re-render the
    component is when a prop changes its value.
  prefs: []
  type: TYPE_NORMAL
- en: In order to fix our components to avoid the multiple renders when we write in
    the input, we need to wrap our components on the `memo` HOC.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first component we will fix is our `List` component, and you just need
    to effect `import memo` and wrap the component on `export default`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you need to do the same with the `Task` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we try to write `Go` again in the input, let''s see how many renders
    we get this time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a758059b-3561-4a90-9927-55f4b2ad7a61.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we just get the first batch of renders the first time, and then, when we
    write `Go`, we just get two more renders of the `App` component, which is totally
    fine because the task state (input value) that we are changing is actually part
    of the `App` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we can see how many renders we are performing when we create a new task
    by clicking on the Create button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/128157ac-ed62-472c-b399-63287304f2f3.png)'
  prefs: []
  type: TYPE_IMG
- en: If you see, the first 16 renders are the word counting of the Go to the doctor
    string, and then, when you click on the Create button, you should see one render
    of the `Task` component, one render of `List`, and one render of the `App` component.
    As you can see, we have improved performance a lot, and we are just performing
    the exact need that it renders.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you're probably thinking that the correct way is to always add
    memo to our components, or maybe you're thinking why React doesn't do this by
    default for us?
  prefs: []
  type: TYPE_NORMAL
- en: The reason is **performance**, which means **it** **is not a good idea to add**
    `memo` **to all our components unless it is totally necessary**, otherwise, the
    process of shallow comparisons and memorization will have inferior performance
    than if we don't use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'I have a rule when it comes to establishing whether it is a good idea to use
    `memo`, and this rule is straightforward: **just don''t use it.** Normally, when
    we have small components or basic logic, we don''t need this unless you''re working
    with **large data from some API or your component needs to perform a lot of renders
    (normally huge lists), or when you notice that your app is going slow**. Only
    in that case would I recommend using `memo`.'
  prefs: []
  type: TYPE_NORMAL
- en: Memoizing a value with useMemo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s suppose that we now want to implement a search feature in our to-do
    list. The first thing we need to do is to add a new state called `term` to the
    `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need to create a function called `handleSearch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Right before the return, we will create `filterTodoList`, which will filter
    the to-dos based on the task, and we will add a console there to see how many
    times it is being rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to add a new button next to the Create button that already
    exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, I recommend that you remove or comment `console.log` in the
    `List` and `Task` components so that we can focus on the performance of filtering:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/61331e13-ded8-4eab-add0-1704e4d178be.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When you run the application again, you will see that filtering is being executed
    twice, and then the `App` component as well, and everything looks good here, but
    what''s the problem with this? Try to write `Go to the doctor` again in the input
    and let''s see how many Rendering and Filtering you get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/130012da-d053-4f2b-b2b5-1b83bdadc05e.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, for each letter you write, you will get two filtering calls
    and one `App` render and you don't need to be a genius to see that this is bad
    performance; and not to mention that if you are working with a large data array,
    this will be worse, so how can we fix this issue?
  prefs: []
  type: TYPE_NORMAL
- en: 'The `useMemo` Hook is our hero in this situation, and basically, we need to
    move our filter inside `useMemo`, but first let''s see the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `useMemo` Hook will memorize the result (value) of a function and will
    have some dependencies to listen to. Let''s see how we can implement it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you write something again in the input, you will see that filtering
    won''t be executed all the time, as was the case previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1f273372-2b54-4147-b084-8818284276e8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is great, but there is still one small problem. If you try to click on
    the Search button, it won''t filter, and this is because we missed the dependencies.
    Actually, if you see the console warnings, you will see this warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/67075e04-e4cf-4722-8849-9b64fedcf868.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You need to add the `term` and `todoList` dependencies to the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'It should now work if you write `Go` and click on the Search button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/34c00dec-2193-44f3-bbb0-05ed84679c9c.png)Here, we have to use the
    same rule that we used for memo; **just don''t use it until absolutely necessary.**'
  prefs: []
  type: TYPE_NORMAL
- en: Memoizing a function definition with useCallback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we will add a delete task feature to learn how `useCallback` works. The
    first thing we need to do is to create a new function called `handleDelete` in
    our `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'And then you need to pass this function to the `List` component as a prop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in our `List` component, you need to add the prop to the `Props` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you need to pull it from the props and pass it down to the `Task` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Task` component, you need to create a button that will execute `handleDelete
    onClick`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, I recommend that you remove or comment `console.log` in the
    `List` and `Task` components, so we can focus on the performance of filtering.
    Now you should see the X button next to the task:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0cb5eb97-875e-49f4-9a91-7c0c381cb587.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you click on the X for Go shopping, you should be able to remove it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/aabf1a76-e3c6-410d-bf21-a58a7b1a10fd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So far, so good, right? But again we have a little issue with this implementation.
    If you now try to write something in the input, such as `Go to the doctor`, let''s
    see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7acf5bb0-bb7c-4f70-88a4-dc0398c62fe3.png)'
  prefs: []
  type: TYPE_IMG
- en: If you see, we are performing **71** renders of all the components again. At
    this point, you are probably thinking about, *what is going on if we have already
    implemented the memo HOC to memorize the components*? But the problem now is that
    our `handleDelete` function is being passed in two components, from `App` to `List`
    and to `Task`, and the issue is that this function is regenerated every time we
    have a new re-render, in this case, every time we write something. So how do we
    fix this problem?
  prefs: []
  type: TYPE_NORMAL
- en: 'The `useCallback` Hook is the hero in this case and is very similar to `useMemo`
    in the syntax, but the main difference is that instead of memorizing the result
    value of a function, as `useMemo` does, it is memorizing the **function definition**
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `handleDelete` function should be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it should work just fine if we write `Go to the doctor` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/04e9608a-b0b5-425a-9826-ddfd424785e3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, instead of 71 renders, we just have 23, which is normal, and we are also
    able to delete tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3910a623-ff9b-4198-947c-24f7574e0a9e.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the `useCallback` Hook helps us to improve performance significantly.
    In the next section, you will learn how to memorize a function passed as an argument
    in the `useEffect` Hook.
  prefs: []
  type: TYPE_NORMAL
- en: Memoizing function passed as an argument in effect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a special case where we will need to use the `useCallback` Hook, and
    this is when we pass a function as an argument in a `useEffect` Hook, for example,
    in our `App` component. Let''s create a new `useEffect` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we are listening for changes on the `todoList` state. If you
    run this code and you create or remove a task, it will work just fine (remember
    to remove all the other consoles first):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/88a3b7ff-a819-4871-86c5-f2e7c2989aba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Everything works fine, but let''s add `todoList` to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''re using Visual Studio Code, you will get the following warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/47c343cd-00bc-4851-b52c-547a6ceeec9a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Basically, it is asking us to add the `printTodoList` function to the dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'But now, after we do that, we get another warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7a3abf84-d180-43d3-acd6-c4bfe17fd267.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The reason why we get this warning is that we are now manipulating a state
    (consoling the state), which is why we need to add a `useCallback` Hook to this
    function to fix this issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we delete a task, we can see that `todoList` updated correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/333a4b5d-6f08-4e91-83ad-7fe0a24a8679.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At this point, this may be information overload for you, so let''s have a quick
    recap:'
  prefs: []
  type: TYPE_NORMAL
- en: '`memo`:'
  prefs: []
  type: TYPE_NORMAL
- en: Memorizes a **component**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Re-memorizes when props change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoids re-renders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useMemo`:'
  prefs: []
  type: TYPE_NORMAL
- en: Memorizes a **calculated value**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For computed properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For heavy processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useCallback`:'
  prefs: []
  type: TYPE_NORMAL
- en: Memorizes a **function definition** to avoid redefining it on each render.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use it whenever a function is passed as an effect argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use it whenever a function is passed by props to a memorized component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And finally, do not forget the golden rule: **Do not use them until absolutely
    necessary.**'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to learn how to use the new `useReducer` Hook.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the useReducer Hook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You probably have some experience of using Redux (`react-redux`) with class
    components, and if that is the case, then you will understand how `useReducer`
    works. The concepts are basically the same: actions, reducers, dispatch, store,
    and state. Even if, in general, it seems very similar to `react-redux`, they have
    some differences. The main difference is that `react-redux` provides middleware
    and wrappers such as thunk, sagas, and many more besides, while `useReducer` just
    gives you a `dispatch` method that you can use to dispatch plain objects as actions.
    Also, `useReducer` does not have a store by default; instead, you can create one
    using `useContext`, but this is just reinventing the wheel.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a basic application to understand how `useReducer` works. You
    can start by creating a new React app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Then, as always, you can delete all files in your `src` folder except `App.tsx`
    and `index.tsx` to start a brand-new application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a basic `Notes` application where we can list, delete, create,
    or update our notes using `useReducer`. The first thing you need to do is import
    the `Notes` component, which we will create later, into your `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in our `Notes` component, you first need to import `useReducer` and `useState`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need to define some TypeScript types that we need to use for our `Note`
    object, the Redux action, and the action types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, we need to create `initialNotes` (also known as `initialState`)
    with some dummy notes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'If you remember how the reducers work, then this will seem very similar to
    how we handle the reducer using a `switch` statement, so as to perform basic operations
    such as `ADD`, `DELETE`, and `UPDATE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the component is very straightforward. Basically, you get the notes
    and the `dispatch` method from the `useReducer` Hook (similar to `useState`),
    and you need to pass the `reducer` function and `initialNotes` (`initialState`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Then, we have a `handleSubmit` function to create a new note when we write something
    in the input. Then, we press *Enter:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we render our `Notes` list with `map`, and we also create two buttons,
    one for delete and one for update, and then the input should be wrapped into a
    `<form>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the application, you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bf608854-dd2c-45c9-b79f-62980c4fa16e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the React DevTools, the `Reducer` object contains the two
    notes that we have defined as our initial state. Now, if you write something in
    the input and you press *Enter*, you should be able to create a new note:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/12c45050-34b0-48da-9360-078d81bac8ac.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, if you want to delete a note, you just need to click on the X button.
    Let''s remove Note 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b59b6e27-19c5-4086-be3d-8b298b5ae25d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, you can write anything you want in the input, and if you click on
    the Update button, you will change the note value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dd7d6d51-28c4-43ab-8223-35ee015dde78.png)'
  prefs: []
  type: TYPE_IMG
- en: Nice, huh? As you can see the `useReducer` Hook is pretty much the same as redux
    in terms of the dispatch method, actions, and reducers, but the main difference
    is that this is limited just to the context of your component and its child, so
    if you need a global store to be accessible from your entire application then
    you should use `react-redux` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope you enjoyed reading this chapter, which is full of very good information
    pertaining to the new React Hooks. So far, you have learned how the new React
    Hooks work, how to fetch data with Hooks, how to migrate a class component to
    React Hooks, how the effects work, the difference between `memo`, `useMemo`, and
    `useCallback`, and finally, you learned how the `useReducer` Hook works and the
    main difference compared with `react-redux`. This will help you to improve the
    performance of your React components.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will go through some of the most popular composition
    patterns and tools.
  prefs: []
  type: TYPE_NORMAL
