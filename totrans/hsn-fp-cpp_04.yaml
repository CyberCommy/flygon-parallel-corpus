- en: Deep Dive into Lambdas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations! You've just mastered the power of pure functions! It's now
    time to move on to the next level—pure functions on steroids, or the legendary
    lambdas. They've been around for longer than objects, they have a mathematical
    theory around them (if you like that sort of thing), and they're very powerful,
    as we'll discover in this chapter and the next.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the concept and history of lambdas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to write lambdas in C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How pure functions compare to lambdas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use lambdas with classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need a C++ compiler that supports C++ 17\. The code can be found in
    the GitHub repository ([https://github.com/PacktPublishing/Hands-On-Functional-Programming-with-Cpp](https://github.com/PacktPublishing/Hands-On-Functional-Programming-with-Cpp))
    in the `Chapter03` folder. A `makefile` file is provided to make it easier for
    you to compile and run the code.
  prefs: []
  type: TYPE_NORMAL
- en: What is a lambda?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The year was 1936\. A 33-year old mathematician, Alonzo Church, published his
    research on the foundations of mathematics. In doing so, he created the so-called
    **lambda calculus**, which was a model for the recently created field of computation.
    In collaboration with Alan Turing, he would then go on to prove that the lambda
    calculus is equivalent to a Turing machine. The relevance of this discovery is
    fundamental to programming—it means that we can write any program for a modern
    computer by using lambdas and by taking advantage of lambda calculus. That explains
    why it's called **lambda**—mathematicians have long preferred single Greek letters
    for every notation. But what exactly is it?
  prefs: []
  type: TYPE_NORMAL
- en: 'If you ignore all the mathematical notations, a lambda is just a **pure function**
    that can be applied to variables or values. Let''s take a look at an example.
    We will learn how to write lambdas in C++, but, for now, I will use the Groovy
    syntax since it''s the simplest syntax that I know:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`add` is a lambda. As you can see, it''s a function that has two parameters
    and returns their sum. Since Groovy has optional types, I don''t have to specify
    the type of the argument. Additionally, I don''t need to use a `return` statement
    to return the sum; it will automatically return the value of the last statement.
    In C++, we can''t skip types or the `return` statements, as we''ll discover in
    the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, let''s take a look at another property of a lambda, that is, the ability
    to capture values from the context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `first` is not a parameter to the function, but a variable
    defined in the context. The lambda *captures* the value of the variable and uses
    it inside its body. We can use this property of lambdas to simplify the code or
    to gradually refactor toward immutability.
  prefs: []
  type: TYPE_NORMAL
- en: We'll explore how to use lambdas in future chapters; for now, let's demonstrate
    how to write them in C++, how to ensure they are immutable, and how to capture
    values from the context.
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We explored how to write lambdas in Groovy. So, can we use their power in C++?
    Well, since C++ 11, a specific syntax was introduced. Let''s take a look at how
    our `add` lambda would look in C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s unpack the syntax as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Our lambda starts with `[]`. This block specifies the variables we capture from
    the context, and we'll see how to use it in a moment. Since we don't capture anything,
    the block is empty.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we have the parameter list, `(int first, int second)`, as in any other
    C++ function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we write the body of the lambda, using a return statement: `{ return
    first + second; }`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The syntax has a bit more ceremony than in Groovy, but it feels like C++ and
    that's a good thing; uniformity helps us to remember things.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can use the arrow syntax, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The arrow syntax is a staple of lambdas since Alonzo Church used the notation
    in his lambda calculus. In addition to this, C++ requires the return type specification
    before the lambda body, which may provide clarity in situations where type casts
    are involved.
  prefs: []
  type: TYPE_NORMAL
- en: Due to its history, the arrow syntax is present, in one way or another, in all
    functional programming languages. It's rarely useful in C++; however, it's useful
    to know if you want to get used to functional programming in general.
  prefs: []
  type: TYPE_NORMAL
- en: It's now time to explore how to capture variables from the context. As we mentioned
    previously, it's all in the `[]` block.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, what if we wanted to capture the variable? In Groovy, we just used the
    variable inside the lambda scope. This won''t work in C++, because we need to
    specify what variables we are capturing and how we are capturing them. So, if
    we just use the `first` variable inside our `add` lambda, we will get a compilation
    error as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to capture variables in C++, we need to use a capture specifier inside
    the `[]` block. There are multiple ways of doing this, depending on what you want.
    The most intuitive way is to write the name of the variable we''re capturing directly.
    In our case, since we are trying to capture the first variable, we just need to
    add `[first]` before the lambda parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As we will see, this means that the `first` variable is captured by a value.
    Since C++ gives a lot of control to programmers, we expect it to provide specific
    syntax for capturing variables by reference. Now, let's explore the capture syntax
    in more details.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing variables by value and by reference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We know that the specifier for capturing a variable by value is just writing
    the name of the variable, that is, `[first]`. This means that the variable is
    copied, so we''re wasting a few bytes of memory. The solution is to capture the
    variable by reference. The syntax for the capture specifier is very intuitive—we
    can just use the name of the variable as a `[&first]` reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'I know what you''re thinking: can the lambda now modify the value of the `first`
    variable since it''s passed by reference? Spoiler alert—yes, it can. We''ll revisit
    immutability, pure functions, and lambdas in the next section. For now, there''s
    more syntax to learn. For example, if we want to capture multiple variables from
    the context, do we have to write them all in the capture specifier? As it turns
    out, there are shortcuts to help you avoid this.'
  prefs: []
  type: TYPE_NORMAL
- en: Capturing multiple values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, what if we want to capture multiple values? Let''s explore what our lambda
    would look like if we added five captured values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Our current syntax is a bit redundant, isn''t it? We could use a default capture
    specifier instead. Fortunately, the language designers thought the same way; notice
    the `[&]` syntax before the lambda parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `[&]` syntax is telling the compiler to capture all the specified variables
    from the context by reference. This is the *default capture by reference* specifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to copy their values instead, we need to use the *default capture
    by value* specifier, which you''ll have to remember because this is the only place
    where it''s used like this. Notice the `[=]` syntax before the lambda parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `[=]` syntax tells the compiler that all the variables will be captured
    by copying their values. At least, this is the default. If, for some reason, you''d
    like all variables except `first` to be passed by value, then you just combine
    the default with a variable specifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We know now how to capture variables by value and by reference, and how to use
    default specifiers. This leaves us with one important type of variable—pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing pointer values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pointers are just simple values. If we want to capture a pointer variable by
    value, we could just write its name, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to capture the pointer variable by reference, the capture syntax
    is the same as for capturing any other type of variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The default specifiers work exactly as you''d expect; that is, `[=]` captures
    pointer variables by value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In comparison, `[&]` captures pointer variables by reference, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We'll explore what effects capturing variables by reference can have on immutability.
    But first, since there are multiple ways of capturing variables for a lambda,
    we need to check which one we prefer and when to use each of them.
  prefs: []
  type: TYPE_NORMAL
- en: What capture should we use?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve seen a few options for capturing values, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Name the variable to capture it by value; for example, `[aVariable]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Name the variable and precede it with the reference specifier to capture it
    by reference; for example, `[&aVariable]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the default value specifier to capture all the used variables by value;
    the syntax is `[=]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the default reference specifier to capture all the used variables by reference;
    the syntax is `[&]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In practice, I find that using the default value specifier is the best version
    for most situations. This is probably influenced by my preference for very small
    lambdas that don't mutate their captured values. I believe that simplicity is
    very important; when you have multiple options, it's very easy to make the syntax
    more complex than necessary. Think through each context and use the simplest syntax
    that works; my advice is to start from `[=]` and to only change it if required.
  prefs: []
  type: TYPE_NORMAL
- en: We've explored how to write lambdas in C++. What we haven't mentioned is how
    they are implemented. The current standard implements lambdas as a C++ object
    with an unknown type, created on the stack. Like any C++ object, it has a class
    behind it, with a constructor, a destructor, and the captured variables stored
    as data members. We can pass a lambda to a `function<>` object, in which case
    the `function<>` object will store a copy of the lambda. Moreover, *lambdas use
    lazy evaluation*, unlike `function<>` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas appear to be an easier way to write pure functions; so, what's the relationship
    between lambdas and pure functions?
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas and pure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We learned in [Chapter 2](79295589-e861-4722-96a5-d131b429aac0.xhtml), *Understanding
    Pure Functions*, that pure functions have three characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: They always return the same values for the same argument values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They don't have side effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They don't change the values of their parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also discovered that we need to pay attention to immutability when writing
    pure functions. This is easy, as long as we remember where to place the `const`
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: So, how do lambdas deal with immutability? Do we have to do anything special
    or do they just work?
  prefs: []
  type: TYPE_NORMAL
- en: Lambda immutability and pass by value arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with a very simple lambda, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''re passing the argument by value, so we don''t expect any change
    in the value after calling the lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we copy the value, we''re probably using a few extra bytes of memory
    and an additional assignment. We can add a `const` keyword to make things clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Due to the `const` specifier, the compiler will give an error if the lambda
    tries to change `value`.
  prefs: []
  type: TYPE_NORMAL
- en: But we're still passing the argument by value; how about passing by reference?
  prefs: []
  type: TYPE_NORMAL
- en: Lambda immutability and pass by reference arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s explore the effect on the input parameter when we call this lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As it turns out, it''s relatively close to what you''d expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the lambda changes the value of the argument. That''s not good enough,
    so let''s make it immutable, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Once again, the compiler will help us with an error message if the lambda tries
    to change `value`.
  prefs: []
  type: TYPE_NORMAL
- en: Well, that's better; but what about pointers?
  prefs: []
  type: TYPE_NORMAL
- en: Lambda immutability and pointer arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like we saw in [Chapter 2](79295589-e861-4722-96a5-d131b429aac0.xhtml),
    *Understanding Pure Functions*, there are two questions regarding pointer arguments,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Can the lambda change the pointer address?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can the lambda change the pointed value?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once again, if we pass in the pointer by value, there''s no change in the address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Passing the pointer by reference changes that though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'So, once again, we need to use a well-placed `const` keyword to protect ourselves
    from this change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also make the value immutable. As expected, we need another `const` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: While this works, I suggest that you favor a simpler way to pass the `[](const
    int& value)` value—that is, just dereference the pointer and pass an actual value
    to the lambda, which will make the parameter syntax easier to understand and more
    reusable.
  prefs: []
  type: TYPE_NORMAL
- en: So, no surprises! We can use the same syntax we use for pure functions to ensure
    immutability.
  prefs: []
  type: TYPE_NORMAL
- en: But can lambdas call mutable functions, such as I/O, for example?
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas and I/O
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What better way to test lambdas and I/O than the `Hello, world` program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, lambdas aren't protected from calling mutable functions. This is
    no surprise, given that we learned the same thing about pure functions. This means
    that, similar to pure functions, programmers need to pay extra attention to separate
    I/O, which is fundamentally mutable, from the rest of the code, which can be immutable.
  prefs: []
  type: TYPE_NORMAL
- en: Since we're trying to get the compiler to help us with enforcing immutability,
    can we do that for captured values?
  prefs: []
  type: TYPE_NORMAL
- en: Lambda immutability and capturing values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve discovered that lambdas can capture variables from the context, both
    by value and by reference. So, does this mean we can mutate their value? Let''s
    check it out, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This code immediately gives you a compilation error—*cannot assign to a variable
    captured by copy*. This is an improvement from passing parameters by value; that
    is, there is no need to use the `const` keyword—it just works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Immutability for values captured by reference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, what about values captured by reference? Well, we can just use the default
    reference specifier, `[&]`, and check the value of the variable before and after
    the call to our `increment` lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the `value` changes. So, how do we protect against this mutation?
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, there''s no easy way to do this. C++ assumes that if you capture
    variables by reference, you want to modify them. While it''s possible, it requires
    a bit more syntactic sugar. Specifically, we need to capture its cast to a `const` type,
    instead of the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Given the choice, I prefer using simpler syntax. So, I'd rather use the capture
    by value syntax unless I really need to optimize performance.
  prefs: []
  type: TYPE_NORMAL
- en: We've explored how to make lambdas immutable when capturing value types. But
    can we ensure immutability when capturing pointer types?
  prefs: []
  type: TYPE_NORMAL
- en: Immutability for pointers captured by value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Things get interesting when we use pointers. If we capture them by value, we
    can''t modify the address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we can still modify the pointed value, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Constraining immutability requires a variable of the `const int*` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'However, there''s a much easier solution—that is, just capture the value of
    the pointer instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Immutability for pointers captured by reference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Capturing pointers by reference allows you to change the memory address as
    well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We could use the same trick as before to enforce the constant nature of the
    memory address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this is getting quite complicated. The only reason to do this is due
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We want to avoid copying 64 bits at most
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The compiler doesn't optimize it for us
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's simpler to stick to the values that are passed by value instead, that is,
    unless you want to do pointer arithmetic in your lambda.
  prefs: []
  type: TYPE_NORMAL
- en: You now know how lambdas work with immutability. But, in our C++ code, we're
    used to classes. So, what is the relationship between lambdas and classes? Can
    we use them together?
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas and classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have learned how to write lambdas in C++. All the examples use lambda
    expressions outside classes, either as variables or as part of the `main()` function.
    However, most of our C++ code lives in classes. This begs the question—how can
    we use lambdas in classes?
  prefs: []
  type: TYPE_NORMAL
- en: 'To explore this question, we need an example of a simple class. Let''s use
    a class that represents basic imaginary numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to use our new-found lambda superpowers to write a simple `toString`
    function, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: So, what options do we have?
  prefs: []
  type: TYPE_NORMAL
- en: Well, lambdas are simple variables so they can be a data member. Alternatively,
    they can be `static` variables. Perhaps we can even convert class functions to
    lambdas. Let's explore these ideas next.
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas as data members
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first try to write it as a member variable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, this results in a compilation error. We need to specify the
    type of the lambda variable if we want to have it as a non-static data member.
    To make this work, let''s wrap our lambda into a `function` type, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The function type has a special syntax, allowing us to define lambda types.
    The `function<string()>` notation means the function returns a `string` value
    and receives no parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this still doesn''t work. We receive another error because we haven''t
    captured the variables that we''re using. We can use any of the captures that
    we''ve learned about so far. Alternatively, we can capture `this` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This is, therefore, how we can write a lambda as part of a class while capturing
    the data members of the class. Capturing `this` is a useful shortcut when refactoring
    existing code. However, I would avoid it in more permanent situations. It's best
    to capture the required variables directly rather than the whole pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas as static variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We could also define our lambda as a `static` variable. We can''t capture the
    values any more, so we need to pass in a parameter, but we can still access the
    `real` and `imaginary` private data members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Converting a static function to a lambda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, we need to convert a `static` function to a lambda variable. This
    is very easy in C++, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We can simply assign a function from a class to a variable, as you can see
    in this line from the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We can then use the variable in the same way that we would use the function.
    As we'll discover, this is a very powerful concept because it allows us to compose
    functions even when they are defined inside a class.
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas and coupling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have many options when it comes to interaction between lambdas and classes.
    They can become both overwhelming and they can make design decisions more difficult.
  prefs: []
  type: TYPE_NORMAL
- en: While it's good to know the options since they help when going through difficult
    refactorings, I've found, through practice, that it's best to follow one simple
    principle when it comes to lambdas; that is, to choose the option that reduces
    the coupling area between your lambda and the rest of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we''ve seen that we can write our lambda as a `static` variable
    in a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This lambda has a coupling area as large as the `ImaginaryNumber` class. However,
    it only needs two values: the real and the imaginary part. We could easily rewrite
    it as a pure function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: If, for some reason, you decide to change the representation of the imaginary
    number by adding members or methods, removing members or methods, splitting it
    into multiple classes, or changing data member types, this lambda will not need
    to be changed. Of course, it takes two parameters instead of one, but the parameter
    type no longer matters, as long as `to_string` works for them. In other words,
    this is a polymorphic function that leaves your options for representing the data
    structure open.
  prefs: []
  type: TYPE_NORMAL
- en: But we'll discuss more about how to use lambdas for design in the following
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You''ve just obtained lambda superpowers! Not only can you write simple lambdas
    in C++, but you also know the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to capture variables from the context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to specify the default capture type—by reference or by value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to write immutable lambdas even when capturing values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use lambdas in classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've also touched on the design principle of low coupling and how lambdas can
    help with this. We'll keep mentioning this principle in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Would you believe me if I told you that lambdas are even more powerful than
    what we've seen so far? Well, we'll discover that we can grow from simple to complex
    lambdas through functional composition.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the simplest lambda you can write?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you write a lambda that concatenates two string values passed as parameters?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens if one of the values is a variable that's captured by value?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens if one of the values is a variable that's captured by reference?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens if one of the values is a pointer that's captured by value?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens if one of the values is a pointer that's captured by reference?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens if both values are captured by value using the default capture
    specifier?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens if both values are captured by reference using the default capture
    specifier?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you write the same lambda as a data member in a class that has the two
    string values as data members?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you write the same lambda as a `static` variable in the same class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
