- en: Client-Side and DDoS Attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, you learned how to parse a web page, as well as how
    to glean specific information from an HTML page. In this chapter, we will go through
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Validation in a web page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Penetration testing of validations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DoS attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DDoS attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detection of DDoS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing client-side validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, when you access a web page in your web browser, you open a form, fill
    in the form, and submit it. During the filling of the form, some fields may have
    constraints, such as the username, which should be unique; and the password, which
    should be greater than eight characters, and these fields should not be empty.
    For this purpose, two types of validations are used, which are client-side and
    server-side validations. Languages such as PHP and ASP.NET use server-side validation,
    taking the input parameter and matching it with the database of the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'In client-side validation, the validation is done at the client side. JavaScript
    is used for client-side validation. A quick response and easy implementation make
    client-side validation beneficial, to some extent. However, the frequent use of
    client-side validation gives attackers an easy way to attack; server-side validation
    is more secure than client-side validation. Normal users can see what is happening
    on a web browser, but a hacker can see what can be done outside the web browser.
    The following image illustrates client-side and server-side validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1114bf29-1c02-4172-a8ab-bc3389b8a5b6.png)'
  prefs: []
  type: TYPE_IMG
- en: PHP plays a middle-layer role. It connects the HTML page to the SQL Server.
  prefs: []
  type: TYPE_NORMAL
- en: Tampering with the client-side parameter with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The two most commonly used methods, POST and GET, are used to pass the parameters
    in the HTTP protocol. If the website uses the GET method, its passing parameter
    is shown in the URL and you can change this parameter and pass it to a web server;
    this is in contrast to the POST method, where the parameters are not shown in
    the URL.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will use a dummy website with simple JavaScript code, along
    with parameters passed by the POST method and hosted on the Apache web server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the `index.php` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'I hope you can understand the HTML, JavaScript, and PHP code. The preceding
    code shows a sample form, which comprises two text-submitting fields, name and
    comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code shows validation. If the name field is empty or filled as
    `HACKER`, then it displays an alert box and, if the comment field is empty, it
    will show an alert message where you can enter your comment, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/65ffb5a7-a5f8-4094-9d3b-34ceaabdd5a1.png)'
  prefs: []
  type: TYPE_IMG
- en: Alert box of validation
  prefs: []
  type: TYPE_NORMAL
- en: So, our challenge here is to bypass validation and submit the form. You may
    have done this earlier using the Burp suite. Now, we will do this using Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapter, you saw the BeautifulSoup tool; now, I am going to
    use a Python browser called *mechanize*. The mechanize web browser provides the
    facility to obtain forms in a web page and also facilitates the submission of
    input values. By using mechanize, we are going to bypass the validation, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'All our code snippets start with an `import` statement. So here, we are importing
    the `mechanize` module. The next line creates a `br` object of the `mechanize`
    class. The `url = raw_input("Enter URL ")` statement asks for the user input.
    The next five lines represent the browser option that helps in redirection and
    `robots.txt` handling. The `br.open(url)` statement opens the URL given by us.
    The next statement prints forms in the web pages. Now, let''s check the output
    of the `paratemp.py` program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb38b115-8782-404d-957e-5c34178514b4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The program output shows that two name values are present. The first is `name`
    and the second is `comment`, which will be passed to the action page. Now, we
    have received the parameters. Let''s see the rest of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first line is used to select the form. In our website, only one form is
    present. The `br.form['name'] = 'HACKER'` statement fills the value `HACKER` in
    the name field, the next line fills the empty comment, and the last line submits
    the values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see the output from both sides. The output of the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6dc1573a-95e1-47d0-b743-1c0b53fc93a9.png)'
  prefs: []
  type: TYPE_IMG
- en: Form submission
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the website is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ed254b7-d848-47dd-b292-be4d86a30b15.png)'
  prefs: []
  type: TYPE_IMG
- en: Validation bypass
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows that it has been successful.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you must have got a fair idea of how to bypass the validations. Generally,
    people think that parameters sent by the POST method are safe. However, in the
    preceding experiment, you have seen that it is safe for normal users in an internal
    network. If the website is used only by internal users, then client-side validation
    is a good choice. However, if you use client-side validation for e-commerce websites,
    then you are just inviting attackers to exploit your website. In the following
    topic, you will see some ill effects of client-side validation on business.
  prefs: []
  type: TYPE_NORMAL
- en: Effects of parameter tampering on business
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a pentester, you will often have to analyze the source code. These days,
    the world of e-commerce is growing quickly. Consider an example of an e-commerce
    website, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b33fc280-f002-4546-bc22-2559fe84a0e8.png)'
  prefs: []
  type: TYPE_IMG
- en: Example of a website
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding screenshot shows that the price of a `Nokia C7` is `60` and the
    price of an `iPhone 3G` is `600`. You do not know whether these prices came from
    the database or if they are written in the web page. The following screenshot
    shows the price of both mobiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dbefdd2d-f080-4fe7-8949-f94c836e2293.png)'
  prefs: []
  type: TYPE_IMG
- en: View source code
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the source code, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f68e78b-f917-4bdf-b7d1-33899a1031f2.png)'
  prefs: []
  type: TYPE_IMG
- en: Look at the rectangular boxes in the preceding screenshot. The price `60` is
    written in the web page, but the price `600` is taken from the database. The price
    `60` can be changed by URL tampering if the `GET` method is used. The price can
    be changed to `6` instead of `60`. This will badly impact the business. In white-box
    testing, the client gives you the source code and you can analyze this code, but
    in black-box testing, you have to carry out the test by using attacks. If the
    `POST` method is used, you can use the Mozilla add-on Tamper Data ([https://addons.mozilla.org/en-US/firefox/addon/tamper-data/](https://addons.mozilla.org/en-US/firefox/addon/tamper-data/))
    for parameter tampering. You have to do it manually, so there is no need to use
    Python programming.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing DoS and DDoS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to discuss one of the most deadly attacks, called
    the Denial-of-Service attack. The aim of this attack is to consume machine or
    network resources, making it unavailable for the intended users. Generally, attackers
    use this attack when every other attack fails. This attack can be done at the
    data link, network, or application layer. Usually, a web server is the target
    for hackers. In a DoS attack, the attacker sends a huge number of requests to
    the web server, aiming to consume network bandwidth and machine memory. In a **Distributed
    Denial-of-Service** (**DDoS**) attack, the attacker sends a huge number of requests
    from different IPs. In order to carry out a DDoS attack, the attacker can use
    Trojans or IP spoofing. In this section, we will carry out various experiments
    to complete our reports.
  prefs: []
  type: TYPE_NORMAL
- en: Single IP, single ports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this attack, we send a huge number of packets to the web server using a single
    IP (which might be spoofed) and from a single source port number. This is a very
    low-level DoS attack and will test the web server's request-handling capacity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code of `sisp.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'I have used scapy to write this code and I hope that you are familiar with
    this. The preceding code asks for three things: the source IP address, the destination
    IP address, and the source port address.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the output on the attacker''s machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f703009-3f39-4ce3-bf68-e2900bcb5957.png)'
  prefs: []
  type: TYPE_IMG
- en: Single IP with single port
  prefs: []
  type: TYPE_NORMAL
- en: I have used a spoofed IP in order to hide my identity. You will have to send
    a huge number of packets to check the behavior of the web server. During the attack,
    try to open a website hosted on a web server. Irrespective of whether it works
    or not, write your findings in the reports.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the output on the server side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/70b97414-fd0f-446c-9b49-a4fe423bc6c6.png)'
  prefs: []
  type: TYPE_IMG
- en: Wireshark output on the server
  prefs: []
  type: TYPE_NORMAL
- en: This output shows that our packet was successfully sent to the server. Repeat
    this program with different sequence numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Single IP, multiple port
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, in this attack, we use a single IP address but multiple ports.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, I have written the code of the `simp.py` program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'I used the `for` loop for the ports. Let''s check the output of the attacker:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d28dba77-5745-43db-a692-8d72108dd2f2.png)'
  prefs: []
  type: TYPE_IMG
- en: Packets from the attacker's machine
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding screenshot shows that the packet was sent successfully. Now,
    check the output on the target machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8efc7b0-36cc-48fa-8613-3ad99b1fe37d.png)'
  prefs: []
  type: TYPE_IMG
- en: Packets appearing in the target machine
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, the rectangular box shows the port numbers. I will
    leave it to you to create multiple IPs with a single port.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple IP, multiple ports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will discuss the multiple IP with multiple port addresses.
    In this attack, we use different IPs to send the packet to the target. Multiple
    IPs denote spoofed IPs. The following program will send a huge number of packets
    from spoofed IPs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we used the `a`, `b`, `c`, and `d` variables to store
    four random strings, ranging from `1` to `254`. The `src` variable stores random
    IP addresses. Here, we have used the `loop_break` variable to break the `for`
    loop after `50` packets. It means 50 packets originate from one IP while the rest
    of the code is the same as the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the output of the `mimp.py` program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/381dff7b-35b4-42b5-90d3-fc0731cbaf48.png)'
  prefs: []
  type: TYPE_IMG
- en: Multiple IP with multiple ports
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, you can see that after packet 50, the IP addresses
    get changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the output on the target machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12c21c02-c40e-4f63-a828-3e1f185a1840.png)'
  prefs: []
  type: TYPE_IMG
- en: The target machine's output on Wireshark
  prefs: []
  type: TYPE_NORMAL
- en: Use several machines and execute this code. In the preceding screenshot, you
    can see that the machine replies to the source IP. This type of attack is very
    difficult to detect, because it is very hard to distinguish whether the packets
    are coming from a valid host or a spoofed host.
  prefs: []
  type: TYPE_NORMAL
- en: Detection of DDoS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When I was pursuing my Masters of Engineering degree, my friend and I were
    working on a DDoS attack. This is a very serious attack and difficult to detect,
    where it is nearly impossible to guess whether the traffic is coming from a fake
    host or a real host. In a DoS attack, traffic comes from only one source, so we
    can block that particular host. Based on certain assumptions, we can make rules
    to detect DDoS attacks. If the web server is running only traffic containing port
    80, it should be allowed. Now, let''s go through a very simple code for detecting
    a DDoS attack. The program''s name is `DDOS_detect1.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In [Chapter 3](4cbd4179-2d24-454b-b279-bcdae27210e2.xhtml), *Sniffing and Penetration
    Testing*, you learned about a sniffer. In the previous code, we used a sniffer
    to get the packet''s source IP address. The `file_txt = open("dos.txt",''a'')`
    statement opens a file in append mode, and this `dos.txt` file is used as a logfile
    to detect the DDoS attack. Whenever the program runs, the `file_txt.writelines(t1)`
    statement writes the current time. The `D_val =10` variable is an assumption just
    for the demonstration of the program. The assumption is made by viewing the statistics
    of hits from a particular IP. Consider a case of a tutorial website. The hits
    from the college and school''s IP would be more. If a huge number of requests
    come in from a new IP, then it might be a case of a DoS. If the count of the incoming
    packets from one IP exceeds the `D_val` variable, then the IP is considered to
    be responsible for a DDoS attack. The `D_val1` variable will be used later in
    the code to avoid redundancy. I hope you are familiar with the code before the
    `if dict.has_key(IP):` statement. This statement will check whether the key (IP
    address) exists in the dictionary or not. If the key exists in `dict`, then the
    `dict[IP]=dict[IP]+1` statement increases the `dict[IP]` value by one, which means
    that `dict[IP]` contains a count of packets that come from a particular IP. The
    `if(dict[IP]>D_val)` and `(dict[IP]<D_val1)` : statements are the criteria to
    detect and write results in the `dos.txt` file; `if(dict[IP]>D_val)` detects whether
    the incoming packet''s count exceeds the `D_val` value or not. If it exceeds it,
    the subsequent statements will write the IP in `dos.txt` after getting new packets.
    To avoid redundancy, the `(dict[IP]<D_val1)` statement has been used. The upcoming
    statements will write the results in the `dos.txt` file.'
  prefs: []
  type: TYPE_NORMAL
- en: Run the program on a server and run `mimp.py` on the attacker's machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the `dos.txt` file. Look at that file. It writes
    a single IP nine times, as we have mentioned `D_val1 = D_val+10`. You can change
    the `D_val` value to set the number of requests made by a particular IP. These
    depend on the old statistics of the website. I hope the preceding code will be
    useful for research purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b6f3aff-d07f-4c2f-ac83-7a22b8944046.png)'
  prefs: []
  type: TYPE_IMG
- en: Detecting a DDoS attack
  prefs: []
  type: TYPE_NORMAL
- en: If you are a security researcher, the preceding program should be useful to
    you. You can modify the code such that only the packet that contains port 80 will
    be allowed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about client-side validation as well as how to bypass
    client-side validation. We also learned in which situations client-side validation
    is a good choice. We have gone through how to use Python to fill in a form and
    send the parameter where the GET method has been used. As a penetration tester,
    you should know how parameter tampering affects a business. Four types of DoS
    attacks have been presented in this chapter. A single IP attack falls into the
    category of a DoS attack and a Multiple IP attack falls into the category of a
    DDoS attack. This section is helpful not only for a pentester, but also for researchers.
    Taking advantage of Python DDoS-detection scripts, you can modify the code and
    create larger code, which can trigger actions to control or mitigate the DDoS
    attack on the server.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn SQL injection and **Cross-Site Scripting**
    attacks (**XSS**). You will learn how to take advantage of Python to carry out
    SQL injection tests. You'll also learn how to automate an XSS attack by using
    Python scripts.
  prefs: []
  type: TYPE_NORMAL
