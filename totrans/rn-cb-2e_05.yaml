- en: Implementing Complex User Interfaces - Part III
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a map app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an audio player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an image carousel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding push notifications to your app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing browser-based authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll cover some of the more advanced features you might need
    to add to an app. The applications we'll build in this chapter include building
    a fully functional audio player, map integration, and implementing browser-based
    authentication so that your app can connect to public APIs for developers.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a map app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using a mobile device is a portable experience, so it's no surprise that maps
    are a common part of many iOS and Android applications. Your app may need to tell
    a user where they are, where they're going, or where other users are in real time.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll be making a simple app that uses Google Maps on Android,
    and Apple's Maps app on iOS, to display a map centered on the user's location.
    We will be using Expo's `Location` helper library to get the latitude and longitude
    of the user and will use that data to render the map using Expo's `MapView` component.
    `MapView` is an Expo ready version of the react-native-maps package created by
    Airbnb, so you can expect the react-native-maps documentation to apply, which
    can be found at [https://github.com/react-community/react-native-maps](https://github.com/react-community/react-native-maps).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will need to create a new app for this recipe. Let's call it `map-app`. Since
    the user pin in this recipe will use a custom icon, we'll also need an image for
    that. I used the icon You Are Here by Maico Amorim, which you can download from
    [https://thenounproject.com/term/you-are-here/12314/](https://thenounproject.com/term/you-are-here/12314/).
    Feel free to use any image you'd like to represent the user pin. Save the image
    to the `assets` folder in the root of the project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start by opening `App.js` and adding our imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s define the `App` class and the initial `state`. In this recipe, `state`
    will only need to keep track of the user''s `location`, which we initialize to
    `null`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll define the `componentDidMount` life cycle hook, which will ask
    the user to grant permission to access the user''s location via the device''s
    geolocation. If the user grants the app permission to use its location, the return
    object will have a `status` property with the value `''granted''`. If granted,
    we''ll get the user''s location with `this.getLocation`, defined in the next step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getLocation` function is simple. It grabs the location information from
    the device''s GPS using the `getCurrentPositionAsync` method of the `Location`
    component, then saves that location information to `state`. That information contains
    the latitude and longitude of the user, which we''ll use when we render the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s use that location information to render our map. First, we''ll
    check that a `location` has been saved on `state`. If so, we''ll render the `MapView`,
    and otherwise render `null`. The only property we need to set to render our map
    is the `initialRegion` property, which defines the location the map should display
    when it is first rendered. We''ll pass this property on the object with the latitude
    and longitude saved to `state`, and define a starting zoom level with `latitudeDelta`
    and `longitudeDelta`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the `MapView`, we''ll need to add a marker at the user''s current location.
    The `Marker` component is part of the `MapView` parent component, so in the JSX
    we''ll define a `MapView.Marker` child element of the `MapView` element. This
    element takes the user''s location, a title, and description for displaying when
    the icon is tapped, and a custom image via the `image` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s define our `render` function. It simply renders the map within
    a containing `View` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, let''s add our styles. We''ll set `flex` to `1` on both the container
    and the map, so that both fill the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we open the app, we''ll see a map rendered with our custom user icon
    at the location provided by the device! Unfortunately, Google Maps integration
    may not work in the Android emulator, so a real device may be needed to test the
    Android implementation of the app. Check out the *There''s more...* section at
    the end of this recipe for more information. Don''t be surprised that the iOS
    app running on a simulator displays the user''s location in San Francisco; this
    is due to how Xcode location defaults work. Run it on a real iOS device to see
    it render your location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/d2f4cb86-df1e-47df-bab4-248b6f2f34a3.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By making use of the `MapView` component provided by Expo, the implementation
    of a map in your React Native app is now a much simpler and straightforward process
    than it once was.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 3*, we made use of the `Permissions` helper library. `Permissions`
    has a method called `askAsync`, which takes one parameter defining what type of
    permissions your app would like to request from the user. `Permissions` also has
    constants for each type of permission you can request from the user. These permission
    types include `LOCATION`, `NOTIFICATIONS` (which we'll use later in this chapter),
    `CAMERA`, `AUDIO_RECORDING`, `CONTACTS`, `CAMERA_ROLL`, and `CALENDAR`. Since
    we need the location in this recipe, we passed in the constant `Permissions.LOCATION`.
    Once the `askAsync` return promise resolves, the return object will have a `status`
    property and an `expiration` property. If the user has allowed the requested permission,
    `status` will be set to the `'granted'`string. If granted, we will fire off our
    `getLocation` method.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 4*, we defined the function that gets the location from the device's
    GPS. We call the `getCurrentPositionAsync` method of the `Location` component.
    This method will return an object with a `coords` property and a `timestamp` property.
    The `coords` property gives us access to the `latitude` and `longitude`, as well
    as the `altitude`, `accuracy` (radius of uncertainty for the location, measured
    in meters), `altitudeAccuracy` (accuracy of the altitude value, in meters (iOS
    only)), `heading`, and `speed`. Once received, we save the location to `state`
    so that the `render` function will be called, and our map will be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *step 5*, we defined the `renderMap` method to render the map. First, we
    check whether there is a location, and if there is, we render the `MapView` element.
    This element only requires us to define the value for one property: `initialRegion`.
    This property takes an object with four properties: `latitude`, `longitude`, `latitudeDelta`,
    and `longitudeDelta`. We set the `latitude` and `longitude` equal to those in
    the `state` object, and provide initial values for `latitudeDelta` and `longitudeDelta`.
    These last two properties dictate the initial zoom level that the map should be
    rendered at; the larger this number is, the more zoomed out the map will be. I
    suggest experimenting with these two values to see how they affect the rendered
    map.'
  prefs: []
  type: TYPE_NORMAL
- en: In *step 6*, we added the marker to the map by adding a `MapView.Marker` element
    as a child of the `MapView` element. We defined the coordinates by passing the
    info saved on `state` (`state.location.coords`) to the `coords` property, and
    set a `title` and `description` for the marker's popup when tapped. We were also
    able to easily define a custom pin by inlining our custom image with a `require`
    statement in the `image` property.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned previously, you can read the docs for the react-native-maps project
    to learn more about the features of this excellent library ([https://github.com/react-community/react-native-maps](https://github.com/react-community/react-native-maps)).
    For instance, you can easily customize the appearance of your Google map by using
    Google Maps Styling Wizard ([https://mapstyle.withgoogle.com/](https://mapstyle.withgoogle.com/))
    to generate a `mapStyle` JSON object, then pass that object to the `MapView` component's `customMapStyle`
    property. Or, you could add geometric shapes to your map with the `Polygon` and
    `Circle` components.
  prefs: []
  type: TYPE_NORMAL
- en: Once you're ready to deploy your app, there are a few follow-up steps that you
    will need to take to take to ensure the map works properly on Android. You can
    read the details on how deploying to a standalone Android app with a `MapView` component
    works in the Expo documentation at [https://docs.expo.io/versions/latest/sdk/map-view#deploying-to-a-standalone-app-on-android](https://docs.expo.io/versions/latest/sdk/map-view#deploying-to-a-standalone-app-on-android).
  prefs: []
  type: TYPE_NORMAL
- en: There is a known issue that could cause problems when rendering Google Maps
    within the Android simulator. You can refer to the following GitHub link for more
    information: [https://github.com/react-native-community/react-native-maps/issues/942](https://github.com/react-native-community/react-native-maps/issues/942).
  prefs: []
  type: TYPE_NORMAL
- en: Creating an audio player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Audio players are another common interface built into many applications. Whether
    your app needs to play audio files stored locally on the device or stream audio
    from a remote location, Expo's `Audio` component comes to the rescue.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll be building a full-fledged basic audio player, with
    play/pause, next track, and previous track functionality. For simplicity, we''ll
    be hardcoding the information for the tracks we''ll be using, but in a real-world
    scenario, you''ll likely be working with similar objects to what we''re defining:
    an object with a track title, album name, artist name, and a URL to a remote audio
    file. I''ve chosen three random live tracks from the Internet Archive''s Live
    Music Archive ([https://archive.org/details/etree](https://archive.org/details/etree)).'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll need to create a new app for this recipe. Let's call it `audio-player`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by opening up `App.js` and adding the dependencies we''ll need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'An audio player needs audio to play. We''ll create a `playlist` array to hold
    the audio tracks. Each track is represented by an object with a `title`, `artist`, `album`,
    and `uri`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll define our `App` class and initial `state` object with four properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`isPlaying` for defining whether the player is playing or paused'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`playbackInstance` to hold the `Audio` instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`volume` and `currentTrackIndex` for the currently playing track'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isBuffering` to display a `Buffering...` message while the track is buffering
    at the beginning of playback'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As shown in following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define the `componentDidMount` life cycle hook next. We''ll use this
    method to configure the `Audio` component via the `setAudioModeAsync` method,
    passing in an `options` object with a few recommended settings. These will be
    discussed more in the *How it works...* section at the end of the recipe. After
    this, we''ll load the audio with `loadAudio`, defined in the next step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `loadAudio` function will handle loading the audio for our player. First,
    we''ll create a new instance of `Audio.Sound`. We''ll then call the `setOnPlaybackStatusUpdate`
    method on our new `Audio` instance, passing in a handler that will be called whenever
    the state of playback within the instance has changed. Finally, we call `loadAsync`
    on the instance, passing it a source from the `playlist` array, as well as a status
    object with the volume and a `shouldPlay` property set to the `isPlaying` value
    of `state`. The third parameter dictates whether we want to wait for the file
    to finish downloading before it is played, so we pass in `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We still need to define the callback for handling status updates. All we need
    to do in this function is set the value of `isBuffering` on `state` to the `isBuffering`
    value on the `status` parameter that was passed in from the `setOnPlaybackStatusUpdate`
    function call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Our app now knows how to load an audio file from the `playlist` array and update
    `state` with the current buffering status of the loaded audio file, which we''ll
    use later in the `render` function to display a message to the user. All that''s
    left is to add the behavior for the player itself. First, we''ll handle the play/pause
    state. The `handlePlayPause` method checks the value of `this.state.isPlaying`
    to determine whether the track should be played or paused, and calls the associated
    method on the `playbackInstance` accordingly. Finally, we need to update the value
    of  `isPlaying `for `state`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s define the function for handling skipping to the previous track.
    First, we''ll clear the current track from the `playbackInstance` by calling `unloadAsync`.
    We''ll update the `currentTrackIndex` value of `state` to either one less than
    the current value, or `0` if we''re at the beginning of the `playlist` array.
    Then, we''ll call `this.loadAudio` to load the proper track:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Not surprisingly, `handleNextTrack` is the same as the preceding function,
    but this time we''ll either add `1` to the current index, or set the index to
    `0` if we''re at the end of the `playlist` array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s time to define our `render` function. We will need three basic pieces
    in our UI: a `''Buffering...''` message when the track is playing but still buffering,
    a section for displaying information for the current track, and a section to hold
    the player''s controls. The `''Buffering...''`  message will only display if both
    `this.state.isBuffering` and `this.state.isPlaying` are `true`. The song info
    is rendered via the `renderSongInfo` method, which we''ll define in *step 12*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The player controls are made up of three `TouchableOpacity` button elements,
    each with a corresponding icon from the Feather icon library. You can find more
    information on using icons in [Chapter 3](4d1b8446-1a41-4729-9bc2-7e525cb1f206.xhtml), *Implementing
    Complex User Interfaces – Part I*. We''ll determine whether to display the Play
    icon or the Pause icon depending on the value of `this.state.isPlaying`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `renderSongInfo` method returns basic JSX for displaying the metadata associated
    with the track currently playing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'All that''s left to add are the styles. The styles defined here are well-covered
    ground by now, and don''t go beyond centering, colors, font size, and adding padding
    and margins:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now check out your app in the simulator, and you should have a fully
    working audio player! Note that audio playback in the Android emulator may be
    too slow for the playback to work properly, and may sound very choppy. Open the
    app on a real Android device to hear the track playing properly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/21780eb9-bf05-4182-bad9-c53978ff19b1.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *step 4*, we initialized options on the `Audio` component once the app finished
    loading via the `componentDidMount` method. The `Audio` component's `setAudioModeAsync`
    method takes an option object as its only parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review some of the options we used in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '`interruptionModeIOS` and `interruptionModeAndroid` set how the audio in your
    app should interact with the audio from other applications on the device. We used
    the `Audio` component''s `INTERRUPTION_MODE_IOS_DO_NOT_MIX` and `INTERRUPTION_MODE_ANDROID_DO_NOT_MIX` enums,
    respectively, to declare that our app''s audio should interrupt any other applications
    playing audio.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`playsInSilentModeIOS` is a Boolean that determines whether your app should
    play audio when the device is in silent mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shouldDuckAndroid` is a Boolean that determines whether your app''s audio
    should lower in volume (duck) when audio from another app interrupts your app.
    While this setting defaults to `true`, I''ve added it to the recipe so that you''re
    aware that it''s an option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *step 5*, we defined the `loadAudio` method, which performs the heavy lifting
    in this recipe. First, we created a new instance of the `Audio.Sound` class and
    saved it to the  `playbackInstance` variable for later use. Next, we set the `source`
    and `status` variables that will be passed into the `loadAsync` function on the
    `playbackInstance` for actually loading the audio file. In the `source` object,
    we set the `uri` property to the corresponding `uri` property on the object in
    the `playlist` array at the index stored in `this.state.currentTrackIndex`. In
    the `status` object, we set the volume to the `volume` value saved on `state`,
    and set `shouldPlay`, a Boolean that determines whether the audio should be playing,
    initially to `this.state.isPlaying`. And, since we want to stream the remote MP3
    file instead of waiting for the entire file to download, we pass `false` the third,
    `downloadFirst`, parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Before calling the `loadAsync` method, we first called `setOnPlaybackStatusUpdate `of `playbackInstance`, which
    takes a callback function that should be called when the state of `playbackInstance`
    has changed. We defined that handler in *step 6*. The handler simply saves the
    `isBuffering` value from the callback's `status` parameter to the `isBuffering`
    property of `state`, which will fire a rerender, updating the 'Buffering...' message
    in the UI accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 7*, we defined the `handlePlayPause` function for toggling play and
    pause functionality in the app. If there's a track playing, `this.state.isPlaying`
    will be `true`, so we'll call the `pauseAsync` function on the `playbackInstance` otherwise,
    we'll call `playAsync` to start playing the audio again. Once we've played or
    paused, we update the value of `isPlaying` on `state`.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 8* and *step 9*, we created the functions that handle skipping to the
    next and previous tracks. Each of these functions increases or decreases the value
    of `this.state.currentTrackIndex` as appropriate, so that by the time `this.loadAudio`
    is called at the bottom of each function, it will load the track associated with
    the object in the `playlist` array at the new index.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The features of our current app are more basic than you'll find in most audio
    players, but all the tools you need for building a feature-rich audio player are
    at your disposal. For instance, you could display the current track time in the
    UI by tapping into the `positionMillis` property on the `status` parameter in
    the `setOnPlaybackStatusUpdate` callback. Or, you could use a React Native `Slider`
    component to allow the user to adjust the volume or playback rate. Expo's `Audio`
    component provides all the building blocks for a great audio player app.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an image carousel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are all kinds of applications that make use of image carousels. Any time
    there's a collection of images that you'd like your user to be able to peruse,
    a carousel is likely among the most effective UI patterns for accomplishing the
    task.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of packages in the React Native community for handling the
    creation of carousels, but in my experience none are more stable or more versatile
    than react-native-snap-carousel ([https://github.com/archriss/react-native-snap-carousel](https://github.com/archriss/react-native-snap-carousel)).
    This package provides a great API for customizing the look and behavior of your
    carousel, and supports Expo app development without the need for ejecting. You
    can easily change how slides appear as they slide in and out of the carousel frame
    via the Carousel component's `layout` property, and as of version 3.6, you can
    even create custom interpolations!
  prefs: []
  type: TYPE_NORMAL
- en: While you are not limited to only displaying images with this package, we'll
    be building a carousel that just displays images along with a caption to keep
    the recipe simple. We'll be using the excellent license-free photo site [unsplash.com](http://www.unsplash.com)
    to get random images for displaying in our carousel via the Unsplash Source project
    hosted at [source.unsplash.com](http://source.unsplash.com). Unsplash Source allows
    you to easily request random images from Unsplash without needing to access the
    official API. You can visit the Unsplash Source site for more information on how
    it works.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll need to create a new app for this recipe. Let's call this app `carousel`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start by opening `App.js` and importing dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s define the `App` class and the initial `state` object. The `state`
    has three properties: a Boolean for whether we''re currently displaying the carousel
    or not, a `layoutType` property for setting the layout style of our carousel,
    and an array of `imageSearchTerms` we''ll use later to get images from Unsplash
    Source. Feel free to change the `imageSearchTerms` array to your heart''s content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define the `render` method next. We''ll just check the value of `this.state.showCorousel`
    and either show the carousel or the controls accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s create the `renderControls` function. This will be the layout
    the user sees when they first open the app, and consists of a React Native `Picker`
    for selecting a layout type to use in the carousel and a button for opening the
    carousel. The `Picker` has three options available: default, tinder, and stack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define the `toggleCarousel` function. This function simply sets the
    value of `showCarousel` on `state` to its opposite. By defining a toggle function,
    we can use the same function to both open and close the carousel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the `updateLayoutType` method just updates the `layoutType` on `state`
    to the `layoutType` value passed into it from the `Picker` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `renderCarousel` function returns the markup for the carousel. It''s made
    up of a button for closing the carousel and the `Carousel` component itself. This
    component takes a `layout` property, as set by the `Picker`. It also has a `data` property,
    which takes the data that should be looped over for each carousel slide, and a
    `renderItem` callback that handles the rendering of each individual slide:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We still need the function that handles the rendering of each slide. This function
    receives one object parameter containing the next item in the array passed to
    the `data` property. We''ll return an `Image` component that uses the `item` parameter
    value to get a random item from Unsplash Source that''s `350x350` in size. We''ll
    also add a `Text` element to display the type of image being displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we''ll need is some styles to lay out our UI. The `container`
    styles apply to the main wrapping `SafeAreaView` element, so we set `justifyContent`
    to `''space-evenly''` so that the `Picker` and `TouchableOpacity` components fill
    up the screen. To display the close button in the top-right corner of the screen,
    we''ll apply `flexDirection: ''row` and `justifyContent: ''flex-end''` to the
    wrapping element. The rest of the styles are just dimensions, colors, padding,
    margins, and font size:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve completed our carousel app. It probably won''t win any design awards,
    but it''s a working carousel app with smooth, native-feeling behavior:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/611a73a0-ec0a-4a09-bf88-c819dbece914.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *step* 4, we defined the `renderControls` function, which renders the UI
    when the app is first launched. This is the first recipe in which we've used the
    `Picker` component. It's a part of the core React Native library and provides
    the drop-down type selector used to select options in many applications. The `selectedValue`
    property is the value tied to whichever item is currently selected in the picker.
    By setting it to `this.state.layoutType`, we'll default the selection to the `'default'`
    layout, and keep the values synced when a different `Picker` item is selected.
    Each item in the picker is represented by a `Picker.Item` component. Its `label`
    property defines the display text for the item, and the `value` property represents
    the string value for the item. Since we provided the `onValueChange` property
    with the `updateLayoutType` function, it will be called whenever a new item is
    selected, which in turn will update `this.state.layoutType` accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: In *step* 7, we defined the JSX for the carousel. The carousel's `data` and
    `renderItem` properties are required, and work together to render each slide in
    the carousel. When the carousel is instantiated, the array passed into the `data` property
    will be looped over, and the `renderItem` callback function will be called for
    each item in the area, with that item passed into the `renderItem` as a parameter.
    We also set the `sliderWidth` and `itemWidth` properties, which are required for
    horizontal carousels.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 8*, we defined the `renderItem` function that gets called for each
    entry in the array passed into `data`. We set the source of the returned `Image` component
    to an Unsplash source URL, which will return a random image of the type requested.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few things we could do to improve this recipe. We could make use
    of the `Image.prefetch()` method to download the first image before opening the
    carousel, so that the image is ready right away, or add an input to allow the
    user to select their own image search terms.
  prefs: []
  type: TYPE_NORMAL
- en: The react-native-snap-carousel package provides a great way to build a multimedia
    carousel for a React Native app. There are a number of features we didn't have
    the time to cover here, including parallax images and custom pagination. For the
    adventurous developer, the package provides a way to create custom interpolations,
    allowing you to make your own layouts beyond the three built-in layouts.
  prefs: []
  type: TYPE_NORMAL
- en: Adding push notifications to your app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Push notifications are a great way to provide a constant feedback loop between
    the app and the user by continually providing app-specific data that's relevant
    to the user. Messaging applications send notifications when new messages arrive.
    Reminder applications display a notification to remind the user of a task at a
    specific time or location. A podcast app might use notifications to inform the
    user that a new episode has been published. A shopping app could use notifications
    to alert the user to check out a limited-time deal.
  prefs: []
  type: TYPE_NORMAL
- en: Push notifications are a proven way to increase user interaction and retention.
    If your app makes use of time-sensitive or event-based data, push notifications
    could be a valuable asset. In this recipe, we'll be using Expo's push notification
    implementation, which simplifies some of the setup that would be required with
    a vanilla React Native project. If the needs of your app demand a non-Expo project,
    I would recommend considering the react-native-push-notification package at [https://github.com/zo0r/react-native-push-notification](https://github.com/zo0r/react-native-push-notification).
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll be making a very simplistic messaging app with push notifications.
    We'll request proper permissions, then register a push notification token to an
    Express server we'll be building. We'll also render a `TextInput` for the user
    to enter a message into. When the Send button is pressed, the message will be
    sent to our server, and the server will send a push notification via Expo's push
    notification server, with the message from the app, to all devices that have registered
    a token with our Express server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thanks to Expo''s built-in push notification service, the complicated work
    of creating a notification for each native device is offloaded to an Expo hosted
    backend. The Express server we build in this recipe will just pass off JSON objects
    for each push notification to the Expo backend, and the rest is taken care of.
    The following diagram from the Expo docs ([https://docs.expo.io/versions/latest/guides/push-notifications](https://docs.expo.io/versions/latest/guides/push-notifications))
    illustrates the life cycle of a push notification:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c8f284dd-63b9-47fe-8645-0c9a31c52862.png)Image source: [https://docs.expo.io/versions/latest/guides/push-notifications/](https://docs.expo.io/versions/latest/guides/push-notifications/)'
  prefs: []
  type: TYPE_IMG
- en: While implementing push notifications using Expo is less setup work than it
    would otherwise be, the requirements of the technology still mean we will need
    to run a server for handling registrations and sending notifications, which means
    this recipe will be a little longer than most. Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the first things we'll need to do in this app is request permission from
    the device to use push notifications. Unfortunately, push notification permissions
    do not work properly in emulators, so a real device will be needed to test this
    app.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also need to be able to access the push notification server from an address
    outside of the localhost. In a real-world setup, the push notification server
    would already have a public URL, but in a development environment, the easiest
    solution is to create a tunnel that exposes the development push notification
    server to the internet. We'll be using the ngrok tool for this purpose, since
    it is a mature, robust, and incredibly easy-to-use solution. You can read more
    about the software at [https://ngrok.com](https://ngrok.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install `ngrok` globally via `npm` using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it''s installed, you can create a tunnel from the internet to a port on
    your local machine by executing `ngrok` with the `https` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We'll use this command later in the recipe to expose the development server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new app for this recipe. We''ll call it `push-notifications`.
    We''re going to need three extra npm packages for this recipe: `express` for the
    push notification server, `esm` for using ES6 syntax support on the server, and
    `expo-server-sdk` for processing push notifications. Install them with `yarn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, install them using `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with building the `App`. We''ll start that by adding the dependencies
    we need to `App.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re going to declare two constants for the API endpoints on our server,
    but the `url` will be generated by `ngrok` when we run the server later in the
    recipe, so we''ll update the value of these constants at that point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create the `App` component and initialize the `state` object. We''ll
    need a `notification` property to hold notifications received by the `Notifications`
    listener, which we will define in a later step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define the method that will handle registering the push notification
    token to the server. We''ll ask for notification permission from the user via
    the `askAsync` method on the `Permissions` component. If permission is granted,
    get the token from the device from the `getExpoPushTokenAsync` method of the `Notifications`
    component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the appropriate token, we''ll send it over to the push notification
    server for registration. We will then make a `POST` request to `PUSH_REGISTRATION_ENDPOINT`,
    sending a `token` object and `user` object in the request body. I''ve hardcoded
    the values in the user object, but in a real app this would be the metadata you''ve
    stored for the current user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'After the token is registered, we''ll set up an event listener to listen to
    any notifications that occur while the app is open and foregrounded. In certain
    cases, we will need to manually handle displaying the information from an incoming
    push notification. Check the *How it works...* section at the end of this recipe
    for more on why this is necessary and how it can be leveraged. We''ll define the
    handler in the next step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever a new notification is received, the `handleNotification` method will
    be run. We''ll just store the new notification passed to this callback on the
    `state` object for later use in the `render` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We want our app to ask for permission to use push notifications, and to register
    the push notification token when the app launches. We''ll utilize the `componentDidMount`
    life cycle hook to run our `registerForPushNotificationsAsync` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The UI will be very minimal to keep the recipe simple. It''s made up of a `TextInput`
    for the message text, a Send button for sending the message, and a `View` for
    displaying any notifications heard by the notification listener:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `TextInput` component defined in the previous step is missing the method
    it needs for its `onChangeText` property. Let''s create that method next. It just
    saves the text input by the user to `this.state.messageText` so it can be used
    by the `value` property and elsewhere:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `TouchableOpacity` component''s `onPress` property calls the `sendMessage`
    method to send the message text when the user presses the button. In this function,
    we''ll just take the message text and `POST` it to the `MESSAGE_ENDPOINT` on our
    push notification server. The server will handle things from there. Once the message
    is sent, we''ll clear the `messageText` property on `state`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The last piece we need for the `App` is the styles. These styles are straightforward,
    and should all look quite familiar by now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'With the React Native app portion out of the way, let''s move on to the server
    portion. First, we''ll create a new `server` folder in the root of the project
    with an `index.js` file inside of it. Let''s start by importing `express` to run
    the server and `expo-server-sdk` to handle the registration and sending of push
    notifications. We''ll create an Express server app and store it in the `app` const,
    and a new instance of the Expo server SDK in the `expo` const. We''ll also add a
    `savedPushTokens` array for storing any tokens that are registered with the React
    Native app, and a `PORT_NUMBER` const for the port we want to run the server on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Our server will need to expose two endpoints (one for registering tokens, and
    one for accepting messages from the React Native app), so we''ll create two functions
    that will be executed when these routes are hit. We''ll define the `saveToken`
    function first. It just takes a token, checks whether it''s stored in the `savedPushTokens`
    array, and pushes it to the array if it isn''t there already:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The other function our server needs is a handler for sending push notifications
    when a message is received from the React Native app. We''ll loop over all of
    the tokens that have been saved to the `savedPushTokens` array and create a message
    object for each token. Each message object has a title of `Message received!`,
    which will display in bold on the push notification, and the message text as the
    body of the notification:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have an array of messages, we can send them to Expo''s server, which
    in turn will send the push notification to all registered devices. We''ll send
    the messages array via the expo server''s `chunkPushNotifications` and `sendPushNotificationsAsync`
    methods, and `console.log` the success receipts, or an error, as appropriate to
    the server console. There''s more on how this works in the *How it works... *section
    at the end of this recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the functions defined for handling push notifications and messages,
    let's expose those functions by creating API endpoints. If you're not familiar
    with Express, it's a powerful and easy-to-use framework for running a web server
    in Node. You can quickly get up to speed on the basics of routing with the basic
    routing docs at [https://expressjs.com/en/starter/basic-routing.html](https://expressjs.com/en/starter/basic-routing.html).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ll be working with JSON data, so the first step will be applying the JSON
    parser middleware with a call to `express.json()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though we won''t really be using the root path (`/`) of the server, it''s
    good practice to define one. We''ll just respond with a message that the server
    is running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'First, let''s implement the endpoint for saving a push notification token.
    When a `POST` request is sent to the `/token` endpoint, we''ll pass the token
    value to the `saveToken` function and return a response stating that the token
    was received:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, the `/message` endpoint will take the `message` from the request
    body and pass it to the `handlePushTokens` function for processing. Then, we''ll
    send back a response that the message was received:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The last piece to the server is the call to Express''s `listen` method on the
    server instance, which will start the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re going to need a way to start the server, so we''ll add a custom script
    to the `package.json` file called serve. Open the `package.json` file and update
    it to have a scripts object with a new `serve` script. With this added, we can
    run the server with yarn via the `yarn run serve` command or with `npm` via the 
    command `npm run serve`. The `package.json` file should look something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve got all the code in place, let''s use it! As mentioned previously, push
    notification permissions do not work properly on the emulator, so a real device
    will be needed to test the push notification functionality. First, we''ll fire
    up our newly created server by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'You should be greeted by the `Server Online` message we defined in the `listen`
    method call in *step 21*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/410ec457-c70d-469f-a885-07a9b98c66bc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we''ll need to run `ngrok` to expose our server to the internet. Open
    a new Terminal window and create an `ngrok` tunnel with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the `ngrok` interface in the Terminal. This displays the URLs
    generated by `ngrok`. In this case, `ngrok` is forwarding my server located at
    `http://localhost:3000` to the URL `http://ddf558bd.ngrok.io`. Let''s copy that
    URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bd7818a2-f122-4c7c-8107-9b599085a897.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can test that the server is running and accessible from the internet by
    visiting the generated URL in a browser. Navigating directly to this URL behaves
    exactly the same as navigating to `http://localhost:3000`, which means the `GET`
    endpoint we defined in previous step should run. That function returns the Push
    Notification Server Running string, and should display in your browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/9261690a-6d72-4e3d-8fb6-f9295621a921.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we''ve confirmed that the server is running, let''s update the React
    Native app to use the correct server URL. In *step 2*, we added to constants to
    hold our API endpoints, but we didn''t have the correct URL yet. Let''s update
    these URLs to reflect the tunnel URL generated by `ngrok`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned previously, you''ll need to run this app on a real device for
    the permissions request to work correctly. As soon as you open the app, you should
    be prompted by the device, asking if you''d like to allow the app to send notifications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/767c5400-2b08-4fdb-a32d-b8c7d958b410.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As soon as Allow is selected, the push notification token will be sent to the
    server's `/token` endpoint to be saved. This should also print the associated
    `console.log` statement in the server Terminal with the saved token. In this case,
    my iPhone's push token is the string
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ExponentPushToken[g5sIEbOm2yFdzn5VdSSy9n]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d7795f23-8301-4b8a-a9b2-194f92f7d37e.png)'
  prefs: []
  type: TYPE_IMG
- en: At this point, if you have a second Android or iOS device, go ahead and open
    the React Native app on that device as well. If not, don't worry. There's another
    easy way to test that our push notification functionality is working without using
    a second device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can use the React Native app''s text input to send a message to other registered
    devices.. If you''ve got a second device that has registered a token with the
    server, it should receive a push notification corresponding to the newly sent
    message. You should also see two new instances of `console.log` in the server:
    one that displays the received message, and another that displays the `receipts`
    array received back from the Expo servers. Each receipt object in the array will
    have a `status` property with the value `''ok''` if the operation was successful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/edda5d92-00c3-4943-a4b3-f253ab9fe1a2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you don''t have a second device to test on, you can use Expo''s push notification
    tool, hosted at [https://expo.io/dashboard/notifications](https://expo.io/dashboard/notifications).
    Just copy the `push token` from the server Terminal and paste it into the input
    labeled EXPO PUSH TOKEN (from your app). To emulate a message sent from our React
    Native app, set MESSAGE TITLE to `Message received!`,  MESSAGE BODY to the message
    text you''d like to send, and check the Play Sound checkbox. If you like, you
    can also emulate the `data` object by providing a JSON object with a key of `"message"`
    and a value of your message text,such as `{ "message": "This is a test message."
    }`. The received message should then look something like this screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/02ed0e2b-79a7-4e72-a36c-8281d44c2e37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The recipe we built here is a little contrived, but the core concepts needed
    to request permissions, register tokens, accept app data, and send push notifications
    in response to app data are all there.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *step 4*, we defined the first part of the `registerForPushNotificationsAsync`
    function. We began by asking the user for their permission to send them notifications
    from our app via the `Permissions.askAsync` method, passing in the constant for
    the push notifications permission, `Permissions.NOTIFICATIONS`. We then saved
    the `status` property from the resolved `return` object, which will have the value
    `''granted''` if the user granted permission. If we don''t get permission, we `return`
    right away; otherwise, we get the token from Expo''s `Notifications` component
    by calling `getExpoPushTokenAsync`. This function returns a token string, which
    will be in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In *step 5*, we defined the `POST` call to the server's registration endpoint
    (`/token`). This function sends the token in the request body, which is then saved
    on the server using the `saveToken` function defined in *step 14*.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 6*, we created an event listener that will listen for any new incoming
    push notifications. This is done by calling `Notifications.addListener` and passing
    in a callback function to be executed every time a new notification is received. On
    iOS devices, the system is designed to only produce a push notification if the
    app sending the push notification isn't open and foregrounded. That means if you
    try to send your user a push notification while they're currently using your app,
    they will never receive it.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome this issue, Expo suggests manually displaying the push notification
    data from within your app. This `Notifications.addListener` method was created
    to fulfill this need. When a push notification is received, the callback passed
    to `addListener` will be executed and will receive the new notification object
    as a parameter. In *step 7*, we saved this notification to `state` so that the
    UI would be re-rendered accordingly. We only displayed the message text in a `Text`
    component in this recipe, but you could also use a modal for a more notification-like
    presentation.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 11*, we created the `sendMessage` function, which posts the message
    text stored on `state` to the server's `/message` endpoint. This will execute
    the `handlePushToken` server function defined in *step 15*.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 13*, we started working on the server, which utilizes Express and the
    Expo server SDK. A new server is created with express by calling `express()` directly,
    as a local const, usually named `app` by convention. We were able to create a
    new Expo server SDK instance with `new Expo()`, storing it in the `expo` const.
    We later used the Expo server SDK to send the push notification using `expo`,
    define routes using `app` in *st**eps 17* to  *step 20*, and initiate the server
    by calling `app.listen()` in *step 22*.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 14*, we defined the `saveToken` function, which will be executed when
    the `/token` endpoint is used by the React Native app to register a token. This
    function saves the incoming token to the `savedPushTokens` array, to be used later
    when a message arrives from a user. In a real app, this is where you would likely
    want to save the tokens to a persistent database of some kind, such as SQL, MongoDB,
    or Firebase Database.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *step 15*, we started defining the `handlePushTokens` function, which runs
    when the React Native app uses the `/message` endpoint. The function loops over
    the `savedPushTokens ` array for processing. Each token is checked for validity
    using the Expo server SDK''s `isExpoPushToken `method, which takes in a token
    and returns `true` if the token is valid. If it''s invalid, we log an error to
    the server console. If it''s valid, we push a new notification object onto the
    local `notifications` array for batch processing in the next step. Each notification
    object requires a `to` property with the value set to a valid Expo push token.
    All other properties are optional. The optional properties we set were as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sound**: Can be default to play the default notification sound or `null`
    for no sound'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Title**: The title of the push notification, usually displayed in bold'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Body**: The body of the push notification'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data**: A custom data JSON object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In *step 16*, we used the Expo server SDK''s `chunkPushNotifications` instance
    method to create an array of data chunks optimized for sending to Expo''s push
    notification server. We then looped over the chunks, and sent each chunk to Expo''s
    push notification server via the `expo.sendPushNotificationsAsync` method. It
    returned a promise that resolved to an array of receipts for each push notification.
    If the process is successful, there will be a `{ status: ''ok'' }` object for
    each notification in the array.'
  prefs: []
  type: TYPE_NORMAL
- en: This endpoint's behavior is simpler than a real server would probably be, because
    most message applications would have a more complicated way of handling a message.
    At the very least, there would likely be a list of recipients that would dictate
    which registered devices would in turn receive a particular push notification.
    The logic was intentionally kept simple to portray the basic flow.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 18*, we defined the first accessible route on our server, the root
    (`/`) path. Express provides the `get` and `post` helper methods for easily making
    API endpoints for `GET` and `POST` requests respectively. The callback function
    receives a request object and response object as parameters. All server URLs need
    to respond to the request; otherwise, the request would time out. The response
    is sent via the `send` method on the response object. This route doesn't process
    any data, so we just returned the string indicating that our server is running.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 19* and *step 20*, we defined `POST` endpoints for `/token` and `/message`,
    which will execute `saveToken` and `handlePushTokens` respectively. We also added
    `console.log` statements to each, to log the token and the message to the server
    Terminal for ease of development.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 21*, we defined the `listen` method on our Express server, which starts
    the server. The first parameter is the port number to listen for requests on,
    and the second parameter is a callback function, usually used to `console.log`
    a message to the server Terminal that the server has been started.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *step 22*, we added a custom script to the `package.json` file of our project.
    Any command that can be run in the Terminal can be made a custom npm script by
    adding a `scripts` key to the `package.json` file set to an object whose keys
    are the name of the custom script, and whose values are the command that should
    be executed when that custom script is run. In this recipe, we defined a custom
    scripted named `serve` that runs the `node -r esm server/index.js `command. This
    command runs our server file (`server/index.js`) with Node, using the `esm` npm
    package we installed at the beginning of this recipe. Custom scripts can be executed
    with `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'They can also be executed using `yarn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Push notifications can be complicated, but thankfully Expo simplifies the process
    in a number of ways. There's great documentation on Expo's push notification service,
    which covers the specifics of notification timing, Expo server SDKs in other languages,
    and how to implement notifications over HTTP/2\. I encourage you to read more
    at [https://docs.expo.io/versions/latest/guides/push-notifications](https://docs.expo.io/versions/latest/guides/push-notifications).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing browser-based authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Logging in with Facebook *recipe in [Chapter 8](b41f8c20-f817-4b29-992b-18f8bcd6f071.xhtml), *Working
    with Application Logic and Data*, we will cover using the Expo `Facebook` component
    to create a login workflow for providing our app with the user's basic Facebook
    account information. Expo also provides a `Google` component, which provides similar
    functionality for getting a user's Google account information. But what do we
    do if we want to create a login workflow that uses account information from a
    different site? In this case, Expo provides the `AuthSession` component.
  prefs: []
  type: TYPE_NORMAL
- en: '`AuthSession` is built on Expo''s `WebBrowser` component, which we''ve already
    used in [Chapter 4](c6579db8-eca6-469d-8134-6e3c64b5c2fa.xhtml), *Implementing
    Complex User Interfaces – Part II*. The typical login workflow consists of four
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The user initiates the login process
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The web browser opens to the login page
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The authentication provider provides a redirect on successful login
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The React Native app handles the redirect
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this app, we'll be using the Spotify API to get Spotify account information
    for our app via user login. Head over to [https://beta.developer.spotify.com/dashboard/applications](https://beta.developer.spotify.com/dashboard/applications) to
    create a new Spotify dev account (if you don't already have one) and a new app.
    The app can be named whatever you like. Once the app is created with Spotify,
    you'll see a client ID string displayed in the information for your app. We'll
    need this ID when building the React Native app.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will need a new app for this recipe. Let's name the app `browser-based-auth`.
  prefs: []
  type: TYPE_NORMAL
- en: The redirect URI also needs to be whitelisted in the Spotify app we created
    previously. The redirect should be in the form of `https://auth.expo.io/@YOUR_EXPO_USERNAME/YOUR_APP_SLUG`.
    Since my Expo username is `warlyware`, and since this React Native app we're building
    is named `browser-based-auth`, my redirect URI is `https://auth.expo.io/@warlyware/browser-based-auth`.
    Be sure to add this to the Redirect URIs list in the settings of the Spotify app.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start by opening `App.js` and importing the dependencies we will be
    using:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also declare the `CLIENT_ID` as a constant to be used later. Copy the
    client ID for the Spotify app we created previously so that we can save it in
    the `CLIENT_ID` const:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create the `App` class and the initial `state`. The `userInfo` property
    will hold the user information we receive back from the Spotify API, and `didError`
    is a Boolean for tracking whether an error occurred during login:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s define the method that logs the user in to Spotify. The `AuthSession`
    component''s `getRedirectUrl` method provides the redirect URL needed for returning
    to the React Native app after login, which is the same redirect URI we saved in
    the Spotify app in the *Getting ready* section of this recipe. We''ll then use
    the redirect URL in the login request, which we''ll launch with the `AuthSession.startAsync`
    method, passing in an options object with the `authUrl` property set to the Spotify
    endpoint for authorizing user data with an app. There''s more information on this
    URL in the *How it works... *section at the end of this recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'We saved the results of hitting the Spotify endpoint for user authentication
    in the local `results `variable. If the `type` property on the results object
    returns anything other than `''success''`, then an error occurred, so we''ll update
    the `didError` property of `state` accordingly. Otherwise, we''ll hit the `/me`
    endpoint with the access token we received from authorization to get the user''s
    info, which we''ll save to `this.state.userInfo`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the `auth` related methods are defined, let''s create the `render`
    function. We''ll use the `FontAwesome` Expo icon library to display the Spotify
    logo, add a button to allow the user to log in, and add methods for rendering
    either an error or the user info, depending on the value of `this.state.didError`.
    We''ll also disable the login button once there''s data saved on the `userInfo`
    property of `state`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s define the JSX for handling errors. The template just displays
    a generic error message to indicate that the user should try again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The `displayResults` function will be a `View` component that displays the
    user''s image, username, and email address if there is `userInfo` saved to `state`,
    otherwise it will prompt the user to log in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The styles for this recipe are quite simple. It uses a column flex layout,
    applies the Spotify color scheme of black and green, and adds font sizes and margins:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we look at the app, we should be able to log in to Spotify, and see
    the associated image, username, and email address for the account used to log
    in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/5d4f47b5-36b9-4733-87ff-2fa6f8554563.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *step 4*, we created the method for handling the Spotify login process. The
    `AuthSession.startAsync` method just needed an `authUrl`, which was provided by
    the Spotify Developers documentation. The four pieces required are the `Client-ID`,
    the redirect URI for handling the response from Spotify, a `scope` parameter indicating
    the scope of user information the app is requesting, and a `response_type` parameter
    of `token`. We only need basic information from the user, so we requested a scope
    type of `user-read-email`. For information on all the scopes available, check
    the documentation at [https://beta.developer.spotify.com/documentation/general/guides/scopes/](https://beta.developer.spotify.com/documentation/general/guides/scopes/).
  prefs: []
  type: TYPE_NORMAL
- en: In *step 5*, we completed the Spotify login handler. If the login was not successful,
    we updated `didError` on `state` accordingly. If it was successful, we used that
    response to access the Spotify API endpoint for getting user data ([https://api.spotify.com/v1/me](https://api.spotify.com/v1/me)).
    We defined the `Authorization` header of the `GET` request with `Bearer ${results.params.access_token}`
    to validate the request, as per Spotify's documentation. On the success of this
    request, we stored the returned user data in the `userInfo` `state` object, which
    re-rendered the UI and displayed the user's information.
  prefs: []
  type: TYPE_NORMAL
- en: For a deeper dive into Spotify's auth process, you can find the guide at [https://beta.developer.spotify.com/documentation/general/guides/authorization-guide/](https://beta.developer.spotify.com/documentation/general/guides/authorization-guide/).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Expo Permissions docs: [https://docs.expo.io/versions/latest/sdk/permissions](https://docs.expo.io/versions/latest/sdk/permissions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expo `MapView` docs: [https://docs.expo.io/versions/latest/sdk/map-view](https://docs.expo.io/versions/latest/sdk/map-view)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Airbnb's React Native Maps package: [https://github.com/react-community/react-native-maps](https://github.com/react-community/react-native-maps)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expo Audio docs: [https://docs.expo.io/versions/latest/sdk/audio](https://docs.expo.io/versions/latest/sdk/audio)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React Native Image Prefetch docs: [https://facebook.github.io/react-native/docs/image.html#prefetch](https://facebook.github.io/react-native/docs/image.html#prefetch)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React Native Snap Carousel Custom Interpolations docs: [https://github.com/archriss/react-native-snap-carousel/blob/master/doc/CUSTOM_INTERPOLATIONS.md](https://github.com/archriss/react-native-snap-carousel/blob/master/doc/CUSTOM_INTERPOLATIONS.md)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expo Push Notifications docs: [https://docs.expo.io/versions/latest/guides/push-notifications](https://docs.expo.io/versions/latest/guides/push-notifications)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Express Basic Routing guide: [https://expressjs.com/en/starter/basic-routing.html](https://expressjs.com/en/starter/basic-routing.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: esm package: [https://github.com/standard-things/esm](https://github.com/standard-things/esm)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expo server SDK for Node: [https://github.com/expo/exponent-server-sdk-node](https://github.com/expo/exponent-server-sdk-node)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ngrok package: [https://github.com/inconshreveable/ngrok](https://github.com/inconshreveable/ngrok)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
