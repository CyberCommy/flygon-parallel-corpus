- en: Chapter 5. Performance Optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are now completely able to scan many different types of hosts, and overcome
    a plethora of methods that system administrators and network engineers use to
    defend or mask their machines. Excellent! At this juncture, we will begin to look
    at some of the broader strokes that Nmap can address: specifically, the difficulty
    we may encounter if we attempt to scan large swaths of IP addresses that may create
    performance disruptions.'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, using advanced Nmap options, which we learned about in the last
    chapter, can make scans take significantly longer time than we may have. Performance
    optimization techniques are some of the least used but most useful Nmap flags,
    so it's worth it to learn them well—and to employ them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic Nmap timing optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customized host group sizes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to increase or decrease Nmap's parallelism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to deal with stuck hosts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to delay (or increase the rate of) individual packets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nmap timing optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The easiest way to make a scan run faster is to use the built-in `timing` flags.
    These flags are invoked using `-T` and a number from 1 (slowest) to 5 (fastest).
    The default scanning speed is `-T3`, right in the middle.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few risks to use significantly faster scanning, since it creates
    certain unreliable aspects in the scan. Particularly, if your network interface
    is known to be reliable, these options should be used with caution!
  prefs: []
  type: TYPE_NORMAL
- en: The default timing flags change six different elements—many of which we'll go
    into specific detail, later in this chapter. Specifically, the timing flags change
    the individual values of `initial_rtt_timeout`, `min_rtt_timeout`, `max_rtt_timeout`,
    `max_parallelism`, `scan_delay`, and `max_scan_delay`. Don't worry if these flags
    sound strange to you—we'll cover the different ones you need to know in enough
    detail that you should be able to debug a large variety of network and performance
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: '![Nmap timing optimization](img/BO4089_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot, downloaded from [http://www.professormesser.com/](http://www.professormesser.com/),
    shows how the `-T` flags optimize in various different ways. The most important
    distinctions are the parallel to serial transition between `-T3` and `-T2` (meaning
    that hosts are no longer scanned at the same time), and the significant time out
    differences across the board.
  prefs: []
  type: TYPE_NORMAL
- en: System administrators also make the target less vulnerable by increasing the
    time to respond, as much of the time host information can be read from TTL values,
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Running an "insane" scan can clearly make a large network block go faster, but
    it's interesting to note that on the other end of the spectrum, "sneaky" and "paranoid"
    scans (`-T1` and `-T0`) can be very effective at "hiding" port scans.
  prefs: []
  type: TYPE_NORMAL
- en: If we are working on a penetration testing engagement with intrusion detection
    systems and intrusion prevention systems running, it can be very beneficial to
    run these slow scans.
  prefs: []
  type: TYPE_NORMAL
- en: '![Nmap timing optimization](img/BO4089_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding screenshot, a `-T5` scan against `scanme.nmap.org`
    (including all ports) took only one minute (and one second), as is visible in
    the output from the `time` command and Nmap's own timing calculator. On the other
    hand, running a `-T1` scan—otherwise called "sneaky"—takes significantly longer.
  prefs: []
  type: TYPE_NORMAL
- en: In order to show the true effect of a long-term slow scan, we ran a `-T1` scan
    against the same host—you can see here that after sixteen hours, the scan was
    still only 2.75% done—that is a very slow scan! It's easy to see how we wouldn't
    want these scanning options to go through a large block of IP addresses, but that
    to be extra stealthy on a client engagement (such as one running an IDS or IPS),
    it could be invaluable.
  prefs: []
  type: TYPE_NORMAL
- en: '![Nmap timing optimization](img/BO4089_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Customized host group sizes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to scan hosts efficiently, Nmap uses groups of hosts that it scans
    at the same time. Assuming your Internet connection (and computer processing power)
    is sufficient, it's generally better to increase the host group sizes to finish
    large scans quickly. For example, if you're scanning 1,000 hosts with a host group
    size of 250, it will only take four "sweeps" to complete the full scan in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: However, one should carefully weigh what they're looking to achieve by changing
    the host group sizes. The benefit of scanning many hosts at once is clear, but
    the downside may not be—if you're scanning a large group, you have to wait for
    the entire host group to be finished scanning before seeing any results and moving
    onto another group. If you are trying to see results quickly, a smaller host group
    would be better for your specific scan.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Nmap tries to take a dynamic middle-ground approach to host group
    sizes: it dynamically changes the host groups to accommodate a verbose scan (so
    we can see what''s happening) and efficiency (so the full scan finishes quickly).
    Nmap starts host groups as low as 4 or 5, and increases them to as high as 1024—all
    automatically.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re looking for fine-tuned control, however, there are two host group
    flags you should keep in mind: `--min-hostgroup` and `--max-hostgroup`. If you''re
    planning to scan a full class C network, for example, specifying a group size
    of 256 would finish this run-through in one large, parallel pass—greatly increasing
    the efficiency of the scanning engine.'
  prefs: []
  type: TYPE_NORMAL
- en: It's worth noting that host group specification does not work for host discovery
    scans, including ping sweeps—Nmap will automatically use very large (usually 4096)
    host groups in order to make these run efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Increasing and decreasing parallelism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although the host group size customization we just learned about can help increase
    or decrease parallelism in full scans, it doesn't deal with the numbers of probes
    that are being sent out at a time. The actual parallelism flags, however, can
    help us deal with that!
  prefs: []
  type: TYPE_NORMAL
- en: As with many things, Nmap will attempt to automatically create the most efficient
    scanning groups, which is great for almost all instances. In my experience, changing
    the number of simultaneous probes being sent out without having a serious education
    in networking can result in disaster—but that's not always the case.
  prefs: []
  type: TYPE_NORMAL
- en: By increasing the value of `--min-parallelism`—say up to 10 or 12—you can force
    Nmap to scan at least that fast. Nmap will still make the scan run faster if it
    needs to, which reduces some of the risk.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, it's possible to set the value of `--max-parallelism` as
    low as 1\. This is very useful; in the sense that you can force Nmap to send out
    only one probe at a time, but also force the tool to run extremely slowly (as
    you might imagine). We can use tricks like this to fool security systems, or to
    ensure that the reliability of our scans are never impacted by network-related
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: If you see hosts that appear to not be finishing, or you're very concerned with
    the number of hosts that are scanned in a current group, adjusting parallelism
    can be very useful.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with stuck hosts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unfortunately, when dealing with large blocks of IP addresses—which is a very
    common occurrence if you're scanning a large enterprise, whether for internal
    security purposes or as a client engagement—it isn't uncommon to deal with stuck
    hosts.
  prefs: []
  type: TYPE_NORMAL
- en: When a host gets stuck, it means that something is stopping the scan from completing
    at a normal rate. This could be caused by something benign such as a network hiccup
    on either end of the connection, or something more intentional such as a security
    software that is intentionally making the target host respond very slowly or inconsistently—effectively
    breaking the scan.
  prefs: []
  type: TYPE_NORMAL
- en: For the purposes of demonstration, I am going to start a ping agnostic (`-Pn`)
    scan against a host that doesn't exist on my network. There's no way you can get
    results from it, but it can still take a very long time to scan.
  prefs: []
  type: TYPE_NORMAL
- en: '![Dealing with stuck hosts](img/BO4089_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see in the preceding screenshot that it took 1,051 seconds—or seventeen
    minutes—to scan this non-existent host. Nmap did the best it could to change RTT
    variables in an attempt to compensate for any network problems, but in the end
    it took a very long time to realize that nothing was there. Think about what would
    happen if you were scanning a Class B network! We would be waiting for days, weeks,
    or years for the scan to complete. No one wants to watch an unresponsive Nmap
    screen!
  prefs: []
  type: TYPE_NORMAL
- en: '![Dealing with stuck hosts](img/BO4089_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this second scan against a host that doesn't exist, we kept the same flags,
    but changed `--host-timeout` to 1 minute. As you can see, after 60 seconds, Nmap
    gave up on the host and finished the scan—one seventeenth of the time it would
    have taken to complete!
  prefs: []
  type: TYPE_NORMAL
- en: The `--host-timeout` flag is very useful, especially in large scans, but make
    sure that you don't set the time too low—or Nmap will give up on hosts that it
    was still actively scanning! In many assessments, my team will set `--host-timeout`
    to 10 minutes, which generally is enough time for many port scans to complete
    without any error per host. Combined with parallelism and host group customization,
    setting a host time out flag can save significant amounts of time on larger target
    hosts.
  prefs: []
  type: TYPE_NORMAL
- en: Delaying and increasing probe rates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last important timing improvement flag to understand is delaying and increasing
    rates directly. This is probably the most fine-tuned of the performance optimization,
    and should generally only be used if there is a specific problem you are trying
    to solve, or a situation you are trying to create.
  prefs: []
  type: TYPE_NORMAL
- en: The first of these flags, `--scan-delay`, specifies the amount of time that
    Nmap should wait, not doing anything, between probes. This can be extremely useful
    in slowing scans down (and sometimes speeding them up, with a low scan-delay).
    Again, the most common usage of slowing down scans is to avoid detection of a
    target administrator or security system, or to try to avoid network throttling
    issues. Since many systems use the rate at which requests are being made to determine
    whether or not the machine is under attack, this can be a very stealthy technique
    without very much effort on the part of the tester. It's also useful to note that
    `--max-scan-delay` can be used in conjunction with other timing flags to supersede
    them, and ensure that scan delays are never slower than a certain amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: '![Delaying and increasing probe rates](img/BO4089_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see in the preceding screenshot that increasing `--scan-delay` to 5
    seconds made a four-port scan (plus ping sweep) take 41 seconds. Not great for
    efficiency, but perfect to conceal what's happening!
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, direct control of Nmap's rates can also be set using a combination of
    `--min-rate` and `--max-rate`, which controls the packets per second sent over
    the network. It's worth noting that Nmap's internal controls for these settings
    are very good, but on occasion, more fine-tuned control is necessary. By setting
    flags such as `--min-rate 1` and `--max-rate 100`", we can allow Nmap's built-in
    timing engine to control efficiency—but never send more than 100 packets per second
    or less than 1 per second. As with many of these flags, it's important to never
    set the minimum value too high or the maximum value too low!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter taught us some very valuable timing flags—Nmap is versatile enough
    to include many options that can help us make sure we have complete control over
    timing, in order to maximize efficiency and overcome potential pitfalls.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we covered basic Nmap timing optimization, customized host
    group sizes, how to increase or decrease Nmap's parallelism, how to deal with
    stuck hosts, and how to delay (or increase the rate of) individual packets.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will talk about one of the most interesting and powerful
    features of Nmap: the **Nmap Scripting Engine** (**NSE**). We''ll talk about what
    the NSE is, what it can do, and how to invoke interesting scripts using it.'
  prefs: []
  type: TYPE_NORMAL
