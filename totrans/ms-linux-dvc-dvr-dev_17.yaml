- en: '*Chapter 14*: Linux Kernel Debugging Tips and Best Practices'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the time, as part of development, writing code is not the hardest part.
    Things are rendered difficult by the fact that the Linux kernel is a standalone
    software that is at the lowest layer of the operating system. This makes it challenging
    to debug the Linux kernel. However, this is compensated by the fact that the majority
    of the time, we don't need additional tools to debug kernel code because most
    of the kernel debugging tools are part of the kernel itself. We will begin by
    familiarizing ourselves with the Linux kernel release model and you will learn
    the Linux kernel release process and steps. Then, we will look at the Linux kernel
    debugging-related development tips (especially debugging by printing) and finally,
    we will focus on tracing the Linux kernel, ending with off-target debugging and
    learning to leverage kernel oops.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Linux kernel release process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux kernel development tips
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux kernel tracing and performance analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux kernel debugging tips
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are prerequisites for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Advanced computer architecture knowledge and C programming skills
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux kernel v4.19.X sources, available at [https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Linux kernel release process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'According to the Linux kernel release model, there are always three types of
    active kernel release: mainline, the stable release, and the **Long-Term Support**
    (**LTS**) release. First, bug fixes and new features are gathered and prepared
    by subsystem maintainers and then submitted to Linus Torvalds in order for him
    to include them in his own Linux tree, which is called the *mainline Linux tree*,
    also known as the *master* Git repository. This is where every stable release
    originates from.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before each new kernel version is released, it is submitted to the community
    through *release candidate* tags, so that developers can test and polish all the
    new features and, most importantly, share feedback. During this cycle, Linus will
    rely on the feedback in order to decide whether the final version is ready to
    be released. When he is convinced that the new kernel is ready to go, he makes
    (tags it actually) the final release, and we call this release *stable* to indicate
    that it''s no longer a *release candidate*: those releases are *vX.Y* versions.'
  prefs: []
  type: TYPE_NORMAL
- en: There is no strict timeline for making releases. However, new mainline kernels
    are generally released every 2–3 months. Stable kernel releases are based on Linus's
    releases, that is, the mainline tree releases.
  prefs: []
  type: TYPE_NORMAL
- en: Once a mainline kernel is released by Linus, it also appears in the *linux-stable*
    tree (available at [https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/)),
    where it becomes a branch and from where it can receive bug fixes for a stable
    release. *Greg Kroah-Hartman* is responsible for maintaining this tree, which
    is also referred to as the stable tree because it is used to track previously
    released stable kernels. That said, in order for a fix to be applied to this tree,
    this fix must first be incorporated in the Linus tree. Because the fix must go
    forth before coming back, it is said that this fix is back-ported. Once the bug
    is fixed in the mainline repository, it can then be applied to previously released
    kernels that are still maintained by the kernel development community. All fixes
    back-ported to stable releases must meet a set of mandatory acceptance criteria
    — and one of these criteria is that they **must already exist in Linus's tree**.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Bugfix kernel releases are considered stable.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `4.9` kernel is released by Linus, and then the stable kernel
    releases based on this kernel are numbered `4.9.1`, `4.9.2`, `4.9.3`, and so on.
    Such releases are known as *bugfix kernel releases*, and the sequence is usually
    shortened with the number *4.9.y* when referring to their branch in the stable
    kernel release tree. Each stable kernel release tree is maintained by a single
    kernel developer, who is responsible for picking the requisite patches for the
    release, and for performing the review/release process. There are usually only
    a few bugfix kernel releases until the next mainline kernel becomes available,
    unless it is designated a *long-term maintenance kernel*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every subsystem and kernel maintainer repository is hosted here: [https://git.kernel.org/pub/scm/linux/kernel/git/](https://git.kernel.org/pub/scm/linux/kernel/git/).
    There, we can also find either Linus or stable trees. In the Linus tree ([https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/)),
    there is only one branch in Linus''s tree, that is, the master branch. Tags in
    there are either stable releases or release candidates. In the stable tree ([https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/)),
    there is one branch per stable kernel release (named *<A.B>.y*, where *<A.B>*
    is the release version in the Linus tree) and each branch contains its bugfix
    kernel releases.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: There are a few links that you can keep to hand in order to follow the Linux
    kernel release. The first one is [https://www.kernel.org/](https://www.kernel.org/),
    from where you can download kernel archives, and then there is [https://www.kernel.org/category/releases.html](https://www.kernel.org/category/releases.html),
    from where you can access the latest LTS kernel releases and their support timelines.
    You can also refer to this link, [https://patchwork.kernel.org/](https://patchwork.kernel.org/),
    from where you can follow kernel patch submissions on a subsystem basis.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are familiar with the Linux kernel release model, we can delve into
    some development tips and best practices, which helps to consolidate and leverage
    other kernel developer experiences.
  prefs: []
  type: TYPE_NORMAL
- en: Linux kernel development tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best Linux kernel development practices are inspired by existing kernel
    code. This way, you could certainly learn good practices. That said, we will not
    reinvent the wheel. We will focus on what is necessary for this chapter, that
    is, debugging. The most frequently used debugging method involves logging and
    printing. In order to leverage this time-tested debugging technique, the Linux
    kernel provides suitable logging APIs and exposes a kernel message buffer to store
    the logs. Though it may seem obvious, we will focus on the kernel logging APIs
    and learn how to manage the message buffer, either from within the kernel code
    or from user space.
  prefs: []
  type: TYPE_NORMAL
- en: Message printing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Message printing and logging are inherent to development, irrespective of whether
    we are in kernel space or user space. In a kernel, the `printk()` function has
    long since been the de facto kernel message printing function. It is similar to
    `printf()` in the C library, but with the concept of log levels.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at an example of actual driver code, you''ll notice it is used
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, `<LOG_LEVEL>` is one of the eight different log levels defined in `include/linux/kern_levels.h`
    and specifies the severity of the error message. You should also note that there
    is no comma between the log level and the format string (as the preprocessor concatenates
    both strings).
  prefs: []
  type: TYPE_NORMAL
- en: Kernel log levels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Linux kernel uses the concept of levels to determine how critical the message
    is. There are eight of them, each defined as a string, and they are described
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`KERN_EMERG`, defined as `"0"`. It is to be used for emergency messages, meaning
    the system is about to crash or is unstable (unusable).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KERN_ALERT`, defined as `"1"`, meaning that something bad happened and action
    must be taken immediately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KERN_CRIT`, defined as `"2"`, meaning that a critical condition occurred,
    such as a serious hardware/software failure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KERN_ERR`, defined as `"3"` and used during an error condition, often used
    by drivers to indicate difficulties with the hardware or a failure to interact
    with a subsystem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KERN_WARNING`, defined as `"4"` and used as a warning, meaning nothing serious
    by itself, but may indicate problems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KERN_NOTICE`, defined as `"5"`, meaning nothing serious, but notable nevertheless.
    This is often used to report security events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KERN_INFO`, defined as `"6"`, used for informational messages, for example,
    startup information at driver initialization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KERN_DEBUG`, defined as `"7"`, used for debugging purposes, and active only
    if the `DEBUG` kernel option is enabled. Otherwise, its content is simply ignored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you don't specify a log level in your message, it defaults to `DEFAULT_MESSAGE_LOGLEVEL`
    (usually `"4"` = `KERN_WARNING`), which can be set via the `CONFIG_DEFAULT_MESSAGE_LOGLEVEL`
    kernel configuration option.
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, for new drivers, you are encouraged to use more convenient printing
    APIs, which embed the log level in their names. Those printing helpers are `pr_emerg`,
    `pr_alert`, `pr_crit`, `pr_err`, `pr_warning`, `pr_warn`, `pr_notice`, `pr_info`,
    `pr_debug`, or `pr_dbg`. Besides being more concise than the equivalent `printk()`
    calls, they can use a common definition for the format string through the `pr_fmt()`
    macro; for instance, defining this at the top of a source file (before any `#include`
    directive):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This would prefix every `pr_*()` message in that file with the module and function
    name that originated the message. `pr_devel` and `pr_debug` are replaced with
    `printk(KERN_DEBUG …)` if the kernel was compiled with `DEBUG`, otherwise they
    are replaced with an empty statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pr_*()` family macros are to be used in core code. For device drivers,
    you should use the device-related helpers, which also accept the concerned device
    structure as a parameter. They also print the name of the relevant device in standard
    form, ensuring that it''s always possible to associate a message with the device
    that generated it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: While the concept of log levels is used by the kernel to determine the importance
    of a message, it is also used to decide whether this message should be presented
    to the user immediately, by printing it to the current console (where the console
    could also be a serial line or even a printer, not an `xterm`).
  prefs: []
  type: TYPE_NORMAL
- en: In order to decide, the kernel compares the log level of the message with the
    `console_loglevel` kernel variable, and if the message log level importance is
    higher (that is, a lower value) than `console_loglevel`, the message will be printed
    to the current console. Since the default kernel log level is usually `"4"`, this
    is the reason why you don't see `pr_info()` or `pr_notice()` or even `pr_warn()`
    messages on the console, as they have higher or equal values (which means lower
    priority) than the default one.
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine the current `console_loglevel` on your system, you can simply
    type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first integer (`4`) is the current console log level, the second number
    (`4`) is the default one, the third number (`1`) is the minimum console log level
    that can be set, and the fourth number (`7`) is the boot-time default console
    log level.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change your current `console_loglevel`, simply write to the same file, that
    is, `/proc/sys/kernel/printk`. Hence, in order to get all messages printed to
    the console, perform the following simple command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Every kernel message will appear on your console. You''ll then have the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to change the console log level is to use `dmesg` with the `-n`
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding command, `console_loglevel` is set to print `KERN_WARNING`
    (`4`) or more severe messages. You can also specify the `console_loglevel` at
    boot time using the `loglevel` boot parameter (refer to `Documentation/kernel-parameters.txt`
    for more details).
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also `KERN_CONT` and `pr_cont`, which are sort of special since they
    do not specify a level of urgency, but rather indicate a continued message. They
    should only be used by core/arch code during early bootup (a continued line is
    not SMP-safe otherwise). This can be useful when part of a message line to be
    printed depends on the result of a computation, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You should keep in mind that only the final print statement has the trailing
    `\n` character.
  prefs: []
  type: TYPE_NORMAL
- en: Kernel log buffer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whether they are immediately printed on the console or not, each kernel message
    is logged in a buffer. This kernel message buffer is a fixed-size circular buffer,
    which means that if the buffer fills up, it wraps around and you may lose a message.
    Thus, increasing the buffer size could be helpful. In order to change the kernel
    message buffer size, you can play with the `LOG_BUF_SHIFT` option, the value of
    which is used to left-shift by 1 in order to obtain the final size, the kernel
    log buffer size (for example, `16` => `1<<16` => `64KB`, `17` => `1 << 17` =>
    `128KB`). That said, it is a static size defined at compile time. This size can
    also be defined through kernel boot parameters, by using the `log_buf_len` parameter,
    in other words, `log_buf_len=1M` (accept only power of 2 values).
  prefs: []
  type: TYPE_NORMAL
- en: Adding timing information
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sometimes, it is useful to add timing information to the printed messages,
    so you can see when a particular event occurred. The kernel includes a feature
    for doing this, called `printk times`, enabled through the `CONFIG_PRINTK_TIME`
    option. This option is found on the **Kernel Hacking** menu when configuring the
    kernel. Once enabled, this timing information prefixes each log message as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The timestamps that are inserted into the kernel message output consist of seconds
    and microseconds (`seconds.microseconds` actually) as absolute values from the
    start of machine operation (or from the start of kernel timekeeping), which corresponds
    to the time when the bootloader passes control to the kernel (when you see something
    like `[ 0.000000] Booting Linux on physical CPU 0x0` on the console).
  prefs: []
  type: TYPE_NORMAL
- en: 'Printk times can be controlled at runtime by writing to `/sys/module/printk/parameters/time`
    in order to enable and disable `printk` timestamps. The following are examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It does not control whether the timestamp is logged. It only controls whether
    it is printed while the kernel message buffer is being dumped, at boot time, or
    while using `dmesg`. This may be an area for boot-time optimization. If disabled,
    it would take less time for logs to be printed.
  prefs: []
  type: TYPE_NORMAL
- en: We are now familiar with kernel printing APIs and their log buffer. We have
    seen how to tweak the message buffer, and add or remove information according
    to requirements. Those skills can be used for debugging by printing. However,
    other debugging and tracing tools are shipped in the Linux kernel, and the following
    section will introduce some of them.
  prefs: []
  type: TYPE_NORMAL
- en: Linux kernel tracing and performance analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though debugging by printing covers most of the debugging needs, there are situations
    where we need to monitor the Linux kernel at runtime to track strange behavior,
    including latencies, CPU hogging, scheduling issues, and so on. In the Linux world,
    the most useful tool for achieving this is part of the kernel itself. The most
    important is `ftrace`, which is a Linux kernel internal tracing tool, and is the
    main topic of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Using Ftrace to instrument the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Function Trace**, in short **Ftrace**, does much more than what its name
    says. For example, it can be used to measure the time it takes to process interrupts,
    to track time-consuming functions, calculate the time to activate high-priority
    tasks, to track context switches, and much more.'
  prefs: []
  type: TYPE_NORMAL
- en: Developed by *Steven Rostedt*, Ftrace has been included in the kernel since
    version 2.6.27 in 2008\. This is the framework that provides a debugging ring
    buffer for recording data. This data is gathered by the kernel's integrated tracing
    programs. Ftrace works on top of the `debugfs` filesystem and is, most of the
    time, mounted in its own directory called `tracing` when it is enabled. In most
    modern Linux distributions, it is mounted by default in the `/sys/kernel/debug/`
    directory (this is only available to the root user), meaning that you can leverage
    Ftrace from within `/sys/kernel/debug/tracing/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the kernel options to be enabled in order to support Ftrace
    on your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding options depend on the architecture supporting tracing features
    by having the `CONFIG_HAVE_FUNCTION_TRACER`, `CONFIG_HAVE_DYNAMIC_FTRACE`, and
    `CONFIG_HAVE_FUNCTION_GRAPH_TRACER` options enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'To mount the `tracefs` directory, you can add the following line to your `/etc/fstab`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can mount it at runtime with the help of the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The contents of the directory should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We won''t describe all of these files and subdirectories, as this has already
    been covered in the official documentation. Instead, we''ll just briefly describe
    the files relevant to our context:'
  prefs: []
  type: TYPE_NORMAL
- en: '`available_tracers`: Available tracing programs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tracing_cpumask`: This allows selected CPUs to be traced. The mask should
    be specified in a hex string format. For example, to trace only core `0`, you
    should include a `1` in this file. To trace core `1`, you should include a `2`
    in there. For core `3`, the number `8` should be included.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`current_tracer`: The tracing program that is currently running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tracing_on`: The system file responsible for enabling or disabling data writing
    to the ring buffer (to enable this, the number `1` has to be added to the file;
    to disable it, the number `0` is added).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trace`: The file where tracing data is saved in a human-readable format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have introduced Ftrace and described its functions, we can delve
    into its usage and learn how useful it can be for tracing and debugging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Available tracers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can view the list of available tracers with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a quick look at the features of each tracer:'
  prefs: []
  type: TYPE_NORMAL
- en: '`function`: A function call tracer without arguments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`function_graph`: A function call tracer with subcalls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`blk`: A call and event tracer related to block device I/O operations (this
    is what `blktrace` uses).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mmiotrace`: A memory-mapped I/O operation tracer. It traces all the calls
    that a module makes to the hardware. It is enabled with `CONFIG_ MMIOTRACE`, which
    depends on `CONFIG_HAVE_MMIOTRACE_SUPPORT`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irqsoff`: Traces the areas that disable interrupts and saves the trace with
    the longest maximum latency. This tracer depends on `CONFIG_IRQSOFF_TRACER`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`preemptoff`: Depends on `CONFIG_PREEMPT_TRACER`. It is similar to `irqsoff`,
    but traces and records the amount of time for which preemption is disabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`preemtirqsoff`: Similar to `irqsoff` and `preemptoff`, but it traces and records
    the largest time for which irqs and/or preemption is disabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wakeup` and `wakeup_rt`, enabled by `CONFIG_SCHED_TRACER`: The former traces
    and records the maximum latency that it takes for the highest priority task to
    get scheduled after it has been woken up, while the latter traces and records
    the maximum latency that it takes for just `wakeup` tracer does).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nop`: The simplest tracer, which, as the name suggests, doesn''t do anything.
    The `nop` tracer simply displays the output of `trace_printk()` calls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irqsoff`, `preemptoff`, and `preemtirqsoff` are the so-called latency tracers.
    They measure how long interrupts are disabled for, how long preemption is disabled
    for, and how long interrupts and/or preemption are disabled for. Wakeup latency
    tracers measure how long it takes a process to run after it has been awoken for
    either all tasks or just RT tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: The function tracer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ll begin our introduction to Ftrace with the function tracer. Let''s look
    at a test script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This script is fairly straightforward, but there are a few things worth noting.
    We enable the current tracer by writing its name to the `current_tracer` file.
    Next, we write a `1` to `tracing_on`, which enables the ring buffer. The syntax
    requires a space between `1` and the `>` symbol; `echo1> tracing_on` will not
    work. One line later, we disable it (if `0` is written to `tracing_on`, the buffer
    won't clear and Ftrace won't be disabled).
  prefs: []
  type: TYPE_NORMAL
- en: 'Why would we do this? Between the two `echo` commands, we see the `sleep 1`
    command. We enable the buffer, run this command, and then disable it. This lets
    the tracer include information relating to all of the system calls that occur
    while the command runs. In the last line of the script, we give the command to
    display tracing data in the console. Once the script has run, we''ll see the following
    printout (this is just a small fragment):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1 – Ftrace function tracer snapshot'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.1_B10985.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.1 – Ftrace function tracer snapshot
  prefs: []
  type: TYPE_NORMAL
- en: 'The printout starts with information pertaining to the number of entries in
    the buffer and the total number of entries written. The difference between these
    two numbers is the number of events lost while filling the buffer. Then, there''s
    a list of functions that includes the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: The process name (`TASK`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The process identifier (`PID`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The CPU the process runs on (`CPU#`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function start time (`TIMESTAMP`). This timestamp is the time since boot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the function being traced (`FUNCTION`) and the parent function that
    was called following the `<-` symbol. For example, in the first line of our output,
    the `irq_may_run` function was called by `handle_fasteoi_irq`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we are familiar with the function tracer and its specificities, we
    can learn about the next tracer, which is more feature-rich and provides much
    more tracing information, such as the call graph.
  prefs: []
  type: TYPE_NORMAL
- en: The function_graph tracer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `function_graph` tracer works just like a function, but in a more detailed
    manner: the entry and exit point is shown for each function. With this tracer,
    we can trace functions with subcalls and measure the execution time of each function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s edit the script from our previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After running this script, we get the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In this graph, `DURATION` shows the time spent running a function. Pay careful
    attention to the points marked by the `+` and `!` symbols. The plus sign (`+`)
    means the function took more than 10 microseconds, while the exclamation point
    (`!`) means it took more than 100 microseconds. Under `FUNCTION_CALLS`, we find
    information pertaining to each function call. The symbols used to show the initiation
    and completion of each function are the same as in the C programming language:
    bracers (`{}`) demarcate functions, one at the start and one at the end; leaf
    functions that don''t call any other function are marked with a semicolon (`;`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ftrace also allows tracing to be restricted just to functions that exceed a
    certain amount of time, using the `tracing_thresh` option. The time threshold
    at which the functions should be recorded must be written in that file in microsecond
    units. This can be used to find routines that are taking a long time in the kernel.
    It may be interesting to use this at kernel startup, to help optimize boot-up
    time. To set the threshold at startup, you can set it in the kernel command line
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This traces all functions taking longer than 200 microseconds (0.2 ms). You
    can use any duration threshold you want.
  prefs: []
  type: TYPE_NORMAL
- en: At runtime, you can simply execute `echo 200 > tracing_thresh`.
  prefs: []
  type: TYPE_NORMAL
- en: Function filters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Pick and choose what functions to trace. It goes without saying that fewer
    functions to trace equals less overhead. The Ftrace printout can be big, and finding
    exactly what you''re looking for can be extremely difficult. However, we can use
    filters to simplify our search: the printout will only display information about
    the functions we''re interested in. To do this, we just have to write the name
    of our function in the `set_ftrace_filter` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To disable the filter, we add an empty line to this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is the opposite: the printout will give us information about every
    function except `kfree()`. Another useful option is `set_ftrace_pid`. This tool
    is for tracing functions that can be called on behalf of a particular process.'
  prefs: []
  type: TYPE_NORMAL
- en: Ftrace has many more filtering options. For a more detailed look at these, you
    can read the official documentation available at [https://www.kernel.org/doc/Documentation/trace/ftrace.txt](https://www.kernel.org/doc/Documentation/trace/ftrace.txt).
  prefs: []
  type: TYPE_NORMAL
- en: Tracing events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before introducing trace events, let's talk about **tracepoints**. Tracepoints
    are special code inserts that trigger system events. Tracepoints may be dynamic
    (meaning they have several checks attached to them) or static (no checks attached).
  prefs: []
  type: TYPE_NORMAL
- en: 'Static tracepoints do not affect the system in any way; they just add a few
    bytes for the function call at the end of the instrumented function and add a
    data structure in a separate section. Dynamic tracepoints call a trace function
    when the relevant code fragment is executed. Tracing data is written to the ring
    buffer. Tracepoints can be included anywhere in code. In fact, they can already
    be found in a lot of kernel functions. Let''s look at the `kmem_cache_free` function
    excerpt from `mm/slab.c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`kmem_cache_free` is then itself a tracepoint. We can find countless more examples
    just by looking at the source code of other kernel functions.'
  prefs: []
  type: TYPE_NORMAL
- en: The Linux kernel has a special API for working with tracepoints from the user
    space. In the `/sys/kernel/debug/tracing` directory, there is an `events` directory
    where system events are saved. These are available for tracing. System events
    in this context can be understood as the tracepoints included in the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: 'A list of these can be viewed by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'A long list will be printed out in the console with the `<subsystem>:<tracepoint>`
    pattern. This is slightly inconvenient. We can print out a more structured list
    by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: All possible events are combined in the subdirectory by subsystem. Before we
    can start tracing events, we will make sure we've enabled writing to the ring
    buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 1*](B10985_01_ePub_AM.xhtml#_idTextAnchor015), *Linux Kernel Concepts
    for Embedded Developers*, we introduced *hrtimers*. By listing the content of
    `/sys/kernel/debug/tracing/events/timer`, we will have timer-related tracepoints,
    including `hrtimer`-related ones, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now trace the access to `hrtimer`-related kernel functions. For our
    tracer, we''ll use `nop` because `function` and `function_graph` record too much
    information, including event information that we''re just not interested in. The
    following is the script we will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We first disable tracing in case it was already running. Then we clear the
    ring buffer data before setting the current tracer to `nop`. Next, we enable timer-related
    tracepoints, or should we say, we enable timer event tracing. Finally, we enable
    tracing and dump the ring buffer content, which looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.2 – Ftrace event tracing with the nop tracer snapshot'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.2_B10985.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.2 – Ftrace event tracing with the nop tracer snapshot
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the printout, we''ll find information about `hrtimer` function
    calls (here is a small section). More detailed information about configuring event
    tracing can be found here: [https://www.kernel.org/doc/Documentation/trace/events.txt](https://www.kernel.org/doc/Documentation/trace/events.txt).'
  prefs: []
  type: TYPE_NORMAL
- en: Tracing a specific process with the Ftrace interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using Ftrace as is lets you have tracing-enabled kernel tracepoints/functions
    irrespective of the process those functions run on behalf of. To trace just the
    kernel functions executed on behalf of a particular function, you should set the
    pseudo `set_ftrace_pid` variable to the `pgrep`, for example. If the process is
    not already running, you can use a wrapper shell script and the `exec` command
    to execute a command as a known PID, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, `$$` is the PID of the currently executing process
    (the shell script itself). This is set in the `set_ftrace_pid` variable, and then
    the `function_graph` tracer is enabled, after which this script executes the command
    (specified by the first argument to the script).
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming the script name is `trace_process.sh`, an example of usage could be
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now we are familiar with tracing events and tracepoints. We are able to track
    and trace specific kernel events or subsystems. While tracing is a must in terms
    of kernel development, there are situations, which, sadly, affect the stability
    of the kernel. Such cases may require off-target analysis, which is addressed
    in debugging, and is discussed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Linux kernel debugging tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing the code is not always the hardest aspect of kernel development. Debugging
    is the real bottleneck, even for experienced kernel developers. That said, most
    kernel debugging tools are part of the kernel itself. Sometimes, finding where
    the fault originated is assisted by the kernel via messages called **Oops**. Debugging
    then comes down to analyzing the message.
  prefs: []
  type: TYPE_NORMAL
- en: Oops and panic analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Oops are messages printed by the Linux kernel when an error or an unhandled
    exception occurs. It tries its best to describe the exception and dumps the callstack
    just before the error or the exception occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the following kernel module, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding module code, we try to dereference a null pointer in order
    to panic the kernel. Moreover, we use the `__noinline__` attribute in order for
    `create_oops()` not to be inlined, allowing it to appear as a separate function
    during disassembly and in the callstack. This module has been built and tested
    on both the ARM and x86 platforms. Oops messages and content will vary from machine
    to machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s have a closer look at the preceding dump to understand some of the important
    bits of information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line describes the bug and its nature, which in this case states
    that the code tried to dereference a `NULL` pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`create_oops` function, which is located in the `oops` module (which is listed
    in square brackets). The hex numbers indicate that the instruction pointer was
    `24` (`0x18` in hex) bytes into the function, which appears to be `32` (`0x20`
    in hex) bytes long:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`LR` is the link register, which contains the address to which the program
    counter should be set when it reaches a "return from subroutine" instruction.
    In other words, `LR` holds the address of the function that called the currently
    executing function (the one where `PC` is located). First, this means `my_oops_init`
    is the function that called the executing code. It also means that if the function
    in `PC` had returned, the next line to be executed would be `my_oops_init+0x18`,
    which means the CPU would branch at the `0x18` offset from the start address of
    `my_oops_init`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding line of code, `pc` and `lr` are the real hexadecimal content
    of `PC` and `LR`, with no symbol name shown. Those addresses can be used with
    the `addr2line` program, which is another tool we can use to find a faulty line.
    This is what we would see in the printout if the kernel was built with the `CONFIG_KALLSYMS`
    option disabled. We can then deduce that the addresses of `create_oops` and `my_oops_init`
    are `0xbf2a8000` and `0xbf045000`, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '**sp** stands for **stack pointer** and holds the current position in the stack,
    while **fp** stands for **frame pointer** and points to the currently active frame
    in the stack. When a function returns, the stack pointer is restored to the frame
    pointer, which is the value of the stack pointer just before the function was
    called. The following example from Wikipedia explains it quite well:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the stack frame of `DrawLine` would have a memory location holding
    the frame pointer value that `DrawSquare` uses. The value is saved upon entry
    to the subroutine and restored upon return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding is the dump of a number of CPU registers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line shows the process on behalf of which the panic occurred,
    which is `insmod` in this case, and its PID was `20021`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also oops where the backtrace is present, a bit like the following,
    which is an excerpt from the oops generated by typing `echo c > /proc/sysrq-trigger`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.3 – Backtrace excerpt in a kernel oops'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.3_B10985.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.3 – Backtrace excerpt in a kernel oops
  prefs: []
  type: TYPE_NORMAL
- en: 'The backtrace traces the function call history before the one that generated
    the oops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '`Code` is a hex-dump of the section of machine code that was being run at the
    time the oops occurred.'
  prefs: []
  type: TYPE_NORMAL
- en: Trace dump on oops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the kernel crashes, it is possible to use `kdump`/`kexec` with the `crash`
    utility in order to examine the state of the system at the point of the crash.
    However, this technique does not let you see what has happened prior to the event
    that caused the crash, which may be a good input for understanding or fixing the
    bug.
  prefs: []
  type: TYPE_NORMAL
- en: Ftrace is shipped with a feature that tries to address this issue. In order
    to enable it, you can either echo a `1` into `/proc/sys/kernel/ftrace_dump_on_oops`
    or enable `ftrace_dump_on_oops` in the kernel boot parameters. Having Ftrace configured
    along with this feature enabled will instruct Ftrace to dump the entire trace
    buffer to the console in ASCII format on oops or panic. Having the console output
    to a serial line makes debugging crashes much easier. This way, you can set everything
    up and just wait for the crash. Once it occurs, you'll see the trace buffer on
    the console. You'll then be able to trace back the events that led up to the crash.
    How far back you can go in tracing events depends on the size of the trace buffer,
    since this is what stores the event history data.
  prefs: []
  type: TYPE_NORMAL
- en: That said, dumping to the console may take a long time and it is common to shrink
    the trace buffer before putting everything in place, since the default Ftrace
    ring buffer is in excess of 1 megabyte per CPU. You can use `/sys/kernel/debug/tracing/buffer_size_kb`
    in order to reduce the trace buffer size by writing in that file the number of
    kilobytes you want the ring buffer to be. Note that the value is per CPU, and
    not the total size of the ring buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of modifying the trace buffer size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will shrink the Ftrace ring buffer down to 3 kilobytes
    per CPU (1 kb might be enough; it depends on how far you need to go back prior
    to the crash).
  prefs: []
  type: TYPE_NORMAL
- en: Using objdump to identify the faulty code line in the kernel module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use `objdump` to disassemble the object file and identify the line that
    generated the oops. We use the disassembled code to play with the symbol name
    and offset in order to point to the exact faulty line.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line will disassemble the kernel module in the `oops.as` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The generated output file will have content similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the debug option while compiling the module would make the debug info
    available in the `.ko` object. In this case, `objdump -S` would interpose the
    source code and assembly for a better view.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the oops, we have seen that the PC is at `create_oops+0x18`, which is
    at the `0x18` offset from the address of `create_oops`. This leads us to the `18:
    e5833000 str r3, [r3]` line. In order to understand the line of interest to us,
    let''s describe the line before it, `mov r3, #0`. After this line, we have `r3
    = 0`. Back to our line of interest, for people familiar with ARM assembly language,
    it means writing `r3` to the original address pointed to by `r3` (the C equivalent
    of `[r3]` is `*r3`). Remember, this corresponds to `*(int *)0 = 0` in our code.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced a number of kernel debugging tips, and explained how
    to use Ftrace to trace the code in order to identify strange behavior, such as
    time-consuming functions and irq latencies. We covered the printing of APIs, either
    for core- or device driver-related code. Finally, we learned how to analyze and
    debug kernel oops.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter marks the end of this book and I hope you have enjoyed the journey
    through this book while reading it as much as I did while writing it. I also hope
    that my best efforts in imparting my knowledge throughout this book will prove
    useful to you.
  prefs: []
  type: TYPE_NORMAL
