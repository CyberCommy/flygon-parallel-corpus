- en: Managing State in Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing the state of an application is one of the key aspects when architecting
    any software solution, regardless of whether it is a monolith desktop application
    or a complex, distributed system hosted in a cloud environment. Even if most of
    your services in the system are stateless, some part of your system will be stateful,
    for example, a cloud-hosted NoSQL database or a dedicated service you have implemented
    yourself. And if you are aiming at good scalability for your design, you have
    to ensure that the storage for your stateful services scales appropriately. In
    these terms, services or applications hosted in Docker containers are no different
    – you need to manage the state, especially if you want the data to be persisted
    on container restarts or failures.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will provide you with a better understanding of how state
    can be persisted in Docker containers running on Windows and how these concepts
    relate to data persistence in Kubernetes applications. You will learn about the
    concepts of *volumes* and *bind mounts* and how they can be used in order to share
    state between containers and the container host.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Mounting local volumes for stateful applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using remote/cloud storage for container storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running clustered solutions inside containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Windows 10 Pro, Enterprise, or Education (version 1903 or later, 64-bit) installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Desktop for Windows 2.0.0.3 or later installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The installation of Docker Desktop for Windows and its detailed requirements
    were covered in [Chapter 1](deffbcf5-3a21-4690-ad42-ae5e4cd97dea.xhtml)*, Creating
    Containers*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also need your own Azure account. You can read more about how to obtain
    a limited free account for personal use here: [https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the latest code samples for this chapter from this book''s
    official GitHub repository: [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter02](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter02).'
  prefs: []
  type: TYPE_NORMAL
- en: Mounting local volumes for stateful applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand native Docker storage options for stateful applications, we have
    to take a look at how the layer filesystem is organized. The main role of this
    filesystem service is to provide a single virtual logical filesystem for each
    container based on Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker images consist of a series of read-only layers, where each layer corresponds
    to one instruction in a Dockerfile. Let''s take a look at the following Dockerfile
    from the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When building a Docker image, (*almost*) each instruction creates a new layer
    that contains only a set of differences in the filesystem that a given command
    has introduced. In this case, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FROM mcr.microsoft.com/windows/servercore/iis:windowsservercore-1903`: This
    instruction defines the base layer (or a set of layers) from the base image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUN powershell -NoProfile -Command Remove-Item -Recurse C:\inetpub\wwwroot\*`:
    The layer that''s created by this instruction will reflect the deletion of contents
    in the `C:\inetpub\wwwroot\` directory from the original base image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WORKDIR /inetpub/wwwroot`: Even though this instruction is not causing any
    filesystem changes, it will still create **no operation** (**nop**) layer to persist
    this information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COPY index.html .`: This final instruction creates a layer that consists of
    `index.html` in the `C:\inetpub\wwwroot\` directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you have an existing Docker image, you can inspect the layers yourself using
    the `docker history` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, for the image resulting from the preceding Dockerfile, you can
    expect the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b0a4b0a1-5d0b-467a-8027-c23e7a0b972d.png)'
  prefs: []
  type: TYPE_IMG
- en: The bottom five layers come from the `mcr.microsoft.com/windows/servercore/iis:windowsservercore-1903`
    base image, whereas the top three layers are a result of the instructions we described
    previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a new container is created, the filesystem for it is created, which consists
    of read-only image layers and a writeable top layer, also called a container layer.
    For the container, the layers are transparent and processes "see" it as a regular
    filesystem – on the Windows system, this is guaranteed by the *Windows Container
    Isolation File System* service*.* Any changes that are made to the container filesystem
    by the processes inside it are persisted in the writeable layer. This concept
    can be seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/eb1cb350-5f48-4da0-9990-574cc1f58aae.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we know the principles of the layer filesystem in Docker, we can focus
    on *volumes* and *bind mounts*.
  prefs: []
  type: TYPE_NORMAL
- en: Volumes and bind mount
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, it may seem that having a writeable container layer for each
    container is enough to provide state persistence for your application. Data is
    persisted, even if you stop and restart the same container afterward. Unfortunately,
    you would easily discover that containers and their writeable layers are tightly
    coupled and that you cannot easily share data between different containers or
    even new instances of the same image. A simple scenario where this becomes apparent
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Build a container image based on your current Dockerfile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start a new container based on this build.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Introduce some modifications to the writeable container layer; for example,
    a process inside the container modifies a file that stores data for the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, you would like to create a new version of your image by modifying the Dockerfile
    with additional instructions. At the same time, you want to recreate the container
    and reuse the data in the file that has already been modified in the container's
    writable layer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will realize that after recreating the container with the new image version,
    all of the changes that you made to the file using the application state will
    be gone. Apart from this, using the container layer to store data has more disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: The writeable layer is coupled with the container host, which means it isn't
    possible to easily move the data to a different host.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layer filesystems provide worse performance than direct access to the host filesystem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot share the writeable layer between different containers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A general rule of thumb is to avoid storing data in a writeable container layer,
    especially for I/O-intensive applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker provides two solutions for persistent storage that can be mounted into
    a container: volume and bind mounts. In both cases, the data is exposed as a directory
    in the container filesystem and will be persisted, even if the container is stopped
    and deleted. In terms of performance, both volumes and bind mounts access the
    host''s filesystem directly, which means there is no layer filesystem overhead.
    It is also possible to share data between multiple containers using these Docker
    features.'
  prefs: []
  type: TYPE_NORMAL
- en: Bind mounts provide a simple functionality of mounting any *file *or *directory*
    from the container host to a given container. This means that a bind mount will
    act as a shared file or directory between the host and a container. In general,
    it is not recommended to use bind mounts as they are harder to manage than volumes,
    but there are certain use cases when bind mounts are useful, especially on the
    Windows platform, where volume support is limited.
  prefs: []
  type: TYPE_NORMAL
- en: Bind mounts allow you to share any files from the container host. This means
    that if you mount sensitive directories such as `C:\Windows\` to an untrusted
    container, you risk a security breach.
  prefs: []
  type: TYPE_NORMAL
- en: Volumes provide similar functionality to bind mounts but they are fully managed
    by Docker, which means you don't have to worry about physical paths in the container's
    host filesystem. You can create *anonymous* or *named* volumes and then mount
    them into containers. Any data in the volume will not be deleted unless you explicitly
    delete the volume using Docker. A very common use case for volumes is providing
    persistent storage for containers that are running a database instance – when
    the container is recreated, it will use the same volume that contains the data
    that was written by the previous container instance.
  prefs: []
  type: TYPE_NORMAL
- en: The basic functionality of volumes is that they provide storage in the container
    host filesystem. It is also possible to use *volume drivers *(*plugins*), which
    use volume abstraction to access remote cloud storage or network shares. Note
    that, currently, on the Windows platform, there is limited support for volume
    plugins and most of them can only be used on the Linux OS. More on the available
    plugins can be found at [https://docs.docker.com/engine/extend/legacy_plugins/#volume-plugins](https://docs.docker.com/engine/extend/legacy_plugins/#volume-plugins).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a look at how to perform basic operations on Docker volumes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and mounting volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating a new volume can be performed explicitly using the `docker volume
    create` command. It is also possible to create named and anonymous volumes automatically
    when the container starts. To manually create a Docker named volume, follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After creation, you can inspect the details of the volume using the `docker
    volume inspect` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/570e760b-4ffa-4ecf-a854-d552cfbab98c.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the volume data is stored as a regular directory in the host
    filesystem when using the default *local* driver.
  prefs: []
  type: TYPE_NORMAL
- en: 'To mount a volume to a container, you have to use the `--mount` or `--volume`
    (short parameter: `-v`) parameters for the `docker run` command. Originally, `--volume`
    was used for stand-alone containers, whereas `--mount` was used for swarm containers,
    but starting with Docker 17.06, `--mount` can also be used for standalone containers
    and is the recommended practice as it provides more robust options. More about
    these flags can be found in the official documentation: [https://docs.docker.com/storage/volumes/#choose-the--v-or---mount-flag](https://docs.docker.com/storage/volumes/#choose-the--v-or---mount-flag).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to mount a volume:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that you would like to mount `test-named-volume` from the previous
    example in a new PowerShell container under the `C:\Data` directory, you have
    to specify the `--mount` parameter, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Omitting the `source=<volumeName>` parameter will cause the creation of an *anonymous*
    volume that can be accessed using the volume ID later. Bear in mind that if you
    run a container with the `--rm` option, anonymous volumes will be automatically
    deleted when the container is exited.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the container has started and the terminal has been attached, try creating
    a simple file in the directory where a volume has been mounted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, exit the container (which will cause it to stop and be automatically removed
    due to the `--rm` flag) and inspect the volume directory on the host:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To demonstrate that the named volume can be easily mounted in another container,
    let''s create a new container based on the `mcr.microsoft.com/windows/servercore:1903`
    image and with a volume mount target that''s different from the one in the previous
    example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you inspect the volume directory in the container, you will notice that
    the `test.txt` file is present and contains the expected content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to use the `VOLUME` command in a Dockerfile in order to
    force the automatic creation of a volume on container start, even if the `--mount`
    parameter was not provided for the `docker run` command. This is useful if you
    would like to explicitly inform others of where state data is stored by your application
    and also when you need to ensure that the layer filesystem is not introducing
    additional overhead. You can find an example of the `VOLUME` command''s usage
    in the following Dockerfile in the repository for this book: [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter02/03_MongoDB_1903/Dockerfile#L44](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter02/03_MongoDB_1903/Dockerfile#L44).'
  prefs: []
  type: TYPE_NORMAL
- en: In the next subsection, we'll take a quick look at how to remove volumes using
    the Docker CLI.
  prefs: []
  type: TYPE_NORMAL
- en: Removing volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To remove existing named or anonymous volumes using the `docker volume rm`
    command, they cannot be used in any container (even stopped ones). The standard
    procedure would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: For anonymous volumes, if you use the `--rm` flag for the `docker run` command,
    the container will be removed on exit, along with its anonymous volumes. This
    flag should be used depending on the scenario – in most cases, it is useful for
    testing and development purposes to make cleanup easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'During development, you may occasionally need to perform a full cleanup of
    all of the volumes on your Docker host, for example, if you need to free disk
    space. The Docker CLI provides a dedicated command that will remove any volumes
    that are not used in any container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will take a look at bind mounts and how they differ from volumes.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting a local container host directory using bind mounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Bind mounts are the simplest form of persistent storage that is shared between
    the container and the host machine. In this way, you can mount any existing directory
    from the host filesystem in the container. It is also possible to "overwrite"
    an existing directory in the container with host directory contents, which may
    be useful in some scenarios. In general, volumes are the recommended storage solution,
    but there are a few cases where bind mounts can be useful:'
  prefs: []
  type: TYPE_NORMAL
- en: Sharing configuration between the host and the container. A common use case
    may be DNS configuration or the `hosts` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In development scenarios, sharing build artifacts that were created on the host
    so that they can be consumed inside the container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On Windows, mounting SMB file shares as directories in the container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Volumes can be seen as an *evolution* of bind mounts. They are fully managed
    by Docker, without tight coupling to the container host filesystem being visible
    to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a bind mount for a container requires the `docker run` command to
    be specified with an additional parameter, `type=bind`, for the `--mount` flag.
    In this example, we will mount the host''s `C:\Users` directory as `C:\HostUsers`
    in the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You can verify that any changes performed to `C:\HostUsers` will also be visible
    on the host machine in `C:\Users`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows-specific features and the limitations of bind mounts can be found in
    the official documentation from Microsoft: [https://docs.microsoft.com/en-us/virtualization/windowscontainers/manage-containers/container-storage#bind-mounts](https://docs.microsoft.com/en-us/virtualization/windowscontainers/manage-containers/container-storage#bind-mounts).'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to learn how to leverage bind mounts in order
    to use remote or cloud storage in Windows containers.
  prefs: []
  type: TYPE_NORMAL
- en: Using remote/cloud storage for container storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Storing data locally in a container host filesystem is not suitable for use
    cases that require high-availability, failover, and ease of data backup. In order
    to provide storage abstraction, Docker provides volume drivers (plugins), which
    can be used to manage volumes that are hosted on remote machines or in cloud services.
    Unfortunately, at the time of writing this book, Windows containers running on-premises
    do not support the volume plugins that are currently available on Linux OS. This
    leaves us with three choices when it comes to using cloud storage in Windows containers:'
  prefs: []
  type: TYPE_NORMAL
- en: Use Docker for Azure and the Cloudstor volume plugin, which is a partially managed
    solution for running Docker in *swarm* mode on Azure VMs. In this book, we will
    not cover Docker for Azure as this solution is separate from Kubernetes, including
    Azure offerings for managed Kubernetes. If you are interested in more details
    about this service, please refer to [https://docs.docker.com/docker-for-azure/persistent-data-volumes/](https://docs.docker.com/docker-for-azure/persistent-data-volumes/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use cloud storage directly in application code using cloud service provider
    SDKs. This is the most obvious solution, but it requires embedding storage management
    into your application code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use bind mounts and **Server Message Block** (**SMB**) global mappings in order
    to mount Azure Files, which is a fully managed cloud file share that can be accessed
    via the SMB protocol.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Soon, we will demonstrate how to leverage the last option: SMB global mappings
    for Azure Files. But first, we have to install the Azure CLI in order to manage
    Azure resources.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Azure CLI and Azure PowerShell module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to manage Azure resources efficiently from the command line, it is
    recommended to use the official Azure CLI. The official installation notes can
    be found at [https://docs.microsoft.com/en-us/cli/azure/install-azure-cli-windows?view=azure-cli-latest](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli-windows?view=azure-cli-latest).
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing the Azure CLI from PowerShell requires running the following commands
    as an Administrator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After installing the Azure CLI, you need to restart your PowerShell window.
    Next, log in to your Azure account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will open your default browser and instruct you to log
    in to your Azure account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the following command to verify that you have been logged in properly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You should be able to see your subscription details, similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ad13b529-964b-49e8-8597-de51cc5f9edb.png)'
  prefs: []
  type: TYPE_IMG
- en: On top of that, we need to install the Azure PowerShell module since some operations
    are not available in the Azure CLI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installation for the currently logged-in user can be performed using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The official installation steps can be found here: [https://docs.microsoft.com/en-us/powershell/azure/install-az-ps?view=azps-2.5.0#install-the-azure-powershell-module-1](https://docs.microsoft.com/en-us/powershell/azure/install-az-ps?view=azps-2.5.0#install-the-azure-powershell-module-1).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run into problems while importing the newly installed module, you''ll
    also need to set a PowerShell execution policy to `RemoteSigned` as an Administrator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Logging in to Azure using the PowerShell module has to be done separately from
    the Azure CLI and can be performed using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you should be able to manage your resources using the Azure CLI
    and the Azure PowerShell module, without opening the Azure Portal website! Let's
    take a look at how to create an Azure Files SMB share.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Azure Files SMB share
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Assuming that you are following along with these examples on a fresh Azure
    subscription, let''s create an Azure Resource Group and Azure Storage Account
    first:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a PowerShell window, execute the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You can choose a location that is the most suitable for you (in order to show
    a list of available locations, run `az account list-locations`). In this example,
    we are using the `westeurope` Azure location.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the PowerShell script in this book''s GitHub repository to
    do this: [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter02/01_CreateAzureFilesSMBShare.ps1](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter02/01_CreateAzureFilesSMBShare.ps1).
    Remember to run this script as an Administrator since global mappings for SMB
    share must be added from a privileged account.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the successful creation of an Azure Resource Group, continue by creating
    an Azure Storage Account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will create a `general-purpose v2` storage account with
    `read-access geo-redundant` storage called `dockerstorageaccount` in `docker-storage-resource-group`.
    This operation can take up to a few minutes to complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you have to create the actual Azure Files SMB share. First, create a
    connection string for your Azure Storage Account and store it as a variable in
    PowerShell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Remember to keep the connection string safe as it can be used to manage your
    storage account!
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the connection string stored in the `$azureStorageAccountConnString`
    variable, create the share:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This will create a share called `docker-bind-mount-share` with a quota limit
    of 2 GB, which we will now use in our Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting Azure Files SMB share in a container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to mount the new Azure Files SMB share as a bind mount in a container,
    we will leverage the *SMB Global Mapping* feature that was introduced in Window
    Server 1709\. Global mappings have been introduced specifically for this purpose,
    that is, mounting SMB shares on the host so that they''re visible to containers.
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: First, ensure that you are logged in so that you can execute Azure PowerShell
    (using the `Connect-AzAccount` command).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, let''s define a few variables that will be used in the commands we''ll
    execute soon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The names being used here are exactly the same as the ones we used in the previous
    subsection while creating the Azure Files SMB share.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to define the `$storageAccount` and `$storageAccountKeys`
    variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: These variables will be used for the retrieval of file share details and credentials
    for access, both of which are needed for SMB Global Mapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, *optionally*, you can persist your share credentials in Windows Credential
    Manager using the `cmdkey` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also need details regarding Azure Files SMB share, so let''s define
    a new variable called `$fileShare`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, you can also check if the file share details have been retrieved
    successfully. By doing this, you will be able to detect if, for example, `$fileShareName`
    contains the wrong share name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step, before creating an SMB Global Mapping, is to define a credentials
    object, which will be used for mapping creation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can use the `New-SmbGlobalMapping` command in order to create the
    mapping for Azure Files SMB share:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If you need to remove SMB Global Mapping, you can do so using the `Remove-SmbGlobalMapping`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding command will mount your Azure Files SMB share persistently as
    the `G:` drive. You can use this path later for bind mounts for Docker containers.
    Now, you can test if your mapping works correctly by moving some test files to
    the `G:` drive using Windows Explorer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The principle of using bind mount for a globally mapped SMB share can be used
    for any SMB-compatible server, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A traditional file server hosted in your local network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A third-party implementation of the SMB protocol,such as NAS appliances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A traditional SAN or **Scale-out File Server** (**SoFS**) on top of **Storage
    Spaces Direct** (**S2D**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Globally mapped SMB shares, when used as bind mounts, are transparently visible
    for the containers as regular directories in the local filesystem. All of the
    "heavy lifting" is performed by the container host, which is responsible for managing
    the SMB share connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s demonstrate this feature by creating a simple PowerShell process-isolated
    container:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a directory called `G:\ContainerData` in the SMB share for our
    demonstration container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can run the container by providing the new directory in the Azure Files
    SMB share as a bind mount with `C:\Data` as the target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: With this, we can easily prove that our solution works and that the container
    state files are indeed stored in Azure Cloud!
  prefs: []
  type: TYPE_NORMAL
- en: 'In the running container, create a file that contains data. For example, get
    a list of the currently running processes and store it as a `processes.txt` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, log in to Azure Portal (`https://portal.azure.com/`) and do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to Storage accounts from the main menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the dockerstorageaccount account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the storage account menu, open Files under the File service group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the docker-bind-mount-share file share from the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see a familiar directory structure. Navigate into the ContainerData
    directory to see that the `processes.txt` file is indeed there and contains the
    data that was stored in the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5fa27a7f-8af4-4b69-ac32-1837119a24db.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In Kubernetes, a similar procedure can be performed in a managed way using
    *volumes* (not to be confused with Docker volumes). We will focus on this in [Chapter
    11](9ad8c38e-6d0d-435b-a46c-82a468f18007.xhtml), *Configuring Applications to
    Use Kubernetes Features*. You can also refer to the official documentation: [https://kubernetes.io/docs/concepts/storage/](https://kubernetes.io/docs/concepts/storage/).'
  prefs: []
  type: TYPE_NORMAL
- en: Please note that this scenario can also be achieved with a regular SMB File
    Server hosted in your local network, which may be a suitable solution if you use
    them in your infrastructure already.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have successfully created a Windows container that uses
    Azure Cloud storage to persist container state. In the next section, we will learn
    how to run MongoDB inside Windows containers as an example of a multi-container
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: Running clustered solutions inside containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MongoDB is a free and open source cross-platform, document-oriented database
    program that can run in cluster mode (using shards and ReplicaSets). In this example,
    we will run a three-node MongoDB ReplicaSet as that is much easier to configure
    than a full sharded cluster and is sufficient to demonstrate the principle of
    storing container state data persistently.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would like to learn more about MongoDB and advanced sharded cluster
    components, please refer to the official documentation: [https://docs.mongodb.com/manual/core/sharded-cluster-components/](https://docs.mongodb.com/manual/core/sharded-cluster-components/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our MongoDB ReplicaSet architecture will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e4ed078e-6bb7-4908-9eb9-bb8a33c4d258.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The primary node is responsible for managing all write operations, and there
    can only be one primary in a ReplicaSet. The secondary nodes are only replicating
    the primary''s *oplog* and apply the data operations so that their datasets reflect
    the dataset of the primary. The main benefits of such a MongoDB deployment are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automatic failover**: If the primary becomes unavailable, the rest of the
    secondary nodes will perform new leader election and resume cluster functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Possibility to use secondaries to read data**: You can specify read preference
    so that clients offload the primary for read operations. However, you have to
    take note of the fact that asynchronous replication may result in secondaries
    being slightly off-sync with the primary node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's create our MongoDB ReplicaSet!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a MongoDB ReplicaSet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to create the ReplicaSet:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a Docker network called `mongo-cluster` for the new cluster
    using the `docker network create` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If you would like to learn more about Docker networks, please refer to the
    official documentation: [https://docs.docker.com/network/](https://docs.docker.com/network/).'
  prefs: []
  type: TYPE_NORMAL
- en: For Windows-specific documentation, please go to [https://docs.microsoft.com/en-us/virtualization/windowscontainers/container-networking/network-drivers-topologies](https://docs.microsoft.com/en-us/virtualization/windowscontainers/container-networking/network-drivers-topologies).
  prefs: []
  type: TYPE_NORMAL
- en: We will use Azure Files SMB share (globally mapped to the `G:` drive), which
    we created in the previous section, in order to store MongoDB's state using bind
    mounts.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create new directories in our SMB share, two for each MongoDB node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Currently, the official MongoDB image for Windows only exists in Windows Server
    Core 1803, which means we would have to use Hyper-V isolation to run such containers
    on Windows 1903\. This means that we can''t leverage SMB Global Mappings, so we
    need to create our own MongoDB image based on Windows Server Core 1903\. This
    will make it possible for us to use process isolation. The image we are going
    to build is based on the official MongoDB image for the 4.2.0 RC8 version, which
    can be found here: [https://github.com/docker-library/mongo/blob/a3a213fd2b4b2c26c71408761534fc7eaafe517f/4.2-rc/windows/windowsservercore-1803/Dockerfile](https://github.com/docker-library/mongo/blob/a3a213fd2b4b2c26c71408761534fc7eaafe517f/4.2-rc/windows/windowsservercore-1803/Dockerfile).
    To perform the build, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the Dockerfile from this book''s GitHub repository: [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter02/03_MongoDB_1903/Dockerfile](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter02/03_MongoDB_1903/Dockerfile).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In PowerShell, navigate to the location where you downloaded the Dockerfile
    (using a new, separate directory is recommended).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Execute the `docker build` command in order to create a custom MongoDB image
    named `mongo-1903` in your local image registry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The build process will take a few minutes as MongoDB has to be downloaded and
    installed in the build container.
  prefs: []
  type: TYPE_NORMAL
- en: 'This image also exposes the MongoDB data as volumes under `C:\data\db` and
    `C:\data\configdb` inside the container ([https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter02/03_MongoDB_1903/Dockerfile#L44](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter02/03_MongoDB_1903/Dockerfile#L44)).
    Taking all of these into account, let''s create our first MongoDB process-isolated
    container named `mongo-node1`, which will be running in the background (using
    the `-d` option):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: When running this container, we are providing a custom command to run the container
    process, that is, `mongod --bind_ip_all --replSet replSet0`. The `--bind_ip_all`
    argument instructs MongoDB to bind to all the network interfaces that are available
    in the container. For our use case, the `--replSet replSet0` argument ensures
    that the daemon runs in ReplicaSet mode, expecting to be in a ReplicaSet named
    `replSet0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the successful creation of the first node, repeat this process for the
    next two nodes, changing their name and volume mount points appropriately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'After the creation process has finished, you can verify that the containers
    are running properly using the `docker ps` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6516dce2-6200-447b-ab62-59d2da30d6fd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding steps have also been provided as a PowerShell script in this
    book''s GitHub repository: [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter02/02_InitializeMongoDBReplicaSet.ps1](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter02/02_InitializeMongoDBReplicaset.ps1).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next stage is to configure the ReplicaSet. We will do this using the mongo
    shell. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an instance of the mongo shell. If you''re already running a MongoDB
    container (for example,`mongo-node1`), the easiest way to do this is to `exec`
    into an existing container and run the`mongo` process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'After a few seconds, you should see the mongo shell console prompt, `>`. You
    can initialize the ReplicaSet using the `rs.initiate()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command creates a ReplicaSet called `replSet0` using our three
    nodes. These can be identified by their DNS names in the `mongo-cluster` Docker
    network.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more details regarding the initialization of ReplicaSets, please refer
    to the official documentation: [https://docs.mongodb.com/manual/reference/method/rs.initiate/](https://docs.mongodb.com/manual/reference/method/rs.initiate/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also verify the state of initialization using the `rs.status()` command
    in the mongo shell. After a short time, when the ReplicaSet is fully initialized,
    in the command JSON output, you should be able to see the ReplicaSet in one node
    with `"stateStr": "PRIMARY"` and two other nodes with `"stateStr": "SECONDARY"`
    in the command''s output.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next subsection, we will quickly verify our ReplicaSet by generating
    test data and reading it in another container.
  prefs: []
  type: TYPE_NORMAL
- en: Writing and reading test data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to write and read test data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in the mongo shell for the ReplicaSet primary node (as a prompt, you
    will see `replSet0:PRIMARY>` ), let''s add 1,000 sample documents in the `demo`
    collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You can quickly verify the inserted documents by using the `find()` method
    on the `demo` collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will create a minimalistic .NET Core 3.0 console application running
    in a Docker container. This will connect to the ReplicaSet running in our Docker
    container, query our `demo` collection, and write a value of `exampleValue` for
    each document to standard output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can find the source code and Dockerfile for this in this book''s GitHub
    repository: [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter02/04_MongoDB_dotnet](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter02/04_MongoDB_dotnet).'
  prefs: []
  type: TYPE_NORMAL
- en: If, during the execution of this scenario, you experience any instability issues
    with MongoDB, consider upgrading the `mongo-1903` Dockerfile to the latest MongoDB
    version.
  prefs: []
  type: TYPE_NORMAL
- en: 'To read our test data, we need to build the application Docker image and create
    a container that''s running in the `mongo-cluster` network. Perform the following
    steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: Clone the repository and navigate to the `Chapter02/04_MongoDB_dotnet` directory
    in PowerShell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Execute `docker build` in the current directory in order to create the `mongo-dotnet-sample`
    Docker image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the sample container. This needs to be connected to the `mongo-cluster`
    network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the output, you should see an increasing sequence of numbers, which is the
    values of `exampleValue` in our test documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/83cccc9f-2049-48f4-98ff-0f8405a01987.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you are curious, you can check what the SMB share contains on Azure Portal
    ([https://portal.azure.com/](https://portal.azure.com/)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cc802dbb-7896-4eb4-bf0a-120893c9cce9.png)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations! You have successfully created and tested a MongoDB ReplicaSet
    running in a Windows container with Azure Files SMB share being used as a bind
    mount for storing data. Let's quickly summarize what we have learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned the key aspects of Docker storage on Windows:
    using volumes and bind mounts. With the help of Azure, you successfully set up
    your Azure Files SMB share, which can be used to store container state data using
    SMB global mappings. Last but not least, you wrapped all this up by setting up
    your own three-node MongoDB ReplicaSet backed by Azure Cloud storage and verified
    your setup!'
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will be the last one to focus purely on Docker on the Windows
    platform. You can expect to learn about the fundamentals of how to work with Docker
    images and how to use them in your application development life cycle. After that,
    we will be ready to begin our journey with Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the container layer in the Docker storage architecture?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between volumes and bind mounts?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is storing container state data in the container layer not recommended?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you mount Azure Files SMB share transparently in a container?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you use bind mounts in containers that run in Hyper-V isolation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What command removes all unused volumes on the container host?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are volume drivers (plugins)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can find the answers to these questions in the *Assessments *section of
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information concerning managing state and volumes in Docker (not only
    on Windows), please refer to the following Packt book:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Learn Docker – Fundamentals of Docker 18.x* ([https://www.packtpub.com/networking-and-servers/learn-docker-fundamentals-docker-18x](https://www.packtpub.com/networking-and-servers/learn-docker-fundamentals-docker-18x)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also refer to the official Docker documentation, which gives a good
    overview of possible storage options for Docker itself: [https://docs.docker.com/storage/](https://docs.docker.com/storage/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
