- en: APIs, Plugins, and Loaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **Application Programming Interface** (**API**) is typically used for interfaces
    between remotely stationed programs, such as when a company offers partial access
    to their website's functionality as part of an integrated system through, say,
    a mobile app.
  prefs: []
  type: TYPE_NORMAL
- en: Webpack seeks to compile and optimize localized code, so knowing the difference
    between localized code and an external API is essential for operating the software.
  prefs: []
  type: TYPE_NORMAL
- en: Plugins and loaders are similar. A loader essentially instructs Webpack on how
    to handle specific tasks involved in more unusual programming languages and bundling.
    Loaders are often developed by the user community, rather than by in-house Webpack developers.
    Plugins, on the other hand, offer some of the processes that loaders don't currently
    offer and so are more general in their operation than loaders. A concise explanation
    of each feature with detailed examples will follow during the course of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Webpack 5 offers developers a rich plugin interface. Most of the features within
    Webpack use this plugin interface, making Webpack quite flexible to use.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will explore plugins, loaders, and APIs, as well as the salience
    of each and how each feature plays its part in the operation of Webpack.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics discussed in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Loaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Loaders are fundamental to Webpack and many of them enable greater functionality,
    particularly with scripts and frameworks that are not native ECMAScripts, such
    as JavaScript and JSON.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter aims to give you a broad overview of the available loaders as well
    as some that you may need to buy. When working with a salient or unique code that
    is specific to your project, you should search the Webpack online registry to
    ensure that the code can be transpiled.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, this section will discuss the following loaders:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cache-loader`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`coffee-loader`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`coffee-redux-loader`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`worker-loader`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cover.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i18n-loader`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`imports-loader`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`polymer-webpack-loader`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`script-loader`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`source-map-loader`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`less-loader`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll discuss and give examples of each loader, where appropriate, although
    some may need no real elaboration. Let's begin with `cache-loader`.
  prefs: []
  type: TYPE_NORMAL
- en: cache-loader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Caching is something that we alluded to in the previous chapter. `cache-loader`
    allows caches to be made from a loader. We can set it up as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by installing the loader through the **Command-Line Interface** (**CLI**),
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that other loaders are executed in our configuration (see the following
    code) and a cache will be made of any of the resulting outputs made by the loader
    that start with `cache-loader`. This will be made, by default, in the project
    folder but can also be configured to be made in the cache in a database.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure this, use `webpack.config.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that where `cache-loader` is placed in the configuration is where it should
    always be placed, ahead of other loaders.
  prefs: []
  type: TYPE_NORMAL
- en: That explains the installation and use of `cache-loader`. We'll go through a
    few other loaders in the same way, starting with `worker-loader`. As it will need
    to be declared first, we should discuss it first, even though it is always used
    in a chain or sequence with other loaders.
  prefs: []
  type: TYPE_NORMAL
- en: worker-loader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`worker-loader` essentially gives the developer a solution for getting the
    program to handle large computation tasks in the background. To get the loader
    up and running, we will take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, use the command line to install `worker-loader`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, there is an inline way to import `worker-loader` from the `App.js`
    file. In this file, which is present in any Webpack project directory, make the
    following amendment, if it hasn''t been done already:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have imported the loader, perform a configuration using `webpack.config.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`use` refers to the configuration needed to allow access to the loader.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code in `App.js` to allow this file to be an export location
    for the loader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code also adds an `event` listener to allow testing later in the
    development console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, run Webpack via your preferred method to see the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You should see `worker-loader` installed and imported from `App.js` if you chose
    that method. This can be observed in the console window or by viewing the page
    source.
  prefs: []
  type: TYPE_NORMAL
- en: This gives you a couple of choices for utilizing `worker-loader`, either through
    the command-line utility or through the configuration of the `App.js` file. Next,
    we'll discuss `coffee-loader`.
  prefs: []
  type: TYPE_NORMAL
- en: coffee-loader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CoffeeScript is a simplified form of JavaScript, but it isn't exactly JavaScript,
    so a loader must be used to work with it in Webpack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through the following steps to be able to use `coffee-loader`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by installing `coffee-loader`. To install the loader, use the following
    command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure that you are using the recommended configuration of the loader for the
    sake of testing and to use the `literate` key. To allow testing, load `coffee-loader` and
    set the `literate` key to `true`. The `literate` key will ensure that the loader''s
    usage is interpreted by the compiler :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The code in the preceding example shows how the loader can be used and a new
    rule set up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Should you need it, we will show you how to install `coffee-redux`. **Redux**
    is an open source library for managing JavaScript application states. It is frequently
    used with libraries such as **React** and **Angular**. To install it, type the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example will not only help you understand the procedure for installing
    and using CoffeeScript in your bundles but also how the procedure works for the
    loaders that are not mentioned here, as they work in pretty much the same way.
  prefs: []
  type: TYPE_NORMAL
- en: You will see, however, that the shorthand installation and development mode
    for setting the command line has been used— `i` and `-D`, respectively. This works,
    in most cases, although you may find that there is now a response when there is
    a compatibility issue between your command-line utility and the Webpack version
    you are using.
  prefs: []
  type: TYPE_NORMAL
- en: Doing things this way can save you time, but when in doubt, use the verbose
    command-line convention demonstrated in this guide.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to `coverjs`, which works a little differently.
  prefs: []
  type: TYPE_NORMAL
- en: coverjs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`coverjs` allows your code to be instrumented. This essentially means it allows
    your code to be measured or monitored in terms of performance.'
  prefs: []
  type: TYPE_NORMAL
- en: The `coverjs` loader does not need to be combined with `mocha-loader`, as it
    is independent. The `reportHtml` function will append to the output of the body.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, `webpackOptions.js` is the subject of the code. In
    the first set of curly braces (`{`) are the options related to the module export
    procedures. In the double-set of braces (`[{`) is the code that binds the `coverjs`
    loader and the `test:""` statement (which indicates that every file will be tested):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this particular loader has its options set through a local file.
    Amendments to this will have the same effect as the configuration discussed in
    the previous chapter. That should be all you need to get `coverjs` up and running
    in your application. Next up is a more complicated topic, involving the use of
    international languages.
  prefs: []
  type: TYPE_NORMAL
- en: i18n-loader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`i18n-loader` deals with internationalization (`i18n`), which is the process
    of preparing an application so that it supports local languages and cultural settings.
    Let''s set it up by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin with the command-line installation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s start by using CSS. We will set up our style sheet for use with
    `i18n`**. **This is done with our usual project style sheet, `css/styles.css`.
    It''s fine if you are importing another style sheet; just make the alterations
    there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The loader can be called, assuming our locale is `de-de-berlin` (the German
    language and regional settings, for the sake of this example).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will localize the color scheme for our code in the `i18n` setting
    by using the `index.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, wait for the status to be ready. This is only required once for all locales because
    all locales of the same language are merged into one module chunk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is usually all done in the same file as previously. The preceding code
    will append a child node to the `locale` variable in the `console.log` function,
    which will help with testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, configure the loader with `webpack.config.js` and make use of the related
    options available. As there are also options with this loader, you should tell
    the loader about all your locales, if you want to load them once and then want
    to use them synchronously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the `// "bundleTogether": false` statement in the preceding code—this can
    be uncommented and set to disable the bundling of locales.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are alternative calls. The following code chooses the correct file by
    locale:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this will not merge the objects. In the following code, the first
    line will concatenate all the locales that fit and the second line will merge
    the resulting objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, `./file.js` in the preceding code block is executed while compiling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code block simply reinforces the regular expression. It ensures
    that either of the `require` statements will load the same file.
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget to polyfill `require` if you want to use it in Node.js. See the
    *Further reading* section at the end of this chapter for the relevant Webpack
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: The previous code blocks simply adjusted your project so that it is compatible
    with German-language territories with a German-speaking audience. Next up is `imports-loader`.
  prefs: []
  type: TYPE_NORMAL
- en: imports-loader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`imports-loader` allows you to use modules that depend on specific global variables.
    This is useful for third-party modules that may rely on global variables. `imports-loader`
    can add the necessary `require` calls, making them work with Webpack. Let''s set
    it up by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the loader in the command line, use the following statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming that you have the `example.js` file, this loader allows you to append
    an imported script to image tags using jQuery, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `$` variable can then be injected into the module by configuring `imports-loader`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This will simply prepend `var $ = require("jquery");` to `example.js`. This
    can be useful, for instance, if you are optimizing your code to run libraries
    locally.
  prefs: []
  type: TYPE_NORMAL
- en: Using `polymer-loader` similarly optimizes your code or automates your processes
    to allow transitions. This is the next topic of our discussion.
  prefs: []
  type: TYPE_NORMAL
- en: polymer-loader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`polymer-loader` is used to convert HTML files into JavaScript files. To configure
    the loader, use the following code with `webpack.config.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `polymer-webpack-loader` phrase allows the developer to write HTML, CSS,
    and JavaScript code together as polymer elements in single documents—for instance,
    while still being able to use the full Webpack system, including module bundling
    and code splitting.
  prefs: []
  type: TYPE_NORMAL
- en: script-loader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`script-loader` essentially allows JavaScript to be loaded in a single instance.
    This applies globally throughout your project. Let''s set this up by going through
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install `script-loader`, type the following in the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note that this doesn't work in Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `webpack.config.js` to configure Webpack, which will export `exec` from `''script.exec.js'';.`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also an inline way of doing this, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: That should be all you need to be able to use `script-loader` with your Webpack
    application. Next is `source-map-loader`.
  prefs: []
  type: TYPE_NORMAL
- en: source-map-loader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`source-map-loader` extracts existing source maps from all JavaScript entries
    in your project. This includes both inline source maps as well as those that are
    externally loaded. All source map data is processed as per a chosen source map
    style, which you specify with the `devtool` option in `webpack.config.js`. The
    following code shows that configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This loader can be extremely useful when using third-party libraries that have
    source maps. If not extracted and processed into the source map of the bundle,
    browsers may interpret source map data incorrectly. This loader allows the maintenance
    of source map data continuity across libraries and frameworks to ensure easy debugging.
  prefs: []
  type: TYPE_NORMAL
- en: The loader will extract from any JavaScript file, including those in the `node_modules`
    directory. Care should be taken when setting `include` and `exclude` rule conditions
    to optimize bundling performance.
  prefs: []
  type: TYPE_NORMAL
- en: less-loader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**`less-loader` **loads **LESS** (a type of **CSS**) scripts. You should install
    this in the usual way using the command line—for example, `npm i less-loader`.
    For the uninitiated, LESS is a more syntactically succinct form of CSS that is
    useful for backward compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should chain `less-loader` with `css-loader` and `style-loader` to immediately
    apply all styles to the document. To configure this, use the following example
    code using the `webpack.config.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You can pass any LESS-specific options to the `less-loader` through the loader
    options. Since these options are passed to LESS as part of the program, they will
    need to be passed in `camelCase`; the following example in **`webpack.config.js` **shows
    how this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note that LESS won't map all options to `camelCase` individually. It is recommended
    that you check the relevant executable and search for the `dash-case` option.
  prefs: []
  type: TYPE_NORMAL
- en: When in production mode, it is usually recommended that you extract the style
    sheets into a dedicated file using `MiniCssExtractPlugin`. This way, your styles
    are not dependent on JavaScript (more on this later).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have discussed loaders in depth and also made a detailed
    examination of some of the more useful ones. Most loaders follow the same logic
    of installation and configuration and are built by the Webpack community, rather
    than by Webpack themselves. We'll discuss custom loaders in more detail in the
    final chapter of this book.
  prefs: []
  type: TYPE_NORMAL
- en: There are too many other loaders to mention here, but this gives you a very
    solid foundation to work with them in all sorts of imaginative ways. Something
    that is related to the non-native script that loaders tend to handle is the use
    of APIs with Webpack. We'll investigate this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: APIs are crucial to getting the most out of Webpack. In simple terms, APIs are
    required when communicating between applications and a website. When it comes
    to a JavaScript bundler such as Webpack, this includes the database and backend
    connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: There is a huge number of APIs available when working with JavaScript but we
    cannot go through all of them here; however, there are some more useful common,
    but also complex, APIs that are used as tools quite often when programming with
    Webpack.
  prefs: []
  type: TYPE_NORMAL
- en: These tools are specific to Webpack and allow extensive or versatile functionality
    within Webpack, rather than just simple access to external code. The most notable
    of these tools are Babel and Node.js. So, let's use these tools as examples and
    learn about their usage in the following subsections, starting with Babel.
  prefs: []
  type: TYPE_NORMAL
- en: Babel and its loader builder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In case you are not aware, Babel is a toolchain that mainly converts ECMAScript
    2015 and the preceding code into a regressive version of JavaScript that is compatible
    with current and older browsers or environments. The main things that Babel can
    do for you as a developer are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Transform syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polyfill features that are missing in your target environment using `@babel/polyfill`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform source code transformations, called code mods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Webpack uses an API for the Babel interface. If you attempt to install it with
    the command line, you should get the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If you receive this message, it means that you have the `npm` package that Babel installed
    and it is using the short notation of the loader in the Webpack configuration
    file (which is not valid anymore, as of Webpack versions 2 and later).
  prefs: []
  type: TYPE_NORMAL
- en: 'In `webpack.config.js`, you may see the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As a result of installing Babel, Webpack tries to load the `babel` package instead
    of `babel-loader`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To resolve this, the `npm` package Babel should be installed, as it is deprecated
    in Babel version 6\. If you''re using Babel version 6, then you should instead
    install `@babel/cli `or `@babel/core`. If one of your dependencies is installing Babel and
    you cannot uninstall it yourself, use the complete name of the loader in `webpack.config.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The example you have followed so far should stand you in good stead for using
    Babel in general, but one key use of Babel is the customized loader. This is a
    topic covered more extensively in the final chapter of this book, but we will
    now go over how Babel works with customized loaders, especially since you may
    not use a loader that you customize yourself.
  prefs: []
  type: TYPE_NORMAL
- en: '`babel-loader` exposes a `loader-builder` utility that allows users to add
    custom handling of Babel''s configuration for each file that it processes.'
  prefs: []
  type: TYPE_NORMAL
- en: The `.custom` phrase accepts a callback that will be called with the loader's
    instance of Babel. This is so that the tool can ensure that it uses the same `@babel/core` instance
    as the loader itself.
  prefs: []
  type: TYPE_NORMAL
- en: In cases where you want to customize but don't actually have a file to call `.custom`,
    you can also pass the `customize` option with a string pointing to a file that
    exports your custom callback function.
  prefs: []
  type: TYPE_NORMAL
- en: Probably the best way to learn how this works is through a practical example;
    let's go through one in the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this example is to demonstrate how `babel-loader` can be used to
    build custom loaders.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example first uses a custom filename. This can be whatever you want, but
    for the sake of this exercise, the name we have chosen is `./my-custom-loader.js`.
    You can export from this location or wherever you want:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by creating a custom file by using the following code in `./my-custom-loader.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code block, we can see a `require` statement. This uses `babel-loader`,
    which we will need to create the custom loader.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to configure our project to set up passing for the loader, as
    shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note that `custom:` refers to pulling out any custom options that the loader
    might have. Also, note the `loader` reference after the two options. This passes
    the options back with the two `custom` options removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we pass Babel''s `PartialConfig` object, setting the normal configuration
    as `return cfg.options`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, where the `testPlugin` statement is made, we can see the
    inclusion of a custom plugin, which will then be available as an option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s make the placeholder text to test the custom loader on. The preceding
    code should generate something like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This code block shows that the custom loader is generating code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure that your configuration is made correctly. Note that you should always
    replace `__dirname` and `custom-loader` with a name of your choice. In the Webpack
    configuration module, type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The preceding block shows you how to set up and configure `customOptions`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the loader''s options, split the custom options out of the options for `babel-loader`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Given Babel''s `PartialConfig` object, return the `options` object that should
    be passed to `babel.transform`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Both of the preceding code blocks refer to the contents of the custom file we
    have built, which, in this example, is `./my-custom-loader.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that Babel's `result` object will allow loaders to make additional tweaks
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: That should be all you need to get the custom loader working with Babel. Read
    the last chapter of this book on authoring and custom loaders for further information.
    Another key API often used in Webpack projects is the Node.js API.
  prefs: []
  type: TYPE_NORMAL
- en: The Node.js API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Node.js API is useful when using a custom development process. This is because
    all reporting and error handling is done manually. In this situation, Webpack
    simply handles the compilation processes. Note that the `stats` configuration
    options will not have any effect when using the Node.js API.
  prefs: []
  type: TYPE_NORMAL
- en: 'This API will be installed whenever you install Webpack 5; you can refer to
    the first chapter if you are reading this section out of sequence. Let''s set
    this API up by taking the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by including the `webpack` module to your Node.js script. This is done
    using the `webpack.config.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, a callback function was provided—`webpack()`—which
    runs the compiler. The code presents a few conditions. This is only an example
    and should be substituted with your code, of course. Also, the `some` term should
    similarly be replaced with the correct object name associated with your project.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `some` object won't include compilation errors, but only issues
    related to Webpack specifically, such as misconfiguration. Those errors are instead
    handled using the `stats.hasErrors()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Next, ensure that the passing of the compiler instance is done correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the Webpack function is not provided with a callback, it will return a `compiler`
    instance. The `compiler` instance can manually trigger the `webpack()` function
    or ensure that it watches for changes (using `.run(callback)` or `.watch(watchOptions,
    handler)`) during a build, or even runs the build itself without the need for
    the CLI.
  prefs: []
  type: TYPE_NORMAL
- en: The `compiler` instance permits the use of child compilers and will delegate
    all the bundling, writing, and loading work to registered plugins.
  prefs: []
  type: TYPE_NORMAL
- en: There is something called a `hook` property, which is part of the `compiler`
    instance. Its purpose is to register any plugin to any hook event during a compiler's
    life cycle. You can configure this compiler with the `WebpackOptionsDefaulter`
    and `WebpackOptions Apply` utilities.
  prefs: []
  type: TYPE_NORMAL
- en: Upon completion of a build run, the previously mentioned callback function will
    be executed. The final logging of any errors or statistics are done with this
    function.
  prefs: []
  type: TYPE_NORMAL
- en: The Node.js API will only support a single compilation once. Concurrent watches
    or builds can corrupt the output bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Using the API to call a run is similar to using the `compiler` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should now run a compilation using `webpack.config.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'From here, we can also trigger a `watch` session. When the `webpack()` function
    detects a change, it will run again and return an instance of `watching`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As filesystem inaccuracies can trigger multiple builds if a change is detected,
    the `console.log` statement in the previous code block may cause this trigger
    multiple times for any single modification. Checking `stats.hash` can help you
    see whether the file has changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `watch` method this way will return a `watching` instance and a `.close(callback)`
    method. The calling of this method will end the `watching` session:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that using the `invalidate` watching function will allow the manual invalidation
    of the current compilation without stopping the `watch` process. This is useful
    as only one run is permitted at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'As multiple, simultaneous compilations are restricted, Webpack offers something
    called `MultiCompiler` to expedite your project development. It is a module that
    allows Webpack to run multiple configurations in separate compilers. If your `options`
    parameter is an array, Webpack will apply separate compilers and execute any callbacks
    after all the compilers have completed their process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code block shows you how to configure your project in `webpack.config.js` to
    allow this procedure.
  prefs: []
  type: TYPE_NORMAL
- en: As explained, attempting to run these compilations in parallel will produce
    incorrect outputs. If this is done accidentally, error management comes to the
    fore.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, error handling encompasses three types of errors—fatal Webpack errors
    (such as misconfiguration), compilation errors (such as missing assets), and compilation
    warnings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block shows you how you can configure your project—in this
    example, using `webpack.config.js`—to handle those errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding block, the `some` element indicates these errors as a variable.
    We can see the various conditions that will register those errors in the console
    log.
  prefs: []
  type: TYPE_NORMAL
- en: We have given you an intensive crash course on how APIs work with Webpack, so
    if you survived, you are now a hardcore expert in programming skills. Well done!
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have explored a variety of loaders and APIs (including Babel and
    Node.js), it is time to look at the final feature covered in this chapter—plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Plugins serve the purpose of doing everything that a loader cannot do. Loaders
    often help run code that is not native to Webpack and plugins do the same; however,
    loaders are often built by the community whereas plugins are built by Webpack's
    in-house developers.
  prefs: []
  type: TYPE_NORMAL
- en: Plugins are said to be the backbone of Webpack. The software is built on the
    same plugin system that you use in your Webpack configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Webpack has a rich plugin interface and most of the features within Webpack
    itself use it. The following is a bulleted list of the available plugins that
    this section will cover in detail. Next to each name is a brief description of
    the plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BabelMinifyWebpackPlugin`: Minificates with `babel-minify`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CommonsChunkPlugin`: Extracts common modules shared between chunks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ContextReplacementPlugin`: Overrides the inferred context of a require expression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HotModuleReplacementPlugin`: Enables **Hot Module Replacement** (**HMR**)
    (more on this later)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HtmlWebpackPlugin`: Easily creates HTML files to serve your bundles'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LimitChunkCountPlugin`: Sets minimum/maximum limits for chunking to better
    control the process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProgressPlugin`: Reports compilation progress'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProvidePlugin`: Uses modules without having to use `import`/`require`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TerserPlugin`: Enables control of the version of Terser in your project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many more plugins available on the Webpack community pages; however,
    the preceding list illustrates the more salient and useful ones. Next, we will
    go over each one with a detailed explanation.
  prefs: []
  type: TYPE_NORMAL
- en: We won't go over the final three plugins as they only need to be installed in
    the usual fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 'The installation of each plugin follows the same process as the one used for
    loaders:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install the plugin using the command line and then alter the configuration
    file to require the plugin, similar to the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Remember, this is a generic example; you will have to add your plugin name.
    The same can be said of the following configuration, which follows the same procedure
    as most Webpack projects and the same configuration file that we previously used, `webpack.config.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should prepare our configuration file now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'That concludes your general introduction to plugins. We took a general approach
    to prevent over-complication. Now, we can move on to some of the intriguing aspects
    of the various plugins available on Webpack. In the following subsection, we will
    discuss the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BabelMinifyWebpackPlugin`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CommonsChunkPlugin`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ContextReplacementPlugin`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HtmlWebpackPlugin`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LimitChunkCountPlugin`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most plugins are developed by Webpack inhouse and fill the development gaps
    that loaders are not yet able to. These are some of the more interesting ones.
    Let's start with `BabelMinifyWebpackPlugin`.
  prefs: []
  type: TYPE_NORMAL
- en: BabelMinifyWebpackPlugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this subsection, we are going to install `BabelMinifyWebpackPlugin`. This
    plugin is designed to minify Babel script. Minifying, as previously discussed,
    refers to the removal of erroneous or surplus code to compress the application
    size. To use `babel-loader` and include `minify` as a preset, use `babel-minify`.
    The use of `babel-loader` with this plugin will be much faster and will operate
    on smaller file sizes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Loaders in Webpack operate on single files and the preset of `minify` will
    execute each file directly in the browser''s global scope; this is done by default.
    Some things in the top-level scope will not be optimized. Optimization of the
    `topLevel` scope of the file can be done using the following code and `minifyOptions`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: When `node_modles` is excluded from the run through `babel-loader`, then the
    minify optimizations are not applied to the excluded files since nothing is passed
    through `minifer`.
  prefs: []
  type: TYPE_NORMAL
- en: When using `babel-loader`, the generated code does not go through the loader
    and is not optimized.
  prefs: []
  type: TYPE_NORMAL
- en: A plugin can operate on the entire chunk or bundle output and can optimize the
    whole bundle, and some differences can be seen in the minified output; however,
    in that case, the file size would be huge.
  prefs: []
  type: TYPE_NORMAL
- en: The Babel plugin is very useful when working with Webpack and it works across
    multiple platforms. The next plugin we will discuss is `CommonsChunkPlugin`, which
    is designed to work with multiple module chunks—again, something that is very
    native to Webpack.
  prefs: []
  type: TYPE_NORMAL
- en: CommonsChunkPlugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`CommonsChunkPlugin` is an optional feature that creates a separate feature
    known as a chunk. Chunks consist of common modules shared between multiple entry
    points.'
  prefs: []
  type: TYPE_NORMAL
- en: This plugin has been removed in Webpack 4 (Legato).
  prefs: []
  type: TYPE_NORMAL
- en: Looking into `SplitChunkPlugin` will show you more on how chunks are treated
    in Legato.
  prefs: []
  type: TYPE_NORMAL
- en: The resulting chunked file can be initially loaded once by separating the common
    modules that form the bundle. This is stored in the cache for later use.
  prefs: []
  type: TYPE_NORMAL
- en: Using the cache in this way will allow the browser to load pages quicker, rather
    than forcing it to load larger bundles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following declaration in your configuration to use this plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: A short and simple installation, but worth the introduction. Next, let's work
    with `ContextReplacementPlugin`.
  prefs: []
  type: TYPE_NORMAL
- en: ContextReplacementPlugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ContextReplacementPlugin` refers to a `require` statement with an extension,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: When you encounter an expression such as this, the plugin will infer the directory
    of `./local/` and a regular expression. If a name is not included at the time
    of compilation, then every file will be included as a module in the bundle. This
    plugin will allow the inferred information to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: The next plugin to discuss is `HtmlWebpackPlugin`.
  prefs: []
  type: TYPE_NORMAL
- en: HtmlWebpackPlugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`HtmlWebpackPlugin` simplifies the creation of HTML files to serve the bundle.
    This is especially useful for bundles that include a hash in the filename, which
    changes every compilation.'
  prefs: []
  type: TYPE_NORMAL
- en: When using this method, we have three choices—use a template with `lodash` templates,
    use your loader, or let the plugin generate an HTML file. The template is simply
    an HTML template that you can automatically load using `lodash` for speed. The
    loader or the plugin can generate its HTML file. This all speeds up any automated
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: When using multiple entry points, they will be included with the `<script>` tags
    in the generated HTML.
  prefs: []
  type: TYPE_NORMAL
- en: If you have any CSS assets in Webpack's output, then these will be included
    with the `<link>` tags in the `<head>` element of the generated HTML. An example
    would be if CSS is extracted with `MiniCssExtractPlugin`.
  prefs: []
  type: TYPE_NORMAL
- en: Back to working with chunks. The next plugin to look at is a plugin that deals
    with limiting the chunk count.
  prefs: []
  type: TYPE_NORMAL
- en: LimitChunkCountPlugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`LimitChunkCountPlugin` is used when loading on-demand because many code splits
    can be used. When compiling, you might notice that some chunks are very small,
    which creates a larger HTTP overhead. `LimitChunkCountPlugin` can postprocess
    chunks by merging them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Limiting the maximum number of chunks can be done by using a value greater
    than or equal to `1`. Using `1` prevents additional chunks from being added as
    the main or entry point chunk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Keeping the chunk size above the specified limit is not a feature you will find
    in Webpack 5; `MinChuckSizePlugin` should be used, instead, in this situation.
  prefs: []
  type: TYPE_NORMAL
- en: That concludes our introduction to plugins and this chapter in general. Plugins
    allow Webpack to work in a variety of ways and Webpack enables developers to build
    loaders and plug gaps in functionality issues. They are indispensable when working
    on a larger scale project or complex projects that require automation.
  prefs: []
  type: TYPE_NORMAL
- en: Our section on APIs showed you how, sometimes, we don't always want to use local
    code and provided you with an excellent transition to libraries, which we will
    discuss in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has given you an in-depth view of loaders and how they are used
    in Webpack. Loaders are fundamental to Webpack, but plugins are the core and backbone.
    This chapter took you through the major features of these topics, demonstrating
    the best uses for each and when it is a good time to switch between them.
  prefs: []
  type: TYPE_NORMAL
- en: We then explored plugins and how they are used, including Babel, custom plugins,
    and loaders. We have also looked at APIs and their usage, specifically APIs that
    facilitate a wider range of functionality within Webpack, such as the Babel and
    Node APIs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss libraries and frameworks. Our examination
    of plugins, APIs, and loaders has revealed that sometimes, we don't want to use
    remote code such as libraries, but other times we do. Webpack generally deals
    with locally hosted code, but there are times when we might want to work with
    libraries. This provides a good transition to that topic.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is an `i18n` loader?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the toolchain that Webpack typically uses to convert ECMA scripts?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Babel mainly used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which loader allows users to add custom handling of Babel's configuration?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does `polymer-webpack-loader` do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does `polymer-webpack-loader` offer a developer?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When using the Node.js API, what will the callback function that is provided
    run?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
