- en: Understanding the Linux Permissions Scheme
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore how the Linux permission scheme is implemented.
    Read, write, and execute permissions for files and directories will be discussed,
    and we will see how they affect files and directories differently. We will see
    how multiple users can work together using groups, and how some files and directories
    are available to others as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands will be introduced in this chapter: `id`, `touch`, `chmod`,
    `umask`, `chown`, `chgrp`, `sudo`, `useradd`, `groupadd`, `usermod`, `mkdir`,
    and `su`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Read, write, and execute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users, groups, and others
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with multiple users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced permissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will explore the Linux permissions scheme using the virtual machine we created
    in [Chapter 2](cdd5838b-007b-4e1a-a8dc-3c9ea8ebefca.xhtml), *Setting Up Your Local
    Environment*. During this chapter, we will add new users to this system, but only
    having access as the first user (which has administrative, or *root* privileges)
    is sufficient at this point.
  prefs: []
  type: TYPE_NORMAL
- en: Read, write, and execute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed the Linux filesystem and the different
    types with which Linux implements the *everything is a file* philosophy. However,
    we did not look at permissions on those files. As you might have guessed, in a
    multi-user system such as a Linux server, it is not a particularly great idea
    that users can access files which are owned by other users. Where would the privacy
    be in that?
  prefs: []
  type: TYPE_NORMAL
- en: 'The Linux permissions scheme is actually at the heart of the Linux experience,
    as far as we are concerned. Just as (almost) everything is handled as a file in
    Linux, all of those files have a distinct set of permissions accompanying them.
    While exploring the file system in the previous chapter, we limited ourselves
    to files that were viewable by either everyone or by the currently logged in user.
    However, there are many files that are only viewable or writable by the `root`
    user: often, these are sensitive files such as `/etc/shadow` (which contains the
    *hashed* passwords for all users), or files which are used when starting the system,
    such as `/etc/fstab` (which determines which file systems are mounted at boot).
    If everyone could edit those files, it could result in an unbootable system very
    quickly!'
  prefs: []
  type: TYPE_NORMAL
- en: RWX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'File permissions under Linux are handled by three attributes: **r**ead, **w**rite,
    and e**x**ecute, or RWX. While there are other permissions (some of which we will
    discuss later in this chapter), most interactions with regards to permissions
    will be handled by these three. Even though the names seem to speak for themselves,
    they behave differently with regards to (normal) files and directories. The following
    table should illustrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: Allows the user to see the contents of the file with any command that supports
    this, such as `vim`, `nano`, `less`, `cat`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Permission** | **On normal files** | **On directories**  |'
  prefs: []
  type: TYPE_TB
- en: '| Read | Allows the user to list the contents of the directory using the `ls`
    command. This will even list files in the directory on which the user has no other
    privileges! | Allows the user to list the contents of the directory using the
    ls command. This will even list files in directory on which the user has no other
    privileges! |'
  prefs: []
  type: TYPE_TB
- en: '| Write | Allows the user to make changes to the file. | Allows the user to
    replace or delete files within the directory, even if the user has no direct permissions
    on that file. However, this does not include read permissions on all files within
    the directory! |'
  prefs: []
  type: TYPE_TB
- en: '| Execute | Allows the user to execute the file. This is only relevant when
    the file is something that is supposed to be executed, such as a binary or script;
    otherwise, this attribute does nothing. | Allows the user to traverse into the
    directory by using `cd`. This is a separate permission from the listing of contents,
    but they are almost always used together; being able to list without being able
    to navigate into it (and vice versa) is mostly an ineffective configuration. |'
  prefs: []
  type: TYPE_TB
- en: This overview should provide a basis for the three different permissions. Please
    take a good look and see whether you can fully understand what is presented there.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's about to get a little more complicated. While these permissions on
    both files and directories show what can and cannot be done for a user, how does
    Linux deal with multiple users? How does Linux keep track of file *ownership*,
    and how are files shared by multiple users?
  prefs: []
  type: TYPE_NORMAL
- en: Users, groups, and others
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Under Linux, every file is *owned* by exactly one user and one group. Every
    user has an identifying number, the **User ID** (**UID**). The same applies for
    a group: it is resolved by a **Group ID** (**GID**). Every user has exactly one
    UID and one *primary* GID; however, users can be members of multiple groups. In
    that case, the user will have one or more supplementary GIDs. You can see this
    for yourself by running the `id` command on your Ubuntu machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding output, we can see the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: The `uid` for the `reader` user is `1000`; Linux typically starts numbering
    normal users at `1000`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `gid` is `1004`, which corresponds to the `reader` group; by default, Linux
    creates a group with the same name as the user (unless told specifically not to)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other groups include `adm`, `sudo`, and others
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does this mean? The current logged-in user has a `uid` of `1000`, a primary
    `gid` of `1004`, and a few supplementary groups, which makes sure that it has
    other privileges. For example, under Ubuntu, the `cdrom` group allows the user
    to have access to the disk drive. The `sudo` group allows the user to perform
    administrative commands, and the `adm` group allows the user to read administrative
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we typically refer to users and groups by name, this is just a representation
    for the UIDs and GIDs that Linux provides us with. On a system level, only the
    UID and GIDs are important for permissions. This makes it possible, for example,
    to have two users with the same username but different UIDs: the permissions for
    those users will not be the same. The other way around is also possible: two different
    usernames with the same UID—this causes the permissions for both users to be the
    same, at least on the UID level. However, both situations are terribly confusing
    and should not be used! As we''ll see later on, using groups to share permissions
    is by far the best solution for sharing files and directories.'
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to keep in mind is that UIDs and GIDs are *local to the machine*.
    So if I have a user named bob with UID 1000 on machine A, and UID 1000 is mapped
    to user alice on machine B, transferring bob's files from machine A to machine
    B would result in the files being owned by alice on system B!
  prefs: []
  type: TYPE_NORMAL
- en: 'The RWX permissions explained previously relate to the users and groups we''re
    discussing now. In essence, every file (or directory, which is just a different
    type of file), has the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: The file is owned by a *user*, which has (part of) the RWX permissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The file is also owned by a *group*, which again, has (part of) the RWX permissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The file finally has RWX permissions for *others*, which means all different
    users that don't share the group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To determine if a user can read, write, or execute a file or directory, we
    need to look at the following attributes (not necessarily in this order):'
  prefs: []
  type: TYPE_NORMAL
- en: Is the user the owner of the file? What RWX permissions does the owner have?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the user part of the group that owns the file? What RWX permissions have
    been set for the group?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the file have enough permissions on the *others* attribute?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at some simple examples before it gets too abstract. On your virtual
    machine, follow along with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we ensure that we are in the `home` directory for the `reader` user.
    If not, we can move back there by using the `cd /home/reader` command or, alternatively,
    by just entering `cd` (without an argument, `cd` defaults to the user''s `home`
    directory!). We proceed by listing the contents of the directory in the long format,
    using `ls -l`, which shows us one file: `nanofile.txt`, from [Chapter 2](cdd5838b-007b-4e1a-a8dc-3c9ea8ebefca.xhtml), *Setting
    Up Your Local Environment* (don''t worry if you didn''t follow along there and
    do not have the file; we''ll be creating and manipulating files in a little bit).
    We use a new command, `touch`, to create an empty file. The argument we specify
    for `touch` is interpreted as the file name, as we can see when we list the files
    again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll see the permission followed by two names: the username and the group
    name (in that order!). For our `testfile`, the user `reader` and members of the
    `reader` group can both read and write to the file, but cannot execute (on the
    position of the `x`, there is instead a `-`, indicating an absence of that permission).
    All other users, such as those that are neither *readers* nor part of the *reader*
    group (which, in this case, is really all other users), can only read the file
    due to the permission of others. This is also described in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **File type** **(1st character)** | **User permissions (2^(nd) to 4**^(th)
    **characters)**  | **Group permissions (5^(th) to 7^(th) characters)**  | **Others
    permissions (8^(th) to 10^(th) characters)**  | **User ownership** | **Group ownership**
    |'
  prefs: []
  type: TYPE_TB
- en: '| - (normal file) | `rw-`, read and write, no execute | `rw-`, read and write,
    no execute | `r--`, only read | reader | reader |'
  prefs: []
  type: TYPE_TB
- en: 'If a **file** had full permissions for everyone, it would look like this: `-rwxrwxrwx`.
    For files that have all permissions for the owner and the group, but none for
    others, it would be `-rwxrwx---`. **Directories** with full permissions on user
    and group, but none for others, are represented as `drwxrwx---`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `home` directory for the systems'' superuser is `/root/`. We can see from
    the first character on the line that it is a `d`, for *directory*. It has RWX
    (one last time: read, write, execute) permissions for the owner `root`, and no
    permissions for the group (also `root`), nor for others (as denoted by `---`).
    These permissions can only mean one thing: **only the user** **root** **can enter
    or manipulate this directory!** Let''s see if our assumption is correct. Remember,
    *entering* a directory requires the `x` permission, while *listing* the directory
    contents the `r` permission. We should not be able to do either, since we''re
    neither the `root` user or in the root group. In this case, the permissions of
    others will be applied, this being `---`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Manipulating file permissions and ownership
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading the first part of this chapter, you should have a decent understanding
    of Linux file permissions, and how read, write, and executed are used on a user,
    group, and other levels to ensure that files are exposed exactly as required.
    However, up until this point, we've been dealing with static permissions. When
    administering a Linux system, you will most likely spend a fair bit of time adjusting
    and troubleshooting permissions. In this part of the book, we'll be exploring
    the commands we can use to manipulate the permissions on files.
  prefs: []
  type: TYPE_NORMAL
- en: chmod, umask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s circle back to our `testfile`. It has the following permissions: `-rw-rw----`.
    Read/writable by user and group, readable by others. While these permissions might
    be fine for most files, they are definitely not a great fit for all files. What
    about private files? You would not want those to be readable by everyone, perhaps
    not even by group members.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Linux command to change permissions on a file or directory is `chmod`,
    which we like to read as **ch**ange file **mod**e. `chmod` has two operating modes:
    symbolic mode and numeric/octal mode. We will begin by explaining symbolic mode
    (which is easier to understand), before we move to octal mode (which is faster
    to use).'
  prefs: []
  type: TYPE_NORMAL
- en: Something we have not yet introduced is the command to view manuals for commands.
    The command is simply `man`, followed by the command for which you'd like to see
    the manual of. In this case, `man chmod` will place us into the `chmod` manual
    pager, which uses the same navigation controls as you learned for Vim. Remember,
    quitting is done by entering `:q`. In this case, just `q` is enough. Take a look
    at the `chmod` manual now and read at least the **description** header; it will
    make the explanation that follows clearer.
  prefs: []
  type: TYPE_NORMAL
- en: Symbolic mode uses the RWX construct we saw before with the UGOA letters. This
    might seem new, but it actually isn't! **U**sers, **G**roups, **O**thers, and
    **A**ll are used to denote which permissions we're changing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add permissions, we tell `chmod` who (users, groups, others, or all) we
    are doing this for, followed by the permission we want to add. `chmod u+x <filename>`,
    for example, will add the execute permission for the user. Similarly, removing
    permissions with `chmod` is done as follows: `chmod g-rwx <filename>`. Notice
    that we use the `+` sign to add permissions and the `-` sign to remove permissions.
    If we do not specify user, group, others, or all, **all** is used by default.
    Let''s try this out on our Ubuntu machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: First, we added the execute permission for the user to the `testfile`. Next,
    we removed read, write, and execute from the group, resulting in `-rwx---r--`.
    In this scenario, group members are still able to read the file, however, *because
    everyone can still read the file*. Not the perfect permissions for privacy, to
    say the least. Lastly, we do not specify anything before the `-r`, which effectively
    removes read access for the user, group, and others, causing the file to end up
    as `--wx------`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Being able to write and execute a file you can''t read is a bit weird. Let''s
    fix it and look at how octal permissions work! We can use the **verbose** option
    on `chmod` to make it print more information by using the `-v` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we now get output from `chmod`! Specifically, we can see the
    octal mode. Before we changed the file, the mode was `0300`, and after adding
    read for the user, it jumped up to `0700`. What do these numbers mean?
  prefs: []
  type: TYPE_NORMAL
- en: 'It all has to do with the binary implementation of the permission. For all
    three levels (user, group, others), there are 8 different possible permissions
    when combining read, write, and execute, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbolic** | **Octal** |'
  prefs: []
  type: TYPE_TB
- en: '| `---` | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `--x` | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `-w-` | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| `-wx` | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| `r--` | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| `r-x` | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| `rw-` | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| `rwx` | 7 |'
  prefs: []
  type: TYPE_TB
- en: 'Basically, the octal value is between 0 and 7, for a total of 8 values. This
    is the reason it''s called octal: from the Latin/Greek representation of 8, **octo**.
    The read permission is given the value of 4, write permission the value of 2,
    and the execute permission the value of 1.'
  prefs: []
  type: TYPE_NORMAL
- en: By using this system, the value of 0 to 7 can always be uniquely related to
    an RWX value. RWX is *4+2+1 = 7*, RX is *4+1 = 5*, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how octal representations work, we can use them to modify
    the file permissions with `chmod`. Let''s give the test file full permissions
    (RWX or 7) for user, group, and others in a single command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `chmod` accepts four numbers as the argument. The first number
    is in regards to a special type of permission called the sticky bit; we won't
    be discussing this, but we have included material in the *Further reading* section
    for those interested. In these examples, it is always set to `0`, so no special
    bits are set. The second number maps to the user permissions, the third to group
    permissions, and the fourth, unsurprisingly, to the others permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to do this using symbolic representation, we could have used the `chmod
    a+rwx` command. So, why is octal faster than, as we said earlier on? Let''s see
    what happens if we want to have different permissions for each level, for example, `-rwxr-xr--`.
    If we want to do this with symbolic representation, we''d need to use either three
    commands or one chained command (another function of `chmod`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the `chmod u+rwx,g+rx,o+r testfile` command, things have
    gotten a bit complicated. Using octal notation, however, the command is much simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Basically, the difference is mainly using *imperative* notation (add or remove
    permissions) versus *declarative* notation (set it to these values). In our experience,
    declarative is almost always the better/safer option. With imperative, we need
    to first check the current permissions and mutate them; with declarative, we can
    just specify in a single command exactly what we want.
  prefs: []
  type: TYPE_NORMAL
- en: It might be obvious by now, but we prefer to use the octal notation. Besides
    the benefits from shorter, simpler commands that are handled declaratively, another
    benefit is that most examples you will find online use the octal notation as well.
    To fully understand these examples, you will need to at least understand octals.
    And, if you need to understand them anyway, nothing beats using them in your day
    to day life!
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier, when we used the `touch` command, we ended up with a file that could
    be read and written to by both the user and group, and was readable to others.
    These seem to be default permissions, but where do they come from? And how can
    we manipulate them? Let''s meet `umask`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `umask` session is used to determine the file permissions for newly created
    files and directories. For files, the following is done: take the maximum octal
    value for files, `0666`, and subtract the `umask` (in this case, `0002`), which
    gives us `0664`. This would mean that newly created files are `-rw-rwr--`, which
    is exactly what we saw for our `testfile`. Why do we take `0666` and not `0777`,
    you might ask? This is a protection that Linux provides; if we were to use `0777`,
    most files would be created as executable. Executable files can be dangerous,
    and the design decision was made that files should only be executable when explicitly
    set that way. So, with the current implementation, there is no such thing as *accidentally*
    creating an executable file. For directories, the normal octal value of `0777`
    is used, which means that directories are created with `0775`, `-rwxrwxr-x` permissions.
    We can check this out by creating a new directory with the `mkdir` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Because the execute permission on a directory is much less dangerous (remember,
    it is used to determine if you can move into the directory), this implementation
    differs from files.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have one last trick we''d like to showcase with regards to `umask`. In specific
    cases, we''d like to determine default values for files and directories ourselves.
    We can also do this using the `umask` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, you can see that running the `umask` command without
    arguments prints the current umask. Running it with a valid umask value as an
    argument changes umask to that value, which is then used when creating new files
    and directories. Compare `umaskfile` and `umaskdir` with the earlier `testfile`
    and `testdir` in the preceding output. This is very useful if we want to create
    files that are private by default!
  prefs: []
  type: TYPE_NORMAL
- en: sudo, chown, and chgrp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have seen how we can manipulate the (basic) permissions for files
    and directories. However, we haven''t dealt with changing either the owner or
    the group for a file. It would be a little impractical to always have to work
    with users and groups as they were at creation time. For Linux, we can use two
    tools to change the owner and group: **ch**ange **own**er (`chown`) and **ch**ange
    **gr**ou**p** (`chgrp`). However, there is one very important thing to note: these
    commands can only be executed for someone with root permissions (which will, typically,
    be the `root` user). So, before we introduce you to `chown` and `chgrp`, let''s
    look at `sudo`!'
  prefs: []
  type: TYPE_NORMAL
- en: sudo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `sudo` command was originally named for **su**peruser **do**, which, as
    the name implies, gives you a chance to perform an action as the root superuser.
    The `sudo` command uses the `/etc/sudoers` file to determine if users are allowed
    to elevate to superuser permissions. Let's see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We first try to look at the contents of `/etc/sudoers` as a normal user. When
    that gives us a `Permission denied` error, we look at the permissions on the file.
    From the `-r--r----- 1 root root` line, it becomes obvious that only the `root`
    user or members of the `root` group can read the file. To elevate to root privileges,
    we use the `sudo` command *in front of* the command we want to run, which is `cat
    /etc/sudoers`. For verification, Linux will always ask the user for their password.
    This password is then kept in memory for about 5 minutes by default, so you do
    not have to type your password every time if you've recently entered it.
  prefs: []
  type: TYPE_NORMAL
- en: 'After entering the password, the `/etc/sudoers` file is printed for us! It
    seems that `sudo` did indeed provide us with superuser permissions. How that works
    is also explained by the `/etc/sudoers` file. The `# Allow members of group sudo
    to execute any command` line is a comment (since it starts with a `#`; more on
    this later) and tells us that the line below gives all users of the `sudo` group
    permissions for any commands. On Ubuntu, the default created user is considered
    an administrator and is a member of this group. Use the `id` command to verify
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sudo` command has another excellent use: switching to the `root` user!
    For this, use the `--login` flag, or its shorthand, `-i`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the prompt, you will see that the username has changed from `reader` to
    `root`. Furthermore, the last character in your prompt is now a `#` instead of
    a `$`. This is also used to denote the current elevated permissions. You can exit
    this elevated position by using the built-in `exit` shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Remember, the `root` user is the superuser of the system that can do everything.
    And with everything, we really mean everything! Unlike other operating systems,
    if you tell Linux to delete the root file system and everything below it, it will
    happily oblige (right up until the point it has destroyed too much to work properly
    anymore). Do not expect an `Are you sure?` prompt either. Be very, very careful
    with `sudo` commands or anything in a root prompt.
  prefs: []
  type: TYPE_NORMAL
- en: chown, chgrp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After the little `sudo` detour, we can get back to file permissions: how do
    we change the ownership of files? Let''s start with changing the group using `chgrp`.
    The syntax is as follows: `chgrp <groupname> <filename>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: First, we list the contents using `ls`. Next, we try to use `chgrp` to change
    the group of the `umaskfile` file to games. However, since this is a privileged
    operation and we did not start the command with `sudo`, it fails with the `Operation
    not permitted` error message. Next, we use the correct `sudo chgrp games umaskfile` command,
    which does not give us feedback; generally, this is a good sign in Linux. We list
    the files again to make sure that this is the case, and we can see that the group
    has changed to `games` for the `umaskfile`!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do the same, but now for the user, by using the `chown` command. The
    syntax is the same as `chgrp`: `chown <username> <filename>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, we have now changed the file ownership from `reader:reader`
    to `pollinate:games`. However, there is one little trick that''s so convenient
    that we''d like to show you it right away! You can actually use `chown` to change
    both users and groups by using the following syntax: `chown <username>:<groupname>
    <filename>`. Let''s see if this can restore the `umaskfile` to its original ownership:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We used random users and groups in the preceding examples. If you want to see
    which groups are present on the system, inspect the `/etc/group` file. For users,
    the same information can be found in `/etc/passwd`.
  prefs: []
  type: TYPE_NORMAL
- en: Working with multiple users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we've stated before, Linux is inherently a multi-user system, especially
    in the context of a Linux server, where these systems are often administered not
    by a single user, but often a (large) team. Each user on a server has it own set
    of permissions. Imagine, for example, a server where three departments need to
    be development, operations, and security. Development and operations both have
    their own stuff there, but also need to share some other things. The security
    department needs to be able to view everything to ensure proper compliance and
    adherence to security guidelines. How could we arrange such a structure? Let's
    make it happen!
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to create some users. For each department, we will create a single
    user, but since we're going to ensure permissions on the group level, this will
    work just as well for 5, 10, or 100 users in each department. We can create users
    with the `useradd` command. In its basic form, we can just use `useradd <username>`,
    and Linux will handle the rest via default values. Obviously, as with almost everything
    in Linux, this is highly customizable; check the man page (`man useradd`) for
    more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'As was the case with `chown` and `chgrp`, `useradd` (and later `usermod`) is
    a privileged command, which we will execute with `sudo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As a last reminder, we've showed you what happens when you forget `sudo`. While
    the error message is technically fully correct (you need root permissions to edit
    `/etc/passwd`, where user information is stored), it might not be fully obvious
    why the command is failing, especially because of the misleading `try again later!` error.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `sudo`, however, we are able to add three users: `dev-user1`, `ops-user1`,
    and `sec-user1`. When we inspect these users in order, we can see that their `uid`
    goes up by one each time. We can also see that a group with the same name as the
    user is created, and that that is the sole group of which the users are a member.
    Groups also have their `gid`, which is incremented by one for each next user.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now we have the users in place, but we need shared groups. For this, we
    have a similar command (both in name and operation): `groupadd`. Check the man
    page for `groupadd` and add three groups corresponding to our departments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To see which groups are already available, you can check out the `/etc/group`
    file (with, for example, `less` or `cat`). Once you''re satisfied, we now have
    the users and groups in place. But how do we make the users members of the groups?
    Enter `usermod` (which stands for **user** **mod**ify). The syntax to set a user''s
    primary group is as follows: `usermod -g <groupname> <username>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'What we have accomplished now is closer to our goal, but we''re not there yet.
    So far, we have only ensured that multiple developers can share files by all being
    in the development group. But how about the shared folder between development
    and operations? And how can security monitor everything? Let''s create some directories
    (using `mkdir`, which stands for **m**a**k**e **dir**ectory) with the correct
    groups and see how far we can get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have the following structure: a `/data/` top level directory, which
    contains the directories `dev-files` and `ops-files`, which are owned by the `development`
    and `operations` groups, respectively. Now, let''s fulfill the requirement that
    security can go into both directories and manage the files! Apart from using `usermod`
    to change the main groups, we can also append users to extra groups. In this case,
    the syntax is `usermod -a -G <groupnames> <username>`. Let''s add `sec-user1`
    to the `development` and `operations` groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The user from the security department is now a member of all new groups: security,
    development, and operations. Since both `/data/dev-files/` and `/data/ops-files/`
    do not have permissions for *others*, our current user should not be able to enter
    either, but `sec-user1` should be. Let''s see if this is correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If you followed along with this example, you should see that we introduced
    a new command: `su`. Short for **s**witch **u**ser, it allows us to, well, switch
    between users. If you prefix it with `sudo`, you can switch to a user without
    needing the password for that user, as long as you have those privileges. Otherwise,
    you will have to enter the password (which is hard in this case, since we haven''t
    set a password for the user). As you might have noticed, the shell is different
    for the new user. That''s because we haven''t loaded any configuration (which
    is automatically done for the default user). Don''t worry about that, though—it''s
    still a fully functioning shell! Our test succeeded: we were able to move into
    the `dev-files` directory, even though we are not a developer. We were even able
    to create a file. If you want, verify that the same is possible for the `ops-files`
    directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s create a new group, `devops`, which we will use to share files
    between developers and operations. After creating the group, we will add both `dev-user1`
    and `ops-user1` to this group, in the same way we added `sec-user1` to the `development`
    and `operations` groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We now have a shared directory, `/data/devops-files/`, where both `dev-user1`
    and `ops-user1` can enter and create files.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an exercise, do any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add `sec-user1` to the `devops` group, so that it can also audit the shared
    files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verify that both `dev-user1` and `ops-user1` can write files in the shared directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Understand why `dev-user1` and `ops-user1` can only read each other''s files
    in the `devops` directory, but cannot edit them (hint: the next section of this
    chapter, *Advanced permissions*, will tell you how to solve this with SGID)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This covers the basic permissions for Linux. There are, however, some advanced
    topics that we'd like to point out, but we will not be discussing them at length.
    For more information on these topics, check the *Further reading* section at the
    end of this chapter. We have included a reference for file attributes, special
    file permissions, and access control lists.
  prefs: []
  type: TYPE_NORMAL
- en: File attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Files can also have attributes that are expressed in another way than the permissions
    we have seen so far. An example of this is making a file immutable (a fancy word,
    which means it cannot be changed). An immutable file still has normal ownership
    and group and RWX permissions, but it will not allow the user to change it, even
    if it contains the writable permission. Another characteristic of this is that
    the file cannot be renamed.
  prefs: []
  type: TYPE_NORMAL
- en: Other file attributes include *undeletable*, *append only*, and *compressed*.
    For more information on file attributes, check the man pages for the `lsattr`
    and `chattr` commands (`man lsattr` and `man chattr`).
  prefs: []
  type: TYPE_NORMAL
- en: Special file permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you might have noticed in the part about octal notation, we always start
    the notation with a zero (0775, 0640, and so on). Why do we include the zero if
    we do not use it? That position is reserved for special file permissions: SUID,
    SGID, and the sticky bit. They have a similar octal notation (where SUID is 4,
    SGID is 2, and the sticky bit is 1) and are used in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Files** | **Directories** |'
  prefs: []
  type: TYPE_TB
- en: '| **SUID** | Files are executed with the permissions of the owner, regardless
    of which user executes it. | Does nothing. |'
  prefs: []
  type: TYPE_TB
- en: '| **SGID** | Files are executed with the permissions of the group, regardless
    of which user executes it. | Files that are created in this directory get the
    same group as the directory. |'
  prefs: []
  type: TYPE_TB
- en: '| **Sticky bit** | Does nothing. | User can only delete their own files within
    this directory. See the `/tmp/` directory for its most famous use. |'
  prefs: []
  type: TYPE_TB
- en: Access Control Lists (ACLs)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ACLs are a way to increase the flexibility of the UGO/RWX system. Using `setfacl`
    (**set** **f**ile **acl**) and `getfacl` (**get** **f**ile **acl**), you can set
    additional permissions for files and directories. So, for example, using ACLs,
    you could say that, while the `/root/` directory is normally only accessible by
    the `root` user, it could also be read by the `reader` user. The other way to
    accomplish this, which is by adding the `reader` user to the `root` group, also
    gives the `reader` user many other privileges on the system (anything that has
    permissions on the root group has then been granted to the reader user!). While
    ACLs are not often used in practice in our experience, for edge cases they can
    be the difference between a complex solution and a simple one.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have looked at the Linux permissions scheme. We have learned
    that there are two main axes on which permissions are arranged: file permissions
    and file ownership. For file permissions, each file has an allowance (or disallowance)
    on *read*, *write*, and *execute* permissions. How these permissions work differs
    for files and directories. Permissions are applied by using ownership: a file
    is always owned by a user and a group. Besides the *user* and *group*, there are
    also file permissions present for everyone else, called the *others* ownership.
    If the user is either the owner or a member of the file''s group, those permissions
    are available to the user. Otherwise, there need to be permissions for others
    to allow interaction with the file.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we learned how to manipulate file permissions and ownership. By using
    `chmod` and `umask`, we were able to get the file permissions in the way we needed.
    Using `sudo`, `chown`, and `chgrp`, we manipulated the owner and group of a file.
    A warning was given about the usage of `sudo` and the `root` user, since both
    can render a Linux system inoperable with very little effort.
  prefs: []
  type: TYPE_NORMAL
- en: We continued with an example of working with multiple users. We added three
    additional users to the system using `useradd`, and gave them the correct groups
    with `usermod`. We saw how those users can be members of the same groups and,
    in that way, share access to files.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we touched on some basics of advanced permissions under Linux. The
    *Further reading* section contains more information for those subjects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands were introduced in this chapter: `id`, `touch`, `chmod`,
    `umask`, `chown`, `chgrp`, `sudo`, `useradd`, `groupadd`, `usermod`, `mkdir`,
    and `su`.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which three permissions are used for Linux files?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which three types of ownership are defined for Linux files?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which command is used to change the permissions on a file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What mechanism controls the default permissions for newly created files?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'How is the following symbolic permission described in octal: `rwxrw-r--`?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'How is the following octal permission described symbolically: `0644`?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which command allows us to gain superuser privileges?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which commands can we use to change ownership for a file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we arrange for multiple users to share access to files?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which types of advanced permissions does Linux have?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following resources might be interesting if you''d like to go deeper into
    the subjects of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fundamentals of Linux** by *Oliver Pelz*, Packt: [https://www.packtpub.com/networking-and-servers/fundamentals-linux](https://www.packtpub.com/networking-and-servers/fundamentals-linux)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**File attributes**: [https://linoxide.com/how-tos/howto-show-file-attributes-in-linux/](https://linoxide.com/how-tos/howto-show-file-attributes-in-linux/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Special file permissions**: [https://thegeeksalive.com/linux-special-permissions/](https://thegeeksalive.com/linux-special-permissions/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access Control Lists**: [https://www.tecmint.com/secure-files-using-acls-in-linux/](https://www.tecmint.com/secure-files-using-acls-in-linux/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
