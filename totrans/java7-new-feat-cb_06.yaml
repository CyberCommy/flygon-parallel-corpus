- en: Chapter 6. Stream IO in Java 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing simple files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using buffered IO for files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Random access IO using the `SeekableByteChannel`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing asynchronous communication using the `AsynchronousServerSocketChannel`
    class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing to a file using the `AsynchronousFileChannel` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading from a file using the `AsynchronousFileChannel` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `SecureDirectoryStream` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Java 7, we found that there are numerous improvements to its IO capabilities.
    Most of these are found in the `java.nio` package, which has been dubbed as **NIO2**.
    In this chapter, we will focus on the new support for streaming and channel-based
    IO. A **stream** is a contiguous sequence of data. **Stream IO** acts on a single
    character at a time, while **channel IO** works with a buffer for each operation.
  prefs: []
  type: TYPE_NORMAL
- en: We start with the new techniques used to work with simple files. These are supported
    by the `Files` class and are discussed in the *Managing simple files* recipe.
    **Buffered IO** is usually more efficient and is explained in the *Using buffered
    IO for files* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: The `java.nio.channels` package's `ByteChannel` interface is a channel that
    can read and write bytes. The `SeekableByteChannel` interface extends the `ByteChannel`
    interface to maintain a position within the channel. The position can be changed
    using seek type random IO operations. This capability is discussed in the *Random
    access IO using the SeekableByteChannel* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java 7 has added support for asynchronous channel functionality. The asynchronous
    nature of these operations is that they do not block. An asynchronous application
    can continue executing without the need to wait for an IO operation to complete.
    When the IO completes, a method of the application is called. There are four new
    `java.nio.channels` package asynchronous channel classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AsynchronousSocketChannel`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AsynchronousServerSocketChannel`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AsynchronousFileChannel`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AsynchronousChannelGroup`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first two are used together in a server/client environment and are detailed
    in the *Managing asynchronous communication using the AsynchronousServerSocketChannel
    class* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: The `AsynchronousFileChannel` class is used for file manipulation operations
    that need to be performed in an asynchronous manner. The methods supporting the
    write and read operations are illustrated in the *Writing to a file using the
    AsynchronousFileChannel class* and *Reading from a file using the AsynchronousFileChannel
    class* recipes, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The `AsynchronousChannelGroup` class provides a means of grouping asynchronous
    channels together in order to share resources. The use of this class is shown
    in the *There's more* section of the *Reading from a file using the AsynchronousFileChannel
    class* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: The `java.nio.file` package's `SecureDirectoryStream` class provides support
    for more secure access to directories. The use of this class is explained in the
    *Using the SecureDirectoryStream* recipe. However, the underlying operating system
    must provide local support for this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `users.txt` file is used for several examples found in this chapter. The
    contents of the `users.txt` file are assumed to initially contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Bob
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tom
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should your file's content differ, then the output of the examples will vary
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several of the recipes in this chapter open a file. Some of these open methods
    that will use an enumeration argument to specify how the file should be opened.
    The `java.nio.file` package''s `OpenOption` interface specifies how the file is
    opened and the `StandardOpenOption` enumeration implements this interface. The
    values of the enumeration are summarized in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Enumeration | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `APPEND` | Bytes are written to the end of the file |'
  prefs: []
  type: TYPE_TB
- en: '| `CREATE` | Creates a new file if it does not exist |'
  prefs: []
  type: TYPE_TB
- en: '| `CREATE_NEW` | Creates a new file only if the file does not exist |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE_ON_CLOSE` | Deletes the file when it is closed |'
  prefs: []
  type: TYPE_TB
- en: '| `DSYNC` | Every update to a file is written synchronously |'
  prefs: []
  type: TYPE_TB
- en: '| `READ` | Open for read access |'
  prefs: []
  type: TYPE_TB
- en: '| `SPARSE` | Sparse file |'
  prefs: []
  type: TYPE_TB
- en: '| `SYNC` | Every update to the file or metadata is written synchronously |'
  prefs: []
  type: TYPE_TB
- en: '| `TRUNCATE_EXISTING` | Truncates the length of a file to 0 when opening a
    file |'
  prefs: []
  type: TYPE_TB
- en: '| `WRITE` | Opens the file for write access |'
  prefs: []
  type: TYPE_TB
- en: While not discussed here, the `java.nio.channels` package's `NetworkChannel`
    interface was introduced in Java 7\. This represents a channel to a network socket.
    Several classes including the `AsynchronousServerSocketChannel` and `AsynchronousSocketChannel`
    classes that are discussed in this chapter implement it. It has a `bind` method
    that binds a socket to a local address, allowing the retrieval and setting of
    various query socket options. It permits the use of operating system-specific
    options, which could be used for high performance servers.
  prefs: []
  type: TYPE_NORMAL
- en: The `java.nio.channels` package's `MulticastChannel` is also new to Java 7\.
    It is used to support multicast operations for a group. It is implemented by the
    `DatagramChannel` class. Methods of this interface support the joining and leaving
    of members from a group.
  prefs: []
  type: TYPE_NORMAL
- en: The **Sockets Direct Protocol** (**SDP**) is a network protocol, which supports
    stream connections using **InfiniBand** (**IB**). The IB technology supports point-to-point
    bi-directional serial links between high-speed peripherals, such as disks. A significant
    part of IB is its ability to move data from the memory of one computer directly
    to the memory of another computer.
  prefs: []
  type: TYPE_NORMAL
- en: SDP is supported in Java 7 on Solaris and Linux operating systems. Several classes
    in the `java.net` and `java.nio.channels` packages support it transparently. However,
    SDP must be enabled before it can be used. Details on how to enable IB and then
    create a SDP configuration file are found at [http://download.oracle.com/javase/tutorial/sdp/sockets/index.html](http://download.oracle.com/javase/tutorial/sdp/sockets/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Managing simple files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some files are small and contain simple data. This is usually true for text
    files. When it is feasible to read or write the entire contents of the file at
    one time, there are a few `Files` class methods that will work quite well.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will examine techniques for processing simple files. Initially,
    we will examine how to read the contents of these types of files. In the *There's
    more* section, we will demonstrate how to write to them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To read the entire contents of a file at once:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `java.nio.file.Path` object representing the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `java.nio.file.Files` class' `readAllBytes` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new console application. We will read and display the contents of
    the `users.txt` file found in the docs directory. Add the following main method
    to the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application. Your output should reflect the contents of the file.
    Here is one possible output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Bob**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mary**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sally**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tom**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ted**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We started by creating a `Path` object, which represents the `users.txt` file.
    The `Files` class' `readAllBytes` method was executed using the `path` object
    as its argument. The method returned an array of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Next, a for statement was used to iterate through the array. Each `byte` was
    cast to a `char` and then displayed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The method will automatically close the file once all of the bytes have been
    read or should an exception occur. In addition to an `IOException` that might
    occur, an `OutOfMemoryError` may be thrown, if it is not possible to create an
    array of sufficient size to hold the contents of the file. Should this happen,
    then an alternative approach should be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are also concerned with:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing to a simple file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading all of the lines of a file returned as a list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing to a simple file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the following example, we are going to take the contents of the `users.txt`
    file and add a new name to the list. Using the previous code, comment out the
    for loop that prints out the values of contents. Then, after invoking the `readAllBytes`
    method on the `Path` object, create a new `path` object directed to a new, non-existent
    text file. Then declare a `String` variable called `name` and invoke the `getBytes`
    method on the string to return a new `byte` array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Next, we are going to use the `Files` class write method to create a new file
    with the same contents as our `users.txt` file, and then append our `String` name
    to this list. In the first invocation of the `write` method, we use `newPath`
    to specify where the file should be created, the contents byte array to specify
    what information should be used, and the `StandardOpenOption.CREATE` argument
    to specify that the file should be created if it does not exist. In the second
    invocation of the `write` method, we again use `newPath`, but then we use the
    byte array `newContents` and the `StandardOpenOption.APPEND` to specify that the
    name should be appended to the existing file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you open the `newUsers.txt` file, you will see the list of names from your
    `users.txt` file, appended by the name you specified using the `newContents` byte
    array.
  prefs: []
  type: TYPE_NORMAL
- en: There is also an overloaded `write` method that uses the same `Path` object
    for its first parameter and uses the `Iterable` interface to iterate over a `CharSequence`
    as its second parameter. The third parameter of this method defines the `Charset`
    to use. The `StandardOpenOptions` are available as optional parameters as shown
    in the previous version. The open options were listed in the introduction to this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Reading all of the lines of a file returned as a list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In instances where you have a simple file you wish to read from, it can be efficient
    to use the `readAllLines` method. The method takes two arguments, namely, a `Path`
    object and a `Charset`. The method may throw an `IOException`. In the following
    example, we use the path to our `users.txt` file and the `Charset` class' `defaultCharset`
    method to execute the `readAllLines` method. The method returns a list of strings,
    which we print out within a for loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Your output should look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the strings returned from the `readAllLines` method does not include
    the end of line character.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `readAllLines` method recognizes the following line terminators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`\u000D` followed by `\u000A` (CR/LF)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\u000A`, (LF)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\u000D`, (CR)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Using buffered* IO *for files:* This recipe examines how buffered IO is handled
    in Java 7'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Writing to a file using the AsynchronousFileChannel class:* This recipe illustrates
    how IO to a file can be performed in an asynchronous fashion'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Reading from a file using the AsynchronousFileChannel class:* This recipe
    illustrates how IO to a file can be performed in an asynchronous fashion'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using buffered IO for files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Buffered IO provides a more efficient technique for accessing files. Two methods
    of the `java.nio.file` package's `Files` class return either a `java.io` package
    `BufferedReader` or a `BufferedWriter` object. These classes provide an easy to
    use and efficient technique for working with text files.
  prefs: []
  type: TYPE_NORMAL
- en: We will illustrate the read operation first. In the *There's more* section,
    we will demonstrate how to write to a file.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To read from a file using a `BufferedReader` object:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Path` object representing the file of interest
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `BufferedReader` object using the `newBufferedReader` method
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the appropriate `read` method to read from the file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new console application using the following `main` method. In this
    method, we will read the contents of the `users.txt` file and then display its
    contents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application. Your output should reflect the contents of the `users.txt`
    file, which should be similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `Path` object representing the `users.txt` file was created followed by the
    creation of a `Charset`. The ISO Latin Alphabet No. 1 was used for this example.
    Other character sets can be used, depending on the platform used.
  prefs: []
  type: TYPE_NORMAL
- en: A try-with-resource block was used to create the `BufferedReader` object. This
    type of `try` block is new to Java 7 and is detailed in the *Using the try-with-resource
    block to improve exception handling code* recipe in [Chapter 1](ch01.html "Chapter 1. Java
    Language Improvements"), *Java Language Improvements*. This will result in the
    `BufferedReader` object automatically being closed when the block completes.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop reads each line of the file. and then displays each line to the
    console. Any `IOExceptions` is thrown as needed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a byte is stored in a file, its meaning can differ depending upon the intended
    encoding scheme. The `java.nio.charset` package's `Charset` class provides a mapping
    between a sequence of bytes and 16-bit Unicode code units. The second argument
    of the `newBufferedReader` method specifies the encoding to use. There is a standard
    set of character sets supported by the JVM, as detailed in the Java documentation
    for the `Charset` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing to a file using the `BufferedWriter` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unbuffered IO support in the `Files` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing to a file using the BufferedWriter class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `newBufferedWriter` method opens or creates a file for writing and returns
    a `BufferedWriter` object. The method requires two arguments, a `Path` object
    and a specified `Charset`, and can use an optional third argument. The third argument
    specifies an `OpenOption` as detailed in the table found in the *Introduction*.
    If no option is specified, the method will behave as though the `CREATE, TRUNCATE_EXISTING`,
    and `WRITE` options were specified, and will either create a new file or truncate
    an existing file.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we specify a new `String` object containing a name
    to add to our `users.txt` file. After declaring our `Path` object, we use a try-with-resource
    block to open a new `BufferedWriter`. In this example, we are using the default
    system charset and `StandardOpenOption.APPEND` to specify that we want to append
    the name to the end of our `users.txt` file. Within the try block, we first invoke
    the `newline` method against our `BufferedWriter` object to ensure that our name
    goes on a new line. Then we invoke the `write` method against our `BufferedWriter`
    object, using our `String` as the first argument, a zero to denote the beginning
    character of the String, and the length of our `String` to denote that the entire
    `String` should be written.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If you examine the contents of the `users.txt` file, the new name should be
    appended to the end of the other names in the file.
  prefs: []
  type: TYPE_NORMAL
- en: Un-buffered IO support in the Files class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While un-buffered IO is not as efficient as buffered IO, it is still useful
    at times. The `Files` class provides support for the `InputStream` and `OutputStream`
    classes through its `newInputStream` and `newOutputStream` methods. These methods
    are useful in instances where you need to access very small files or where a method
    or constructor requires an `InputStream` or `OutputStream` as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we are going to perform a simple copy operation where
    we copy the contents of the `users.txt` file to a `newUsers.txt` file. We first
    declare two `Path` objects, one referencing the source file, `users.txt`, and
    one specifying our destination file, `newUsers.txt`. Then, within a try-with-resource
    block, we open both an `InputStream` and an `OutputStream`, using the `newInputStream`
    and `newOutputStream` methods. Within the block, we read in the data from our
    source file and write it to the destination file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Upon examining the `newUsers.txt` file, you should see that the content matches
    that of the `users.txt` file.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Managing simple files:* This recipe shows how non-buffered IO is handled in
    Java 7'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Writing to a file using the AsynchronousFileChannel class:* This recipe illustrates
    how IO to a file can be performed in an asynchronous fashion'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Reading from a file using the AsynchronousFileChannel class:* This recipe
    illustrates how IO to a file can be performed in an asynchronous fashion'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Random access IO using the SeekableByteChannel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Random access to a file is useful for more complex files. It allows access to
    specific positions within the file in a non-sequential fashion. The `java.nio.channels`
    package's `SeekableByteChannel` interface provides this support, based on channel
    IO. Channels provide a low-level approach for bulk data transfers. In this recipe
    we will use a `SeekableByteChannel` to access a file.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To obtain a `SeekableByteChannel` object:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Path` object representing a file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get a `SeekableByteChannel` object using the `Files` class' static `newByteChannel`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Create a new console application using the following `main` method. We will
    define a `bufferSize` variable to control the size of the buffer used by the channel.
    We will create a `SeekableByteChannel` object and use it to display the first
    two names in the `users.txt` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure that the `users.txt` file contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application. The output should display the first two names in reverse
    order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We created a `bufferSize` variable to control the size of the buffer, used by
    the channel. Next, a `Path` object was created for the `users.txt` file. This
    path was used as the argument to the `newByteChannel` method, which returned a
    `SeekableByteChannel` object.
  prefs: []
  type: TYPE_NORMAL
- en: We moved the read position in the file to the fourth position. This placed us
    at the beginning of the second name in the file. The `read` method was then used,
    which read approximately eight bytes into buffer. The first five bytes of the
    buffer were then displayed.
  prefs: []
  type: TYPE_NORMAL
- en: We repeated this sequence, but moved the position to zero, that is, the beginning
    of the file. A `read` operation was performed again, and then we displayed the
    first four characters, which were the first name in the file.
  prefs: []
  type: TYPE_NORMAL
- en: This example used explicit knowledge of the size of the names in the file. Normally,
    this knowledge is not available unless obtained by some other technique. We used
    this knowledge here simply to demonstrate the nature of the `SeekableByteChannel`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `read` method will start reading from the current position in the file.
    It will read until either the buffer is filled or the end of file is reached.
    The method returns an integer, indicating how many bytes were read. A `-1` is
    returned when the end of stream is reached.
  prefs: []
  type: TYPE_NORMAL
- en: The read and write operations may be accessing the same `SeekableByteChannel`
    object used by multiple threads. As a result, an `AsynchronousCloseException`
    or a `ClosedByInterruptException` exception may be thrown when another thread
    closes the channel or otherwise interrupts the current thread.
  prefs: []
  type: TYPE_NORMAL
- en: There is a `size` method that returns the size of the stream. A `truncate` method
    is available that discards all bytes past a specific position in the file. This
    position is passed as a long argument to the method.
  prefs: []
  type: TYPE_NORMAL
- en: The `Files` class' static `newByteChannel` method can take a second argument,
    which specifies the option used when opening the file. These are detailed in the
    *There's more* section, *Writing to a file using the BufferedWriter class*, of
    the *Using buffered IO for files* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, we need to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: Processing the contents of the entire file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing to a file using the `SeekableByteChannel` interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querying the position
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing the contents of the entire file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Add the following code to the application. The purpose is to demonstrate how
    to process the entire file in a sequential fashion and to gain an understanding
    of various `SeekableByteChannel` interface methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application. Your output should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We started by repositioning the `read` to the beginning of the file, using
    the `position` method. The encoding string for the system was determined for the
    system by accessing the `system` property: `file.encoding`. We kept track of how
    many bytes are read with each read operation and displayed this count.'
  prefs: []
  type: TYPE_NORMAL
- en: In the while loop, we displayed the contents of the buffer by enclosing it in
    a set of brackets. This made it easier to see what was read in. The `rewind` method
    sets the position within the buffer to `0`. This is not to be confused with the
    position within the file.
  prefs: []
  type: TYPE_NORMAL
- en: To display the actual buffer, we need to apply the `forName` method to obtain
    a `Charset` object, and then use the `decode` method against it to convert the
    bytes in the buffer into Unicode characters. This was followed by the `flip` method,
    which sets the limit of the buffer to the current position and then sets the position
    in the buffer to `0`. This sets up the buffer for subsequent reads.
  prefs: []
  type: TYPE_NORMAL
- en: You may want to adjust the `bufferSize` value to see how the application behaves
    with different values.
  prefs: []
  type: TYPE_NORMAL
- en: Writing to a file using the SeekableByteChannel interface
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `write` method takes a `java.nio` package's `ByteBuffer` object and writes
    it to the channel. The operation starts at the current position in the file. For
    example, if the file was opened with an append option, the first write will be
    at the end of the file. The method returns the number of bytes written.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we will append three names to the end of the `users.txt`
    file. We use the `StandardOpenOption.APPEND` as the open option for the `newByteChannel`
    method. This will move the cursor to the end of the file and begin writing at
    that position. A `ByteBuffer` is created with three names separated by the system
    line separator property. Using this property makes the code more portable. The
    `write` method is then executed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The initial contents of the `users.txt` file should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the code sequence to the application and execute the program. Examine the
    contents of the `users.txt` file. It should now appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Query the position
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The overloaded `position` method returns a long value indicating the position
    within the file. This is complemented by a `position` method that takes a long
    argument and sets the position to that value. If the value exceeds the size of
    the stream, then the position is set to the end of the stream. The `size` method
    will return the size of the file used by the channel.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate the use of these methods, we will duplicate the example in the
    previous section. This means we will position the file cursor to the end of the
    `users.txt` file and then write three different names on separate lines.
  prefs: []
  type: TYPE_NORMAL
- en: In the following code sequence, we use the `size` method to determine how big
    the file is, and then use this value as the argument to the `position` method.
    This moves the cursor to the end of the file.
  prefs: []
  type: TYPE_NORMAL
- en: Next, a `ByteBuffer` is created thrice, and written to the file each time using
    a different name. The position is displayed for informational purposes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The contents of the `users.txt` file should initially contain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Add this sequence to the application and execute the program. Examine the contents
    of the `users.txt` file. It should now appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bob**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mary**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sally**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tom**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ted**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Paul**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Carol**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fred**'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this chapter
  prefs: []
  type: TYPE_NORMAL
- en: '*There''s more* section of the *Random access IO using the SeekableByteChannel*
    recipe: This recipe briefs you on the options used to open a file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Writing to a file using the BufferedWriter class* of the *Using buffered IO
    for files* recipe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing asynchronous communication using the AsynchronousServerSocketChannel
    class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Java 7 supports asynchronous communications between a server and a client. The
    `java.nio.channels` package's `AsynchronousServerSocketChannel` class supports
    server operations for streaming IO in a thread-safe manner. Communication is conducted
    using an `AsynchronousSocketChannel` object that acts as a client. Together we
    can use these classes to build a server/client application that communicates in
    an asynchronous fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Both a server and a client need to be created. To create a server:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the static `AsynchronousServerSocketChannel` class' `open` method to get
    an instance of a `AsynchronousServerSocketChannel` object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bind the channel to a local address and port number
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `accept` method to accept a connection request from a client
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Process messages as they are received
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To create a client:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an `AsynchronousSocketChannel` object using the static `open` method
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an instance of an `InetSocketAddress` object for the server
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect to the server
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send messages as needed
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We will create two applications: one on the server and one on the client. Together,
    they will support a simple server/client application, which will explain how asynchronous
    communication is performed using an `AsynchronousSocketChannel`.'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new console application that will be on the server and add the following
    `main` method. The server will simply display any messages sent to it. It opens
    a server socket and binds it to an address. It will then use the `accept` method
    with a `CompletionHandler` to process any requests from a client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Next, create a second console application that will act as a client. It will
    use the `open` method to create an `AsynchronousSocketChannel` object and then
    connect to the server. A `java.util.concurrent` package's `Future` object's `get`
    method is used to block until the connection is complete, and then a message is
    sent to the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You will need to execute both the applications. Depending on your environment,
    you may need to execute one of the applications in a command window and the second
    in your IDE. This will be the case if you can have only one instance of your IDE
    running at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the server application first. Next, execute the client application.
    It should prompt you for a message and then send the message to the server where
    it will be displayed. Your output should have the following general output. The
    client and the server output are shown in separate columns in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Client | Server |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Client: Waiting for the connection to completeEnter a message: First messageClient:
    Sending ...Client: Message sent: First message |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | Server: completed method executingServer: Message received: First message
    |'
  prefs: []
  type: TYPE_TB
- en: '| Enter a message: `Most excellent message`Client: Sending ...Client: Message
    sent: Most excellent message |  |'
  prefs: []
  type: TYPE_TB
- en: '|   | Server: Message received: Most excellent message |'
  prefs: []
  type: TYPE_TB
- en: '| Enter a message: `quit`Client: Sending ...Client: Message sent: quit |  
    |'
  prefs: []
  type: TYPE_TB
- en: '|   | Server: Message received: quitjava.util.concurrent.ExecutionException:
    java.io.IOException: The specified network name is no longer available.... |'
  prefs: []
  type: TYPE_TB
- en: Notice that when the client application was terminated, an `ExecutionException`
    occurred in the server. Normally, we would handle this exception more gracefully
    in a production application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let's examine the server application first. An `AsynchronousServerSocketChannel`
    object was created using the `open` method. The `bind` method was then used to
    associate the socket with a socket address, determined by the system and a port
    number of `5000`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `accept` method was invoked to accept a connection. The first argument
    specified a `null` value, which was used for attachments. Later, we will see how
    to use an attachment. The second argument was a `CompletionHandler` object. This
    object was created as an anonymous inner class, and its methods will be called
    when a communication request made by a client makes a communication request.
  prefs: []
  type: TYPE_NORMAL
- en: In the `completed` method, we displayed a message indicating that the method
    is executing. We then entered an infinite while loop where we allocated 32 bytes
    to a buffer, and then attempted to read from a client. The `read` method returned
    a `Future` object that we subsequently used the `get` method against. This effectively
    blocked the execution until the client sent a message. The message was then displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `get` method returned a generic `Future object` of type `Integer`.
    We could have used this to determine how many bytes were actually read. It was
    used here simply to block until the IO was complete. The `failed` method would
    have been called if an exception had occurred with the channel communication.
  prefs: []
  type: TYPE_NORMAL
- en: The infinite while loop at the end of the try block prevents the server from
    terminating. This is acceptable here for simplicity's sake, but normally, we would
    handle this in a more graceful fashion.
  prefs: []
  type: TYPE_NORMAL
- en: In the client application, we used the `open` method to create an `AsynchronousSocketChannel`
    object. A network address corresponding to the server was created and then used
    with the connect method to connect to the server. This method returned a `Future`
    object. We used this object with the `get` method to block until a connection
    with the server was established.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `connect` method returned a `Future` object of the type `Void`.
    The `Void` class is found in the `java.lang` package and is a wrapper class for
    `void`. It was used here as nothing was effectively returned by the `connect`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: A while loop was entered, which terminated when the user entered `quit`. The
    user was prompted for a message, and then a `ByteBuffer` object was created using
    the message. The buffer was then written to the server.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the use of multiple exceptions in the catch blocks of both applications.
    This is a new Java 7 language improvement and is discussed in the *Catching multiple
    exception types to improve type checking* recipe in [Chapter 1](ch01.html "Chapter 1. Java
    Language Improvements"), *Java Language Improvements*.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `bind` method is overloaded. Both versions' first argument is a `SocketAddress`
    object, corresponding to a local address. A `null` value can be used, which will
    automatically assign a socket address. The second `bind` method accepts an integer
    value for the second argument. This configures the maximum number of pending connections
    allowed in an implementation-dependent manner. A value less than or equal to zero
    will use an implementation-specific default value.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two aspects of this communication technique that we should address:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `Future` object in a server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the `AsynchronousServerSocketChannel` class options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Future object in a server
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `AsynchronousServerSocketChannel` class' `accept` method is overloaded.
    There is a no argument method that accepts a connection and returns a `Future`
    object for the channel. The `Future` object's `get` method will return an `AsynchronousSocketChannel`
    object for the connection. The advantage of this approach is that it returns an
    `AsynchronousSocketChannel` object, which can be used in other contexts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using the `accept` method, which uses a `CompletionHandler`, we
    can use the following sequence to do the same thing. Comment out the previous
    `accept` method and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Execute the applications again. You should get the same output as before.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the AsynchronousServerSocketChannel class options
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `supportedOptions` method returns a set of options used by the `AsynchronousServerSocketChannel`
    class. The `getOption` method will return the value of the option. Add the following
    code after the use of the `bind` method in the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the code. The default values will be displayed and should be similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The options can be set using the `setOption` method. This method takes the
    name of the option and a value. The following illustrates how to set the receive
    buffer size to 16,384 bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `StandardSocketOptions` class defines socket options. Only the `SO_REUSEADDR`
    and `SO_RCVBUF` options are supported for the `AsynchronousServerSocketChannel`
    channel.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this chapter: There''s more section, of the *Reading from a file using the
    AsynchronousFileChannel class* recipe: This recipe explains the use of attachments
    with a completion handler and the use of the `AsynchronousChannelGroup` class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing to a file using the AsynchronousFileChannel class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `java.nio.channels` package's `AsynchronousFileChannel` class permits file
    IO operations to be performed in an asynchronous manner. When an IO method is
    invoked, it will return immediately. The actual operation may occur at some other
    time (and potentially using a different thread). In this recipe, we will explore
    how the `AsynchronousFileChannel` class performs asynchronous **write** operations.
    **Read** operations will be demonstrated in the *Reading from a file using the
    AsynchronousFileChannel class* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To perform a write operation:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Path` object representing the file to be read from.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use this path with the `open` method to open a file channel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `write` method to write data to the file, optionally using a completion
    handler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this example, we will perform a series of write operations against a file.
    There are two overloaded `write` methods. Both take as their initial arguments
    a `java.nio` package's `ByteBuffer`, containing the data to be written and a second
    argument specifying the position to write to in the file.
  prefs: []
  type: TYPE_NORMAL
- en: The two arguments' `write` method returns a `java.util.concurrent` package's
    `Future<Integer>` object, which can also be used to write to a file, as demonstrated
    in the *There's more* section. The second `write` method has a third argument,
    an attachment, and a fourth argument, a `CompletionHandler` object. The completion
    handler is executed when the write operation completes.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new console application. Use the following `main` method. We open a
    file called `asynchronous.txt` for writing. A completion handler is created and
    used with the `write` method. Two write operations are performed. Thread information
    is displayed to explain the asynchronous nature of the operation and how completion
    handlers work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application. Your application may not behave as you expect. Due
    to the asynchronous nature of the operations, the order of execution of the various
    elements may vary from execution to execution. The following is one possible output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Re-executing the application may give a different order of execution. This behavior
    is explained in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We started by creating an `AsynchronousFileChannel` object using a `Path` object
    for the `asynchronous.txt` file in the `docs` directory. The file was opened for
    read and write operations, and was supposed to be created if it did not already
    exist. A `CompletionHandler` object was created. This was used in this example
    to confirm the execution of the write operations.
  prefs: []
  type: TYPE_NORMAL
- en: The `write` method was executed twice. The first time the string, `Sample`,
    was written to the file, starting at position `0` in the file. The second write
    operation wrote the string, `Box`, to the file, also starting at position `0`.
    This resulted in an overwrite, with the contents of the file containing the string,
    `Boxple`. This was intentional, and illustrates the use of the `position` argument
    of the `write` method.
  prefs: []
  type: TYPE_NORMAL
- en: The ID of the current thread was displayed at various points in the code. It
    shows one thread used for the `main` method, and two other threads used for the
    content handlers. When the `write` method was executed, it was performed in an
    asynchronous fashion. The `write` method executes and immediately returns. The
    actual write may occur at a later time. Upon completion of the write operation,
    a successful completion results in the content handler's `completed` method executing.
    This displays the ID for its thread, and a message showing the attachment and
    the number of bytes written. If an exception occurs, the `failed` method will
    be executed.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the output, a separate thread was used to execute the completion
    handler. The completion handler was defined to return an `Integer` value. This
    value represents the number of bytes written. The attachment can be any object
    needed. In this case, we used it to show which `write` method has completed. The
    asynchronous nature of the write operations resulted in an unpredictable execution
    order of the content handlers. However, the `write` methods did execute in the
    anticipated order.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the use of the try-with-resource block. This Java 7 feature is explored
    in the *Using the try-with-resource block to improve exception handling code*
    recipe in [Chapter 1](ch01.html "Chapter 1. Java Language Improvements"), *Java
    Language Improvements*.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The two arguments'' `write` method returns a `Future<Integer>` object. Later,
    in the program, we can use its `get` method, which blocks until the write operation
    has completed. Comment out the previous example''s write operations, and replace
    them with the following code sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application. The output should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `write` methods returned a `Future` object. The `get` method was blocked
    until the write operation was completed. We used the result to display a message
    indicating which write operation executed and how many bytes were written.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are considerably more aspects of asynchronous file channel IO that could
    be addressed. Other aspects that may be of interest include:'
  prefs: []
  type: TYPE_NORMAL
- en: Forcing the updates to a channel to be written
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locking parts or all of a file for exclusive access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `AsynchronousChannelGroup` to manage related asynchronous operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this chapter *Reading from a file using the AsynchronousFileChannel class:*
    This recipe demonstrates how to perform asynchronous reads, and the use of the
    `AsynchronousChannelGroup` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading from a file using the AsynchronousFileChannel class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Asynchronous read operations are also possible using either of two overloaded
    `read` methods. We will demonstrate how this is accomplished using a `java.nio.channels`
    package's `AsynchronousChannelGroup` object. This will provide us with a way of
    observing these methods in action and provide an example of an `AsynchronousChannelGroup`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To perform a write operation:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Path` object representing the file to be read from.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use this path with the `open` method to open a file channel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `read` method to read data from the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Create a new console application. In the `main` method, create an instance of
    a `java.util.concurrent` package's `ScheduledThreadPoolExecutor` object of size
    three. We will use the `ScheduledThreadPoolExecutor` class primarily because it
    is easy to create. A size of three will help illustrate how threads are managed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Next, add a try-with-resource block and create an `AsynchronousFileChannel`
    object for the file `items.txt`. Use an `open` option of `StandardOpenOption.READ`,
    and the previously created pool object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Next, display the main thread ID and then create a `CompletionHandler` object,
    which we will use to display the results of the asynchronous read operation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Next, add code to create an array of `ByteBuffer` objects. Allocate `10` bytes
    for each buffer, and then use a buffer as the first argument of the `read` method
    and as the attachment. Using it as the attachment, allows us to access the result
    of the read operation in the completion handler. The starting read position is
    specified in the second argument, and is set up to read every 10-byte segment
    of the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Add a call to the `awaitTermination` method to allow the read operations to
    complete. Then display the buffers a second time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following as the content of the `items.txt` file, where each entry
    is a 10-byte sequence consisting of an item and a quantity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application. Your output should be similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Notice the use of three IDs for the completion handler threads. These correspond
    to the three threads created as part of the thread pool.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A `java.util.concurrent` package's `ExecutorService` was created with a thread
    pool of size three to demonstrate the use of a thread group and to force the reuse
    of threads. The `items.txt` file contained data of equal lengths. This simplified
    the example.
  prefs: []
  type: TYPE_NORMAL
- en: In the content handler, upon successful completion, the `completed` method was
    executed. The attachment contained the buffer `read`, which was then displayed
    along with the content handler's thread ID. Notice the use of the `synchronized`
    keyword for the `completed` method. While not always required for the method,
    it was used here, so that the output would be more readable. The removal of the
    keyword would result in an interleaving of the buffer's output, making it unreadable.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the non-deterministic behavior of the completion handler threads. They
    did not execute in the order that the corresponding `read` methods were executed.
    Repeated execution of the application should produce differing output.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing that the input file contained only five items, we created five `ByteBuffer`
    objects each of size `10`. The `read` method was executed five times using a different
    buffer.
  prefs: []
  type: TYPE_NORMAL
- en: The `awaitTermination` method was executed, which effectively paused the application
    for a second. This allowed the completion handler's threads to complete. The buffers
    were then displayed a second time to verify the operation.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whenever an asynchronous channel is created, it is assigned to a channel group.
    By defining your own group, you can exercise better control over the threads used
    in the group. When a channel is created using an `open` method, it belongs to
    a global channel group.
  prefs: []
  type: TYPE_NORMAL
- en: An asynchronous channel group provides techniques needed for the completion
    of asynchronous IO operations that are bound to a group. Each group has a thread
    pool. These threads are used for the IO operations and `CompletionHandler` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, we used the `open` method to associate a thread pool
    with the asynchronous operations. An asynchronous channel group can also be created
    using one of the following static `AsynchronousChannelGroup` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`withFixedThreadPool:` A fixed size pool that uses a `ThreadFactory` to create
    new threads. The size of the pool is specified by its first argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`withCachedThreadPool:` This pool uses an `ExecutorService` to create new threads.
    The second argument specifies a suggested number of initial threads for the pool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`withThreadPool:` This also uses an `ExecutorService`, but without an initial
    size specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An asynchronous channel group provides the ability to perform an orderly shutdown
    of a group. Once the shutdown is initiated:'
  prefs: []
  type: TYPE_NORMAL
- en: Its attempts to create a new channel result in a `ShutdownChannelGroupException`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Threads running completion handlers are not interrupted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A group terminates when:'
  prefs: []
  type: TYPE_NORMAL
- en: All of its channels are closed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All completion handlers have run to completion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All group resources have been released
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other methods of interest include:'
  prefs: []
  type: TYPE_NORMAL
- en: The `isShutdown` method, which will determine if a group is shutdown or not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `isTerminated` method, which will determine if a group has been terminated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `shutdownNow` method, which will force the shutdown of a group. All channels
    are closed but content handlers are not interrupted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Writing to a file using the AsynchronousFileChannel class:* This recipe demonstrates
    how to perform asynchronous writes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the SecureDirectoryStream class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `java.nio.file` package's `SecureDirectoryStream` class is designed to be
    used with applications that depend on tighter security than that provided by other
    IO classes. It supports race-free (sequentially consistent) operations on a directory,
    where the operations are performed concurrently with other applications.
  prefs: []
  type: TYPE_NORMAL
- en: This class requires support from the operating system. An instance of the class
    is obtained by casting the return value of the `Files` class' `newDirectoryStream`
    method to a `SecureDirectoryStream` object. If the cast fails, then the underlying
    operating system does not support this type of stream.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To get and use a `SecureDirectoryStream` object:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Path` object representing the directory of interest.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `Files` class' `newDirectoryStream` method, and cast the result to a
    `SecureDirectoryStream`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use this object to affect `SecureDirectoryStream` operations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Create a new console application. In the `main` method, add the following code.
    We will create a `Path` object for the `docs` directory and then obtain a `SecureDirectoryStream`
    object for it. This will be used to view the POSIX permissions for the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application on a system that supports the `SecureDirectoryStream`
    class. The following output was obtained by running the application on an Ubuntu
    system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A `Path` object for the `docs` directory was obtained and then used as the argument
    of the `Files` class' `newDirectoryStream` method. The result of the method was
    cast to a `SecureDirectoryStream` class. The `getFileAttributeView` method was
    then executed to obtain a view, which was used to display the POSIX file permissions
    for the directory. The use of the `PosixFileAttributeView` class is discussed
    in the *Using the PosixFileAttributeView to maintain POSIX file attributes* recipe,
    in [Chapter 3](ch03.html "Chapter 3. Obtaining File and Directory Information"),
    *Obtaining File and Directory Information*.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Other methods supported by the SecureDirectoryStream class include the ability
    to delete a file or directory, a move method to move a file to a different directory,
    and the creation of a `SeekableByteChannel` to access a file.
  prefs: []
  type: TYPE_NORMAL
