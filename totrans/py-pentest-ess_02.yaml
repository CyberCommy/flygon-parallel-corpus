- en: Scanning Pentesting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network scanning refers to a set of procedures that investigate a live host,
    the type of host, open ports, and the type of services running on the host. Network
    scanning is a part of intelligence gathering by virtue of which an attacker can
    create a profile of the target organization.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to check live systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ping sweep
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TCP scanner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create an efficient IP scanner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services running on the target machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concept of a port scanner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create an efficient port scanner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should have a basic knowledge of the TCP/IP layer communication. Before
    proceeding further, the concept of the **protocol data unit** (**PDU**) should
    be clear.
  prefs: []
  type: TYPE_NORMAL
- en: 'PDU is a unit of data specified in the protocol. It is the generic term for
    data at each layer:'
  prefs: []
  type: TYPE_NORMAL
- en: For the application layer, PDU indicates data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the transport layer, PDU indicates a segment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the internet or the network layer, PDU indicates a packet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the data link layer or network access layer, PDU indicates a frame
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the physical layer, that is, physical transmission, PDU indicates bits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to check live systems in a network and the concept of a live system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A ping scan involves sending an **ICMP ECHO Request** to a host. If a host
    is live, it will return an **ICMP ECHO Reply**, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1d0e92cb-1eae-4d31-bf75-948ace2b3865.png)'
  prefs: []
  type: TYPE_IMG
- en: ICMP request and reply
  prefs: []
  type: TYPE_NORMAL
- en: The operating system's `ping` command provides the facility to check whether
    the host is live or not. Consider a situation where you have to test a full list
    of IP addresses. In this situation, if you test the IP addresses one by one, it
    will take a lot of time and effort. In order to handle this situation, we use
    ping sweep.
  prefs: []
  type: TYPE_NORMAL
- en: Ping sweep
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ping sweep is used to identify the live host from a range of IP addresses by
    sending the ICMP ECHO request and the ICMP ECHO reply. From a subnet and network
    address, an attacker or pentester can calculate the network range. In this section,
    I am going to demonstrate how to take advantage of the ping facility of an operating
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, I shall write a simple and small piece of code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `import os` imports the OS module so that we can run
    on the OS command. The next line, `os.popen('ping -n 1 10.0.0.1')`, which takes
    a DOS command, is passed in as a string and returns a file-like object connected
    to the command's standard input or output streams. The `ping –n 1 10.0.0.1` command
    is a Windows OS command that sends one ICMP ECHO request packet. By reading the
    `os.psopen()` function, you can intercept the command's output. The output is
    stored in the `response` variable. In the next line, the `readlines()` function
    is used to read the output of a file-like object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output shows the `reply`, `byte`, `time`, and `TTL` values, which indicate
    that the host is live. Consider another output of the program for IP `10.0.0.2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding output shows that the host is not live.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code is very important for proper functioning and is similar to
    the engine of a car. In order to make it fully functional, we need to modify the
    code so that it is platform-independent and produces easily readable output.
  prefs: []
  type: TYPE_NORMAL
- en: 'I want my code to work for a range of IP addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code asks for the network address of the subnet, but you can give
    any IP address of the subnet. The next line, `net1= net.split('.')`, splits the
    IP address into four parts. The `net2 = net1[0]+a+net1[1]+a+net1[2]+a` statement
    forms the network address. The last two lines ask for a range of IP addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it platform-independent, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code determines whether the code is running on Windows OS or the
    Linux platform. The `oper = platform.system()` statement informs this to the running
    operating system as the `ping` command is different in Windows and Linux. Windows
    OS uses `ping –n 1` to send one packet of the ICMP ECHO request, whereas Linux
    uses `ping –c 1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see the full code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: A couple of new things are in the preceding code. The `for ip in xrange(st1,en1):`
    statement supplies the numeric values, that is, the last octet value of the IP
    address. Within the `for` loop, the `addr = net2+str(ip)` statement makes it one
    complete IP address, and the `comm = ping1+addr` statement makes it a full OS
    command, which passes to `os.popen(comm)`. The `if(line.count("TTL")):` statement
    checks for the occurrence of `TTL` in the line. If any `TTL` value is found in
    the line, then it breaks the further processing of the line by using the `break`
    statement. The next two lines of code print the IP address as live where `TTL`
    is found. I used `datetime.now()` to calculate the total time taken to scan.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the `ping_sweep.py` program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To scan 60 IP addresses, the program took 2 minutes 35 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: The TCP scan concept and its implementation using a Python script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ping sweep works on the ICMP ECHO request and the ICMP ECHO reply. Many users
    turn off their ICMP ECHO reply feature or use a firewall to block ICMP packets.
    In this situation, your ping sweep scanner might not work. In this case, you need
    a TCP scan. I hope you are familiar with the three-way handshake, as shown in
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5142a124-0157-4391-b994-3b2bbf01b9ac.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To establish the connection, the hosts perform a three-way handshake. The three
    steps in establishing a TCP connection are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The client sends a segment with the **SYN** flag; this means the client requests
    the server to start a session
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the form of a reply, the server sends the segment that contains the **ACK**
    and **SYN** flags
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client responds with an **ACK** flag
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s see the following code for a TCP scan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The upper part of the preceding code is the same as in the previous code. Here,
    we use two functions. Firstly, the `scan(addr)` function uses the socket as discussed
    in [Chapter 1](12d92e92-a5b2-459c-99d5-51cfe6741888.xhtml), *Python with Penetration
    Testing and Networking*. The `result = sock.connect_ex((addr,135))` statement
    returns an error indicator. The error indicator is `0` if the operation succeeds,
    otherwise it is the value of the `errno` variable. Here, we used port `135`; this
    scanner works for the Windows system. There are some ports such as `137`, `138`,
    `139` (NetBIOS name service), and `445` (Microsoft-DSActive Directory) that are
    usually open. So, for better results, you have to change the port and scan repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the `iptcpscan.py` program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s change the port number. Use `137`, and you will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'There will be no outcome from that port number. Change the port number again.
    Use `445`, and the output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding three outputs show that `10.0.0.5`, `10.0.0.8`, `10.0.0.11`, `10.0.0.12`,
    `10.0.0.13`, and `10.0.0.15` are live. These IP addresses are running on the Windows
    OS. This is an exercise for you to check the common open ports for Linux and make
    IP a complete IP TCP scanner.
  prefs: []
  type: TYPE_NORMAL
- en: How to create an efficient IP scanner in Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, you have seen the ping sweep scanner and the IP TCP scanner. Imagine
    that you buy a car that has all of the necessary facilities, but its speed is
    very slow; you feel that it is a waste of time and money. The same thing happens
    when the execution of our program is very slow. To scan 60 hosts, the `ping_sweep.py`
    program took 2 minutes 35 seconds for the same range of IP addresses for which
    the TCP scanner took nearly one minute. This took a lot of time to produce the
    results. But don't worry. Python offers you multithreading, which will make your
    program faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'I have written a full program about ping sweep with multithreading, and I will
    explain this to you in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `section 1` section is the same as that for the previous program. The one
    thing that has been added here is an ordered dictionary because it remembers the
    order in which its contents were added. If you want to know which thread gives
    the output first, then the ordered dictionary fits here. The `section 2` section
    contains the threading class, and the `class myThread (threading.Thread):` statement
    initializes the threading class. The `self.st = st` and `self.en = en` statements
    take the start and end range of the IP address. The `section 3` section contains
    the definition of the `run1` function, which is the engine of the car and is called
    by every thread with a different IP address range. The `dic[ip]= addr` statement
    stores the host ID as a key and the IP address as a value in the ordered dictionary.
    The `section 4` statement is totally new in this code; the `total_ip` variable
    is the total number of IP addresses to be scanned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The significance of the `tn =20` variable is that it states that 20 IP addresses
    will be scanned by one thread. The `total_thread` variable contains the total
    number of threads that need to scan `total_ip`, which denotes the number of IP
    addresses. The `threads= []` statement creates an empty list, which will store
    the threads. The `for` loop, `for i in xrange(total_thread):`, produces threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code produces the range of 20-20 IP addresses, such as `st1-20,
    20-40 ......-en1`. The `thread = myThread(st1,en)` statement is the thread object
    of the threading class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code terminates all the threads. The next line, `dict = collections.OrderedDict(sorted(dic.items()))`,
    creates a new sorted dictionary, `dict`, which contains IP addresses in order.
    The next lines print the live IP in order. The `threading.activeCount()` statement
    shows how many threads are produced. One picture says 1,000 words. The following
    diagram does the same thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/245d5e07-b312-4e07-815f-226ba9ef1023.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating and handling of threads
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the `ping_sweep_th_.py` program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The scan has been completed in one minute and 11 seconds. As an exercise, change
    the value of the `tn` variable, set it from `2` to `30`, and then study the result
    and find out the most suitable and optimal value of `tn`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, you have seen ping sweep by multithreading; now, I have written a multithreading
    program with the TCP scan method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'There should be no difficulty in understanding the program. The following diagram
    shows everything:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e11fcf5c-49fc-400b-88d8-956710f96afb.png)'
  prefs: []
  type: TYPE_IMG
- en: The IP TCP scanner
  prefs: []
  type: TYPE_NORMAL
- en: The class takes a range as the input and calls the `run1()` function. The `section
    4` section creates a thread, which is the instance of a class, takes a short range,
    and calls the `run1()` function. The `run1()` function has an IP address, takes
    the range from the threads, and produces the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the `iptcpscan.py` program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 60 IP addresses in 20 seconds; the performance is not bad. As an exercise, combine
    both of the scanners into one scanner.
  prefs: []
  type: TYPE_NORMAL
- en: How to create an efficient IP scanner in Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous IP scanner can work on both Windows and Linux. Now, I am going
    explain an IP scanner that is super fast but will work only on Linux machines.
    In the preceding code, we used the ping utility, but now we shall use our own
    ping packet to ping.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of the Linux-based IP scanner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The concept behind the IP scanner is very simple. We will produce several threads
    to send ping packets to different IP addresses. One daemon thread would be responsible
    for capturing the response of those ping packets. In order to run the IP scanner,
    you need to install the ping module. You can download the `.zip` file of the ping
    module from here: [https://pypi.python.org/pypi/ping](https://pypi.python.org/pypi/ping).
    Just unzip or untar it, browse the folder, and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If you don't want to install the module, then just copy the `ping.py` file from
    the unzipped folder and paste it into the folder from which you are going to run
    the IP scannercode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the code, for `ping_sweep_send_rec.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the IP calculation and thread creation parts are very
    much similar to previous code blocks we have seen. The `send_ping` function is
    called by threads to send ping packets with the help of the ping module. In the
    syntax `ping.do_one(ip,1,32)`, the second and third arguments signify the timeout
    and packet size respectively. Therefore, I set `1` as timeout and `32` as the
    ping packet size. The code inside `icmp_sniff` might be new to you. You will learn
    the full details of all of the syntax in [Chapter 3](4cbd4179-2d24-454b-b279-bcdae27210e2.xhtml),
    *Sniffing and Penetration Testing*. In a nutshell, the `icmp_sniff` function is
    capturing the sender's IP address from the incoming ICMP reply packets. As we
    already know,the ICMP reply packet's code is `0`. The syntaxes `if(ip_hdr[2]==1)`
    and `(icmp_hdr[0]==0)` mean that we only want ICMP and ICMP reply packets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the code and see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/193489c2-4647-48e1-9405-0d61e37d3c6a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding output shows that the program only takes around 11 seconds to
    perform scanning on 254 hosts. In the preceding code, we set 10 IP addresses per
    thread. You can change the IP addresses per thread. Play with different values
    and optimize the value of each IP per thread.
  prefs: []
  type: TYPE_NORMAL
- en: nmap with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section is dedicated to the nmap lovers. You can use `nmap` in Python.
    You just need to install the `python-nmap` module and `nmap`. The command to install
    them is very simple. By using pip, we can install `python-nmap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'After installing the `python-nmap` module, you can check the `nmap` module
    by importing it. If there is no error while importing, then it means that it was
    successfully installed. Let''s check what is inside in `nmap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the `PortScanner` class for this. Let''s see the code and then
    run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is very simple: just make an object of `nm=nmap.PortScanner()`.
    When you call the `nm.scan(host, arguments="-O")` method, you will get a very
    complex dictionary. The following output is part of the dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, it is very easy to obtain the information you need;
    basic Python knowledge is required though. Let''s run the code on four different
    operating systems. First, I ran the code on Redhat Linux 5.3 and Debian 7\. You
    can see this in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cec170e7-9c22-4116-9344-6e94dd715f59.png)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding output, you can see that `nmap` successfully finds the open
    TCP ports and required OS details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run `nmap` on Windows OS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/78ab4f7b-e470-44fa-a884-32d03897291f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding output, `nmap` successfully find Windows XP and Windows 10\.
    There are lots of other features in `nmap` modules. You can explore these yourself
    and write the appropriate code.
  prefs: []
  type: TYPE_NORMAL
- en: What are the services running on the target machine?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, you are familiar with how to scan IP addresses and identify a live host
    within a subnet. In this section, we will discuss the services that are running
    on a host. These services are the ones that are using a network connection. A
    service using a network connection must open a port; from a port number, we can
    identify which service is running on the target machine. In pentesting, the significance
    of port scanning is to check whether an illegitimate service is running on the
    host machine.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a situation where users normally use their computer to download a game,
    and a Trojan is identified during the installation of the game. The Trojan goes
    into hidden mode; opens a port; sends all the keystrokes, including log information,
    to the hacker. In this situation, port scanning helps to identify the unknown
    services that are running on the victim's computer.
  prefs: []
  type: TYPE_NORMAL
- en: Port numbers range from `0` to `65535`. The well-known ports (also known as
    system ports) are those that range from `0` to `1023` and are reserved for privileged
    services. Ports that range from `1024` to `49151` are registered port-like vendors
    used for applications; for example, port `3306` is reserved for MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of a port scanner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TCP's three-way handshake serves as logic for the port scanner; in the TCP/IP
    scanner, you have seen that the port (`137` or `135`) is one in which IP addresses
    are in a range. However, in the port scanner, the IP is only one port in a range.
    Take one IP and try to connect each port as a range given by the user. If the
    connection is successful, the port opens; otherwise, the port remains closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'I have written some very simple code for port scanning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The main logic has been written in the `try` block, which denotes the engine
    of the car. You are familiar with the syntax. Let's do an R&D on the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the `portsc.py` program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The preceding output shows that the port scanner scanned 1,000 ports in `0.7`
    seconds; the connectivity was full because the target machine and the scanner
    machine were on the same subnet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s discuss another output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s analyze the output: to scan 4,000 ports, the scanner took `1:06:43.272751`
    hours. This took a long time. The topology is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`192.168.0.10 --> 192.168.0.1 --> 10.0.0.16 ---> 10.0.0.1`'
  prefs: []
  type: TYPE_NORMAL
- en: The `192.168.0.1` and `10.0.0.16` IP addresses are gateway interfaces. We put
    one second in `socket.setdefaulttimeout(1)`, which means the scanner machine will
    spend a maximum of one second on each port. The total of 4,000 ports means that
    if all ports are closed, then the total time taken will be 4000 seconds; if we
    convert it into hours, it will become 1.07 hours, which is nearly equal to the
    output of our program. If we set `socket.setdefaulttimeout(.5)`, the time taken
    will be reduced to 30 minutes, which is still a long time. Nobody will use our
    scanner. The time taken should be less than 100 seconds for 4,000 ports.
  prefs: []
  type: TYPE_NORMAL
- en: How to create an efficient port scanner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I have stated some points that should be taken into account for a good port
    scanner:'
  prefs: []
  type: TYPE_NORMAL
- en: Multithreading should be used for high performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `socket.setdefaulttimeout(1)` method should be set according to the situation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The port scanner should have the ability to take host names as well as domain
    names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The port should provide the service name with the port number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The total time should be taken into account for port scanning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To scan ports `0` to `65535`, the time taken should be around 3 minutes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So now I have written my port scanner, which I usually use for port scanning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Don't be afraid to see the full code; it took me 2 weeks. I will explain to
    you the full code section-wise. In `section1`, the first two lines are related
    to the database file that stores the port information, which will be explained
    while creating the database file. The `scantcp()` function gets executed by threads.
    In `section 2`, this is for user inputs. If a user provides a port range beyond `65535`,
    then the code automatically takes care of the error. Low connectivity and high
    connectivity means that if you are using the internet, use low connectivity. If
    you are using the code on your own network, you can use high connectivity. In
    `section 3`, thread creation logic is written. The `30` ports would be handled
    by one thread, but if the number of threads exceeds `300`, then the ports per
    thread equation would be recalculated. In a `for` loop, threads get created, and
    each thread carries its own range of ports. In `section 4`, the thread gets terminated.
  prefs: []
  type: TYPE_NORMAL
- en: I wrote the preceding code after performing lots of experiments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to see the output of the `portsc15.py` program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Our efficient port scanner has given the same output as the previous simple
    scanner, but from a performance point of view, there is a huge difference. The
    time taken by a simple scanner was `1:06:43.272751`, but the new multithreaded
    scanner took just 32 seconds. It also shows the service name. Let''s check more
    output with ports `1` to `50000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The time taken was 2 minutes 48 seconds; I did the same experiment in high connectivity,
    where the time taken was `0:01:23.819774`, which is almost half the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: Now, I'm going to teach you how to create a database file that contains the
    description of all the port numbers; let's understand how to create a pickle database
    file that contains the description of all of the ports. Open the following link: [https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers](https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers).
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the port description part and save it in a text file. See the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d3a2287-362e-41db-b1c5-954311e314f1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s see the code for `creatdicnew.py` to convert the preceding file into
    a `pickle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: When you run the preceding code, the code will ask you to enter the text filename.
    After giving the filename, the code will convert the text file into a pickle file
    named `port_description.dat`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network scanning is done to gather information on the networks, hosts, and services
    that are running on the hosts. Network scanning is done by using the `ping` command
    of the OS; ping sweep takes advantage of the ping facility and scans the list
    of IP addresses. Sometimes, ping sweep does not work because users might turn
    off their ICMP ECHO reply feature or use a firewall to block ICMP packets. In
    this situation, your ping sweep scanner might not work. In such scenarios, we
    have to take advantage of the TCP three-way handshake; TCP works at the transport
    layer, so we have to choose the port number on which we want to carry out the
    TCP connect scan. Some ports of the Windows OS are always open, so you can take
    advantage of those open ports. The first main section is dedicated to network
    scanning; when you perform network scanning, your program should have maximum
    performance and take minimum time. In order to increase performance significantly,
    multithreading should be used.
  prefs: []
  type: TYPE_NORMAL
- en: After the scanning of live hosts, port scanning is used to check the services
    running on a particular host; sometimes, some programs use an internet connection
    which allows Trojans and port scanning can detect these types of threats. To make
    an efficient port scan, multithreading plays a vital role because port numbers
    range from `0` to `65536`. To scan a huge list, multithreading must be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, you will see sniffing and its two types: passive and active
    sniffing. You will also learn how to capture data, the concept of packet crafting,
    and the use of the Scapy library to make custom packets.'
  prefs: []
  type: TYPE_NORMAL
