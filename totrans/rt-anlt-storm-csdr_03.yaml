- en: Chapter 3. Understanding Storm Internals by Examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter of the book is dedicated to making you understand the internals
    of Storm and how it works using practical examples. The intent is to get you accustomed
    to writing you own spouts, go through reliable and non-reliable topologies, and
    acquaint you with various groupings provided by the Storm.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics that will be covered in the chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Storm spouts and custom spouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anchoring and acking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different stream groupings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be able to understand the various groupings
    and the concept of reliability by using of anchoring, and you will be able to
    create your own spouts.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing Storm spouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have explored and understood `WordCount` topology provided by the Storm-starter
    project in previous chapters. Now it's time we move on to the next step, the do
    it yourself journey with Storm; so let's take up the next leap and do some exciting
    stuff with our own spouts that read from various sources.
  prefs: []
  type: TYPE_NORMAL
- en: Creating FileSpout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here we will create our own spout to read the events or tuples from a file source
    and emit them into the topology; we would substitute spout in place of `RandomSentenceSpout`
    we used in the `WordCount` topology in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: To start, copy the project we created in [Chapter 2](part0020_split_000.html#page
    "Chapter 2. Getting Started with Your First Topology"), *Getting Started with
    Your First Topology*, into a new project and make the following changes in `RandomSentenceSpout`
    to make a new class called `FileSpout` within the Storm-starter project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will make changes in `FileSpout` so that it reads sentences from a file
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all the Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: Tweaking WordCount topology to use FileSpout
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we need to fit `FileSpout` into our `WordCount` topology and execute it.
    To do this, you need to change one line of code in `WordCount` topology and instantiate
    `FileSpout` instead of `RandomSentenceSpout` in `TopologyBuilder`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This one line change will take care of instantiation of the new spout that
    will read from the specified file `/home/mylog` (please create this file before
    you execute the program). Here is a screenshot of the output for your reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tweaking WordCount topology to use FileSpout](img/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The SocketSpout class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As a next step to understand the spouts better, let''s create a `SocketSpout`
    class. Assuming that you are proficient in writing Socket Server or Producer,
    I will walk you through the process of creating a custom `SocketSpout` class to
    consume a socket output in the Storm topology:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Anchoring and acking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have talked about DAG that is created for the execution of a Storm topology.
    Now when you are designing your topologies to cater to reliability, there are
    two items that needs to be added to Storm:'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a new link, that is, a new stream is being added to the DAG, it is
    called anchoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the tuple is processed in entirety, it is called acking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When Storm knows these preceding facts, then during the processing of tuples
    it can gauge them and accordingly fail or acknowledge the tuples depending upon
    whether they are completely processed or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following `WordCount` topology bolts to understand
    the Storm API anchoring and acking better:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SplitSentenceBolt`: The purpose of this bolt was to split the sentence into
    different words and emit it. Now let''s examine the output declarer and the execute
    methods of this bolt in detail (specially the highlighted sections) as shown in
    the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output declarer functionality of the preceding code is elaborated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`_collector.emit`: Here each tuple being emitted by the bolt on the stream
    called `word` (the second argument ) is anchored using the first argument of the
    method (the tuple). In this arrangement, if a failure occurs the tuple being anchored
    at the root of the tree would be replayed by the spout.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collector.ack`: Here we are informing Storm that tuple has been processed
    successfully by this bolt. In the event of a failure, the programmer can explicitly
    call a `fail` method, or Storm internally calls it, as in the case of timeout
    events so that it can be replayed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`declarer.declare`: This is the method called to specify the stream on which
    successfully processed tuples would be emitted. Notice that we have used the same
    `word` stream in the `_collector.emit` method. Similarly, if you look into the
    `WordCount` topology''s `Builder` method, you''d find another piece in overall
    integration of `word` stream, which is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The unreliable topology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s look at the unreliable version of the same topology. Here, if the
    tuple fails to be processed by Storm in entirety, it is not replayed by the framework.
    The code which we used previously, in this topology, would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Thus, an un-anchored tuple is emitted by the bolt. Sometimes, due to programming
    needs to handle various problems, developers deliberately create unreliable topologies.
  prefs: []
  type: TYPE_NORMAL
- en: Stream groupings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next we need to get acquainted with various stream groupings (a stream grouping
    is basically the mechanism that defines how Storm partitions and distributes the
    streams of tuples amongst tasks of bolts) provided by Storm. Streams are the basic
    wiring component of a Storm topology, and understanding them provides a lot of
    flexibility to the developer to handle various problems in programs efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Local or shuffle grouping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following figure, shuffle grouping is depicted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Local or shuffle grouping](img/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here **Bolt A** and **Bolt B** both have a parallelism of two, each; so two
    instances of each of these bolts is spawned by the Storm framework. These bolts
    are wired together by *shuffle grouping*. We will now discuss the distribution
    of events.
  prefs: []
  type: TYPE_NORMAL
- en: The 50 percent events from **Instance 1** of **Bolt A** would go to **Instance
    1** of **Bolt B**, and the remaining 50 percent would go to **Instance 2** of
    **Bolt B**. Similarly, 50 percent of events emitted by **Instance 2** of **Bolt
    B** would go to **Instance 1** of **Bolt B**, and the remaining 50 percent would
    go to **Instance 2** of **Bolt B**.
  prefs: []
  type: TYPE_NORMAL
- en: Fields grouping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this grouping, we specify two parameters—the source of the stream and the
    fields. The values of the fields are actually used to control the routing of the
    tuples to various bolts. This grouping guarantees that for the same field's value,
    the tuple will always be routed to the same instance of the bolt.
  prefs: []
  type: TYPE_NORMAL
- en: In the following figure, field grouping is depicted between **Bolt A** and **Bolt
    B**, and each of these bolts have two instances each. Notice the flow of events
    based on the value of the field grouping parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Fields grouping](img/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: All the events from **Instance 1** and **Instance 2** of **Bolt A**, where the
    value of **Field** is **P** are sent to **Instance 1** of **Bolt B**.
  prefs: []
  type: TYPE_NORMAL
- en: All the events from **Instance 1** and **Instance 2** of **Bolt A**, where the
    value of **Field** is **Q** are sent to **Instance 2** of **Bolt B**.
  prefs: []
  type: TYPE_NORMAL
- en: All grouping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All grouping is a kind of broadcaster grouping that can be used in situations
    where the same message needs to be sent to all instances of the destination bolt.
    Here, each tuple is sent to all the instances of the bolt.
  prefs: []
  type: TYPE_NORMAL
- en: 'This grouping should be used in very specific cases, for specific streams,
    where we want the same information to be replicated to all bolt instances downstream.
    Let''s take a use case that has some information related to a country and its
    currency value and the bolts following the bolt, which does need this information
    for some currency conversion. Now whenever *currency* bolt has any changes, it
    uses *all* grouping to publish it to all the instances of the following bolts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![All grouping](img/00024.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here we have a diagrammatic representation of *all* grouping, where all the
    tuples from **Bolt A** are sent to all the instances of **Bolt B**.
  prefs: []
  type: TYPE_NORMAL
- en: Global grouping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Global grouping makes sure that the entire stream from the source component
    (spout or bolt) goes to a single instance of target bolt, to be more precise and
    specific to the instance of the target bolt with the lowest ID. Well let''s understand
    the concept with an example, let''s say my topology is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Global grouping](img/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'I will assign the following parallelism to the components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Global grouping](img/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, I will use the following stream groupings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Global grouping](img/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, the framework will direct all data from the *myboltA* stream instances,
    that are emitting onto one instance of *myboltB* stream, which would be the one
    to which Storm has assigned a lower ID while instantiation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Global grouping](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As in the preceding figure, in the case of global grouping, all tuples from
    both instances of **Bolt A** would go to **Instance 1** of **Bolt B**, assuming
    it has a lower ID than **Instance 2** of **Bolt B**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Storm basically assigns IDs to each instance of a bolt or spout that it creates
    in the topology. In global grouping, the allocations are directed to the instance
    that has a lower value on the ID allocated from Storm.
  prefs: []
  type: TYPE_NORMAL
- en: Custom grouping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Storm, being an extendible framework, provides the facility to developers to
    create their own stream grouping. This can be done by providing an implementation
    to the `backtype.storm.grouping.CustomStreamGroupinginterface` class.
  prefs: []
  type: TYPE_NORMAL
- en: Direct grouping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this kind of grouping, the Storm framework provides the ability to the sender
  prefs: []
  type: TYPE_NORMAL
- en: component (spout or bolt) to decide which task of the consumer bolt would receive
    the tuple while the sender component is emitting a tuple to the stream.
  prefs: []
  type: TYPE_NORMAL
- en: The tuple must be emitted to the stream using a special `emitDirect` method
    to the stream, and the task of consuming a component has to be specified (note
    that the tasked can be fetched using the `TopologyContext` method).
  prefs: []
  type: TYPE_NORMAL
- en: Quiz time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Q.1 State whether the following statements are true or false:'
  prefs: []
  type: TYPE_NORMAL
- en: All components of reliable topologies use anchoring.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the event of a failure, all the tuples are played back again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Shuffle grouping does load balancing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Global grouping is like a broadcaster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Q.2 Fill in the blanks:'
  prefs: []
  type: TYPE_NORMAL
- en: _______________ is the method to tell the framework that the tuple has been
    successfully processed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The _______________ method specifies the name of the stream.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ___________ method is used to push the tuple downstream in the DAG.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make changes to `WordCount` topology of the Storm-starter project to create
    a custom grouping so that all words starting from a particular letter always go
    to same instance of the `WordCount` bolt.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have understood the intricacies of the Storm spout. We also
    created a custom file spout and integrated it with `WordCount` topology. We also
    introduced you to the concepts of reliability, acking, and anchoring. The knowledge
    of various groupings provided by the current version of Storm further enhance
    the capabilities of a user to explore and experiment.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we shall get you acquainted with the clustered setup of
    Storm as well as give you an insight on various monitoring tools of clustered
    mode.
  prefs: []
  type: TYPE_NORMAL
