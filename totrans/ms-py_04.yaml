- en: Chapter 4. Functional Programming – Readability Versus Brevity
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is one of the few (or at least the earliest) nonfunctional languages
    to incorporate functional features. While Guido van Rossum has tried to remove
    some of them a few times, they have become ingrained in the Python community,
    and list comprehensions (`dict` and `set` comprehensions soon to follow) are widely
    used in all sorts of code. The most important thing about code shouldn't be how
    cool your `reduce` statement is or how you can fit the entire function in a single
    line with an incomprehensible list comprehension. Readability counts (once again,
    `PEP20`)!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will show you some of the cool tricks that functional programming
    in Python gives you, and it will explain some of the limitations of Python's implementation.
    While we will try to steer clear of lambda calculus (λ-calculus) as much as possible,
    the **Y combinator** will be discussed briefly.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: The last few paragraphs will list (and explain) the usage of the `functools`
    and `itertools` libraries. If you are familiar with these libraries, feel free
    to skip them, but note that some of these will be used heavily in the later chapters
    about decorators ([Chapter 5](ch05.html "Chapter 5. Decorators – Enabling Code
    Reuse by Decorating"), *Decorators – Enabling Code Reuse by Decorating*), generators
    ([Chapter 6](ch06.html "Chapter 6. Generators and Coroutines – Infinity, One Step
    at a Time"), *Generators and Coroutines – Infinity, One Step at a Time*), and
    performance ([Chapter 12](ch12.html "Chapter 12. Performance – Tracking and Reducing
    Your Memory and CPU Usage"), *Performance – Tracking and Reducing Your Memory
    and CPU Usage*).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the topics covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: The theory behind functional programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list` comprehensions'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dict` comprehensions'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set` comprehensions'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lambda` functions'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`functools` (`partial`, and `reduce`)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`itertools` (`accumulate`, `chain`, `dropwhile`, `starmap`, and so on)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional programming
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional programming is a paradigm that originates from the lambda calculus.
    Without diving too much into the lambda calculus (λ-calculus), this roughly means
    that computation is performed through the use of mathematical functions, which
    avoids mutable data and changing state of surroundings. The idea of a strictly
    functional language is that all function outputs are dependent only on the input
    and not on any external state. Since Python is not strictly a programming language,
    this doesn't necessarily hold true, but it is a good idea to adhere to this paradigm
    as mixing these can cause unforeseen bugs as discussed in [Chapter 2](ch02.html
    "Chapter 2. Pythonic Syntax, Common Pitfalls, and Style Guide"), *Pythonic Syntax,
    Common Pitfalls, and Style Guide*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Even outside of functional programming, this is a good idea. Keeping functions
    purely functional (relying only on the given input) makes code clearer, easier
    to understand, and better to test as there are less dependencies. Well-known examples
    can be found within the `math` module. These functions (`sin`, `cos`, `pow`, `sqrt`,
    and so on) have an input and an output that is strictly dependent on the input.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: list comprehensions
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Python `list` comprehensions are a very easy way to apply a function or
    filter to a list of items. List comprehensions can be very useful if used correctly
    but very unreadable if you're not careful.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s dive right into a few examples. The basic premise of a `list` comprehension
    looks like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can easily expand this with a filter:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The syntax is pretty close to regular Python for loops, but the `if` statement
    and automatic storing of results makes it quite useful for some cases. The regular
    Python equivalent is not much longer, however:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Care must be taken though; because of the special list comprehension structure,
    some types of operations are not as obvious as you might expect. This time, we
    are looking for random numbers greater than `0.5`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: See that last number? It's actually less than `0.5`. This happens because the
    first and the last random calls are actually separate calls and return different
    results.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to counter this is by creating the list separate from the filter:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That obviously works, but it's not all that pretty. So what other options are
    there? Well, there are a few but the readability is a bit questionable, so these
    are not the solutions that I would recommend. It's good to see them at least once,
    however.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a `list` comprehension in a list comprehension:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And here''s one that quickly becomes an incomprehensible `list` comprehension:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Caution is needed with these options as the double list comprehension actually
    works like a nested `for` loop would, so it quickly generates a lot of results.
    To elaborate on this regard:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This effectively does the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'These can be useful for some cases, but I would recommend that you limit their
    usage, as they have a tendency to quickly become unreadable. I would strongly
    advise against using `list` comprehensions within `list` comprehensions for the
    sake of readability. It''s still important to understand what is happening, so
    let''s look at one more example. The following `list` comprehension swaps the
    column and row counts, so a 3 x 4 matrix becomes 4 x 3:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Even with the extra indentation, the `list` comprehension just isn't all that
    readable. With four nested loops, that is expectedly so, of course. There are
    rare cases where nested list comprehensions might be justified, but generally
    I won't recommend their usage.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: dict comprehensions
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`dict` comprehensions are very similar to list comprehensions, but the result
    is a `dict` instead. Other than this, the only real difference is that you need
    to return both a key and a value, whereas a `list` comprehension accepts any type
    of value. The following is a basic example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the output is a dictionary, the key needs to be hashable for the `dict`
    comprehension to work.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'The funny thing is that you can mix these two, of course, for even more unreadable
    magic:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Obviously, you need to be careful with these. They can be very useful if used
    correctly, but the output quickly becomes unreadable, even with proper whitespace.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: set comprehensions
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just as you can create a `set` using curly brackets (`{}`), you can also create
    a set using `set` comprehensions. These work in a way similar to `list` comprehensions,
    but the values are unique (and without sort order):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As is the case with the regular set, `set` comprehensions support only hashable
    types.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: lambda functions
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `lambda` statement in Python is simply an anonymous function. Due to the
    syntax, it is slightly more limited than regular functions, but a lot can be done
    through it. As always though, readability counts, so generally it is a good idea
    to keep it as simple as possible. One of the more common use cases is the `sort`
    key for the `sorted` function:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: While the function could have been written separately or the `__cmp__` method
    of `Spam` could have been overwritten in this case, in many cases, this is an
    easy way to get a quick sort function as you would want it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s not that the regular function would be verbose, but by using an anonymous
    function, you have a small advantage; you are not contaminating your local scope
    with an extra function:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As for style, do note that `PEP8` dictates that assigning a lambda to a variable
    is a bad idea. And logically, it is. The idea of an anonymous function is that
    it is just that—anonymous. If you are giving it an identity, you should define
    it as a normal function. It really isn''t much longer if you want to keep it short.
    Note that both of the following statements are considered bad style and are for
    example purposes only:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In my opinion, the only valid use case for `lambda` functions is as anonymous
    functions used as function parameters, and preferably only if they are short enough
    to fit on a single line.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: The Y combinator
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that this paragraph can easily be skipped. It is mostly an example of the
    mathematical value of the lambda statement.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'The Y combinator is probably the most famous example of the λ-calculus:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '![The Y combinator](images/4711_04_01.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
- en: 'All this looks very complicated, but that''s also because it has used the lambda
    calculus notation. You should read this syntax, ![The Y combinator](images/4711_04_02.jpg),
    as an anonymous (lambda) function that takes `x` as an input and returns ![The
    Y combinator](images/4711_04_03.jpg). In Python, this would be expressed almost
    exactly as it is in the original lambda calculus, except for replacing ![The Y
    combinator](images/4711_04_04.jpg) with lambda and `.` with `:`, so it results
    in lambda `x: x^2`.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'With some algebra, this can be reduced to ![The Y combinator](images/4711_04_05.jpg),
    or a function that takes the `f` function and applies it to itself. The λ-calculus
    notation of this function is as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '![The Y combinator](images/4711_04_06.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
- en: 'Here is the Python notation:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following is the longer version:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This might still be a bit unclear to you, so let''s look at an example that
    actually uses it:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following is the short version, where the power of the Y combinator actually
    appears, with a recursive but still anonymous function:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Note that the `n` and `n * c(n – 1)` or `1` part is short for the `if` statement
    used in the longer version of the function. Alternatively, this can be written
    using the Python ternary operator:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You might be wondering about the point of this entire exercise. Can't you write
    a factorial shorter/easier? Yes, you can. The importance of the Y combinator is
    that it can be applied to any function and is very close to the mathematical definition.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'One final example of the Y combinator will be given by the definition of `quicksort`
    in a few lines:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: While the Y combinator most likely doesn't have much practical use in Python,
    it does show the power of the `lambda` statement and how close Python is to the
    mathematical definition. Essentially, the difference is only in the notation and
    not in the functionality.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: functools
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the `list/dict/set` comprehensions, Python also has a few (more
    advanced) functions that can be really convenient when coding functionally. The
    `functools` library is a collection of functions that return callable objects.
    Some of these functions are used as decorators (we'll cover more about that in
    [Chapter 5](ch05.html "Chapter 5. Decorators – Enabling Code Reuse by Decorating"),
    *Decorators – Enabling Code Reuse by Decorating*), but the ones that we are going
    to talk about are used as straight-up functions to make your life easier.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: partial – no need to repeat all arguments every time
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `partial` function is really convenient for adding some default arguments
    to a function that you use often but can''t (or don''t want to) redefine. With
    object-oriented code, you can usually work around cases similar to these, but
    with procedural code, you will often have to repeat your arguments. Let''s take
    the `heapq` functions from [Chapter 3](ch03.html "Chapter 3. Containers and Collections
    – Storing Data the Right Way"), *Containers and Collections – Storing Data the
    Right Way*, as an example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Almost all the `heapq` functions require a `heap` argument, so why not make
    a shortcut for it? This is where `functools.partial` comes in:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Seems a bit cleaner, right? In this case, both versions are fairly short and
    readable, but it's a convenient function to have.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Why should we use `partial` instead of writing a `lambda` argument? Well, it's
    mostly about convenience, but it also helps solve the late binding problem discussed
    in [Chapter 2](ch02.html "Chapter 2. Pythonic Syntax, Common Pitfalls, and Style
    Guide"), *Pythonic Syntax, Common Pitfalls, and Style Guide*. Additionally, partial
    functions can be pickled whereas `lambda` statements cannot.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: reduce – combining pairs into a single result
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `reduce` function implements a mathematical technique called `fold`. It
    basically applies a function to the first and second elements, uses that result
    to apply together with the third element, and continues until the list is exhausted.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: The `reduce` function is supported by many languages but in most cases using
    different names such as `curry`, `fold`, `accumulate`, or `aggregate`. Python
    has actually supported `reduce` for a very long time, but since Python 3, it has
    been moved from the global scope to the `functools` library. Some code can be
    simplified beautifully using the `reduce` statement; whether it's readable or
    not is debatable, however.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a factorial function
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the most used examples of `reduce` is for calculating factorials, which
    is indeed quite simple:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The preceding code uses `operator.mul` instead of `lambda a, b: a * b`. While
    they produce the same results, the former can be quite faster.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Internally, the `reduce` function will do the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To clarify this further, let''s look at it like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Or with a simple `while` loop using the `deque` collection:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Processing trees
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Trees are a case where the `reduce` function really shines. Remember the one-line
    tree definition using a `defaultdict` from [Chapter 3](ch03.html "Chapter 3. Containers
    and Collections – Storing Data the Right Way"), *Containers and Collections –
    Storing Data the Right Way*? What would be a good way to access the keys inside
    of that object? Given a path of a tree item, we can use `reduce` to easily access
    the items inside:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: And lastly, some people might be wondering why Python only has `fold_left` and
    no `fold_right`. In my opinion, you don't really need both of them as you can
    easily reverse the operation.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'The regular `reduce`—the `fold left` operation:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The reverse—the `fold right` operation:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: While this one is definitely very useful in purely functional languages—where
    these operations are used quite often—initially there were plans to remove the
    `reduce` function from Python with the introduction of Python 3\. Luckily, that
    plan was modified, and instead of being removed, it has been moved from `reduce`
    to `functools.reduce`. There may not be many useful cases for `reduce`, but there
    are some cool use cases. Especially traversing recursive data structures is far
    more easily done using `reduce`, since it would otherwise involve more complicated
    loops or recursive functions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: itertools
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `itertools` library contains iterable functions inspired by those available
    in functional languages. All of these are iterable and have been constructed in
    such a way that only a minimal amount of memory is required to process even the
    largest of datasets. While you can easily write most of these functions yourself
    using a simple function, I would still recommend using the ones available in the
    `itertools` library. These are all fast, memory efficient, and—perhaps more importantly—tested.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even though the titles of the paragraphs are capitalized, the functions themselves
    are not. Be careful not to accidently type `Accumulate` instead of `accumulate`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: accumulate – reduce with intermediate results
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `accumulate` function is very similar to the `reduce` function, which is
    why some languages actually have `accumulate` instead of `reduce` as the folding
    operator.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'The major difference between the two is that the `accumulate` function returns
    the immediate results. This can be useful when summing the results of a company''s
    sales, for example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It should be noted that the `operator.add` function is actually optional in
    this case as the default behavior of accumulate is to sum the results. In some
    other languages and libraries, this function is called `cumsum` (cumulative sum).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: chain – combining multiple results
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `chain` function is a simple but useful function that combines the results
    of multiple iterators. Very simple but also very useful if you have multiple lists,
    iterators, and so on—just combine them with a simple chain:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It should be noted that there is a small variant of `chain` that accepts an
    iterable containing iterables, namely `chain.from_iterable`. They work nearly
    identically, except for the fact that you need to pass along an iterable item
    instead of passing a list of arguments. Your initial response might be that this
    can be achieved simply by unpacking the (`*args`) tuple, as we will see in [Chapter
    6](ch06.html "Chapter 6. Generators and Coroutines – Infinity, One Step at a Time"),
    *Generators and Coroutines – Infinity, One Step at a Time*. However, this is not
    always the case. For now, just remember that if you have a iterable containing
    iterables, the easiest method is to use `itertools.chain.from_iterable`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: combinations – combinatorics in Python
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `combinations` iterator produces results exactly as you would expect from
    the mathematical definition. All combinations with a specific length from a given
    list of items:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `combinations` function gives all possible combinations of the given items
    of a given length. The number of possible combinations is given by the binomial
    coefficient, the `nCr` button on many calculators. It is commonly denoted as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '![combinations – combinatorics in Python](images/4711_04_07.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: We have `n=2` and `k=4` in this case.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the variant with repetition of elements:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `combinations_with_repetitions` function is very similar to the regular
    `combinations` function, except that the items can be combined with themselves
    as well. To calculate the number of results, the binomial coefficient described
    earlier can be used with the parameters as `n=n+k-1` and `k=k`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a little combination of combinations and chain for generating
    a `powerset`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `powerset` is essentially the combined result of all combinations from
    `0` to `n`, meaning that it also includes elements with zero items (the empty
    set, or `()`), elements with `1` item, and all the way up to `n`. The number of
    items in the `powerset` is easily calculated using the power operator: `2**n`.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: permutations – combinations where the order matters
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `permutations` function is quite similar to the `combinations` function.
    The only real difference is that `(a, b)` is considered distinct from `(b, a)`.
    In other words, the order matters:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: compress – selecting items using a list of Booleans
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `compress` function is one of those that you won''t need too often, but
    it can be very useful when you do need it. It applies a Boolean filter to your
    iterable, making it return only the ones you actually need. The most important
    thing to note here is that it''s all executed lazily and that `compress` will
    stop if either the data or the selectors collection is exhausted. So, even with
    infinite ranges, it works without a hitch:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: dropwhile/takewhile – selecting items using a function
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `dropwhile` function will drop all results until a given predicate evaluates
    to true. This can be useful if you are waiting for a device to finally return
    an expected result. That''s a bit difficult to demonstrate here, so I''ll just
    show an example with the basic usage—waiting for a number greater than `3`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As you might expect, the `takewhile` function is the reverse of this. It will
    simply return all rows until the predicate turns false:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Simply adding the two will give you the original result again.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: count – infinite range with decimal steps
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `count` function is quite similar to the `range` function, but there are
    two significant differences.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: The first is that this range is infinite, so don't even try to do `list(itertools.count())`.
    You'll definitely run out of memory immediately and it might even freeze your
    system.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: The second difference is that unlike the `range` function, you can actually
    use floating-point numbers here, so there is no need of whole/integer numbers.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'Since listing the entire range will kill our Python interpreter, we''ll simply
    use `zip` both to limit the results and to compare the results of the regular
    `range` function. In a later paragraph, we will see a more convenient option using
    `itertools.islice`. The `count` function takes two optional parameters: a `start`
    parameter, which defaults to `0`, and a `step` parameter, which defaults to `1`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `itertools.islice` function is also very useful in conjunction with `itertools.count`,
    as we'll see in a later paragraph.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: groupby – grouping your sorted iterable
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `groupby` function is a really convenient function for grouping results.
    The usage and use cases are probably clear, but there are some important things
    to keep in mind when using this function:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: The input needs to be sorted by the `group` parameter. Otherwise, it will be
    added as a separate group.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The results are available for use only once. So, after processing a group, it
    will not be available anymore.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of the proper use of `groupby`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And then there are cases where you might get unexpected results:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now we see two groups containing `a`. So, make sure you sort by the grouping
    parameter before trying to group. Additionally, walking through the same group
    a second time offers no results. This can be fixed easily using `groups[group]
    = list(items)` instead, but it can give quite a few unexpected bugs if you are
    not aware of this.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: islice – slicing any iterable
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with the `itertools` functions, you might notice that you cannot
    slice these objects. That is because they are generators, a topic that we will
    discuss in [Chapter 6](ch06.html "Chapter 6. Generators and Coroutines – Infinity,
    One Step at a Time"), *Generators and Coroutines – Infinity, One Step at a Time*.
    Luckily, the `itertools` library has a function for slicing these objects as well—`islice`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take `itertools.counter` from before as an example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'So, instead of the regular `slice`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We enter the `slice` parameters to the function:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: What you should note from this is actually more than the inability to slice
    the objects. It is not just that slicing doesn't work, but it is not possible
    to get the length either—at least not without counting all items separately—and
    with infinite iterators, even that is not possible. The only understanding you
    actually get from a generator is that you can fetch items one at a time. You won't
    even know in advance whether you're at the end of the generator or not.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For some reason, functional programming is a paradigm that scares many people,
    but really it shouldn't. The most important difference between functional and
    procedural programming (within Python) is the mindset. Everything is executed
    using simple (and often translations of the mathematical equivalent) functions
    without any storage of variables. Simply put, a functional program consists of
    many functions having a simple input and output, without using (or even having)
    any outside scope or context to access. Python is not a purely functional language,
    so it is easy to cheat and work outside of the local scope, but that is not recommended.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covered the basics of functional programming within Python and
    some of the mathematics behind it. In addition to this, some of the many useful
    libraries that can be used in a very convenient way by using functional programming
    were covered.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important outtakes should be the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Lambda statements are not inherently bad but it would be best to make them use
    variables from the local scope only, and they should not be longer than a single
    line.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional programming can be very powerful, but it has a tendency to quickly
    become unreadable. Care must be taken.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list/dict/set` comprehensions are very useful, but they should generally not
    be nested, and for the purpose of readability, they should be kept short as well.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ultimately, it is a matter of preference. For the sake of readability, I recommend
    limiting the usage of the functional paradigm when there is no obvious benefit.
    Having said that, when executed correctly, it can be a thing of beauty.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这是一个偏好的问题。为了可读性，我建议在没有明显好处时限制使用功能范式。话虽如此，当正确执行时，它可以成为一种美丽的事物。
- en: Next up are decorators—methods to wrap your functions and classes in other functions
    and/or classes to modify their behavior and extend their functionality.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是装饰器——用来包装您的函数和类的方法，以修改它们的行为并扩展它们的功能。
