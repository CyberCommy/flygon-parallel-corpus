- en: Writing Clean Functions
  prefs: []
  type: TYPE_NORMAL
- en: Clean functions are methods that are small (they have two or fewer arguments)
    and avoid duplication. The ideal method has no parameters and does not modify
    the program's state. Small methods are less prone to exceptions, so you will be
    writing much more robust code that benefits you in the long run as you will have
    fewer bugs to fix.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming is a software coding methodology that treats computations
    as the mathematical evaluation of computations. This chapter will teach you the
    benefits of treating computations as the evaluation of mathematical functions
    in order to void changing an object's state.
  prefs: []
  type: TYPE_NORMAL
- en: Large methods (also known as functions) can be unwieldy to read and prone to
    errors, so writing small methods has its advantages. Hence, we will look at how
    large methods can be broken up into smaller methods. In this chapter, we will
    cover functional programming in C# and how to write small, clean methods.
  prefs: []
  type: TYPE_NORMAL
- en: Constructors and methods with multiple parameters can become a real pain to
    work with, so we will have to look for ways to work around and pass multiple parameters,
    as well as how to avoid using more than two parameters. The main reason for reducing
    the number of parameters we have is that they can become hard to read, be a source
    of irritation to fellow programmers, and cause visual stress if there are enough
    of them. They can also be a sign that the method is trying to do too much, or
    that you need to consider refactoring your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding functional programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping methods small
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding duplication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding multiple parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By the time you have worked through this chapter, you will have the skills
    to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Describe what functional programming is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide existing examples of functional programming in the C# programming language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write functional C# code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid writing methods with more than two arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write immutable data objects and structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep your methods small
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write code that adheres to the **Single Responsibility Principle** (**SRP**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Understanding functional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The only thing that sets functional programming aside from other methods of
    programming is that functions do not modify data or state. You will use functional
    programming in scenarios such as deep learning, machine learning, and artificial
    intelligence when it is necessary to perform different sets of operations on the
    same set of data.
  prefs: []
  type: TYPE_NORMAL
- en: The *LINQ syntax* within .NET Framework is an example of functional programming.
    So, if you are wondering what functional programming looks like, and if you have
    used LINQ before, then you have been subjected to functional programming and should
    know what it looks like.
  prefs: []
  type: TYPE_NORMAL
- en: Since functional programming is a deep subject and many books, courses, and
    videos exist on this topic, we will only touch on the topic briefly in this chapter
    by looking at pure functions and immutable data.
  prefs: []
  type: TYPE_NORMAL
- en: A pure function is restricted to only operating on the data that is passed into
    it. As a result, the method is predictable and avoids producing side effects.
    This benefits programmers because such methods are easier to reason about and
    test.
  prefs: []
  type: TYPE_NORMAL
- en: Once an immutable data object or data structure has been initialized, the contained
    data values will not be modified. Because the data is only set and not modified,
    you can easily reason about what the data is, how it is set, and what the outcome
    of any operation will be, given the inputs. Immutable data is also easier to test
    as you know what your inputs are and what outputs are expected. This makes writing
    test cases much easier as you don't have so many things to consider, such as object
    state. The benefit of immutable objects and structures is that they are thread-safe.
    Thread-safe objects and structures make for good **data transfer objects** (**DTOs**)
    that can be passed between threads.
  prefs: []
  type: TYPE_NORMAL
- en: But structs can still be mutable if they contain reference types. One way around
    this would be to make the reference type immutable. C# 7.2 added support for `readonly
    struct` and `ImmutableStruct`. So, even if our structures contain reference types,
    we can now use these new C# 7.2 constructs to make structures with reference types
    immutable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s have a look at a pure function example. The only way to set the
    properties of an object is via the constructor at construction time. The class
    is a `Player` class whose only job is to hold the name of the player and their
    high score. A method is provided that updates the player''s high score:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `UpdateHighScore` method does not update the `HighScore` property.
    Instead, it instantiates and returns a new `Player` class by passing in the `PlayerName` variable,
    which is already set in the class, and `highScore`, which is the method parameter.
    You have now seen a very simple example of how to program your software without
    changing its state.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming is a very large subject and requires a mind shift that
    can be very difficult for both procedural and object-oriented programmers. Since
    it is outside the scope of this book (to delve deep into the topic of functional
    programming), you are actively encouraged to peruse the functional programming
    resources on offer from PacktPub for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Packt has some very good books and videos that specialize in teaching the top
    tiers of functional programming. You will find links to some Packt functional
    programming resources at the end of this chapter, in the *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on, we will look at some LINQ examples since LINQ is an example
    of functional programming in C#. It will be good to have an example dataset. The
    following code builds a list of vendors and products. We''ll start by writing
    the `Product` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our struct, we will add some sample data inside the `GetProducts()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can start to use LINQ on our list. In the preceding example, we
    will get a distinct list of products, ordered by the vendor''s names, and print
    out the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, we obtain a list of vendors by calling `GetProducts()` and selecting only
    the `Vendor` column. Then, we filter the list so that it only includes a vendor
    once by calling the `Distinct()` method. The list of vendors is then ordered alphabetically
    by calling `OrderBy(x => x)`, where `x` is the vendor's name. Upon obtaining the
    ordered list of distinct vendors, we then loop through the list and print the
    vendor's name. Finally, we wait for the user to press any key to exit the program.
  prefs: []
  type: TYPE_NORMAL
- en: One of the benefits of functional programming is that your methods are much
    smaller than the methods in other types of programming. Next, we will take a look
    at why it is good to keep methods small, as well as the techniques we can use,
    including functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping methods small
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While programming clean and readable code, it is important to keep the methods
    small. Preferably, in the C# world, it is best to keep methods *under 10 lines*
    long. The perfect length is no more than *4 lines*. A good way to keep methods
    small is to consider if you should be trapping for errors or bubbling them further
    up the call stack. With defensive programming, you can become a little too defensive,
    and this can add to the amount of code you find yourself writing. Besides, methods
    that trap errors will be longer than methods that don't.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following code, which can throw an `ArgumentNullException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we can clearly see that there are two locations where
    an `ArgumentNullException` may be raised. The first line of code to potentially
    raise an `ArgumentNullException` is `nameTextBox.Text = _dataItem.Name;`; the
    second line of code that may potentially raise the same exception is `DescriptionTextBox.Text
    = _dataItem.Description;`. We can see that the exception handler catches the exception
    when it occurs, writes it to the console, and then simply throws it back up the
    stack.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that, from a human reading perspective, there are *8 lines* of code that
    form the `try/catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: You can completely replace the `try/catch` exception handling with a single
    line of text by writing your own argument validator. To explain this, we will
    provide an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by looking at the `ArgumentValidator` class. The purpose of this
    class is to throw an `ArgumentNullException` with the name of the method that
    contains the null argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our null validation class, we can perform the new way of validating
    parameters for null values in our methods. So, let''s look at a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can clearly see, we have replaced the whole of the `try catch` block
    with a one-liner at the top of the method. When this validation detects a null
    argument, an `ArgumentNullException` is thrown, preventing the code from continuing.
    This makes the code much easier to read, and also helps with debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we'll look at formatting functions with indentation so that they are easy
    to read.
  prefs: []
  type: TYPE_NORMAL
- en: Indenting code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A very long method is hard to read and follow at the best of times, especially
    when you have to scroll through the method many times to get to the bottom of
    it. But having to do that with methods that are not properly formatted with the
    correct levels of indentation can be a real nightmare.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you ever encounter any method code that is poorly formatted, then make it
    your own responsibility, as a professional coder, to tidy the code up before you
    do anything else. Any code between braces is known as a **code block**. Code within
    a code block should be indented by one level. Code blocks within code blocks should
    also be indented by one level, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example demonstrates bad indentation and also bad loop programming.
    Here, you can see that a list of students is being searched in order to find and
    return a student with the specified ID that was passed in as a parameter. What
    annoys some programmers and reduces the performance of the application is that
    the loop in the preceding code continues, even when the student has been found.
    We can improve the indentation and the performance of the preceding code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have improved the formatting and made sure that the
    code is properly indented. We've added a `break` to the `for` loop so that the
    `foreach` loop is terminated when a match is found.
  prefs: []
  type: TYPE_NORMAL
- en: Not only is the code now more readable, but it also performs much better. Imagine
    that the code is being run against a university with 73,000 students on campus
    and via distance learning. Consider that if the student matches the ID is the
    first in the list, then without the `break` statement, the code would have to
    run 72,999 unnecessary computations. You can see how much of a difference the
    `break` statement makes to the performance of the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: We have left the return value in its original location as the compiler can complain
    that not all code paths return a value. This is also why we added the `break`
    statement. It is clear that proper indentation improves the readability of the
    code, thus aiding the programmer's understanding of it. This enables the programmer
    to make any changes that they deem necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding duplication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code can be either **DRY** or **WET**. WET code stands for **Write Every Time** and
    is the opposite of DRY, which stands for **Don't Repeat Yourself**. The problem
    with WET code is that it is the perfect candidate for *bugs*. Let's say your test
    team or a customer finds a bug and reports it to you. You fix the bug and pass
    it on, only for it to come back and bite you as many times as that code is encountered
    within your computer program.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we DRY our WET code by removing duplication. One way we can do this is
    by extracting the code and putting it into a method and then centralizing the
    method in such a way that it is accessible to all the areas of the computer program
    that need it.
  prefs: []
  type: TYPE_NORMAL
- en: Time for an example. Imagine that you have a collection of expense items that
    consist of `Name` and `Amount` properties. Now, consider having to get the decimal
    `Amount` for an expense item by `Name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say you had to do this 100 times. For this, you could write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no reason why you can''t write that same code 100 times. But there
    is a way to write it only once, thus reducing the size of your codebase and making
    you more productive. Let''s have a look at how we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To extract the required value from the `ExpenseLines` collection within your
    `ViewModel`, all you have to do is pass the name of the value you require into
    the `GetValueName(string name)` method, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: That one line of code is very readable, and the lines of code to get the value
    are contained in a single method. So, if the method needs to be changed for whatever
    reason (such as a bug fix), you only have to modify the code in one place.
  prefs: []
  type: TYPE_NORMAL
- en: The next logical step to writing good functions is to have as few parameters
    as possible. In the next section, we'll look at why we should have no more than
    two parameters, as well as how to work with just parameters, even if we need plenty
    more.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding multiple parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Niladic methods are the ideal type of methods in C#. Such methods have no parameters
    (also known as *arguments*). Monadic methods only have one parameter. Dyadic methods
    have two parameters. Triadic methods have three parameters. Methods that have
    more than three parameters are known as polyadic methods. You should aim to keep
    the number of parameters to a minimum (preferably less than three).
  prefs: []
  type: TYPE_NORMAL
- en: In the ideal world of C# programming, you should do your best to avoid triadic
    and polyadic methods. The reason for this is not because it is bad programming,
    but because it makes your code easier to read and understand. Methods with lots
    of parameters can cause visual stress to programmers, and can also be a source
    of irritation. IntelliSense can also be difficult to read and understand as you
    add more parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a bad example of a polyadic method that updates a user''s account
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown by the `UpdateUserInfo` method, the code is horrible to read. How
    can we modify the method so that it transforms from a polyadic method into a monadic
    method? The answer is simple – we pass in a `UserInfo` object. First of all, before
    we modify the method, let''s take a look at our `UserInfo` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have a class that contains all the information we need to pass into
    the `UpdateUserInfo` method. The `UpdateUserInfo` method can now be transformed
    from a polyadic method into a monadic method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How much better does the preceding code look? It is smaller and much more readable.
    The rule of thumb should be to have less than three parameters, and ideally none.
    If your class is obeying the SRP, then consider implementing the *parameter object
    pattern*, as we have done here.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing SRP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All objects and methods that you write should, at most, have one responsibility
    and no more. Objects can have multiple methods, but those methods, when combined,
    should all work toward the single purpose of the object they belong to. Methods
    can call multiple methods, where each does different things. But the method itself
    should only do one thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'A method that knows and does far too much is known as a **God method**. And
    likewise, an object that knows and does too much is known as a **God object**.
    God objects and methods are hard to read, maintain, and debug. Such objects and
    methods can often have the same bug repeated many times. People who are good at
    the programming craft will avoid God objects and God methods. Let''s look at a
    method that is doing more than one thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`SrpBrokenMethod` is clearly doing more than one thing, so it breaks the SRP.
    We will now break this method down into a number of smaller methods that only
    do one thing. We will also address the issue of the polyadic nature of the method
    in that it has more than two parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we begin to break down the method into smaller methods that do only
    one thing, we need to look at all the actions that the method is performing. The
    method starts by writing text to a file. It then creates an email message, assigns
    an attachment, and finally sends the email. So, for this, we need methods for
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Write text to file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an email message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add an email attachment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send email
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Looking at the current method, we have four parameters that are passed into
    it for writing text to a file: one for the folder, one for the filename, one for
    the text, and one for the media type. The folder and filename can be combined
    into a single parameter called `filename`. If `filename` and `folder` are two
    separate variables that are used inside the calling code, then they can be passed
    into the method as a single interpolated string, such as `$"{folder}{filename}"`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As for the media type, this could be privately set inside a struct during construction
    time. We could use that struct to set the properties we need so that we can pass
    the struct in with the three properties as a single parameter. Let''s look at
    the code that accomplishes this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `TextFileData` constructor ensures that the `FileName` value is unique
    by calling the `GetFileTimestamp()` method and appending it to the end of `FileName`.
    To save the text file, we call the `SaveTextFile()` method. Notice that `MimeType`
    is set internally and is set to `MimeType.TextPlain`. We could have simply hardcoded
    `MimeType` as `MimeType = "text/plain";`, but the advantage of using an `enum`
    is that the code is reusable, with the added benefit of you not having to remember
    the text for a specific `MimeType` or look it up on the internet. Now, we''ll
    code `enum` and add a description to the `enum` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, we''ve got our `enum`, but now we need a way to extract the description
    so that it can be easily assigned to a variable. Therefore, we will create an
    extension class that will enable us to get the description of an `enum`. This
    enables us to set `MimeType`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Without the extension method, the value of `MimeType` would be `0`. But with
    the extension method, the value of `MimeType` is `"text/plain"`. You can now reuse
    this extension in other projects and build it up as you require.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next class we will write is the `Smtp` class, whose responsibility is to
    send an email via the `Smtp` protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `Smtp` class has a constructor that takes a single parameter of the `Credential` type.
    This credential is used to log into the email server. The server is configured
    in the constructor. When the `SendMessage(MailMessage mailMessage)` method is
    called, the message is sent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a `DemoWorker` class that splits the work into different methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `DemoWorker`  class shows a much cleaner version of sending an email message.
    The main method responsible for saving an attachment and sending it as an attachment
    via email is called `DoWork()`. This method only contains two lines of code. The
    first line calls the `SaveTextFile()` method, while the second line calls the
    `SendEmail()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `SaveTextFile()` method creates a new `TextFileData` struct and passes in
    the filename and some text. It then calls the `SaveTextFile()` method in the `TextFileData`
    struct, which is responsible for saving the text to the file specified.
  prefs: []
  type: TYPE_NORMAL
- en: The `SendEmail()` method creates a new `Smtp` class. The `Smtp` class has a
    `Credential` parameter, while the `Credential` class has two string parameters
    for email address and password. The email and password are used to log into the
    SMTP server. Once the SMTP server has been created, the `SendMessage(MailMessage
    mailMessage)` method is called.
  prefs: []
  type: TYPE_NORMAL
- en: This method requires a `MailMessage` object to be passed in. So, we have a method
    called `GetMailMethod()` that builds a `MailMessage` object that is then passed
    into the `SendMessage(MailMessage mailMessage)` method. `GetMailMethod()` adds
    an attachment to `MailMessage` by calling the `GetAttachment()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from these modifications, our code is now more compact and readable.
    That is the key to good quality code that is easy to modify and maintain: it must
    be easy to read and understand. That is why it is important for your methods to
    be small and clean with as few parameters as possible.'
  prefs: []
  type: TYPE_NORMAL
- en: Does your method break the SRP? If it does, you should consider breaking the
    method up into as many methods as there are responsibilities. And that concludes
    this chapter on writing clean functions. It is now time to summarize what you
    have learned and test your knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have seen how functional programming can improve the safety
    of your code by not modifying the state, which can give rise to bugs, especially
    in multithreaded applications. By keeping methods small with meaningful names
    and no more than two parameters, you have seen how much cleaner your code is and
    easier to read. You have also seen how we can remove duplication in our code and
    the benefits of doing so. Code that is easy to read is easier to maintain and
    extend than code that is hard to read and decipher!
  prefs: []
  type: TYPE_NORMAL
- en: We will now move on and look at the topic of exception handling. In the next
    chapter, you will learn how to use exception handling appropriately, write your
    own custom C# exceptions that provide meaningful information, and write code that
    avoids raising `NullPointerExceptions`.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What do you call a method that has no parameters?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What do you call a method that has one parameter?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What do you call a method that has two parameters?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What do you call a method that has three parameters?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What do you call a method that has more than three parameters?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What two method types should be avoided and why?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In layman's terms, what is functional programming?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some advantages of functional programming?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name one disadvantage of functional programming.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is WET code, and why should it be avoided?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is DRY code, and why should you use it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you DRY out WET code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should methods be as small as possible?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you implement validation without having to implement `try/catch` blocks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some additional resources so that you can delve deeper into the realms
    of C# functional programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Functional C#* by Wisnu Anggoro: [https://www.packtpub.com/application-development/functional-c](https://www.packtpub.com/application-development/functional-c).
    This book is devoted to C# functional programming and is a good place to start
    if you want to know more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Functional Programming in C#* by Jovan Poppavic (MSFT): [https://www.codeproject.com/Articles/375166/Functional-programming-in-Csharp](https://www.codeproject.com/Articles/375166/Functional-programming-in-Csharp).
    This is an in-depth article on functional C# programming. It contains diagrams
    and has a 5-star rating.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
