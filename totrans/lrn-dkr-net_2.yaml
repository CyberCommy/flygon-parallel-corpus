- en: Chapter 2. Docker Networking Internals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter discusses the semantics and syntax of Docker networking in detail,
    exposing strengths and weaknesses of the current Docker network paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: 'It covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the IP stack for Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IPv4 support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Issues with IPv4 address management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IPv6 support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring DNS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DNS basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multicast DNS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the Docker bridge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overlay networks and underlay networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are they?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does Docker use them?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are some of their advantages?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the IP stack for Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker uses the IP stack to interact with the outside world using TCP or UDP.
    It supports the IPv4 and IPv6 addressing infrastructures, which are explained
    in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: IPv4 support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, Docker provides IPv4 addresses to each container, which are attached
    to the default `docker0` bridge. The IP address range can be specified while starting
    the Docker daemon using the `--fixed-cidr` flag, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We will discuss more about this in the *Configuring the Docker bridge* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Docker daemon can be listed on an IPv4 TCP endpoint in addition to a Unix
    socket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: IPv6 support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IPv4 and IPv6 can run together; this is called a **dual stack**. This dual stack
    support is enabled by running the Docker daemon with the `--ipv6` flag. Docker
    will set up the `docker0` bridge with the IPv6 link-local address `fe80::1`. All
    packets shared between containers flow through this bridge.
  prefs: []
  type: TYPE_NORMAL
- en: To assign globally routable IPv6 addresses to your containers, you have to specify
    an IPv6 subnet to pick the addresses from.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands set the IPv6 subnet via the `--fixed-cidr-v6` parameter
    while starting Docker and also add a new route to the routing table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure shows a Docker bridge configured with an IPv6 address
    range:'
  prefs: []
  type: TYPE_NORMAL
- en: '![IPv6 support](../images/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you check the IP address range using `ifconfig` inside a container, you
    will notice that the appropriate subnet has been assigned to the `eth0` interface,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: All the traffic to the `1553:ba3:2::/64` subnet will be routed via the `docker0`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding container is assigned using `fe80::42:acff:fe11:1/64` as the link-local
    address and `1553:ba3:2::242:ac11:1/64` as the global routable IPv6 address.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Link-local and loopback addresses have link-local scope, which means they are
    to be used in a directly attached network (link). All other addresses have global
    (or universal) scope, which means they are globally routable and can be used to
    connect to addresses with global scope anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a DNS server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker provides hostname and DNS configurations for each container without us
    having to build a custom image. It overlays the `/etc` folder inside the container
    with virtual files, in which it can write new information.
  prefs: []
  type: TYPE_NORMAL
- en: This can be seen by running the `mount` command inside the container. Containers
    receive the same `resolv.conf` file as that of the host machine when they are
    created initially. If a host's `resolv.conf` file is modified, this will be reflected
    in the container's `/resolv.conf` file only when the container is restarted.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Docker, you can set DNS options in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `docker run --dns=<ip-address>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding `DOCKER_OPTS="--dns ip-address"` to the Docker daemon file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also specify the search domain using `--dns-search=<DOMAIN>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows a **nameserver** being configured in a container
    using the `DOCKER_OPTS` setting in the Docker daemon file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring a DNS server](../images/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The main DNS files are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/etc/hostname`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/etc/resolv.conf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/etc/hosts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the command to add a DNS server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Add hostnames using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Communication between containers and external networks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Packets can only pass between containers if the `ip_forward` parameter is set
    to `1`. Usually, you will simply leave the Docker server at its default setting,
    `--ip-forward=true`, and Docker will set `ip_forward` to `1` for you when the
    server starts up.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check the settings or to turn IP forwarding on manually, use these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'By enabling `ip_forward`, users can make communication possible between containers
    and the external world; it will also be required for inter-container communication
    if you are in a multiple-bridge setup. The following figure shows how `ip_forward
    = false` forwards all the packets to/from the container from/to the external network:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Communication between containers and external networks](../images/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Docker will not delete or modify any pre-existing rules from the Docker filter
    chain. This allows users to create rules to restrict access to containers.
  prefs: []
  type: TYPE_NORMAL
- en: Docker uses the `docker0` bridge for packet flow between all the containers
    on a single host. It adds a rule to forward the chain using IPTables in order
    for the packets to flow between two containers. Setting `--icc=false` will drop
    all the packets.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the Docker daemon is configured with both `--icc=false` and `--iptables=true`
    and `docker run` is invoked with the `--link` option, the Docker server will insert
    a pair of IPTables accept rules for new containers to connect to the ports exposed
    by the other containers, which will be the ports that have been mentioned in the
    exposed lines of its Dockerfile. The following figure shows how `ip_forward =
    false` drops all the packets to/from the container from/to the external network:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Communication between containers and external networks](../images/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: By default, Docker's `forward` rule permits all external IPs. To allow only
    a specific IP or network to access the containers, insert a negated rule at the
    top of the Docker filter chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, using the following command, you can restrict external access
    such that only the source IP `10.10.10.10` can access the containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Restricting SSH access from one container to another
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Following these steps to restrict SSH access from one container to another:'
  prefs: []
  type: TYPE_NORMAL
- en: Create two containers, `c1` and `c2.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For `c1`, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output generated is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'For `c2`, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test connectivity between the containers using the IP address we''ve
    just discovered. Let''s see this now using the `ping` tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Install `openssh-server` on both the containers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Enable iptables on the host machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initially, you will be able to SSH from one container to another.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop the Docker service and add `DOCKER_OPTS="--icc=false --iptables=true"`
    to the default Dockerfile of the host machine. This option will enable the iptables
    firewall and drop all ports between the containers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By default, `iptables` is not enabled on the host. Use the following command
    to enable it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Docker Upstart and SysVinit configuration file. Customize the location of the
    Docker binary (especially for development testing):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `DOCKER_OPTS` to modify the daemon''s startup options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Restart the Docker service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Inspect `iptables`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `DROP` rule has been added to iptables on the host machine, which drops
    a connection between containers. Now you will be unable to SSH between the containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can communicate with or connect containers using the `--link` parameter,
    with the help of following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the first container, which will act as the server, `sshserver`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the `iptables` command, and you will find a Docker chain rule added:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the second container, which acts like a client, `sshclient`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that there are more rules added to the Docker chain rule:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image explains communication between the containers using the
    `--link` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Restricting SSH access from one container to another](../images/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can inspect your linked container with the `docker inspect` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now you can successfully ssh into sshserver with its IP.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Using the `--link` parameter, Docker creates a secure channel between the containers
    that doesn't need to expose any ports externally on the containers.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Docker bridge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Docker server creates a bridge called `docker0` by default inside the Linux
    kernel, and it can pass packets back and forth between other physical or virtual
    network interfaces so that they behave as a single Ethernet network . Run the
    following command to find out the list of interfaces in a VM and the IP addresses
    they are connected to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Once you have one or more containers up and running, you can confirm that Docker
    has properly connected them to the `docker0` bridge by running the `brctl` command
    on the host machine and looking at the `interfaces` column of the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before configuring the `docker0` bridge, install the bridge utilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a host with two different containers connected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Docker uses the `docker0` bridge settings whenever a container is created.
    It assigns a new IP address from the range available on the bridge whenever a
    new container is created, as can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: By default, Docker provides a virtual network called `docker0`, which has the
    IP address `172.17.42.1`. Docker containers have IP addresses in the range of
    `172.17.0.0/16`.
  prefs: []
  type: TYPE_NORMAL
- en: To change the default settings in Docker, modify the file `/etc/default/docker`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changing the default bridge from `docker0` to `br0` can be done like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command displays the new bridge name and the IP address range
    of the Docker service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Overlay networks and underlay networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An overlay is a virtual network that is built on top of underlying network infrastructure
    (the underlay). The purpose is to implement a network service that is not available
    in the physical network.
  prefs: []
  type: TYPE_NORMAL
- en: Network overlay dramatically increases the number of virtual subnets that can
    be created on top of the physical network, which in turn supports multi-tenancy
    and virtualization.
  prefs: []
  type: TYPE_NORMAL
- en: Every container in Docker is assigned an IP address, which is used for communication
    with other containers. If a container has to communicate with the external network,
    you set up networking in the host system and expose or map the port from the container
    to the host machine. With this, applications running inside containers will not
    be able to advertise their external IP and ports, as the information will not
    be available to them.
  prefs: []
  type: TYPE_NORMAL
- en: The solution is to somehow assign unique IPs to each Docker container across
    all hosts and have some networking product that routes traffic between hosts.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different projects to deal with Docker networking, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Flannel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weave
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open vSwitch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Flannel provides a solution by giving each container an IP that can be used
    for container-to-container communication. Using packet encapsulation, it creates
    a virtual overlay network over the host network. By default, Flannel provides
    a `/24` subnet to hosts, from which the Docker daemon allocates IPs to containers.
    The following figure shows the communication between containers using Flannel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Overlay networks and underlay networks](../images/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Flannel runs an agent, **flanneld**, on each host and is responsible for allocating
    a subnet lease out of a preconfigured address space. Flannel uses etcd to store
    the network configuration, allocated subnets, and auxiliary data (such as the
    host's IP).
  prefs: []
  type: TYPE_NORMAL
- en: Flannel uses the universal TUN/TAP device and creates an overlay network using
    UDP to encapsulate IP packets. Subnet allocation is done with the help of etcd,
    which maintains the overlay subnet-to-host mappings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Weave creates a virtual network that connects Docker containers deployed across
    hosts/VMs and enables their automatic discovery. The following figure shows a
    Weave network:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Overlay networks and underlay networks](../images/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Weave can traverse firewalls and operate in partially connected networks. Traffic
    can be optionally encrypted, allowing hosts/VMs to be connected across an untrusted
    network.
  prefs: []
  type: TYPE_NORMAL
- en: Weave augments Docker's existing (single host) networking capabilities, such
    as the `docker0` bridge, so these can continue to be used by containers.
  prefs: []
  type: TYPE_NORMAL
- en: Open vSwitch is an open source OpenFlow-capable virtual switch that is typically
    used with hypervisors to interconnect virtual machines within a host and between
    different hosts across networks. Overlay networks need to create a virtual datapath
    using supported tunneling encapsulations, such as VXLAN and GRE.
  prefs: []
  type: TYPE_NORMAL
- en: The overlay datapath is provisioned between tunnel endpoints residing in the
    Docker host, which gives the appearance of all hosts within a given provider segment
    being directly connected to one another.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a new container comes online, the prefix is updated in the routing protocol,
    announcing its location via a tunnel endpoint. As the other Docker hosts receive
    the updates, the forwarding rule is installed into the OVS for the tunnel endpoint
    that the host resides on. When the host is de-provisioned, a similar process occurs
    and tunnel endpoint Docker hosts remove the forwarding entry for the de-provisioned
    container. The following figure shows the communication between containers running
    on multiple hosts through OVS-based VXLAN tunnels:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Overlay networks and underlay networks](../images/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed Docker's internal networking architecture. We
    learned about IPv4, IPv6, and DNS configuration in Docker. Later in the chapter,
    we covered the Docker bridge and communication between containers within a single
    host and in multiple hosts.
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed overlay tunneling and different methods that are implemented
    in Docker networking, such as OVS, Flannel, and Weave.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn hands-on Docker networking, clubbed with
    various frameworks.
  prefs: []
  type: TYPE_NORMAL
