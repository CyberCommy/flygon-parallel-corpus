- en: Adding Native Functionality - Part II
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Reacting to changes in application state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying and pasting content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authenticating via touch ID or fingerprint sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hiding application content when multitasking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Background processing on iOS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Background processing on Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing audio files on iOS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing audio files on Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will continue with more recipes that touch on different
    aspects of writing React Native apps that interact with native iOS and Android
    code. We will cover example apps that leverage built-in and community created
    modules. The recipes cover a range of topics, from rendering a basic button to
    creating a multithreaded process that does not block the main application thread.
  prefs: []
  type: TYPE_NORMAL
- en: Reacting to changes in application state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The average mobile device user has several apps that they use on a regular basis.
    Ideally, along with the other social media apps, games, media players, and more,
    users will also be using your React Native app. Any specific user may spend a
    short time in each application because he or she multitasks. What if we wanted
    to react to when the user leaves our app and re-enters? We could use this as a
    chance to sync data with the server, or to tell the user that we're happy to see
    them return, or to politely ask for a rating on the app store.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will cover the basics of reacting to changes in the state of the
    application, which is to say reacting to when the app is in the foreground (active),
    background, or inactive.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, let's create a new pure React Native app titled `AppStateApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fortunately, React Native provides support for listening to changes to the
    state of the app through the `AppState` module. Let''s begin building out the
    app by adding dependencies to the `App.js` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the recipe, we''re going to keep track of the previous state to see where
    the user came from. If it''s their first time entering the app, we will welcome
    them, and if they''re returning, we will welcome them back instead. To do so,
    we need to keep a reference to the previous and current app states. We''ll use
    instance variables `previousAppState` and `currentAppStates` instead of using
    state for this purpose, simply to avoid potential naming confusion. We''ll use `state` to
    hold the status message to the user, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When the component mounts, we''ll use the `AppState` component to add an event
    listener to the `change` event. Whenever the app''s state changes (for example,
    when the app is backgrounded), the `change` event will be fired, whereupon we''ll
    fire our `handleAppStateChange` handler, defined in the next step, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `handleAppStateChange` method will receive the `appState` as a parameter,
    which we can expect to be one of three strings: `inactive` if the app is unloaded
    from memory, `background` if the app is in memory and backgrounded, and `active` if
    the app is foregrounded. We''ll use a `switch` statement to update the `statusMessage` on `state` accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `render` method is very basic in this recipe, since it only needs to display
    the status message to the user, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The styles for this app are basic, adding font size, color, and margin, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The completed app should now display the appropriate status message depending
    on the state of the app on a given device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we made use of the built-in `AppState` module. The module listens
    to the `Activity` events on Android, and on iOS it uses `NSNotificationCenter` to
    register a listener on various `UIApplication` events. Note that both platforms
    support the `active` and `background` states; however, the `inactive` state is
    an iOS only concept. Android does not explicitly support the `inactive` state
    due to its multitasking implementation, so only toggles apps between `background` and `active` states.
    To achieve the equivalent of the iOS inactive state on Android, see the *Hiding
    application content w**hen multitasking *recipe later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Copying and pasting content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most used features in both desktop and mobile operating systems is
    the clipboard for copying and pasting content. A common scenario on mobile is
    filling forms with lengthy text, such as long email addresses or passwords. Instead
    of typing it with a few typos, it would be easier to just open your contacts application
    and copy the email from there and paste it into your `TextInput` field.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show a basic example on both Android and iOS of how we can
    copy and paste text inside our React Native application. In our sample app, we
    will have both a static `Text` view and a `TextInput` field that you can use to
    copy its contents to the clipboard. Also, there will be a button that outputs
    the contents of the clipboard to the view.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we'll create a pure React Native application titled `CopyPasteApp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will be using `react-native-button` again. Install it with
    `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can use `yarn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start off by creating a `ClipboardText` component that both uses a `Text` component
    to display text and provides the ability to copy its contents to the clipboard
    via long press. Let''s create a `component` folder in the root of the project,
    and a `ClipboardText.js` file inside of it. We''ll start by importing dependencies,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we''ll define the `App` class and the initial `state`. We will use the `clipboardContent` property
    on `state` for storing text being pasted from the clipboard into the UI, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The UI will have one `Text` component whose text will by copyable via long
    press. Let''s define the `copyToClipboard` method. We''ll grab the input via its `ref` (which
    we''ll define later), and access the component''s text via its `props.children` property.
    Once the text has been stored in a local variable, we simply pass it to the `setString` method
    of `Clipboard` to copy the text to the clipboard, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we''ll also need a method that will paste text into the app''s UI
    from the clipboard. This method will use the  `getString` method of `Clipboard`,
    and save the returned string to the  `clipboardContent` property of `state`, re-rendering
    the app''s UI to reflect the pasted text, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `render` method will be made up of two sections: the first is made of things
    to copy, and the second is a way for pasting text from the clipboard into the
    UI. Let''s start with the first section, which consists of a `Text` input whose `onLongPress` prop
    is wired to the `copyToClipboard` method we created in *step 3*, and a text input
    for normal native copy/pasting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The second portion of the UI consists of a `Text` component for displaying
    the current value saved in `clipboardContent` on `state`, and a button that will
    paste from the clipboard using the `getClipboardContent` method we defined in
    *step 4*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The final app should look similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/77ae1f65-21d0-463c-8387-4dea842f92ce.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we built a simple copy and paste application by using the `Clipboard` API
    provided by React Native. The `Clipboard` module currently only supports content
    of type `String`, even though the devices can copy more complicated data. This
    module makes using the clipboard as easy as calling the methods `setString` and `getString`.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating via touch ID or fingerprint sensor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security is a paramount concern in software, especially when there is any sort
    of authentication. Breaches and leaked passwords have become a part of the daily
    news cycle, and companies of all sizes are wising up to the need for implementing
    added security measures in their apps. One such measure in mobile devices is biometric
    authentication, which uses fingerprint scanning or face recognition technology
    to provide supplementary identification methods.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe covers how to add fingerprint scanning and face recognition security.
    Thanks to the `react-native-touch-id` library, this process has been simplified
    and streamlined in React Native app development.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe we'll need a new pure React Native app. Let's call it `BiometricAuth`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll be using the `react-native-button` and `react-native-touch-id` libraries.
    Install them with `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can use `yarn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, `react-native-touch-id` will need to be linked, so be sure
    to follow up with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Permissions will also need to be adjusted manually. For Android permissions,
    locate the `AndroidManifest.xml` file in the project, which should be at `BiometricAuth/android/app/src/main/AndroidManifest.xml`.
    Along with the other permissions in this file, you''ll need to add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'For iOS permissions, you''ll need to update the `Info.plist` file in a text
    editor. The `Info.plist` can be found at `BiometricAuth/ios/BiometricAuth/Info.plist`.
    Along with all the other entries, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by adding dependencies to the `App.js` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we''ll define that `App` class and the initial `state`. We''ll keep track
    of the authentication status on the `authStatus` property of `state`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define the `authenticate` method, which will be fired on button press,
    and will initiate authentication on the device. We can initiate authentication
    by executing the `TouchID` component''s `authenticate` method. This method''s
    first parameter is an optional string explaining the reason for the request, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This method fires the `handleAuthSuccess` method on success. Let''s define
    it now. This method simply updates the `authStatus` property of `state` to the
    string `Authenticated`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, if authentication fails, the `handleAuthFailure` function will be
    called, which will update the same `state.authStatus` to the string `Not Authenticated`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `render` method will need a button to initiate the authentication request,
    and two `Text` components: one for a label, and one to display the authentication
    status, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ll add styles to color, size, and layout the UI, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe has illustrated how simple it is to incorporate native fingerprint
    and facial recognition security into a React Native app. The call to `TouchID.authenticate` also
    takes a second, optional options object parameter with three properties: `title` for
    the title of the confirmation dialog (Android only), `color` for the color of
    the dialog (Android only), and a `fallbackLabel`  for editing the default Show
    Password label (iOS only).
  prefs: []
  type: TYPE_NORMAL
- en: Hiding application content when multitasking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keeping the theme of application security going, we have to be wary sometimes
    of unwanted eyes and hands touching our devices and potentially getting access
    to our applications. In order to protect the user from prying eyes while looking
    at sensitive information, we can mask our application when the application is
    hidden, but still active. Once the user returns to the application, we would simply
    remove the mask and the user can continue using the app as normal. A good use
    case for this would be in a banking or password app that hides sensitive information
    when the app is not in the foreground.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show you how to render an image to mask your application and
    remove it once the application returns to the foreground or active state. We will
    cover both iOS and Android; however, the implementation varies in its entirety.
    For iOS, we employ a pure Objective-C implementation for optimal performance.
    For Android, we're going to have to make some modifications to the `MainActivity` in
    order to send an event to our JavaScript layer that the application has lost focus.
    We will handle the rendering of the image mask there.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re going to need an image handy to use as the mask when the app is not
    foregrounded. I chose to use an iPhone wallpaper, which you can find at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.hdiphone7wallpapers.com/2016/09/white-squares-iphone-7-and-7-plus-wallpapers.html](http://www.hdiphone7wallpapers.com/2016/09/white-squares-iphone-7-and-7-plus-wallpapers.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The image is a sort of stylized mosaic pattern. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a329bd35-49fe-44b3-bcc3-a6e257a9ed5a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can of course use whatever image you'd like. In this recipe, the image file
    will be named `hidden.jpg`, so rename your image accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: We'll need a new pure React Native app. Let's call it `HiddenContentApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's begin by adding the mask image to the iOS portion of the app. We'll need
    to open the `ios` folder of the project in Xcode, located in the `ios/` directory
    of the new React Native app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can add the `hidden.jpg` image to the project by dragging and dropping the
    image into the `Images.xcassets` folder of the project in Xcode, as shown in this
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/7a2e117f-9a1d-4c3f-952c-282f501c07f5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next we''ll add a new implementation and two methods to the `AppDelegate.m` file.
    The entirety of the file can be found as follows, including generated code. The
    code we''re adding is marked in bold for clarity. We''re extending the `applicationWillResignActive` method,
    which will fire whenever a given app changes from being foregrounded, to add an `imageView` with
    the `hidden.jpg` as its image. Similarly, we also need to extend the opposite
    method, `applicationDidBecomeActive`, to remove the image when the app is re-foregrounded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: With the previous three steps, all of the work required for displaying the mask
    in the iOS app is complete. Let's move on to the Android portion by opening the
    Android portion of the project in Android Studio. In Android Studio, select Open
    an existing Android Studio project and open the `android` directory of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The only native code we''ll need to update in the Android project lives in `MainActivity.java`,
    located here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/752fe834-c63d-4a90-8d38-b145c84a551a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ll need to add one method, as well as the three imports from React that
    the method uses. Again, the complete `MainActivity.java` file is below, with added
    code marked in bold. We''re defining an `onWindowFocusChanged` method that extends
    the base method''s functionality. The base `onWindowFocusChanged` Android method
    is fired whenever a given app''s focus has changed, passing with it a `hasFocus` Boolean
    representing whether the app has focus or not. Our extension will effectively
    pass that `hasFocus` Boolean from the parent method down to the React Native layer
    via an event we''re naming `focusChange`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: To use the  `hidden.jpg` mask image in Android, we'll need to also add it to
    the  React Native project. Let's create a new `assets` folder in the root of the
    React Native project, and add the `hidden.jpg` image file to the new folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the native pieces in place, we''re ready to turn to the JavaScript portion
    of the app. Let''s add the imports we''ll be using to `App.js`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s create the `App` class and the initial `state`. The `state` will
    only need a `showMask` Boolean, which will dictate if the mask should be displayed,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When the component mounts, we want to register an event listener to listen
    to events emitted from the native Android layer using the `DeviceEventEmitter`''s `addListener` method,
    passing the string `focusChange` as the name of the event to listen for as the
    first parameter, and a callback to execute as the second parameter. As you may
    recall, `focusChange` is the name we assigned the event in `MainActivity.java` in
    the `onWindowFocusChange` method in *step 5. *  Register the event listener as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In this step we will save the event listener to the class member `this.subscription`.
    This will allow for the event listener to be cleaned up once the component is
    unmounted. We achieve this by simply calling the `remove` method on `this.subscription`
    when the component unmounts, via the `componentWillUnmount` life cycle hook, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define the `onFocusChange` handler used in *step 9*. The method receives
    a `params` object with an `appHasFocus` Boolean that''s been passed from the native
    layer via the `onWindowFocusChanged` method defined in *step 5*. By setting the `showMask` Boolean
    on `state` to the inverse of the `appHasFocus` Boolean, we can use that in the `render` function
    to toggle displaying the `hidden.jpg` image, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `render` method''s main content is not important in this recipe, but we
    can use it to apply the `hidden.jpg` mask image when the `showMask` property on
    state is `true`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The app is complete. Once the app is loaded, you should be able to go to the
    app selection view (double pressing home on iOS, or the square button on Android)
    and see the mask image applied to the app when it is not foregrounded. Note that
    Android emulators may not properly apply the mask as expected, so this feature
    might require an Android device for testing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/c97ae150-6166-44ee-a686-c3758bc11c7f.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe we've seen an example of having to use two separate approaches
    for accomplishing the same task. For iOS, we handled displaying the image mask exclusively in
    the native layer, without any need for the React Native layer. For Android, we
    used React Native to handle the image masking.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 3* we extended two Objective-C methods: `applicationWillResignActive`,
    which fires when an app changes from being foregrounded, and `applicationDidBecomeActive`,
    which fires when the app is foregrounded. For each event, we simply toggle an `imageView` that
    displays the `hidden.jpg` image store in the `Images.xcassettes` folder in the
    Xcode project.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *step 5* we used the React class `RCTDeviceEventEmitter` from the `DeviceEventManagerModule` to
    emit an event named `focusChange`, passing along a `params` object with the `appHasFocus` boolean
    to the React Native layer, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In *step 9* we defined the `componentWillMount` life cycle hook, which sets
    up an event listener for this `focusChange` event that will be emitted from the
    native Android layer, firing the `onFocusChange` method, which will update the
    value of `state`'s `showMask` value based on the native `appHasFocus` value, triggering
    a rerender, displaying the mask as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Background processing on iOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the last several years, processing power in mobile devices has increased
    considerably. Users are demanding richer experiences and one method of achieving
    improved performance on modern mobile devices is via multithreading.  Most mobile
    devices today are powered by multicore processors, and their operating systems
    now offer developers easy abstractions for executing code in the background, without
    interfering with the performance of the app's UI.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will cover both the use of iOS's **Grand Central Dispatch** (**GCD**) to
    execute asynchronous background processing on a new thread, and communicating
    back to the React Native layer when the processing is complete.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we'll need a new pure React Native application. Let's name
    it `MultiThreadingApp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also be using the `react-native-button` library. Install it with `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can use `yarn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll start by opening the iOS Project in Xcode, located in the `ios` directory
    of the new React Native app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's add a new Cocoa class file named `BackgroundTaskManager` of subclass `NSObject`.
    Refer to the *Exposing Custom iOS Modules* recipe in this chapter for more details
    on doing this in Xcode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, lets wire the new module to the React `RCTBrideModule` in the new module''s
    header file, `BackgroundTaskManager.h`. The code to be added is marked in bold
    in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll implement the native module in the `BackgroundTaskManager.m` file. Again,
    the new code we''re adding is marked in bold in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s turn to the JavaScript layer next. We''ll start by adding dependencies
    to the `App.js` file. As part of the dependencies, we will also need to import
    the `BackgroundTaskManager` native module that we defined in *step 3* and *step
    4*, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define the `App` class, with an initial state of `backgroundTaskStatus`
    set to the string `Not Started`, and a `doNothingCount` property initialized to
    `0`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll need to listen to the `backgroundProcess` event that will be emitted
    from the native iOS layer from the custom module we created in *step 3* and *step
    4*. Let''s set up an event listener using the `NativeAppEventEmitter` React Native
    component, which sets the `backgroundTaskStatus` property of `state` to the value
    of `status` on the event object received from the native event, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'When the component unmounts, we need to remove the event listener from the
    previous step, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The UI will have two buttons that will each need a method to call when pressed.
    The `runBackgroundTask` will run the `loadInBackground` method that we defined
    and exported from the native iOS layer on the `BackgroundTaskManager` custom native
    module. The `increaseCounter` button will simply increase the `counter` property
    on `state` by `1`, serving to show how the main thread is not blocked, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The UI of the app will consist of two buttons to show the `Button` components,
    and a `Text` component for displaying the values saved on `state`. The Run Task button
    will execute the `runBackgroundTask` method to kick off a background process,
    and `this.state.backgroundTaskStatus` will update to display a new status for
    the process. For the five seconds that the background process is running, pressing
    the Increase Counter button will still increase the counter by `1`, demonstrating that
    the background process is non-blocking, as shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'As a final step, let''s layout and style the app with the styles block, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we created a native module similar to the module covered in
    the *Exposing custom iOS modules* recipe from earlier in this chapter. We defined
    the native module to perform arbitrary execution in the background of the React
    Native app. In this recipe the background process is made up of the following
    three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Spawn a new thread.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sleep for five seconds on the new thread.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the five second sleep (simulating the end of a running background process),
    an event is dispatched from the iOS layer to the React Native layer, letting it
    know that the process has been completed. This is accomplished via the OS's GCD
    API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The purpose of the UI in this app is to exhibit that multithreading has been
    achieved. If the background process was executed in the React Native layer, due
    to JavaScript's single-threaded nature, the app would have locked up for five
    seconds while that process was running. When you press a button, the bridge is
    invoked, whereupon messages can be posted to the native layer. If the native thread
    is currently busy sleeping, then we cannot process this message. By offloading
    that processing to a new thread, both can be executed at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Background processing on Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe we'll be building out an Android equivalent to the previous recipe.
    This recipe will also use the native Android layer to create a new process, keep
    that process running by sleeping for five seconds, and allow user interaction
    via the button to exhibit that the app's main processing thread is not blocked.
  prefs: []
  type: TYPE_NORMAL
- en: While the end result will be very much the same, spawning a new process in an
    Android project is handled a bit differently from iOS. This recipe will make use
    of the native `AsyncTask` function, specialized for handling short-running background
    processes, to allow execution in the React Native layer without blocking the main
    thread.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe we'll need to create a new pure React Native app. Let's name
    it `MultiThreadingApp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also be using the `react-native-button` library. Install it with `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can use `yarn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start by opening the Android project in Android Studio. In Android Studio,
    select Open an existing Android Studio project and open the `android` directory
    of the new project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ll need two new Java classes: `BackgroundTaskManager` and `BackgroundTaskPackage`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that both classes have been created, let''s open `BackgroundTaskManager.java` and
    begin implementing the native module that will wrap an `AsyncTask` operation,
    starting with imports and defining the class. Furthermore, like any other native
    Android module, we''ll need to define the `getName` method, used to provide React
    Native with a name for the module, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to execute an `AsyncTask`, it needs to be subclassed by a private
    class. We''ll need to add a new private inner `BackgroundLoadTask` subclass for
    this. Before we define it, let''s first add a `loadInBackground` method that will
    ultimately be exported to the React Native layer. This method simply creates a
    new instance of `BackgroundLoadTask` and calls its `execute` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BackgroundLoadTask` subclass will also be using a helper function for
    sending events back and forth across the React Native bridge to communicate the
    status of the background process. The `sendEvent` method takes an `eventName` and `params` as
    arguments, then uses React Native''s `RCTDeviceEventEmitter` class to `emit` the
    event, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s move on to defining the `BackgroundLoadTask` subclass, which extends `AsyncTask`.
    The subclass will be made up of three methods: `doInBackground` for spinning up
    a new thread and sleeping it for five minutes, `onProgressUpdate` for sending
    a `"Loading"` status to the React Native layer, and `onPostExecute` for sending
    a `"Done"` status when the background task has completed, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Since the only difference between the iOS implementation and the Android implementation
    lives in the native layer of the recipe, you can follow *step 5* to *step 11*
    of the previous recipe to implement the JavaScript portion of the app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final app should behave and look (aside from differences in devices) the
    same as the app in the previous recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/cbc6bfc5-4e0f-4d49-ae41-27748267819a.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we mimicked the functionality we created in the *Background
    processing on iOS* recipe on Android. We created an Android native module with
    a method which, when invoked, performs arbitrary execution in the background (sleep
    for five seconds). When the process is complete, it emits an event to the React
    Native layer, whereupon we update the app UI to reflect the status of the background
    process. Android has multiple options for performing multithreaded operations
    natively. In this recipe, we used `AsyncTask`, since it is geared towards short-running
    (several seconds) processes, it is relatively simple to implement, and the operating
    system manages thread creation and resource allocation for us. You can read more
    about `AsyncTask` in the official documentation at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.android.com/reference/android/os/AsyncTask](https://developer.android.com/reference/android/os/AsyncTask)'
  prefs: []
  type: TYPE_NORMAL
- en: Playing audio files on iOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the chapter *Implementing Complex User Interfaces – Part III*, we covered
    building out a relatively sophisticated little audio player in the *Creating an
    Audio Player* recipe using the `Audio` component provided by the Expo SDK. One
    of the shortcoming of Expo's `Audio` component, however, is that it cannot be
    used to play audio when the app is backgrounded. Using the native layer is currently
    the only way to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create a native module to show the iOS MediaPicker and
    then select a music file to play. The selected file will play through the native iOS
    media player, which allows audio to be played when the app is backgrounded, and
    allows the user to control the audio via the native iOS control center.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we'll need to create a new pure React Native app. Let's call
    it `AudioPlayerApp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also be using the `react-native-button` library, which can be installed
    with `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can use `yarn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This is a recipe that should only be expected to work on a real device. You'll
    also want to make sure you have music synced to the iOS device and available in
    the media library.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start by opening the iOS Project in Xcode located in the `ios` directory
    of the new React Native app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we'll create a new Objective-C Cocoa class called `MediaManager`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `MediaManager` header (`.h`) file, we need to import `MPMediaPickerController` and `MPMusicPlayerController`,
    along with the React Native bridge (`RCTBridgeModule`), as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we are going to need to work on adding the native `MediaPicker` in the `MediaManager` implementation
    (`MediaManager.m`). The first methods will be for showing and hiding the `MediaPicker`: `showMediaPicker` and `hideMediaPicker`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll implement the two actions that the `mediaPicker` needs: `didPickMediaItems` for
    picking a media item, and `mediaPickerDidCancel` for cancelling the action, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''re going to need to expose our `MediaManager` to the React Native
    bridge and create a method that will be invoked to show the `MediaPicker`, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re ready to move on to the JavaScript portion. Let''s start by adding dependencies
    to `App.js`. We also need to import the `MediaManager` native module we created
    in *step 3* to *step 6* using the `NativeModules` component, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define the `App` class and the initial `state`. The `currentSong` property
    will hold the track info for the currently playing song, as passed from the native
    layer, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'When the component mounts, we''ll subscribe to the `SongPlaying` event that
    will be emitted from the native layer when a song begins playing. We''ll save
    the event listener to a local `subscription` class variable so that we can clean
    it up with the `remove` method when the component unmounts, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also need a method for updating the `currentSong` value on `state`,
    and a method for calling the `showSongs` method on the native `MediaManager` module
    we defined in *step 3* to *step 6,* as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The `render` method will be made up of a `Button` component for executing the `showSongs` method
    when pressed, and `Text` components for displaying the info for the song that''s
    currently playing, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ll add our styles for laying out and styling the app, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe we covered how to use the Media Player in iOS by wrapping its
    functionality in a native module. The media player framework allows us to access
    the native iPod library, and play audio files from the library on the device using
    the same functionality as the native iOS Music app.
  prefs: []
  type: TYPE_NORMAL
- en: Playing audio files on Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A benefit that Google likes to claim that Android has over iOS is flexibility
    in dealing with file storage. Android devices support external SD cards that can
    be filled with media files and do not need a proprietary method of adding multimedia
    as iOS does.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use Android's native `MediaPicker`, which is started
    from an intent. We will then be able to pick a song and have it play through our
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we'll create a React Native application titled `AudioPlayer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will use the `react-native-button` library. To install it,
    run the following command in the terminal from your project root directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Make sure you have music files available in your `Music/` directory on your
    Android device or emulator.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start by opening the Android project using Android Studio. In Android
    Studio, select Open an existing Android Studio project and open the `android` directory
    of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll need two new Java classes for this recipe: `MediaManager` and `MediaPackage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our `MediaManager` will use intents to show the `mediaPicker`, `MediaPlayer` to
    play music, and `MediaMetadataRetriever` to parse metadata information from the
    audio file to send back to the JavaScript layer. Let''s start by importing all
    of the dependencies we''ll need in the `MediaManager.java` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '`showSongs`, `getName`, `playSong`, `mediaPlayer`, `onActivityResult`, `mediaMetadataRetreiver`,
    and `SongPlaying` should be in code formatting. Replace with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The custom module will also need to be added to the `getPackages` array in
    the `MainApplication.java` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'As covered in the *Exposing Custom Android Modules *recipe earlier in this
    chapter, we must add the requisite boilerplate to `MediaPackage.java` for our `MediaManager` custom
    module to be exported to the React Native layer. Refer to that recipe for a more
    thorough explanation. Add the requisite boilerplate as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The JavaScript layer for the Android app is identical to that found in the previous
    iOS recipe. Use *step 7* to *step 12* of this recipe to complete the final portion
    of the app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
