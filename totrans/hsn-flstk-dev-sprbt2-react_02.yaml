- en: Using JPA to Create and Access a Database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers how to use JPA with Spring Boot. We will create a database
    by using entity classes. In the first phase, we will be using the H2 in-memory
    database for development and demonstration purposes. H2 is an in-memory SQL database
    that is really good for fast development or demonstration purposes. In the second
    phase, we will move from H2 to use MariaDB. This chapter also describes the creation
    of CRUD repositories and a one-to-many connection between database tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Basics and benefits of using JPA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to define a database by using entity classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create Spring Boot backend with a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java SDK version 8 or higher is necessary for the usage of Spring Boot ([http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html)).
  prefs: []
  type: TYPE_NORMAL
- en: A MariaDB installation is necessary for the creation of the database application
    ([https://downloads.mariadb.org/](https://downloads.mariadb.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: Basics of ORM, JPA, and Hibernate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Object-Relational Mapping** (**ORM**) is a technique that allows you to fetch
    and manipulate from a database by using an object-oriented programming paradigm.
    ORM is really nice for programmers because it relies on object-oriented concepts,
    not on database structure. It also makes development much faster and reduces the
    amount of source code. ORM is mostly independent of the databases and developers
    don''t have to worry about vendor-specific SQL statements.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Java Persistent API** (**JPA**) provides object-relational mapping for Java
    developers. The JPA entity is a Java class that presents the structure of a database
    table. The fields of an entity class present the columns of the database tables.'
  prefs: []
  type: TYPE_NORMAL
- en: Hibernate is the most popular Java-based JPA implementation, and it is used
    in Spring Boot as a default. Hibernate is a mature product and it is widely used
    in large-scale applications.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the entity classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An entity class is a simple Java class that is annotated with JPA's  `@Entity`
    annotation. Entity classes use the standard JavaBean naming convention and have
    proper getter and setter methods. The class fields have private visibility.
  prefs: []
  type: TYPE_NORMAL
- en: JPA creates a database table called the name of the class when the application
    is initialized. If you want to use some other name for the database table, you
    can use the `@Table` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to use JPA and the H2 database, we have to add the following dependencies
    to the `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Following are the steps for creating entity classes:'
  prefs: []
  type: TYPE_NORMAL
- en: To create an entity class in Spring Boot, we will first create our own package
    for entities. The package should be created under the root package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Activate the root package in Eclipse Project Explorer and right-click to show
    a menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the menu, select New | Package. The following screenshot shows the creation
    of package for entity classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/db4abdaa-1fcf-4e52-928d-76b55ab1a1a6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We name our package `com.packt.cardatabase.domain`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1a9b38e4-f800-4008-b706-12f225121521.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we create our entity class. Activate a new entity package, right-click,
    and select New | Class from the menu. Because we are going to create a car database,
    the name of the entity class is `Car`. Type `Car` in the Name field and then press
    the Finish button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8fe3af1e-49e2-480e-8e33-ba06ffa7429e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Open the `Car` class file in the editor by double-clicking it in the project
    explorer. First, we have to annotate the class with the `@Entity` annotation.
    The `Entity` annotation is imported from the `javax.persistence` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can use the *Ctrl* + *Shift* + *O* shortcut in Eclipse IDE to import missing
    packages automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we add some fields to our class. The entity class fields are mapped to
    database table columns. The entity class must also contain a unique ID that is
    used as a primary key in the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The primary key is defined by using the `@Id` annotation. The `@GeneratedValue`
    annotation defines that the ID is automatically generated by the database. We
    can also define our key generation strategy. Type `AUTO` means that the JPA provider
    selects the best strategy for a particular database. You can also create a composite
    primary key by annotating multiple attributes with the `@Id` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The database columns are named according to class field naming by default.
    If you want to use some other naming convention, you can use the `@Column` annotation.
    With the `@Column` annotation, you can also define the column''s length and whether
    the column is nullable. The following code shows an example of using the `@Column`
    annotation. With this definition, the column''s name in the database is `desc`
    and the length of the column is `512` and it is not nullable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally we add getters, setters and constructors with attributes to the entity
    class. We don''t need an ID field in our constructor due to automatic ID generation.
    The source code of `Car` entity class constructors follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Eclipse provides the automatic addition of getters, setters and constructors.
    Activate your cursor inside the class and right-click. From the menu, select Source
    | Generate Getters and Setters... or Source | Generate Constructor using fields...
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the source code of `Car` entity class getters and setters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The table called `car` must be created in the database when we run the application.
    To ensure that, we will add one new property to the `application.properties` file.
    This enables the logging of SQL statements to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now see the table creation statements when running the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ea5f7d7-c3d8-45c4-a545-1fd6b27b0c94.png)'
  prefs: []
  type: TYPE_IMG
- en: 'H2 provides a web-based console that can be used to explore a database and
    execute SQL statements. To enable the console, we have to add the following lines
    to the `application.properties` file. The first setting enables the H2 console
    and the second setting defines the endpoint that we can use to access the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can access the H2 console by navigating to `localhost:8080/h2-console`
    with the web browser. Use `jdbc:h2:mem:testdb` as the JDBC URL and leave the Password
    field empty in the login window. Press the Connect button to log in to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54d517da-1a8d-4868-9a48-4853231caafe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now you can see our `car` table in the database. You may notice that the register
    number has an underscore between the words. That is due to the camel case naming
    of the attribute (`registerNumber`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f8de2f11-fdfe-4ca4-9128-acb7e19e414c.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating CRUD repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spring Boot Data JPA provides a `CrudRepository` interface for CRUD operations.
    It provides CRUD functionalities to our entity class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now create our repository in the `domain` package, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class called `CarRepository` in the `domain` package and modify
    the file according to the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Our `CarRepository` now extends the Spring Boot JPA `CrudRepository` interface.
    `<Car, Long>` type arguments define that this is the repository for the `Car`
    entity class and the type of the ID field is long.
  prefs: []
  type: TYPE_NORMAL
- en: '`CrudRepository` provides multiple CRUD methods that we can now start to use.
    The following table lists the most commonly used methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `long count()` | Returns the number of entities |'
  prefs: []
  type: TYPE_TB
- en: '| `Iterable<T> findAll()` | Returns all items of given type |'
  prefs: []
  type: TYPE_TB
- en: '| `Optional<T> findById(ID Id)` | Returns one item by id |'
  prefs: []
  type: TYPE_TB
- en: '| `void delete(T entity)` | Deletes an entity |'
  prefs: []
  type: TYPE_TB
- en: '| `void deleteAll()` | Deletes all entities of the repository |'
  prefs: []
  type: TYPE_TB
- en: '| `<S extends T> save(S entity)` | Saves an entity |'
  prefs: []
  type: TYPE_TB
- en: If the method returns only one item, the `Optional<T>` is returned instead of
    `T`. The `Optional` class gets introduced in Java 8 SE. `Optional` is a type of
    single value container that either has value or doesn't. By using `Optional`,
    we can prevent null pointer exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are ready to add some demonstration data to our H2 database. For that,
    we will use the Spring Boot `CommandLineRunner`. The `CommandLineRunner` interface
    allows us to execute additional code before the application has fully started.
    Therefore, it is a good point to add demo data to your database. `CommandLineRunner` 
    is located inside the main class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to inject our car repository into the main class into be able
    to save new car objects to the database. An `@Autowired` annotation is used to
    enable dependency injection. The dependency injection allows us to pass dependencies
    into a object. After we have injected the repository class, we can use the CRUD
    methods it provides. The following sample code shows how to insert a few cars
    to the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`Insert` statements can be seen in the Eclipse console after the application
    has been executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9eb6f592-c706-4423-9ac2-229f78df8ed1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also use the H2 console to fetch cars from the database, as seen in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/022a3422-30f9-449a-8c37-ec146b27ffc4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can define your own queries in the Spring Data repositories. The query
    must start with a prefix, for example, `findBy`. After the prefix, you define
    the entity class fields that are used in the query. The following is a sample
    code of three simple queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'There can be multiple fields after the `By` keyword, concatenated with the `And`
    or `Or` keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Queries can be sorted by using the `OrderBy` keyword in the query method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also create queries by using SQL statements, via the `@Query` annotation. 
    The following example shows the usage of a SQL query in `CrudRepository`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use also more advanced expressions with the `@Query` annotation, for
    example, `like`. The following example shows the usage of the `like` query in
    `CrudRepository`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Spring Data JPA also provides `PagingAndSortingRepository`, which extends `CrudRepository`.
    It offers methods for fetching entities using pagination and sorting.  This is
    a good option if you are dealing with larger amounts of data. `PagingAndSortingRepository`
    can be created similarly to what we did with `CrudRepository`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, you now have the two new additional methods that the repository
    provides:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Iterable<T> findAll(Sort sort)` | Returns all entities sorted by the given
    options  |'
  prefs: []
  type: TYPE_TB
- en: '| `Page<T> findAll(Pageable pageable)` | Returns all entities according to
    given paging options |'
  prefs: []
  type: TYPE_TB
- en: Relationships between tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we create a new table called `owner` that has a one-to-many relationship
    with the `car` table. The owner can own multiple cars, but a car can have only
    one owner. The following UML diagram shows the relationship between the tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/97ade669-bf1f-4f12-bdec-5fe34cf5d487.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following are the steps for creating a new table:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create the `Owner` entity and repository in the `domain` package.
    The `Owner` entity and repository are created similarly to what we did with the `Car` class.
    The following is the source code of the `Owner` entity class and `OwnerRepository`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In this phase, it is good to check that everything is done correctly. Run the
    project and check that both database tables are created and that there are no
    errors in the console. The following screenshot shows the console messages when
    tables are created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6f219664-b827-48a6-974a-789cac7ba8df.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, our domain package contains two entity classes and repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0aac2b0d-6e2e-447a-a717-9de4535894c4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The one-to-many relationship can be added by using the `@ManyToOne` and `@OneToMany`
    annotations. In the car entity class, which contains a foreign key, you will define
    the relationship with the `@ManyToOne` annotation. Also, add the getter and setter
    for the owner field. It is recommended using `FetchType.LAZY` for all associations.
    For `toMany` relationships, that is the default value, but for `toOne` relationships,
    you should define it. `FetchType` defines the strategy for fetching data from
    the database. The value can be either `EAGER` or `LAZY`. In our case, the lazy
    strategy means that when the owner is fetched from the database, all the cars
    associated with the owner will be fetched when needed. `Eager` means that the
    cars will be fetched immediately with the owner. The following source code shows
    how to define a one-to-many relationship in the `Car` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the owner entity site, the relationship is defined with the `@OneToMany`
    annotation. The type of the field is `List<Car>` because the owner may have multiple
    cars. Add also the getter and setter for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `@OneToMany` annotation has two attributes that we are using. The `cascade`
    attribute defines how cascading affects the entities. The attribute setting `ALL`
    means that if the owner is deleted, the cars linked to that owner are deleted
    as well. The `mappedBy="owner"` attribute setting tells us that the `Car` class
    has the owner field, which is the foreign key for this relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the project, you can see from the console that the relationship
    is now created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/65c81d66-5d5c-4226-97d8-3cc6cd3ec050.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we can add some owners to the database with `CommandLineRunner`. Let''s
    also modify the `Car` entity classes constructor and add an owner there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We first create two owner objects and save these to the database. For saving
    the owners, we also have to inject the `OwnerRepository` into the main class.
    Then we connect the owners to the cars by using the `Car` constructor. The following
    is the source code of the application main class `CardatabaseApplication`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If you now run the application and fetch cars from the database, you can see
    that the owners are now linked to the cars:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13e22a64-525c-4c56-8c71-1352688039b9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you want to create many-to-many relationship instead, which means, in practice,
    that an owner can have multiple cars and a car can have multiple owners, you should
    use the `@ManyToMany` annotation. In our example application, we will use a one-to-many
    relationship, but there follows an example of how to change the relationship to
    many-to-many. In a many-to-many relationship, it is recommended using `Set` instead
    of `List` with hibernate:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Car` entity class many-to-many relationship, define the getters and
    setters in the following way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the owner entity, the definition as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you run the application, there will be a new join table that is created
    between the `car` and `owner` tables. The join table is defined by using the `@JoinTable`
    annotation. With the annotation, we can set the name of the join table and join
    columns. The following is a screenshot of the database structure when using a
    many-to-many relationship:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/586b87e4-1b95-4af1-b41d-9e95b1440794.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting up the MariaDB database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we switch our database from H2 to MariaDB. The database tables are still
    created automatically by JPA. But before we run our application, we have to create
    a database for it. The database can be created by using HeidiSQL. Open HeidiSQL,
    and follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click your mouse inside the database list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, select New | Database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bc77682b-cdf2-4ded-87cc-11e37a6790d8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s name our database `cardb`. After you press OK, you should see the new
    `cardb` in the database list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a92e8240-513d-4ce7-bdfe-c4b20b8441be.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the application, we add a MariaDB dependency to the `pom.xml` file and remove
    the H2 dependency that we don''t need any more:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `application.properties` file, you define the database connection. First,
    you will define the database''s `url`, `username`, `password` and database driver
    class. The `spring.jpa.generate-ddl` setting defines whether JPA should initialize
    the database (`true`/`false`). The `spring.jpa.hibernate.ddl-auto` setting defines
    the behavior of the database initialization. The possible values are `none`, `validate`,
    `update`, `create`, and `create-drop`. Create-drop means that the database is
    created when an application starts and it is dropped when the application is stopped.
    Create-drop is also a default value if you don''t define any. Create value only
    creates the database when the application is started. Update value creates the
    database and updates the schema if it is changed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, after running the application, you should see the tables in MariaDB. The
    following screenshot shows the HeidiSQL UI after the database has been created.
    Your application is now ready to be used with MariaDB:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/13b4481b-9fd1-4995-9b3c-51bf2e2af457.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we used JPA to create our Spring Boot application database.
    First, we created entity classes, which are mapped to database tables. Then, we
    created `CrudRepository` for our entity class and that provides CRUD operations
    for the entity. After that, we managed to add some demo data to our database by
    using `CommandLineRunner`. We also created one-to-many relations between two entities.
    At the beginning of the chapter, we used the H2 in-memory database, while at the
    end, we switched the database to MariaDB. In the next chapter we will create RESTful
    web service to our backend.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are ORM, JPA, and Hibernate?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you create an entity class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you create `CrudRepository`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does the `CrudRepository` provide for your application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you create a one-to-many relationship between tables?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you add demo data to a database with Spring Boot?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you access the H2 console?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you connect your Spring Boot application to MariaDB?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Packt has other great resources for learning Spring Boot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/application-development/learning-spring-boot-20-second-edition](https://www.packtpub.com/application-development/learning-spring-boot-20-second-edition)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/web-development/spring-boot-getting-started-integrated-course](https://www.packtpub.com/web-development/spring-boot-getting-started-integrated-course)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
