- en: '*Chapter 10*: Setting Up an Express Project with TypeScript and GraphQL Dependencies'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the biggest hurdles for learning modern JavaScript programming is the
    enormous number of packages and dependencies available. It can be overwhelming
    and daunting trying to select the right set of packages for your project. In this
    chapter, we'll learn how to set up a well-configured TypeScript, Express, and
    GraphQL project. We'll see what dependencies are popular and how we can benefit
    by using them for our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a TypeScript-based Express project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding GraphQL and dependencies to a project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing ancillary packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should have a basic understanding of web development using Node, Express,
    and GraphQL. We will once again be using Node and Visual Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub repository is available at [https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node](https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node).
    Use the code in the `Chap10` folder.
  prefs: []
  type: TYPE_NORMAL
- en: To set up the `Chap10` code folder, go to your `HandsOnTypescript` folder and
    create a new folder called `Chap10`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a TypeScript-based Express project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll build a starting project that we will use to base our
    server on. We'll manually review and select each dependency and understand what
    role each will play in our application. When we're done, we will have a strong
    base for building out our server app.
  prefs: []
  type: TYPE_NORMAL
- en: There are many pre-made project templates that can be used to build Node projects.
    A common one for TypeScript users is the TypeScript-Node-Starter project from
    Microsoft. It has a good variety of useful dependencies. Unfortunately, it's geared
    toward MongoDB users, but our app will use Postgres.
  prefs: []
  type: TYPE_NORMAL
- en: Another project template, from the team that makes Express, is `express-generator`.
    It is a CLI that takes parameters and sets up a base project. However, this template
    generator is geared toward servers that do server-side HTML using template engines
    such as `pug` and `ejs`. This would be unnecessary for us since we are creating
    an API for an SPA application. In addition, it has no GraphQL packages to help
    us create our API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, in order to eliminate extraneous packages and as a learning exercise,
    let''s build out our project manually. This will allow us to see every piece that
    is needed to build out our app and understand what each one does. Follow the steps
    given here:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder in the `Chap10` folder and call it `node-server`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In your terminal, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we install TypeScript and initialize it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `tsconfig.json` file like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve already learned about the `tsconfig.json` file in [*Chapter 2*](B15508_02_Final_JC_ePub.xhtml#_idTextAnchor025)*,
    Exploring TypeScript*, but let''s review what we see here:'
  prefs: []
  type: TYPE_NORMAL
- en: We can target ES6 since we are running on our own server and can control the
    V8 version by using an appropriate version of Node.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are using `commonjs` as the `module` system to avoid issues with mixing `require`
    and `import` for modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want to use the latest JavaScript versions, so `lib` is set to allow them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `outDir` field represents the folder that transpiled `js` files will be
    saved into.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rootDir` represents the code source directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are allowing `emitDecoratorMetadata` and `experimentalDecorator` as `TypeORM`;
    the dependency for the repository layer that accesses our database will need to
    use them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `exclude` and `include` folders, as implied, represent folders we would
    like to either hide or make available to the TypeScript compiler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now let''s add some of our base dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We installed `jest` and its types for testing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `ts-jest` package allows us to write our tests in TypeScript.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I am showing `nodemon` for completeness, but we will be running the globally
    installed version that we installed in [*Chapter 8*](B15508_08_Final_JC_ePub.xhtml#_idTextAnchor122)*,
    Learning Server-Side Development with Node and Express*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`faker` is a fake data generator for testing and mocking.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ts-node-dev` will help our Node server to restart when any TypeScript code
    is changed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have our base dependencies installed, let''s start up our plain
    Express server to make sure everything is working:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll need to create a server setup script to initialize our server as we''ve
    done before in [*Chapter 8*](B15508_08_Final_JC_ePub.xhtml#_idTextAnchor122)*,
    Learning Server-Side Development with Node and Express*. Create a folder called
    `src` and then create another file called `index.ts` inside of it. Then, add this
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Basically, this is what we''ve done before: creating an `express` instance
    and then using it to create our server.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll need to create a `"start"` script inside of `package.json`. Open
    that file and find the `"scripts"` section. Then, under the existing `"test"`
    entry, add this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The command uses `ts-node-dev` to monitor when TypeScript changes occur and
    then `"respawn"`. This means it will automatically restart Node as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now if you type this command, your server should run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something like this once it is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – First server run'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.1_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.1 – First server run
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, our server started with our command and the emitted console
    log message.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you update the `index.ts` file by changing the log message, you''ll see
    that the server is auto-restarted, as this screenshot shows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Server restarted'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.2_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.2 – Server restarted
  prefs: []
  type: TYPE_NORMAL
- en: The server restarts and then our new message, `Our server is running great!`,
    is shown.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we started learning about important dependencies for our server.
    We will be using all of these packages as well as other packages to build our
    GraphQL API. In the next section, we'll add our GraphQL dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Adding GraphQL and dependencies to a project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already taken a look at GraphQL in [*Chapter 9*](B15508_09_Final_JC_ePub.xhtml#_idTextAnchor139)*,
    What is GraphQL?*. In this chapter, let's review these packages as well as introduce
    some new related packages that we will be using.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s list some of the GraphQL-related packages we will be using for our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '`graphql`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This package is the reference implementation for JavaScript of GraphQL. It is
    created by the GraphQL foundation and we will be using it to do some of our GraphQL
    query testing.
  prefs: []
  type: TYPE_NORMAL
- en: '`graphql-middleware`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a package that allows us to inject our code either before or after a
    resolver runs. Some possible actions include, but are not limited to, authentication
    checks and logging.
  prefs: []
  type: TYPE_NORMAL
- en: '`graphql-tools`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This package provides some helpers for testing and mocking our GraphQL queries
    when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '`apollo-server-express`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the main library we will use to create our Express GraphQL server, which
    we already used in [*Chapter 9*](B15508_09_Final_JC_ePub.xhtml#_idTextAnchor139)*,
    What is GraphQL?*.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the main packages we will use for our GraphQL implementation. Next,
    we will create a GraphQL server and also build some tests for it. In later chapters,
    we''ll merge the various packages we use here into a single project. Let''s look
    at the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create another folder inside our `Chap10` folder called `gql-server`. Then,
    `cd` into it from the terminal and run these commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Accept all defaults and then run this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Once that completes, run this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now initialize TypeScript with this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Once this is complete, copy the contents of the `tsconfig.json` file from our
    `node-server` project into the `tsconfig.json` file in this new `gql-server` project
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, in our `package.json` file, add a `start` entry to our `scripts` section
    like this:![Figure 10.3 – The start script
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_10.3_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.3 – The start script
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s create a new `src` folder in the root of our `gql-server` folder.
    Then copy these files from the `Chap9/graphql-schema` project and paste them into
    the `src` folder: `db.ts`, `GqlContext.ts`, `resolvers.ts`, `server.ts`, and `typeDefs.ts`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s test that our app will run by starting it up with this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s add some middleware and see how it runs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `Logger.ts` in the `src` folder and add this code
    to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we are intercepting any resolver calls and logging them before
    the `resolver` function runs. Notice that we check that the `parent` object is
    `null`, which indicates that the `resolver` call has not yet run. Let''s also
    add logging to our `getTodos` resolver. Open `resolvers.ts` and add this line
    at the start of the `getTodos` function body, just before the `return` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to update our `server.ts` file so that it makes use of this logger.
    Update `server.ts` like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we have imported the `applyMiddleware` function and the `log` middleware
    we created earlier. Note that this `applyMiddleware` function is coming from the
    `graphql-middleware` package and is distinct from the Apollo `applyMiddleware`
    function, which merely associates the Express instance with our Apollo server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here we have taken our schema that was created by `makeExecutableSchema` and
    used the `applyMiddleware` function to create a schema that has a middleware association.
    Then, we apply this schema, `schemaWithMiddleware`, to our Apollo server. The
    rest of the code is unchanged, so I won't include it here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start your server if you have not done so already and open your browser to
    the GraphQL server URL. If you run the call to `getTodos`, you will see the `todos`
    data come back as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Calling getTodos'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.4_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.4 – Calling getTodos
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, you should see in the Visual Studio Code terminal the `console.log`
    messages we set up earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – The getTodos result'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.5_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.5 – The getTodos result
  prefs: []
  type: TYPE_NORMAL
- en: Our middleware runs and does its log. Then, the actual resolver runs and returns
    the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we''ve now seen GraphQL middleware that allows us to intercept calls and
    inject our own code into the GraphQL process. Let''s now try to create some tests
    with GraphQL:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create a GraphQL query runner for testing purposes. Create a new
    file called `testGraphQLQuery.ts` and add this code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We import `graphql` and `GraphQLSchema` so that we can make manual queries and
    type schema files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Import `Maybe` as it is a GraphQL type indicating whether parameters may or
    may not be used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Create our `Options` interface, which will later act as the `testGraphQLQuery`
    function''s parameters type to run our query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The code `[key: string]` represents object property names – for example, `myObj["some
    name"]`. The `testGraphQLQuery` function is called with the required parameters
    and will return the relevant data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s write our test. Create a `getUser.test.ts` file and add this code
    to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The imports are pretty self-explanatory, but the `faker` import is used to help
    us create fake entries for the field values of our test objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'We set up our test using `describe` and then we create our query for `getUser`
    with the fields that we want:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in our test, we first create our `schema` from the merger of `typeDefs`
    and `resolvers` and then we set up our fake data fields for our mocked `User`
    object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As shown in [*Chapter 6*](B15508_06_Final_JC_ePub.xhtml#_idTextAnchor091)*,
    Setting Up Our Project Using create-react-app and Testing with Jest*, mocking
    allows us to focus on the unit of code we want to test without having to worry
    about other items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `addMockFunctionsToSchema`, we add our mocked `User` object to the schema
    so that it will be returned when relevant queries are made:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we run the `testGraphQLQuery` function to get back our mocked data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If the returned object has the same fields, it shows that the logic of querying
    the `getUser` query is working, since the call has gone through the entire code
    path to get our `User` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we run our test, we need to add a configuration to the `package.json`
    file for `jest`. Add this to the end of the configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This configuration makes certain that all files with `spec` or `test` in the
    name are tested (this is the `testRegex` section), and that any TypeScript files
    are first transpiled to JavaScript before running (this is the `transform` section).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the `jest` command on your terminal, you should see this result;
    make sure you are on the `gql-server` path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.6 – The GraphQL query test result'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.6_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.6 – The GraphQL query test result
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the test passes. I've added several `log` statements in order
    to show that the fields of the mocked `User` are the same. You should avoid this
    in your tests as it is difficult to read.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `package.json` file''s scripts section, you can replace the "test"
    entry with "test" : "jest". This way, it will be more consistent with other NPM
    scripts. As with any NPM script, you would run it with the `npm run test` command.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about some of the NPM packages available for GraphQL.
    These packages can help us build and test our servers, making them more reliable.
    In the next section, we'll look at some other packages that will help us build
    our servers.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing ancillary packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll review some of the ancillary dependencies of our project.
    Our server, at its heart, is Node, Express, and GraphQL, of course. But there
    are also many other activities our server will need to perform in order to be
    complete and fully functional.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s list some packages we will be using throughout our application that
    should allow us to write less code and focus more on our core business logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bcryptjs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every server will have some need to encrypt data for security purposes. An obvious
    example would be our users' passwords. Bcrypt is an industry-standard encryption
    algorithm that exists on numerous platforms, including C++ and Java. `bcryptjs`
    is a JavaScript implementation of the algorithm and will help us secure our application.
  prefs: []
  type: TYPE_NORMAL
- en: '`cors`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The web is full of security hazards and hackers attempting to break servers.
    Because of this, the standard behavior of any web server is to only allow client
    requests coming from the same domain as the server. For complex server setups,
    such as microservices and proxies, this would not be feasible. So, `cors` package
    provides tools for executing CORS on our server.
  prefs: []
  type: TYPE_NORMAL
- en: '`date-fns`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JavaScript Date object is notoriously cumbersome to deal with directly and
    `date-fns` provides lots of useful methods for parsing, formatting, and displaying
    dates and times.
  prefs: []
  type: TYPE_NORMAL
- en: '`dotenv`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every large application needs to store configuration information in a central
    place, both to manage and secure sensitive data and settings. Using `dotenv` will
    allow us to maintain our sensitive information settings without revealing it to
    end users.
  prefs: []
  type: TYPE_NORMAL
- en: '`nodemailer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nodemailer` allows us to send emails from within our Node server. We can send
    emails, for example, to allow users to reset their password or notify them of
    activity on the site.'
  prefs: []
  type: TYPE_NORMAL
- en: '`request`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This package will allow us to make HTTP requests from within our Node server.
    This can be useful, for example, when we need to grab data from another API, whether
    it be third-party or internal.
  prefs: []
  type: TYPE_NORMAL
- en: '`querystring`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`querystring` will allow us to easily create URL querystring parameters from
    objects and parse the body of POST requests into fields. This package can be used
    together with the `request` package.'
  prefs: []
  type: TYPE_NORMAL
- en: '`randomstring`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`randomstring` can be used to generate random temporary passwords.'
  prefs: []
  type: TYPE_NORMAL
- en: There are many more packages we will be using as we build out our application
    – for example, packages that allow us to connect to our Postgres database and
    to our Redis storage. However, I will introduce those packages in the relevant
    sections as it will be clearer what those packages do at that time.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about some of the miscellaneous packages we will
    be using in our project. Although these tools are not the main focus of our application,
    they are nonetheless extremely valuable. If we were to write these dependencies
    ourselves, we would have to become experts in various fields such as encryption
    and date time management, which would be a huge waste of time for us since it
    is not central to our goals.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about additional NPM package dependencies that we
    will use to build out our application. These tools are well used by the community
    and therefore well tested and reliable. Using packages from the Node ecosystem
    is one of the most valuable benefits of Node. It saves us from having to write,
    test, and maintain this extra code ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will review what we will be building in detail. We'll
    see what the various components of our application will be, and we'll start coding
    the React side of our application.
  prefs: []
  type: TYPE_NORMAL
