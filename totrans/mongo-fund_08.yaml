- en: 8\. Coding JavaScript in MongoDB
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8. 在MongoDB中编写JavaScript代码
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you will learn how to read, understand, and create simple MongoDB
    applications using the Node.js driver. These applications will help you to programmatically
    fetch, update, and create data in your MongoDB collections, as well as to handle
    errors and user inputs. By the end of this chapter, you will be able to create
    a simple application built on top of MongoDB.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用Node.js驱动程序阅读、理解和创建简单的MongoDB应用程序。这些应用程序将帮助您以编程方式获取、更新和创建MongoDB集合中的数据，以及处理错误和用户输入。在本章结束时，您将能够创建一个简单的基于MongoDB的应用程序。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: So far, we have interacted directly with the MongoDB database using the mongo
    shell. These direct interactions are quick, easy, and a fantastic way to learn
    or experiment with MongoDB features. However, in many production situations, it
    will be software that connects with the database in place of the user. MongoDB
    is a great place to store and query your data, but often, it's most essential
    use is to serve as a backend for large-scale applications. These applications
    write, read, and update data programmatically, usually after being triggered by
    some condition or user interface.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们直接使用mongo shell与MongoDB数据库进行了交互。这些直接的交互快速、简单，是学习或实验MongoDB功能的绝佳方式。然而，在许多生产情况下，将是软件代替用户连接到数据库。MongoDB是一个很好的存储和查询数据的地方，但通常，它最重要的用途是作为大规模应用程序的后端。这些应用程序通常在某些条件或用户界面触发后以编程方式写入、读取和更新数据。
- en: To connect your software with a database, you will typically use a library (often
    provided by the database creator) known as a driver. This driver will help you
    connect, analyze, read, and write to your database without having to write multiple
    lines of code for simple actions. It provides functions and abstractions for common
    use cases, as well as frameworks for working with data extracted from the database.
    MongoDB provides several different drivers for different programming languages,
    one of the most popular (and the one we will explore in this chapter) being the
    Node.js driver (sometimes known as Node).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要将您的软件与数据库连接，通常会使用一个库（通常由数据库创建者提供）称为驱动程序。这个驱动程序将帮助您连接、分析、读取和写入数据库，而无需为简单操作编写多行代码。它提供了常见用例的函数和抽象，以及用于处理从数据库中提取的数据的框架。MongoDB为不同的编程语言提供了几种不同的驱动程序，其中最流行的（也是我们将在本章中探讨的）是Node.js驱动程序（有时称为Node）。
- en: To relate this to real life, think about your online shopping experience. The
    first time you purchase products from a website, you have to enter all your billing
    and shipping details. If you have signed up for an account, however, the second
    time you go to the checkout, all your details are already saved on the website.
    This is a great experience, and, with many websites, this is accomplished by the
    web application querying a backend database. One such database that can support
    these applications is MongoDB.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要将这与现实生活联系起来，想想您的在线购物体验。第一次从网站购买产品时，您必须输入所有的账单和送货细节。然而，如果您已经注册了一个账户，第二次去结账时，所有的细节都已经保存在网站上。这是一个很好的体验，而且在许多网站上，这是通过Web应用程序查询后端数据库来实现的。MongoDB是可以支持这些应用程序的一个这样的数据库。
- en: One of the primary reasons why MongoDB has achieved such excellent growth and
    adoption is its success in persuading software developers to choose it as the
    database for their applications. Much of this persuasion is derived from how well
    MongoDB integrates with Node.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB取得如此出色的增长和采用的主要原因之一是其成功说服软件开发人员选择它作为其应用程序的数据库。其中很大一部分说服力来自于MongoDB与Node的良好集成。
- en: Node.js has become one of the primary languages for web-based applications,
    which we will learn about later in this chapter. However, for now, it is sufficient
    to know that the ease of integrating Node and MongoDB has proved highly beneficial
    for both technologies. This symbiotic relationship has also led to the creation
    of a large numbers of successful Node/MongoDB implementations, from small mobile
    apps to large-scale web applications. When deciding which programming language
    to choose when demonstrating MongoDB drivers, Node.js is the preferred choice.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js已经成为基于Web的应用程序的主要语言之一，我们将在本章后面学习。然而，现在知道Node和MongoDB集成的便利性对两种技术都非常有益就足够了。这种共生关系还导致了大量成功的Node/MongoDB实现，从小型移动应用到大规模Web应用。在展示MongoDB驱动程序时，选择Node.js是首选。
- en: Depending on your job role, you may either be responsible for writing applications
    that will run against MongoDB or expected to write the occasional line of code.
    However, regardless of your programming level or professional responsibilities,
    an understanding of how applications use drivers to integrate with MongoDB will
    be highly valuable. Most of the MongoDB production queries are run by applications,
    not by people. Whether you are a data analyst, a frontend developer, or a database
    administrator, it is highly possible that your production environment will be
    using one of the MongoDB drivers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的工作角色，您可能负责编写针对MongoDB运行的应用程序，或者期望偶尔编写一行代码。然而，无论您的编程水平或专业责任如何，了解应用程序如何使用驱动程序与MongoDB集成将非常有价值。大多数MongoDB生产查询是由应用程序而不是人运行的。无论您是数据分析师、前端开发人员还是数据库管理员，您的生产环境很可能会使用MongoDB驱动程序之一。
- en: Note
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For the duration of this chapter, the exercises and activities included are
    iterations on a single scenario. The data and examples are based on the MongoDB
    Atlas sample database entitled `sample_mflix`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的整个持续时间内，包括的练习和活动都是对一个情景的迭代。数据和示例都基于名为`sample_mflix`的MongoDB Atlas示例数据库。
- en: For the duration of this chapter, we will follow a set of exercises based on
    a theoretical scenario. This is an expansion of the scenario we covered in *Chapter
    7*, *Aggregations*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的整个持续时间内，我们将按照一个基于理论情景的一系列练习。这是我们在第7章“聚合”中涵盖的情景的扩展。
- en: Building upon the scenario from *Chapter 7*, *Aggregations*, where a cinema
    company is running its annual classic movie marathon and wants to decide what
    their lineup should be, they need a variety of popular movies that meet specific
    criteria to satisfy their customer base. After exploring the data and assisting
    them in making business decisions, you have provided them with new insights. The
    cinema company is pleased with your suggestions and have decided to engage you
    as part of their next project. This project involves creating a simple Node.js
    application that will allow their employees to query the film database, without
    them having to know MongoDB and place votes on which movies should be screened
    at the cinemas. Over the course of this chapter, you will create this application.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第7章*“聚合”中构建场景的基础上，一个电影公司正在举办年度经典电影马拉松，并希望决定他们的放映计划应该是什么，他们需要满足特定标准的各种受欢迎的电影来满足他们的客户群。在探索数据并协助他们做出业务决策后，您为他们提供了新的见解。电影公司对您的建议感到满意，并决定让您参与他们的下一个项目。该项目涉及创建一个简单的Node.js应用程序，允许他们的员工查询电影数据库，而无需了解MongoDB并对应该在电影院放映哪些电影进行投票。在本章的过程中，您将创建此应用程序。
- en: Connecting to the Driver
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到驱动程序
- en: At a high level, the process of using the Node.js driver with MongoDB is similar
    to connecting directly with the shell. You will specify a MongoDB server URI,
    several connection parameters, and you can execute queries against collections.
    This should all be quite familiar; the main difference will be that these instructions
    will be written in JavaScript instead of Bash or PowerShell.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，使用Node.js驱动程序与MongoDB的过程类似于直接连接shell。您将指定MongoDB服务器URI、几个连接参数，并且可以对集合执行查询。这应该都很熟悉；主要区别在于这些指令将以JavaScript而不是Bash或PowerShell编写。
- en: Introduction to Node.js
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node.js简介
- en: Since the objective of this chapter is not to learn Node.js programming, we
    will briefly cover the fundamentals to ensure that we can create our MongoDB application.
    The **js** in Node.js stands for **JavaScript** because JavaScript is the programming
    language that Node.js understands. JavaScript typically runs in a browser. However,
    you can think of Node.js as an engine that executes the JavaScript files on your
    computer.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章的目标不是学习Node.js编程，我们将简要介绍基础知识，以确保我们可以创建我们的MongoDB应用程序。Node.js中的**js**代表**JavaScript**，因为JavaScript是Node.js理解的编程语言。JavaScript通常在浏览器中运行。但是，您可以将Node.js视为在计算机上执行JavaScript文件的引擎。
- en: Over the course of this chapter, you will write JavaScript (`.js`) syntax and
    execute it with Node.js. Although you can write JavaScript files with any text
    editor, it is recommended to use an application that will help you with syntax
    highlighting and formatting, such as **Visual Studio Code** or **Sublime**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的过程中，您将编写JavaScript（`.js`）语法，并使用Node.js执行它。虽然您可以使用任何文本编辑器编写JavaScript文件，但建议使用可以帮助您进行语法高亮和格式化的应用程序，例如**Visual
    Studio Code**或**Sublime**。
- en: 'To begin with, let''s look at some sample code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一些示例代码：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s define each term from the preceding syntax, in detail:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细定义前面语法中的每个术语：
- en: The `var` keyword is used to declare a new variable; in this case, the variable
    name is `message`.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var`关键字用于声明一个新变量；在本例中，变量名为`message`。'
- en: The `=` symbol sets the value of this variable to a string called `Hello, Node!`.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`=`符号将此变量的值设置为一个名为`Hello, Node!`的字符串。'
- en: A semi-colon (`;`) is used at the end of each statement.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个语句的末尾使用分号（`;`）。
- en: '`console.log(message)` is a function used to output the value of `message`.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`console.log(message)`是用于输出`message`值的函数。'
- en: If you're familiar with programming fundamentals, you may have noticed that
    we did not have to explicitly declare the `message` variable as `string`. This
    is because JavaScript is **dynamically typed**, meaning that you don't have to
    explicitly specify the variable type (number, string, Boolean, and so on).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉编程基础知识，您可能已经注意到我们不必将`message`变量显式声明为`string`。这是因为JavaScript是**动态类型**的，这意味着您不必显式指定变量类型（数字、字符串、布尔值等）。
- en: If you're less familiar with programming fundamentals, some of the terminology
    in this chapter might confuse you. Because this is not a JavaScript programming
    book, these concepts will not be covered in depth. The objective of this chapter
    is to understand how drivers interact with MongoDB; the specifics of Node.js are
    not important. Although this chapter attempts to keep the programming concepts
    simple, don't worry if something seems complex.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对编程基础知识不太熟悉，本章中的一些术语可能会使您感到困惑。因为这不是一本JavaScript编程书，这些概念不会被深入讨论。本章的目标是了解驱动程序如何与MongoDB交互；Node.js的具体内容并不重要。尽管本章试图保持编程概念简单，但如果有什么复杂的地方，不要担心。
- en: 'Let''s try running the code sample, saving that code to a file called `1_Hello_World.js`
    in our current directory, and then running the command in our Terminal or Command
    Prompt using the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试运行代码示例，将该代码保存到名为`1_Hello_World.js`的文件中，保存到我们当前的目录中，然后使用以下命令在我们的终端或命令提示符中运行该命令：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You''ll see an output that looks like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到一个看起来像这样的输出：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, it is straightforward to run Node.js scripts since without building
    or compiling, you can write your code and call it with `node`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，运行Node.js脚本非常简单，因为无需构建或编译，您可以编写代码并使用`node`调用它。
- en: 'The `var` keyword stores information in a variable and changes it later in
    the code. However, there is another keyword, `const`, that is used to store information
    that isn''t going to change. So, in our example, we could replace our `var` keyword
    with the `const` keyword. As a best practice, you can declare anything that won''t
    change as `const`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`var`关键字将信息存储在变量中，并在代码中稍后更改。但是，还有另一个关键字`const`，用于存储不会更改的信息。因此，在我们的示例中，我们可以用`const`关键字替换我们的`var`关键字。作为最佳实践，您可以将任何不会更改的内容声明为`const`：'
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let''s consider the structure of functions and parameters. It is like
    the structure from previous chapters'' queries in the mongo shell. To begin, let''s
    consider the following example of defining a function:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And here is a preview of some of the types of code we will encounter later
    in this chapter. You may notice that although it is a much more complex code snippet,
    there are some common elements from the CRUD operations you have learned in earlier
    chapters (*Chapter 4*, *Querying Documents*, in particular), such as the syntax
    of a `find` command and the MongoDB URI:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This may be a little intimidating to begin with, but as we dive deeper into
    this chapter, this will become more familiar. As we mentioned earlier, there should
    be some elements that you recognize from the mongo shell, even if they look a
    little different. Some of the elements in the code that map to mongo shell elements
    are as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: The `collection` object, like `db.collection` in the shell.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `find` command after our `collection`, like the shell.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parameter in our `find` command is a document filter, which is precisely
    what we would use in the shell.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function declaration in Node.js is done using the `function(parameter){…}`
    function and it allows us to create smaller, reusable bits of code that can be
    run multiple times, such as the `find()` or `insertOne()` functions. Defining
    a function is easy; you simply use the `function` keyword, followed by the name
    of the function, its parameters in brackets, and curly braces to define the actual
    logic for this function.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the code that defines a function. Note that there are two ways to do
    this: you can declare a function as a variable or pass a function as a parameter
    to another function. We''ll cover this in detail later in this chapter:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Getting the MongoDB Driver for Node.js
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The easiest way to install the MongoDB driver for Node.js is to use `npm`.
    `npm`, or the node package manager, is a package management tool used to add,
    update, and manage different packages used in Node.js programs. In this case,
    the package you want to add is the MongoDB driver, so, in the directory where
    the scripts are stored, run the following command in your Terminal or Command
    Prompt:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You may see some output once the package is installed, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1: Installing the MongoDB driver with npm'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_08_01.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.1: Installing the MongoDB driver with npm'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: It's as easy as that. Now, let's begin programming against MongoDB.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: The Database and Collection Objects
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using the MongoDB driver, there are three main components that you can
    use for most operations. In the later exercises, we'll see how they all fit together,
    but before that, let's briefly cover each of them and their purpose.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '`MongoClient` is the first object you must create in your code. This represents
    your connection to the MongoDB server. Think of this as the equivalent of your
    mongo shell; you pass in the URL and connection parameters for your database,
    and it will create a connection for you to use. To use `MongoClient`, you must
    import the module at the top of your script:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next is the `database` object. Like the mongo shell, once the connection is
    established, run your commands against a specific database in your server. This
    database object will also determine which collections you may run the queries against:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The third essential object to use in (almost) every MongoDB-based application
    is the `collection` object. As you may have guessed, a `collection` object is
    used to send queries. As with the mongo shell, most common operations will run
    against a single collection:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `database` and `collection` objects express the same concept as if you were
    connecting directly with the mongo shell. For the purposes of this chapter, `MongoClient`
    is only used to create and store connections to the server.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s important to note that the relationship between these objects is `MongoClient`
    object can create multiple `database` objects, and a `database` object can create
    many `collection` objects for running queries against:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，这些对象之间的关系是`MongoClient`对象可以创建多个`database`对象，而`database`对象可以创建多个用于运行查询的`collection`对象：
- en: '![Figure 8.2: Driver entity relationships'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.2：驱动程序实体关系'
- en: '](img/B15507_08_02.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_08_02.jpg)'
- en: 'Figure 8.2: Driver entity relationships'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：驱动程序实体关系
- en: The preceding diagram is a visual representation of the entity relationships
    described in the previous paragraph. Here, there's one `MongoClient` object to
    multiple `database` objects, each of which may have multiple `collection` objects.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 上图是对前面段落中描述的实体关系的可视化表示。这里有一个`MongoClient`对象对应多个`database`对象，每个`database`对象可能有多个用于运行查询的`collection`对象。
- en: Connection Parameters
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接参数
- en: 'Before we write our code, it''s important to know how to establish the connection
    to `MongoClient`. There are only two parameters when creating a new client: the
    URL for your server and any additional connection options. The connection options
    are optional in case you need to create your client, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码之前，了解如何建立到`MongoClient`的连接是很重要的。创建新客户端时只有两个参数：服务器的URL和任何额外的连接选项。如果需要创建客户端，连接选项是可选的，如下所示：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Just like the mongo shell, `serverURL` supports all the MongoDB URI options,
    meaning you can specify a configuration in this connection string itself, rather
    than in the second optional parameter; for example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 与mongo shell一样，`serverURL`支持所有MongoDB URI选项，这意味着您可以在连接字符串本身中指定配置，而不是在第二个可选参数中；例如：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To simplify this string, many of these URI options (and additional options,
    such as the SSL settings) can be specified in the second parameter when creating
    the client; for example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化这个字符串，可以在创建客户端时在第二个参数中指定许多这些URI选项（以及其他选项，例如SSL设置）；例如：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As with the mongo shell, there are many options for configuration, including
    SSL, Authentication, and Write Concern options. However, most of them are beyond
    the scope of this chapter.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 与mongo shell一样，有许多配置选项，包括SSL、身份验证和写入关注选项。然而，大部分超出了本章的范围。
- en: Note
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Remember, you can find a full connection string for Atlas in the user interface
    at cloud.mongodb.com. You may want to copy this connection string and use it in
    all your scripts for `serverURL`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您可以在cloud.mongodb.com的用户界面中找到Atlas的完整连接字符串。您可能希望复制此连接字符串，并在所有脚本中使用它作为`serverURL`。
- en: Let's learn how to establish a connection with the Node.js driver through an
    exercise.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过练习学习如何与Node.js驱动程序建立连接。
- en: 'Exercise 8.01: Creating a Connection with the Node.js Driver'
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.01：使用Node.js驱动程序创建连接
- en: 'Before you begin this exercise, revisit the movie company from the scenario
    outlined in the *Introduction* section. You may recall that the cinema company
    wants a Node.js application that allows users to query and update records in the
    movies database. To accomplish this, the first thing your application will need
    to do is establish a connection to your server. This can be done by executing
    the following steps:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始这个练习之前，回顾一下*介绍*部分中概述的电影公司。您可能还记得电影公司希望有一个Node.js应用程序，允许用户查询和更新电影数据库中的记录。为了实现这一点，您的应用程序首先需要建立与服务器的连接。可以通过执行以下步骤来完成：
- en: 'First, in your current working directory, create a new JavaScript file called
    `Exercise8.01.js` and open it in your chosen text editor (Visual Studio Code,
    Sublime, and so on):'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在您当前的工作目录中，创建一个名为`Exercise8.01.js`的新JavaScript文件，并在您选择的文本编辑器（Visual Studio
    Code、Sublime等）中打开它：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Import the MongoDB driver library (as described earlier in this chapter) into
    your script file by adding the following line to the top of the file:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将以下行添加到文件顶部，将MongoDB驱动程序库（如本章前面所述）导入到您的脚本文件中：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you did not install the npm MongoDB library earlier in this chapter, you
    should do so now by running `npm install mongo --save` in your Command Prompt
    or Terminal. Run this command in the same directory as your script.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在本章早期没有安装npm MongoDB库，现在应该运行`npm install mongo --save`在命令提示符或终端中进行安装。在与您的脚本相同的目录中运行此命令。
- en: 'Create a new variable containing the URL for your MongoDB server:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含您的MongoDB服务器的URL的新变量：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create a new `MongoClient` object called `client` using the `url` variable:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`client`的新`MongoClient`对象，使用`url`变量：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Open a connection to MongoDB using the `connect` function, as follows:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下方式打开到MongoDB的连接`connect`函数：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add a `console.log()` message within the connection block to confirm that the
    connection is open:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在连接块中添加一个`console.log()`消息，以确认连接已打开：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, at the end of the connection block, close the connection using the
    following syntax:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在连接块的末尾，使用以下语法关闭连接：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Your complete script should look like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您的完整脚本应如下所示：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following output is generated once you execute the code using `node Exercise8.01.js`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`node Exercise8.01.js`执行代码后，将生成以下输出：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this exercise, you established a connection to the server using Node.js driver.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您使用Node.js驱动程序建立了与服务器的连接。
- en: Executing Simple Queries
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行简单查询
- en: 'Now that we have connected to MongoDB, we can run some simple queries against
    the database. Running queries in the Node.js driver is very similar to running
    queries in the shell. By now, you should be familiar with the `find` command in
    the shell:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经连接到MongoDB，可以对数据库运行一些简单的查询。在Node.js驱动程序中运行查询与在shell中运行查询非常相似。到目前为止，您应该熟悉shell中的`find`命令：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here is the syntax for the `find` command in the driver:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是驱动程序中`find`命令的语法：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, the general structure is the same as the `find` command you
    would execute in the mongo shell. Here, we get a collection from the database
    object, and then we run the find command against that collection with a query
    document. The process itself is straightforward. The main differences concern
    how we structure our commands and how we handle the results returned from the
    driver.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: When writing Node.js applications, one of the critical concerns is to ensure
    that your code is written in such a way that it can be modified, extended, or
    understood easily, either by yourself in the future or by other professionals
    who may need to work on the application.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Creating and Executing find Queries
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the code from *Exercise 8.01*, *Creating a Connection with the Node.js
    Driver*, as a reference as it already contains the connection:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The logic of our query will be added here:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, we have a connection to the MongoDB server. However, there are two other
    important objects – `db` and `collection`. Let''s create our database object (for
    the `sample_mflix` database), as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We now have our `database` object. When sending queries in the mongo shell,
    you must pass a document to the command as a filter for your documents. This is
    the same in the Node.js driver. You can pass the document directly. However, it
    is advisable to define the filter as a variable separately and then assign a value.
    You can see the difference in the following code snippet:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As with the mongo shell, you may pass an empty document as a parameter to find
    all the documents. You may have also noticed `toArray` at the end of our `find`
    command. This is added because, by default, the `find` command will return a cursor.
    We''ll cover cursors in the next section, but in the meantime, let''s look at
    what this full script would look like:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you were to save this modified script as `2_Simple_Find.js` and run it with
    the command `node 2_Simple_Find.js`, the following output would result:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3: Output for the preceding snippet (truncated for brevity)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_08_03.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.3: Output for the preceding snippet (truncated for brevity)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: The preceding output is very similar to the output from a MongoDB query executed
    through the mongo shell rather than the driver. When executing queries through
    the driver, we have learned that although the syntax may differ from the mongo
    shell, the fundamental elements in a query and its output are the same.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Using Cursors and Query Results
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous examples, we used the `toArray` function to transform our query
    output into an array we could output with `console.log`. When working with small
    amounts of data, this is a simple way to work with the results; however, with
    larger result sets, you should use cursors. You should be somewhat familiar with
    cursors from your mongo shell queries in *Chapter 5*, *Inserting, Updating, and
    Deleting Documents*. In the mongo shell, you could use the `it` command to iterate
    through your cursor. In Node.js, there are many ways to access your cursor, of
    which three are more common patterns, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '`toArray`: This will take all the results of the query and place them in a
    single array. This is easy to use but not very efficient when you are expecting
    a large result from your query. In the following code, we''re running a `find`
    command against the movies collection and then using `toArray` to log the first
    element in the array to the console:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`each`: This will iterate through each document in the result set, one at a
    time. This is a good pattern if you want to inspect or use each document in the
    result. In the following code snippet, we''re running a `find` command against
    the movies collection, using `each` to log every document that''s returned until
    there are no documents left:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When there are no more documents to return, the document will be equal to `null`.
    Hence, it is important to check whether the document exists (using `if(doc)`)
    every time we inspect a new document.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '`next`: This will allow you to access the next document in the result set.
    This is the best pattern to use if you are only looking for a single document
    or a subset of your results without having to iterate through the entire result.
    In the following code snippet, we''re running a `find` command against the movies
    collection, using `next` to get the first document returned, and then outputting
    that document to the console:'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Because `next` only returns one document at a time, in this example, we run
    it three times to inspect the first three documents.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: In the examples, exercises, and activities in this chapter, we will learn how
    all three methods are being used. However, it is essential to note that there
    are other, more advanced, patterns.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also accomplish the same `sort` and `limit` functionality from the
    mongo shell by placing these commands after `find(…)`; this should be familiar
    to you from your previous queries in the shell:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Exercise 8.02: Building a Node.js Driver Query'
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will build upon the scenario in *Exercise 8.01*, *Creating
    a Connection with the Node.js Driver*, which allows you to connect to the mongo
    server. If you are going to deliver a Node.js application that allows cinema employees
    to query and vote on movies, your script will need to query the database with
    given criteria and return the results in an easily readable format. For this scenario,
    the query you must get results for is as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '*Find two movies in the romance category, projecting only the title for each.*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'You can accomplish this in Node.js by executing the following steps:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Create a new JavaScript file called `Exercise8.02.js`.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So that you don't have to rewrite everything from scratch, copy the content
    of `Exercise8.01.js` into your new script. Otherwise, rewrite the connection code
    in your new file.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To keep the code clean, create new variables to store `databaseName` and `collectionName`.
    Remember, since these won''t change throughout our script, you must declare them
    as constants using the `const` keyword:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, create a new `const` to store our query document; you should be familiar
    with creating these from the previous chapters:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'With all your variables defined, create our database object:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, you can send your query with the following syntax. Use the `each` pattern,
    passing in a callback function to handle each document. Don''t worry if this appears
    strange; you will learn about this in detail in the upcoming section. Remember
    to use `limit` to only return two documents and `project` to output only `title`,
    as they are requirements for our scenario:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Inside your callback function, use `console.log` to output each of the documents
    that was returned by our query:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Your final code should look like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, run the script using `node Exercise8.02.js`. You should get the following
    output:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this exercise, you built a Node.js program that executes a query against
    MongoDB and returns the results to us in the console. Although this is a small
    step that we could easily accomplish in the mongo shell, this script will serve
    as a foundation for more advanced and interactive Node.js applications for MongoDB.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Callbacks and Error Handling in Node.js
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, we have managed to open a connection to MongoDB and run some simple queries,
    but there were probably a couple of elements of the code that seemed unfamiliar;
    for example, the syntax here:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This is what is known as a `MongoClient` that once it completes its own internal
    logic, it should execute the code in the function we passed in as a second parameter.
    That second parameter is known as a callback. Callbacks are extra functions (blocks
    of code) that are passed as parameters to another function that executes first.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'Callbacks allow you to specify the logic to execute only after a function has
    completed. The reason we have to use callbacks in Node.js instead of simply having
    the statements be in order is that Node.js is asynchronous, meaning that when
    we call functions such as `connect`, it doesn''t block execution. Whatever is
    next in the script will be executed. That''s why we use callbacks: to ensure that
    our next steps wait for the connection to complete. There are other modern patterns
    that can be used instead of callbacks, such as **promises** and **await/async**.
    However, considering the scope of this book, we will only cover callbacks in this
    chapter and learn how to handle errors returned from the driver.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 回调允许您指定仅在函数完成后执行的逻辑。我们必须在Node.js中使用回调的原因是Node.js是异步的，这意味着当我们调用诸如`connect`之类的函数时，它不会阻塞执行。脚本中的下一个内容将被执行。这就是为什么我们使用回调的原因：确保我们的下一步等待连接完成。除了回调之外，还有其他现代模式可以用来替代回调，例如**promises**和**await/async**。但是，考虑到本书的范围，我们将只在本章中涵盖回调，并学习如何处理驱动程序返回的错误。
- en: Callbacks in Node.js
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js中的回调
- en: Callbacks can often be visually confusing and hard to conceptualize; however,
    fundamentally, they are quite simple. A callback is a function provided as a parameter
    to a second function, which allows both functions to be run in order.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 回调通常在视觉上令人困惑且难以概念化；但是，从根本上讲，它们非常简单。回调是作为第二个函数的参数提供的函数，这允许两个函数按顺序运行。
- en: 'Without using callbacks (or any other synchronization pattern), both functions
    would start executing right after the other. When using a driver, this would create
    errors, because the second function may be dependent on the first function finishing
    before it begins. For example, you cannot query your data until the connection
    is established. Let''s look at a breakdown of a callback:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用回调函数（或任何其他同步模式），两个函数将在彼此之后立即开始执行。使用驱动程序时，这会创建错误，因为第二个函数可能依赖于第一个函数在开始之前完成。例如，在连接建立之前，您无法查询数据。让我们来看一下回调的分解：
- en: '![Figure 8.4: Breakdown of a callback'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.4：回调的分解'
- en: '](img/B15507_08_04.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_08_04.jpg)'
- en: 'Figure 8.4: Breakdown of a callback'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：回调的分解
- en: 'And now, compare this to our `find` query code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将此与我们的`find`查询代码进行比较：
- en: '![Figure 8.5: Breakdown of a MongoDB callback'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.5：MongoDB回调的分解'
- en: '](img/B15507_08_05.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_08_05.jpg)'
- en: 'Figure 8.5: Breakdown of a MongoDB callback'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：MongoDB回调的分解
- en: 'As you can see, the same structure exists, just with different parameters to
    the callback function. You may be wondering how we know which parameters to use
    in a specific callback. The answer is that the parameters passed into our callback
    function are determined by the first function that we provide our callback function
    to. That''s perhaps a confusing sentence, but what it means is this: when passing
    a function, fA, as a parameter to a second function, fB, the parameters of fA
    are provided by fB. Let''s examine our practical example again to make sure we
    understand this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，相同的结构存在，只是回调函数的参数不同。您可能想知道我们如何知道在特定回调中使用哪些参数。答案是，我们传递给回调函数的参数由我们提供回调函数的第一个函数确定。也许这是一个令人困惑的句子，但它的意思是：当将函数fA作为参数传递给第二个函数fB时，fA的参数由fB提供。让我们再次检查我们的实际示例，以确保我们理解这一点：
- en: '[PRE43]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'So, our callback function, `function(err, doc) { … }`, is provided as a parameter
    to the driver function, `each`. This means that `each` will run our callback function
    for each document in the result set, passing the `err` (error) and `doc` (document)
    parameters in for each execution. Here''s the same code, but with some logging
    to demonstrate the order of execution:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的回调函数`function(err, doc) { … }`作为参数提供给驱动程序函数`each`。这意味着`each`将为结果集中的每个文档运行我们的回调函数，为每次执行传递`err`（错误）和`doc`（文档）参数。以下是相同的代码，但添加了一些日志以演示执行顺序：
- en: '[PRE44]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'And if we run this code using `node 3_Callbacks.js`, we can see the order of
    execution in the output:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`node 3_Callbacks.js`运行此代码，我们可以在输出中看到执行顺序：
- en: '[PRE45]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Callbacks are sometimes complicated patterns to become familiar with and are
    increasingly being replaced by more advanced Node.js patterns, such as `promises`
    and `async/await`. The best way to become more familiar with these patterns is
    by using them, so if you don't feel 100% comfortable with them yet, don't worry.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 回调有时是复杂的模式，需要熟悉，并且越来越多地被更高级的Node.js模式（例如`promises`和`async/await`）所取代。熟悉这些模式的最佳方法是使用它们，因此如果您对它们还不太熟悉，不用担心。
- en: Basic Error Handling in Node.js
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node.js中的基本错误处理
- en: 'As we''ve been examining our callbacks, you may have noticed that there was
    a parameter we have not described yet: `err`. In the MongoDB driver, most commands
    that can return an error in the mongo shell can also return an error in the driver.
    In the case of callbacks, the `err` parameter will always exist; however, if there
    is no error, the value of `err` is `null`. This "error-first" pattern to catch
    errors in asynchronous code is standard practice in NodeJS.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们检查回调时，您可能已经注意到我们尚未描述的参数：`err`。在MongoDB驱动程序中，大多数在mongo shell中可能返回错误的命令也可以在驱动程序中返回错误。在回调的情况下，`err`参数将始终存在；但是，如果没有错误，则`err`的值为`null`。在NodeJS中捕获异步代码中的错误的“错误优先”模式是标准做法。
- en: 'For example, imagine you have created an application that enters users'' phone
    numbers into a customer database, and two different users enter the same phone
    number. MongoDB will return a duplicate key error when you attempt to run the
    insert. At this point, it is your responsibility, as the creator of the Node.js
    application, to properly handle that error. To check any errors in our query,
    we can check whether `err` is not `null`. You can easily check this by using the
    following syntax:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您创建了一个应用程序，将用户的电话号码输入客户数据库，两个不同的用户输入相同的电话号码。当您尝试运行插入时，MongoDB将返回重复键错误。此时，作为Node.js应用程序的创建者，您有责任正确处理该错误。要检查查询中的任何错误，我们可以检查`err`是否不为`null`。您可以使用以下语法轻松检查：
- en: '[PRE46]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You may recognize that this was the same syntax we used to check whether we
    have more documents when using `each`. Similar to how we''re checking the error
    for a query, the `connect` function in our client also provides an error to our
    `callback` function, which should be checked before we run any further logic:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: It is advisable to use callbacks to check the parameters that are passed in
    before we try to use them. In the case of a `find` command, this would mean checking
    whether there is an error and checking that a document was returned. When writing
    code against MongoDB, it is good practice to validate everything that was returned
    from the database and log errors for debugging purposes.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'But it''s not just in callbacks that we can validate the accuracy of our code.
    We can also check non-callback functions to make sure everything worked out, for
    example, when we create our `database` object:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Depending on what you are trying to accomplish with MongoDB, your error handling
    might be as simple as the preceding examples, or you may need much more advanced
    logic. However, for the scope of this chapter, we'll only be looking at basic
    error handling.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8.03: Error Handling and Callbacks with the Node.js Driver'
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In *Exercise 8.02*, *Building a Node.js Driver Query*, you created a script
    that successfully connected to a MongoDB server and resulted a query. In this
    exercise, you will add error handling to your code—meaning that if anything goes
    wrong, it allows you to identify or fix the issue. You will test this handling
    by modifying your query so that it fails. You can accomplish this in Node.js by
    going through the following steps:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Create a new JavaScript file called `Exercise8.03.js`.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So that you don't have to rewrite everything from scratch, copy the content
    of `Exercise8.02.js` into your new script. Otherwise, rewrite the connection and
    query code in your new file.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Within the connect callback, check the `err` parameter. If you do have an error,
    make sure to output it using `console.log`:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Add some error checks before running the query to ensure that the database
    object was created successfully. If you do have an error, output it using `console.log`.
    Use the `!` syntax to check whether something does not exist:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the `each` callback, check the `err` parameter to make sure each document
    was returned without error:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'At this point, your entire code should look like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Before adding an error, run the script using node `Exercise8.03.js`. You should
    get the following output:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Modify the query to ensure that you produce an error:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Run the script using node `Exercise8.03.js`. You should get the following output:![Figure
    8.6: Output after the script is run (truncated for brevity)'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15507_08_06.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.6: Output after the script is run (truncated for brevity)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you extended your Node.js application so that it catches and
    handles errors that you may run into when running MongoDB queries in a Node.js
    environment. This will allow you to create more robust, error-tolerant, and scalable
    applications.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Queries
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we connected to a MongoDB server, queried some data,
    outputted it, and handled any errors we encountered. However, an application or
    script would have limited utility if it could only perform read operations. In
    this section, we will apply `write` and `update` operations in the MongoDB driver.
    Furthermore, we will examine how we can use the function syntax to create reusable
    code blocks for our final application.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Inserting Data with the Node.js Driver
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to the mongo shell, we can use either the `insertOne` or `insertMany`
    function to write data into our collection. These functions are called on the
    collection object. The only parameter we need to pass into these functions is
    a single document in the case of `insertOne`, or an array of documents in the
    case of `insertMany`. The following is a code snippet that includes how to use
    `insertOne` and `insertMany` with callbacks. By now, you should be able to recognize
    that this is an incomplete snippet. To execute the following code, you will need
    to add the basic connection logic we learned about earlier in this chapter. This
    should look very familiar by now:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'As with `find`, we pass a callback to these functions to handle the result
    of the operation. Insert operations will return an error (which may be `null`)
    and a result, which details how the insert operation executed. For example, if
    we were to build on top of the result of the previous exercise and log the result
    of an `insertMany` operation, this would produce the following output:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We may see a `result` object like *Figure 8.7* in the output.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'We are only outputting a subset of the overall `result` object, which contains
    much more information about our operation. For example, we are logging `result.result`,
    which is a sub-document within the entire `result` object. This is just for the
    scope of this example. In other use cases, you may want more information about
    the result of your operation:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7: Output showing a subset of the overall result object'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_08_07.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.7: Output showing a subset of the overall result object'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Updating and Deleting Data with the Node.js Driver
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Updating and deleting documents with the driver follows the same pattern as
    the `insert` function, where the `collection` object passes through a callback,
    checks for errors, and analyzes the results of the operation. All these functions
    will return a results document. However, between the three operations, the format
    and information contained within a result document may differ. Let's look at some examples.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of some sample code (also built on top of our earlier connection
    code) that updates a document. We can use either `updateOne` or `updateMany`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'And if we were to run this code, our resulting output may look something like
    this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, let''s look at an example of deleting a document. As with our other functions,
    we can use either `deleteOne` or `deleteMany`. Remember that this snippet exists
    as part of the larger code we created for *Exercise 8.03*, *Error Handling and
    Callbacks with the Node.js Driver*:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'And if we were to run this code, our output would be as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As you can see, all these operations follow similar patterns and are very close
    in structure to the same commands you would send to the mongo shell. The main
    difference comes in the callback, where we can run our custom logic on the results
    of our operations.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Writing Reusable Functions
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our examples and exercises so far, we have always executed a single operation
    and outputted the result. However, in larger, more complex applications, you will
    want to run many different operations in the same program, depending on the context.
    For example, in your application, you may want to run the same query multiple
    times and compare the respective results, or you may want the second query to
    be modified depending on the output of the first.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: This is where we will create our own functions. You have already written a few
    functions to use as callbacks, but in this case, we are going to write functions
    we can call at any time, either for utility or to keep our code clean and separated.
    Let's look at an example.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand this better through the following code snippet, which runs
    three very similar queries. The only difference between these queries is a single
    parameter (rating) in each of the queries:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Let''s try to simplify and clean up this code with a function. We declare a
    new function using the same syntax we would use for a variable. Because this function
    does not change, we can declare it as `const`. For the value of the function,
    we can use the syntax we have become familiar with from callbacks in previous
    examples (examples from the *Callbacks* section, earlier in this chapter):'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, let''s add our logic to this function, between the curly braces:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'But something isn''t quite right. We''re referencing the database object before
    we have created one. We will have to pass that object into this function as a
    parameter, so let''s adjust our function to do that:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We can now replace our three queries with three function calls:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In this chapter, we won't be going too far into creating modular, functional
    code for the sake of simplicity. However, if you wanted to improve this code even
    further, you could use an array and a `for` loop to run the function for each
    value, without having to call it three times.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8.04: Updating Data with the Node.js Driver'
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Considering the scenario from the *Introduction* section, you have made considerable
    progress from where you started. Your final application for the cinema company
    will need to be able to add votes to movies by running update operations. You''re
    not quite ready to add this logic yet. However, to prove that you can accomplish
    this, write a script that updates several different documents in the database,
    and create a reusable function to do this. In this exercise, you will need to
    update the following names in the `chapter8_Exercise4` collection. You will use
    this unique collection to ensure that data is not corrupted for other activities
    during the updates:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '*Ned Stark to Greg Stark, Robb Stark to Bob Stark, and Bran Stark to Brad Stark.*'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'You can accomplish this in Node.js by executing the following steps:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'First, make sure the correct documents exist to update. Connect to the server
    directly with the mongo shell and execute the following code snippet to check
    for these documents:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'If the result of the preceding query is empty, use this snippet to add the
    documents for updating:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Now, to create the script, exit the mongo shell connection and create a new
    JavaScript file called `Exercise8.04.js`. So that you don't have to rewrite everything
    from scratch, copy the content of `Exercise8.03.js` into your new script. Otherwise,
    rewrite the connection code in your new file. If you copied your code from *Exercise
    8.03*, *Error Handling and Callbacks with the Node.js Driver*, then remove the
    code for the find query.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the collection from movies to `chapter8_Exercise4`:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'At the start of your script, before you connect, create a new function called
    `updateName`. This function will take the database object, the client object,
    and `oldName` and `newName` as parameters:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Within the `updateName` function, add the code for running an update command
    that will update a document containing a name field of `oldName` and update the
    value to `newName`:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, within the connect callback, run your new function three times, one for
    each of the three names you are updating:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'At this point, your entire code should look like this:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Run the script using `node Exercise8.04.js`. You should get the following output:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Over the last four sections, you have learned how to create a Node.js script
    that connects to MongoDB, run queries in easy-to-use functions, and handle any
    errors we might encounter. This serves as a foundation upon which you can build
    many scripts to perform complex logic using your MongoDB database. However, in
    our examples so far, our query parameters have always been hardcoded into our
    scripts, meaning each of our scripts can only satisfy a specific use case.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: This is not ideal. One of the great strengths of using something like the Node.js
    driver is the ability to have a single application that solves a vast number of
    problems. To expand the scope of our scripts, we will take user input to create
    dynamic queries, capable of solving users' questions, without us having to rewrite
    and distribute a new version of our program. In this section, we will learn how
    to accept user input, handle it, and build dynamic queries from it.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: In most large, production-ready applications, user input will come in the form
    of a **Graphical User Interface** (**GUI**). These GUIs transform simple user
    selections into complex, relevant queries. However, building GUIs is quite tricky,
    and beyond the scope of this book.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Reading Input from the Command Line
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will be obtaining inputs from the command line for our
    application. Fortunately, Node.js provides some simple ways for us to read input
    from the command line and use it in our code. Node.js provides a module called
    `readline` that will allow us to ask the user for input, accept that input, and
    then use it. You can load `readline` into your script by adding the following
    lines at the top of your file. You must always create an interface when using
    `readline`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now, we can ask the user for some input. `readline` provides us with multiple
    ways to handle input. However, the simplest way, for now, is to use the `question`
    function, as in the example here:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Note
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: The `${input}` syntax allows us to embed a variable within a string. When using
    this, make sure to use backticks, [PRE76]
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Chapter_8> node example.js
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Hello, what is your name? Michael
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Hello, Michael
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: const question = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed
    do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim
    veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
    consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum
    dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident,
    sunt in culpa qui officia deserunt mollit anim id est laborum?"
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: interface.question(question, (input) => {
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: console.log(`Hello, ${input}`);
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: interface.close();
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: const askName = function() {
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: interface.question("Hello, what is your name?", (input) => {
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: if(input === "exit") {
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: return interface.close(); // Will kill the loop.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: console.log(`Hello, ${input}`);
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: askName();
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: askName(); // First Run.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: if(input === "exit") {
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: return interface.close(); // Will kill the loop.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Chapter_8> node examples.js
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Hello, what is your name?Mike
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Hello, Mike
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Hello, what is your name?John
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Hello, John
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Hello, what is your name?Ed
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Hello, Ed
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Hello, what is your name?exit
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: const readline = require('readline');
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: const interface = readline.createInterface({
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: input: process.stdin,
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: output: process.stdout,
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: const login = function() {
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: interface.question("Hello, what is your name?", (name) => {
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: user = name;
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: prompt();
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: const who = function () {
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: console.log(`User is ${user}`);
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: prompt();
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: const prompt = function() {
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: interface.question("login, who OR exit?", (input) => {
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: if(input === "exit") {
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: return interface.close(); // Will kill the loop.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: prompt();
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: if(input === "login") {
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: login();
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: if(input === "who") {
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: who();
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: const readline = require('readline');
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: const interface = readline.createInterface({
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 'input: process.stdin,'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 'output: process.stdout,'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: var choice;
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: var user;
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: var cinema;
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: const login = function() {
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: interface.question("Hello, what is your name?", (name) => {
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: user = name;
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: prompt();
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: const who = function () {
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: console.log(`User is ${user}`)
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: prompt();
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: const prompt = function() {
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: interface.question("login, who OR exit?", (input) => {
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: if(input === "exit") {
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: return interface.close(); // Will kill the loop.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: if(input === "login") {
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: login();
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: if(input === "who") {
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: who();
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: prompt();
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Chapter_8> node .\Exercise8.06.js
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: login, who OR exit?login
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Hello, what is your name?Michael
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: login, who OR exit?who
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: User is Michael
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: login, who OR exit?exit
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you created a basic interactive application using Node.js
    that lets the user choose from three inputs and outputs the result accordingly.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 8.01: Creating a Simple Node.js Application'
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You have been engaged by a cinema company to create an application that allows
    customers to list the highest rated movies in a selected category. Customers should
    be able to provide a category and the responses within a named command-line list.
    They also need to provide details of their favorite movie to be captured within
    the favorite field. Finally, once all this is done, the customer should be able
    to `exit` the application, as follows:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '`"list"`: Ask the user for a genre, and then query the database for the top
    five movies in that genre, outputting the `ID`, `title`, and `favourite` fields.'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"favourite"`: Ask the user for a film ID, and then update that film with a
    favorite field.'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"exit"`: Quit the interactive loop and the application.'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This activity aims to create a small Node.js application that exposes an interactive
    input loop to the user. Within this loop, users can query information in the database
    by genre, as well as update records by ID. You will need to ensure that you also
    handle any errors that may occur from users' input.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: You may complete this objective in several ways, but remember what we have learned
    throughout this chapter and attempt to create simple, easy-to-use code.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: 'The following high-level steps will help you to complete this task:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: Import the `readline` and MongoDB libraries.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create your `readline` interface.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare any variables you will need.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function called list that will fetch the top five highest rated films
    for a given genre, returning the `title`, `favorite`, and `ID` fields.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: You will need to ask for the category in this function. Look at the login method
    in *Exercise 8.05*, *Handling Inputs in Node.js*, for more information.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a function called `favourite` that will update a document by title and
    add a key called `favourite` with a value of `true` to the document. (*Hint: You
    will need to ask for the title in this function using the same method you used
    for your list function.*)'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the MongoDB connection, database, and collection.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an interactive while loop based on the user's input. If you're unsure
    how to do this, refer to our prompt function from *Exercise 8.05*, *Handling Inputs
    in Node.js*.
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the interactive loop, use if conditions to check for the input. If a
    valid input is found, run the relevant function.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remember, you will need to pass the database and client objects through to
    each of your functions, including any time you call `prompt()`. To test your output,
    run the following commands:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`list`'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '`Horror`'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '`favourite`'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '`list`'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '`exit`'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: You may notice that the title `Nosferatu` appears twice in the output. If you
    look at the `_id` values, you will see that these are actually two separate films
    with the same title. In MongoDB, you may have many different documents that share
    the same values in their fields.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8: Final output (truncated for brevity)'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_08_08.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.8: Final output (truncated for brevity)'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found via [this link](B15507_Solution_Final_SZ_ePub.xhtml#_idTextAnchor475).
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered the basic concepts that are essential to the
    creation of a MongoDB-powered application using the Node.js driver. Using these
    fundamentals, a vast number of scripts can be created to perform queries and operations
    on your database. We even learned to handle errors and create interactive applications.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: Although you may not be required to write or read applications like these as
    part of your day-to-day responsibilities, having a thorough understanding of how
    these applications are built gives you a unique insight into MongoDB development
    and how your peers may interact with your MongoDB data.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: However, if you are looking to increase your expertise with regards to the Node.js
    driver for MongoDB, this is just the beginning. There are many different patterns,
    libraries, and best practices you can use to develop Node.js applications against
    MongoDB. This is just the beginning of your Node.js journey.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dive deeper into improving the performance of your
    MongoDB interactions and create efficient indexes that will speed up your queries.
    Another useful feature we will cover is the use of `explain` and how to best interpret
    its output.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
