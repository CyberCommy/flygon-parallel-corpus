- en: 8\. Coding JavaScript in MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to read, understand, and create simple MongoDB
    applications using the Node.js driver. These applications will help you to programmatically
    fetch, update, and create data in your MongoDB collections, as well as to handle
    errors and user inputs. By the end of this chapter, you will be able to create
    a simple application built on top of MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have interacted directly with the MongoDB database using the mongo
    shell. These direct interactions are quick, easy, and a fantastic way to learn
    or experiment with MongoDB features. However, in many production situations, it
    will be software that connects with the database in place of the user. MongoDB
    is a great place to store and query your data, but often, it's most essential
    use is to serve as a backend for large-scale applications. These applications
    write, read, and update data programmatically, usually after being triggered by
    some condition or user interface.
  prefs: []
  type: TYPE_NORMAL
- en: To connect your software with a database, you will typically use a library (often
    provided by the database creator) known as a driver. This driver will help you
    connect, analyze, read, and write to your database without having to write multiple
    lines of code for simple actions. It provides functions and abstractions for common
    use cases, as well as frameworks for working with data extracted from the database.
    MongoDB provides several different drivers for different programming languages,
    one of the most popular (and the one we will explore in this chapter) being the
    Node.js driver (sometimes known as Node).
  prefs: []
  type: TYPE_NORMAL
- en: To relate this to real life, think about your online shopping experience. The
    first time you purchase products from a website, you have to enter all your billing
    and shipping details. If you have signed up for an account, however, the second
    time you go to the checkout, all your details are already saved on the website.
    This is a great experience, and, with many websites, this is accomplished by the
    web application querying a backend database. One such database that can support
    these applications is MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: One of the primary reasons why MongoDB has achieved such excellent growth and
    adoption is its success in persuading software developers to choose it as the
    database for their applications. Much of this persuasion is derived from how well
    MongoDB integrates with Node.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js has become one of the primary languages for web-based applications,
    which we will learn about later in this chapter. However, for now, it is sufficient
    to know that the ease of integrating Node and MongoDB has proved highly beneficial
    for both technologies. This symbiotic relationship has also led to the creation
    of a large numbers of successful Node/MongoDB implementations, from small mobile
    apps to large-scale web applications. When deciding which programming language
    to choose when demonstrating MongoDB drivers, Node.js is the preferred choice.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on your job role, you may either be responsible for writing applications
    that will run against MongoDB or expected to write the occasional line of code.
    However, regardless of your programming level or professional responsibilities,
    an understanding of how applications use drivers to integrate with MongoDB will
    be highly valuable. Most of the MongoDB production queries are run by applications,
    not by people. Whether you are a data analyst, a frontend developer, or a database
    administrator, it is highly possible that your production environment will be
    using one of the MongoDB drivers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For the duration of this chapter, the exercises and activities included are
    iterations on a single scenario. The data and examples are based on the MongoDB
    Atlas sample database entitled `sample_mflix`.
  prefs: []
  type: TYPE_NORMAL
- en: For the duration of this chapter, we will follow a set of exercises based on
    a theoretical scenario. This is an expansion of the scenario we covered in *Chapter
    7*, *Aggregations*.
  prefs: []
  type: TYPE_NORMAL
- en: Building upon the scenario from *Chapter 7*, *Aggregations*, where a cinema
    company is running its annual classic movie marathon and wants to decide what
    their lineup should be, they need a variety of popular movies that meet specific
    criteria to satisfy their customer base. After exploring the data and assisting
    them in making business decisions, you have provided them with new insights. The
    cinema company is pleased with your suggestions and have decided to engage you
    as part of their next project. This project involves creating a simple Node.js
    application that will allow their employees to query the film database, without
    them having to know MongoDB and place votes on which movies should be screened
    at the cinemas. Over the course of this chapter, you will create this application.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the Driver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At a high level, the process of using the Node.js driver with MongoDB is similar
    to connecting directly with the shell. You will specify a MongoDB server URI,
    several connection parameters, and you can execute queries against collections.
    This should all be quite familiar; the main difference will be that these instructions
    will be written in JavaScript instead of Bash or PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Node.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the objective of this chapter is not to learn Node.js programming, we
    will briefly cover the fundamentals to ensure that we can create our MongoDB application.
    The **js** in Node.js stands for **JavaScript** because JavaScript is the programming
    language that Node.js understands. JavaScript typically runs in a browser. However,
    you can think of Node.js as an engine that executes the JavaScript files on your
    computer.
  prefs: []
  type: TYPE_NORMAL
- en: Over the course of this chapter, you will write JavaScript (`.js`) syntax and
    execute it with Node.js. Although you can write JavaScript files with any text
    editor, it is recommended to use an application that will help you with syntax
    highlighting and formatting, such as **Visual Studio Code** or **Sublime**.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, let''s look at some sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define each term from the preceding syntax, in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: The `var` keyword is used to declare a new variable; in this case, the variable
    name is `message`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `=` symbol sets the value of this variable to a string called `Hello, Node!`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A semi-colon (`;`) is used at the end of each statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`console.log(message)` is a function used to output the value of `message`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you're familiar with programming fundamentals, you may have noticed that
    we did not have to explicitly declare the `message` variable as `string`. This
    is because JavaScript is **dynamically typed**, meaning that you don't have to
    explicitly specify the variable type (number, string, Boolean, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: If you're less familiar with programming fundamentals, some of the terminology
    in this chapter might confuse you. Because this is not a JavaScript programming
    book, these concepts will not be covered in depth. The objective of this chapter
    is to understand how drivers interact with MongoDB; the specifics of Node.js are
    not important. Although this chapter attempts to keep the programming concepts
    simple, don't worry if something seems complex.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try running the code sample, saving that code to a file called `1_Hello_World.js`
    in our current directory, and then running the command in our Terminal or Command
    Prompt using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll see an output that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it is straightforward to run Node.js scripts since without building
    or compiling, you can write your code and call it with `node`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `var` keyword stores information in a variable and changes it later in
    the code. However, there is another keyword, `const`, that is used to store information
    that isn''t going to change. So, in our example, we could replace our `var` keyword
    with the `const` keyword. As a best practice, you can declare anything that won''t
    change as `const`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s consider the structure of functions and parameters. It is like
    the structure from previous chapters'' queries in the mongo shell. To begin, let''s
    consider the following example of defining a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is a preview of some of the types of code we will encounter later
    in this chapter. You may notice that although it is a much more complex code snippet,
    there are some common elements from the CRUD operations you have learned in earlier
    chapters (*Chapter 4*, *Querying Documents*, in particular), such as the syntax
    of a `find` command and the MongoDB URI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This may be a little intimidating to begin with, but as we dive deeper into
    this chapter, this will become more familiar. As we mentioned earlier, there should
    be some elements that you recognize from the mongo shell, even if they look a
    little different. Some of the elements in the code that map to mongo shell elements
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `collection` object, like `db.collection` in the shell.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `find` command after our `collection`, like the shell.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parameter in our `find` command is a document filter, which is precisely
    what we would use in the shell.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function declaration in Node.js is done using the `function(parameter){…}`
    function and it allows us to create smaller, reusable bits of code that can be
    run multiple times, such as the `find()` or `insertOne()` functions. Defining
    a function is easy; you simply use the `function` keyword, followed by the name
    of the function, its parameters in brackets, and curly braces to define the actual
    logic for this function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the code that defines a function. Note that there are two ways to do
    this: you can declare a function as a variable or pass a function as a parameter
    to another function. We''ll cover this in detail later in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Getting the MongoDB Driver for Node.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The easiest way to install the MongoDB driver for Node.js is to use `npm`.
    `npm`, or the node package manager, is a package management tool used to add,
    update, and manage different packages used in Node.js programs. In this case,
    the package you want to add is the MongoDB driver, so, in the directory where
    the scripts are stored, run the following command in your Terminal or Command
    Prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You may see some output once the package is installed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1: Installing the MongoDB driver with npm'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_08_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.1: Installing the MongoDB driver with npm'
  prefs: []
  type: TYPE_NORMAL
- en: It's as easy as that. Now, let's begin programming against MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: The Database and Collection Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using the MongoDB driver, there are three main components that you can
    use for most operations. In the later exercises, we'll see how they all fit together,
    but before that, let's briefly cover each of them and their purpose.
  prefs: []
  type: TYPE_NORMAL
- en: '`MongoClient` is the first object you must create in your code. This represents
    your connection to the MongoDB server. Think of this as the equivalent of your
    mongo shell; you pass in the URL and connection parameters for your database,
    and it will create a connection for you to use. To use `MongoClient`, you must
    import the module at the top of your script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next is the `database` object. Like the mongo shell, once the connection is
    established, run your commands against a specific database in your server. This
    database object will also determine which collections you may run the queries against:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The third essential object to use in (almost) every MongoDB-based application
    is the `collection` object. As you may have guessed, a `collection` object is
    used to send queries. As with the mongo shell, most common operations will run
    against a single collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `database` and `collection` objects express the same concept as if you were
    connecting directly with the mongo shell. For the purposes of this chapter, `MongoClient`
    is only used to create and store connections to the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s important to note that the relationship between these objects is `MongoClient`
    object can create multiple `database` objects, and a `database` object can create
    many `collection` objects for running queries against:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2: Driver entity relationships'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_08_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.2: Driver entity relationships'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram is a visual representation of the entity relationships
    described in the previous paragraph. Here, there's one `MongoClient` object to
    multiple `database` objects, each of which may have multiple `collection` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Connection Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we write our code, it''s important to know how to establish the connection
    to `MongoClient`. There are only two parameters when creating a new client: the
    URL for your server and any additional connection options. The connection options
    are optional in case you need to create your client, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like the mongo shell, `serverURL` supports all the MongoDB URI options,
    meaning you can specify a configuration in this connection string itself, rather
    than in the second optional parameter; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To simplify this string, many of these URI options (and additional options,
    such as the SSL settings) can be specified in the second parameter when creating
    the client; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As with the mongo shell, there are many options for configuration, including
    SSL, Authentication, and Write Concern options. However, most of them are beyond
    the scope of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Remember, you can find a full connection string for Atlas in the user interface
    at cloud.mongodb.com. You may want to copy this connection string and use it in
    all your scripts for `serverURL`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's learn how to establish a connection with the Node.js driver through an
    exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8.01: Creating a Connection with the Node.js Driver'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you begin this exercise, revisit the movie company from the scenario
    outlined in the *Introduction* section. You may recall that the cinema company
    wants a Node.js application that allows users to query and update records in the
    movies database. To accomplish this, the first thing your application will need
    to do is establish a connection to your server. This can be done by executing
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in your current working directory, create a new JavaScript file called
    `Exercise8.01.js` and open it in your chosen text editor (Visual Studio Code,
    Sublime, and so on):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Import the MongoDB driver library (as described earlier in this chapter) into
    your script file by adding the following line to the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you did not install the npm MongoDB library earlier in this chapter, you
    should do so now by running `npm install mongo --save` in your Command Prompt
    or Terminal. Run this command in the same directory as your script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new variable containing the URL for your MongoDB server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `MongoClient` object called `client` using the `url` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Open a connection to MongoDB using the `connect` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `console.log()` message within the connection block to confirm that the
    connection is open:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, at the end of the connection block, close the connection using the
    following syntax:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Your complete script should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output is generated once you execute the code using `node Exercise8.01.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, you established a connection to the server using Node.js driver.
  prefs: []
  type: TYPE_NORMAL
- en: Executing Simple Queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have connected to MongoDB, we can run some simple queries against
    the database. Running queries in the Node.js driver is very similar to running
    queries in the shell. By now, you should be familiar with the `find` command in
    the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the syntax for the `find` command in the driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the general structure is the same as the `find` command you
    would execute in the mongo shell. Here, we get a collection from the database
    object, and then we run the find command against that collection with a query
    document. The process itself is straightforward. The main differences concern
    how we structure our commands and how we handle the results returned from the
    driver.
  prefs: []
  type: TYPE_NORMAL
- en: When writing Node.js applications, one of the critical concerns is to ensure
    that your code is written in such a way that it can be modified, extended, or
    understood easily, either by yourself in the future or by other professionals
    who may need to work on the application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and Executing find Queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the code from *Exercise 8.01*, *Creating a Connection with the Node.js
    Driver*, as a reference as it already contains the connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The logic of our query will be added here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have a connection to the MongoDB server. However, there are two other
    important objects – `db` and `collection`. Let''s create our database object (for
    the `sample_mflix` database), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have our `database` object. When sending queries in the mongo shell,
    you must pass a document to the command as a filter for your documents. This is
    the same in the Node.js driver. You can pass the document directly. However, it
    is advisable to define the filter as a variable separately and then assign a value.
    You can see the difference in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the mongo shell, you may pass an empty document as a parameter to find
    all the documents. You may have also noticed `toArray` at the end of our `find`
    command. This is added because, by default, the `find` command will return a cursor.
    We''ll cover cursors in the next section, but in the meantime, let''s look at
    what this full script would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If you were to save this modified script as `2_Simple_Find.js` and run it with
    the command `node 2_Simple_Find.js`, the following output would result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3: Output for the preceding snippet (truncated for brevity)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_08_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.3: Output for the preceding snippet (truncated for brevity)'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding output is very similar to the output from a MongoDB query executed
    through the mongo shell rather than the driver. When executing queries through
    the driver, we have learned that although the syntax may differ from the mongo
    shell, the fundamental elements in a query and its output are the same.
  prefs: []
  type: TYPE_NORMAL
- en: Using Cursors and Query Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous examples, we used the `toArray` function to transform our query
    output into an array we could output with `console.log`. When working with small
    amounts of data, this is a simple way to work with the results; however, with
    larger result sets, you should use cursors. You should be somewhat familiar with
    cursors from your mongo shell queries in *Chapter 5*, *Inserting, Updating, and
    Deleting Documents*. In the mongo shell, you could use the `it` command to iterate
    through your cursor. In Node.js, there are many ways to access your cursor, of
    which three are more common patterns, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`toArray`: This will take all the results of the query and place them in a
    single array. This is easy to use but not very efficient when you are expecting
    a large result from your query. In the following code, we''re running a `find`
    command against the movies collection and then using `toArray` to log the first
    element in the array to the console:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`each`: This will iterate through each document in the result set, one at a
    time. This is a good pattern if you want to inspect or use each document in the
    result. In the following code snippet, we''re running a `find` command against
    the movies collection, using `each` to log every document that''s returned until
    there are no documents left:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: When there are no more documents to return, the document will be equal to `null`.
    Hence, it is important to check whether the document exists (using `if(doc)`)
    every time we inspect a new document.
  prefs: []
  type: TYPE_NORMAL
- en: '`next`: This will allow you to access the next document in the result set.
    This is the best pattern to use if you are only looking for a single document
    or a subset of your results without having to iterate through the entire result.
    In the following code snippet, we''re running a `find` command against the movies
    collection, using `next` to get the first document returned, and then outputting
    that document to the console:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Because `next` only returns one document at a time, in this example, we run
    it three times to inspect the first three documents.
  prefs: []
  type: TYPE_NORMAL
- en: In the examples, exercises, and activities in this chapter, we will learn how
    all three methods are being used. However, it is essential to note that there
    are other, more advanced, patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also accomplish the same `sort` and `limit` functionality from the
    mongo shell by placing these commands after `find(…)`; this should be familiar
    to you from your previous queries in the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 8.02: Building a Node.js Driver Query'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will build upon the scenario in *Exercise 8.01*, *Creating
    a Connection with the Node.js Driver*, which allows you to connect to the mongo
    server. If you are going to deliver a Node.js application that allows cinema employees
    to query and vote on movies, your script will need to query the database with
    given criteria and return the results in an easily readable format. For this scenario,
    the query you must get results for is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Find two movies in the romance category, projecting only the title for each.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can accomplish this in Node.js by executing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new JavaScript file called `Exercise8.02.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So that you don't have to rewrite everything from scratch, copy the content
    of `Exercise8.01.js` into your new script. Otherwise, rewrite the connection code
    in your new file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To keep the code clean, create new variables to store `databaseName` and `collectionName`.
    Remember, since these won''t change throughout our script, you must declare them
    as constants using the `const` keyword:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a new `const` to store our query document; you should be familiar
    with creating these from the previous chapters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'With all your variables defined, create our database object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can send your query with the following syntax. Use the `each` pattern,
    passing in a callback function to handle each document. Don''t worry if this appears
    strange; you will learn about this in detail in the upcoming section. Remember
    to use `limit` to only return two documents and `project` to output only `title`,
    as they are requirements for our scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside your callback function, use `console.log` to output each of the documents
    that was returned by our query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Your final code should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the script using `node Exercise8.02.js`. You should get the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, you built a Node.js program that executes a query against
    MongoDB and returns the results to us in the console. Although this is a small
    step that we could easily accomplish in the mongo shell, this script will serve
    as a foundation for more advanced and interactive Node.js applications for MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: Callbacks and Error Handling in Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, we have managed to open a connection to MongoDB and run some simple queries,
    but there were probably a couple of elements of the code that seemed unfamiliar;
    for example, the syntax here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This is what is known as a `MongoClient` that once it completes its own internal
    logic, it should execute the code in the function we passed in as a second parameter.
    That second parameter is known as a callback. Callbacks are extra functions (blocks
    of code) that are passed as parameters to another function that executes first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Callbacks allow you to specify the logic to execute only after a function has
    completed. The reason we have to use callbacks in Node.js instead of simply having
    the statements be in order is that Node.js is asynchronous, meaning that when
    we call functions such as `connect`, it doesn''t block execution. Whatever is
    next in the script will be executed. That''s why we use callbacks: to ensure that
    our next steps wait for the connection to complete. There are other modern patterns
    that can be used instead of callbacks, such as **promises** and **await/async**.
    However, considering the scope of this book, we will only cover callbacks in this
    chapter and learn how to handle errors returned from the driver.'
  prefs: []
  type: TYPE_NORMAL
- en: Callbacks in Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Callbacks can often be visually confusing and hard to conceptualize; however,
    fundamentally, they are quite simple. A callback is a function provided as a parameter
    to a second function, which allows both functions to be run in order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without using callbacks (or any other synchronization pattern), both functions
    would start executing right after the other. When using a driver, this would create
    errors, because the second function may be dependent on the first function finishing
    before it begins. For example, you cannot query your data until the connection
    is established. Let''s look at a breakdown of a callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4: Breakdown of a callback'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_08_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.4: Breakdown of a callback'
  prefs: []
  type: TYPE_NORMAL
- en: 'And now, compare this to our `find` query code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5: Breakdown of a MongoDB callback'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_08_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.5: Breakdown of a MongoDB callback'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the same structure exists, just with different parameters to
    the callback function. You may be wondering how we know which parameters to use
    in a specific callback. The answer is that the parameters passed into our callback
    function are determined by the first function that we provide our callback function
    to. That''s perhaps a confusing sentence, but what it means is this: when passing
    a function, fA, as a parameter to a second function, fB, the parameters of fA
    are provided by fB. Let''s examine our practical example again to make sure we
    understand this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'So, our callback function, `function(err, doc) { … }`, is provided as a parameter
    to the driver function, `each`. This means that `each` will run our callback function
    for each document in the result set, passing the `err` (error) and `doc` (document)
    parameters in for each execution. Here''s the same code, but with some logging
    to demonstrate the order of execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'And if we run this code using `node 3_Callbacks.js`, we can see the order of
    execution in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Callbacks are sometimes complicated patterns to become familiar with and are
    increasingly being replaced by more advanced Node.js patterns, such as `promises`
    and `async/await`. The best way to become more familiar with these patterns is
    by using them, so if you don't feel 100% comfortable with them yet, don't worry.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Error Handling in Node.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we''ve been examining our callbacks, you may have noticed that there was
    a parameter we have not described yet: `err`. In the MongoDB driver, most commands
    that can return an error in the mongo shell can also return an error in the driver.
    In the case of callbacks, the `err` parameter will always exist; however, if there
    is no error, the value of `err` is `null`. This "error-first" pattern to catch
    errors in asynchronous code is standard practice in NodeJS.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, imagine you have created an application that enters users'' phone
    numbers into a customer database, and two different users enter the same phone
    number. MongoDB will return a duplicate key error when you attempt to run the
    insert. At this point, it is your responsibility, as the creator of the Node.js
    application, to properly handle that error. To check any errors in our query,
    we can check whether `err` is not `null`. You can easily check this by using the
    following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'You may recognize that this was the same syntax we used to check whether we
    have more documents when using `each`. Similar to how we''re checking the error
    for a query, the `connect` function in our client also provides an error to our
    `callback` function, which should be checked before we run any further logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is advisable to use callbacks to check the parameters that are passed in
    before we try to use them. In the case of a `find` command, this would mean checking
    whether there is an error and checking that a document was returned. When writing
    code against MongoDB, it is good practice to validate everything that was returned
    from the database and log errors for debugging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'But it''s not just in callbacks that we can validate the accuracy of our code.
    We can also check non-callback functions to make sure everything worked out, for
    example, when we create our `database` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Depending on what you are trying to accomplish with MongoDB, your error handling
    might be as simple as the preceding examples, or you may need much more advanced
    logic. However, for the scope of this chapter, we'll only be looking at basic
    error handling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8.03: Error Handling and Callbacks with the Node.js Driver'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In *Exercise 8.02*, *Building a Node.js Driver Query*, you created a script
    that successfully connected to a MongoDB server and resulted a query. In this
    exercise, you will add error handling to your code—meaning that if anything goes
    wrong, it allows you to identify or fix the issue. You will test this handling
    by modifying your query so that it fails. You can accomplish this in Node.js by
    going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new JavaScript file called `Exercise8.03.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So that you don't have to rewrite everything from scratch, copy the content
    of `Exercise8.02.js` into your new script. Otherwise, rewrite the connection and
    query code in your new file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Within the connect callback, check the `err` parameter. If you do have an error,
    make sure to output it using `console.log`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Add some error checks before running the query to ensure that the database
    object was created successfully. If you do have an error, output it using `console.log`.
    Use the `!` syntax to check whether something does not exist:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `each` callback, check the `err` parameter to make sure each document
    was returned without error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, your entire code should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Before adding an error, run the script using node `Exercise8.03.js`. You should
    get the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the query to ensure that you produce an error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script using node `Exercise8.03.js`. You should get the following output:![Figure
    8.6: Output after the script is run (truncated for brevity)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15507_08_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.6: Output after the script is run (truncated for brevity)'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you extended your Node.js application so that it catches and
    handles errors that you may run into when running MongoDB queries in a Node.js
    environment. This will allow you to create more robust, error-tolerant, and scalable
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we connected to a MongoDB server, queried some data,
    outputted it, and handled any errors we encountered. However, an application or
    script would have limited utility if it could only perform read operations. In
    this section, we will apply `write` and `update` operations in the MongoDB driver.
    Furthermore, we will examine how we can use the function syntax to create reusable
    code blocks for our final application.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting Data with the Node.js Driver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to the mongo shell, we can use either the `insertOne` or `insertMany`
    function to write data into our collection. These functions are called on the
    collection object. The only parameter we need to pass into these functions is
    a single document in the case of `insertOne`, or an array of documents in the
    case of `insertMany`. The following is a code snippet that includes how to use
    `insertOne` and `insertMany` with callbacks. By now, you should be able to recognize
    that this is an incomplete snippet. To execute the following code, you will need
    to add the basic connection logic we learned about earlier in this chapter. This
    should look very familiar by now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'As with `find`, we pass a callback to these functions to handle the result
    of the operation. Insert operations will return an error (which may be `null`)
    and a result, which details how the insert operation executed. For example, if
    we were to build on top of the result of the previous exercise and log the result
    of an `insertMany` operation, this would produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We may see a `result` object like *Figure 8.7* in the output.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'We are only outputting a subset of the overall `result` object, which contains
    much more information about our operation. For example, we are logging `result.result`,
    which is a sub-document within the entire `result` object. This is just for the
    scope of this example. In other use cases, you may want more information about
    the result of your operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7: Output showing a subset of the overall result object'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_08_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.7: Output showing a subset of the overall result object'
  prefs: []
  type: TYPE_NORMAL
- en: Updating and Deleting Data with the Node.js Driver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Updating and deleting documents with the driver follows the same pattern as
    the `insert` function, where the `collection` object passes through a callback,
    checks for errors, and analyzes the results of the operation. All these functions
    will return a results document. However, between the three operations, the format
    and information contained within a result document may differ. Let's look at some examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of some sample code (also built on top of our earlier connection
    code) that updates a document. We can use either `updateOne` or `updateMany`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'And if we were to run this code, our resulting output may look something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s look at an example of deleting a document. As with our other functions,
    we can use either `deleteOne` or `deleteMany`. Remember that this snippet exists
    as part of the larger code we created for *Exercise 8.03*, *Error Handling and
    Callbacks with the Node.js Driver*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'And if we were to run this code, our output would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, all these operations follow similar patterns and are very close
    in structure to the same commands you would send to the mongo shell. The main
    difference comes in the callback, where we can run our custom logic on the results
    of our operations.
  prefs: []
  type: TYPE_NORMAL
- en: Writing Reusable Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our examples and exercises so far, we have always executed a single operation
    and outputted the result. However, in larger, more complex applications, you will
    want to run many different operations in the same program, depending on the context.
    For example, in your application, you may want to run the same query multiple
    times and compare the respective results, or you may want the second query to
    be modified depending on the output of the first.
  prefs: []
  type: TYPE_NORMAL
- en: This is where we will create our own functions. You have already written a few
    functions to use as callbacks, but in this case, we are going to write functions
    we can call at any time, either for utility or to keep our code clean and separated.
    Let's look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand this better through the following code snippet, which runs
    three very similar queries. The only difference between these queries is a single
    parameter (rating) in each of the queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try to simplify and clean up this code with a function. We declare a
    new function using the same syntax we would use for a variable. Because this function
    does not change, we can declare it as `const`. For the value of the function,
    we can use the syntax we have become familiar with from callbacks in previous
    examples (examples from the *Callbacks* section, earlier in this chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add our logic to this function, between the curly braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'But something isn''t quite right. We''re referencing the database object before
    we have created one. We will have to pass that object into this function as a
    parameter, so let''s adjust our function to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now replace our three queries with three function calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: In this chapter, we won't be going too far into creating modular, functional
    code for the sake of simplicity. However, if you wanted to improve this code even
    further, you could use an array and a `for` loop to run the function for each
    value, without having to call it three times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8.04: Updating Data with the Node.js Driver'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Considering the scenario from the *Introduction* section, you have made considerable
    progress from where you started. Your final application for the cinema company
    will need to be able to add votes to movies by running update operations. You''re
    not quite ready to add this logic yet. However, to prove that you can accomplish
    this, write a script that updates several different documents in the database,
    and create a reusable function to do this. In this exercise, you will need to
    update the following names in the `chapter8_Exercise4` collection. You will use
    this unique collection to ensure that data is not corrupted for other activities
    during the updates:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Ned Stark to Greg Stark, Robb Stark to Bob Stark, and Bran Stark to Brad Stark.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can accomplish this in Node.js by executing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, make sure the correct documents exist to update. Connect to the server
    directly with the mongo shell and execute the following code snippet to check
    for these documents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'If the result of the preceding query is empty, use this snippet to add the
    documents for updating:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Now, to create the script, exit the mongo shell connection and create a new
    JavaScript file called `Exercise8.04.js`. So that you don't have to rewrite everything
    from scratch, copy the content of `Exercise8.03.js` into your new script. Otherwise,
    rewrite the connection code in your new file. If you copied your code from *Exercise
    8.03*, *Error Handling and Callbacks with the Node.js Driver*, then remove the
    code for the find query.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the collection from movies to `chapter8_Exercise4`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'At the start of your script, before you connect, create a new function called
    `updateName`. This function will take the database object, the client object,
    and `oldName` and `newName` as parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the `updateName` function, add the code for running an update command
    that will update a document containing a name field of `oldName` and update the
    value to `newName`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, within the connect callback, run your new function three times, one for
    each of the three names you are updating:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, your entire code should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script using `node Exercise8.04.js`. You should get the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Over the last four sections, you have learned how to create a Node.js script
    that connects to MongoDB, run queries in easy-to-use functions, and handle any
    errors we might encounter. This serves as a foundation upon which you can build
    many scripts to perform complex logic using your MongoDB database. However, in
    our examples so far, our query parameters have always been hardcoded into our
    scripts, meaning each of our scripts can only satisfy a specific use case.
  prefs: []
  type: TYPE_NORMAL
- en: This is not ideal. One of the great strengths of using something like the Node.js
    driver is the ability to have a single application that solves a vast number of
    problems. To expand the scope of our scripts, we will take user input to create
    dynamic queries, capable of solving users' questions, without us having to rewrite
    and distribute a new version of our program. In this section, we will learn how
    to accept user input, handle it, and build dynamic queries from it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In most large, production-ready applications, user input will come in the form
    of a **Graphical User Interface** (**GUI**). These GUIs transform simple user
    selections into complex, relevant queries. However, building GUIs is quite tricky,
    and beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Reading Input from the Command Line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will be obtaining inputs from the command line for our
    application. Fortunately, Node.js provides some simple ways for us to read input
    from the command line and use it in our code. Node.js provides a module called
    `readline` that will allow us to ask the user for input, accept that input, and
    then use it. You can load `readline` into your script by adding the following
    lines at the top of your file. You must always create an interface when using
    `readline`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can ask the user for some input. `readline` provides us with multiple
    ways to handle input. However, the simplest way, for now, is to use the `question`
    function, as in the example here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `${input}` syntax allows us to embed a variable within a string. When using
    this, make sure to use backticks, [PRE76]
  prefs: []
  type: TYPE_NORMAL
- en: Chapter_8> node example.js
  prefs: []
  type: TYPE_NORMAL
- en: Hello, what is your name? Michael
  prefs: []
  type: TYPE_NORMAL
- en: Hello, Michael
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: const question = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed
    do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim
    veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
    consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum
    dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident,
    sunt in culpa qui officia deserunt mollit anim id est laborum?"
  prefs: []
  type: TYPE_NORMAL
- en: interface.question(question, (input) => {
  prefs: []
  type: TYPE_NORMAL
- en: console.log(`Hello, ${input}`);
  prefs: []
  type: TYPE_NORMAL
- en: interface.close();
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: const askName = function() {
  prefs: []
  type: TYPE_NORMAL
- en: interface.question("Hello, what is your name?", (input) => {
  prefs: []
  type: TYPE_NORMAL
- en: if(input === "exit") {
  prefs: []
  type: TYPE_NORMAL
- en: return interface.close(); // Will kill the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: console.log(`Hello, ${input}`);
  prefs: []
  type: TYPE_NORMAL
- en: askName();
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: askName(); // First Run.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: if(input === "exit") {
  prefs: []
  type: TYPE_NORMAL
- en: return interface.close(); // Will kill the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Chapter_8> node examples.js
  prefs: []
  type: TYPE_NORMAL
- en: Hello, what is your name?Mike
  prefs: []
  type: TYPE_NORMAL
- en: Hello, Mike
  prefs: []
  type: TYPE_NORMAL
- en: Hello, what is your name?John
  prefs: []
  type: TYPE_NORMAL
- en: Hello, John
  prefs: []
  type: TYPE_NORMAL
- en: Hello, what is your name?Ed
  prefs: []
  type: TYPE_NORMAL
- en: Hello, Ed
  prefs: []
  type: TYPE_NORMAL
- en: Hello, what is your name?exit
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: const readline = require('readline');
  prefs: []
  type: TYPE_NORMAL
- en: const interface = readline.createInterface({
  prefs: []
  type: TYPE_NORMAL
- en: input: process.stdin,
  prefs: []
  type: TYPE_NORMAL
- en: output: process.stdout,
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: const login = function() {
  prefs: []
  type: TYPE_NORMAL
- en: interface.question("Hello, what is your name?", (name) => {
  prefs: []
  type: TYPE_NORMAL
- en: user = name;
  prefs: []
  type: TYPE_NORMAL
- en: prompt();
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: const who = function () {
  prefs: []
  type: TYPE_NORMAL
- en: console.log(`User is ${user}`);
  prefs: []
  type: TYPE_NORMAL
- en: prompt();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: const prompt = function() {
  prefs: []
  type: TYPE_NORMAL
- en: interface.question("login, who OR exit?", (input) => {
  prefs: []
  type: TYPE_NORMAL
- en: if(input === "exit") {
  prefs: []
  type: TYPE_NORMAL
- en: return interface.close(); // Will kill the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: prompt();
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: if(input === "login") {
  prefs: []
  type: TYPE_NORMAL
- en: login();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: if(input === "who") {
  prefs: []
  type: TYPE_NORMAL
- en: who();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: const readline = require('readline');
  prefs: []
  type: TYPE_NORMAL
- en: const interface = readline.createInterface({
  prefs: []
  type: TYPE_NORMAL
- en: 'input: process.stdin,'
  prefs: []
  type: TYPE_NORMAL
- en: 'output: process.stdout,'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: var choice;
  prefs: []
  type: TYPE_NORMAL
- en: var user;
  prefs: []
  type: TYPE_NORMAL
- en: var cinema;
  prefs: []
  type: TYPE_NORMAL
- en: const login = function() {
  prefs: []
  type: TYPE_NORMAL
- en: interface.question("Hello, what is your name?", (name) => {
  prefs: []
  type: TYPE_NORMAL
- en: user = name;
  prefs: []
  type: TYPE_NORMAL
- en: prompt();
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: const who = function () {
  prefs: []
  type: TYPE_NORMAL
- en: console.log(`User is ${user}`)
  prefs: []
  type: TYPE_NORMAL
- en: prompt();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: const prompt = function() {
  prefs: []
  type: TYPE_NORMAL
- en: interface.question("login, who OR exit?", (input) => {
  prefs: []
  type: TYPE_NORMAL
- en: if(input === "exit") {
  prefs: []
  type: TYPE_NORMAL
- en: return interface.close(); // Will kill the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if(input === "login") {
  prefs: []
  type: TYPE_NORMAL
- en: login();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if(input === "who") {
  prefs: []
  type: TYPE_NORMAL
- en: who();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: prompt();
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Chapter_8> node .\Exercise8.06.js
  prefs: []
  type: TYPE_NORMAL
- en: login, who OR exit?login
  prefs: []
  type: TYPE_NORMAL
- en: Hello, what is your name?Michael
  prefs: []
  type: TYPE_NORMAL
- en: login, who OR exit?who
  prefs: []
  type: TYPE_NORMAL
- en: User is Michael
  prefs: []
  type: TYPE_NORMAL
- en: login, who OR exit?exit
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you created a basic interactive application using Node.js
    that lets the user choose from three inputs and outputs the result accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 8.01: Creating a Simple Node.js Application'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You have been engaged by a cinema company to create an application that allows
    customers to list the highest rated movies in a selected category. Customers should
    be able to provide a category and the responses within a named command-line list.
    They also need to provide details of their favorite movie to be captured within
    the favorite field. Finally, once all this is done, the customer should be able
    to `exit` the application, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"list"`: Ask the user for a genre, and then query the database for the top
    five movies in that genre, outputting the `ID`, `title`, and `favourite` fields.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"favourite"`: Ask the user for a film ID, and then update that film with a
    favorite field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"exit"`: Quit the interactive loop and the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This activity aims to create a small Node.js application that exposes an interactive
    input loop to the user. Within this loop, users can query information in the database
    by genre, as well as update records by ID. You will need to ensure that you also
    handle any errors that may occur from users' input.
  prefs: []
  type: TYPE_NORMAL
- en: You may complete this objective in several ways, but remember what we have learned
    throughout this chapter and attempt to create simple, easy-to-use code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following high-level steps will help you to complete this task:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `readline` and MongoDB libraries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create your `readline` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare any variables you will need.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function called list that will fetch the top five highest rated films
    for a given genre, returning the `title`, `favorite`, and `ID` fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You will need to ask for the category in this function. Look at the login method
    in *Exercise 8.05*, *Handling Inputs in Node.js*, for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a function called `favourite` that will update a document by title and
    add a key called `favourite` with a value of `true` to the document. (*Hint: You
    will need to ask for the title in this function using the same method you used
    for your list function.*)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the MongoDB connection, database, and collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an interactive while loop based on the user's input. If you're unsure
    how to do this, refer to our prompt function from *Exercise 8.05*, *Handling Inputs
    in Node.js*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the interactive loop, use if conditions to check for the input. If a
    valid input is found, run the relevant function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remember, you will need to pass the database and client objects through to
    each of your functions, including any time you call `prompt()`. To test your output,
    run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`list`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Horror`'
  prefs: []
  type: TYPE_NORMAL
- en: '`favourite`'
  prefs: []
  type: TYPE_NORMAL
- en: '`list`'
  prefs: []
  type: TYPE_NORMAL
- en: '`exit`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You may notice that the title `Nosferatu` appears twice in the output. If you
    look at the `_id` values, you will see that these are actually two separate films
    with the same title. In MongoDB, you may have many different documents that share
    the same values in their fields.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8: Final output (truncated for brevity)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_08_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.8: Final output (truncated for brevity)'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found via [this link](B15507_Solution_Final_SZ_ePub.xhtml#_idTextAnchor475).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered the basic concepts that are essential to the
    creation of a MongoDB-powered application using the Node.js driver. Using these
    fundamentals, a vast number of scripts can be created to perform queries and operations
    on your database. We even learned to handle errors and create interactive applications.
  prefs: []
  type: TYPE_NORMAL
- en: Although you may not be required to write or read applications like these as
    part of your day-to-day responsibilities, having a thorough understanding of how
    these applications are built gives you a unique insight into MongoDB development
    and how your peers may interact with your MongoDB data.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you are looking to increase your expertise with regards to the Node.js
    driver for MongoDB, this is just the beginning. There are many different patterns,
    libraries, and best practices you can use to develop Node.js applications against
    MongoDB. This is just the beginning of your Node.js journey.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dive deeper into improving the performance of your
    MongoDB interactions and create efficient indexes that will speed up your queries.
    Another useful feature we will cover is the use of `explain` and how to best interpret
    its output.
  prefs: []
  type: TYPE_NORMAL
