- en: Chapter 7. Adding a Menu and Routing Functionality Using vue-router and Nuxt.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we added a very important feature to our application
    – *authentication*. Now, our users are able to register, log in to the application,
    and manage their resources once they are logged in. So, now they can manage the
    configuration of the Pomodoro timer and their account's settings. They also have
    access to their statistics data once they are logged in. We have learned how to
    use Firebase's authentication API and connect the Vue application to it. I must
    say, the previous chapter has been extensive in learning and a very backend oriented
    chapter. I enjoyed it a lot and I hope you enjoyed it as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite having this complex feature of authentication and authorization, our
    application still lacks navigation. For simplicity reasons, we are currently displaying
    all the application''s parts on the main page. This is… ugly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a Menu and Routing Functionality Using vue-router and Nuxt.js](../images/00112.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Admit it, this is ugly
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are not going to make things beautiful. What we are going
    to do is make things navigable so that all parts of the application are accessible
    through navigation. We are going to apply the `vue-router` mechanism in order
    to achieve the natural browser''s navigation and we are going to use Bootstrap''s
    `navbar` in order to have the corresponding buttons to navigate to each section
    easily. Thus, in this chapter we are going to:'
  prefs: []
  type: TYPE_NORMAL
- en: Explore `vue-router` again to achieve the navigation of the ProFitOro application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Bootstrap's `navbar` to render the navigation bar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explore code splitting techniques to load each part of the application only
    when it's needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And, finally, we are going to explore the Nuxt.js template, rebuild our application
    using it, and achieve routing in an unobtrusive and enjoyable way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding navigation using vue-router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I hope you still remember from the second chapter what `vue-router` is, what
    it does, and how it works. Just to remind you:'
  prefs: []
  type: TYPE_NORMAL
- en: Vue-router is the official router for Vue.js. It deeply integrates with Vue.js
    core to make building Single Page Applications with Vue.js a breeze.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: -(From the official documentation of vue-router)
  prefs: []
  type: TYPE_NORMAL
- en: 'The `vue-router` is very easy to use, and we don''t need to install anything
    – it already comes with the default scaffolding of Vue applications with a webpack
    template. In a nutshell, if we have Vue components that should represent the routes,
    this is what we have to do:'
  prefs: []
  type: TYPE_NORMAL
- en: Tell Vue to use `vue-router`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a router instance and map each component to its path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass this instance to the options of a Vue instance or component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Render it using the `router-view` component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Check the official `vue-router` documentation: [https://router.vuejs.org](https://router.vuejs.org)'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you create your router, you should pass the array of routes to it. Each
    array item represents the mapping of a given component to some path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'ProFitOro only has four possible routes – the Pomodoro timer itself, which
    we can consider as the home page, views with settings and statistics, and the
    view with collaborative workouts. Thus, our router looks very simple and easy
    to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you import the created router in the `ContentComponent` view, pass
    it to the options of the component and render the `router-view` component, you
    will be able to see the Vue routing in action! You can also delete all the component
    imports, because the only thing that `ContentComponent` should actually import
    now is the router which will be responsible for everything else. So, `ContentComponent`
    will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Open the page, type `localhost:8080/settings`, `localhost:8080/statistics`,
    `localhost:8080/workouts` in the browser's address bar and you will see how the
    views appear according to what you are actually trying to access. You must admit
    that this was really easy.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's add the links, because we want to navigate by clicking some buttons
    and not by introducing the navigation URL in the browser address bar, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding navigation links with `vue-router` is fairly easy. Use the provided
    `router-link` component with the attribute `to` that points the link to the desired
    path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add these links in our `Header` component. This is the component that
    should be responsible for the navigation representation. So, in the `template`
    section of our `HeaderComponent.vue`, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t forget to import the router and export it in the component''s options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'With a bit of playing around with Bootstrap classes, we get something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding navigation using vue-router](../images/00113.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Navigating ProFitOro using vue-router
  prefs: []
  type: TYPE_NORMAL
- en: This is, in a nutshell, the basics covering routing and navigation using `vue-router`
    and its components. You can find the final code for this part in the `chapter7/1/profitoro`
    folder. Pay special attention to the router itself (`router/index.js`), `ContentComponent.vue`
    and the `HeaderComponent.vue` files.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise - restrict the navigation according to the authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Don't forget that we have to restrict the navigation links according to the
    authentication state of the user. If the user is authenticated anonymously, we
    shouldn't show the navigation links at all. However, there should be a button
    that enables users to go back to the main page. So, this button should invoke
    a logout functionality and just display a different text, let's say, **Go to the
    start page**. You already know how to conditionally render Vue components. Our
    router links are no more than just regular components, so apply the conditional
    rendering mechanism to them based on the value of the user and its property as
    `isAnonymous`.
  prefs: []
  type: TYPE_NORMAL
- en: Check the solution for this exercise in the `chapter7/2/profitoro` folder. Pay
    attention to the `HeaderComponent` component.
  prefs: []
  type: TYPE_NORMAL
- en: Using Bootstrap navbar for navigation links
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our current navigation bar is great – it''s functional, but not responsive.
    Luckily for us, Bootstrap has a `navbar` component that implements responsiveness
    and adaptiveness for us. We just have to wrap our navigation elements with some
    Bootstrap classes and then sit back and check our beautiful navigation bar that
    collapses on mobile devices and expands on desktop devices. Check Bootstrap''s
    documentation regarding the `navb` `ar` component: [https://v4-alpha.getbootstrap.com/components/navbar/](https://v4-alpha.getbootstrap.com/components/navbar/).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep in mind that this URL is for the alpha version. The next stable version
    4 will be available on the official website.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the classes we are going to use to transform our simple navigation
    bar into a Bootstrap-managed responsive navigation bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '`navbar`: This wraps the whole navigation bar element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`navbar-toggleable-*`: This should also wrap the whole navigation bar element
    and will tell it when to toggle between expanded/collapsed state (for example,
    `navbar-toggleable-md` would make navigation bar collapse on medium-size devices)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`navbar-toggler`: This is a class for the button that will be clicked to open
    the collapsed menu on small devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`navbar-toggler-*`: This tells the `toggler` element where to be positioned,
    for example, `navbar-toggler-right`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`navbar-brand`: This is a class for the navigation bar element that will represent
    a brand (can be logo and/or text)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collapse navbar-collapse`: These are classes that will wrap the navigation
    bar elements that should be collapsed on small devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nav-item`: This is a class for each of the navigation bar items'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nav-link`: This is a class for the nested element of the `nav-item` items;
    this will finally be an anchor that will lead you to the given link'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are lots of other classes to define a color scheme for your navigation
    bar, as well as its positioning, alignment, and so on. Check the documentation
    and try them all. I will just change the markup of the `Header` component. So,
    it will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You have probably noticed that I used our `router-link` elements with `nav-link`
    classes inside the navigation items. It turns out that they play really nicely
    together. So, we mixed the Vue routing mechanism with Bootstrap''s navigation
    bar and achieved an elegant solution for responsive routing in our Vue application.
    Now, our header looks as great as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Bootstrap navbar for navigation links](../images/00114.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: ProFitOro's navigation bar on desktop device
  prefs: []
  type: TYPE_NORMAL
- en: 'If we open our ProFitOro on a mobile device, we will see a nice toggle button
    instead of the menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Bootstrap navbar for navigation links](../images/00115.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is how ProFitOro's menu looks on a mobile device
  prefs: []
  type: TYPE_NORMAL
- en: 'If we click on the toggle button on the mobile device, the menu will expand
    vertically:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Bootstrap navbar for navigation links](../images/00116.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is how an expanded ProFitOro menu looks on a mobile device
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This works nicely with alpha version of Bootstrap 4, however, if you use Bootstrap
    4 Beta you will see some inconsistencies. Some classes were dropped, some classes
    were added. In order to make it to look exactly the same, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: replace the `navbar-tooglable-md` class with the `navbar-expand-lg`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: replace `btn-secondary` buttons' class with `button-outline-secondary` swap
    the toggler button and brand element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The functionality of conditional rendering based on the authentication has
    been dropped. I will re-add it, but instead of hiding the elements when the user
    is anonymous, I will make them disabled. This will bring extra value to the application
    – an unregistered user will constantly be reminded that there is some nice functionality
    that he can use if he registers. Thus, I will bind the `disabled` Bootstrap class
    to the `router-link` elements. This class will be activated if the user is anonymous.
    So, each of our router links will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you open the page now and enter the application as an anonymous user you
    will see that the links appear as disabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Bootstrap navbar for navigation links](../images/00117.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: For an unauthorized user the links appear as disabled
  prefs: []
  type: TYPE_NORMAL
- en: But, our user is smart, we all know that, right? Our user will do exactly the
    same thing that you are considering doing right now (if you haven't already done
    it) - open the developer tools console, go to the elements tab, edit the markup
    and remove the class `disabled`. *Ba-dum-tsss*, now you can click on the navigation
    links!
  prefs: []
  type: TYPE_NORMAL
- en: So, we need also to protect it on the router side. Fortunately for us, `vue-router`
    instance provides a hook method called `beforeEach`. This method receives both
    the next and previous routes and, inside it, you can evaluate them and invoke
    the `next()` method that will proceed to the next route or replace the path being
    invoked, depending on the condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, each route item can include the meta attribute where we can pass
    a condition on which this route can or cannot be invoked. Check the `vue-router`
    documentation in this regard: [https://router.vuejs.org/en/advanced/meta.html](https://router.vuejs.org/en/advanced/meta.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s add a meta attribute `requiresAuth` to each of three route items
    and use the `beforeEach` method like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Et voilá*, from now on, even if you explicitly type one of the conditional
    routes URLs in the browser''s address bar while being unauthorized, you will be
    redirected to the home page!'
  prefs: []
  type: TYPE_NORMAL
- en: Check the final code for this part in the `chapter7/3/profitoro` folder. Pay
    special attention to the router itself (`router/index.js`) and to the `Header`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: Code splitting or lazy loading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we build our application to deploy for production, all the JavaScript is
    bundled into a unique JavaScript file. It's very handy, because once the browser
    loads this file, the whole application is already on the client side and no one
    is worried about loading more things. Of course, this is only valid for SPAs.
  prefs: []
  type: TYPE_NORMAL
- en: Our ProFitOro application (at least at this stage) benefits from such bundling
    behavior – it's small, it's a single request, everything is in place and we don't
    need to request anything from the server for any of the JavaScript files.
  prefs: []
  type: TYPE_NORMAL
- en: However, this kind of bundling might have some downsides. I am pretty sure that
    you have already built or have already seen huge JavaScript applications. There'll
    always be some point when loading huge bundles will become unbearably slow, especially
    when we want these apps to run on both desktop and mobile environments.
  prefs: []
  type: TYPE_NORMAL
- en: An obvious solution for this problem would be to split the code in such a way
    that different chunks of code are loaded only when they are needed. This is quite
    a challenge for single page applications and this is why we have a huge community
    working on web development nowadays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right now, some simple techniques already exist in the web development world
    that can be used to split the code in webpack applications. Check the official
    webpack documentation to find out more about it: [https://webpack.js.org/guides/code-splitting/](https://webpack.js.org/guides/code-splitting/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use code splitting in a Vue.js application, you don''t need to
    do anything complex. There is no need to reconfigure your webpack configuration
    files and there is no need to rewrite your components. Check this documentation
    entry regarding lazy loading routes: [https://router.vuejs.org/en/advanced/lazy-loading.html](https://router.vuejs.org/en/advanced/lazy-loading.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**TL;DR**: in order to lazy load your routes, you just need to change the way
    you are importing them. So, consider the following code: `import PomodoroTimer
    from ''@/components/main/sections/PomodoroTimer''` To lazy load your routes, you
    would write the following instead: `const PomodoroTimer = () => import(''@/components/main/sections/PomodoroTimer'')`'
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the code remains totally unchanged!
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, we just change the way that we import components in our router:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: That's it! Check the page and ensure that everything still works as intended.
    Check the network panel. You will see that now it will request different JavaScript
    bundles for different route views!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you compare the network requests with the previous version, you will see
    that there are now actually four requests – `0.js`, `1.js`, `2.js,` and `3.js
    -` compared to the previous single `app.js` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code splitting or lazy loading](../images/00118.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A single request for app.js bundle before code splitting
  prefs: []
  type: TYPE_NORMAL
- en: 'After the code splitting, if we navigate through the application''s navigation
    links, we will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code splitting or lazy loading](../images/00119.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Considerably smaller JavaScript chunk is being requested for every route
  prefs: []
  type: TYPE_NORMAL
- en: Pay attention to the chunk sizes. Don't you agree that for big projects the
    code splitting technique might actually increase the application's performance?
    Check the router's code in the `chapter7/3.1/profitoro` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Server-side rendering** (**SSR**) recently became yet another popular abbreviation
    in the web development world. Used in addition to code splitting techniques, it
    helps you to boost the performance of your web application. It also positively
    affects your SEO, since all the content comes at once, and crawlers are able to
    see it immediately, contrary to cases where the content is being built in the
    browser after the initial request.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I found a great article about SSR that compares server and client side rendering
    (although it''s from 2012). Check it out: [http://openmymind.net/2012/5/30/Client-Side-vs-Server-Side-Rendering/](http://openmymind.net/2012/5/30/Client-Side-vs-Server-Side-Rendering/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s fairly easy to bring server-side rendering to your Vue application –
    check the official documentation in this regard: [https://ssr.vuejs.org](https://ssr.vuejs.org).'
  prefs: []
  type: TYPE_NORMAL
- en: It is important that our applications are performant; it is also important that
    SEO works. However, it is also important not to abuse the tools and not to introduce
    implementation overhead and overkill. Do we need SSR for the ProFitOro application?
    To answer this question let's think about our content. If there is a lot of content
    which is being brought to the page and is being used as a base for the initial
    rendering then the answer is probably yes. Well, this is not the case for our
    application. We have a simple login page, our ProFitOro timer, and a couple of
    configuration settings. The only view where it might make sense in the future
    is the one that contains workouts. But for now, let's not complicate things. You
    can try out server-side rendering techniques for Vue applications with our ProFitOro,
    but keep in mind that it's not something that should be used all the time. Learn
    the differences between server-side rendering and pre-rendering as well ([https://github.com/chrisvfritz/prerender-spa-plugin](https://github.com/chrisvfritz/prerender-spa-plugin))
    and check how our application could actually benefit from both of these techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Nuxt.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While we were busy defining our router object, router links, code splitting
    and learning things about the server-side rendering, someone implemented a way
    of developing Vue.js applications without being worried about all these things
    at all. Just write your code. All the things like routing, code splitting and
    even server-side rendering will be handled behind the scenes for you! If you are
    wondering what the hell it is, let me introduce you to Nuxt.js: [https://nuxtjs.org](https://nuxtjs.org).'
  prefs: []
  type: TYPE_NORMAL
- en: So, what is Nuxt.js?
  prefs: []
  type: TYPE_NORMAL
- en: Nuxt.js is a framework for creating Universal Vue.js Applications.
  prefs: []
  type: TYPE_NORMAL
- en: Its main scope is UI rendering while abstracting away the client/server distribution.
  prefs: []
  type: TYPE_NORMAL
- en: What's so great about it? Nuxt.js introduces the concept of pages – basically,
    pages are also Vue components, but each one of the pages represents a *route*.
    Once you define your components inside the `pages` folder they become routes without
    any additional configuration.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will totally migrate our ProFitOro to the Nuxt architecture.
    So, brace yourself; we are going to make lots of changes! At the end of the chapter,
    our efforts will be rewarded with a piece of nice, elegant code.
  prefs: []
  type: TYPE_NORMAL
- en: The Nuxt application has a single `config` file, where you can define the necessary
    webpack configuration, as well as `meta`, `links` and additional `scripts` for
    your `index.html` file. This is because Nuxt will generate your `index.html` automatically
    during the build process, so you don't have to have it in your application's root
    directory. In this config file, you can also define a transition that should happen
    on each route change.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way to create a Nuxt application is very similar to creating any Vue application
    – all Nuxt.js functionality is built in the `nuxt-starter` template: [https://github.com/nuxt-community/starter-template](https://github.com/nuxt-community/starter-template).
    So, creating the Vue.js application with a Nuxt template is just:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a `profitoro-nuxt` project and see how it works. Run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Click Enter to answer to the questions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the generated folder, install the dependencies, and run the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the page on `localhost:3000` and make sure that you see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Nuxt.js](../images/00120.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The initial default page of the Nuxt application
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore the folders' structure and the code. There's a folder called `pages`
    where you can find the `index.vue` page. There's also a folder called `components`
    – here we will store our components. There is a `nuxt.config.js` file where all
    the basic configuration is stored. In a nutshell, that's it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s work on the `pages` folder. What components of our ProFitOro application
    can we define as `pages`? It''s fairly easy to identify them, since we already
    have our defined routes. So, I would say that we can identify the following pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`index.vue`: This will check if the user is logged in and render either the
    login page or the Pomodoro timer page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`login.vue`: This page is identical to our current `LandingComponent.vue`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pomodoro.vue`: This will be the page that contains the Pomodoro timer component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`settings.vue`: This page will represent our `Settings.vue` component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`statistics.vue`: This page will be responsible for rendering the `Statistics.vue`
    component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`workouts.vue`: This page will be responsible for managing the workouts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create placeholders for all these pages. This is what my directory structure
    inside the `pages` folder looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the initial content of the `login.vue` page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'All the other pages are very similar to this one, except the `index.vue` page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If you open this application in your browser and try to type different paths
    (`localhost:3000/pomodoro`, `localhost:3000/settings`, and so on) in the browser's
    address bar, you will see how it actually renders the corresponding pages. How
    nice is that? We didn't have to define any routes or any additional configuration
    in order to achieve this behavior! Check the code for this part in the `chapter7/4/profitoro-nuxt`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Adding links with nuxt-link
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like `vue-router` provides a component called `router-link`, Nuxt provides
    a very similar component called `nuxt-link`. Let's change our `HeaderComponent`
    using nuxt-links instead of router-links and let's include this component inside
    our pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before doing that, let''s install `sass-loader`, because, if you remember,
    we are using the sass pre-processor for our CSS and our `HeaderComponent` is actually
    heavily relying on that. So, go ahead and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: I've also re-included Bootstrap styles, using its *sass* styles instead of plain
    CSS. Check out the `assets/styles` folder in the `chapter7/5/profitoro-nuxt` folder.
    Run `npm install` inside this folder and use this as your working directory for
    this part.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now copy our `HeaderComponent.vue` and `Logo.vue` to the `components/common`
    folder. Our logo''s markup will change. Before it was wrapped inside the `router-link`
    component and pointing to the home page. Instead of using `router-link` we will
    use the `nuxt-link` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we are binding the `src` attribute to the `src` value. We will get
    our source from the `assets` folder. In the Nuxt application, we can use the `~`
    notation to indicate the root directory of the application. Using this notation
    actually facilitates the usage of the relative paths. Thus, the source data attribute
    for the logo will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Our logo is ready; now it's time to check the `HeaderComponent` component and
    replace all the router links with `nuxt-links`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the just copied `HeaderComponent.vue` component and remove all the data
    used from the Vuex store for now and leave only the `import` of the `Logo` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, remove all the references to any data inside the markup, leave only the
    links and replace them with `nuxt-link` components. So, our links section will
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Import `HeaderComponent` to our pages (`settings`, `statistics`, `pomodoro`
    and `workouts`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the page. Check that our links haven''t changed at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding links with nuxt-link](../images/00121.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Our links look absolutely the same!
  prefs: []
  type: TYPE_NORMAL
- en: 'Check that even our responsiveness is still there. If you resize your page,
    you will see the Bootstrap''s menu button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding links with nuxt-link](../images/00122.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Menu button is still there as well
  prefs: []
  type: TYPE_NORMAL
- en: The most important part, of course, is that the routing works! Click on the
    links and check that the pages change.
  prefs: []
  type: TYPE_NORMAL
- en: Have you also noticed a nice transition happening when you change from one page
    to another?
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding links with nuxt-link](../images/00123.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The transition happens automatically, we haven't written any extra code for
    it to happen!
  prefs: []
  type: TYPE_NORMAL
- en: You can find the final code up to this point in the `chapter7/6/profitoro-nuxt`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – making the menu button work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have already checked, our responsive menu button is still there. However,
    if you click on it, nothing happens! This is because this button's behavior is
    defined in the `bootstrap.js` dependency and we still haven't included it. Use
    `nuxt.config.js` to include the necessary JavaScript files to make the menu button
    great again.
  prefs: []
  type: TYPE_NORMAL
- en: After you're done, check my solution in the `chapter7/7/profitoro-nuxt` folder.
    In particular, check the `head` section of the `nuxt.config.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: Nuxt.js and Vuex store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Well, there will not be anything new in this section – the Vuex store can be
    used in the exact same way it has been used before. Ah, wait. Inside the Nuxt
    application, we have to export the function that returns Vuex store and not an
    instance itself. Check the official documentation in this regard: [https://nuxtjs.org/guide/vuex-store](https://nuxtjs.org/guide/vuex-store).
    So, basically, we will not use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, we have to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Let's also use this opportunity to initialise the Firebase application in a
    separate file and use it as a singleton for our application. So, move the `firebaseApp`
    initialization to its individual `firebase/index.js` file and replace all the
    occurrences of the `state.firebaseApp` with the imported `firebaseApp` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last, but not least, don''t forget to install the required `vuexfire` and `firebase`
    dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Check the code for this part in the `chapter7/8/profitoro-nuxt` folder. In particular,
    pay special attention to the `store` and `firebase` folders.
  prefs: []
  type: TYPE_NORMAL
- en: Nuxt.js middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Do you remember how we had to introduce the `beforeEach` method to the vue router
    instance in order to prevent some routes from being rendered if the user is not
    authenticated? There is a very similar mechanism for Nuxt.js. You just have to
    define a so-called `middleware` where you can redirect the request based on some
    conditions (for example, on the value of the `isAuthenticated` attribute from
    the Vuex store) and then tell the pages that they have to rely on the authentication
    middleware. Then, every time that an attempted routing to the given page occurs,
    the middleware's function will run and do whatever it demands to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add this kind of middleware to our ProFitOro Nuxt application. Create
    a file `authentication.js` inside the folder `middleware` and add the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This piece of code is responsible for checking the `isAuthenticated` property
    and redirecting the user to the home page in case it's either false or undefined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the property middleware to the settings, statistics, and workouts
    pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Open the page and try to click on the corresponding links for the pages to which
    we just added the middleware. It will not work! Try to remove the middleware code
    for some of the pages and check that the routing then works. Isn't it fantastic?
  prefs: []
  type: TYPE_NORMAL
- en: Check the code for this part in the `chapter7/9/profitoro-nuxt` folder. Check
    the `middleware/index.js` file and Vue pages inside the `pages` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – finish 'em all!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Well, we've done a lot in order to make our ProFitOro into a Nuxt.js application,
    but our functionality is still not totally there. We still have to copy lots of
    components. So, please do it. Right now, it's just a matter of a good copy-paste.
    So, please do it and make sure that our ProFitOro works fine.
  prefs: []
  type: TYPE_NORMAL
- en: If in doubt, check the `chapter7/10/profitoro-nuxt` folder. You will probably
    run into the issue of trying to login with an *Enter* key and finding yourself
    being an anonymous user. This is a minor issue that will be fixed in the next
    chapters. For now, please, every time you try to login with your valid credentials,
    just don't forget to click the **LOGIN** button!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we have added basic routing to our application using different
    tools. First, we learned how to use vue-router to achieve routing functionality
    and then we used the Nuxt.js template to build a brand new application using old
    components and styles. We have used the concept of pages offered by Nuxt vue in
    order to achieve the same routing functionality as with `vue-router` and have
    transformed our ProFitOro application into a Nuxt application in an easy and unobtrusive
    way. We have significantly reduced the amount of code and learned something new.
    Total winners!
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we have also used Bootstrap's `navbar` to display our navigation
    routes in a nice and responsive way, and learned that even with the most drastic
    refactoring, the functionality and responsiveness stays with us when we use the
    Bootstrap approach. Once again – great success!
  prefs: []
  type: TYPE_NORMAL
- en: Our application is almost fully functional, however, it still lacks its main
    functionality – workouts. For now, during the Pomodoro intervals we are showing
    a hardcoded pushups workout.
  prefs: []
  type: TYPE_NORMAL
- en: Are you using the ProFitOro application while reading this book? If yes, I guess
    I will recognize you on the street – you will have huge muscles after doing so
    many pushups.
  prefs: []
  type: TYPE_NORMAL
- en: It's time to add more workouts to our application, don't you think? If you remember
    the requirements, workouts are the subject of collaborative work. So, we will
    add this functionality in the next chapter. We will use Firebase's data storage
    mechanism in order to store the workouts' images, the real-time database to store
    the workouts' objects, Bootstrap's cards layout to display different workouts
    and the Bootstrap-powered form in order to add new workouts to our application.
  prefs: []
  type: TYPE_NORMAL
