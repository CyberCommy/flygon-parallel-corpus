- en: Reactive Microservices Using C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have covered essential aspects of reactive programming using C++.
    Some of the key topics covered include:'
  prefs: []
  type: TYPE_NORMAL
- en: The reactive programming model and its cognitive prerequisites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The RxCpp library and its programming model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive GUI programming using Qt/RxCpp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing Custom Operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design patterns and the reactive programming model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you take a closer look, all examples so far in this book are related to what
    happens inside a process. Or, we were essentially focusing on shared memory parallel
    and concurrent techniques. The Rx.net, RxJava and most Rx implementations are  
    basically concerned with shared memory concurrent and parallel programming. A
    system such as Akka applies reactive programming model to the distributed world.
    In Akka, we can write reactive logic that spans processes and machines. The reactive
    programming model is also good for exposing REST-based web services and consuming
    them. The RxJs library is mostly used for consuming REST-based services from a
    browser page. The RxCpp library can be used for writing web clients for aggregating
    the contents from various service endpoints. We can leverage the RxCpp library 
    from  console and GUI applications. Another use case is aggregating data from
    multiple fine-grained services and delivering it to web clients.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will write a basic web application, using C++, that will
    leverage the Microsoft C++ REST SDK to write the server part and use the (C++
    REST SDK ) client library to consume those services. In the process, we will explain
    what micro-services are and how to consume them. We will also explain how the
    RxCpp library can be used to access REST endpoints and HTML pages ,by writing
    a wrapper on top of the `libcurl` library. We are planning to leverage Kirk Shoop's
    RxCurl library (written as part of his Twitter analysis application) to demonstrate
    this technique.
  prefs: []
  type: TYPE_NORMAL
- en: The C++ language and web programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, most web-centric applications are developed using Python, Java, C#,
    PHP, and other high-level languages. But, for these applications, people place
    reverse proxies, such as NGINX, Apache Web server, or IIS redirector, to manage
    the traffic . All of these reverse proxies are written in C++. Likewise, most
    of the web browsers and HTTP client libraries, such as `libwww`, `libcurl`, and
    `WinInet`, are written using C++.
  prefs: []
  type: TYPE_NORMAL
- en: One reason why Java, (statically-typed) C#, and other dynamic languages (such
    as Python, Ruby, and PHP) became popular is the fact that these languages support
    reflective capabilities (in the case of static languages, such as C#/Java) and
    duck typing (supported by dynamic languages). These features help web application
    servers to load  web page handlers dynamically. Read about them by searching for
    keywords such as *Reflection API* and *Duck Typing*.
  prefs: []
  type: TYPE_NORMAL
- en: The REST programming model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The REST, which stands for  **REpresentational State Transfer**, is an architectural
    style spearheaded by Roy Fielding as part of his PhD thesis. Nowadays, it is one
    of the most popular technique for exposing and consuming web services. REST follows
    a resource-centric approach and nicely maps to the CRUD pattern, which are popular
    among programmers who are well versed in writing enterprise business applications.
    We use **JavaScript Object Notation** (also known as **JSON**) as payload while
    writing REST services, instead of the XML format (which is in vogue for SOAP services).
    The REST programming model relies on HTTP verbs (GET,POST,PUT,DELETE and so on
    )to indicate the kind of operations to be executed while receiving a REST API
    call. The most popular methods supported are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`POST`: Creates a new resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET`: Retrieves a resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`: Updates an existing resource (if it''s a new resource, behaves like
    `POST`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: Deletes a resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The C++ REST SDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The C++ REST SDK is a Microsoft project for cloud-based client-server communication
    in native code using a modern asynchronous C++ API design. This toolkit aims to
    help C++ developers connect to and interact with HTTP based services. The SDK
    has the following features that help you to write robust services:'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP client/server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebSocket's client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: oAuth support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The C++ REST SDK relies on the parallel patterns library's task API. The PPL
    tasks is a powerful model for composing asynchronous operations based on modern
    C++ features. The C++ REST SDK supports Windows desktop, Windows Store (UWP),
    Linux, macOS, Unix, iOS, and Android.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP client programming using the C++ REST SDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The C++ REST SDK programming model is inherently  asynchronous in nature, and
    we can invoke the API calls in a synchronous manner as well. The following program
    will demonstrate how we can invoke HTTP client API calls asynchronously. The program
    demonstrates workings of the client side of the HTTP protocol supported by the
    C++ REST SDK. We use a technique called **task continuation** (a technique of
    chaining blocks of code) here to retrieve data from a web page and store it in
    a local disk file. The C++ REST SDK follows an asynchronous I/O model and we chain
    operations together. Finally, we invoke the composition using the `wait()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The above program demonstrate workings of the task continuation style of programming.
    The bulk of the code is about composing lambdas, and the actual execution starts
    when the `wait()` method is called. The lazy evaluation strategy of lambda functions
    helps us to compose code in the manner given above.We can invoke the logic in
    a synchronous manner as well. Consult the Microsoft C++ REST SDK documentation
    to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP server programming using the C++ REST SDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already learned about HTTP client programming model supported by the
    C++ REST SDK. We worked with the asynchronous task-continuation-based API to retrieve
    contents of a web page and persist it into a disk file. Now, it is time to start
    concentrating on the REST SDK HTTP server programming. The C++ REST SDK has a
    listener interface that will handle HTTP requests, and we can place handlers for
    each type of the HTTP verbs, such as `GET`, `PUT`, `POST and so on`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `SimpleServer` C++ class is basically a wrapper on top of the `http_listener`
    class supported by the C++ REST SDK. The class listens for the incoming HTTP request,
    and it is possible to set request handlers for each request type (`GET`, `POST`,
    `PUT`, and so on). When a request arrives, `http_listener` will dispatch request
    information to associated handlers, depending upon the HTTP verb.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code snippets bind request handlers to the `http_request` object.
    We are only focusing on the `GET`, `PUT`, `POST`, and `DELETE` verbs. These verbs
    are the most popular commands supported by all REST implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The above code block follows a pattern that can be easily deciphered by any
    developer. All the handler does is print the request parameters to the console
    of the server and return a string to the client to indicate that the request was
    successfully completed. (HTTP status code - 200)  We will show how we can access
    these services through the POSTMAN and CURL utilities in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The main function instantiates an  instance of the  `SimpleListener`  class
    through the `StartServer` function. Then, the `main` function waits for a key
    to be pressed before the `ShutDown` function is called. Once we have kick-started
    the application, we can use the `CURL` tool or `POSTMAN` to test whether program
    works or not.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the HTTP server using CURL and POSTMAN
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`CURL` is a command-line tool that is portable across Windows, GNU Linux, MacOS,
    and other POSIX compliant systems. The tool helps to transfer data using various
    TCP/IP-based application protocols. Some of the common protocols supported include
    HTTP, HTTPS, FTP, FTPS, SCP, SFTP, TFTP, DICT, TELNET, and LDAP,to name a few.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using the `CURL` tool to test the HTTP server we wrote. The command-line
    utility can be invoked by giving the requisite command-line parameters to place
    HTTP requests with associated verbs. We give the command-line parameters for invoking
    the `GET` and the `PUT` request to the server we wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Embed the previous command in a batch file or shell script, depending upon
    your platform. The output on the console should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, by consulting the `CURL` documentation, we can test the other HTTP
    verbs as well.
  prefs: []
  type: TYPE_NORMAL
- en: POSTMAN is a powerful HTTP client for testing HTTP based services. It started
    as a side project by an Indian developer by the name  Abhinav Asthana.  It was
    a Chrome plugin that went viral. Today, it is an independent platform and there
    exists a company formed around this application, where Mr. Asthana is the CEO.
    You can download POSTMAN tool to test these services. Since download  URLs can
    change, please consult your favorite search engine to find the download URL in
    vogue. ( search for "POSTMAN HTTP Client")
  prefs: []
  type: TYPE_NORMAL
- en: The libcurl and the HTTP client programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already come across the CURL utility, which is, in fact a wrapper on
    top of the `libcurl` library. We will use the libcurl  library to access REST
    services we wrote,in this chapter. To get you familiar with the libcurl library
    and its programming model, we will write a basic HTTP client using the library:
    The program will ping the  http://example.com.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The previous code pings the [http://example.com](http://example.com) URL to
    retrieve its contents and displays them on the console. The programming model
    is very simple, and the documentation of the library is really good. It is one
    of the most popular libraries for accessing the TCP/IP application services. In
    the next section, we will leverage a reactive wrapper on to top of the libcurl
    library.
  prefs: []
  type: TYPE_NORMAL
- en: Kirk Shoop's libCURL Wrapper library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary implementer of the RxCpp library is Kirk Shoop, who is currently
    associated with the Microsoft. He wrote a Twitter analysis sample app ([https://github.com/kirkshoop/twitter](https://github.com/kirkshoop/twitter))
    to demonstrate various facets of reactive programming. One of the things he did
    as part of the initiative was to write a reactive wrapper over `libcurl` to implement
    HTTP `GET` and `POST` methods. The authors of this book have extended his code
    to support the `PUT` and `DELETE` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the `RxCurl` library bundled with the source code of this book:
    (The listing is too big to be included here )'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We created an `observable` by using the `factory` class for creating the HTTP
    `request` object. The `map` function just retrieves body of the response object.
    The most important structure in the whole code is the `http_request` struct, whose
    definition is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of the http_request structure is pretty much obvious from the above
    declaration. The members are
  prefs: []
  type: TYPE_NORMAL
- en: url - the target URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: method - The HTTP verb
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: headers - HTTP headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: body - body of the request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `request` Observable can be subscribed for `on_next` using a lambda function
    that takes `observable<string>` ,as the `map` function returns `observable<string>`.
    In the body of the `on_next` function, we aggregate the content to produce a string
    using the `observable<string>::sum()` reducer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `response_message` Observable is subscribed with a lambda, which takes a
    string as the parameter. In the body of the `on_next` function, we simply assign
    the string containing the HTML to the `html` variable. Finally, we display the
    contents on to the console. Please take a look at the `rxcurl.h` header file to
    see how the library works.
  prefs: []
  type: TYPE_NORMAL
- en: The JSON and HTTP protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The payload format for invoking web services were once monopolized by the XML
    format. The SOAP-based services mostly support the XML format. With the advent
    of REST-based services, developers use **JavaScript Object Notation** (**JSON**)
    as the payload format.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows a comparison between XML and corresponding JSON object:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **XML** | **JSON** |'
  prefs: []
  type: TYPE_TB
- en: '| `<person>` `   <firstName>John</firstName>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`   <lastName>Smith</lastName>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`   <age>25</age>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`   <address>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`     <streetAddress>21 2nd`'
  prefs: []
  type: TYPE_NORMAL
- en: '`     Street</streetAddress>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`     <city>New York</city>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`     <state>NY</state>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`     <postalCode>10021</postalCode>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`   </address>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`   <phoneNumber>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`     <type>home</type>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`     <number>212 555-1234</number>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`   </phoneNumber>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`   <phoneNumber>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`     <type>fax</type>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`     <number>646 555-4567</number>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`   </phoneNumber>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`   <gender>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`     <type>male</type>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`   </gender>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`</person>` | `{` `   "firstName": "John",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`   "lastName": "Smith",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`   "age": 25,`'
  prefs: []
  type: TYPE_NORMAL
- en: '`   "address": {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`     "streetAddress": "21 2nd'
  prefs: []
  type: TYPE_NORMAL
- en: Street",`
  prefs: []
  type: TYPE_NORMAL
- en: '`     "city": "New York",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`     "state": "NY",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`     "postalCode": "10021"`'
  prefs: []
  type: TYPE_NORMAL
- en: '` },`'
  prefs: []
  type: TYPE_NORMAL
- en: '` "phoneNumber": [`'
  prefs: []
  type: TYPE_NORMAL
- en: '`   {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`     "type": "home",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`     "number": "212 555-1234"`'
  prefs: []
  type: TYPE_NORMAL
- en: '`   },`'
  prefs: []
  type: TYPE_NORMAL
- en: '`   {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`     "type": "fax",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`     "number": "646 555-4567"`'
  prefs: []
  type: TYPE_NORMAL
- en: '`   }`'
  prefs: []
  type: TYPE_NORMAL
- en: '`   ],`'
  prefs: []
  type: TYPE_NORMAL
- en: '`  "gender": {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`     "type": "male"`'
  prefs: []
  type: TYPE_NORMAL
- en: '`   }`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}` |'
  prefs: []
  type: TYPE_NORMAL
- en: 'The JSON format contains following data types:'
  prefs: []
  type: TYPE_NORMAL
- en: String
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object (JSON object)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us inspect a JSON object, to see how preceding data types are represented
    in the real world.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The mappings are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: The value is string type (`"john"`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`age`: The value is number (`35`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spouse`: This is a JSON object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`siblings`: This is an array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`employed`: This is a Boolean (`true`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have a better understanding of JSON and its core aspects, we will
    write a simple program that demonstrates usage of the JSON API, available as part
    of the C++ REST SDK:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `JSonToObject` static method converts a JSON object to the `EMPLOYEE_INFO`
    structure. `json::at` returns a reference to `json::value` based on the string
    that we used to index it. The resultant `json::value` reference is used to invoke
    the type-specific conversion methods, such as `as_string`, `as_integer`, and `as_double`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`ObjectToJson` is an instance method of `EMPLOYEE_STRUCT`, which helps to produce
    JSON output from the instance data. Here, we use conversion methods to transfer
    instance data to `json::value`. Next, we will focus on how we can create `json::object`
    from scratch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We create an `EMPLOYEE_INFO` struct and assign some values into the fields.
    We then invoke `EMPLOYEE_INFO::ObjectToJSon()` to create a `json::value` object.
    We call the `serialize()` method to generate the JSON textual output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code snippets demonstrate the use to parse textual strings to
    produce `json::value` objects. We invoked the `serialize` method to print the
    JSON string to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The C++ REST SDK-based REST server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we have leveraged code from Marius Bancila's excellent article
    about the C++ REST SDK. In fact, the key/value database code is borrowed from
    his implementation. The authors are thankful to him for the excellent article,
    available at [https://mariusbancila.ro/blog/2017/11/19/revisited-full-fledged-client-server-example-with-c-rest-sdk-2-10/](https://mariusbancila.ro/blog/2017/11/19/revisited-full-fledged-client-server-example-with-c-rest-sdk-2-10/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a micro-service application that puts everything together we have
    learned so far in the context of Microsoft C++ REST SDK. We will consume REST
    services by leveraging the RxCurl library written by Kirk Shoop, as part of his
    Twitter analysis application. We have added support to the DELETE and PUT verbs,
    as the original implementation contained only support for GET and POST verbs.
    The REST service implemented here supports the following verbs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`: Lists all the key/value pairs in the storage. The response will be in
    the `{ key:value,key:value}` format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`: Retrieves values corresponding to an array of keys. The request should
    be in the `[key1,...,keyn]` format. The response will be in the `{key:value,key:value....}`
    format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`: Inserts a collection of key/value pairs into the storage. The request
    should be in the `{key:value,key:value}` format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: Deletes an array of keys and their corresponding values from the
    storage. The request should be in the `[key,key]` format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s have a look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `RequestWorker` is a global function, that takes `http_request` as a parameter
    along, with a lambda with specific signature. The lambda takes two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: An input JSON object of the `json::value` type (a constant parameter)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An output JSON object that contains result from the lambda call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The JSON payload is extracted and passed to the `then` continuation. Once the
    data is retrieved, the handler lambda is invoked. Since the result is passed by
    reference, we can use the resultant JSON for generating the HTTP response. Now,
    we will create a simple key/value data store to simulate an industrial-strength
    key/value database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The key/value pairs are stored in an STL map for the sake of the ease of implementation.
    In the constructor, we initialize STL map with some records. We can use `PUT`
    and `POST` to add additional records, and `DELETE` for deleting records:  Let
    us dissect the source code of the function which handles GET requests.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GET_HANLDER` method will be invoked by the HTTP listener, when it encounters
    an HTTP `GET` verb as part of the request payload. After creating `json::value::object`,
    we stuff contents of the storage map into it. The resulting JSON object is returned
    to the HTTP client: Let us take a look at source code of the POST handler.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `POST_HANDLER` expects an array of JSON values in the body of request,
    and cycles through each element to retrieve the data corresponding to keys provided.
    The resultant object stores the returned value. If some keys are not present in
    the key/value DB, a  literal string ("notond") is returned to indicate that the
    value is not found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PUT_HANDLER` expects a list of key/value pairs in the JSON format. The
    collection of keys is iterated to do the lookup into the storage. If the key already
    exists in the storage, the value is updated, otherwise the key/value is inserted
    into the storage. A JSON object (result) is returned to indicate the action performed
    on each key (whether it was an insert or an update):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DEL_HANDLER` expects an array of keys as the input, and it cycles through
    the array to retrieve the data. If the key is already present in the storage,
    keys are added to a delete list (- an STL set). A JSON object (result) is populated
    with the kind of action taken on each key. The resultant object will be returned
    to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a functional simulated key/value database `engine`, we will
    use the functionality of the database to the outside world as a REST service endpoint
    with `GET`, `POST`, `PUT`, and `DELETE` commands. The HTTP handlers will just
    delegate the call to the `HttpValueDBEngine` instance. The code is very similar
    to the code that we wrote for the `SimpleServer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The above code binds HTTP verbs to the corresponding handlers. The bodies of
    the handlers are similar in character, as the handlers are just delegating the
    HTTPcall to the key/value engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The code for the HTTP controller is not different from `SimpleServer` ,which
    we wrote earlier in the chapter. We provided the listing here for the sake of
    completeness. With this, we have learned how to expose a REST service endpoint
    to the outside world, using the C++ REST SDK.
  prefs: []
  type: TYPE_NORMAL
- en: We have already discussed how we can expose a REST endpoint and how to write
    handlers for the various HTTP verbs. In a micro-services architecture style, we
    will have lot of REST endpoints deployed independently. The process of breaking
    a coarse-grained service into a micro-service is an art that is highly dependent
    upon context. The micro-services are exposed to outside world, sometimes through
    aggregation services.  An aggregation service will make request to multiple end
    points and the results from different endpoints will be aggregated, before responding
    to Its client. The aggregation services are a candidate for writing reactive client
    logic for accessing the REST micro-services. Since network calls are asynchronous,
    the reactive programming model is natural here.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking REST services using the RxCurl library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `RxCurl` library, written by Kirk Shoop, originally supported  `GET` and
    `POST` verbs. The Twitter analysis app only warrants that. The authors of the book
    have added support for the `PUT` and `DELETE` verbs.  You can refer to the source
    of `rxcurl.h` ,to  see necessary changes made to support these additional verbs,
    in the Github repository: Let us see how we can use the modified library to make
    calls to the REST server, we wrote above.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `factory` object, we can create request object by calling the `create`
    method. The `create` method expects:'
  prefs: []
  type: TYPE_NORMAL
- en: The URL endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The HTTP method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The body of HTTP request:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The above code creates a `request` object by composing creation of the HTTP
    request and a function to map from `http_response` to the HTTP body. There is
    an option to return chunks of data.  We are not using it here, as we expect only
    small amount of data as response.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The above code makes a blocking call to the  `observable` we created earlier.
    The body of the `subscribe` method''s `on_next` function concatenates the content
    to form another Observable. In real life, we can make this call in an asynchronous
    manner as well. That involves a little more programming effort. Moreover, the
    code listing won''t fit in the available page budget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `main` method demonstrates how we can invoke the `HttpCall` function created
    by us. The code has been provided to show how you can leverage the RxCurl library.
    We can use the library to issue multiple requests asynchronously and wait for
    their completion as well. The reader can tweak the code to support such a feature.
  prefs: []
  type: TYPE_NORMAL
- en: A word about the Reactive micro-services architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have learned how to write a microservices controller using the C++ REST
    SDK. Maybe we can say that the server we just implemented can be a microservice
    instance. In a real-life microservices architecture scenario, there will be multiple
    services hosted in different boxes (Docker containers or Virtual machines), and
    microservices controller will access these independently deployed services to
    cater to the client. The microservice controller will aggregate output from different
    services to send as a response to the client. A basic architecture for a microservice
    application is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6addcc36-9af8-4635-9f66-3691c9ebbc2f.png)'
  prefs: []
  type: TYPE_IMG
- en: In the previous diagram, the REST (HTTP) client makes an HTTP call to the microservices
    controller, which wraps `http_listener` object. The controller invokes three microservices
    to retrieve data, and the resultant data will be assembled or merged to provide
    a response to the REST client. The endpoints can be deployed in a container or
    in different containers, using technologies such as Docker.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to Martin Fowler:'
  prefs: []
  type: TYPE_NORMAL
- en: '"*The term "Microservice Architecture" has sprung up over the last few years
    to describe a particular way of designing software applications as suites of independently
    deployable services. While there is no precise definition of this architectural
    style, there are certain common characteristics around organization around business
    capability, automated deployment, intelligence in the endpoints, and decentralized
    control of languages and data*."'
  prefs: []
  type: TYPE_NORMAL
- en: The topic of microservices architecture is a subject in its own right, and the
    topic warrants a book of its own. What we have covered here is how we can leverage
    the C++ programming language to write web applications in this style. The description
    given here is meant to point readers to the right information. The reactive programming
    model is suitable for aggregating information from different service endpoints
    and presenting it uniformly to the client. The aggregation of services is the
    key concern, which ought to be further researched by the readers.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we talk about microservices architecture, we need to understand following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Fine-grained services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polyglot persistence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Independent deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service orchestration and Service choreography
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive web service calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss them in detail in following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Fine-grained services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traditional SOA- and REST-based services are mostly coarse-grained services
    and are written with a mindset in which reduction of network roundtrip is the
    core concern. To reduce the network roundtrip, developers often created payload
    formats that were composite (multiple data elements packed together ) in nature.
    So, an endpoint or a URI was used to handle more than one concern, and violated
    the principle of Separation Of Concerns. The microservices architecture expects
    services to perform a single responsibility, and payload formats are tailored
    for that. In this way, the service becomes granular.
  prefs: []
  type: TYPE_NORMAL
- en: Polyglot persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Polyglot persistence is a term used to denote the use of multiple storage technologies
    while persisting data. The term come from the term **polyglot programming**, where
    the choice of programming language is determined by the context. In the case of
    polyglot programming, we mix different programming languages. The authors of this
    book have come across systems that use Java for the application server code, Scala
    for stream processing,  C++ for storage-related concerns, C# for writing the web
    layer, and, of course, TypeScript/JavaScript for the client-side programming.
    In the case of polyglot persistence, we have the choice of using RDBMS, key/value
    stores, document databases, graph databases, columnar databases, and even time
    series databases.
  prefs: []
  type: TYPE_NORMAL
- en: An e-commerce portal is a classic example of a system where polyglot persistence
    can be really handy. Such a platform will deal with many types of data (for example,
    shopping cart, inventory, and completed orders). Instead of trying to store all
    of this data in one database, we might use RDBMS (to record transactions), key/value
    DBs (caching and lookup), a document database for storing logs, and so on. *Choose
    the right persistence model for your concern and context* is the main motto here.
  prefs: []
  type: TYPE_NORMAL
- en: Independent deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The biggest difference between microservices architecture and traditional SOA
    is in the area of deployment. With the evolution of container technologies, we
    can deploy services independently and in isolation, very easily. The DevOps movement
    helped a lot in popularizing the independent deployment model of services and
    applications. We can now automate the process of provisioning a VM and associated
    containers with CPU, memory, storage, additional disks, virtual networks, firewalls,
    load balancing, auto scaling  and so on, in deployment policies attached to a
    cloud service, such as AWS,Azure  or Google Cloud. Policies help you deploy microservices
    in an automatic manner, using automation scripts.
  prefs: []
  type: TYPE_NORMAL
- en: While developing applications using the microservices architectural style, the
    notion of container technology will pop up again and again. An associated movement,
    called DevOps, is brought into the realm of discussion. Covering DevOps and containerization
    (and cluster management) in the context of independent deployment is beyond the
    scope of this book. You can search for Docker, Kubernetes, and "Infrastructure
    as code", to gain more insight into these technologies.
  prefs: []
  type: TYPE_NORMAL
- en: Service orchestration and choreography
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with service orchestration. You put together several services by
    a fixed logic. This logic is described in a single place. But we might deploy
    multiple instances of same services, for availability. An aggregator service will
    call these services independently and aggregate the data for the downstream systems.
    On the other hand, in service choreography, the decision logic is distributed
    with no centralized point. A call to service will trigger multiple calls between
    services, before data reaches the downstream system. Service choreography requires
    more effort than implementing orchestration. You can read more about service orchestration
    and choreography by searching the web using your favorite search engine.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive web service call
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The processing of web requests is nicely mapped to the reactive programming
    model. In the case of applications with responsive UI, we typically make a call
    to the server once. An aggregator service running on the server will spawn a series
    of requests asynchronously. The resulting responses are aggregated to give a response
    to the UI layer. The modified `RxCurl` can be used as a mechanism to invoke multiple
    services in projects which use C++ programming language.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered how the Rx programming model can be used to write
    reactive microservices using C++. As part of the process, we introduced you to
    the Microsoft C++ REST SDK and its programming model. The C++ REST SDK follows
    an asynchronous programming model based on a technique called task continuation
    style, while writing client-side code. To write REST clients, we leveraged Kirk
    Shoop's `RxCurl` library, with some modifications to support the `PUT` and `DELETE`
    verbs. Finally, we wrote a REST server and consumed it in a reactive manner.In
    the next chapter, we will learn how to handle errors and exceptions using constructs
    available in the RxCpp library.
  prefs: []
  type: TYPE_NORMAL
