- en: '*Chapter 11*: Packet Capture and Analysis in Linux'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll be discussing packet capturing using Linux. In many respects,
    packets are the closest thing to the *truth* in the data center; the proverb that's
    frequently quoted is *Packets Don't Lie*. No matter what policies or convoluted
    configuration exists on hosts or firewalls, the host and application packets will
    always reflect what's happening. This makes packet capture and, more importantly,
    the analysis of those packets a key problem-solving and troubleshooting skill
    in the toolbox of a network administrator.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to packet capturing – the right places to look
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance considerations when capturing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capturing tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering captured traffic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting an application – capturing a VoIP telephone call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll capture packets. The initial setup and packet capturing
    use a physical switch that you may not have access to. However, once we start
    looking at the packets themselves, all of the capture files are available for
    download. Since the majority of this chapter is about analyzing and interpreting
    the captured packets, our existing Linux host should do nicely without undue modification.
    This is also a good way for us to ensure that when you are following the examples
    in this chapter, your display matches what we're describing.
  prefs: []
  type: TYPE_NORMAL
- en: Do feel free to build packet capturing into your lab, though, or better yet
    into your work environment. It's an extremely valuable tool in troubleshooting
    or just to get a better understanding of the various protocols and applications
    that we use every day!
  prefs: []
  type: TYPE_NORMAL
- en: 'The capture files that are referenced in this chapter can be found in the `C11`
    folder of this book''s GitHub repository: [https://github.com/PacktPublishing/Linux-for-Networking-Professionals/tree/main/C11](https://github.com/PacktPublishing/Linux-for-Networking-Professionals/tree/main/C11).'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to packet capturing – the right places to look
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are multiple ways to intercept and capture packets between two hosts,
    and multiple places in the communications path to do it from. Let's discuss some
    of the more popular choices.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing from either end
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is definitely the easiest option since when all is well, the hosts at
    both ends of the conversation will receive or send all packets. There are a few
    detractors to this, though:'
  prefs: []
  type: TYPE_NORMAL
- en: You may not have access to either end. Depending on the situation, one of the
    endpoint hosts may not be in your organization at all.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even if they do, you may not have administrative access to the host (or hosts)
    in your environment. Especially in a corporate environment, it's common to see
    that the networking team and/or security team may not have administrative access
    (or any access) on servers especially.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing new system software is not usually something you can do willy-nilly
    in most organizations. Most companies require a rigorous change control procedure
    for anything that might affect the operation of workstations or servers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even if a change request for installing a packet capture application is approved,
    odd applications like this can be a bone of contention for months or years after
    installation, where anything strange on the server in question might be blamed
    on "that weird application" that the networking team put on the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are troubleshooting a problem, you might not see the issue from the end
    that you have access to. For instance, if some or all of the packets aren't arriving
    at the server (or client), then capturing at the problem station may not help
    you in solving the problem – other than confirming that those packets aren't arriving,
    that is.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For these reasons, it's often preferred to capture packets at some mid-point
    in the path. A popular choice is to configure a switch port to *mirror* or *monitor*
    the traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Switching the monitoring port
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common situation is that we need to capture packets to or from a host but
    we're not able to access either host, can't interrupt the service, or can't get
    the necessary permissions to install packet capturing software. Since these situations
    are very common, switch vendors have implemented features to help us out. Most
    switches will have the facility to *mirror* or *monitor* traffic to or from a
    port. This is commonly called a **Switched Port Analyzer** (**SPAN**) configuration.
    From the switch, we simply configure what port we're monitoring, whether we want
    sent (Tx), received (Rx), or both directions of traffic, and which port we want
    the data to be sent to.
  prefs: []
  type: TYPE_NORMAL
- en: 'On a Cisco switch, for instance, in this configuration, we are monitoring the
    `GigabitEthernet 1/0/1` port (both send and receive), and our packet capture host
    is on the `GigabitEthernet 1/0/5` port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, these are defined for `monitor session 1`, which implies that
    yes, most switches will support more than one monitor session at a time. This
    can be expanded by monitoring for an entire VLAN (so the source might be VLAN
    7) or sending the packet capture to a remote destination, called a **Remote Switched
    Port Analyzer** (**RSPAN**) destination.
  prefs: []
  type: TYPE_NORMAL
- en: If there are firewalls or load balancers in the mix, be careful about which
    source port you define – your packet capture data will differ quite a bit if it
    is captured before or after NAT, for instance.
  prefs: []
  type: TYPE_NORMAL
- en: Where else can you look for packets in a particular conversation? Network devices
    are another popular choice here.
  prefs: []
  type: TYPE_NORMAL
- en: Intermediate in-line host
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this case, an intermediate host such as a router, switch, or firewall can
    capture traffic. Firewalls in particular are handy since in many cases, you can
    capture traffic both before and after NAT. This approach makes great sense if
    you are troubleshooting a well-defined problem. However, the following must be
    taken into account:'
  prefs: []
  type: TYPE_NORMAL
- en: Network devices usually have limited storage, so you'll need to keep the overall
    volume of packets within the storage capacity of the capturing device. On some
    devices, you can send your capture to a remote destination in real time to take
    this issue off the table, but there are issues with that as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In either case, the packet rate should be low. In many cases, local storage
    on these devices is relatively slow, and if the packet rates are high, sending
    the packet capture to a network destination in real time could result in lost
    packets in your capture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capturing packets will adversely affect the CPU of the capturing device. Be
    sure that your overall CPU utilization is low before considering adding a packet
    capture to the load on this device.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you send the captured packets to a remote destination, make sure that there
    is sufficient bandwidth to do that – if you exceed the bandwidth of the port,
    you will drop packets either on the capture side or the send side of this equation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All this being said, in many cases, you are looking for very specific packets
    in a stream to troubleshoot a problem so that you can craft a *filter* to collect
    just that traffic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A more complete description of using a Cisco router as a *collector* for packets
    can be found here: https://isc.sans.edu/forums/diary/Using+a+Cisco+Router+as+a
    +Remote+Collector+for+tcpdump+or+Wireshark/7609/.'
  prefs: []
  type: TYPE_NORMAL
- en: Other platforms' packet capture facilities are usually very similar – they create
    a *list* that defines the traffic of interest, then start the capturing process.
    Whatever your device, your vendor will have this documented more completely than
    what we can address here.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we'll look at the "purist" approach; that is, using a network tap.
  prefs: []
  type: TYPE_NORMAL
- en: Network tap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A tap is a hardware device that is inserted in-line into the traffic and allows
    full monitoring in either or both directions. Because it's traditionally an electrical/hardware
    solution, there's no quibbling about packet capacity; every bit in either direction
    is simply replicated electrically to the listening station. However, taps do cost
    money and require that you be on-premises. You also have to disconnect the Ethernet
    cable in question to put the tap in line. For these reasons, taps are still very
    handy to have, but are often not used anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical low-end tap (`10` or `10/100`) is the Ethernet "Throwing Star" by
    Michael Ossmann, which can be found at [https://greatscottgadgets.com/throwingstar/](https://greatscottgadgets.com/throwingstar/).
    The following diagram shows how a typical low-end (`10/100`) tap like this operates.
    Note that there are two ways to build a tap – as shown in the following diagram,
    you can construct a listen-only tap with two ports, each "listening" for traffic
    in one direction only:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Two tap ports, each in one direction'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_11_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.1 – Two tap ports, each in one direction
  prefs: []
  type: TYPE_NORMAL
- en: 'You also have the more traditional tap, which will "hear" traffic in both directions
    on a single port:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – One tap port sees all traffic (only pins)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_11_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.2 – One tap port sees all traffic (only pins)
  prefs: []
  type: TYPE_NORMAL
- en: This all worked until 1 GB Ethernet, at which point the signal loss of taps
    like this became a problem. 10 Gbps is even more complex to capture with a tap,
    in that the actual Layer 1 signaling no longer matches that of standard Ethernet.
    For these reasons, at 10 Gbps or above, taps are active devices, behaving more
    like switches with one or more SPAN ports than passive devices. The signal is
    still fully replicated to the destination ports, but there's more circuitry behind
    it to ensure that the signal that's sent to the actual source, destination, and
    capturing hosts can still be reliably read by all parties.
  prefs: []
  type: TYPE_NORMAL
- en: Where we do still see taps used is in some specific security settings, where
    1G, 10G, or faster traffic must be captured, but we also need electrical isolation
    to prevent any transmission.
  prefs: []
  type: TYPE_NORMAL
- en: Taps are still handy troubleshooting devices to keep in your laptop bag for
    the unusual situation where you need exactly this, but as noted, they are not
    often used anymore for run-of-the-mill packet captures.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we've described various legitimate methods of capturing packets, but
    how do the criminals and their malware get the job done?
  prefs: []
  type: TYPE_NORMAL
- en: Malicious packet capture approaches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we've considered how to legitimately capture packets. However, if you
    are considering malicious intent, how can you defend against an attacker that
    might use other methods? To do this, let's think like our attacker, and look at
    how they might set up a packet capture station without administrative access to
    anything.
  prefs: []
  type: TYPE_NORMAL
- en: The first method was covered in [*Chapter 7*](B16336_07_Final_NM_ePub.xhtml#_idTextAnchor118),
    *DHCP Services on Linux*. The attacker can mount a rogue DHCP server, and either
    make their host the default gateway or a proxy server (using the WPAD method)
    for the target computers. In either method, the victim's packets route through
    the attacker's host and can be captured. If the protocols are in clear text (for
    instance, using HTTP, TFTP, FTP, or SIP, as we'll see later in this chapter, in
    the *Troubleshooting* *an application – capturing a VoIP telephone call* section),
    these packets can either be stored for later analysis or even modified in real
    time. We can protect against attacks of this type by securing DHCP services (as
    we discussed in [*Chapter 7*](B16336_07_Final_NM_ePub.xhtml#_idTextAnchor118),
    *DHCP Services on Linux*).
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, an attacker can hijack a routing protocol to capture traffic for
    a specific subnet or host. We see this occasionally on the internet, where a subnet
    might be hijacked using the trusting nature of the BGP routing protocol. In these
    situations, we often see credit card portals being redirected to unexpected countries,
    where people's credentials are harvested as they log into the fake website that's
    ready for them there. How can a victim protect themselves in a case like this?
    Actually, it's both simpler and less reliable than you might think. If the victim
    receives a warning of an invalid certificate, they should close that session and
    not proceed. Unfortunately, while this is indeed a simple solution (that warning
    screen is almost full-page, and has lots of red in it), it's also not very reliable,
    as many people will simply click whatever it takes to dismiss the warning and
    proceed to the site.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other commonly seen method that an attacker can use to capture packets
    is called ARP cache poisoning. To understand this, you might need to review how
    ARP works ([*Chapter 3*](B16336_03_Final_NM_ePub.xhtml#_idTextAnchor053), *Using
    Linux and Linux Tools for Network Diagnostics*). At a high level, the attacker
    uses ARP packets to "lie" to each victim – this can easily be seen in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – ARP cache poisoning'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_11_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.3 – ARP cache poisoning
  prefs: []
  type: TYPE_NORMAL
- en: In this diagram, the two victims are `3333.3333.3333`, and telling `3333.3333.3333`.
    The switch doesn't see any of this; it just routes the various packets around
    since they're all technically valid. Now, when `3333.3333.3333`.
  prefs: []
  type: TYPE_NORMAL
- en: The attacker can expand this to off-network captures if **Victim 2** happens
    to be the default gateway for the subnet.
  prefs: []
  type: TYPE_NORMAL
- en: This seems somewhat complex, but it's been automated for many years now – the
    first tool for this type of attack was *dSniff*, written by *Dug Song* way back
    in 2000\. A more modern tool that uses a GUI and allows you to graphically select
    your various victims is Ettercap. Ettercap and its successor, Bettercap, have
    the advantage that as they see "artifacts of interest" such as credentials or
    password hashes, they will collect them automatically.
  prefs: []
  type: TYPE_NORMAL
- en: After the process is complete, when Ettercap closes, it gracefully repopulates
    the ARP table of all of the victim stations with the correct values. The implication
    of this is that if Ettercap closes in a non-graceful way (for instance, being
    kicked off the network or being "swamped" by too much traffic), the victim sites
    will be "stranded" with the wrong ARP entries, often for the duration of the ARP
    timer of each workstation. If the attacker station had the subnet's default gateway
    in its list, this situation will isolate the entire subnet for the duration of
    the ARP timer of the gateway (which can be up to 4 hours).
  prefs: []
  type: TYPE_NORMAL
- en: How can we protect against an attack of this type? Logging is a great start
    here. Most modern-day switches and routers will log a `Duplicate IP Address` error
    when it sees two different MAC addresses claiming to have the same IP address.
    Alerts on log entries of this type (see [*Chapter 12*](B16336_12_Final_NM_ePub.xhtml#_idTextAnchor216),
    *Network Monitoring Using Linux*) can help in starting a proactive incident response
    program.
  prefs: []
  type: TYPE_NORMAL
- en: Is there something more "active" that we can do? Most switches have a feature
    called **Dynamic ARP Inspection** (**DAI**) that will look for exactly this type
    of attack. When the attack is seen, the attacker's Ethernet port is disabled.
    You want to take care where this is implemented, though – don't configure DAI
    on a switch port that has a downstream switch or a wireless access point; otherwise,
    the attacker will take lots of innocent bystanders down with them when their port
    is disabled. Ports with downstream switches or APs are generally configured as
    "trusted," with the expectation that the downstream device will handle inspection
    for its own connected stations.
  prefs: []
  type: TYPE_NORMAL
- en: 'DAI looks very similar to DHCP inspection and trust configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As we mentioned previously, on switch ports that have downstream switches,
    APs, and so on, you can disable DAI with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To decrease the DAI ARP threshold from the default limit of 15 packets per
    second to something lower (10, in this example), you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If ARP inspection was enabled during an attack using a tool such as Ettercap,
    that tool will usually send a steady stream of ARP packets to its victims, to
    ensure that their ARP cache stays poisoned. In that situation, the affected switch
    would generate `DAI-4-"DHCP_SNOOPING_DENY" "Invalid ARPs"` error messages as the
    port threshold was exceeded. The port would also create the `ERR-DISABLE` status,
    taking the attacker offline completely.
  prefs: []
  type: TYPE_NORMAL
- en: In today's world of ever-increasing network speeds, though, you may find that
    you are in a position where the data being captured exceeds the capacity of your
    workstation – don't give up, though; there are optimizations that you can make
    that might help!
  prefs: []
  type: TYPE_NORMAL
- en: Performance considerations when capturing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we alluded to in the previous section, once the data rates start to go up,
    capturing packets can impact a host, even if it's a higher-end Linux host or VM.
    There are also some network decisions to make when you are setting up for a packet
    capture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Factors to consider include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: If you are using a SPAN or Monitor port, depending on the switch model, your
    destination port (the one your sniffer station is plugged into) may not be on
    the network – it might only see the traffic to and from the source. What this
    means is that often, you must use your fastest onboard NIC for packet capturing,
    and then use a lower performance USB NIC if that host needs to be active on the
    network at the same time (for instance, if you are remoting to it).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In all cases, ensure that your NIC is fast enough to actually "see" all of the
    target packets. Especially in a monitor port setup, you can configure a 10 Gbps
    source and a 1 Gbps destination. This will work fine until you start to see the
    traffic volumes exceed 1 Gbps. At that point, the switch will start to queue and/or
    drop packets, depending on the switch model. In other words, your mileage may
    vary, and your results may be unpredictable (or predictably bad).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once on the NIC, make sure that the NIC's upstream can handle the traffic volumes.
    For instance, if you are using a 10 Gbps Thunderbolt adapter on a laptop, be sure
    that it's plugged into a Thunderbolt port (not a USB-C port) and that you have
    sufficient bandwidth to add this new bandwidth. For instance, if you have two
    4K screens on that same laptop, chances are that there aren't 10 Gbps left on
    your Thunderbolt uplink for a high-speed packet capture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving up the line, make sure that your disk has both sufficient speed and capacity.
    If you are capturing 10 Gbps, you'll likely want to target an NVME SSD for storage.
    You'll likely also want it to be on-board, not plugged into the same Thunderbolt
    or USB-C adapter that you have your network adapter on. Alternatively, if you
    are using a server for capturing, take a look at the RAID or SAN throughputs available.
    Especially if the storage is iSCSI, be sure that your packet capture won't be
    "starving" other iSCSI clients of bandwidth to the SAN.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider the size of your ring buffer – tcpdump, in particular, has good flexibility
    regarding this. The ring buffer is the temporary area in memory that captured
    packets are stored in, before being sent to disk or the capturing application's
    memory. On most Linux systems, this defaults to 2 MB, which is usually more than
    adequate. However, if you see that your capture session seems to be missing packets,
    increasing this value might fix that issue. In tcpdump, this is easily adjusted
    with the `-B` parameter – this makes tcpdump an ideal tool to use when you know
    or suspect that you might be pushing the limits with your packet capture. Note
    that tcpdump does not document the default size for this; the 2 MB default is
    just what is commonly seen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider that you need the entire packet. If you only need the packet headers
    to troubleshoot your issue (in other words, you don't need the actual payload),
    you can adjust `snaplen` – the number of bytes to capture in each packet. For
    instance, decreasing this from `1500` to `64` can dramatically increase the number
    of packets that will fit into your ring buffer. You will want to ensure that the
    `snaplen` value is large enough to capture all of the packet header information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, there are also things to keep in mind if you are working as an attacker
    in a sanctioned security exercise such as a penetration test. If you are using
    ARP cache poisoning as part of your engagement, be aware that there is some measure
    of risk to this attack. Be sure that your station has sufficient interface bandwidth,
    CPU, and memory capacity to succeed in an attack of this type – if the **Man in
    the Middle** (**MiTM**) traffic exceeds your station's capacity, your machine
    will likely go offline. What that means to the victims (which could be the entire
    VLAN) is that they will be left with invalid ARP caches and will essentially be
    stranded for the duration of their ARP timers (up to 4 hours on some platforms).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With all the theory behind us, what tools will we be using to capture and analyze
    packets?
  prefs: []
  type: TYPE_NORMAL
- en: Capturing tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many different tools can be used to capture packets off the network and either
    analyze the packet data directly or store them in `pcap` files. There are even
    more tools that will take those `pcap` files and allow you to do further offline
    analysis on them.
  prefs: []
  type: TYPE_NORMAL
- en: tcpdump
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've referenced tcpdump several times. This is a command-line packet capture
    tool, which means that it can be used on systems that don't have a GUI or if you
    are using a non-GUI interface such as SSH. Because it's not dealing with any graphics
    and isn't preprocessing packets for you to look at (to tell you any of the protocol
    specifics for instance), it's one of the higher-performance, lowest-impact tools
    you'll find for packet capture.
  prefs: []
  type: TYPE_NORMAL
- en: tcpdump uses the **Berkely Packet Filter** (**BPF**) syntax to decide which
    packets to capture. This can be used to filter by IP address, MAC address, protocol,
    or even specific flags in a TCP packet.
  prefs: []
  type: TYPE_NORMAL
- en: Wireshark
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Wireshark is one of the more commonly used packet capture tools. It has a GUI,
    and each packet is categorized, color-coded, and massaged so that as much information
    is displayed as possible. Similar to tcpdump, Wireshark uses BPF syntax to filter
    packets during capture. It uses a different filter syntax to filter packets being
    displayed.
  prefs: []
  type: TYPE_NORMAL
- en: TShark
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TShark is packaged with the Wireshark application and is essentially a command-line/text
    version of Wireshark. Having TShark available can be very handy if you are in
    an SSH session and want something a bit more flexible than tcpdump.
  prefs: []
  type: TYPE_NORMAL
- en: Other PCAP tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are hundreds, if not thousands, of tools you can use to capture packets
    or analyze packet captures. On the attacker's side, we've already discussed Ettercap,
    Bettercap, and dsniff as MiTM attack tools. Tools such as NetworkMiner are great
    for either packet captures or processing existing packet captures. Tools like
    this allow you to save time in analyzing what can quickly become very large packet
    capture files. NetworkMiner will extract valuable artifacts from `pcap` files
    such as credentials, credential hashes, certificates, and data files that were
    transferred during the captured session.
  prefs: []
  type: TYPE_NORMAL
- en: We'll discuss more advanced tools that use packet capture, namely **Intrusion
    Detection Systems** (**IDS**), **Intrusion Prevention Systems** (**IPS**), and
    passive traffic monitoring, in the upcoming chapters ([*Chapter 13*](B16336_13_Final_NM_ePub.xhtml#_idTextAnchor236),
    *Intrusion Prevention Systems on Linux*, and [*Chapter 14*](B16336_14_Final_NM_ePub.xhtml#_idTextAnchor252),
    *Honeypot Services on Linux*).
  prefs: []
  type: TYPE_NORMAL
- en: What you will tend to find is that the reason you are doing a packet capture
    in the first place is to solve a problem. Let's discuss how to capture or view
    only the packets that apply to the problem you are working on.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering captured traffic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing that you will notice when using a packet capture tool is the
    sheer volume of packets that appear on the display. Since packet captures are
    often done for troubleshooting purposes, you usually want to limit the packets
    to the ones that have issues you need to solve. To that end, you typically either
    want to "filter" those packets during the capture process or filter the display
    of the packets once they have been captured. Let's discuss both situations.
  prefs: []
  type: TYPE_NORMAL
- en: Wireshark capture filters (capturing your home network traffic)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With no particular switch configuration, packet captures on your home network
    will find more than you might think. Lots of homes these days have a small herd
    of network-connected Linux-based appliances – if connected, your TV, thermostat,
    doorbell, treadmill, and fridge are likely all Linux hosts. These are commonly
    referred to as **Internet of Things** (**IoT**) devices. Almost all IoT hosts
    are likely broadcasting and multicasting a constant stream of "discovery" packets
    on your wired and wireless network, which they do to find controllers and hubs
    that might want to talk to them or even control them.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a quick look – we'll use the Wireshark tool for this.
  prefs: []
  type: TYPE_NORMAL
- en: Start the tool and select the network adapter that connects to your network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you hit **Start**, let''s add a capture filter. We''ll exclude our address,
    and also exclude ARP packets from the capture. Note that your IP address will
    be different:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Adding a capture filter to Wireshark'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_11_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.4 – Adding a capture filter to Wireshark
  prefs: []
  type: TYPE_NORMAL
- en: Now, hit the **Start Capture** button, the blue *shark fin* icon at the top
    left, or choose **Capture/Start**.
  prefs: []
  type: TYPE_NORMAL
- en: 'On a typical home network, you should have dozens of packets to explore within
    a few seconds – the following screenshot shows the packets after 10 seconds on
    my home network. You will likely see a mix of broadcast and multicast traffic
    – traffic that is, by definition, sent to all stations. While this might be seen
    as a limited capture, you can use this to start an inventory of what''s on your
    network:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5 – A typical home network capture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_11_005.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.5 – A typical home network capture
  prefs: []
  type: TYPE_NORMAL
- en: 'Even without exploring the packet''s contents, there are a few key things to
    note regarding the preceding screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: Some IPv4 devices are operating in the `169.254.0.0/16` range (the Automatic
    Private IP Addressing range). These addresses cannot route off your network, but
    for things such as TV remotes or doorbells talking to a controller on the local
    network, that's perfectly OK.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You'll likely see Spanning Tree traffic from your local switch, and if you wait
    long enough, you'll likely see **Link Layer Discovery Protocol** (**LLDP**) or
    **Cisco Discovery Protocol** (**CDP**) packets from switches as well (we'll see
    an example of this later in this section).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You'll also very likely see IPv6 traffic – in this capture, we can see `DHCPv6`
    and `ICMPv6` packets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All this from 10 seconds of listening! For fun, dig into your home network,
    even something as simple as looking at the MAC addresses you see, and identify
    the vendor for each using its OUI.
  prefs: []
  type: TYPE_NORMAL
- en: Let's dig deeper into a specific set of devices from a packet point of view
    – **Voice over IP** (**VoIP**) phones.
  prefs: []
  type: TYPE_NORMAL
- en: tcpdump capture filters – VoIP phones and DHCP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s explore capture filters in both tcpdump and Wireshark by looking at
    the boot-up sequence of a typical VoIP phone. Our network is pretty simple; there
    are four stations and two VLANs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6 – Lab setup for packet captures'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_11_006.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.6 – Lab setup for packet captures
  prefs: []
  type: TYPE_NORMAL
- en: Note that we have a monitor session set up, where port `5` receives all packets
    in and out of port `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A summary of the stations involved in the startup and communications of the
    VoIP phones is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16336_11_Table_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that as we go from left to right in the table, we're traveling down the
    "stack" that's represented by the ISO model – the extensions are represented in
    the application layer, IP addresses are Layer 4, MAC addresses and VLANs are Layer
    2, and finally we have the interfaces themselves.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's use tcpdump to capture a DHCP sequence on the DHCP server itself.
    Using this host is handy because the DHCP server is one end of the DHCP "conversation,"
    so if all is working well, it should see all of the packets in both directions.
  prefs: []
  type: TYPE_NORMAL
- en: Also, using tcpdump means that we're not dependent on any GUI – if you are operating
    from an SSH session, you are still fully supported. tcpdump is almost universally
    supported. tcpdump is installed by default on almost every Linux distribution,
    and in addition, you can call tcpdump (using one syntax or another) on most firewalls,
    routers, and switches – this isn't surprising, given how many of these platforms
    are Linux or BSD Unix-based.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get on with the capture. Because the source station doesn''t have an
    IP address yet, we''ll need to specify the traffic based on the MAC address of
    the phone and the two UDP ports used by DHCP: `67/udp` (bootps) and `68/udp` (bootpc).
    We''ll capture the full packets and write them to a file – note that *sudo* rights
    are needed for the actual capture.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, list the interfaces so that we get the source correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's capture some packets!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Our arguments included the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16336_11_Table_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the output, we can see the first few packets in the exchange – what we want
    to do is write this to a file, so let''s add `-w` for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's suppose that we don't have access to the DHCP server. Alternatively,
    if DHCP isn't working correctly, we might want a *network perspective* of the
    exchange, to maybe see why either the server or the client isn't receiving or
    sending DHCP packets. In this situation, remember that the client is a phone,
    so while it's very likely Linux-based, the vendor might not have made it easy
    to SSH to that platform to run tcpdump.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this situation, the typical solution is to set up a SPAN port, also called
    a `monitor` or `mirror` port (depending on the switch vendor). In this situation,
    our packet capturing host is in port `5`, so that will be the monitor session
    destination. The phone is in port `1`, so that will be our monitor session source.
    On a Cisco switch, this setup syntax looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To view the various monitor sessions in play, the `show` command would look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s set this up in Wireshark. This has a ton of advantages for us – not
    only will it syntax check our filter (note that it turns green when it''s valid),
    but we can also graphically pick our network adapter, and the packets are shown
    graphically during the capture. Again, after we select our capturing interface,
    the filter will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7 – Defining a capture filter in Wireshark'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_11_007.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.7 – Defining a capture filter in Wireshark
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the capture filter syntax is the same for Wireshark as it is for
    tcpdump; it uses what''s called BPF syntax. In this example, we added an `ether
    host` to the filter, to only capture DHCP packets to or from that MAC address.
    Press the **Start Capture** button (the blue *shark fin* icon at the top left
    of the window); we''ll see our DHCP sequence as the phone boots up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.8 – A full DHCP "DORA" sequence captured'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_11_008.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.8 – A full DHCP "DORA" sequence captured
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have a lab set up, you can collect this `pcap` file from our GitHub
    page ([https://github.com/PacktPublishing/Linux-for-Networking-Professionals/tree/main/C11](https://github.com/PacktPublishing/Linux-for-Networking-Professionals/tree/main/C11));
    the filename is `DHCP DORA Example.pcapng`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can simply expand the various data fields in the packet to show the various
    diagnostic values. Expand the DHCP section of the first frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.9 – Exploring the DHCP "Discover" packet'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_11_009.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.9 – Exploring the DHCP "Discover" packet
  prefs: []
  type: TYPE_NORMAL
- en: 'Scroll down and expand a few of the DHCP `Option` fields – in particular, `Parameter
    Request List`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.10 – DHCP options in the "Discover" packet'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_11_010.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.10 – DHCP options in the "Discover" packet
  prefs: []
  type: TYPE_NORMAL
- en: Note how many items are in the phone's *request list*. These offer a few great
    options for an attacker. In particular, if a malicious DHCP server can respond
    and give the phone a different TFTP server and Bootfile name, that file on the
    TFTP server has the entire configuration of the phone, including its extension
    and caller ID – pretty much everything.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, provisioning servers like this are almost always either TFTP or
    HTTP servers. What this means for an attacker is that if they can get an MiTM
    position between the client and the server (using Ettercap, Bettercap, or a similar
    tool), they can not only collect the configuration data for later use in the attack
    – they can also modify this data in real time, as the phone is downloading it.
  prefs: []
  type: TYPE_NORMAL
- en: This underscores just how important it is to secure both your DHCP services
    and VoIP provisioning services! Let's look at a more generic protocol we can use
    for both good and evil – LLDP and CDP.
  prefs: []
  type: TYPE_NORMAL
- en: More capture filters – LLDP and CDP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What else can we see as a station boots up? CDP and LLDP are the main Layer
    2 discovery protocols that you will see in most environments. These protocols
    will give us all kinds of useful information in troubleshooting or auto-documenting
    our network and stations. They also give an attacker that same information, which
    means that where you can, you'll want to limit these protocols, typically on any
    communication links that connect to other companies.
  prefs: []
  type: TYPE_NORMAL
- en: LLDP is required for almost all VoIP implementations, though – it's how the
    phones know which VLAN to be on in most cases (unless the VLAN is set in DHCP),
    and it's also how most phones negotiate their **Power over Ethernet** (**PoE**)
    power levels. Without LLDP, all phones would receive a full 15 watts of power,
    which would mean that any given switch would need to supply 6-7 times more power
    than it needs (most phones are in the 2-4-6 watt range).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at CDP (which multicasts to a Layer 2 address of `01:00:0c:cc:cc:cc`)
    and LLDP (which multicasts to `01:80:C2:00:00:0E` and has an Ethernet protocol
    of `0x88cc`). In this case, our capture filter will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, it will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The resulting capture shows that both LLDP and CDP are in play, but what can
    we see in the LLDP packet that the phone sends?
  prefs: []
  type: TYPE_NORMAL
- en: The information that we're seeking is all in the application section of the
    Wireshark display (the example file for this capture is both LLDP and CDP – `Phone
    Example.pcapng`). Open the file and highlight the **Link Layer Discovery Protocol**
    section of an LLDP packet. Note that the following data contains a lot of hexadecimal
    characters, but there's enough that translates into ASCII that you can see some
    useful data already!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.11 – A captured LLDP frame'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_11_011.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.11 – A captured LLDP frame
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, expand that LLDP tab so that we can look at some details in that section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.12 – Looking at the LLDP packet in more detail'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_11_012.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.12 – Looking at the LLDP packet in more detail
  prefs: []
  type: TYPE_NORMAL
- en: The phone has been set to auto speed and duplex and is negotiated to 100/Full.
  prefs: []
  type: TYPE_NORMAL
- en: The phone is a Yealink, Model T21P-E2, with a serial number of `805ec086ac2c`.
    It's running firmware version 52.84.0.15.
  prefs: []
  type: TYPE_NORMAL
- en: It is in the untagged (native) VLAN (the VLAN ID is `0`) and does not have `0`,
    so is the L2 priority).
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to collect the same information from the CDP packets in the capture
    file – remember that we filtered for both CDP and LLDP.
  prefs: []
  type: TYPE_NORMAL
- en: This may seem like a simple example, but all too often, networks are put together
    "organically" over years, with little or no documentation. At some point, the
    network will be complex enough, or the one person who knew how it all connected
    will leave the company – at that point, it will become important to document your
    network. If CDP or LLDP is enabled, this gives you an important tool to get a
    good start on this, with all IP addresses, model numbers, firmware, and connecting
    ports.
  prefs: []
  type: TYPE_NORMAL
- en: From an attacker's perspective, this same information can be used to identify
    hosts that might be good candidates for exploitation. You can use this same approach
    to collect this data, looking for a piece of infrastructure with a firmware version
    that has known vulnerabilities. That piece of gear can then become the next platform
    that the attacker will pivot to, using that host to collect further information
    to use in the next attack. This approach can easily be used to continue their
    attack into the next connected organization, maybe targeting the router or switch
    that our ISP has on our internet or MPLS uplink.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at extracting specific artifacts from a packet capture, such
    as files.
  prefs: []
  type: TYPE_NORMAL
- en: Collecting files from a packet capture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are working with a set of captured packets, or are in the middle of a
    packet capture, what options do you have if you see a file transfer go by? If
    it's using any TCP protocol, or a well-known UDP protocol (such as TFTP or RTP),
    it's as easy as pie!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see a packet capture (`file-transfer-example.pcapng` in our GitHub
    repository). Wireshark correctly identifies this as a TFTP file transfer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.13 – A packet capture containing a file transfer'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_11_013.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.13 – A packet capture containing a file transfer
  prefs: []
  type: TYPE_NORMAL
- en: Knowing that there are VoIP phones on this network, we suspect that these might
    be provisioning files – configuration files for the phones that get transferred
    during the bootup/initialization process. Let's take a closer look.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the first line, we can see a read request for a file called `SIPDefault.cnf`.
    This is indeed a high-value target as it provides the set of defaults for Cisco
    SIP Phones, if they are centrally provisioned. Highlight the first packet marked
    as **Data Packet** (packet 3). Right-click on it and choose **Follow | UDP Stream**.
    As you recall, there is no session data in UDP protocols, but Wireshark has decodes
    built in for many protocols, and TFTP is just one of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.14 – Collecting a transferred file from a PCAP – step 1'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_11_014.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.14 – Collecting a transferred file from a PCAP – step 1
  prefs: []
  type: TYPE_NORMAL
- en: 'Bingo! We have the file we''re looking for! Choose **Save as...** to "harvest"
    this file. Now, let''s see what else we might have:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.15 – Collecting a transferred file from a PCAP – step 2'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_11_015.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.15 – Collecting a transferred file from a PCAP – step 2
  prefs: []
  type: TYPE_NORMAL
- en: Close this window and clear out the display filter line in Wireshark so that
    we can see the whole capture again (clear out the text that says `udp stream eq
    1`).
  prefs: []
  type: TYPE_NORMAL
- en: Down on packet 15, we see a request for a second file called `SIP0023049B48F1.cnf`.
    Repeat the process we followed previously for this file – the transfer starts
    on packet 17, so follow the UDP stream that starts there. With this file in hand,
    we now have the SIP configuration for the phone with a MAC address of `0023.049B.48F1`.
    Looking at this file, we can see that this is the configuration file for extension
    `1412`, with a caller ID of `Helpdesk Extension 2`. This file contains the entire
    configuration of that phone, including the SIP password. With this information,
    an attacker can easily impersonate the helpdesk extension and collect confidential
    information from people calling the helpdesk using social engineering – a valuable
    piece of information indeed!
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's dig deeper into our telephony system and capture the audio from an
    actual VoIP phone call.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting an application – capturing a VoIP telephone call
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To do this, I'll keep our same capture setup and make a call from the client
    phone on port `G1/0/1` to the helpdesk call on `G1/0/2`. Capturing all the packets
    in and out of `G1/0/1` should get us what we need – for this interval, the traffic
    in and out of `G1/0/2` should be identical to `G1/0/1` (just in the reverse direction).
  prefs: []
  type: TYPE_NORMAL
- en: To capture our text, we'll simply do a full capture; no filters are needed in
    this case. We started our capture, ensuring that we caught the start and end of
    the call (so we started the capture before the dial, and ended it after the hang-up).
  prefs: []
  type: TYPE_NORMAL
- en: With the capture completed, we can look at our PCAP in Wireshark – the example
    file for this lab is `HelpDesk Telephone Call.pcapng`, which is located in our
    GitHub repository at [https://github.com/PacktPublishing/Linux-for-Networking-Professionals/tree/main/C11](https://github.com/PacktPublishing/Linux-for-Networking-Professionals/tree/main/C11).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at packet 6, labeled `Ringing`. Exploring the application data
    in this packet illustrates how easy it is to understand this data in many cases
    – SIP (when used in call setup) in particular follows what you might expect from
    using email:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.16 – Exploring a SIP "ring / INVITE" packet'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_11_016.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.16 – Exploring a SIP "ring / INVITE" packet
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at a few other SIP packets and explore some of the fields in the
    application data of each.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll look at the call itself. Notice that on packet 15, the protocol
    changes from SIP (on `5060/udp`) to `IP section` and then expand the `46` has
    been set:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.17 – DSCP bits in an RTP (voice) packet'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_11_017.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.17 – DSCP bits in an RTP (voice) packet
  prefs: []
  type: TYPE_NORMAL
- en: DSCP is a 6-bit field in the packet that tells the intervening network gear
    how to prioritize this packet. In this case, the value is set to `46` or **Expedited
    Forwarding**, or **EF** for short. This tells the switch that if there are several
    packets queued up, this one (and others with the same marking) should go first.
    In fact, the EF marking is unique in that it tells the network gear not to queue
    this packet at all (if possible).
  prefs: []
  type: TYPE_NORMAL
- en: The EF marking is unique in that it is not queued and is forwarded first to
    preserve the integrity of the voice stream and prevent artifacts such as "echo."
    It's also unique in that if the buffers fill to the point that this packet must
    be queued, often, the intervening network gear will drop a few of these packets
    rather than delay them. This is because the human ear is much more forgiving of
    a VoIP call where a few packets get dropped compared to these same packets being
    delayed.
  prefs: []
  type: TYPE_NORMAL
- en: If you check one of the SIP packets that's used in setting up the call, these
    all have a DSCP value of 26 (Assured Forwarding) – in other words, not expedited,
    but it's marked as a UDP packet that's of some importance. These markings request
    that if an interface or path is congested, then this packet should be buffered
    and not dropped.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s dive back into the application data in this RTP packet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.18 – RTP application data'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_11_018.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.18 – RTP application data
  prefs: []
  type: TYPE_NORMAL
- en: Note that this data is much simpler. For the most part, there's a bit of lead-in
    data that identifies that this packet is part of an ongoing phone call. This is
    packet (and frame) 4 of the call. The CODEC is identified so that the device at
    the far end knows how to decode the data. The majority of the packet is in the
    `Payload` field, which is voice data.
  prefs: []
  type: TYPE_NORMAL
- en: You can "follow" this stream by highlighting one RTP packet in the call, right-clicking
    on it, and selecting **Follow UDP Stream**. This extracts all of the RTP/voice
    data in the call so that it can be analyzed. In other protocols, you might select
    **Follow TCP Stream** or **Follow UDP Stream**, and then be able to recover an
    entire file (from an FTP or TFTP session, for example).
  prefs: []
  type: TYPE_NORMAL
- en: 'To recover a voice conversation, Wireshark has added a special handler. With
    this PCAP file open, choose `R` (for right) is making the call, while `L` (for
    left) is receiving the call. If you select the **Play** button, you can play the
    entire conversation back:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.19 – Playing back a captured VoIP conversation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_11_019.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.19 – Playing back a captured VoIP conversation
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, select any of the RTP packets and choose **Telephony | RTP |
    Stream Analysis**. Now, choose **Save** and choose any of the synchronization
    options (-0, for instance), **Unsynchronized Forward**, and **Reverse Audio**.
    This saves the file as an "AU" (Sun Audio) file, which can be played back by most
    media players, or converted into any other audio format that is desired:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.20 – Saving a VoIP conversation as a playable media file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_11_020.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.20 – Saving a VoIP conversation as a playable media file
  prefs: []
  type: TYPE_NORMAL
- en: This has some obvious implications for anyone running VoIP solutions. By default,
    most VoIP configurations do not encrypt the voice traffic. This is to remove encryption/decryption
    as a source of delay or jitter, two major causes of degraded voice quality. This
    means that in these situations, the voice data cannot be treated as "secure."
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that in our helpdesk call, the helpdesk person used the caller ID
    display to verify the caller's identity. This might work when all is well, but
    we've already described one way this can be compromised. An even simpler method
    is for an attacker to use packet captures to identify how the VoIP infrastructure
    works, then stand up a "soft phone" on their computer. In that situation, the
    attacker can define whatever they want for the caller ID; it's a simple text field.
    When the call is made, normally, the caller ID is supplied by the handsets rather
    than the PBX, so in this case, the helpdesk is tricked into performing a password
    reset.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, the phone boot-up sequence uses a provisioning service based on TFTP
    or HTTP. This downloads a configuration file based on the phone handset's "name."
    In many cases, the handset's "name" is the word `SIP`, followed by the MAC address
    of the phone – you can see these names in the phone's LLDP advertisements as well.
    This convention will vary with different handset vendors, but it is almost always
    a simple text string, combined with the handset MAC address. All an attacker needs
    to do to compromise the configuration of such a phone is MiTM between the configuration/provisioning
    server and the phone handset. This, plus the clear text nature of the configuration
    file, allows the attacker to modify key fields as the file is being downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: Wireshark display filters – separating specific data in a capture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sticking with our helpdesk call file, we can easily filter this file to only
    show specific traffic. For instance, when troubleshooting, it''s common to need
    to see just the SIP traffic – all too often the SIP gateway belongs to a cloud
    provider who often gets the setup wrong, resulting in SIP authentication issues
    or even getting the ACLs incorrect, so the login or even the initial connection
    fails. You can see all of these issues in the packets, so let''s filter for the
    SIP protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.21 – Filtering for SIP traffic only (call setup/teardown)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_11_021.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.21 – Filtering for SIP traffic only (call setup/teardown)
  prefs: []
  type: TYPE_NORMAL
- en: This shows the entire call setup, ringing, the pickup, and the final hangup
    (the `BYE` packet at `7848`, two lines from the bottom). We can also filter this
    by specifying `udp.port==5060`. Comparing this to the packet capture filters,
    note that the display filters use a different syntax, which ends up being much
    more flexible. Often, you'll capture with a filter that gets what you need, then
    filter again once you are in Wireshark, allowing you to drill down to get exactly
    what you want using multiple filters strung together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the `5882` missing packets between `14` and `5896`; that''s the conversation
    itself. Let''s filter just for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.22 – Filtering for RTP traffic (the voice conversation)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_11_022.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.22 – Filtering for RTP traffic (the voice conversation)
  prefs: []
  type: TYPE_NORMAL
- en: 'You typically only filter for RTP by protocol name, since the RTP ports will
    vary from call to call as they are negotiated during the SIP setup. By drilling
    down into the RTP packet, we can see that the ports are `12200` for `192.168.123.55`
    and `12830` for `192.168.123.53` (you can get the names and extensions from the
    SIP packets):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.23 – RTP ports in use for this conversation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_11_023.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.23 – RTP ports in use for this conversation
  prefs: []
  type: TYPE_NORMAL
- en: 'Where are these two ports negotiated? These are set up in SDP, which is part
    of the SIP exchange. The first SDP packet is in packet 4, where the caller at
    x1234 identifies their RTP port. Expand this packet, then scroll to the **Session
    Initiation Protocol (INVITE) | Message Body | Session Description Protocol | Media
    Description** section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.24 – Caller setting their RTP port'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_11_024.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.24 – Caller setting their RTP port
  prefs: []
  type: TYPE_NORMAL
- en: 'The SDP reply comes in packet 13, when the handset at the far end gets picked
    up. This is where the recipient (extension `1411` at `192.168.123.53`) comes back
    with its port; that is, `12830`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.25 – Call recipient setting their RTP port'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_11_025.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.25 – Call recipient setting their RTP port
  prefs: []
  type: TYPE_NORMAL
- en: 'You can filter for just the SDP packets by looking for `SIP and SDP` as a display
    filter (packets 4 and 15):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.26 – Filtering for SIP/SDP packets only'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_11_026.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.26 – Filtering for SIP/SDP packets only
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you look at the first packet, it's a failed invitation. You can
    dig into why that might be the case if you're interested!
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, you can take the approaches you learned here for analyzing the various
    VoIP protocols in this section and apply them to concrete problem-solving issues
    in your production environment.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we've covered how to use packet capturing tools, both from a
    legitimate troubleshooting point of view and from an attacker's point of view.
    In particular, we've covered how to position and configure things so that packets
    can be captured, what tools to use, and how to filter the "firehose" of information
    down to just what you need to solve the issue. Filtering in particular is very
    useful, which is why there is a two-stage filtering approach in place in Wireshark
    (at the time of capture and as the packets are being displayed).
  prefs: []
  type: TYPE_NORMAL
- en: We've covered the operation of a VoIP call in some depth, from booting a phone
    to making a call, to capturing and listening to the audio playback of a call.
    At this point, you should have some appreciation for the depth of functionality
    that is available in these tools for network, system, and application administrators.
    You should be well-positioned to take this appreciation to true mastery – just
    keep in mind that the best way to learn a tool such as Wireshark or tcpdump is
    to use it to solve a problem, or at least use it to learn something else (such
    as how DHCP works, or how a phone call works over a network, for instance).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll be discussing network monitoring, which will include
    logging, network monitoring systems that use SNMP, and the use of NetFlow and
    other flow-based protocols to monitor and troubleshoot networks.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material. You will find the answers in the *Assessments*
    section of the *Appendix*:'
  prefs: []
  type: TYPE_NORMAL
- en: Why would you use an endpoint host, an intermediate device over a SPAN port,
    for packet capture?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When would you use tcpdump as opposed to Wireshark?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What port does the RTP, which is used for VoIP conversations, use?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about what was covered in this chapter, please take a look at
    the following references:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Wireshark User''s Guide: [https://www.wireshark.org/docs/wsug_html_chunked/](https://www.wireshark.org/docs/wsug_html_chunked/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'tcpdump man page: [https://www.tcpdump.org/manpages/tcpdump.1.html](https://www.tcpdump.org/manpages/tcpdump.1.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SANS (January 2019) TCPIP and tcpdump cheat sheet: [https://www.sans.org/security-resources/tcpip.pdf](https://www.sans.org/security-resources/tcpip.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Wireshark Display Filters cheat sheet: [https://packetlife.net/media/library/13/Wireshark_Display_Filters.pdf](https://packetlife.net/media/library/13/Wireshark_Display_Filters.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Green, T. (2012, November 16). Analyzing Network Traffic With Basic Linux
    Tools*: [https://www.sans.org/reading-room/whitepapers/protocols/paper/34037](https://www.sans.org/reading-room/whitepapers/protocols/paper/34037)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Cheok, R. (2014, July 3). Wireshark: A Guide to Color My Packets*: [https://www.sans.org/reading-room/whitepapers/detection/paper/35272](https://www.sans.org/reading-room/whitepapers/detection/paper/35272)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*VandenBrink R (2009, November 18), Using a Cisco Router as a Remote Collector
    for tcpdump or Wireshark*: https://isc.sans.edu/forums/diary/Using+a+Cisco+Router+as+a+Remote+Collector+for+tcpdump
    +or+Wireshark/7609/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
