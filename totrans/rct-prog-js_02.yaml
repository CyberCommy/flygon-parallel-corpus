- en: Chapter 2. Core JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JavaScript is a good and a bad language rolled into one. There are some truly
    awful parts to JavaScript and some excellent parts. Overall, JavaScript is a dynamic,
    loosely typed, interpreted scripting language. The approach to the language as
    a whole is to explore it with emphasis on *The Good Parts* as described by Douglas
    Crockford, because of how bad the bad parts of JavaScript are: they are truly
    minefields. Crockford has had a profound influence on how JavaScript is used now;
    enough that the blog post titled *AngularJS: The Bad Parts* instantly, clearly,
    and completely telegraphs what sort of things will be dissected in painful detail.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics covered in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Strict mode**: Implicitly used in code including ECMAScript 6 modules'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Variables and assignment**: Some of the basic building blocks of programming
    in any language'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Comments**: There are two styles; we focus on one in preference to the other
    due to the ease of producing unintended behavior by having comments really begin
    or end somewhere other than where the programmer intended'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flow control**: A basic look at if-then, if-then-else, and switch statements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A note on values and NaN**: Notes on truthiness and the toxic *not a number*
    value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functions**: Illustration of JavaScript functions, one of the best parts
    of the language'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A few brief notes on ECMAScript 6**: The first truly radical change in core
    JavaScript in years'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The strict mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`"use strict";` as the first line of a file or function will cause certain
    things that can cause innumerable problems (such as assigning to a variable without
    declaring it) to cleanly error out with a line number called out, rather than
    leaving you to ferret out clues from any of a number of possible consequences.
    The `"use strict";` can also be the first line of a function, in which case the
    function is in strict mode.'
  prefs: []
  type: TYPE_NORMAL
- en: Perl users will know about the `-w` flag, possibly the best-known flag associated
    with the language, and its successor, Perl's use warnings pragma. The documentation
    says things like, opening the list of known bugs, *The behavior implied by the
    use warnings is not mandatory*.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript's strict mode by itself may or may not be on par with Perl's use
    warnings pragma, but it's at least something to make you get into the habit of
    using.
  prefs: []
  type: TYPE_NORMAL
- en: Variables and assignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variables should be declared with the `var` keyword. Any variable that is declared
    outside of a function, or any variable that is used without being declared, is
    a global variable, and global variables are a big problem; their place in *default
    JavaScript* is one of the major design flaws.
  prefs: []
  type: TYPE_NORMAL
- en: When there was a major public relations push for Java, JavaScript was named
    to run on Java's coattails, and certain decisions were made to make JavaScript
    code look like Java. These decisions were unfortunate. JavaScript is formally
    a C-like language and its most recent common ancestor with Java or C# is C, not
    C++ or Java. JavaScript has been described as being like Scheme in C's clothing.
    Lisp is a syntax associated with a family of languages including Scheme, Common
    Lisp, Clojure, and ClojureScript, and it is arguable that the increasingly functional
    emphasis in pursuit of the best JavaScript is from ClojureScript. In JavaScript,
    there are no separate integer and float types; numbers are 64-bit floating point
    values that behave like integers when used within a certain long range. However,
    they do sometimes give surprises to new programmers; for example, 0.1 + 0.2 does
    not equal 0.3, for historical reasons that also plague innumerable other languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basic variable assignments can look C-like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If a variable is declared without being assigned, as `x` in the preceding example,
    its value will be undefined.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We will avoid the use of the last of the three listed in the preceding example,
    as it is not considered one of The Good Parts. Douglas Crockford, in one of his
    videos, recounts a tale where he gave an hour long eloquent defense of the `++y`
    usage, and then had an interminable debugging session in which the subtleties
    of `++y` had bitten him. Unlike the first two options in the preceding example,
    one can assign a value to it, and `++y` and `y++` are not the same. Crockford
    then magnanimously backed down from his earlier position.
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most languages support comments in some form. Besides explanation of the code,
    they are also used to temporarily deactivate the code. JavaScript has the comments
    that would be expected of a language made to look like Java; however, Javadoc
    comments are not natively special (various solutions such as JSDoc have been made
    to fill the gap).
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript supports both classes of C++ comments. The first three lines contain
    only a comment and no executable code, the last line has a line of code and then
    a comment until the end of the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We will be avoiding the multiline comments. Asterisks and slashes occur often
    enough in regular expressions that multiline comments can be tripped up, and regular
    expressions may be required by a context or written by someone else in code that
    will still trip unintended effects. Inline comments, by their nature, are less
    vulnerable to surprise effects.
  prefs: []
  type: TYPE_NORMAL
- en: Flow control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If-then and if-then-else works as described in the following example code,
    one of which does something if a number is nonzero, and the other of which takes
    one action if a number is nonzero and another if it is false. Both use truthiness
    in that 0 (and NaN) are falsy, while any other value is truthy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: A note on values and NaN
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All values can be used in Boolean context and tested for truthiness. The values
    `undefined`, `null`, `''`, `0`, `[]`, `false`, and `NaN` (Not a Number) are `falsy`
    and all the other values are `truthy`.
  prefs: []
  type: TYPE_NORMAL
- en: '`NaN` in particular is a special case and it does not behave like other *real*
    numeric values. `NaN` is toxic; any calculation that includes `NaN` will give
    a result of `NaN`. Furthermore, although `NaN` is `falsy`, it does not equal anything,
    including `NaN` itself. The usual way of checking for `NaN` is via the `isNaN()`
    function. If you find `NaN` lurking somewhere unexpected, you might give debugging
    log statements for code, leading to where you detected `NaN`; there may be some
    distance between where `NaN` was first generated and where you observed it corrupting
    your results.'
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a function, by default, control flows from the beginning to the end, and
    the function returns `undefined`. Optionally, there can be a return statement
    before the end, and the function will stop execution and return the value in question.
    The following example illustrates a function with a return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The previous function takes two parameters, although functions can be given
    (without an error or error message) fewer or more arguments than the declaration
    specifies. If they are declared to have values, those values will be present as
    local variables (in the preceding example, `first` and `second`). In any case,
    the arguments are also available in an array-like object called `arguments` which
    has a `.length` method (arrays have a `.length` method which is one greater than
    the highest position of an item), but not the rest of an array's features. Here
    we make a function that can take any arbitrary number of *Number arguments*, and
    returns their (arithmetical) average by using the `arguments` pseudo-array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Basic data types include number, string, Boolean, symbol, object, null, and
    undefined. Objects include function, array, date, and RegExp.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that the objects include the functions means that the functions are
    values and can be passed as values. This facilitates higher-order functions, or
    functions that take functions as values.
  prefs: []
  type: TYPE_NORMAL
- en: 'For an example of a higher-order function, we will include a `sort` function
    that sorts an array and optionally accepts a comparator. This builds on function
    definitions, actually containing a function definition within a function definition
    (which is perfectly legal as anywhere else), and then an implementation of QuickSort
    where values are divided into *compares as less than the first element*, *compares
    as equal to the first element*, and *compares as greater than the first element*,
    and the first and last of these three are recursively sorted. We check for nonempty
    length before sorting, in order to avoid infinite recursion. An implementation
    of the classic QuickSort algorithm, here implemented as a higher-level function,
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Comments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are several basic features and observations to note regarding this function,
    which is not intended to be pushing the envelope, but demonstrate how to cover
    standard bases well:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We use `var sort = function()...` rather than the permitted `function sort()...`.
    When used within a function, this stores the function in a variable, rather than
    defining something globally. Note that it may be helpful in debugging to include
    a name for the function, `var sort = function sort()...` to access the function
    only through the variable, and let debuggers pick up on the second. For example:
    `sort` rather than referring to the function anonymously. Note that with `var
    sort = function()`, the variable declaration is hoisted, not the initialization;
    with `function sort()`, the function value is hoisted, available anywhere within
    the current scope.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is a standard way of checking to see if only one of the two arguments
    has been specified, that is if an array has been provided without a sort function.
    If not, a default function is provided. We run a few trial runs of sorting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us an opportunity to debug. Now, let''s suppose we add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Before the declaration of result, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output that says `Same: a,1,3,2,11,9` looks suspicious, a `Same` bucket
    should have identical values, so that an appropriate output might be `Same: 2,2,2`
    or just `Same: 3` where the `Same` list has five values, no two of which are alike.
    This can''t be the behavior we intended. It appears that the integers are being
    classified as the same as the initial "a", and the rest of it is being sorted.
    A little investigation confirms that ''`"a" < 1`'' and ''`"a" > 1`'' are both
    false, so our comparator could be improved.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We make a dictionary order sort of their types. This is somewhat arbitrary
    to sort first on alphabetical order of type, and then on the default sort order
    within types defaults which could be overridden with another comparator. This
    is an example of another of the many kinds of comparators one might use to sort
    an array: this one, unlike the previous one, segments different kinds of items
    such as Numbers sorted in order, and will appear before Strings, sorted in order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `typeof` function returns a string containing a description of a type; thus
    `typeof` can offer an extended type. With a comparator function similar to this,
    one can meaningfully compare objects such as records that hold a first name, a
    last name, and an address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Objects can be declared via curly brace notation. Blocks of code and objects
    can both use curly braces, but these are two separate things. The following code
    with its braces, is not a block of code with statements to execute; it defines
    a dictionary with keys and values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Unless a key is a reserved word or contains a special character, as `'strange.key'`
    does (here a period), the quotation marks around a key are optional. JSON formatting,
    in order to have a simple and consistent rule, requires quotes in all cases, and
    specifically double quotes, not single.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a record having a first name, a last name, and email address,
    perhaps populated via JSON, is shown next. This example is not JSON because it
    does not follow JSON''s rules about double quoting all keys and all strings, but
    it illustrates an array of records which could have other fields and could be
    much longer. It may make sense to sort by distance or seniority (with populated
    fields not shown here): there is a whole world of possible comparators one might
    use for records.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note that a trailing comma is not merely inappropriate in JavaScript (after
    the last entry in almost anything separated by commas), but it has some strange
    and unexpected behavior which can be extremely hard to debug.
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript was designed to have semicolons at the end of a statement which
    may be optional. This is a debatable decision, and was tied to a decision to make
    a popular language that regular non-programmers could use without involving IT
    people, a factor also involved in the design of SQL. We should always supply semicolons
    when they are appropriate. One side effect of this is that `return` alone on a
    line will return undefined. This means that the following code will not have the
    desired effect and will return undefined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The effect as the code is executed is different from what it appears to be and
    probably what was intended, so it is advisable to not do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the desired effect, the open curly brace should be on the same line
    as the return statement, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'However, JavaScript does have an object-oriented programming that avoids a
    classical difficulty in object-oriented programming: having to get the ontology
    right the first time. Objects are usually best constructed, not as instances of
    a class, but by factories. Or so Douglas Crockford has been abbreviated. Prototypes
    are still part of the language, like many features good and bad, but barring esoteric
    use cases objects should usually be made by factories that allow for a "better
    than ontology-driven classes" approach to object-oriented programming. We will
    be avoiding the pseudo-classical new `function()`, not because it can clobber
    global variables if you ever forget the new, but because its semblance of traditional
    object-oriented programming does not really help that much.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should be aware of a wide-respected convention in JavaScript that constructors
    intending to work with `new` begin with a capital letter. If a function name begins
    with a capital letter, it is intended to be used with the `new` keyword, and strange
    things may happen if it is invoked without the `new` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: In JavaScript, the interests served by classical object-oriented programming
    in some other languages are sometimes best advanced by functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Loops include the `for` loop, the `for in` loop, the `while-do` loop, and the
    `do-while` loop. The `for` loop works as in C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `for in` loop will loop over everything in an object. The `hasOwnProperty()`
    method can be used to examine only an object''s fields. The two variants, for
    an object named `obj`, are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This will include any fields from the prototype chain(not explained here).
    To check things that are direct properties of an object itself, and not potentially
    noisy data from a prototype chain, we use an object''s `hasOwnProperty()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Ordering is not guaranteed; if you are looking for any specific fields, it is
    worth considering to just iterate over the fields you want and check them on an
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Taking a look at ECMAScript 6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript tools have been booming, with one tool being eclipsed by another
    and an incredibly rich ecosystem that few developers can boast knowing both broadly
    and deeply. However, the core language, ECMAScript or JavaScript, has been stable
    for several years.
  prefs: []
  type: TYPE_NORMAL
- en: ECMAScript 6, with one introductory roadmap available from [http://tinyurl.com/reactjs-ecmascript-6](http://tinyurl.com/reactjs-ecmascript-6),
    introduces profound new changes and expansions to the core language. As a rule,
    these features enhance, deepen, or make more consistent the functional aspects
    of JavaScript. It might be suggested that ECMAScript 6 features that do not do
    this kind of work, such as enhanced class-oriented syntactic sugar to let Java
    programmers pretend that JavaScript means programming in Java, may be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: ECMAScript 6 features are a force to reckon with and at the time of this writing
    have more than started to make their way into the mainstream browsers. If you
    want to expand and improve your value as a JavaScript developer, don't restrict
    yourself to digging deeper into the rich JavaScript ecosystem, no matter how important
    that may be. Learn the new JavaScript. Learn an ECMAScript with heaping mounds
    more better parts.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this whirlwind tour of some of JavaScript's better parts, we have covered
    foundational building blocks that can be helpful as we push further in JavaScript.
    These include variables and assignment, comments, flow control, values, NaN functions,
    and ECMAScript 6.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Variables and assignment* section, we threw light on some basic building
    blocks of most programming, although the emphasis in functional reactive programming
    may lie elsewhere. In the *Comments* section, we understood how comments are the
    same everywhere, but the main concern here is to prevent strange surprises.
  prefs: []
  type: TYPE_NORMAL
- en: The *Flow control* section covered basic flow control within a function (or
    possibly outside of any function, although that is usually to be avoided).
  prefs: []
  type: TYPE_NORMAL
- en: In the section *A note on values and NaN*, we discussed that similarly to Perl,
    JavaScript holds truth to be self-evident; that is, the things are falsy if they
    are null, zero, empty, Not a Number, and so on, and true for anything not on the
    list.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Functions* section, we got a look at the functions that included a somewhat
    involved example. In the section *ECMAScript 6,* we discussed how the core JavaScript
    language is expanding.
  prefs: []
  type: TYPE_NORMAL
- en: This has been a brief tour of highlights, not a comprehensive tour. If you need
    a more comprehensive grounding in JavaScript, there are multiple options available
    to you. We will continue in the next chapter with basic theory for reactive programming.
  prefs: []
  type: TYPE_NORMAL
