- en: Chapter 3. When Objects Are Alike
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the programming world, duplicate code is considered evil. We should not have
    multiple copies of the same, or similar, code in different places.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways to merge pieces of code or objects that have a similar
    functionality. In this chapter, we''ll be covering the most famous object-oriented
    principle: inheritance. As discussed in [Chapter 1](ch01.html "Chapter 1. Object-oriented
    Design"), *Object-oriented Design*, inheritance allows us to create *is a* relationships
    between two or more classes, abstracting common logic into superclasses and managing
    specific details in the subclass. In particular, we''ll be covering the Python
    syntax and principles for:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Basic inheritance
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheriting from built-ins
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple inheritance
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism and duck typing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic inheritance
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Technically, every class we create uses inheritance. All Python classes are
    subclasses of the special class named `object`. This class provides very little
    in terms of data and behaviors (the behaviors it does provide are all double-underscore
    methods intended for internal use only), but it does allow Python to treat all
    objects in the same way.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'If we don''t explicitly inherit from a different class, our classes will automatically
    inherit from `object`. However, we can openly state that our class derives from
    `object` using the following syntax:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is inheritance! This example is, technically, no different from our very
    first example in [Chapter 2](ch02.html "Chapter 2. Objects in Python"), *Objects
    in Python*, since Python 3 automatically inherits from `object` if we don't explicitly
    provide a different superclass. A superclass, or parent class, is a class that
    is being inherited from. A subclass is a class that is inheriting from a superclass.
    In this case, the superclass is `object`, and `MySubClass` is the subclass. A
    subclass is also said to be derived from its parent class or that the subclass
    extends the parent.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: As you've probably figured out from the example, inheritance requires a minimal
    amount of extra syntax over a basic class definition. Simply include the name
    of the parent class inside parentheses after the class name but before the colon
    terminating the class definition. This is all we have to do to tell Python that
    the new class should be derived from the given superclass.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we apply inheritance in practice? The simplest and most obvious use
    of inheritance is to add functionality to an existing class. Let''s start with
    a simple contact manager that tracks the name and e-mail address of several people.
    The contact class is responsible for maintaining a list of all contacts in a class
    variable, and for initializing the name and address for an individual contact:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This example introduces us to class variables. The `all_contacts` list, because
    it is part of the class definition, is shared by all instances of this class.
    This means that there is only one `Contact.all_contacts` list, which we can access
    as `Contact.all_contacts`. Less obviously, we can also access it as `self.all_contacts`
    on any object instantiated from `Contact`. If the field can't be found on the
    object, then it will be found on the class and thus refer to the same single list.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be careful with this syntax, for if you ever *set* the variable using `self.all_contacts`,
    you will actually be creating a **new** instance variable associated only with
    that object. The class variable will still be unchanged and accessible as `Contact.all_contacts`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a simple class that allows us to track a couple pieces of data about
    each contact. But what if some of our contacts are also suppliers that we need
    to order supplies from? We could add an `order` method to the `Contact` class,
    but that would allow people to accidentally order things from contacts who are
    customers or family friends. Instead, let''s create a new `Supplier` class that
    acts like our `Contact` class, but has an additional `order` method:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, if we test this class in our trusty interpreter, we see that all contacts,
    including suppliers, accept a name and e-mail address in their `__init__`, but
    only suppliers have a functional order method:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So, now our `Supplier` class can do everything a contact can do (including adding
    itself to the list of `all_contacts`) and all the special things it needs to handle
    as a supplier. This is the beauty of inheritance.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Extending built-ins
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One interesting use of this kind of inheritance is adding functionality to
    built-in classes. In the `Contact` class seen earlier, we are adding contacts
    to a list of all contacts. What if we also wanted to search that list by name?
    Well, we could add a method on the `Contact` class to search it, but it feels
    like this method actually belongs to the list itself. We can do this using inheritance:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Instead of instantiating a normal list as our class variable, we create a new
    `ContactList` class that extends the built-in `list`. Then, we instantiate this
    subclass as our `all_contacts` list. We can test the new search functionality
    as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Are you wondering how we changed the built-in syntax `[]` into something we
    can inherit from? Creating an empty list with `[]` is actually a shorthand for
    creating an empty list using `list()`; the two syntaxes behave identically:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In reality, the `[]` syntax is actually so-called **syntax sugar** that calls
    the `list()` constructor under the hood. The `list` data type is a class that
    we can extend. In fact, the list itself extends the `object` class:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As a second example, we can extend the `dict` class, which is, similar to the
    list, the class that is constructed when using the `{}` syntax shorthand:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is easy to test in the interactive interpreter:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Most built-in types can be similarly extended. Commonly extended built-ins are
    `object`, `list`, `set`, `dict`, `file`, and `str`. Numerical types such as `int`
    and `float` are also occasionally inherited from.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Overriding and super
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, inheritance is great for *adding* new behavior to existing classes, but
    what about *changing* behavior? Our `contact` class allows only a name and an
    e-mail address. This may be sufficient for most contacts, but what if we want
    to add a phone number for our close friends?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'As we saw in [Chapter 2](ch02.html "Chapter 2. Objects in Python"), *Objects
    in Python*, we can do this easily by just setting a `phone` attribute on the contact
    after it is constructed. But if we want to make this third variable available
    on initialization, we have to override `__init__`. Overriding means altering or
    replacing a method of the superclass with a new method (with the same name) in
    the subclass. No special syntax is needed to do this; the subclass''s newly created
    method is automatically called instead of the superclass''s method. For example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Any method can be overridden, not just `__init__`. Before we go on, however,
    we need to address some problems in this example. Our `Contact` and `Friend` classes
    have duplicate code to set up the `name` and `email` properties; this can make
    code maintenance complicated as we have to update the code in two or more places.
    More alarmingly, our `Friend` class is neglecting to add itself to the `all_contacts`
    list we have created on the `Contact` class.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'What we really need is a way to execute the original `__init__` method on the
    `Contact` class. This is what the `super` function does; it returns the object
    as an instance of the parent class, allowing us to call the parent method directly:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This example first gets the instance of the parent object using `super`, and
    calls `__init__` on that object, passing in the expected arguments. It then does
    its own initialization, namely, setting the `phone` attribute.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the `super()` syntax does not work in older versions of Python. Like
    the [] and {} syntaxes for lists and dictionaries, it is a shorthand for a more
    complicated construct. We'll learn more about this shortly when we discuss multiple
    inheritance, but know for now that in Python 2, you would have to call `super(EmailContact,
    self).__init__()`. Specifically notice that the first argument is the name of
    the child class, not the name as the parent class you want to call, as some might
    expect. Also, remember the class comes before the object. I always forget the
    order, so the new syntax in Python 3 has saved me hours of having to look it up.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`super()`语法在较旧版本的Python中不起作用。就像列表和字典的[]和{}语法一样，它是更复杂结构的简写。当我们讨论多重继承时，我们很快会了解更多，但现在要知道，在Python
    2中，您必须调用`super(EmailContact, self).__init__()`。特别注意第一个参数是子类的名称，而不是您想要调用的父类的名称，这可能有些人会期望。还要记住类在对象之前。我总是忘记顺序，所以Python
    3中的新语法为我节省了很多时间。
- en: A `super()` call can be made inside any method, not just `__init__`. This means
    all methods can be modified via overriding and calls to `super`. The call to `super`
    can also be made at any point in the method; we don't have to make the call as
    the first line in the method. For example, we may need to manipulate or validate
    incoming parameters before forwarding them to the superclass.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`super()`调用可以在任何方法中进行，不仅仅是`__init__`。这意味着所有方法都可以通过覆盖和调用`super`进行修改。`super`的调用也可以在方法中的任何位置进行；我们不必在方法中的第一行进行调用。例如，我们可能需要在将参数转发给超类之前操纵或验证传入参数。'
- en: Multiple inheritance
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多重继承
- en: 'Multiple inheritance is a touchy subject. In principle, it''s very simple:
    a subclass that inherits from more than one parent class is able to access functionality
    from both of them. In practice, this is less useful than it sounds and many expert
    programmers recommend against using it.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 多重继承是一个敏感的话题。原则上，它非常简单：从多个父类继承的子类能够访问它们两者的功能。实际上，这并不像听起来那么有用，许多专家程序员建议不要使用它。
- en: Tip
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As a rule of thumb, if you think you need multiple inheritance, you're probably
    wrong, but if you know you need it, you're probably right.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个经验法则，如果您认为需要多重继承，您可能是错误的，但如果您知道需要它，您可能是正确的。
- en: 'The simplest and most useful form of multiple inheritance is called a **mixin**.
    A mixin is generally a superclass that is not meant to exist on its own, but is
    meant to be inherited by some other class to provide extra functionality. For
    example, let''s say we wanted to add functionality to our `Contact` class that
    allows sending an e-mail to `self.email`. Sending e-mail is a common task that
    we might want to use on many other classes. So, we can write a simple mixin class
    to do the e-mailing for us:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单和最有用的多重继承形式称为**mixin**。mixin通常是一个不打算独立存在的超类，而是打算被其他一些类继承以提供额外功能。例如，假设我们想要为我们的`Contact`类添加一个功能，允许向`self.email`发送电子邮件。发送电子邮件是一个常见的任务，我们可能希望在许多其他类上使用它。因此，我们可以编写一个简单的mixin类来为我们发送电子邮件：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For brevity, we won't include the actual e-mail logic here; if you're interested
    in studying how it's done, see the `smtplib` module in the Python standard library.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我们不会在这里包含实际的电子邮件逻辑；如果您有兴趣学习如何完成，可以查看Python标准库中的`smtplib`模块。
- en: 'This class doesn''t do anything special (in fact, it can barely function as
    a standalone class), but it does allow us to define a new class that describes
    both a `Contact` and a `MailSender`, using multiple inheritance:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类并没有做任何特殊的事情（实际上，它几乎不能作为一个独立的类运行），但它确实允许我们定义一个新的类，描述了`Contact`和`MailSender`，使用多重继承：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The syntax for multiple inheritance looks like a parameter list in the class
    definition. Instead of including one base class inside the parentheses, we include
    two (or more), separated by a comma. We can test this new hybrid to see the mixin
    at work:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 多重继承的语法看起来像类定义中的参数列表。在括号内不是包含一个基类，而是包含两个（或更多），用逗号分隔。我们可以测试这个新的混合体，看看mixin的工作情况：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `Contact` initializer is still adding the new contact to the `all_contacts`
    list, and the mixin is able to send mail to `self.email` so we know everything
    is working.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`Contact`初始化器仍然将新联系人添加到`all_contacts`列表中，而mixin能够向`self.email`发送邮件，所以我们知道一切都在运作。'
- en: 'This wasn''t so hard, and you''re probably wondering what the dire warnings
    about multiple inheritance are. We''ll get into the complexities in a minute,
    but let''s consider some other options we had, rather than using a mixin here:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不难，你可能想知道关于多重继承的严重警告是什么。我们将在一分钟内深入讨论复杂性，但让我们考虑一些其他选项，而不是在这里使用mixin：
- en: We could have used single inheritance and added the `send_mail` function to
    the subclass. The disadvantage here is that the e-mail functionality then has
    to be duplicated for any other classes that need e-mail.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们本可以使用单一继承，并将`send_mail`函数添加到子类中。这样做的缺点是，电子邮件功能必须为任何需要电子邮件的其他类复制。
- en: We can create a standalone Python function for sending an e-mail, and just call
    that function with the correct e-mail address supplied as a parameter when the
    e-mail needs to be sent.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建一个独立的Python函数来发送电子邮件，并在需要发送电子邮件时使用正确的电子邮件地址作为参数调用该函数。
- en: We could have explored a few ways of using composition instead of inheritance.
    For example, `EmailableContact` could have a `MailSender` object instead of inheriting
    from it.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们本可以探索一些使用组合而不是继承的方法。例如，`EmailableContact`可以有一个`MailSender`对象，而不是继承它。
- en: We could monkey-patch (we'll briefly cover monkey-patching in [Chapter 7](ch07.html
    "Chapter 7. Python Object-oriented Shortcuts"), *Python Object-oriented Shortcuts*)
    the `Contact` class to have a `send_mail` method after the class has been created.
    This is done by defining a function that accepts the `self` argument, and setting
    it as an attribute on an existing class.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以对`Contact`类进行猴子补丁（我们将在[第7章](ch07.html "第7章。Python面向对象快捷方式")中简要介绍猴子补丁，*Python面向对象快捷方式*），在类创建后添加一个`send_mail`方法。这是通过定义一个接受`self`参数的函数，并将其设置为现有类的属性来完成的。
- en: Multiple inheritance works all right when mixing methods from different classes,
    but it gets very messy when we have to call methods on the superclass. There are
    multiple superclasses. How do we know which one to call? How do we know what order
    to call them in?
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore these questions by adding a home address to our `Friend` class.
    There are a few approaches we might take. An address is a collection of strings
    representing the street, city, country, and other related details of the contact.
    We could pass each of these strings as a parameter into the `Friend` class's `__init__`
    method. We could also store these strings in a tuple or dictionary and pass them
    into `__init__` as a single argument. This is probably the best course of action
    if there are no methods that need to be added to the address.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Another option would be to create a new `Address` class to hold those strings
    together, and then pass an instance of this class into the `__init__` method of
    our `Friend` class. The advantage of this solution is that we can add behavior
    (say, a method to give directions or to print a map) to the data instead of just
    storing it statically. This is an example of composition, as we discussed in [Chapter
    1](ch01.html "Chapter 1. Object-oriented Design"), *Object-oriented Design*. The
    "has a" relationship of composition is a perfectly viable solution to this problem
    and allows us to reuse `Address` classes in other entities such as buildings,
    businesses, or organizations.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'However, inheritance is also a viable solution, and that''s what we want to
    explore. Let''s add a new class that holds an address. We''ll call this new class
    "AddressHolder" instead of "Address" because inheritance defines an *is a* relationship.
    It is not correct to say a "Friend" is an "Address" , but since a friend can have
    an "Address" , we can argue that a "Friend" is an "AddressHolder". Later, we could
    create other entities (companies, buildings) that also hold addresses. Here''s
    our `AddressHolder` class:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Very simple; we just take all the data and toss it into instance variables upon
    initialization.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: The diamond problem
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use multiple inheritance to add this new class as a parent of our existing
    `Friend` class. The tricky part is that we now have two parent `__init__` methods
    both of which need to be initialized. And they need to be initialized with different
    arguments. How do we do this? Well, we could start with a naive approach:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this example, we directly call the `__init__` function on each of the superclasses
    and explicitly pass the `self` argument. This example technically works; we can
    access the different variables directly on the class. But there are a few problems.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: First, it is possible for a superclass to go uninitialized if we neglect to
    explicitly call the initializer. That wouldn't break this example, but it could
    cause hard-to-debug program crashes in common scenarios. Imagine trying to insert
    data into a database that has not been connected to, for example.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, and more sinister, is the possibility of a superclass being called
    multiple times because of the organization of the class hierarchy. Look at this
    inheritance diagram:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '![The diamond problem](images/8781OS_3_01.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
- en: The `__init__` method from the `Friend` class first calls `__init__` on `Contact`,
    which implicitly initializes the `object` superclass (remember, all classes derive
    from `object`). `Friend` then calls `__init__` on `AddressHolder`, which implicitly
    initializes the `object` superclass *again*. This means the parent class has been
    set up twice. With the `object` class, that's relatively harmless, but in some
    situations, it could spell disaster. Imagine trying to connect to a database twice
    for every request!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: The base class should only be called once. Once, yes, but when? Do we call `Friend`,
    then `Contact`, then `Object`, then `AddressHolder`? Or `Friend`, then `Contact`,
    then `AddressHolder`, then `Object`?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The order in which methods can be called can be adapted on the fly by modifying
    the `__mro__` (**Method Resolution Order**) attribute on the class. This is beyond
    the scope of this book. If you think you need to understand it, I recommend *Expert
    Python Programming*, *Tarek Ziadé*, *Packt Publishing*, or read the original documentation
    on the topic at [http://www.python.org/download/releases/2.3/mro/](http://www.python.org/download/releases/2.3/mro/).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的调用顺序可以通过修改类的`__mro__`（**方法解析顺序**）属性来动态调整。这超出了本书的范围。如果您认为您需要了解它，我建议阅读*Tarek
    Ziadé*的*Expert Python Programming*，*Packt Publishing*，或者阅读有关该主题的原始文档[http://www.python.org/download/releases/2.3/mro/](http://www.python.org/download/releases/2.3/mro/)。
- en: 'Let''s look at a second contrived example that illustrates this problem more
    clearly. Here we have a base class that has a method named `call_me`. Two subclasses
    override that method, and then another subclass extends both of these using multiple
    inheritance. This is called diamond inheritance because of the diamond shape of
    the class diagram:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个更清楚地说明这个问题的第二个刻意的例子。这里有一个基类，其中有一个名为`call_me`的方法。两个子类覆盖了该方法，然后另一个子类使用多重继承扩展了这两个子类。这被称为菱形继承，因为类图的形状是菱形：
- en: '![The diamond problem](images/8781OS_3_02.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![菱形问题](images/8781OS_3_02.jpg)'
- en: 'Let''s convert this diagram to code; this example shows when the methods are
    called:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个图表转换为代码；这个例子展示了方法何时被调用：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This example simply ensures that each overridden `call_me` method directly
    calls the parent method with the same name. It lets us know each time a method
    is called by printing the information to the screen. It also updates a static
    variable on the class to show how many times it has been called. If we instantiate
    one `Subclass` object and call the method on it once, we get this output:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子简单地确保每个重写的`call_me`方法直接调用具有相同名称的父方法。它通过将信息打印到屏幕上来告诉我们每次方法被调用的次数。它还更新了类的静态变量，以显示它被调用的次数。如果我们实例化一个`Subclass`对象并调用它的方法一次，我们会得到这个输出：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Thus we can clearly see the base class's `call_me` method being called twice.
    This could lead to some insidious bugs if that method is doing actual work—like
    depositing into a bank account—twice.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以清楚地看到基类的`call_me`方法被调用了两次。如果该方法正在执行实际工作，比如存款到银行账户，这可能会导致一些隐匿的错误。
- en: 'The thing to keep in mind with multiple inheritance is that we only want to
    call the "next" method in the class hierarchy, not the "parent" method. In fact,
    that next method may not be on a parent or ancestor of the current class. The
    `super` keyword comes to our rescue once again. Indeed, `super` was originally
    developed to make complicated forms of multiple inheritance possible. Here is
    the same code written using `super`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 多重继承需要记住的一点是，我们只想调用类层次结构中的“下一个”方法，而不是“父”方法。实际上，下一个方法可能不在当前类的父类或祖先上。`super`关键字再次来到我们的救援。事实上，`super`最初是为了使复杂形式的多重继承成为可能而开发的。这里是使用`super`编写的相同代码：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The change is pretty minor; we simply replaced the naive direct calls with
    calls to `super()`, although the bottom subclass only calls `super` once rather
    than having to make the calls for both the left and right. The change is simple
    enough, but look at the difference when we execute it:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 变化非常小；我们只是用`super()`调用替换了天真的直接调用，尽管底部的子类只调用了一次`super`，而不是必须为左侧和右侧都进行调用。这个变化很简单，但当我们执行它时看看它的不同之处：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Looks good, our base method is only being called once. But what is `super()`
    actually doing here? Since the `print` statements are executed after the `super`
    calls, the printed output is in the order each method is actually executed. Let's
    look at the output from back to front to see who is calling what.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错，我们的基本方法只被调用了一次。但`super()`在这里实际上是在做什么呢？由于`print`语句是在`super`调用之后执行的，所以打印输出是每个方法实际执行的顺序。让我们从后往前看输出，看看是谁在调用什么。
- en: First, `call_me` of `Subclass` calls `super().call_me()`, which happens to refer
    to `LeftSubclass.call_me()`. The `LeftSubclass.call_me()` method then calls `super().call_me()`,
    but in this case, `super()` is referring to `RightSubclass.call_me()`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`Subclass`的`call_me`调用`super().call_me()`，这恰好是指`LeftSubclass.call_me()`。然后`LeftSubclass.call_me()`方法调用`super().call_me()`，但在这种情况下，`super()`指的是`RightSubclass.call_me()`。
- en: 'Pay particular attention to this: the `super` call is *not* calling the method
    on the superclass of `LeftSubclass` (which is `BaseClass`). Rather, it is calling
    `RightSubclass`, even though it is not a direct parent of `LeftSubclass`! This
    is the *next* method, not the parent method. `RightSubclass` then calls `BaseClass`
    and the `super` calls have ensured each method in the class hierarchy is executed
    once.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意：`super`调用*不*是在`LeftSubclass`的超类（即`BaseClass`）上调用方法。相反，它调用`RightSubclass`，即使它不是`LeftSubclass`的直接父类！这是*下一个*方法，而不是父方法。然后`RightSubclass`调用`BaseClass`，并且`super`调用确保了类层次结构中的每个方法都被执行一次。
- en: Different sets of arguments
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不同的参数集。
- en: 'This is going to make things complicated as we return to our `Friend` multiple
    inheritance example. In the `__init__` method for `Friend`, we were originally
    calling `__init__` for both parent classes, *with different sets of arguments*:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们回到我们的`Friend`多重继承示例时，情况会变得复杂。在`Friend`的`__init__`方法中，我们最初调用了两个父类的`__init__`，*使用不同的参数*：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How can we manage different sets of arguments when using `super`? We don't necessarily
    know which class `super` is going to try to initialize first. Even if we did,
    we need a way to pass the "extra" arguments so that subsequent calls to `super`,
    on other subclasses, receive the right arguments.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`super`时，我们如何管理不同的参数集？我们不一定知道`super`将首先尝试初始化哪个类。即使我们知道，我们也需要一种方法来传递“额外”的参数，以便后续对其他子类的`super`调用接收正确的参数。
- en: Specifically, if the first call to `super` passes the `name` and `email` arguments
    to `Contact.__init__`, and `Contact.__init__` then calls `super`, it needs to
    be able to pass the address-related arguments to the "next" method, which is `AddressHolder.__init__`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: This is a problem whenever we want to call superclass methods with the same
    name, but with different sets of arguments. Most often, the only time you would
    want to call a superclass with a completely different set of arguments is in `__init__`,
    as we're doing here. Even with regular methods, though, we may want to add optional
    parameters that only make sense to one subclass or set of subclasses.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Sadly, the only way to solve this problem is to plan for it from the beginning.
    We have to design our base class parameter lists to accept keyword arguments for
    any parameters that are not required by every subclass implementation. Finally,
    we must ensure the method freely accepts unexpected arguments and passes them
    on to its `super` call, in case they are necessary to later methods in the inheritance
    order.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'Python''s function parameter syntax provides all the tools we need to do this,
    but it makes the overall code look cumbersome. Have a look at the proper version
    of the `Friend` multiple inheritance code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We've changed all arguments to keyword arguments by giving them an empty string
    as a default value. We've also ensured that a `**kwargs` parameter is included
    to capture any additional parameters that our particular method doesn't know what
    to do with. It passes these parameters up to the next class with the `super` call.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you aren't familiar with the `**kwargs` syntax, it basically collects any
    keyword arguments passed into the method that were not explicitly listed in the
    parameter list. These arguments are stored in a dictionary named `kwargs` (we
    can call the variable whatever we like, but convention suggests `kw`, or `kwargs`).
    When we call a different method (for example, `super().__init__`) with a `**kwargs`
    syntax, it unpacks the dictionary and passes the results to the method as normal
    keyword arguments. We'll cover this in detail in [Chapter 7](ch07.html "Chapter 7. Python
    Object-oriented Shortcuts"), *Python Object-oriented Shortcuts*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: The previous example does what it is supposed to do. But it's starting to look
    messy, and it has become difficult to answer the question, *What arguments do
    we need to pass into* `Friend.__init__`? This is the foremost question for anyone
    planning to use the class, so a docstring should be added to the method to explain
    what is happening.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Further, even this implementation is insufficient if we want to *reuse* variables
    in parent classes. When we pass the `**kwargs` variable to `super`, the dictionary
    does not include any of the variables that were included as explicit keyword arguments.
    For example, in `Friend.__init__`, the call to `super` does not have `phone` in
    the `kwargs` dictionary. If any of the other classes need the `phone` parameter,
    we need to ensure it is in the dictionary that is passed. Worse, if we forget
    to do this, it will be tough to debug because the superclass will not complain,
    but will simply assign the default value (in this case, an empty string) to the
    variable.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few ways to ensure that the variable is passed upwards. Assume
    the `Contact` class does, for some reason, need to be initialized with a `phone`
    parameter, and the `Friend` class will also need access to it. We can do any of
    the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Don't include `phone` as an explicit keyword argument. Instead, leave it in
    the `kwargs` dictionary. `Friend` can look it up using the syntax `kwargs['phone']`.
    When it passes `**kwargs` to the `super` call, `phone` will still be in the dictionary.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make `phone` an explicit keyword argument but update the `kwargs` dictionary
    before passing it to `super`, using the standard dictionary syntax `kwargs['phone']
    = phone`.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Make `phone` an explicit keyword argument, but update the `kwargs` dictionary
    using the `kwargs.update` method. This is useful if you have several arguments
    to update. You can create the dictionary passed into `update` using either the
    `dict(phone=phone)` constructor, or the dictionary syntax `{''phone'': phone}`.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '将`phone`作为显式关键字参数，但使用`kwargs.update`方法更新`kwargs`字典。如果有多个参数需要更新，这是很有用的。您可以使用`dict(phone=phone)`构造函数或字典语法`{''phone'':
    phone}`创建传递给`update`的字典。'
- en: Make `phone` an explicit keyword argument, but pass it to the super call explicitly
    with the syntax `super().__init__(phone=phone, **kwargs)`.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`phone`作为显式关键字参数，但使用语法`super().__init__(phone=phone, **kwargs)`将其明确传递给super调用。
- en: We have covered many of the caveats involved with multiple inheritance in Python.
    When we need to account for all the possible situations, we have to plan for them
    and our code will get messy. Basic multiple inheritance can be handy but, in many
    cases, we may want to choose a more transparent way of combining two disparate
    classes, usually using composition or one of the design patterns we'll be covering
    in [Chapter 10](ch10.html "Chapter 10. Python Design Patterns I"), *Python Design
    Patterns I* and [Chapter 11](ch11.html "Chapter 11. Python Design Patterns II"),
    *Python Design Patterns II*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了Python中多重继承涉及的许多注意事项。当我们需要考虑所有可能的情况时，我们必须为它们做好规划，我们的代码会变得混乱。基本的多重继承可能很方便，但在许多情况下，我们可能希望选择更透明的方式来组合两个不同的类，通常使用组合或我们将在[第10章](ch10.html
    "第10章。Python设计模式I")中介绍的设计模式之一，*Python设计模式I*和[第11章](ch11.html "第11章。Python设计模式II")中介绍的设计模式之一，*Python设计模式II*。
- en: Polymorphism
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态
- en: 'We were introduced to polymorphism in [Chapter 1](ch01.html "Chapter 1. Object-oriented
    Design"), *Object-oriented Design*. It is a fancy name describing a simple concept:
    different behaviors happen depending on which subclass is being used, without
    having to explicitly know what the subclass actually is. As an example, imagine
    a program that plays audio files. A media player might need to load an `AudioFile`
    object and then `play` it. We''d put a `play()` method on the object, which is
    responsible for decompressing or extracting the audio and routing it to the sound
    card and speakers. The act of playing an `AudioFile` could feasibly be as simple
    as:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第1章](ch01.html "第1章。面向对象设计")中介绍了多态。这是一个描述简单概念的花哨名字：根据使用的子类不同，会发生不同的行为，而不必明确知道子类实际上是什么。举个例子，想象一个播放音频文件的程序。媒体播放器可能需要加载一个`AudioFile`对象，然后`play`它。我们会在对象上放一个`play()`方法，负责解压或提取音频并将其路由到声卡和扬声器。播放`AudioFile`的行为可能是非常简单的：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: However, the process of decompressing and extracting an audio file is very different
    for different types of files. The `.wav` files are stored uncompressed, while
    `.mp3`, `.wma`, and `.ogg` files all have totally different compression algorithms.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，解压和提取音频文件的过程对于不同类型的文件是非常不同的。`.wav`文件是未压缩的，而`.mp3`、`.wma`和`.ogg`文件都有完全不同的压缩算法。
- en: 'We can use inheritance with polymorphism to simplify the design. Each type
    of file can be represented by a different subclass of `AudioFile`, for example,
    `WavFile`, `MP3File`. Each of these would have a `play()` method, but that method
    would be implemented differently for each file to ensure the correct extraction
    procedure is followed. The media player object would never need to know which
    subclass of `AudioFile` it is referring to; it just calls `play()` and polymorphically
    lets the object take care of the actual details of playing. Let''s look at a quick
    skeleton showing how this might look:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用继承和多态来简化设计。每种类型的文件都可以由`AudioFile`的不同子类来表示，例如`WavFile`、`MP3File`。每个子类都会有一个`play()`方法，但是为了确保正确的提取过程，每个文件的这个方法都会有不同的实现。媒体播放器对象永远不需要知道它正在引用`AudioFile`的哪个子类；它只是调用`play()`，并且通过多态让对象来处理实际的播放细节。让我们看一个快速的骨架，展示这个可能是什么样子：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: All audio files check to ensure that a valid extension was given upon initialization.
    But did you notice how the `__init__` method in the parent class is able to access
    the `ext` class variable from different subclasses? That's polymorphism at work.
    If the filename doesn't end with the correct name, it raises an exception (exceptions
    will be covered in detail in the next chapter). The fact that `AudioFile` doesn't
    actually store a reference to the `ext` variable doesn't stop it from being able
    to access it on the subclass.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 所有音频文件都会检查初始化时是否给出了有效的扩展名。但是你有没有注意到父类中的`__init__`方法如何能够从不同的子类中访问`ext`类变量？这就是多态的作用。如果文件名不以正确的名称结尾，它会引发一个异常（异常将在下一章详细介绍）。`AudioFile`实际上并没有存储对`ext`变量的引用，但这并不妨碍它能够在子类上访问它。
- en: 'In addition, each subclass of `AudioFile` implements `play()` in a different
    way (this example doesn''t actually play the music; audio compression algorithms
    really deserve a separate book!). This is also polymorphism in action. The media
    player can use the exact same code to play a file, no matter what type it is;
    it doesn''t care what subclass of `AudioFile` it is looking at. The details of
    decompressing the audio file are *encapsulated*. If we test this example, it works
    as we would hope:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`AudioFile`的每个子类都以不同的方式实现了`play()`（这个例子实际上并不播放音乐；音频压缩算法确实值得一本单独的书！）。这也是多态的实际应用。媒体播放器可以使用完全相同的代码来播放文件，无论它是什么类型的；它不在乎它正在查看`AudioFile`的哪个子类。解压音频文件的细节被*封装*起来。如果我们测试这个例子，它会按照我们的期望工作：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: See how `AudioFile.__init__` is able to check the file type without actually
    knowing what subclass it is referring to?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 看看`AudioFile.__init__`如何能够检查文件类型，而实际上并不知道它正在引用哪个子类？
- en: 'Polymorphism is actually one of the coolest things about object-oriented programming,
    and it makes some programming designs obvious that weren''t possible in earlier
    paradigms. However, Python makes polymorphism less cool because of duck typing.
    Duck typing in Python allows us to use *any* object that provides the required
    behavior without forcing it to be a subclass. The dynamic nature of Python makes
    this trivial. The following example does not extend `AudioFile`, but it can be
    interacted with in Python using the exact same interface:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Our media player can play this object just as easily as one that extends `AudioFile`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism is one of the most important reasons to use inheritance in many
    object-oriented contexts. Because any objects that supply the correct interface
    can be used interchangeably in Python, it reduces the need for polymorphic common
    superclasses. Inheritance can still be useful for sharing code but, if all that
    is being shared is the public interface, duck typing is all that is required.
    This reduced need for inheritance also reduces the need for multiple inheritance;
    often, when multiple inheritance appears to be a valid solution, we can just use
    duck typing to mimic one of the multiple superclasses.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Of course, just because an object satisfies a particular interface (by providing
    required methods or attributes) does not mean it will simply work in all situations.
    It has to fulfill that interface in a way that makes sense in the overall system.
    Just because an object provides a `play()` method does not mean it will automatically
    work with a media player. For example, our chess AI object from [Chapter 1](ch01.html
    "Chapter 1. Object-oriented Design"), *Object-oriented Design*, may have a `play()`
    method that moves a chess piece. Even though it satisfies the interface, this
    class would likely break in spectacular ways if we tried to plug it into a media
    player!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Another useful feature of duck typing is that the duck-typed object only needs
    to provide those methods and attributes that are actually being accessed. For
    example, if we needed to create a fake file object to read data from, we can create
    a new object that has a `read()` method; we don't have to override the `write`
    method if the code that is going to interact with the object will only be reading
    from the file. More succinctly, duck typing doesn't need to provide the entire
    interface of an object that is available, it only needs to fulfill the interface
    that is actually accessed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Abstract base classes
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While duck typing is useful, it is not always easy to tell in advance if a class
    is going to fulfill the protocol you require. Therefore, Python introduced the
    idea of abstract base classes. **Abstract base classes**, or **ABCs**, define
    a set of methods and properties that a class must implement in order to be considered
    a duck-type instance of that class. The class can extend the abstract base class
    itself in order to be used as an instance of that class, but it must supply all
    the appropriate methods.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: In practice, it's rarely necessary to create new abstract base classes, but
    we may find occasions to implement instances of existing ABCs. We'll cover implementing
    ABCs first, and then briefly see how to create your own if you should ever need
    to.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Using an abstract base class
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most of the abstract base classes that exist in the Python Standard Library
    live in the `collections` module. One of the simplest ones is the `Container`
    class. Let''s inspect it in the Python interpreter to see what methods this class
    requires:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'So, the `Container` class has exactly one abstract method that needs to be
    implemented, `__contains__`. You can issue `help(Container.__contains__)` to see
    what the function signature should look like:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: So, we see that `__contains__` needs to take a single argument. Unfortunately,
    the help file doesn't tell us much about what that argument should be, but it's
    pretty obvious from the name of the ABC and the single method it implements that
    this argument is the value the user is checking to see if the container holds.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is implemented by `list`, `str`, and `dict` to indicate whether
    or not a given value is in that data structure. However, we can also define a
    silly container that tells us whether a given value is in the set of odd integers:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we can instantiate an `OddContainer` object and determine that, even though
    we did not extend `Container`, the class *is a* `Container` object:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: And that is why duck typing is way more awesome than classical polymorphism.
    We can create *is a* relationships without the overhead of using inheritance (or
    worse, multiple inheritance).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'The interesting thing about the `Container` ABC is that any class that implements
    it gets to use the `in` keyword for free. In fact, `in` is just syntax sugar that
    delegates to the `__contains__` method. Any class that has a `__contains__` method
    is a `Container` and can therefore be queried by the `in` keyword, for example:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Creating an abstract base class
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we saw earlier, it''s not necessary to have an abstract base class to enable
    duck typing. However, imagine we were creating a media player with third-party
    plugins. It is advisable to create an abstract base class in this case to document
    what API the third-party plugins should provide. The `abc` module provides the
    tools you need to do this, but I''ll warn you in advance, this requires some of
    Python''s most arcane concepts:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is a complicated example that includes several Python features that won't
    be explained until later in this book. It is included here for completeness, but
    you don't need to understand all of it to get the gist of how to create your own
    ABC.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: The first weird thing is the `metaclass` keyword argument that is passed into
    the class where you would normally see the list of parent classes. This is a rarely
    used construct from the mystic art of metaclass programming. We won't be covering
    metaclasses in this book, so all you need to know is that by assigning the `ABCMeta`
    metaclass, you are giving your class superpower (or at least superclass) abilities.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Next, we see the `@abc.abstractmethod` and `@abc.abstractproperty` constructs.
    These are Python decorators. We'll discuss those in [Chapter 5](ch05.html "Chapter 5. When
    to Use Object-oriented Programming"), *When to Use Object-oriented Programming*.
    For now, just know that by marking a method or property as being abstract, you
    are stating that any subclass of this class must implement that method or supply
    that property in order to be considered a proper member of the class.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'See what happens if you implement subclasses that do or don''t supply those
    properties:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Since the `Wav` class fails to implement the abstract attributes, it is not
    possible to instantiate that class. The class is still a legal abstract class,
    but you'd have to subclass it to actually do anything. The `Ogg` class supplies
    both attributes, so it instantiates cleanly.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Going back to the `MediaLoader` ABC, let's dissect that `__subclasshook__` method.
    It is basically saying that any class that supplies concrete implementations of
    all the abstract attributes of this ABC should be considered a subclass of `MediaLoader`,
    even if it doesn't actually inherit from the `MediaLoader` class.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: More common object-oriented languages have a clear separation between the interface
    and the implementation of a class. For example, some languages provide an explicit
    `interface` keyword that allows us to define the methods that a class must have
    without any implementation. In such an environment, an abstract class is one that
    provides both an interface and a concrete implementation of some but not all methods.
    Any class can explicitly state that it implements a given interface.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Python's ABCs help to supply the functionality of interfaces without compromising
    on the benefits of duck typing.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Demystifying the magic
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can copy and paste the subclass code without understanding it if you want
    to make abstract classes that fulfill this particular contract. We'll cover most
    of the unusual syntaxes throughout the book, but let's go over it line by line
    to get an overview.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This decorator marks the method as a class method. It essentially says that
    the method can be called on a class instead of an instantiated object:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This defines the `__subclasshook__` class method. This special method is called
    by the Python interpreter to answer the question, *Is the class* `C` *a subclass
    of this class?*
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We check to see if the method was called specifically on this class, rather
    than, say a subclass of this class. This prevents, for example, the `Wav` class
    from being thought of as a parent class of the `Ogg` class:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'All this line does is get the set of methods and properties that the class
    has, including any parent classes in its class hierarchy:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This line uses set notation to see whether the set of abstract methods in this
    class have been supplied in the candidate class. Note that it doesn't check to
    see whether the methods have been implemented, just if they are there. Thus, it's
    possible for a class to be a subclass and yet still be an abstract class itself.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If all the abstract methods have been supplied, then the candidate class is
    a subclass of this class and we return `True`. The method can legally return one
    of the three values: `True`, `False`, or `NotImplemented`. `True` and `False`
    indicate that the class is or is not definitively a subclass of this class:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If any of the conditionals have not been met (that is, the class is not `MediaLoader`
    or not all abstract methods have been supplied), then return `NotImplemented`.
    This tells the Python machinery to use the default mechanism (does the candidate
    class explicitly extend this class?) for subclass detection.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, we can now define the `Ogg` class as a subclass of the `MediaLoader`
    class without actually extending the `MediaLoader` class:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Case study
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s try to tie everything we''ve learned together with a larger example.
    We''ll be designing a simple real estate application that allows an agent to manage
    properties available for purchase or rent. There will be two types of properties:
    apartments and houses. The agent needs to be able to enter a few relevant details
    about new properties, list all currently available properties, and mark a property
    as sold or rented. For brevity, we won''t worry about editing property details
    or reactivating a property after it is sold.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: The project will allow the agent to interact with the objects using the Python
    interpreter prompt. In this world of graphical user interfaces and web applications,
    you might be wondering why we're creating such old-fashioned looking programs.
    Simply put, both windowed programs and web applications require a lot of overhead
    knowledge and boilerplate code to make them do what is required. If we were developing
    software using either of these paradigms, we'd get so lost in GUI programming
    or web programming that we'd lose sight of the object-oriented principles we're
    trying to master.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, most GUI and web frameworks utilize an object-oriented approach, and
    the principles we're studying now will help in understanding those systems in
    the future. We'll discuss them both briefly in [Chapter 13](ch13.html "Chapter 13. Concurrency"),
    *Concurrency*, but complete details are far beyond the scope of a single book.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Looking at our requirements, it seems like there are quite a few nouns that
    might represent classes of objects in our system. Clearly, we'll need to represent
    a property. Houses and apartments may need separate classes. Rentals and purchases
    also seem to require separate representation. Since we're focusing on inheritance
    right now, we'll be looking at ways to share behavior using inheritance or multiple
    inheritance.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '`House` and `Apartment` are both types of properties, so `Property` can be
    a superclass of those two classes. `Rental` and `Purchase` will need some extra
    thought; if we use inheritance, we''ll need to have separate classes, for example,
    for `HouseRental` and `HousePurchase`, and use multiple inheritance to combine
    them. This feels a little clunky compared to a composition or association-based
    design, but let''s run with it and see what we come up with.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Now then, what attributes might be associated with a `Property` class? Regardless
    of whether it is an apartment or a house, most people will want to know the square
    footage, number of bedrooms, and number of bathrooms. (There are numerous other
    attributes that might be modeled, but we'll keep it simple for our prototype.)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: If the property is a house, it will want to advertise the number of stories,
    whether it has a garage (attached, detached, or none), and whether the yard is
    fenced. An apartment will want to indicate if it has a balcony, and if the laundry
    is ensuite, coin, or off-site.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Both property types will require a method to display the characteristics of
    that property. At the moment, no other behaviors are apparent.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Rental properties will need to store the rent per month, whether the property
    is furnished, and whether utilities are included, and if not, what they are estimated
    to be. Properties for purchase will need to store the purchase price and estimated
    annual property taxes. For our application, we'll only need to display this data,
    so we can get away with just adding a `display()` method similar to that used
    in the other classes.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we'll need an `Agent` object that holds a list of all properties, displays
    those properties, and allows us to create new ones. Creating properties will entail
    prompting the user for the relevant details for each property type. This could
    be done in the `Agent` object, but then `Agent` would need to know a lot of information
    about the types of properties. This is not taking advantage of polymorphism. Another
    alternative would be to put the prompts in the initializer or even a constructor
    for each class, but this would not allow the classes to be applied in a GUI or
    web application in the future. A better idea is to create a static method that
    does the prompting and returns a dictionary of the prompted parameters. Then,
    all the `Agent` has to do is prompt the user for the type of property and payment
    method, and ask the correct class to instantiate itself.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s a lot of designing! The following class diagram may communicate our
    design decisions a little more clearly:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '![Case study](images/8781OS_3_03.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
- en: Wow, that's a lot of inheritance arrows! I don't think it would be possible
    to add another level of inheritance without crossing arrows. Multiple inheritance
    is a messy business, even at the design stage.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'The trickiest aspects of these classes is going to be ensuring superclass methods
    get called in the inheritance hierarchy. Let''s start with the `Property` implementation:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This class is pretty straightforward. We've already added the extra `**kwargs`
    parameter to `__init__` because we know it's going to be used in a multiple inheritance
    situation. We've also included a call to `super().__init__` in case we are not
    the last call in the multiple inheritance chain. In this case, we're *consuming*
    the keyword arguments because we know they won't be needed at other levels of
    the inheritance hierarchy.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: We see something new in the `prompt_init` method. This method is made into a
    static method immediately after it is initially created. Static methods are associated
    only with a class (something like class variables), rather than a specific object
    instance. Hence, they have no `self` argument. Because of this, the `super` keyword
    won't work (there is no parent object, only a parent class), so we simply call
    the static method on the parent class directly. This method uses the Python `dict`
    constructor to create a dictionary of values that can be passed into `__init__`.
    The value for each key is prompted with a call to `input`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Apartment` class extends `Property`, and is similar in structure:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `display()` and `__init__()` methods call their respective parent class
    methods using `super()` to ensure the `Property` class is properly initialized.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: The `prompt_init` static method is now getting dictionary values from the parent
    class, and then adding some additional values of its own. It calls the `dict.update`
    method to merge the new dictionary values into the first one. However, that `prompt_init`
    method is looking pretty ugly; it loops twice until the user enters a valid input
    using structurally similar code but different variables. It would be nice to extract
    this validation logic so we can maintain it in only one location; it will likely
    also be useful to later classes.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: With all the talk on inheritance, we might think this is a good place to use
    a mixin. Instead, we have a chance to study a situation where inheritance is not
    the best solution. The method we want to create will be used in a static method.
    If we were to inherit from a class that provided validation functionality, the
    functionality would also have to be provided as a static method that did not access
    any instance variables on the class. If it doesn't access any instance variables,
    what's the point of making it a class at all? Why don't we just make this validation
    functionality a module-level function that accepts an input string and a list
    of valid answers, and leave it at that?
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore what this validation function would look like:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We can test this function in the interpreter, independent of all the other classes
    we've been working on. This is a good sign, it means different pieces of our design
    are not tightly coupled to each other and can later be improved independently,
    without affecting other pieces of code.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, let''s quickly update our `Apartment.prompt_init` method to use this new
    function for validation:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'That''s much easier to read (and maintain!) than our original version. Now
    we''re ready to build the `House` class. This class has a parallel structure to
    `Apartment`, but refers to different prompts and variables:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'There''s nothing new to explore here, so let''s move on to the `Purchase` and
    `Rental` classes. In spite of having apparently different purposes, they are also
    similar in design to the ones we just discussed:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'These two classes don''t have a superclass (other than `object`), but we still
    call `super().__init__` because they are going to be combined with the other classes,
    and we don''t know what order the `super` calls will be made in. The interface
    is similar to that used for `House` and `Apartment`, which is very useful when
    we combine the functionality of these four classes in separate subclasses. For
    example:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This is slightly surprising, as the class on its own has neither an `__init__`
    nor `display` method! Because both parent classes appropriately call `super` in
    these methods, we only have to extend those classes and the classes will behave
    in the correct order. This is not the case with `prompt_init`, of course, since
    it is a static method that does not call `super`, so we implement this one explicitly.
    We should test this class to make sure it is behaving properly before we write
    the other three combinations:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: It looks like it is working fine. The `prompt_init` method is prompting for
    initializers to all the super classes, and `display()` is also cooperatively calling
    all three superclasses.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The order of the inherited classes in the preceding example is important. If
    we had written `class HouseRental(House, Rental)` instead of `class HouseRental(Rental,
    House)`, `display()` would not have called `Rental.display()`! When `display`
    is called on our version of `HouseRental`, it refers to the `Rental` version of
    the method, which calls `super.display()` to get the `House` version, which again
    calls `super.display()` to get the property version. If we reversed it, `display`
    would refer to the `House` class's `display()`. When super is called, it calls
    the method on the `Property` parent class. But `Property` does not have a call
    to `super` in its `display` method. This means `Rental` class's `display` method
    would not be called! By placing the inheritance list in the order we did, we ensure
    that `Rental` calls `super`, which then takes care of the `House` side of the
    hierarchy. You might think we could have added a `super` call to `Property.display()`,
    but that will fail because the next superclass of `Property` is `object`, and
    `object` does not have a `display` method. Another way to fix this is to allow
    `Rental` and `Purchase` to extend the `Property` class instead of deriving directly
    from `object`. (Or we could modify the method resolution order dynamically, but
    that is beyond the scope of this book.)
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have tested it, we are prepared to create the rest of our combined
    subclasses:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'That should be the most intense designing out of our way! Now all we have to
    do is create the `Agent` class, which is responsible for creating new listings
    and displaying existing ones. Let''s start with the simpler storing and listing
    of properties:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Adding a property will require first querying the type of property and whether
    property is for purchase or rental. We can do this by displaying a simple menu.
    Once this has been determined, we can extract the correct subclass and prompt
    for all the details using the `prompt_init` hierarchy we''ve already developed.
    Sounds simple? It is. Let''s start by adding a dictionary class variable to the
    `Agent` class:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'That''s some pretty funny looking code. This is a dictionary, where the keys
    are tuples of two distinct strings, and the values are class objects. Class objects?
    Yes, classes can be passed around, renamed, and stored in containers just like
    *normal* objects or primitive data types. With this simple dictionary, we can
    simply hijack our earlier `get_valid_input` method to ensure we get the correct
    dictionary keys and look up the appropriate class, like this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This may look a bit funny too! We look up the class in the dictionary and store
    it in a variable named `PropertyClass`. We don't know exactly which class is available,
    but the class knows itself, so we can polymorphically call `prompt_init` to get
    a dictionary of values appropriate to pass into the constructor. Then we use the
    keyword argument syntax to convert the dictionary into arguments and construct
    the new object to load the correct data.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Now our user can use this `Agent` class to add and view lists of properties.
    It wouldn''t take much work to add features to mark a property as available or
    unavailable or to edit and remove properties. Our prototype is now in a good enough
    state to take to a real estate `agent` and demonstrate its functionality. Here''s
    how a demo session might work:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Exercises
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Look around you at some of the physical objects in your workspace and see if
    you can describe them in an inheritance hierarchy. Humans have been dividing the
    world into taxonomies like this for centuries, so it shouldn't be difficult. Are
    there any non-obvious inheritance relationships between classes of objects? If
    you were to model these objects in a computer application, what properties and
    methods would they share? Which ones would have to be polymorphically overridden?
    What properties would be completely different between them?
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Now, write some code. No, not for the physical hierarchy; that's boring. Physical
    items have more properties than methods. Just think about a pet programming project
    you've wanted to tackle in the past year, but never got around to. For whatever
    problem you want to solve, try to think of some basic inheritance relationships.
    Then implement them. Make sure that you also pay attention to the sorts of relationships
    that you actually don't need to use inheritance for. Are there any places where
    you might want to use multiple inheritance? Are you sure? Can you see any place
    you would want to use a mixin? Try to knock together a quick prototype. It doesn't
    have to be useful or even partially working. You've seen how you can test code
    using `python -i` already; just write some code and test it in the interactive
    interpreter. If it works, write some more. If it doesn't, fix it!
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Now, take a look at the real estate example. This turned out to be quite an
    effective use of multiple inheritance. I have to admit though, I had my doubts
    when I started the design. Have a look at the original problem and see if you
    can come up with another design to solve it that uses only single inheritance.
    How would you do it with abstract base classes? What about a design that doesn't
    use inheritance at all? Which do you think is the most elegant solution? Elegance
    is a primary goal in Python development, but each programmer has a different opinion
    as to what is the most elegant solution. Some people tend to think and understand
    problems most clearly using composition, while others find multiple inheritance
    to be the most useful model.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Finally, try adding some new features to the three designs. Whatever features
    strike your fancy are fine. I'd like to see a way to differentiate between available
    and unavailable properties, for starters. It's not of much use to me if it's already
    rented!
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Which design is easiest to extend? Which is hardest? If somebody asked you why
    you thought this, would you be able to explain yourself?
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've gone from simple inheritance, one of the most useful tools in the object-oriented
    programmer's toolbox, all the way through to multiple inheritance, one of the
    most complicated. Inheritance can be used to add functionality to existing classes
    and built-ins using inheritance. Abstracting similar code into a parent class
    can help increase maintainability. Methods on parent classes can be called using
    `super` and argument lists must be formatted safely for these calls to work when
    using multiple inheritance.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll cover the subtle art of handling exceptional circumstances.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
