- en: Creating a User Interface with Qt Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn to use the following widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a welcome message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Radio Button widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grouping radio buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying options in the form of checkboxes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying two groups of checkboxes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be learning to create GUI applications using the Qt toolkit. The Qt
    toolkit, known simply as Qt, is a cross-platform application and UI framework
    developed by **Trolltech**, which is used for developing GUI applications. It
    runs on several platforms, including Windows, macOS X, Linux, and other UNIX platforms.
    It is also referred to as a widget toolkit because it provides widgets such as
    buttons, labels, textboxes, push buttons, and list boxes, which are required for
    designing a GUI. It includes a cross-platform collection of classes, integrated
    tools, and a cross-platform IDE. To create real-time applications, we will be
    making use of Python bindings for the Qt toolkit called, **PyQt5**.
  prefs: []
  type: TYPE_NORMAL
- en: PyQt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PyQt is a set of Python bindings for the cross-platform application framework that
    combines all the advantages of Qt and Python. With PyQt, you can include Qt libraries
    in Python code, enabling you to write GUI applications in Python. In other words,
    PyQt allows you to access all the facilities provided by Qt through Python code.
    Since PyQt depends on the Qt libraries to run, when you install PyQt, the required
    version of Qt is also installed automatically on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: A GUI application may consist of a main window with several dialogs or just
    a single dialog. A small GUI application usually consists of at least one dialog.
    A dialog application contains buttons. It doesn't contain a menu bar, toolbar,
    status bar, or central widget, whereas a main window application normally has
    all of those.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dialogs are of the following two types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Modal**: This dialog is one that blocks the user from interacting with other
    parts of the application. The dialog is the only part of the application that
    the user can interact with. Until the dialog is closed, no other part of the application
    can be accessed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modeless**: This dialog is the opposite of a modal dialog. When a modeless
    dialog is active, the user is free to interact with the dialog and with the rest
    of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ways of creating GUI applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are the following two ways to write a GUI application:'
  prefs: []
  type: TYPE_NORMAL
- en: From scratch, using a simple text editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With Qt Designer, a visual design tool with which you can create a user interface
    quickly using drag and drop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will be using Qt Designer to develop GUI applications in PyQt, as it is
    a quick and easy way to design user interfaces without writing a single line of
    code. So, launch Qt Designer by double-clicking on its icon on desktop.
  prefs: []
  type: TYPE_NORMAL
- en: 'On opening, Qt Designer asks you to select a template for your new application,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4c0a403e-cd4c-427f-93aa-fcfdc443eefd.png)'
  prefs: []
  type: TYPE_IMG
- en: Qt Designer provides a number of templates that are suitable for different kinds
    of applications. You can choose any of these templates and then click the Create
    button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Qt Designer provides the following predefined templates for a new application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dialog with Buttons Bottom: This template creates a form with the OK and Cancel
    buttons in the bottom-right corner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dialog with Buttons Right: This template creates a form with the OK and Cancel
    buttons in the top-right corner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dialog without Buttons: This template creates an empty form on which you can
    place widgets. The superclass for dialogs is `QDialog`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Main Window: This template provides a main application window with a menu bar
    and a toolbar that can be removed if not required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Widget: This template creates a form whose superclass is `QWidget` rather than
    `QDialog`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every GUI application has a top-level widget and the rest of the widgets are
    called its children. The top-level widget can be `QDialog`, `QWidget`, or `QMainWindow`,
    depending on the template you require. If you want to create an application based
    on the dialog template, then the top-level widget or the first class that you
    inherit will be `QDialog`. Similarly, to create an application based on the Main
    Window template, the top-level widget will be `QMainWindow`, and to create the
    application based on the Widget template, you need to inherit the `QWidget` class.
    As mentioned previously, the rest of the widgets that are used for the user interface
    are called child widgets of the classes.
  prefs: []
  type: TYPE_NORMAL
- en: Qt Designer displays a menu bar and toolbar at the top. It shows a Widget box
    on the left that contains a variety of widgets used to develop applications, grouped
    in sections. All you have to do is drag and drop the widgets you want from the
    form. You can arrange widgets in layouts, set their appearance, provide initial
    attributes, and connect their signals to slots.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a welcome message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, the user will be prompted to enter his/her name followed by
    clicking a push button. On clicking the button, a welcome message will appear,
    "Hello," followed by the name entered by the user. For this recipe, we need to
    make use of three widgets, Label, Line Edit, and Push Button. Let's understand
    these widgets one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Label widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Label widget is an instance of the `QLabel` class and is used for displaying
    messages and images. Because the Label widgets simply display results of computations
    and don't take any input, they are simply used for supplying information on the
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the methods provided by the `QLabel` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setText()`: This method assigns text to the Label widget'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setPixmap()`: This method assigns `pixmap`, an instance of the `QPixmap` class,
    to the Label widget'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setNum()`: This method assigns an integer or double value to the Label widget'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clear()`: This method clears text from the Label widget'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default text of `QLabel` is TextLabel. That is, when you add a `QLabel`
    class to a form by dragging a Label widget and dropping it on the form, it will
    display TextLabel. Besides using `setText()`, you can also assign text to a selected
    `QLabel` object by setting its text property in the Property Editor window.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Line Edit widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Line Edit widget is that is popularly used for entering single-line data.
    The Line Edit widget is an instance of the `QLineEdit` class, and you can not
    only enter, but also edit the data too. Besides entering data, you can undo, redo,
    cut, and paste data in the Line Edit widget.
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the methods provided by the `QLineEdit` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setEchoMode()`: It sets the echo mode of the Line Edit widget. That is, it
    determines how the contents of the Line Edit widget are to be displayed. The available
    options are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Normal`: This is the default mode and it displays characters the way they
    are entered'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NoEcho`: It switches off the Line Edit echo, that is, it doesn''t display
    anything'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Password`: This option is used for password fields, no text will be displayed;
    instead, asterisks appear for the text entered by the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PasswordEchoOnEdit`: It displays the actual text while editing the password
    fields, otherwise it will display the asterisks for the text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxLength()`: This method is used to specify the maximum length of text that
    can be entered in the Line Edit widget.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setText()`: This method is used for assigning text to the Line Edit widget.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`text()`: This method accesses the text entered in the Line Edit widget.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clear()`: This method clears or deletes the complete content of the Line Edit
    widget.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setReadOnly()`: When the Boolean value true is passed to this method, it will
    make the Line Edit widget read-only, that is, non-editable. The user cannot make
    any changes to the contents displayed through the Line Edit widget, but can only
    copy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isReadOnly()`: This method returns the Boolean value true if the Line Edit
    widget is in read-only mode, otherwise it returns false.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setEnabled()`: By default, the Line Edit widget is enabled, that is, the user
    can make changes to it. But if the Boolean value false is passed to this method,
    it will disable the Line Edit widget so the user cannot edit its content, but
    can only assign text via the `setText()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setFocus()`: This method positions the cursor on the specified Line Edit widget.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Push Button widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To display a push button in an application, you need to create an instance
    of the `QPushButton` class. When assigning text to buttons, you can create shortcut
    keys by preceding any character in the text with an ampersand. For example, if
    the text assigned to a push button is `Click Me`, the character `C` will be underlined
    to indicate that it is a shortcut key, and the user can select the button by pressing
    *Alt* + *C*. The button emits the clicked() signal if it is activated. Besides
    text, an icon can also be displayed in the push button. The methods for displaying
    text and an icon in a push button are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setText()`: This method is used to assign text to the push button'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setIcon()`: This method is used to assign an icon to the push button'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a new application based on the Dialog without Buttons template.
    As said earlier, this application will prompt the user to enter a name and, on
    clicking the push button after entering a name, the application with display a
    hello message along with the entered name. Here are the steps to create this application:'
  prefs: []
  type: TYPE_NORMAL
- en: The other Label with default text should have the objectName property of  `labelResponse`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag one more Label widget from the Display Widgets category and drop it on
    the form. Do not change the text property of this Label widget and leave its text
    property to its default value, TextLabel. This is because the text property of
    this Label widget will be set through code, that is, it will be used to display
    the hello message to the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag one Line Edit from the Input Widgets category and drop it on the form.
    Set its objectName property to `lineEditName.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag one Push Button widget from the Buttons category and drop it onto the
    form. Set its text property to `Click`. You can change the text property of the
    Push Button widget through any of three ways: by double-clicking the Push Button
    widget and overwriting the default text, by right-clicking the Push Button widget
    and selecting the Change text... option from the context menu that pops up, or
    by selecting the text property from the Property Editor window and overwriting
    the default text.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the objectName property of the Push Button widget to `ButtonClickMe`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Save the application with the name `demoLineEdit.ui`. Now the form will appear,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/d296bf34-b970-46a3-af33-77336aebb427.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The user interface that you create with Qt Designer is stored in a `.ui` file
    that includes all the form''s information: its widgets, layout, and so on. The
    `.ui` file is an XML file, and you need to convert it to Python code. That way,
    you can maintain a clear separation between the visual interface and the behavior
    implemented in code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `.ui` file, you first need to convert it into a Python script. The
    command utility that you will use for converting a `.ui` file into a Python script
    is `pyuic5`. In Windows, the `pyuic5` utility is bundled with PyQt. To do the
    conversion, you need to open a Command Prompt window and navigate to the folder
    where the file is saved and issue the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let's assume that we saved the form at this location: `C:\Pythonbook\PyQt5>`.
    The preceding command shows the conversion of the `demoLineEdit.ui` file into
    a Python script, `demoLineEdit.py`.
  prefs: []
  type: TYPE_NORMAL
- en: The Python code generated by this method should not be modified manually, as
    any changes will be overwritten the next time you run the `pyuic5` command.
  prefs: []
  type: TYPE_NORMAL
- en: The code of the generated Python script file, `demoLineEdit.py`, can be seen
    in the source code bundle of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Treat the code in the `demoLineEdit.py` file as a header file, and import it
    to the file from which you will invoke its user interface design.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The header file is a term referred to those files which are imported into the
    current file. The command to import such files is usually written at the top in
    the script, hence named as header files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create another Python file with the name `callLineEdit.py` and import
    the `demoLineEdit.py` code into it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `demoLineEdit.py` file is very easy to understand. A class with the name
    of the top-level object is created, with `Ui_` prepended. Since the top-level
    object used in our application is `Dialog`, the `Ui_Dialog` class is created and
    stores the interface elements of our widget. That class has two methods, `setupUi()`
    and `retranslateUi()`. The `setupUi()` method sets up the widgets; it creates
    the widgets that you use while defining the user interface in Qt Designer. The
    method creates the widgets one by one and also sets their properties. The `setupUi()`
    method takes a single argument, which is the top-level widget in which the user
    interface (child widgets) is created. In our application, it is an instance of
    `QDialog`. The `retranslateUi()` method translates the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand what `callLineEdit.py` does statement-wise:'
  prefs: []
  type: TYPE_NORMAL
- en: It imports the necessary modules. `QWidget` is the base class of all user interface
    objects in PyQt5.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It creates a new `MyForm` class that inherits from the base class, `QDialog`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It provides the default constructor for `QDialog`. The default constructor has
    no parent, and a widget with no parent is known as a window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Event handling in PyQt5 uses signals and slots. A signal is an event, and a
    slot is a method that is executed on the occurrence of a signal. For example,
    when you click a push button, a `clicked()` event, also known as a signal, occurs.
    The `connect()` method connects signals with slots. In this case, the slot is
    a method: `dispmessage()`. That is, when the user clicks the push button, the
    `dispmessage()` method will be invoked. `clicked()` is an event here and an event
    handling loop waits for an event to occur and then dispatches it to perform some
    task. The event handling loop continues to work until either the `exit()` method
    is called or the main widget is destroyed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It creates an application object with the name `app` through the `QApplication()`
    method. Every PyQt5 application must create `sys.argv` application object which
    contains a list of arguments from the command line, and it is passed to the method
    while creating the application object. The `sys.argv` parameter helps in passing
    and controlling the startup attributes of a script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An instance of the `MyForm` class is created with the name `w`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `show()` method will display the widget on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `dispmessage()` method performs event handling for the push button. It displays
    the Hello text, along with the name entered in the Line Edit widget.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `sys.exit()` method ensures a clean exit, releasing memory resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `exec_()` method has an underscore because `exec` is a Python keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'On executing the preceding program, you get a window with the Line Edit and
    Push Button widgets, as shown in the following screenshot. When the push button
    is selected, the `dispmessage()` method will be executed, displaying the Hello
    message along with the user''s name that is entered in the Line Edit widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1aa5d22d-74f6-4f2d-9664-791751d4bedb.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the Radio Button widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe displays certain flight types via Radio Button and when the user
    selects the radio button, the price associated with that flight will be displayed.
    We need to first understand the workings of Radio Button.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Radio Button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Radio Button widgets are very popular when you want the user to select only
    one option out of the available options. Such options are known as mutually exclusive
    options. When the user selects an option, the previously selected option is automatically
    deselected. The Radio Button widgets are instances of the `QRadioButton` class.
    Every radio button has an associated text label. The radio button can be either
    in selected (checked) or unselected (unchecked) states. If you want two or more
    sets of radio buttons, where each set allows the exclusive selection of a radio
    button, put them into different button groups (instances of `QButtonGroup`). The
    methods provided by `QRadioButton` are shown next.
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `QRadioButton` class provides the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`isChecked()`: This method returns the Boolean value true if the button is
    in the selected state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setIcon()`: This method displays an icon with the radio button.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setText()`: This method assigns the text to the radio button. If you want
    to specify a shortcut key for the radio button, precede the preferred character
    in the text with an ampersand (`&`). The shortcut character will be underlined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setChecked()`: To make any radio button appear selected by default, pass the
    Boolean value true to this method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signal description
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Signals emitted by `QRadioButton` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'toggled(): This signal is emitted whenever the button changes its state from
    checked to unchecked or vice versa'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'clicked(): This signal is emitted when a button is activated (that is, pressed
    and released) or when its shortcut key is pressed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'stateChanged(): This signal is emitted when a radio button changes its state
    from checked to unchecked or vice versa'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To understand the concept of radio buttons, let's create an application that
    asks the user to select the flight type and displays three options, First Class,
    Business Class, and Economy Class, in the form of radio buttons. On selecting
    an option through the radio button, the price for that flight will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a new application based on the Dialog without Buttons template.
    This application will display different flight types along with their respective
    prices. When a user selects a flight type, its price will be displayed on the
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag and drop two Label widgets and three Radio Button widgets onto the form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the text property of the first Label widget to `Choose the flight type`
    and delete the text property of the second Label widget. The text property of
    the second Label widget will be set through code; it will be used to display the
    price of the selected flight type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the text property of the three Radio Button widgets to `First Class $150`,
    `Business Class $125`, and `Economy Class $100`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the objectName property of the second Label widget to `labelFare`. The default
    object names of the three radio buttons are `radioButton`, `radioButton_2`, and
    `radioButton_3`. Change the objectName property of these three radio buttons to
    `radioButtonFirstClass`, `radioButtonBusinessClass`, and `radioButtonEconomyClass`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the application with name `demoRadioButton1.ui`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/545e660b-5490-4767-8101-c8f7ab6dea60.png)'
  prefs: []
  type: TYPE_IMG
- en: The `demoRadioButton1.ui` application is an XML file and needs to be converted
    into Python code through the `pyuic5` command utility. The generated Python code,
    `demoRadioButton1.py`, can be seen in the source code bundle of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Import the `demoRadioButton1.py` file as a header file in the Python script
    that you are going to create next to invoke the user interface design.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Python script, write the code to display the flight type on the basis
    of the radio button selected by the user. Name the source file `callRadioButton1.py`;
    its code is shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The toggled() event of Radio Button is connected to the `dispFare()` function,
    which will display the price of the selected flight type. In the `dispFare()`
    function, you check the state of the radio buttons. Hence, if `radioButtonFirstClass`
    is selected, the value `150` is assigned to the fare variable. Similarly, if `radioButtonBusinessClass`
    is selected, the value `125` is assigned to the `fare` variable. Similarly, the
    value `100` is assigned to the `fare` variable when `radioButtonEconomyClass`
    is selected. Finally, the value in the `fare` variable is displayed via `labelFare`.
  prefs: []
  type: TYPE_NORMAL
- en: 'On executing the previous program, you get a dialog that displays three flight
    types and prompts the user to select the one that he/she wants to use for travel.
    On selecting a flight type, the price of the selected flight type is displayed,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1f097ec8-af6f-4177-8496-d35da2a29cc3.png)'
  prefs: []
  type: TYPE_IMG
- en: Grouping radio buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this application, we will learn to create two groups of radio buttons. The
    user can select radio buttons from either group and accordingly the result or
    text will appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will display a dialog that displays shirts of different sizes and different
    payment methods. On selecting a shirt size and a payment method, the selected
    shirt size and payment method will be displayed on the screen. We will create
    two groups of radio buttons, one of the shirt sizes and other payment methods.
    The shirt size group displays four radio buttons showing four different types
    of the size such as M, L, XL, and XXL, where M stands for medium size, L stands
    for large size, and so on. The payment method group displays three radio buttons, Debit/Credit
    Card, NetBanking, and Cash On Delivery. The user can select any radio button from
    either of the groups. When the user selects any of the shirt sizes or payment
    methods, the selected shirt size and payment method will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s recreate the preceding application step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new application based on the Dialog without Buttons template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag and drop three Label widgets and seven Radio Button widgets. Out of these
    seven radio buttons, we will arrange four radio buttons in one vertical layout
    and the other three radio buttons in the second vertical layout. The two layouts
    will help in grouping these radio buttons. Radio buttons being mutually exclusive
    will allow only one radio button to be selected from a layout or group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the text property of the first two Label widgets to `Choose your Shirt Size`
    and `Choose your payment method` respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the text property of the third Label widget because we will display the
    selected shirt size and payment method through the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Property Editor window, increase the font size of all the widgets to
    increase their visibility in the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the text property of the first four radio buttons to `M`, `L`, `XL`, and
    `XXL`. Arrange these four radio buttons into one vertical layout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the text property of the next three radio buttons to `Debit/Credit Card`,
    `NetBanking`, and `Cash On Delivery`. Arrange these three radio buttons into a
    second vertical layout. Remember, these vertical layouts help by grouping these
    radio buttons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the object names of the first four radio buttons to `radioButtonMedium`,
    `radioButtonLarge`, `radioButtonXL`, and `radioButtonXXL`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the objectName property of the first `VBoxLayout` layout to `verticalLayout`.
    The `VBoxLayout` layout will be used for aligning radio buttons vertically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the object names of next three radio buttons to `radioButtonDebitCard`,
    `radioButtonNetBanking`, and `radioButtonCashOnDelivery`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the objectName property of the second `QVBoxLayout` object to `verticalLayout_2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the objectName property of the third Label widget to `labelSelected`. It
    is through this Label widget that the selected shirt size and payment method will
    be displayed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the application with the name `demoRadioButton2.ui`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, the form will appear, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/8c185e1e-852e-46ca-bb90-d767f275c3ab.png)'
  prefs: []
  type: TYPE_IMG
- en: The `.ui` (XML) file is then converted into Python code through the `pyuic5`
    command utility. You can find the Python code, `demoRadioButton2.py`, in the source
    code bundle for this book.
  prefs: []
  type: TYPE_NORMAL
- en: Import the `demoRadioButton2.py` file, as a header file in our program to invoke
    the user interface design and to write code to display the selected shirt size
    and payment method through a Label widget when the user selects or unselects any
    of the radio buttons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s name the program `callRadioButton2.pyw`; its code is shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The toggled() event of all the radio buttons is connected to the `dispSelected()`
    function, which will display the selected shirt size and payment method. In the
    `dispSelected()` function, you check the status of the radio buttons to find out
    whether they are checked or unchecked. On the basis of the selected radio button
    in the first vertical layout, the value of the `selected1` variable will be set
    to `Medium`, `Large`, `Extra Large`, or `Extra Extra Large`. Similarly, from the
    second vertical layout, depending on the radio button selected, the value of the
    `selected2` variable will be initialized to Debit/Credit Card, NetBanking, or
    Cash On Delivery. Finally, the shirt size and payment method assigned to the `selected1`
    variable and selected variables will be displayed via the `labelSelected` widget.
    On running the application, you get a dialog prompting you to select the shirt
    size and payment method. On selecting a shirt size and payment method, the selected
    shirt size and payment method are displayed via the Label widget, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fbe0eafa-412a-4a05-8700-c88f95f491ee.png)'
  prefs: []
  type: TYPE_IMG
- en: Displaying options in the form of checkboxes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While creating applications, you may come across a situation where you need
    to provide several options for the user to select from. That is, you want the
    user to select one or more than one option from a set of options. In such situations,
    you need to make use of checkboxes. Let's find out more about checkboxes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whereas radio buttons allow only one option to be selected in a group, checkboxes
    allow you to select more than one option. That is, selecting a checkbox will not
    affect other checkboxes in the application. Checkboxes are displayed with a text
    label as an instance of the `QCheckBox` class. A checkbox can be in any of three
    states: selected (checked), unselected (unchecked), or tristate (unchanged). Tristate
    is a no change state; the user has neither checked nor unchecked the checkbox.'
  prefs: []
  type: TYPE_NORMAL
- en: Method application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the methods provided by the `QCheckBox` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`isChecked()`: This method returns the Boolean value true if the checkbox is
    checked, and otherwise returns false.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setTristate()`: If you don''t want the user to change the state of the checkbox,
    you pass the Boolean value true to this method. The user will not be able to check
    or uncheck the checkbox.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setIcon()`: This method is used to display an icon with the checkbox.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setText()`: This method assigns text to the checkbox. To specify a shortcut
    key for the checkbox, precede the preferred character in the text with an ampersand.
    The shortcut character will appear as underlined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setChecked()`: In order to make a checkbox appear as checked by default, pass
    the Boolean value true to this method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signal description
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The signals emitted by `QCheckBox` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'clicked(): This signal is emitted when a checkbox is activated (that is, pressed
    and released) or when its shortcut key is pressed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'stateChanged(): This signal is emitted whenever a checkbox changes its state
    from checked to unchecked or vice versa'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To understand the Check Box widget, let's assume that you run a restaurant where
    several food items, such as pizzas, are sold. The pizza is sold along with different
    toppings, such as extra cheese, extra olives, and so on, and the price of each
    topping is also mentioned with it. The user can select a regular pizza with one
    or more toppings. What you want is that when a topping is selected, the total
    price of the pizza, including the selected topping, is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The focus of this recipe is to understand how an action is initiated when the
    state of a checkbox changes from checked to unchecked or vice versa. Following
    is the step-by-step procedure to create such an application:'
  prefs: []
  type: TYPE_NORMAL
- en: Begin by creating a new application based on the Dialog without Buttons template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag and drop three Label widgets and three Check Box widgets onto the form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the text property of the first two Label widgets to `Regular Pizza $10`
    and `Select your extra toppings`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Property Editor window, increase the font size of all three labels and
    checkboxes to increase their visibility in the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the text property of the three checkboxes to `Extra Cheese $1`, `Extra Olives
    $1`, and `Extra Sausages $2`. The default object names of the three checkboxes
    are `checkBox`, `checkBox_2`, and `checkBox_3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change these to `checkBoxCheese`, `checkBoxOlives`, and `checkBoxSausages`,
    respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the objectName property of the Label widget to `labelAmount`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Save the application with the name `demoCheckBox1.ui`. Now, the form will appear
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/a49fb108-5909-488f-98fb-addd10717ebf.png)'
  prefs: []
  type: TYPE_IMG
- en: The `.ui` (XML) file is then converted into Python code through the `pyuic5`
    command utility. The Python code generated in the `demoCheckBox1.py` file can
    be seen in the source code bundle of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Import the `demoCheckBox1.py` file, as a header file in our program to invoke
    the user interface design and to write code to calculate the total cost of regular
    pizza, along with the selected toppings, through a Label widget when the user
    selects or unselects any of the checkboxes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s name the program `callCheckBox1.pyw`; its code is shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The stateChanged() event of checkboxes is connected to the `dispAmount` function,
    which will calculate the cost of the pizza along with the toppings selected. In
    the `dispAmount` function, you check the status of the checkboxes to find out
    whether they are checked or unchecked. The cost of the toppings whose checkboxes
    are checked is added and stored in the `amount` variable. Finally, the addition
    of the amount stored in the `amount` variable is displayed via `labelAmount`.
    On running the application, you get a dialog prompting you to select the toppings
    that you want to add to your regular pizza. On selecting any toppings, the amount
    of the regular pizza along with the selected toppings will be displayed on the
    screen, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4ed74906-5046-4431-99fb-2da485c83932.png)The `dispAmount` function
    will be invoked every time the status of any checkbox changes. As a result, the
    total amount will be displayed via the Label widget, as soon as any checkbox is
    checked or unchecked.'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying two groups of checkboxes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this application, we will learn to make two groups of checkboxes. The user
    can select any number of checkboxes from either group and, accordingly, the result
    will appear.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will try displaying a menu of a restaurant where different types of ice creams
    and drinks are served. We will create two groups of checkboxes, one of ice creams
    and the other of drinks. The ice cream group displays four checkboxes showing
    four different types of ice cream, mint chocolate chip, cookie dough, and so on,
    along with their prices. The drinks group displays three checkboxes, coffee, soda,
    and so on, along with their prices. The user can select any number of checkboxes
    from either of the groups. When the user selects any of the ice creams or drinks,
    the total price of the selected ice creams and drinks will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the steps to create an application, which explain how checkboxes can
    be arranged into different groups and how to take respective action when the state
    of any checkbox from any group changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new application based on the Dialog without Buttons template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag and drop four Label widgets, seven Check Box widgets, and two Group Box
    widgets onto the form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the text property of the first three Label widgets to `Menu`, `Select your
    IceCream`, and `Select your drink` respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the text property of the fourth Label widget because we will display
    the total amount of the selected ice creams and drinks through the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Through Property Editor, increase the font size of the all the widgets to increase
    their visibility in the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the text property of the first four checkboxes to `Mint Choclate Chips $4`,
    `Cookie Dough $2`, `Choclate Almond $3`, and `Rocky Road $5`. Put these four checkboxes
    into the first group box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the text property of the next three checkboxes to `Coffee $2`, `Soda $3`,
    and `Tea $1` respectively. Put these three checkboxes into the second group box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the object names of the first four checkboxes to `checkBoxChoclateChips`,
    `checkBoxCookieDough`, `checkBoxChoclateAlmond`, and `checkBoxRockyRoad`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the objectName property of the first group box to `groupBoxIceCreams`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the objectName property of the next three checkboxes to `checkBoxCoffee`,
    `checkBoxSoda`, and `checkBoxTea`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the objectName property of the second group box to `groupBoxDrinks`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the objectName property of the fourth Label widget to `labelAmount`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Save the application with the name `demoCheckBox2.ui`. It is through this Label
    widget that the total amount of the selected ice creams and drinks will be displayed,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/0c376114-b3d1-4706-8f83-f503e597ac9f.png)'
  prefs: []
  type: TYPE_IMG
- en: The `.ui` (XML) file is then converted into Python code through the `pyuic5`
    command utility. You can find the generated Python code, the `demoCheckbox2.py`
    file, in the source code bundle of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Import the `demoCheckBox2.py` file as a header file in our program to invoke
    the user interface design, and to write code to calculate the total cost of ice
    creams and drinks through a Label widget when the user selects or unselects any
    of the checkboxes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s name the program `callCheckBox2.pyw`; its code is shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The stateChanged() event of all the checkboxes is connected to the `dispAmount` function,
    which will calculate the cost of the selected ice creams and drinks. In the `dispAmount` function,
    you check the status of the checkboxes to find out whether they are checked or
    unchecked. The cost of the ice creams and drinks whose checkboxes are checked
    is added and stored in the `amount` variable. Finally, the addition of the amount
    stored in the `amount` variable is displayed via the `labelAmount` widget. On
    running the application, you get a dialog prompting you to select the ice creams
    or drinks that you want to order. On selecting the ice creams or drinks, the total
    amount of the chosen items will be displayed, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9e489150-d6f2-4a81-bb85-67494f09c7fd.png)'
  prefs: []
  type: TYPE_IMG
