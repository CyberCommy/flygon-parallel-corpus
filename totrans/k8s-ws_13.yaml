- en: 13\. Runtime and Network Security in Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at various resources that we can use to secure
    workloads running in our cluster. We will also understand a rough threat model
    and apply it to architect a secure cluster so that we can defend our cluster and
    application against various types of threats. By the end of this chapter, you
    will be able to create Role and ClusterRole, as well as RoleBinding and ClusterRoleBinding
    to control the access of any process or user to the Kubernetes API server and
    objects. Then, you will learn how to create a NetworkPolicy to restrict communication
    between your application and the database. You will also learn how to create a
    PodSecurityPolicy to ensure that the running components of your application are
    conforming to the defined limits.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last couple of chapters, we had our DevOps hat on and learned how to
    set up a cluster, as well as how to roll out new application versions safely and
    without downtime in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to switch gears a bit, take our DevOps hat off, and put on our
    security analyst hat. First, we will look at where someone might attack our Kubernetes
    cluster and how an unauthorized user could potentially wreak havoc in our cluster.
    After that, we're going to introduce a few of the security primitives of Kubernetes
    and how we can combat the most common forms of attack. Finally, we'll further
    modify our application and demonstrate how some of these security primitives work.
  prefs: []
  type: TYPE_NORMAL
- en: But before we get to any of it, let's begin by taking a brief look at the various
    areas of concern for security in a modern web application, as well as a basic
    paradigm for implementing effective security for our cluster. We'll start by examining
    what we call the "4Cs of Cloud Native Security."
  prefs: []
  type: TYPE_NORMAL
- en: Threat Modeling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is far beyond the scope of this chapter to adequately teach many of the necessary
    disciplines of security so that you have a rigorous understanding of how modern
    workload security should be implemented and orchestrated. However, we will briefly
    gain an idea of how we should be thinking about it. Threat modeling is a discipline
    where we examine the various areas where our applications could be subject to
    an attack or unauthorized usage.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider an HTTP web server. It will typically have ports 80 and
    443 exposed for serving web traffic, but it also acts as an entry point for any
    potential attackers. It may have a web management console exposed at a certain
    port. It may have certain other management ports open and API access to allow
    other software to manage it for automation purposes. The application runtime may
    need to regularly handle sensitive data. The entire end-to-end pipeline meant
    to create and deliver the application could expose various points that are vulnerable
    to compromise. The encryption algorithms that an application relies on may be
    compromised or made obsolete due to the increased sophistication of brute-force
    attacks. All these represent the various areas where our application could be
    subject to an attack.
  prefs: []
  type: TYPE_NORMAL
- en: 'An easy way to organize some of the attack vectors of our application is to
    remember the acronym **STRIDE**. It stands for the following types of attacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**S**poofing: A user or an application disguising themselves as someone else.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**T**ampering: Changing any data without seeking consent from or providing
    information to the concerned stakeholders.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**R**epudiation: Being able to deny your involvement in your actions and/or
    the lack of ability to trace any actions to a particular user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I**nformation disclosure: Exfiltrating privileged or sensitive information
    you were not intended to have.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**D**enial of service: Flooding a server with bogus requests to saturate its
    resources and deny it the ability to serve its intended purpose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**E**levation of privilege: Getting access to a restricted resource or privilege
    by exploiting bugs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many of the attacks that hackers carry out are designed to do one or more of
    the preceding, usually to jeopardize the confidentiality, integrity, and availability
    of our data. With this in mind, we can use a mental model of how we can think
    about where threats to our system might exist in various parts of a modern cloud
    native application stack. This mental model is called "The 4Cs of Cloud Native
    Security," and we'll be using it to organize our exploration of the security primitives
    of Kubernetes. Ideally, by leveraging all these primitives, this should give you
    a good level of confidence in your application's resistance to STRIDE-like attacks,
    specifically within the context of Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: The 4Cs of Cloud Native Security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Security can and should be organized into layers. This is considered a "defense
    in depth" approach to security and it is widely regarded by the technology community
    as the best way to prevent the compromise of any single component from exposing
    the whole system. When it comes to cloud native applications, we think of security
    in four layers: securing your code, containers, cluster, and cloud. The following
    diagram shows how they are organized. This helps us visualize that if a compromise
    happens at a lower level, it will most assuredly compromise a higher level that
    depends on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1: The 4Cs of Cloud Native Security'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_13_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.1: The 4Cs of Cloud Native Security'
  prefs: []
  type: TYPE_NORMAL
- en: Since this book is focused on Kubernetes, we'll zoom into cluster security and
    then begin to implement some of the suggestions in our example application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For suggestions on the other C''s, take a look at this link: [https://kubernetes.io/docs/concepts/security/overview/](https://kubernetes.io/docs/concepts/security/overview/).'
  prefs: []
  type: TYPE_NORMAL
- en: Cluster Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One way to think about Kubernetes is as a gigantic self-orchestrating pool of
    compute, networking, and storage. As such, in many respects, Kubernetes is *exactly
    like a cloud platform*. It is important to understand this equivalence because
    this mental abstraction allows us to reason differently as a cluster operator
    versus a cluster developer. A cluster operator would want to ensure that all the
    components *of* the cluster were secure and hardened against any workload. A cluster
    developer would concern themselves with ensuring that the workload they are defining
    for Kubernetes is running securely inside the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is where your work becomes a bit easy â€“ most cloud provider offerings
    from Kubernetes will ensure the security of the Kubernetes control plane for you.
    If, for whatever reason, you''re not able to leverage a cloud provider offering,
    you''ll want to read more in the documentation about securing your cluster at
    this link: [https://kubernetes.io/docs/tasks/administer-cluster/securing-a-cluster/](https://kubernetes.io/docs/tasks/administer-cluster/securing-a-cluster/).'
  prefs: []
  type: TYPE_NORMAL
- en: Even when you are using a cloud provider's offering, just because they are securing
    your control plane does not mean that your Kubernetes cluster is secure. The reason
    you cannot rely on your cloud provider's security is that your application, its
    container, or a poor policy implementation could leave your infrastructure very
    exposed to attacks. So, now, we need to talk about securing workloads within our
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There is active work being done in the Kubernetes community to improve security
    concepts and implementations. The relevant Kubernetes documentation should be
    revisited often to determine whether improvements have been made.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fortify our internal cluster security, we need to take a look at the following
    three concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Kubernetes RBAC**: This is the main policy engine of Kubernetes. It defines
    a system of roles and permissions, as well as how permissions are granted to those
    roles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NetworkPolicies**: These are (depending on your Container Network Interface
    plugin) policies that act as a "firewall" between Pods. Think of them as a Kubernetes-aware
    network access control list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PodSecurityPolicies**: These are defined at a particular scope (namespace,
    whole cluster) and serve as a definition of how a Pod is allowed to run in Kubernetes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will not be covering encrypting Kubernetes Secrets at rest in etcd as most
    cloud providers either handle that for you or the implementation is specific to
    that cloud provider (such as AWS KMS).
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes RBAC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive into RBAC, recall from *Chapter 4*, *How to Communicate with
    Kubernetes (API Server)*, how Kubernetes authorizes requests to the API. We learned
    that there are three stages â€“ Authentication, Authorization, and AdmissionControl.
    We will learn more about Admission Controllers in *Chapter 16*, *Kubernetes Admission
    Controllers*.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes supports multiple different methods of authenticating with the cluster,
    and you'll want to reference your cloud provider's documentation to get more details
    on their specific implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization logic is handled through something called **RBAC**. It stands
    for **role-based access control** and it's the foundation of how we constrain
    certain users and groups to the minimum necessary permissions to perform their
    job. This is based on a concept in software security called "the principle of
    least privilege." For example, if you are a software engineer for a credit card
    processing company, **Payment Card Industry Data Security Standard** (**PCI DSS**)
    compliance requires that you shouldn't have access to production clusters and
    customer data. Therefore, if you did have access to a cluster in production, you
    should have a role that has no privileges.
  prefs: []
  type: TYPE_NORMAL
- en: 'RBAC is implemented by cluster administrators through four different API objects:
    **Roles**, **RoleBindings**, **ClusterRoles**, and **ClusterRoleBindings**. Let''s
    look at how they work together by examining a diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2: Different objects interacting to implement RBAC'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_13_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.2: Different objects interacting to implement RBAC'
  prefs: []
  type: TYPE_NORMAL
- en: In this diagram, we can see that Kubernetes `User`/`Group` and `ServiceAccount`
    objects obtain their permissions by being bound to a `Role` or `ClusterRole`.
    Let's understand these objects individually.
  prefs: []
  type: TYPE_NORMAL
- en: Role
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is a sample spec for a Role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The various fields define the permissions that a Role should have:'
  prefs: []
  type: TYPE_NORMAL
- en: '`namespace`: Roles are scoped to a Kubernetes namespace, which is defined in
    this field. This makes a Role different from a ClusterRole, whose permissions
    apply for any namespace in the cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`verbs`: These describe which Kubernetes actions we are allowing. Some examples
    of commonly used verbs include `get`, `list`, `watch`, `create`, `update`, and
    `delete`. There are more, but these are usually good enough for most use cases.
    For a refresher on this, please refer to *The Kubernetes API* section of *Chapter
    4*, *How to Communicate with Kubernetes (API Server)*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apiGroups`: These describe which Kubernetes API groups the Role will have
    access to. These are specified as `<group>/<version>` (such as `apps/v1`). If
    you use CustomResourceDefinitions, these API groups can be referenced here as
    well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'A full list of API groups that ship with Kubernetes can be found here (as of
    version 1.18): [https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/).'
  prefs: []
  type: TYPE_NORMAL
- en: '`resources`: These describe which API objects we are talking about and are
    defined by the value in the `Kind` field of the object definition; for example,
    `deployment`, `secret`, `configmap`, `pod`, `node`, and others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RoleBinding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As shown in the preceding diagram, a RoleBinding binds or associates a Role
    to ServiceAccounts, users, or groups of users. Here''s a sample spec for a RoleBinding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This spec defines the subjects that should be able to use a Role to perform
    an action that requires authorization in Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`subjects`: This refers to an authenticated ServiceAccount, user, or group
    that should be able to use this Role.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`roleRef`: This refers to the Role they can assume.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ClusterRole
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A ClusterRole is identical to a Role in every way except one. Instead of granting
    permissions only inside one Kubernetes namespace, it grants this set of permissions
    cluster-wide.
  prefs: []
  type: TYPE_NORMAL
- en: ClusterRoleBinding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is identical to a RoleBinding except that it must be bound to a ClusterRole
    and not a Role. You cannot bind a ClusterRoleBinding to a Role, nor a RoleBinding
    to a ClusterRole.
  prefs: []
  type: TYPE_NORMAL
- en: Some Important Notes about RBAC Policies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RBAC policy documents are allow-only. This means that, by default, a subject
    has no access, and only via RoleBinding or ClusterRoleBinding will it have the
    specific access set forth in the corresponding Role or ClusterRole.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bindings are immutable. This means that once you have bound a subject to a Role
    or ClusterRole, it cannot be changed. This is to prevent privilege escalation.
    As such, an entity can be granted permission to modify objects (which is good
    enough for many use cases) while preventing it from elevating its own privileges.
    If you need to modify a binding, simply delete and recreate it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A ClusterRole or Role that can create other ClusterRoles and Roles will only
    be able to grant, at most, the same permissions it has. Otherwise, it would be
    a clear privilege escalation path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ServiceAccount
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapters, when we learned about authentication in terms of Minikube
    and Kops, we saw that Kubernetes generated certificates that we used. In the case
    of EKS, AWS IAM roles and the AWS IAM Authenticator were used.
  prefs: []
  type: TYPE_NORMAL
- en: As it turns out, Kubernetes has a special object type for allowing resources
    within the cluster to authenticate with the API server.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the ServiceAccount resource to allow Pods to receive a Kubernetes-generated
    token that it will pass to the API server for authentication. All official Kubernetes
    client libraries support this type of authentication, so it is the preferred method
    for programmatic Kubernetes cluster access from within the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are running as a cluster admin, you can use `kubectl` to authenticate
    using a particular ServiceAccount using the `--as` parameter. For the example
    ServiceAccount shown previously, this would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We'll learn how these objects work together so that we can control access in
    the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.01: Creating a Kubernetes RBAC ClusterRole'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will create a ClusterRole and ClusterRoleBinding. Then,
    we will become the user and inherit their permissions, as defined by the ClusterRole,
    and demonstrate how Kubernetes prevents access to certain APIs based on rules.
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, we will recreate the EKS cluster from the Terraform file we
    used in *Exercise 12.02*, *Creating a Cluster with EKS Using Terraform*. If you
    already have the `main.tf` file, you can work with it. Otherwise, you can run
    the following command to get it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, use the following two commands, one after the other, to get your cluster
    resources up and running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: After performing any of these exercises, if you plan to continue working through
    the following exercises after a significant amount of time, it might be a good
    idea to deallocate your cluster resources to stop AWS billing. You can do that
    using the `terraform destroy` command. Then, you can run this step to get everything
    back online again when you are ready to perform an exercise or activity.
  prefs: []
  type: TYPE_NORMAL
- en: If any exercise or activity relies on objects that were created in the previous
    exercises, you will need to recreate those objects as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''re going to create three YAML files for our RBAC resources. The first
    is a ServiceAccount that lets us have identity and authentication tokens granted
    to us by the cluster. Create a file called `sa.yaml` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we are going to create a ClusterRole object and assign it some permissions.
    Create a file called `cr.yaml` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We are defining a `ClusterRole` with the ability to list all the Pods in any
    namespace, but nothing else.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to create a `ClusterRoleBinding` object that will bind the
    created ServiceAccount and ClusterRole. Create a file called `crb.yaml` with the
    following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In these files, we are defining three objects: a `ServiceAccount`, a `ClusterRole`,
    and a `ClusterRoleBinding`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to create this RBAC policy, as well as our ServiceAccount:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3: Creating a ServiceAccount, a ClusterRole, and a ClusterRoleBinding'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_13_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.3: Creating a ServiceAccount, a ClusterRole, and a ClusterRoleBinding'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following steps, we will demonstrate that using our service account''s
    ClusterRole will prevent us from describing Pods. But before that, let''s get
    a list of the Pods and prove that everything still works. Do this by running the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4: Getting the list of Pods'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_13_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.4: Getting the list of Pods'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s describe the first Pod. The name of the first Pod here is `aws-node-fzr6m`.
    The `describe` command, in this case, would be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Please use the Pod name that you have for your cluster. You should see a response
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5: Describing the aws-node-fzr6m Pod'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_13_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.5: Describing the aws-node-fzr6m Pod'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows the truncated version of the output of the `describe`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will run the same commands we used previously, but this time pretending
    to be the user using the ServiceAccount that is currently bound to the ClusterRole
    and ClusterRoleBinding that we created. We''ll do this by using the `--as` parameter
    with `kubectl`. Thus, the command will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we can assume the ClusterRole because we are an admin in the cluster
    that we created. You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6: Getting the list of Pods while assuming the test-sa ServiceAccount'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_13_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.6: Getting the list of Pods while assuming the test-sa ServiceAccount'
  prefs: []
  type: TYPE_NORMAL
- en: Sure enough, that still works. As you may recall from *step 3*, we mentioned
    the `list` as an allowed verb, which is what's used for fetching the list of all
    resources of a certain kind.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see what happens if a user with the ClusterRole we created attempts
    to describe a Pod:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7: Forbidden error'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_13_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.7: Forbidden error'
  prefs: []
  type: TYPE_NORMAL
- en: The kubectl `describe` command uses the `get` verb. Recall from *step 3* that
    it was not on the allowed list of verbs for our ClusterRole.
  prefs: []
  type: TYPE_NORMAL
- en: 'If this were a user (or a hacker) trying to use any command not allowed for
    them, we would have successfully stopped it. There are many practical RBAC examples
    available on the Kubernetes documentation website. It is beyond the scope of this
    chapter to talk about all the design patterns for RBAC in Kubernetes. All we can
    say is this: wherever possible, you should be practicing the "principle of least
    privilege" to limit unnecessary access to the Kubernetes API server. That is,
    everyone should get the minimum level of access required to do their job; not
    everyone needs to be a cluster admin.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While we cannot make specific recommendations about security at your company,
    we can say that there are a few good "rules of thumb," which can be stated as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever possible, try to make cluster contributors/users inside of a Role instead
    of a ClusterRole. Since a Role is constrained to a namespace, this will prevent
    that user from gaining unauthorized access to another namespace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only cluster admins should have access to ClusterRoles, which should be limited
    and temporary in scope. For example, if you do on-call rotations where engineers
    are responsible for the availability of your services, then they should only have
    an admin ClusterRole for the time they are on call.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NetworkPolicies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NetworkPolicy objects in Kubernetes are essentially Network Access Control Lists
    but at the Pod and namespace level. They work by using label selection (such as
    Services) or by indicating a CIDR IP address range to allow on a particular port/protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is immensely helpful for ensuring security, especially when you have multiple
    microservices running on a cluster. Now, imagine you have a cluster that hosts
    many applications for your company. It hosts a marketing website that runs an
    open-source library, a database server with sensitive data, and an application
    server that controls access to that data. If the marketing website doesn''t need
    to access the database, then there should be no reason for it to be allowed access
    to the database. By using a NetworkPolicy, we can prevent an exploit or a bug
    in the marketing website from allowing an attacker to expand that attack so that
    they can access your business data by preventing the marketing website Pod from
    even being able to talk to the database. Let''s take a look at a sample NetworkPolicy
    document and decipher it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s examine some of the fields of this NetworkPolicy:'
  prefs: []
  type: TYPE_NORMAL
- en: It contains the standard `apiVersion`, `kind`, and `metadata` fields that we
    described earlier in this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`podSelector`: The labels it should look for in the namespace to apply the
    policy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`policyTypes`: Can be either ingress, egress, or both. This means that the
    network policy applies to either traffic coming into the Pods being selected,
    leaving the Pods being selected, or both.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ingress`: This takes a `from` block that defines where traffic can originate
    from in the policy. This can be a namespace, a Pod selector, or an IP address
    block and port combination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Egress`: This takes a `to` block and defines where traffic is allowed to go
    to in the network policy. This can be a namespace, a Pod selector, or an IP address
    block and port combination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your CNI may not have a mature implementation of NetworkPolicies, so be sure
    to consult your cloud provider's documentation for more information. In the case
    of the cluster we set up using EKS, it is using the Amazon CNI. We can use **Calico**,
    an open-source project, to augment the existing EKS CNI and make up for deficiencies
    with respect to enforcing NetworkPolicy declarations. It is worth mentioning that
    Calico can be used as a CNI as well, but we will only be using the supplementary
    functionality for NetworkPolicy enforcement in the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.02: Creating a NetworkPolicy'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will implement Calico to augment the out-of-the-box enforcement
    of NetworkPolicy declarations available with Amazon CNI in EKS. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to install the Amazon CNI with Calico:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a response similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.8: Installing Amazon CNI with Calico'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_13_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.8: Installing Amazon CNI with Calico'
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that you have deployed the DaemonSet corresponding to Calico successfully,
    use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the `calico-node` DaemonSet, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.9: Checking the calico-node DaemonSet'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_13_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.9: Checking the calico-node DaemonSet'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create our NetworkPolicy object. First, create a file named `net_pol_all_deny.yaml`
    with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This policy is a very simple NetworkPolicy. It says that no traffic to and from
    Pods is allowed in or out of the cluster. This is the secure base on which we're
    going to continue expanding our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s apply our policy using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, there is no traffic flowing through our cluster. We can prove this by deploying
    our application since it needs the network to communicate with itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a test application, we will use the same application we used in *Exercise
    12.04*, *Deploying an Application Version Update*. If you already have the YAML
    file for that, you can use it. Otherwise, run the following command to get the
    file in your working directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use the following command to deploy the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.10: Deploying our application'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_13_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.10: Deploying our application'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s check the status of our deployment using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.11: Checking the status of our application'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_13_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.11: Checking the status of our application'
  prefs: []
  type: TYPE_NORMAL
- en: This is a truncated screenshot. As you can see, we have an issue that we are
    unable to communicate with Redis. Fixing this will be a part of *Activity 13.01*,
    *Going Beyond Primitives*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to test network access now, so in a separate Terminal window,
    let''s start our proxy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see this response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to verify that the NetworkPolicy is preventing traffic is to use
    our `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a response similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we are able to prevent unauthorized communication between Pods
    in our Kubernetes cluster. By leveraging NetworkPolicies, we can prevent attackers
    from doing further damage if they are able to compromise some of the components
    of our cluster, containers, or source code.
  prefs: []
  type: TYPE_NORMAL
- en: PodSecurityPolicy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have learned about and tested Kubernetes RBAC to prevent unauthorized
    API server access, and also applied a NetworkPolicy to prevent unnecessary network
    communication. The next most important area of security outside the network is
    the application runtime. Attackers need access to the network to get in and out,
    but they also need a vulnerable runtime to do anything more serious. This is where
    Kubernetes PodSecurityPolicy objects help prevent that from happening.
  prefs: []
  type: TYPE_NORMAL
- en: PodSecurityPolicy objects overlap with a specific type of AdmissionController
    and allow a cluster operator to dynamically define the minimum runtime requirements
    of a Pod that's been admitted for scheduling on the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: To understand exactly how PodSecurityPolicies can be useful, let's consider
    the following scenario. You are a Kubernetes cluster admin at a large financial
    institution. Your company uses ticket-based change management software in an ITIL-compliant
    fashion (ITIL is a standardized change management framework for IT services) to
    ensure that changes that are made to the environment are stable. This prevents
    developers from doing anything disastrous in production. To keep up with the change
    of pace in the market that your customers are demanding, you need a programmatic
    way to enable developers to do more change management autonomously. But you also
    need to do so in a way that is secure and compliant with certain standards. PodSecurityPolicies
    help us do this because they allow administrators to create policy definitions
    in software that are enforced when a Pod is being admitted to a cluster. This
    means that developers can move more rapidly, and cluster admins can still certify
    that their environment is fully compliant with the set standards.
  prefs: []
  type: TYPE_NORMAL
- en: Further extending this scenario, you might want to prevent users from running
    their container as the root user so that attackers can't exploit any vulnerabilities
    in Docker. By applying a PodSecurityPolicy, you can prevent your users from accidentally
    deploying unsecured containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have seen how they can be useful, let''s consider a sample PodSecurityPolicy
    and examine it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s examine a few noteworthy fields here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`metadata.namespace`: This is going to create the PodSecurityPolicy in the
    `default` namespace and will apply to Pods in the same namespace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`privileged`: This controls whether containers are allowed to run in a privileged
    execution context on the node, which effectively grants the container root-level
    access to the host. You can find more information about privileged containers
    here: [https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities](https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`seLinux`: This defines any SELinux settings. Some Kubernetes clusters run
    in SELinux environments, which implement something called "mandatory access control"
    outside of the cluster. This allows those controls to be projected into the cluster.
    By stating `RunAsAny`, we are allowing any SELinux user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`supplementalGroups`: This is a mandatory field of the policy. It essentially
    tells us that we are allowing any Linux user group ID (GID). In this sample spec,
    we are saying that users from any Linux user group with IDs 1 to 2500 are allowed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`runAsUser`: This allows us to specify specific Linux users who are permitted
    to run any process in the Pod. By stating `MustRunAsNonRoot`, we are saying that
    any process in the Pod must not run with root privileges.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fsGroup`: This is the Linux group ID the container process must be running
    as to interact with certain volumes on the cluster. Thus, even if a volume exists
    on a Pod, we can restrict certain processes in that Pod from accessing it. In
    this sample spec, we are saying that only Linux users in the `devops` group with
    a GID of 655 can access the volume. This is applied regardless of the location
    of the Pod in the cluster or where the volume is.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`volumes`: This allows us to permit the different types of volume that can
    be mounted to that Pod, such as a `configmap` or a `persistentVolumeClaim`. In
    this sample spec, we have specified `*` (an asterisk), which implies that all
    kinds of volumes are allowed to be used by the processes in this Pod.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have understood what the different fields in the spec mean, we'll
    create a PodSecurityPolicy in the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.03: Creating and Testing a PodSecurityPolicy'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''re going to be creating a PodSecurityPolicy and applying
    it to our cluster to demonstrate the types of functionalities Pods must now comply
    with in our cluster after we apply it. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `pod_security_policy_example.yaml` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To apply this to the cluster, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: To check that our policy is enforced, let's try to create a Pod that doesn't
    comply with this policy. Now we have a policy called `MustRunAsNonRoot`, so we
    should try to run a container as root and see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a Docker container that would violate this PodSecurityPolicy, first,
    create a file named `Dockerfile` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The second line of this `Dockerfile` switches to the root user (indicated by
    the UID of `0`), and then the `echo` command should tell us what user is running
    in this container when it starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build the Docker image by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.12: Building our Docker image'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_13_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.12: Building our Docker image'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run our Docker container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, this container is going to run as root.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to create a Pod from this container. Create a file named `pod.yaml`
    with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You can push your own image to your Docker Hub repository and replace this link,
    or you can use the container that we have already provided for convenience. As
    a general rule of thumb, you should always be careful when downloading something
    that is supposed to run with root access.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, a PodSecurityPolicy does nothing until the `use` permission is
    installed on a user, group, or ServiceAccount that will be creating the Pod. To
    mimic this, we will quickly create a ServiceAccount:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a Role that will be subject to this PodSecurityPolicy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this is another quick way to create a Role. Here, `psp:unprivileged`
    corresponds to the name of the role, while the flags correspond to the fields
    that we studied earlier. We are using the `--resource-name` flag to apply the
    Role to our specific PodSecurityPolicy. You should get the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s bind this role to our ServiceAccount using a RoleBinding:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are using a command similar to the one we used in the previous step.
    You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s masquerade as this user and try to create this Pod:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.13: Trying to create a Pod while assuming the fake-user ServiceAccount'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_13_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.13: Trying to create a Pod while assuming the fake-user ServiceAccount'
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of this chapter, we explored the 4Cs of cluster security, and
    then throughout this chapter, we have seen different ways in which Kubernetes
    allows us to harden our cluster against various areas of attack. We learned that
    RBAC policies allow us to control access to our API and objects, NetworkPolicy
    allows us to harden the networking topology, and PodSecurityPolicy helps us protect
    against compromised runtimes.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's bring these concepts together in the following activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 13.01: Securing Our App'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As it stands, our application from the previous chapter is already quite secure
    for the use case. What we need to do, though, is prevent users from deploying
    Pods that are privileged (so that they can''t escalate their permissions) and
    make sure that our app can communicate with both the outside world and its datastore.
    A correct solution to this application would be to have the following functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: The application should work seamlessly, as we demonstrated in the previous chapter,
    but now, it should prevent any unnecessary network traffic. Unnecessary here refers
    to the fact that the only Pod communicating with the Redis server should be the
    app, and that the app should only be communicating with other IP ranges.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In *Exercise 13.02*, *Creating a NetworkPolicy*, we saw that our application
    did not work due to the highly restrictive NetworkPolicy. However, in this case,
    you should see the application running with an output similar to the following:![Figure
    13.14: Expected output for Activity 13.01'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '](image/B14870_13_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.14: Expected output for Activity 13.01'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some steps that can help you complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that you have a cluster infrastructure and all the objects from *Exercise
    13.01, Creating a Kubernetes RBAC ClusterRole*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a file named `pod_security_policy.yaml` ( and then apply it). Keep in
    mind the functionality as described in the first bullet point above when creating
    this file. You might want to re-visit the section *PodSecurityPolicy* where we
    describe each of the fields used in such a file in detail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a file named `network_policy.yaml`. Keep in mind the requirement as listed
    in the second bullet point above when creating this file. You might want to re-visit
    the section *NetworkPolicies* where we describe each of the fields used in such
    a file in detail. Make sure to apply this policy once you have created it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you have the application from *Exercise 14.02, Creating a NetworkPolicy*
    still deployed in your cluster, you can move on to the next step. Otherwise, rerun
    *steps 5* and *6* from that exercise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, test the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at the following address: [https://packt.live/304PEoD](https://packt.live/304PEoD).'
  prefs: []
  type: TYPE_NORMAL
- en: Also, consider deleting the NetworkPolicy and PodSecurityPolicy after you are
    done with this chapter to avoid any interference with later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our journey of building a production-ready Kubernetes environment, security
    is a critical aspect. With that in mind, in this chapter, we examined how threat
    modeling allows us to think in an adversarial way about our application infrastructure
    and how it informs us of how we can defend it from attack. Then, we looked at
    the 4Cs of Cloud Native Security to understand where our attack surfaces are,
    followed by how Kubernetes can help us run workloads securely in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kubernetes has several security features that we can leverage to secure our
    cluster. We learned about three security measures that are important to leverage:
    RBAC, NetworkPolicies, and PodSecurityPolicies. We also learned about their various
    applications when it comes to securing access to your cluster, securing your container
    network, and securing your container runtimes.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to examine how to manage storage objects in
    Kubernetes and deal with apps that are stateful.
  prefs: []
  type: TYPE_NORMAL
