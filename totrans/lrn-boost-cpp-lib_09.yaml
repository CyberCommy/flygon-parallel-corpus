- en: Chapter 9. Files, Directories, and IOStreams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programming for real-world systems requires interacting with various subsystems
    of the operating system to utilize their services. Starting with this chapter,
    we look at the various Boost libraries that provide programmatic access to OS
    subsystems.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we look at the Boost libraries for performing input and output,
    and interacting with filesystems. We cover these libraries in the following sections
    of the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing files and directories with Boost Filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extensible I/O with Boost IOStreams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the libraries and techniques covered in this chapter, you will be able
    to write portable C++ programs that interact with filesystems and perform all
    kinds of I/O using a standard interface. We do not cover network I/O in this chapter,
    but devote [Chapter 10](ch10.html "Chapter 10. Concurrency with Boost"), *Concurrency
    with Boost*, to this topic.
  prefs: []
  type: TYPE_NORMAL
- en: Managing files and directories with Boost Filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software written using the Boost libraries runs on multiple operating systems,
    including Linux, Microsoft Windows, Mac OS, and various other BSD variants. How
    these operating systems access paths to files and directories may differ in several
    ways; for example, MS Windows uses backward slashes as the directory separator
    while all Unix variants, including Linux, BSD, and Mac, use forward slashes. Non-English
    operating systems may use other characters as directory separators, and sometimes,
    multiple directory separators may be supported. The Boost Filesystem library hides
    these platform-specific peculiarities and lets you write code that is much more
    portable. Using the functions and types in the Boost Filesystem library, you can
    write OS-agnostic code to perform common operations on the filesystem that an
    application needs to run, like copying, renaming, and deleting files, traversing
    directories, creating directories and links, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating paths
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Filesystem paths are represented using objects of type `boost::filesystem::path`.
    Given an object of type `boost::filesystem::path`, we can glean useful information
    from it and derive other `path` objects from it. A `path` object allows us to
    model a real filesystem path and derive information from it, but it need not represent
    a path that really exists in the system.
  prefs: []
  type: TYPE_NORMAL
- en: Printing paths
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us look at our first example of using Boost Filesystem to print the current
    working directory of a process:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 9.1: The first example of using Boost Filesystem**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the program determines its current working directory by calling
    the `current_path` (line 8), which is a namespace level function in the `boost::filesystem`
    namespace. It returns an object of type `boost::filesystem::path` representing
    the path to the current working directory. Most functions in `boost::filesystem`
    work on `boost::filesystem::path` objects rather than strings.
  prefs: []
  type: TYPE_NORMAL
- en: We print the path by calling the `generic_string` member function of `path`
    (line 11), by calling the `string` member function (line 12), and also by streaming
    `cwd`, the path object, to the output stream (line 13). The `generic_string` member
    returns the path in a **generic format** supported by Boost Filesytem with forward
    slashes as separators. The `string` member function returns the path in the **native
    format**, which is an implementation-defined format dependent on the operating
    system. On Windows, the native format uses backslashes as path separator, while
    on UNIX there is no difference between the generic and native formats. Boost Filesystem
    recognizes both forward and backward slashes as path separators on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Streaming the `path` object too writes the path in the native format but additionally
    puts double quotes around the path. Putting double quotes around paths with embedded
    spaces makes it easy to use the result as arguments to commands. If there be embedded
    double quote characters (`"`) in the path, those are escaped with an ampersand
    (`&`).
  prefs: []
  type: TYPE_NORMAL
- en: On Windows, the full paths are stored as wide character (`wchar_t`) strings,
    so `generic_string` or `string` return the path as a `std::string` *after* performing
    conversion. Depending on the specific Unicode characters in the path, there may
    not be a meaningful conversion of the path to a single-byte character string.
    On such systems, it is only safe to call the `generic_wstring` or `wstring` member
    functions, which return the path as a `std::wstring` in generic or native formats.
  prefs: []
  type: TYPE_NORMAL
- en: 'We print each directory component in the path, iterating through them using
    a range-based for-loop in C++11 (line 15). If range-based for-loop is not available,
    we should use the `begin` and `end` member functions in `path` to iterate through
    path elements. On my Windows box, this program prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'On my Ubuntu box, this is the output I get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The program prints its current working directory in the generic and native formats.
    You can see that there is no difference between the two on Ubuntu (and generally
    on any Unix).
  prefs: []
  type: TYPE_NORMAL
- en: On Windows, the first component of the path is the drive letter, generally referred
    to as the **root name**. This is followed by / (the root folder) and each subdirectory
    in the path. On Unix, there is no root name (as is usually the case), so the listing
    starts with / (the root directory) followed by each subdirectory in the path.
  prefs: []
  type: TYPE_NORMAL
- en: The `cwd` object of type `path` is streamable (line 19) and printing it to standard
    output prints it in the native format, enclosed in quotes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Compiling and linking examples with Boost Filesystem**'
  prefs: []
  type: TYPE_NORMAL
- en: Boost Filesystem is not a header-only library. The Boost Filesystem shared libraries
    are installed as part of the Boost operating system packages, or built from source
    as described in [Chapter 1](ch01.html "Chapter 1. Introducing Boost"), *Introducing
    Boost*.
  prefs: []
  type: TYPE_NORMAL
- en: '**On Linux**'
  prefs: []
  type: TYPE_NORMAL
- en: If you installed Boost libraries using your native package manager, then you
    can use the following commands to build your programs. Note that the library names
    are in system layout.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you built Boost from source as shown in [Chapter 1](ch01.html "Chapter 1. Introducing
    Boost"), *Introducing Boost*, and installed it under `/opt/boost`, you can use
    the following commands to compile and link your sources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Since we built the libraries with names in tagged layout, we link against appropriately
    named versions of Boost Filesystem and Boost System. The `-Wl,-rpath,/opt/boost/lib`
    part embeds the path to the Boost shared libraries in the generated executable
    so that the runtime linker knows from where to pick the shared libraries for the
    executable to run.
  prefs: []
  type: TYPE_NORMAL
- en: '**On Windows**'
  prefs: []
  type: TYPE_NORMAL
- en: 'On Windows, under Visual Studio 2012 or later, you can enable auto-linking
    and need not explicitly specify the libraries to link. For this, you need to edit
    the **Configuration Properties** settings in the **Project Properties** dialog
    box (brought up using *Alt* + *F7* in the IDE):'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Under **VC++ Directories**, append `<boost-install-path>\include` to the
    **Include Directories** property.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Under **VC++ Directories**, append `<boost-install-path>\lib` to the **Library
    Directories** property.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Under **Debugging**, set the **Environment** property to `PATH=%PATH%;<boost-install-path>\lib`.
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Under **C/C++ > Preprocessor**, define the following preprocessor symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BOOST_ALL_DYN_LINK`'
  prefs: []
  type: TYPE_NORMAL
- en: '`BOOST_AUTO_LINK_TAGGED` (only if you built using tagged layout)'
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Build by hitting *F7* from the Visual Studio IDE and run your program by
    hitting *Ctrl* + *F5* from the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing paths
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can construct instances of `boost::filesystem::path` using one of the `path`
    constructors or by combining existing paths in some way. Strings and string literals
    are implicitly convertible to `path` objects. You can construct relative as well
    as absolute paths, convert relative paths to absolute paths, append or strip elements
    from the path and "normalize" paths, as shown in listing 9.2:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 9.2a: Constructing empty path objects**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: A default constructed path object represents an empty path, as illustrated by
    the preceding example. You can assign a path string to an empty `path` object
    (line 10) and it ceases to be empty (line 11). On calling the `clear` member function
    on the path (line 12), it once again turns empty (line 13). Over the years, some
    parts of the Boost Filesystem library have been deprecated and replaced by better
    alternatives. We define the macro `BOOST_FILESYSTEM_NO_DEPRECATED` (line 1) to
    ensure that such deprecated member functions and types are not accessible.
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 9.2b: Constructing relative paths**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We construct a relative path by using `..` (double dot), which is a common way
    to refer to the parent directory relative to any directory on most filesystems
    (line 16). We then use `operator/=` to append an additional `..` path element
    to the relative path (line 17). We then print the relative path in its native
    format (line 18) and create absolute paths using this relative path.
  prefs: []
  type: TYPE_NORMAL
- en: The `boost::filesystem::absolute` function constructs an absolute path given
    a relative path. You may pass it an absolute path to which the relative path must
    be appended to construct a new absolute path (line 21). Note that we pass a Windows
    absolute path and make sure to escape the backslashes. If you omit the second
    parameter to `absolute`, it constructs the absolute path from the relative path
    by using the current working directory of the process as the base path (line 23).
  prefs: []
  type: TYPE_NORMAL
- en: 'A file path such as `/opt/boost/lib/../include` can be *normalized* to the
    equivalent form, `/opt/boost/include`. The function `boost::filesystem::canonical`
    generates a **normalized absolute path** from a given path (line 25), but requires
    that the path exist. Otherwise, it throws an exception that needs to be handled.
    It also reads and follows any symbolic links in the path. The preceding code prints
    the following output on my Windows box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that the output for the canonical path has the double dots collapsed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 9.2c: Handling errors**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This example illustrates how `canonical` errors out when it is passed a path
    that does not exist. We create a path object, `p3`, for the absolute path `E:\DATA`
    on Windows (line 29). We then create a second path object `p4` by appending successive
    path elements (`boost` and `boost_1_56`) to `p3` using the overloaded `operator/`
    for `path` objects (line 30). This constructs a path that is equivalent of `E:\DATA\boost\boost_1_56`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we append the relative path `../boost_1_100` to `p4` (line 35), which
    constructs a path that is equivalent of `E:\DATA\boost\boost_1_56\..\boost_1_100`.
    This path does not exist on my system so when I call `canonical` on this path,
    it errors out. Notice that we passed an object of type `boost::system::error_code`
    as a second argument to `canonical`, to capture any error. We check for a non-zero
    error code returned using the `value` member function of `error_code` (line 38).
    In case an error occurred, we can also retrieve a system-defined descriptive error
    message using the message `member` function (line 43). Alternatively, we can invoke
    another overload of `canonical`, which does not take an `error_code` reference
    as argument and instead throws an exception if the path passed does not exist.
    A throwing and a non-throwing overload is a common pattern seen in functions in
    the Filesystem library and other system programming libraries from Boost.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking paths into components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, we saw how we can get the parent directory of a path
    by calling the `parent_path` member function. In fact, there is a whole slew of
    member functions in `boost::filesystem::path` to extract the components in a path.
    Let us first take a look at a path and its components.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first understand the Boost Filesystem terminology for path components
    using the following path from a UNIX system:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/opt/boost/include/boost/filesystem/path.hpp`'
  prefs: []
  type: TYPE_NORMAL
- en: The leading `/` is called the **root directory**. The last component, `path.hpp`,
    is called the **filename**, even when the path represents a directory rather than
    a regular file. The path stripped of the filename (`/opt/boost/include/boost/filesystem`)
    is called the **parent path**. The part following the leading slash (`opt/boost/include/boost/filesystem/path.hpp`)
    is called the **relative path**.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, `.hpp` is the **extension** (including the period
    or dot) and `path` is the **stem** of the filename. In case of a filename with
    multiple embedded dots (for example, `libboost_filesystem-mt.so.1.56.0`), the
    extension is considered to start from the last (right-most) dot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider the following Windows path:'
  prefs: []
  type: TYPE_NORMAL
- en: '`E:\DATA\boost\include\boost\filesystem\path.hpp`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The component `E:` is called the **root name**. The leading backslash following
    `E:` is called the **root directory**. The concatenation of the root name with
    the root directory (`E:\`) is called the **root path**. The following is a short
    function that prints these different components of a path using member functions
    of `boost::filesystem::path`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 9.3: Splitting a path into components**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the function `printPathParts`(line 6) prints as many
    components of a path as are available. To access a path component, it uses a corresponding
    member function of `path`. To check whether a component is available, it uses
    one of the `has_` member functions of `path`. It also checks whether a path is
    a relative path or an absolute path using the `is_relative` and `is_absolute`
    member functions of `path` (lines 10, 13).
  prefs: []
  type: TYPE_NORMAL
- en: We call `printPathParts` with different relative and absolute paths. The results
    may vary across operating systems. For example, on Windows, a call to `has_root_name`
    (line 17) returns `false` for all the paths except the Windows path `E:\DATA\books.txt`
    (line 54), which is considered an absolute path. Calling `root_name` on this path
    returns `E:`. On UNIX however, the backslashes are not recognized as separators
    and considered part of the path components, so `E:\DATA\books.txt` will be interpreted
    as a relative path with the filename `E:\DATA\books.txt`, the stem `E:\DATA\books`,
    and the extension `.txt`. This, coupled with the fact that forward slashes are
    recognized on Windows as path separators, is a good reason to never use backslashes
    in path literals like we have done here.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For maximum portability, always use forward slashes in path literals or generate
    paths using the overloaded `operator/` and `operator/=`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also compare two paths to see whether they are **equal** and **equivalent**.
    Two paths can be compared for equality using the overloaded `operator==`, which
    returns `true` only if the two paths are decomposable to the same components.
    Note that this means the paths `/opt` and `/opt/` are not equal; in the former,
    the filename component is `opt`, while in the latter, it is `.` (dot). Two paths
    that are not equal can still be equivalent if they represent the same underlying
    filesystem entry. For example, `/opt/boost` and `/opt/cmake/../boost/` are equivalent
    although they are not equal paths. To compute equivalence, we can use the `boost::filesystem::equivalent`
    function, which returns `true` if the two paths refer to the same entry in the
    filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As with `boost::filesystem::canonical`, the `equivalent` function also actually
    checks for the existence of the paths and throws an exception if either path does
    not exist. There is also an overload that does not throw but sets a `boost::system::error_code`
    out-parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `path` object can be looked upon as a sequence container of path elements
    and these elements can be iterated through using an iterator interface exposed
    by `path`. This allows easy application of several standard algorithms to `path`
    objects. To iterate through each path element, we can use the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print the components separated by a pair of spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/ optboost include boost thread.hpp`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `begin` and `end` member functions of `boost::filesystem::path` return
    a random-access iterator of type `boost::filesystem::path::iterator`, which you
    can use with Standard Library algorithms in interesting ways. For example, to
    find the number of components in a path, you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, consider two paths: `/opt/boost/include/boost/filesystem/path.hpp` and
    `/opt/boost/include/boost/thread/detail/thread.hpp`. We will now write a function
    that computes the common subdirectory under which both paths are located:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 9.4: Finding the common prefix path**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Calling the `commonPrefix` function on the two paths correctly returns `/opt/boost/include/boost`.
    For this function to work correctly, we should pass paths that do not have `.`
    or `..` components, something that a more complete implementation can take care
    of. To compute the prefix, we first define a nested function called `prefix` using
    a lambda expression (lines 7-17), which performs the actual computation. We compute
    the element count of the two paths (lines 19, 20) and pass the shorter path as
    the first argument and the longer one as the second argument to the `prefix` function
    (lines 22-23). In the `prefix` function, we use the `std::mismatch` algorithm
    on the two paths to compute the first component where they do not match (line
    10). We then construct the common prefix as the path up to this first mismatch
    and return it (lines 12-15).
  prefs: []
  type: TYPE_NORMAL
- en: Traversing directories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Boost Filesystem provides two iterator classes, `directory_iterator` and `recursive_directory_iterator`,
    that make iterating through directories fairly simple. Both conform to the **input
    iterator** concept and provide an `operator++` for forward traversal. In the first
    example here, we see `directory_iterator` in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 9.5: Iterating directories**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `traverse` function takes a parameter `dirpath` of type `boost::filesystem::path`
    representing the directory to traverse. Using the namespace level functions, `exists`
    and `is_directory` (line 7), the function checks to see that `dirpath` actually
    exists and is a directory before proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: To perform the iteration, we create an instance `dirit` of `boost::filesystem::directory_iterator`
    for the path and a second default-constructed `directory_iterator` instance called
    `end` (line 11). The default-constructed `directory_iterator` acts as the end-of-sequence
    marker. Dereferencing a valid iterator of type `directory_iterator` returns an
    object of type `boost::filesystem::directory_entry`. The sequence represented
    by the iterator range [`dirit`, `end`) is the list of entries in the directory.
    To iterate through them, we use the familiar `std::for_each` standard algorithm.
    We use a lambda to define the action to perform on each entry, which is to simply
    print it to the standard output (lines 13-14).
  prefs: []
  type: TYPE_NORMAL
- en: 'While we can write recursive logic around `boost::directory_iterator` to iterate
    through a directory tree recursively, `boost::recursive_directory_iterator` provides
    an easier alternative. We can replace `boost::directory_iterator` with `boost::recursive_directory_iterator`
    in listing 9.5 and it will still work, performing a depth-first traversal of the
    directory tree. But the `recursive_directory_iterator` interface provides additional
    capabilities like skipping descent into specific directories and keeping track
    of the depth of descent. A hand-written loop serves better to fully leverage these
    capabilities, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 9.6: Recursively iterating directories**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We create a `recursive_directory_iterator` and initialize it with a path (line
    8) just as we did for a `directory_iterator` in listing 9.5\. The `recursive_directory_iterator`
    constructor may throw an exception if the path does not exist or cannot be read
    by the program. To catch such exceptions, we put the code in the `try-catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: We use a while-loop to iterate through entries (line 10) and advance the iterator
    by calling the `increment` member function (line 19). When the `increment` member
    function encounters a directory, it tries to descend into it in depth-first order.
    This can sometimes fail due to system issues, like when the program does not have
    sufficient permissions to look into the directory. In such cases, we want to continue
    on to the next available entry rather than abort the iteration. For this reason,
    we do not use `operator++` on the iterator because it throws an exception when
    it encounters an error and handling this makes the code more convoluted. The `increment`
    function takes a `boost::system::error_code` argument, and in case of an error,
    it sets the `error_code` *and* advances the iterator to the next entry. In such
    a case, we can get the system-defined error message associated with the error
    using the `message` member function of `error_code`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Behavior of boost::filesystem::recursive_directory_iterator**'
  prefs: []
  type: TYPE_NORMAL
- en: Prior to Boost version 1.56, when the `operator++` and `increment` member functions
    encountered an error, they would only throw an exception or set an `error_code`,
    without advancing the iterator. This made writing a correct loop that skips on
    errors more complex. As of Boost 1.56, these functions also advance the iterator
    to the next entry making the loop code a lot simpler.
  prefs: []
  type: TYPE_NORMAL
- en: We process each entry by a call to a fictitious function `printFileProperties`
    (line 11), which takes two arguments—the result of dereferencing the `recursive_directory_iterator`
    instance, and the depth of traversal obtained by a call to the `level` member
    function of the iterator. The `level` function returns zero for first-level directories
    and its return value is incremented by 1 for each additional level of descent.
    The `printFileProperties` function can use this to indent entries in subdirectories,
    for example. We will implement the `printFileProperties` function in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: To add dimension to the example, we decide not to descend into directories named
    `foo`. For this, we check for directories named `foo` (lines 13-15) and call the
    `no_push` member function on the `recursive_directory_iterator` to prevent descending
    into the directory (line 16). Likewise, we can call the `pop` member function
    on the iterator at any time to go up a level in the directory tree without necessarily
    completing iteration at the current level.
  prefs: []
  type: TYPE_NORMAL
- en: On systems that support symbolic links, if the `recursive_directory_iterator`
    encounters a symbolic link pointing to a directory, it does not follow the link
    to descend into the directory. If we want to override this behavior, we should
    pass a second argument of the enum type `boost::filesystem::symlink_option` to
    the `recursive_directory_iterator` constructor. The `symlink_option` enum provides
    the values `none` (or `no_recurse`), which is the default, and `recurse`, which
    indicates that symbolic links should be followed to descend into directories.
  prefs: []
  type: TYPE_NORMAL
- en: Querying filesystem entries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Boost Filesystem provides a set of functions to perform useful operations on
    files and directories. Most of these are functions in the `boost::filesystem`
    namespace. Using these functions, we can check whether a file exists, its size
    in bytes, its last modification time, the file type, whether it is empty, and
    so on. We use this slew of functions to write the `printFileProperties` function
    we used in the preceding section:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 9.7: Querying file system entries**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `printFileProperties` is used to print a short summary for a given file,
    including attributes like type, size, last modification time, name, and for symbolic
    links, the target file. The first argument to this function is of type `directory_entry`,
    the result of dereferencing a `directory_iterator` or `recursive_directory_iterator`.
    The second argument is the depth of traversal. We obtain the path to the file
    referenced by the `directory_entry` object by calling the `path` member function
    of `directory_entry` (line 9). We obtain a reference to a `file_status` object
    by calling the `symlink_status` member function of `directory_entry` (line 10).
    The `file_status` object contains additional details about a filesystem entry,
    which we use in our example to print the status of special files. The `symlink_status`
    function acts on all kinds of files not just symbolic links, but it returns the
    status of the symbolic link itself without following it to the target. If you
    need the status of the target each time you query the symbolic link, use the `status`
    member function instead of `symlink_status`. The `status` and `symlink_status`
    member functions are faster than the global functions of the same name because
    they keep the file stats cached instead of querying the filesystem on every call.
  prefs: []
  type: TYPE_NORMAL
- en: We determine the type of each entry before printing information appropriate
    for the type. To do this, we use the convenience functions `is_symlink`, `is_regular_file`
    and `is_directory` (lines 14, 19, 24). On POSIX systems like Linux, there are
    other kinds of files like block and character devices, fifos, and Unix domain
    sockets. To identify such files, we use the `file_status` object we obtained earlier
    (line 10). We call the `type` member function on the `file_status` object to determine
    the exact type of special file (line 29). Note that we first check if the file
    is a symbolic link and then perform other tests. That is because `is_regular_file`
    or `is_directory` may also return true for a symbolic link, based on the type
    of the target file.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function prints each entry in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The file type is indicated by a single letter (`D`: directory, `F`: regular
    file, `L`: symbolic link, `C`: character device, `B`: block device, `P`: fifo,
    `S`: Unix domain socket). The size is printed in bytes, the last modification
    time is printed as a long integer, and the file name is printed without the full
    path. Only for symbolic links, a trailing arrow followed by the target path is
    appended after the name. Hyphens (`-`) appear for missing fields when file size
    or last write time are not available. For each level of descent, the entry is
    indented with an extra pair of spaces (line 11).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a sample output from running this function on my Linux system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Querying filesystem entries](img/1217OT_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can also run this on the `/dev` directory on Linux to look at how device
    files are listed.
  prefs: []
  type: TYPE_NORMAL
- en: To get the target file pointed to by a symbolic link, we call the `read_symlink`
    function (line 15). To get the size of a file in bytes, we call the `file_size`
    function (line 21), and to get the last modification time of a file, we call the
    `last_write_time` function (lines 22, 26, and 46). The `last_write_time` function
    returns the **Unix time** at which the file was last modified. We print a meaningful
    representation of this time stamp by calling the `boost::posix_time::from_time_t`
    function to convert this numeric timestamp into a printable date time string (see
    [Chapter 7](ch07.html "Chapter 7. Higher Order and Compile-time Programming"),
    *Higher Order and Compile-time Programming*).
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to build this program, you must additionally link against the Boost
    DateTime library, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: There are several such functions for querying objects in the filesystem for
    different kinds of information—for example, finding the number of hard links to
    a file. We can query the `file_status` object (line 10) for file permissions.
    Notice that we do not qualify these namespace level functions with the namespace;
    they are correctly resolved using Argument Dependent Lookup based on the type
    of their arguments (`boost::filesystem::path`).
  prefs: []
  type: TYPE_NORMAL
- en: Performing operations on files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to querying filesystem entries for information, we can also use
    the Boost Filesystem library to perform operations on files like creating directories
    and links, copying files and moving them, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Creating directories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is easy to create directories using the function `boost::filesystem::create_directory`.
    You pass it a path and it creates a directory at that path if one does not exist;
    it does nothing if the directory already exists. If the path exists but is not
    a directory, `create_directory` throws an exception. There is also a non-throwing
    version that takes a `boost::system::error_code` reference, which it sets on error.
    These functions returns `true` if they create the directory and `false` if they
    do not:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 9.8: Creating directories**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this example, calling `create_directory` on the path `notpresent/dirtest`
    relative to the current directory fails (line 10) either if there is no directory
    called `notpresent` already in your current directory, or if `notpresent/dirtest`
    exists. This is because `create_directory` expects the parent directory of the
    path passed to exist, and it does not create a path that already exists. If we
    did not pass the error code parameter, this call to `create_directory` would have
    thrown an exception that would need to be handled. If `notpresent/dirtest` already
    exists and is a directory, then `create_directory` fails, but does not set the
    error code (line 12).
  prefs: []
  type: TYPE_NORMAL
- en: The function `boost::filesystem::create_directories` creates all path components
    needed, akin to `mkdir –p` on Unix systems. The call to it (line 17) succeeds
    unless there are permission issues or the path already exists. It creates the
    directory, including any missing directories along the path. Calls to `create_directory`
    and `create_directories` are idempotent; if the target directory exists, no error
    is returned or exception thrown, but the functions return `false` because no new
    directory was created.
  prefs: []
  type: TYPE_NORMAL
- en: Creating symbolic links
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Symbolic links, sometimes called soft links, are entries in the filesystem that
    act like aliases to other files. They can refer to files as well as directories
    and are often used to provide alternate, simplified names and paths for files
    and directories. Symbolic links have been around on UNIX systems for quite a while
    now and have been available in some form on Windows since Windows 2000\. We can
    use the function `boost::filesystem::create_symlink` to create symbolic links.
    For creating symbolic links to directories, the function `boost::filesystem::create_directory_symlink`
    is recommended for better portability.
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 9.9: Creating symbolic links**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This shows a function `makeSymLink` that creates a symbolic link to a given
    path. The first parameter to the function is the target path that the link must
    alias, and the second parameter is the path to the link itself. This order of
    arguments is reminiscent of the UNIX `ln` command. If the target is a directory,
    this function calls `create_directory_symlink` (line 8), while for all other cases
    it calls `create_symlink` (line 10). Note that the target path need not exist
    at the time of creation of the symbolic link and a dangling symbolic link will
    be created in such a case. Calling these functions has the same effect as the
    command `ln –s target link` on POSIX systems. On Windows, you get the same effect
    by running the command `mklink /D link target` when `target` is a directory, or
    by running the command `mklink link target` when `target` is not a directory.
    The function `makeSymLink` will throw if `create_directory_symlink` or `create_symlink`
    threw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Copying files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Copying files is another common chore that Boost Filesystem helps in. The `boost::filesystem::copy_file`
    function copies regular files from source to destination and fails if the file
    already exists at the destination. Using an appropriate override, it can be made
    to overwrite the file at the destination instead. The `boost::filesystem::copy_symlink`
    takes a source symbolic link and creates a second symbolic link at the destination
    that aliases the same file as the source. You cannot pass a directory as the destination
    to either function. There is also a `boost::copy_directory` function, which does
    not seem to do what its name suggests. It creates directories and copies attributes
    of the source directory to the target directory. So, we will roll out our own
    recursive directory-copying utility function instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 9.10: Recursively copying directories**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9.10 defines the `copyDirectory` function, which recursively copies
    a source directory to a target directory. It performs basic validations and throws
    an exception if the requisite initial conditions are not met (line 6). If any
    of the following conditions hold true, then a necessary precondition is violated:'
  prefs: []
  type: TYPE_NORMAL
- en: The source path is not a directory (line 2)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The target path exists, but is not a directory (line 3)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The parent of the target path is not a directory (line 4)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The target path is a subdirectory of the source path (line 5)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To detect violation 4, we reuse the `commonPrefix` function we defined in listing
    9.4\. If the target path already exists, a subdirectory with the same name as
    the source directory is created under it to hold the copied contents (lines 11-12,
    14). Otherwise, the target directory is created and the content is copied into
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond this, we iterate recursively through the source directory using `directory_iterator`
    instead of `recursive_directory_iterator` (line 17). We use `copy_file` to copy
    regular files, passing the `copy_option::overwrite_if_exists` option to make sure
    a destination file that already exists is overwritten (lines 23-24). We use `copy_symlink`
    to copy a symbolic link (line 26). Each time we encounter a subdirectory, we recursively
    call `copyDirectory` (line 28). If an exception is thrown from the Boost Filesystem
    functions called by `copyDirectory`, it terminates the copy.
  prefs: []
  type: TYPE_NORMAL
- en: Moving and deleting files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can move or rename files and directories using the `boost::filesystem::rename`
    function, which takes the old and new paths as arguments. The two-argument overload
    throws an exception if it fails, while the three-argument overload sets an error
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If `new_path` does not exist, it is created provided its parent directory exists;
    otherwise, the call to rename fails. If `old_path` is not a directory, then `new_path`,
    if it exists, cannot be a directory either. If `old_path` is a directory, then
    `new_path`, if it exists, must be an empty directory or the function fails. When
    a directory is moved to another empty directory, the contents of the source directory
    are copied inside the target empty directory, and then the source directory is
    removed. Renaming symbolic links acts on the links, not on the files they refer
    to.
  prefs: []
  type: TYPE_NORMAL
- en: You can delete files and empty directories by calling `boost::filesystem::remove`
    passing it the path to the filesystem entry. To recursively remove a directory
    that is not empty, you must call `boost::filesystem::remove_all`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `remove` function returns false if the file named by the path does not exist.
    This removes symbolic links without impacting the files they alias. The `remove_all`
    function returns the total number of entries it removes. On error, the single-argument
    overloads of `remove` and `remove_all` throw an exception, while the two-argument
    overloads set the error code reference passed to it without throwing an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Path-aware fstreams
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition, the header file `boost/filesystem/fstream.hpp` provides versions
    of Standard file stream classes that work with `boost::filesystem::path` objects.
    These are very handy when you are writing code that uses `boost::filesystem` and
    also needs to read and write files.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A C++ Technical Specification based on the Boost Filesystem library has been
    recently approved by ISO. This makes way for its inclusion in a future revision
    of the C++ Standard Library.
  prefs: []
  type: TYPE_NORMAL
- en: Extensible I/O with Boost IOStreams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Standard Library IOStreams facility is meant to provide a framework for
    operations of all kinds on all manner of devices, but it has not proven to be
    the easiest of frameworks to extend. The Boost IOStreams library supplements this
    framework with a simpler interface for extending I/O facilities to newer devices,
    and provides some pretty useful classes that address common needs while reading
    and writing data.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture of Boost IOStreams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Standard Library IOStreams framework provides two basic abstractions, **streams**
    and **stream buffers**. Streams provide a uniform interface to the application
    for reading or writing a sequence of characters on an underlying device. Stream
    buffers provide a lower-level abstraction for the actual device, which is leveraged
    and further abstracted by streams.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Boost IOStreams framework provides the `boost::iostreams::stream` and `boost::iostreams::stream_buffer`
    templates, which are generic implementations of the stream and stream buffer abstractions.
    These two templates implement their functionality in terms of a further set of
    concepts, which are described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A **source** is an abstraction for an object from which a sequence of characters
    can be read.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **sink** is an abstraction for an object to which a sequence of characters
    can be written.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **device** is a source, a sink, or both.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **input filter** modifies a sequence of characters read from a source, while
    an **output filter** modifies a sequence of characters before it is written to
    a sink.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **filter** is an input filter or an output filter. It is possible to write
    a filter that can be used either as an input filter or as an output filter; this
    is known as a **dual use filter**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To perform I/O on a device, we associate a sequence of zero or more filters
    plus the device with an instance of `boost::iostreams::stream` or an instance
    of `boost::iostreams::stream_buffer`. A sequence of filters is called a **chain**
    and a sequence of filters with a device at the end is said to be a **complete
    chain**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram is a unified view of input and output operation, illustrating
    the I/O path between a stream object and the underlying device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Architecture of Boost IOStreams](img/1217OT_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Boost IOStreams architecture
  prefs: []
  type: TYPE_NORMAL
- en: Input is read from the device and passed through an optional stack of filters
    to reach the stream buffer from where it is accessible via the stream. Output
    is written from the stream via the stream buffer and passed through a stack of
    filters before reaching the device. The filters, if any, act on the data read
    from the device to present a transformed sequence to the reader of the stream.
    They also act on the data to be written to the device and transform it before
    it is written. The preceding diagram is meant for visualizing these interactions
    but is slightly inaccurate; in code, a filter cannot act both as an input filter
    and an output filter at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: The Boost IOStreams library comes with several built-in device and filter classes,
    and it is easy to create our own too. In the following sections, we illustrate
    the use of different components of the Boost IOStreams library with code examples.
  prefs: []
  type: TYPE_NORMAL
- en: Using devices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A device provides an interface to read and write characters to an underlying
    medium. It abstracts a real medium like a disk, memory, or network connection.
    In this book, we will focus on using the number of readily available devices shipped
    as part of the Boost IOStreams library. Methods of writing our own device classes
    are beyond the scope of this book, but you should have little difficulty in picking
    them up from the online documentation once you are familiar with the content we
    cover in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Devices for file I/O
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Boost defines a number of devices for performing I/O on files and the one we
    look at first is a device that abstracts platform-specific file descriptors. Each
    platform uses some native handle for open files, different from how standard C++
    represents open files using `fstream`s. These could be integer file descriptors
    on POSIX systems and HANDLEs on Windows, for example. The Boost IOStreams library
    provides the `boost::iostreams::file_descriptor_source`, `boost::iostreams::file_descriptor_sink`,
    and `boost::iostreams::file_descriptor` devices that adapt POSIX file descriptors
    and Windows file handles into devices for input and output. In the following example,
    we use a `file_descriptor_source` object to read successive lines from a file
    on a POSIX system using the stream interface. This is useful if you want to use
    a stream interface for I/O on a file that is opened using system calls that deal
    in file descriptors.
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 9.11: Using the file_descriptor device**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Using this program, we open the first file named on the command line and read
    successive lines off it. We first open the file using the Unix system call, `open`
    (line 15), for which we include the Unix headers `sys/types.h` and `fcntl.h` (lines
    6-7). If the file is opened successfully (indicated by a positive value of the
    file descriptor returned by `open`), then we create an instance of `file_descriptor_source`
    passing it the open file descriptor and a flag `close_handle` to indicate that
    the descriptor should be appropriately closed when the device is destroyed (lines
    17-18).
  prefs: []
  type: TYPE_NORMAL
- en: If we did not want the device to manage the descriptor's lifetime, then we had
    to pass the flag `never_close_handle` instead. We then create an instance of `boost::iostreams::stream<file_descriptor_source>`
    (line 19) passing it the device object, and read successive lines from it using
    the `std::getline` function just as we would use any `std::istream` instance (line
    23). Note that we assert the device is open for reading using the `is_open` member
    function (line 19). This code is meant to compile on Unix and Unix-like systems.
    On Windows, the Visual Studio C Runtime library provides compatible interfaces
    so that you may be able to compile and run this on Windows as well by including
    one additional header file `io.h`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The types and functions in Boost IOStreams library are split into a set of fairly
    independent header files, and there is no single header file including which will
    give you all symbols. Device headers are available under `boost/iostreams/device`
    directory and filter headers are under `boost/iostreams/filter` directory. The
    rest of the interfaces are available under `boost/iostreams`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build this program, we must link it with the `libboost_iostreams` library.
    I use the following command line on my Ubuntu box to build the program using the
    Boost libraries installed under default paths via the native package manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We may also want to build our program to use the Boost libraries we built from
    source in [Chapter 1](ch01.html "Chapter 1. Introducing Boost"), *Introducing
    Boost*. For this, I use the following command line to build this program on my
    Ubuntu box, specifying the include path and the library path, as well as the `libboost_iostreams-mt`
    library to link against:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: To write to a file via a file descriptor, we need to use a `file_descriptor_sink`
    object. We can also use a `file_descriptor` object to both read and write to the
    same device. There are other devices that allow writing to files—the `file_source`,
    `file_sink`, and `file` devices allow you to read and write named files. The `mapped_file_source`,
    `mapped_file_sink`, and `mapped_file` devices allow you to read and write to files
    via memory mappings.
  prefs: []
  type: TYPE_NORMAL
- en: Devices for reading and writing to memory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Standard Library `std::stringstream` family of classes is commonly used
    for reading and writing formatted data to memory. If you want to read and write
    from any given contiguous memory area, like an array or byte buffer, the `array`
    family of devices (`array_source`, `array_sink`, and `array`) from Boost IOStreams
    library comes in handy:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 9.12: Using array devices**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This example follows the same pattern as Listing 9.11, but we use two devices,
    a sink and a source, instead of one. In each case, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We create an appropriately initialized device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We create a stream object and associate the device with it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We perform input or output on the stream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We first define an `array_sink` device, which is used to write to a contiguous
    region of memory. The region of memory is passed to the device constructor as
    a pair of pointers to the first element of an array of `char`s and the one past
    the last element (line 10). We associate this device with a stream object `out`
    (line 11) and then write some content to the stream using insertion operators
    (`<<`). Note that this content can be of any streamable type, not just textual.
    Using the manipulator `std::ends` (line 13), we make sure that the array has a
    terminating null character after the text. Using the `std::flush` manipulator,
    we make sure that this content is not held in the device buffer but finds its
    way to the backing array `out_array` of the sink device before we call `strlen`
    on `out_array` (line 16).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create a `vector` of `chars` called `vchars` initialized with the
    content of `out_array` (lines 15-16). We then define an `array_source` device
    backed by this `vector`, passing to the constructor an iterator to the first element
    of `vchars` and the number of characters in `vchars` (line 17). Finally, we construct
    an input stream associated with the device (line 18) and then use the `boost::iostreams::copy`
    function template to copy characters from the input stream to the standard output
    (line 20). Running the preceding code writes the following line to `out_array`
    through the `array_sink` device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: It then reads each word in this phrase and prints it to the standard output
    on a new line.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the `array` devices, the `back_insert_device` device can be
    used to adapt several standard containers as sinks. The difference between `back_insert_device`
    and `array_sink` is that `array_sink` requires a fixed memory buffer to operate
    on, whereas `back_insert_device` can use as its backing store any standard container
    with an `insert` member function. This allows the underlying memory area for a
    `back_insert_device` to grow as required by the size of input. We rewrite listing
    9.12 using a `back_insert_device` in place of the `array_sink`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 9.13: Using back_insert_device**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here, we write to `out_vec`, which is a `vector<char>` (line 11), and do so
    using the `back_insert_device` sink (line 12). We write the size of `out_vec`
    to the stream, but this may not print the total number of characters already written
    to the device at that point, because the device may buffer some of the output
    before flushing it to the vector. Since we intend to copy this data to another
    vector for reading (lines 16-17), we ensure that all the data is written to `out_vec`
    using the `std::flush` manipulator (line 14).
  prefs: []
  type: TYPE_NORMAL
- en: There are other interesting devices, like the `tee_device` adaptor that allows
    writing a character sequence to two different devices, reminiscent of the Unix
    `tee` command. We will now look at how you can write your own device.
  prefs: []
  type: TYPE_NORMAL
- en: Using filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Filters act on the character stream that is written to a sink or read from a
    source, either transforming it before it is written and read, or simply observing
    some properties of the stream. The transformation can do a variety of things,
    like tagging keywords, translating text, performing regular expression substitution,
    and performing compression or decompression. Observer filters can compute line
    and word counts or compute a message digest among other things.
  prefs: []
  type: TYPE_NORMAL
- en: Regular streams and stream buffers do not support filters and we need to use
    **filtering streams** and **filtering stream buffers** instead in order to use
    filters. Filtering streams and stream buffers maintain a stack of filters with
    the source or sink at the top and the outermost filter at the bottom in a data
    structure called a **chain**.
  prefs: []
  type: TYPE_NORMAL
- en: We will now look at several utility filters that are shipped as part of the
    Boost IOStreams library. Writing our own filters is outside the scope of this
    book, but the excellent online documentation covers this topic in adequate detail.
  prefs: []
  type: TYPE_NORMAL
- en: Basic filters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the first example of using filters, we use `boost::iostreams::counter` filter
    to keep a count of characters and lines in text read from a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 9.14: Using the counter filter**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We create a `boost::iostream::file_source` device for reading the contents of
    a file named on the command line (line 14). We create a `counter` filter for counting
    the number of lines and characters read (line 15). We create an object of `filtering_istream`
    (line 16) and push the filter (line 17) followed by the device (line 19). Till
    the device is pushed, we can assert that the filtering stream is incomplete (line
    18) and it is complete once the device is pushed (line 20). We copy the contents
    read from the filtering input stream to the standard output (line 22) and then
    access the character and line counts.
  prefs: []
  type: TYPE_NORMAL
- en: To access the counts, we need to refer to the `counter` filter object sitting
    in the chain inside the filtering stream. To get to this, we call the `component`
    member template function of `filtering_istream` passing in the index of the filter
    we want and the type of the filter. This returns a pointer to the `counter` filter
    object (line 24) and we retrieve the number of characters and lines read by calling
    the appropriate member functions (lines 25-26).
  prefs: []
  type: TYPE_NORMAL
- en: In the next example, we use `boost::iostreams::grep_filter` to filter out blank
    lines. Unlike the counter filter which did not modify the input stream, this transforms
    the output stream by removing blank lines.
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 9.15: Using the grep_filter**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This example is on the same lines as the listing 9.14 except that we use a different
    filter, `boost::iostreams::grep_filter`, to filter out blank lines. We create
    an instance of the `grep_filter` object, passing three arguments to its constructor.
    The first argument is the regular expression `^\s*$` that matches blank lines—lines
    that contain zero or more whitespace characters (line 16). Note that the backslash
    is escaped in code. The second argument is the constant `match_default` to indicate
    that we use Perl regular expression syntax (line 17). The third argument `boost::iostreams::grep::invert`
    tells the filter to let only those lines that match the regular expression to
    be filtered out (line 17). The default behavior is to filter out only those lines
    that do not match the regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build this program on Unix, you must additionally link against the Boost
    Regex library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'On a system without the Boost native packages and with Boost installed at a
    custom location, use the following more elaborate command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: On Windows, using Visual Studio and enabling auto linking against DLLs, you
    do not need to explicitly specify the Regex or IOStream DLLs.
  prefs: []
  type: TYPE_NORMAL
- en: Filters for compression and decompression
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Boost IOStreams library comes with three different filters for compressing and
    decompressing data, one each for gzip, zlib, and bzip2 formats. The gzip and zlib
    formats implement different variants of the **DEFLATE algorithm** for compression,
    while the bzip2 format uses the more space-efficient **Burrows-Wheeler algorithm**.
    Since these are external libraries, they must be built and linked to our executables
    if we use these compression formats. If you have followed the detailed steps outlined
    in [Chapter 1](ch01.html "Chapter 1. Introducing Boost"), *Introducing Boost*,
    to build Boost libraries with support for zlib and bzip2, then the zlib and bzip2
    shared libraries should have been built along with the Boost Iostreams shared
    library.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we compress a file named on the command line and write
    it to the disk. We then read it back, decompress it, and write it to the standard
    output.
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 9.16: Using gzip compressor and decompressor**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code first uses the `boost::iostreams::gzip_compressor` filter
    (line 16) to decompress the file as it is read (line 17). It then writes this
    content to a file with the `.gz` extension appended to the original file name
    using `boost::iostreams::copy` (lines 20-22). The call to `boost::iostreams::copy`
    also flushes and closes the output and input streams passed to it. Thus, it is
    safe to read back from the file immediately after the call to `copy` returns.
    To read this compressed file back, we use a `boost::iostreams::file_source` device
    with a `boost::iostreams::gzip_decompressor` in front (lines 27-28) and write
    the decompressed output to the standard output (line 30). We reuse the `filtering_istream`
    object for reading the original file and again for reading the compressed file.
    Calling the `reset` member function on the filtering stream closes and removes
    the filter chain and device associated with the stream (line 26), so we can associate
    a new filter chain and device (lines 27-28).
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to override several defaults by supplying additional arguments
    to the constructor of the compressor or decompressor filter, but the essential
    structure does not change. By changing the header from `gzip.hpp` to `bzip2.hpp`
    (line 4), and replacing the `gzip_compressor` and `gzip_decompressor` with `bzip2_compressor`
    and `bzip2_decompressor` in the preceding code, we can test the code for the bzip2
    format; likewise for the zlib format. Ideally, the extensions should be changed
    aptly (.bz2 for bzip2 and .zlib for zlib). On most Unix systems, it will be worthwhile
    to test the generated compressed files by uncompressing them independently using
    gzip and bzip2 tools. Command-line tools for zlib archives seem scanty and less
    standardized. On my Ubuntu system, the `qpdf` program comes with a raw zlib compression/decompression
    utility called `zlib-flate`, which can compress to and decompress from zlib format.
  prefs: []
  type: TYPE_NORMAL
- en: The steps to build this program are the same as the steps outlined to build
    listing 9.15\. Even if you use the `zlib_compressor` or `bzip2_compressor` filters
    instead, the necessary shared libraries will be automatically picked up by the
    linker (and later, the runtime linker during execution) as long as the option
    `-Wl,-rpath,/opt/boost/lib` is used during linking and the path `/opt/boost/lib`
    contains the shared libraries for zlib and bzip2.
  prefs: []
  type: TYPE_NORMAL
- en: Composing filters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Filtering streams can apply multiple filters to a character sequence in a pipeline.
    Using the `push` method on the filtering stream, we form the pipeline starting
    with the outermost filter, inserting the filters in the desired order, and ending
    with the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that for filtering an output stream, you first push the filter that
    gets applied first and work forward pushing each successive filter, followed at
    the end by the sink. For example, in order to filter out some lines and compress
    before writing to a sink, the sequence of pushes would be like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'For filtering input streams, you push the filters, starting with the filter
    that gets applied last and work backward pushing each preceding filter, followed
    at the end by the source. For example, in order to read a file, decompress it
    and then perform a line count, the sequence of pushes will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Pipelining
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It turns out that a little operator overloading can make this much more expressive.
    We can write the preceding chains using the pipe operator (`operator|`) in the
    following alternative notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding snippet is clearly more expressive with fewer lines of code.
    From left to right, the filters are strung together in the order you push them
    into the stream, with the device at the end. Not all filters can be combined in
    this way, but many readily available ones from the Boost IOStreams library can;
    more definitively, filters must conform to the **Pipable concept** to be combined
    this way. Here is a complete example of a program that reads the text in a file,
    removes blank lines, and then compresses it using bzip2:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 9.17: Piping filters**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example strings together a grep filter for filtering out blank
    lines (lines 16-18) and a bzip2 compressor (line 15) with a file source device
    using pipes (line 20). The rest of the code should be familiar from listings 9.15
    and 9.16.
  prefs: []
  type: TYPE_NORMAL
- en: Branching data streams with tee
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While using filter chains with multiple filters, it is sometimes useful, especially
    for debugging, to capture the data flowing between two filters. The `boost::iostreams::
    tee_filter` is an output filter akin to the Unix `tee` command that sits interposed
    between two filters and extracts a copy of the data stream flowing between the
    two filters. Essentially, when you want to capture data at different intermediate
    stages of processing, you can use a `tee_filter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Branching data streams with tee](img/1217OT_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also multiplex two sink devices to create a **tee device**, such that
    writing some content to the tee device writes it to both the underlying devices.
    The `boost::iostream::tee_device` class template combines two sinks to create
    such a tee device. By nesting tee devices or pipelining tee filters, we can generate
    several parallel streams that can be processed differently. The `boost::iostreams::tee`
    function template can generate tee filters and tee streams. It has two overloads—a
    single-argument overload that takes a sink and generates a `tee_filter`, and a
    two-argument overload that takes two sinks and returns a `tee_device`. The following
    example shows how to compress a file to three different compression formats (gzip,
    zlib, and bzip2) using very little code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 9.18: Branching output streams with tees**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We set up three compression filters for gzip, bzip2, and zlib (lines 17, 23,
    and 29). We need one `filtering_ostream` for each output file. We create the `gzout`
    stream for the gzip-compressed output (line 20) and the `bz2out` stream for the
    bzip2-compressed output (line 26). We create tee filters around these two streams
    (lines 21 and 27). Finally, we string together the filters gztee, bz2tee, and
    zlib in front of the zlibfile sink and push this chain into the zlibout `filtering_ostream`
    for the zlib file (line 33). Copying from the input stream `ins` into the output
    stream `zlibout` generates the three compressed output files in a pipeline, as
    shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Branching data streams with tee](img/1217OT_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the calls to tee are not namespace-qualified but get correctly resolved
    due to Argument Dependent Lookup (see [Chapter 2](ch02.html "Chapter 2. The First
    Brush with Boost's Utilities"), *The First Brush with Boost's Utilities*).
  prefs: []
  type: TYPE_NORMAL
- en: The Boost IOStreams library provides a very rich framework for writing and using
    devices and filters. This chapter introduces only the basic uses of this library
    and there is a whole host of filters, devices, and adaptors that can be combined
    into useful patterns for I/O.
  prefs: []
  type: TYPE_NORMAL
- en: Self-test questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For multiple-choice questions, choose all options that apply:'
  prefs: []
  type: TYPE_NORMAL
- en: What is unique to the `canonical` and `equivalent` functions for manipulating
    paths?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. The arguments cannot name real paths.
  prefs: []
  type: TYPE_NORMAL
- en: b. Both are namespace-level functions.
  prefs: []
  type: TYPE_NORMAL
- en: c. The arguments must name real paths.
  prefs: []
  type: TYPE_NORMAL
- en: What is the problem with the following code snippet assuming the path is of
    type `boost::filesystem::path`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: a. It must have static `value` field.
  prefs: []
  type: TYPE_NORMAL
- en: b. It must have an embedded type called `type`.
  prefs: []
  type: TYPE_NORMAL
- en: c. It must have static `type` field.
  prefs: []
  type: TYPE_NORMAL
- en: d. It must have an embedded type called `result`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given this code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: What is the value of n?
  prefs: []
  type: TYPE_NORMAL
- en: a. 5, the total number of components in the path.
  prefs: []
  type: TYPE_NORMAL
- en: b. 6, the total number of components in the path.
  prefs: []
  type: TYPE_NORMAL
- en: c. 10, the sum of the number of slashes and components.
  prefs: []
  type: TYPE_NORMAL
- en: d. 4, the total number of directory components.
  prefs: []
  type: TYPE_NORMAL
- en: You want to read a text file, remove all blank lines using a `grep_filter`,
    replace specific keywords using the `regex_filter`, and count the characters and
    lines in the result. Which of the following pipelines will you use?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `file_source | grep_filter| regex_filter | counter`
  prefs: []
  type: TYPE_NORMAL
- en: b. `grep_filter | regex_filter | counter | file_source`
  prefs: []
  type: TYPE_NORMAL
- en: c. `counter | regex_filter | grep_filter |file_source`
  prefs: []
  type: TYPE_NORMAL
- en: d. `file_source | counter | grep_filter | regex_filter`
  prefs: []
  type: TYPE_NORMAL
- en: 'True or false: A tee filter cannot be used with an input stream.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. True.
  prefs: []
  type: TYPE_NORMAL
- en: b. False.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the Boost Filesystem library for reading file metadata
    and state of files and directories, and performing operations on them. We also
    covered the high-level Boost IOStreams framework for performing type-safe I/O
    with rich semantics.
  prefs: []
  type: TYPE_NORMAL
- en: Working with files and performing I/O are basic system programming tasks that
    almost any useful piece of software needs to perform and the Boost libraries we
    covered in this chapter ease those tasks through a set of portable interfaces.
    In the next chapter, we will turn our attention to another systems programming
    topic—concurrency and multithreading.
  prefs: []
  type: TYPE_NORMAL
