- en: Introduction to Object-Orientated Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, you have seen how to modularize code in functions and encapsulate data
    with code in a class. You have also seen how to write generic code with templates.
    Classes and encapsulation allow you to combine together code and data as an object.
    In this chapter, you'll learn how to *reuse* code through inheritance and composition
    and how to use class inheritance to write object-orientated code.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance and composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The classes you have seen so far are complete classes: you can create an instance
    of the class on the free store or the stack. You can do this because the data
    members of the class have been defined and so it is possible to calculate how
    much memory is needed for the object, and you have provided the full functionality
    of the class. These are called **concrete classes**.'
  prefs: []
  type: TYPE_NORMAL
- en: If you have a routine in a class that proves useful and you want to reuse in
    a new class, you have a few choices. The first is called **composition**. With
    composition you add an instance of your utility class as a data member of the
    classes that will use the routine. A simple example is the `string` class--this
    provides all the functionality that you want from a string. It will allocate memory
    according to how many characters have to be stored and deallocate the memory it
    uses when the string object is destroyed. Your class uses the functionality of
    a string, but it is not a string itself, hence it has the string as a data member.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use **inheritance**. There are many ways to use inheritance,
    and this chapter will mention some of them. In basic terms, inheritance is when
    one class *extends* another class the class being extended is called the **base
    class**, **parent class**, or **superclass**, and the class doing the extending
    is called a **derived class**, **child class**, or **subclass**. However, there
    is an important concept to understand with inheritance: the relationship of the
    derived class to the base class. It is commonly given in terms of **is-a**. If
    the derived class is a type of base class, then the relationship is inheritance.
    An mp3 file is an operating system file, so if you have a `os_file` class, then
    you could legitimately derive from it to create an `mp3_file` class.'
  prefs: []
  type: TYPE_NORMAL
- en: The derived class has the functionality and state of the base class (although
    it may not have complete access to them, as will be explained later), so it can
    use the functionality of the base class. In this case, it is similar to composition.
    However, there are significant differences. In general, in composition, the composed
    object is used by the class and not exposed directly to the client of the class.
    With inheritance, an object of the derived class is an object of the base class,
    so usually the client code will see the base class functionality. However, a derived
    class can hide the functionality of the base class, so client code will not see
    the hidden base class member, and the derived class can override the base class
    methods and provide its own version.
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot of disagreement in the C++ community over whether you should
    use inheritance or composition to reuse code, and there are advantages and disadvantages
    of each. Neither is perfect and often a compromise is needed.
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting from a class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider a class that wraps an operating system. This will provide lots of
    methods to give access to things such as the creation date, modification date,
    and the size of the file obtained by calling operating system functions. It could
    also provide methods to open the file, close the file, map the file into memory,
    and other useful things. Here are a few such members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'An mp3 file is an operating system file, but there are other operating system
    functions to access its data. We could decide to create an `mp3_file` class that
    derives from an `os_file` so that it has the functionality of the operating system
    file and extend this with the functionality of an mp3 file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first line of the `mp3_file` class indicates that it uses *public* *inheritance*
    (we will explain what public inheritance means later, but it is worth pointing
    out that this is the most common way to derive from a class). The derived class
    inherits the data members and the methods, and users of the derived class can
    use the members of the base class through the derived class, subject to the access
    specifiers. In this example, if some code has an `mp3_file` object, it can call
    the `get_length_in_seconds` method from the `mp3_file` class, and it can also
    call the `get_size_in_bytes` method from the base because this method is `public`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The base class methods will most likely access the base class data members,
    and this illustrates an important point: the derived object contains the base
    class data members. Conceptually, in memory, you can think of the derived object
    as being the base class object data members with the extra data members defined
    in the derived object. That is, the derived object is an extended version of the
    base class object. This is illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/92734943-7c75-4c41-8840-907b7ddd8b2b.png)'
  prefs: []
  type: TYPE_IMG
- en: In memory, an `os_file` object has two data members, `file_name` and `file_handle`,
    and an `mp3_file` object has these two data members and an additional data member,
    `length_in_secs`.
  prefs: []
  type: TYPE_NORMAL
- en: The encapsulation principle is important in C++. Although an `mp3_file` object
    contains the `file_name` and `file_handle` data members, they should only be changed
    by the base class methods. In this code, this is enforced by making them `private`
    to the `os_file` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a derived object is created, the base object must be created first (with
    an appropriate constructor), similarly, when a derived object is destroyed, the
    derived part of the object is destroyed first (through the destructor of the derived
    class) before the base class destructor is called. Consider the following code
    snippet, using the members discussed in preceding text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `open_file` and `close_file` functions will be some operating system functions
    to open and close operating system files.
  prefs: []
  type: TYPE_NORMAL
- en: The derived class no longer has to perform the action of closing the file because
    the base class destructor,Â `~os_file`, is automatically called after the derived
    class destructor is called. The `mp3_file` constructor calls the base class constructor
    through its constructor member list. If you do not explicitly call a base class
    constructor, then the compiler will call the default constructor of the base class
    as the first action of the derived class constructor. If the member list initializes
    data members, these will be initialized after any base class constructor is called.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding methods and hiding names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The derived class inherits the functionality of the base class (subject to
    the access level of the methods), so a base class method can be called through
    an object of the derived class. The derived class can implement a method with
    the same prototype as the base class method, in which case the base class method
    is *overridden* by the derived class method and the derived class provides the
    functionality. A derived class will often override a base class method to provide
    functionality that is specific to the derived class; however, it can call the
    base class method by calling the method using the name resolution operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Remember that a struct is a `class` type where members are `public` by default,
    and inheritance is `public` by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the `base::f` and `base::g` methods will perform some action available
    to users of instances of this class. The `derived` class inherits both methods,
    and since it does not implement the method `g` when instances of the `derived`
    class call the `g` method, they will actually call the `base::g` method. The `derived`
    class implements its own version of the `f` method, so when an instance of the
    `derived` class calls the `f` method, they will call `derived::f` and not the
    base class version. In this implementation, we have decided that we need some
    of the functionality of the base class version, so `derived::f` explicitly calls
    the `base::f` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, the method calls the base class version first before
    providing its own implementation. There is no specific convention here. Class
    libraries are sometimes implemented specifically for you to derive from a base
    class and use the class library code. The documentation of the class library will
    say whether you are expected to replace the base class implementation or if you
    are expected to add to the base class implementation, and if so, whether you will
    call the base class method before or after your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the derived class provides a method with the exact prototype
    as the method on the base class to override it. In fact, adding any method with
    the same name as a method in the base class hides that base class method from
    the client code that uses the derived instance. So, consider that the `derived`
    class is implemented like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the `base::f` method is hidden from the code that creates a `derived`
    object, even though the method has a different prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The base class method with the same name is hidden, so the last line will not
    compile. You can, however, call the function explicitly by providing the base
    class name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: At first sight, this syntax looks a little odd but once you know that the `.`
    and `->` operators give access to a member, and the symbol after the operator
    is the name of the member, in this case, explicitly specified using the class
    name and scope resolution operator.
  prefs: []
  type: TYPE_NORMAL
- en: In general, the code shown so far is called **implementation inheritance**,
    where a class inherits the implementation from a base class.
  prefs: []
  type: TYPE_NORMAL
- en: Using pointers and references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C++, you can get a pointer to where an object (a built-in type or a custom
    type) resides in memory using the `&` operator. The pointer is typed, so the code
    using the pointer assumes that the pointer points to the memory layout of the
    object of the type. Similarly, you can obtain a reference to an object, and the
    reference is an *alias* for the object, that is, operations on the reference occur
    on the object. A pointer (or a reference) to an instance of a derived class can
    be implicitly converted to a pointer (or a reference) to a base class object.
    This means that you can write a function that acts upon base class objects, using
    the behavior of the base class objects, and as long as the parameter is a pointer
    or reference to a base class, you can pass any derived class object to the function.
    The function does not know about, nor does it care about, the derived class functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should think about the derived object as being a base class object and
    accept that it can be used as a base class object. Clearly, a base class pointer
    will only have access to the members on the base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3893edb8-394f-41f6-8150-a82d8a8a097d.png)'
  prefs: []
  type: TYPE_IMG
- en: If the derived class hides a member of the base class, it means that a pointer
    to the derived class will call the derived version through the member name, but
    the base class pointer will only see the base class member, not the derived version.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have a base class pointer, you can cast it to a derived class pointer
    using `static_cast`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The problem here is how can the `print_y` function guarantee that the base class
    pointer passed as the parameter to the specific derived object? It cannot, without
    discipline from the developers using the function guaranteeing that they will
    never pass a derived class pointer of a different type. The `static_cast` operator
    will return a pointer to a `derived` object even if the memory does not contain
    that object. There is a mechanism to perform type checking on the pointer being
    cast, which we will cover later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Access levels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have seen two access specifiers for class members: `public` and
    `private`. Members declared in the `public` section can be accessed by code in
    the class *and* by code outside the class either on an object or if the member
    is `static`, using the class name. Members declared in the `private` section can
    only be accessed by other members in the same class. A derived class can access
    the `private` members of the base class but not the `private` members. There is
    a third type of member access: `protected`. Members declared in the `protected`
    section can be accessed by methods in the same class or by methods in any derived
    class and by friends, but not by external code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, the `test` method can be called by members in the `derived` class
    but not by code outside of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are writing a base class that you intend only ever to be used as a base
    class (client code should not create instances of it), then it makes sense to
    make the destructor `protected`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The compiler will not allow you to create objects of this class on the free
    store and then destroy with `delete`, because this operator will call the destructor.
    Similarly, the compiler won't allow you to create objects on the stack because
    the compiler will call the inaccessible destructor when the object goes out of
    scope. This destructor will be called through the destructor of the derived class,
    so you can be assured that a correct cleanup of the base class will occur. This
    pattern does mean that you always only intend to use pointers to the derived classes
    to destroy the object with a call to the `delete` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Changing access level through inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you override a method in the derived class, the access to the method is
    defined by the derived class. So if the base class method is `protected` or `public`,
    the access can be changed by the derived class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `base::f` method is `protected`, so only the `derived`
    class can access it. The `derived` class overrides this method (and can call the
    base class method if the fully qualified name is used) and makes it `public`.
    Similarly, theÂ `base::g` method is `public` but the `derived` class overrides
    this method and makes it `protected` (and if desired, it could make the method
    `private`).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also expose a `protected` base class from a derived class as a `public`
    member with a `using` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the `derived::f` method is `public` without the derived class creating
    a new method. A better use of this facility is to make a method `private` so that
    it is not available to derived classes (or if it was `public`, through an instance),
    or make it `protected` so that external code cannot access the member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code can be used like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The last line won''t compile because the `f` method is `protected`. If the
    intention is to make the method available only in the derived class and not to
    in any classes that may derive from it, you can use the `using` statement in the
    `private` section of the derived class; this is similar to deleting a base class
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `f` method cannot be used through the `derived` class, but the class can
    call the `base` class method.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance access levels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier, you saw that to derive from a class, you provide the base class name
    and give an inheritance access specifier; the examples so far have used `public`
    inheritance, but you can use `protected` or `private` inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: This is another difference between class and struct. For a class, if you miss
    off the inheritance access specifier, the compiler will assume that it is private;
    for a struct, if you miss off the inheritance access specifier, the compiler will
    assume that it is public.
  prefs: []
  type: TYPE_NORMAL
- en: The inheritance specifier applies more access restrictions, it will not relax
    them. The access specifier does not determine the access it has to the base class
    members, instead it alters the accessibility of those members through the derived
    class (that is through an instance of the class, or if another class derives from
    it). If a base class has `private` members, and a class inherits using `public`
    inheritance, the derived class still cannot access the `private` members; it only
    has access to `public` and `protected` members and objects of the derived class
    can only access the `public` members, and a class deriving from this class will
    only have access to the `public` and `protected` members.
  prefs: []
  type: TYPE_NORMAL
- en: If a derived class derives through the *protected inheritance*, it still has
    the same access to the base class asÂ `public` and `protected` members, but the
    base class `public` and `protected` members will now be treated as `protected`
    through the derived class, so they can be accessed by a further derived class
    but are not accessible through an instance. If a class derives through private
    inheritance then all base class members become `private` in the derived class;
    so, although the derived class can access `public` and `protected` members, classes
    that derive from it cannot access any of the base class members.
  prefs: []
  type: TYPE_NORMAL
- en: One way of looking at protected inheritance is if the derived class had a `using`
    statement for each of the `public` members of the base class in the `protected`
    part of the class. Similarly, private inheritance is as if you have deleted each
    of the `public` and `protected` methods of the base class.
  prefs: []
  type: TYPE_NORMAL
- en: In general, most inheritance will be through *public inheritance*. However,
    *private inheritance* has a use when you want to access some functionality from
    a base class but do not want its functionality to be available to classes that
    derive from your class. This is a little like composition, where you are using
    functionality but do not want that functionality directly exposed.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C++ allows you to inherit from more than one base class. This is a powerful
    facility when used with interfaces, as we will discover later in this chapter.
    It can be useful for implementation inheritance, but it can cause some problems.
    The syntax is simple: you provide a list of classes to inherit from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: One way to use multiple inheritances is to build up libraries of classes each
    providing some functionality, or services. To get these services in your class
    you can add the class from the library to your base class list. Such a *building
    block* approach to creating classes through implementation inheritance has issues,
    as we will see later, and often a better approach is to use composition.
  prefs: []
  type: TYPE_NORMAL
- en: It is important when you consider multiple inheritances that you carefully review
    that you need the services via inheritance or whether composition is more appropriate.
    If a class provides a member that you do not want to be used by instances and
    you decide that you need to delete it, it is a good sign that you should consider
    composition.
  prefs: []
  type: TYPE_NORMAL
- en: 'If both classes have a member with the same name, then there is a potential
    problem. The most obvious case is if the base classes have a data member with
    the same name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, both base classes have a data member called `x`. The
    `derived` class inherits from both classes, so does this mean that it gets just
    one data member called `x`? No. If it did, then this would mean that the `base1`
    class would be able to alter a data member in the `base2` class without knowing
    that it is affecting another class, and similarly the `base2` class will find
    its data member being altered by the `base1` class even though that class is not
    a `friend`. Consequently, when you derive from two classes with data members that
    have the same name, the derived class gets both data members.
  prefs: []
  type: TYPE_NORMAL
- en: This yet again illustrates the importance of maintaining encapsulation. Such
    data members should be `private` and only changed by the base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The derived class (and the code that uses instances, if the data members are
    accessible) can distinguish between them using their full names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The class can be summed up with the following diagram, illustrating the memory
    occupied by the three classes: `base1`, `base2`, and `derived`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/05bc19b7-42ab-43b1-83a6-dd934527e416.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you maintain encapsulation and make data members `private` and give access
    only through accessor methods, then derived classes will not have direct access
    to the data members and will not see this issue. However, the same issue occurs
    with methods, but the problem occurs even if the methods have different prototypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the two base classes have a method with the same name, `a`, but
    with a different prototype. This causes a problem when using the `derived` class,
    even when it may be obvious by the parameters what method should be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will not compile, and the compiler will complain that the method
    call is ambiguous. Again, the solution to this problem is simple, you just need
    to specify which base class method to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Multiple inheritances can get even more complicated. The problem occurs if you
    have two classes that derive from the same base class and then you create another
    class that derives from both. Does the new class get two copies of the topmost
    base class members--one through each of its immediate base classes?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb441eea-fa33-4434-b4ba-56255cba5624.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At the first level of inheritance, each of the classes (`base1` and `base2`)
    inherit the data member from the ultimate base class (here, the data members are
    both called `base::x` to illustrate that they are inherited from the ultimate
    base class, `base`). The most derived class, `derived`, inherits *two* data members,
    so which one is `base::x`? The answer is that only one of them is, `base1::x`
    is `base::x`, because it is the first in the inheritance list. When the `base`
    methods change it, the change will be seen in `base1` through `base1::x`. The
    `base2::x` member is a separate data member and not affected when `base` changes
    `base::x`. This is perhaps an unexpected result: the most-derived class inherits
    `x` from both of its parent classes.'
  prefs: []
  type: TYPE_NORMAL
- en: This may not be the behavior you want. This issue is often called *diamond inheritance
    issue*Â and it should be apparent from the preceding diagram, where this name comes
    from. The solution is straightforward, and will be covered later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Object slicing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in the chapter, you saw that if you use a base class pointer to a derived
    object only the base class members can be safely accessed. The other members are
    still there, but they can only be accessed through an appropriate derived class
    pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you cast a derived class object to a base class object, something
    else happens: you create a new object, and that object is the base class object,
    just the base class object. The variable that you have cast to will only have
    the memory for the base class object, so the result is only the base class object
    part of the derived object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the objects `b1` and `b2` have been created by *slicing off* the extra
    data in the `derived` class object `d`. This code looks a bit perverse, and you
    are not likely to write it, but the situation is likely to happen if you pass
    an object by value to a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If you pass a `derived` object to this function, the `base` copy constructor
    will be called to create a new object, slicing off the `derived` class data members.
    In most cases, you do not want this behavior. This issue also has an unexpected
    behavior if your base class has virtual methods and expects the polymorphic functionality
    that virtual methods offer (virtual methods are covered later in this chapter).
    It is almost always a better idea to pass objects by reference.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Polymorphism comes from the Greek for *many shapes*. So far, you have a basic
    form of polymorphism. If you use a base class pointer to an object, then you can
    access the base class behavior, and if you have a derived class pointer, you get
    the derived class behavior. This is not as trivial as it appears because the derived
    class can implement its own version of the base class methods, so you can have
    a different implementation of that behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can have more than one class derived from a base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Since C++ is strongly typed, it means that a pointer to one derived class cannot
    be used to point to another derived class. So you cannot use a `derived1*` pointer
    to access an instance of `derived2`, it can only point to an object of type `derived1`.
    Even if the classes have the same members, they are still different types and
    their pointers are different. However, all derived classes have something in common,
    which is the base class. A derived class pointer can be implicitly converted to
    a base class pointer, so a `base*` pointer can point to an instance of `base`,
    `derived1`, `derived2`, or `derived3`. This means that a generic function taking
    a `base*` pointer as a parameter can be passed a pointer to any of these classes.
    This is the basis of interfaces, as we will see later.
  prefs: []
  type: TYPE_NORMAL
- en: The polymorphic aspect is that through pointers (or references), an instance
    of a class can be treated as an instance of any of the classes in its inheritance
    hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A base class pointer or reference giving access to just the base class functionality,
    and makes sense, but it is restrictive. If you have a `car` class that provides
    the interface for a car, a gas pedal, and brake to alter the speed, a steering
    wheel and reverse gear to alter the direction-you can derive from this class various
    other car types: a sports car, an SUV, or a family sedan. When you press the gas
    pedal, you expect the car to have the torque of an SUV, if your car is an SUV,
    or the speed of a sports car if it''s a sports car. Similarly, if you call the
    `accelerate` method on a `car` pointer and that pointer is to a `suv`, then you
    expect to get method to reflect the torque of the SUV, and if the `car` pointer
    points to a `sportscar` object, you performance acceleration. Earlier, we said
    that if you access a derived class instance through a base class pointer, then
    you will get the implementation of the base class methods. This means that, calling
    the `accelerate` method on a `car` pointer that points to an `suv` or a `sportscar`
    object, you will still get the implementation of `car::accelerate` and not `suv::accelerate`
    or `sportscar::accelerate`Â which you would want.'
  prefs: []
  type: TYPE_NORMAL
- en: This behavior of calling the derived method through a base class pointer is
    known as **method dispatching**. The code calling a method through a base class
    pointer does not know the type of object that the pointer points to, but it still
    gets the functionality of that object because the method on that object is called.
    This method dispatching is not applied by default because it involves a little
    extra cost both in memory and performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Methods that can take part in method dispatching are marked with the keyword
    `virtual` in the base class, and hence are usually called **virtual methods**.
    When you call such a method through a base class pointer, the compiler ensures
    that the method on the actual object''s class is called. Since every method has
    a `this` pointer as a hidden parameter, the method dispatching mechanism must
    ensure that the `this` pointer is appropriate when the method is called. Consider
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a base class and two child classes, `derived1` and `derived2`. There
    is a further level of inheritance through `derived2` to a class called `derived3`.
    The base class implements a method called `who` that prints the class name. This
    method is implemented appropriately on each of the derived classes so that when
    this method is called on an object of `derived3`, the method will print `derived3`
    in the console. The `main` function creates an instance of each of the derived
    classes and passes each one by reference to a function called `who_is_it` that
    calls the `who` method. This function has a parameter that is a reference to `base`,
    and since this is the base class of all of the classes (for `derived3`, its immediate
    base class is `derived2`). When you run this code, the result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This output comes from the three calls to the `who_is_it` function, passing
    objects that are instances of the `derived1`, `derived2`, and `derived3` classes.
    Since the parameter is a reference to `base`, it means that the `base::who` method
    is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Making one simple change will alter this behavior completely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'All that has changed is the addition of the `virtual` keyword to the `who`
    method in the base class, but the result is significant. When you run this code,
    the result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You have not changed the `who_is_it` function, nor the methods on the derived
    classes, yet the output of `who_is_it` is very different compared to what it was
    earlier. The `who_is_it` function calls the `who` method through a reference,
    but now, rather than calling the `base::who` method, the `who` method on the actual
    object that the reference aliases is called. The `who_is_it` function has done
    nothing additional to make sure that the derived class function is called--it
    is *exactly* the same as earlier.
  prefs: []
  type: TYPE_NORMAL
- en: The `derived3` class is not derived directly from `base`, instead, it is derived
    from `derived2`, which is itself a child class of `base`. Even so, the method
    dispatching works on instances of the `derived3` class. This illustrates that
    however far up the inheritance chain `virtual` is applied, the method dispatching
    will still work on the inherited method of the derived class.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to point out that the method dispatching is applied *only* to
    the methods that `virtual` has been applied to in the base class. Any other methods
    in the base class not marked with `virtual` will be called without method dispatching.
    A derived class will inherit a `virtual` method and get the method dispatching
    automatically, it does not have to use the `virtual` keyword on any methods it
    overrides, but it is a useful visual indication as to how the method can be called.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the derived classes implementing `virtual` methods, you can use a single
    container to hold pointers to instances of all such classes and invoke their `virtual`
    methods without the invocation code knowing the type of the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `arr` built-in array holds pointers to objects of the three types
    and the ranged `for` loop iterates through the array and calls the method virtually.
    This gives the expected result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three important points about the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: It is important that a built-in array is used here; there are issues with the
    Standard Library containers like `vector`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important that the array holds pointers, not objects. If you have an array
    of `base` objects, they will be initialized by slicing the derived objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is also important that the address of a stack object is used. This is because
    there are issues with destructors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These three issues are covered in later sections.
  prefs: []
  type: TYPE_NORMAL
- en: For a `virtual` method to be called using method dispatching, the derived class
    method must match the same signature as the base class'Â `virtual` method in terms
    of the name, parameters, and return type. If any of these are different (for example,
    different parameters), then the compiler will think that the derived method is
    a new function, and so when you call the `virtual` method through the base pointer,
    you'll get the base method. This is a rather insidious error because the code
    will compile, but you will get the wrong behavior.
  prefs: []
  type: TYPE_NORMAL
- en: The one exception to the last paragraph is if two methods differ by return types
    that are **covariant**, that is, one type can be converted to the other.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual method tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The behavior of method dispatching via virtual methods is all you need to know,
    but it is helpful to see how the C++ compiler implements method dispatching because
    it highlights the overhead of the `virtual` methods.
  prefs: []
  type: TYPE_NORMAL
- en: When the compiler sees a `virtual` method on a class, it will create a method
    pointer table, called the **vtable**, and put a pointer to each of the `virtual`
    methods in the class in the table. There will be a single copy of the `vtable`
    for the class. The compiler will also add a pointer to this table, called the
    **vptr**, in every instance of the class. So, when you mark a method as `virtual`,
    there will be a single memory overhead of a `vtable` being created for that class
    at runtime, and the memory overhead of an extra data member, the `vptr`, for every
    object created from the class. Normally, when client code calls a (non-inline)
    method, the compiler will place a jump to the function in the client code to the
    method. When the client code calls a `virtual` method, the compiler has to dereference
    the `vptr` to get to the `vtable` and then use the appropriate address stored
    there. Clearly, this involves an extra level of indirection.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a separate entry in the `vtable` for each `virtual` method in the
    base class, in the order in which they are declared. When you derive from a base
    class with `virtual` methods, the derived class will also have a `vptr`, but the
    compiler will make it point to the `vtable` of the derived class, that is, the
    compiler will populate the `vtable` with the addresses of the `virtual` method
    implementations in the derived class. If the derived class does not implement
    a `virtual` method it inherits, then the pointer in the `vtable` will be to the
    base class method. This is illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc74ce55-48c9-4bd6-bd99-e02d38151193.png)'
  prefs: []
  type: TYPE_IMG
- en: On the left-hand side, there are two classes; the base class has two virtual
    functions, and the derived class implements just one of these. On the right-hand
    side, there is an illustration of the memory layout. Two objects are shown as
    aÂ `base` object and a `derived` object. Each object has a single `vptr` followed
    by the data members of the class, and the data members are arranged in such a
    way that the base class data members are arranged first, followed by the derived
    class data members. The `vtable` pointers contain method pointers to the `virtual`
    methods. In the case of the base class, the method pointers point to the methods
    implemented on the `base` class. In the case of the derived class, only the second
    method is implemented in the `derived` class, so the `vtable` for this class has
    a pointer to one virtual method in the `base` class and the other in the `derived`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'This raises the question: what happens if a derived class introduces a new
    method, not available in the base class, and makes that `virtual`? This is not
    inconceivable since the ultimate base class could provide just part of the behavior
    needed and classes derived from it, provide more of the behavior to be called
    through virtual method dispatching on subclasses. The implementation is quite
    simple: the compiler creates a `vtable` for all of the `virtual` methods on the
    class, so if a derived class has extra `virtual` methods, the pointers for these
    appear in the `vtable` after the pointers to the `virtual` methods inherited from
    the base class. When the object is called through a base class pointer, wherever
    that class is in the inheritance hierarchy, it will only see the `vtable` entries
    relevant to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eccd155e-2d01-427f-96ed-3261ff940476.png)'
  prefs: []
  type: TYPE_IMG
- en: Multiple inheritance and virtual method tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If a class derives from more than one class and the parent classes have `virtual`
    methods, then the vtable for the derived class will be a combination of the vtables
    of its parents arranged in the order in which the parent classes were listed in
    the derivation list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f3c6f103-1c95-4b1d-ac49-1b656fb4c8d6.png)'
  prefs: []
  type: TYPE_IMG
- en: If the object is accessed through a base class pointer, the `vptr` has access
    to the part of the `vtable` relevant to that base class.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual methods, construction, and destruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The derived class portion of the object won't be constructed until the constructor
    has completed, so if you call a `virtual` method, the `vtable` entry will not
    be set up to call the correct method. Similarly, in a destructor, the derived
    class portions of the object will have already been destroyed-including their
    data members, and so the `virtual` methods on the derived class cannot be called
    because they may attempt to access data members that no longer exist. If the `virtual`
    method dispatching was allowed in these situations, the result would be unpredictable.
    You should not call a `virtual` method in a constructor or a destructor, if you
    do, the call will resolve to the base class version of the method.
  prefs: []
  type: TYPE_NORMAL
- en: If a class is expected to be called through base class pointers with the `virtual`
    method dispatching, then you should make the destructor `virtual`. We do this
    because a user may delete a base class pointer, and in this situation, you will
    want the derived destructor to be called. If the destructor is not `virtual` and
    the base class pointer is deleted, then only the base class destructor is called,
    potentially causing a memory leak.
  prefs: []
  type: TYPE_NORMAL
- en: In general, a base class destructor should be either `protected` and non-virtual,
    or `public` and `virtual`. If the intention is to use the class through base class
    pointers, then the destructor should be `public` and `virtual` so that the derived
    class destructor is called, but if the base class is intended to be used to provide
    services available only through a derived class object, then you should not give
    direct access to base class objects, and so the destructor should be `protected`
    and non-virtual.
  prefs: []
  type: TYPE_NORMAL
- en: Containers and virtual methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One advantage of the `virtual` methods is to put objects related by a base
    class into a container; earlier, we saw a specific case of using a built-in array
    of base class pointers, but what about the Standard Library containers? As an
    example, imagine that you have a class hierarchy where there is one base class,
    `base`, and three derived classes, `derived1`, `derived2`, and `derived3`, and
    each class implements a `virtual` method `who`, as used earlier. One attempt to
    put objects in a container may be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The problem is that the vector holds `base` objects, and so as the items in
    the initialization list are put into the container, they are actually used to
    initialize new `base` objects. Since the type of `vec` is `vector<base>`, the
    `push_back` method will slice the object. Thus, the statement that calls the `who`
    method on each object will print a string `base`.
  prefs: []
  type: TYPE_NORMAL
- en: In order to have `virtual` method dispatching, we need to put the whole object
    in the container. We can do this either with a pointer or a reference. To use
    a pointer, you can use the addresses of stack objects as long as the `vector`
    does not live longer than the objects in the container. If you use objects created
    on the heap, then you need to ensure that the objects are deleted appropriately,
    and you can do this using smart pointers.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may be tempted to create a container of references:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in a slew of errors; unfortunately, none of them fully indicate
    the issue. The `vector` must contain types that are copy constructible and assignable.
    This is not the case with references because they are aliases to actual objects.
    There is a solution. The `<functional>` header contains an adapter class called
    `reference_wrapper` that has a copy constructor and assignment operator. The class
    converts a reference of an object to a pointer to that object. Now you can write
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The downside of using `reference_wrapper` is that to call the wrapped object
    (and their virtual methods), you need to call the `get` method, which will return
    a *reference* to the wrapped object.
  prefs: []
  type: TYPE_NORMAL
- en: Friends and inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C++, friendship is not inherited. If a class makes another class (or function)
    a friend, it means that the friend has access to its `private` and `protected`
    members as if the friend is a member of the class. If you derive from the `friend`
    class, the new class is not a friend of the first class, and it has no access
    to the members of that first class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the last chapter, we saw how you can insert an object into an `ostream`
    object to print it by writing a global insertion operator and making this a `friend`
    of the class. In the following, the `friend` function is implemented inline, but
    it is actually a separate, global function that can be called without an object
    or name resolution with the class name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: If we derive from the `base` class, we will need to implement a `friend` function
    to insert the derived object into the stream. Since the function is a *friend*,
    it will be able to access the `private` and `protected` members of the derived
    class, but it cannot access the `private` members of the base class. This situation
    will mean that the insertion operator that is a *friend* of the derived class
    can only print out part of the object.
  prefs: []
  type: TYPE_NORMAL
- en: If a `derived` class object is cast to a `base` class, say, through a pointer
    or reference when passing by reference, and the object is printed, it will be
    the `base` version of the insertion operator that will be called. The insertion
    operator is a `friend` function so that it has access to the class' non-public
    data members, but being a *friend* is not enough to allow it to be a `virtual`
    method, so there is no `virtual` method dispatching.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the `friend` function cannot be called as a `virtual` method, it can
    call `virtual` methods and get the method dispatching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In this version, there is just one insertion operator and it is defined for
    the `base` class. This means that any object that can be converted to the `base`
    class can be printed using this operator. The actual work of printing out the
    object is delegated to a `virtual` function called `output`. This function is
    protected because it is intended only to be used by the class or derived classes.
    The `base` class version of this prints out the data members of the base class.
    The `derived` class version has two tasks: printing out the data members in the
    `base` class and then printing out the data members specific to the `derived`
    class. The first task is accomplished by calling the `base` class version of the
    method by qualifying the name with the base class name. The second task is simple
    because it has access to its own data members. If you were to derive another class
    from `derived`, then its version of `output`Â function will be similar, but it
    would call `derived::output`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now when an object is inserted into an `ostream` object like `cout`, the insertion
    operator will be called, and the call to the `output` method will be dispatched
    to the appropriate derived class.
  prefs: []
  type: TYPE_NORMAL
- en: Override and final
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned earlier, if you type the prototype of a derived `virtual` method
    wrong, for example, use the wrong parameter types, the compiler will treat the
    method as a new method and will compile it. It is perfectly legal for a derived
    class not to override the method of the base class; this is a feature that you
    will often want to use. However, if you make a mistake in typing the prototype
    of a derived `virtual` method, the base method will be called when you intended
    your new version to be called. The `override` specifier is designed to prevent
    this bug. When the compiler sees this specifier, it knows that you intend to override
    a `virtual` method inherited from a base class and it will search the inheritance
    chain to find a suitable method. If no such method can be found, then the compiler
    will issue an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Here, `derived::f` won't compile because there is no method in the inheritance
    chain with the same signature. The `override` specifier gets the compiler to perform
    some useful checks, so it is a good habit to use it on all derived overridden
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++11 also provides a specifier called `final`, which you can apply to a method
    to indicate that a derived class cannot override it, or you can apply it to a
    class to indicate that you cannot derive from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: It is rare that you'll want to use this.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Earlier, we talked about the so-called *diamond* problem with multiple inheritance,
    where a class inherits from a single ancestor class via two base classes. When
    a class inherits from another class, it will get the parent class'' data members
    so that an instance of the derived class is treated as being made up of the base
    class data members and the derived class data members. If the parent classes are
    derived from the same ancestor class, they will each get the ancestor class''
    data members resulting in the final derived classes getting copies of the ancestor
    class'' data members from each parent class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'When you create an instance of the `most_derived` class, you have two copies
    of `base` in the object: one from each of the `derived1` and `derived2`. This
    means that the `most_derived` object will have two copies of the data member `x`.
    Clearly, the intention is for the derived class to get just one copy of the ancestor
    class'' data members, so how can this be achieved? The solution to this problem
    is **virtual inheritance**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Without virtual inheritance, derived classes just call the constructors of
    their immediate parent. When you use `virtual` inheritance, the `most_derived`
    class has the responsibility to call the constructor of the topmost parent class
    and if you do not explicitly call the base class constructor, the compiler will
    automatically call the default constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `most_derived` constructor calls the `base` constructor
    because this is the base class that its parent classes inherit from virtually.
    The `virtual` base classes are always created before the non-virtual base classes.
    In spite of the call to the `base` constructor in the `most_derived` constructor,
    we still have to call the `base` constructor in the derived classes. If we further
    derive from `most_derived`, then that class must call the constructor of `base`
    too because that is where the `base` object will be created. Virtual inheritance
    is more expensive than single or multiple inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A class with `virtual` methods is still a **concrete class**--you can create
    instances of the class. You may decide that you want to provide just a part of
    the functionality, with the intention that a user *has* to derive from the class
    and add the missing functionality.
  prefs: []
  type: TYPE_NORMAL
- en: One way to do this is to provide a `virtual` method that has no code. This means
    that you can call the `virtual` method in your class, and at runtime, the version
    of the method in the derived class will be called. However, although this provides
    a mechanism for you to call derived methods in your code, it does not *force*
    the implementation of those `virtual` methods. Instead, the derived class will
    inherit the empty `virtual` methods and if it does not override them, the client
    code will be able to call the empty method. You need a mechanism to *force* a
    derived class to provide an implementation of those `virtual` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++ provides a mechanism called **pure virtual methods** that indicates that
    the method should be overridden by a derived class. The syntax is simple, you
    mark the method with `= 0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the complete class; it is all that this class provides for the definition
    of the method `f`. This class will compile even though the method `g` calls a
    method that has no implementation. However, the following will not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'By declaring a pure virtual function, you make the class abstract, which means
    that you cannot create instances. You can, however, create pointers or references
    to the class and call code on them. This function will compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This function only knows about the public interface of the class and does not
    care how that is implemented. We have implemented the method `g` to call the method
    `f` to show that you can call a pure virtual method in the same class. In fact,
    you can call the pure virtual function outside the class too; this code is just
    as valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The only way to use an abstract class is to derive from it and implement the
    pure virtual functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are two classes derived from the abstract class, which both implement
    the pure virtual function. These are concrete classes and you can create instances
    of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Abstract classes are used to indicate that a specific functionality has to
    be provided by a derived class, and the `= 0` syntax indicates that the method
    body is not provided by the abstract class. In fact, it is more subtle than this;
    the class must be derived and the method called on the derived class must be defined
    on the derived class, but the abstract base class can also provide a body for
    the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, this class cannot be instantiated, you *must* derive from it and you
    *must* implement the method to be able to instantiate an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The derived class can call the pure virtual function defined in the abstract
    class, but when external code calls such a method, it will always result (through
    method dispatching) in a call to the implementation of the virtual method on the
    derived class.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining type information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ provides type information, that is, you can get information that is unique
    to that type and, which identifies it. C++ is a strongly typed language so the
    compiler will determine type information at compile time and will enforce typing
    rules when it comes to conversions between variable types. Any type checking that
    the compiler does, you can do as the developer. As a general rule of thumb if
    you need to cast using `static_cast`, `const_cast`, `reinterpret_cast`, or C-like
    casts, then you are making the types do something they shouldn't and hence you
    should reconsider rewriting your code. The compiler is very good at telling you
    where there is a misalignment of types, so you should use this as a hint to reassess
    your code.
  prefs: []
  type: TYPE_NORMAL
- en: A *no casting* rule can be a bit too strict, and often code using casts is simpler
    to write and easier to read, but such a rule does focus your mind to always question
    whether a cast is needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you use polymorphism, you will often get a pointer or reference to a type
    that is different to the type of the object, and this becomes especially true
    when you move to interface programming where frequently the actual object is unimportant,
    as it is the behavior that is important. There may be occasions when you need
    to obtain type information and the compiler is unable to help you at compile time.
    C++ provides a mechanism to obtain type information called **Runtime Type Information**
    (**RTTI**) because you can obtain this information at runtime. This information
    is obtained using the `typeid` operator on an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is the following printed at the command-line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This reflects that the `string` class is in fact a `typedef` for the templated
    class, `basic_string`, with a `char` as the character type with character traits
    described by the specialization of the `char_traits` class and an allocator object
    (used to maintain the buffer used by the string), which is a specialization of
    the `allocator` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `typeid` operator returns a `const` reference to a `type_info` object, and
    in this case, we use the `name` method to return a `const char` pointer to the
    name of the type of the object. This is the readable version of the type name.
    The type name is actually stored in a compact, decorated name, which is obtained
    via the `raw_name` method, but if you want to store objects according to their
    type (in a dictionary object, for example), then a more efficient mechanism is
    to use the 32-bit integer returned from the `hash_code` method rather than the
    decorated name. In all cases, the value returned will be the same for all objects
    of the same type, but different to objects of another type.
  prefs: []
  type: TYPE_NORMAL
- en: The `type_info` class has no copy constructor or copy assignment operator, and
    so objects of this class cannot be put in a container. If you want to put `type_info`
    objects in an associative container like a `map`, then you have two options. First
    you can put a pointer to the `type_info` object into a container (a pointer can
    be obtained from a reference); in which case, if the container is ordered, you
    need to define a comparison operator. The `type_info` class has a `before` method,
    which can be used to compare two `type_info` objects.
  prefs: []
  type: TYPE_NORMAL
- en: The second option (in C++11) is to use objects of the `type_index` class as
    the key to the associative container, and this class is used to wrap theÂ `type_info`
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: The `type_info` class is intended to be read-only, and the only way to create
    instances is through the `typeid` operator. You can, however, call the comparison
    operators, `==` and `!=`, on `type_info` objects, which means that you can compare
    at runtime the types of objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since you can apply the `typeid` operator on both variables and types, it means
    that you can use the operator to perform casts that are safe from slicing or from
    casting to a completely unrelated type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This function can take a pointer for any class that is derived from the `base`
    class. The first line uses the conditional operator where the comparison is between
    the type information for the object pointed to by the function parameter and the
    type of the class `derived`. If the pointer is to a `derived` object, then the
    cast will work. If the pointer is to an object of another derived type, but not
    the `derived` class, then the comparison will fail and the expression evaluates
    to `nullptr`. The `call_me` function will only call the `f` method if the pointer
    points to an instance of the `derived` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++ provides a cast operator that performs runtime, and such type checking
    at runtime is called `dynamic_cast`. If the object can be cast to the requested
    type, then the operation will succeed and return a valid pointer. If the object
    cannot be accessed through the requested pointer, then the cast fails and the
    operator returns `nullptr`. This means that whenever you use `dynamic_cast`, you
    should always check the returned pointer before using it. The `call_me` function
    can be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This is essentially the same code as earlier; the `dynamic_cast` operator performs
    runtime type checking and returns an appropriate pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that you cannot downcast, neither to a `virtual` base class pointer nor
    to a class derived through `protected` or `private` inheritance. The `dynamic_cast`
    operator can be used for casts other than downcasts; clearly, it will work for
    an upcast (to a base class, although it is not necessary), it can be used for
    casts sideways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Here there are two base classes, so if you access a derived object through
    one of the base class pointers, you can use the `dynamic_cast` operator to cast
    to a pointer of the other base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Smart pointers and virtual methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to use dynamically created objects, you will want to use smart pointers
    to manage their lifetime. The good news is that `virtual` method dispatching works
    through smart pointers (they are simply wrappers around object pointers), and
    the bad news is that the class relationships are lost when you use smart pointers.
    Let's examine why.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following two classes are related by inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This is straightforward: that implement a `virtual` method, which indicates
    the type of the object. There is, a `virtual` destructor because we are going
    to hand over the lifetime management to a smart pointer object and we want to
    ensure that the `derived` class destructor is called appropriately. You can create
    an object on the heap using `make_shared` or the constructor of the `shared_ptr`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'A derived class pointer can be converted to a base class pointer and this is
    explicit in the first statement: `new` returns a `derived*` pointer, which is
    passed to a `shared_ptr<base>` constructor that expects a `base*` pointer. The
    situation in the second statement is a bit more complicated. The `make_shared`
    function returns a temporary `shared_ptr<derived>` object that is converted to
    a `shared_ptr<base>` object. This is carried out by a conversion constructor on
    the `shared_ptr` class that calls a **compiler intrinsic** called `__is_convertible_to`,
    which determines if one pointer type can be converted to the other. In this case,
    there is an upcast so the conversion is allowed.'
  prefs: []
  type: TYPE_NORMAL
- en: Compiler intrinsic are essentially functions provided by the compiler. In this
    example `__is_convertible_to(derived*, base*)` will return `true` and `__is_convertible_to(base*,
    derived*)` will return `false`. You will rarely need to know about intrinsics
    unless you are writing libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Since a temporary object is created in the statement using the `make_shared`
    function, it is more efficient to use the first statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `operator->` on a `shared_ptr` object will give direct access to the wrapped
    pointer and hence this means that the following code will perform `virtual` method
    dispatching, as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The smart pointer will ensure that the derived object is destroyed through the
    base class pointer when `b_ptr` goes out of scope, and since we have a `virtual`
    destructor, appropriate destruction will occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have multiple inheritance, you can use `dynamic_cast` (and RTTI) to
    cast between pointers to the base classes so that you can select only the behavior
    that you need. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have a pointer to either of these base classes, you can convert one
    to the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The `who` and `what` methods can be called on a `derived*` pointer and hence
    they can be called on the smart pointer. The following lines obtain a base class
    pointer so that *specific* behavior is accessed. In this code, we call the `get`
    method to get the raw pointer from the smart pointer. The problem with this method
    is that there is now a pointer to the object that is not protected by the smart
    pointer lifetime management, so it is possible for code to call `delete` on either
    pointer `b1_ptr` or `b2_ptr` and cause problems later when the smart pointer attempts
    to delete the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code works, and there is correct lifetime management of the dynamically-created
    object in this code, but accessing raw pointers like this is inherently unsafe
    because there is no guarantee that the raw pointers will not be deleted. The temptation
    is to use smart pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The problem is that even though the classes `base1` and `derived` are related,
    the classes `shared_ptr<derived>` and `shared_ptr<base1>` are *not* related, and
    so a different control block will be used for each smart pointer type even though
    they refer to the *same object*. The `shared_ptr` class will reference the count
    using the control block and will delete the object when the reference count falls
    to zero. Having two unrelated `shared_ptr` objects and two control blocks to the
    same object means that they will attempt to manage the lifetime of the `derived`
    object independently of each other, and this will ultimately mean one smart pointer
    deleting the object before the other has finished with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three messages here: a smart pointer is a lightweight wrapper around
    a pointer, so you can call `virtual` methods with method dispatching; however,
    be cautious about using raw pointers obtained from smart pointers, and bear in
    mind that although you can have many `shared_ptr` objects to the same object,
    they must be of the same type so that only one control block is used.'
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pure virtual functions and virtual method dispatching leads to an incredibly
    powerful way of writing object-orientated code, which is calledÂ **interfaces**.
    An interface is a class that has no functionality; it only has pure virtual functions.
    The purpose of an interface is to define a behavior. A concrete class that derives
    from an interface *must* provide an implementation of all of the methods on the
    interface, and hence this makes the interface a kind of contract. Users of objects
    that implement an interface have a guarantee that the object that has the interface
    will implement *all* the methods of the interface. Interface programming decouples
    behavior from the implementation. Client code is only interested in behavior and
    they are not interested in the actual class that provides the interface.
  prefs: []
  type: TYPE_NORMAL
- en: For example, an `IPrint` interface could give access to the behavior of printing
    a document (setting page size, orientation, number of copies, and telling the
    printer to print the document). The `IScan` interface can give access to the behavior
    of scanning a sheet of paper (resolution, grayscale or color, and adjustments
    like rotation and cropping). These two interfaces are two different behaviors.
    Client code will use an `IPrint` if it wants to print a document or an `IScan`
    interface pointer if it wants to scan a document. Such client code does not care
    whether it is a `printer` object that implements the `IPrint` interface or a `printer_scanner`
    object that implements both the `IPrint` and `IScan` interfaces. Client code that
    is passed to an `IPrint*` interface pointer is guaranteed that it can call every
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we have defined the `IPrint` interface (the `define`
    makes it more obvious that we are defining abstract classes as interfaces):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'A class can implement this interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then create the `printer` object and call the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Our inkjet printer is also a scanner, so we can make it implement the `IScan`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The next version of the `inkject_printer` class can use multiple inheritance
    to implement this interface, but note that there is a problem. The class already
    implements a method called `set_page`, and since the page properties of the printer
    will be different from the page properties of the scanner, we want a different
    method for the `IScan` interface. We can address this with two different methods
    and qualifying their names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can get the `IScan` interface on the `inkjet` object and call it as
    a scanner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the `inkject_printer` class derives from both the `IPrinter` and `IScan`
    interfaces, you can obtain one interface pointer and cast to the other through
    the `dynamic_cast` operator since this will use RTTI to ensure that the cast is
    possible. So assuming that you''ve got an `IScanner` interface pointer, you can
    test to see if you can cast this to an `IPrint` interface pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Effectively, the `dynamic_cast` operator is being used to request one interface
    pointer if the behavior represented by another interface is unavailable on the
    object that pointer points to.
  prefs: []
  type: TYPE_NORMAL
- en: An interface is a contract; once you have defined it, you should *never* change
    it. This does not constrain you from changing the class. In fact, this is the
    advantage of using interfaces because the class implementation can change completely,
    but as long as it continues to implement the interfaces that the client code uses,
    users of the class can continue to use the class (although a recompile will be
    needed). There are cases when you will discover that the interface you defined
    is inadequate. Perhaps there is a parameter which is incorrectlyÂ typed that you
    need to fix, or perhaps you need to add additional functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, imagine that you want to tell the printer object to print an entire
    document rather than a page at a time. The way to do this is to derive from the
    interface that needs changing and create a new interface; interface inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Interface inheritance means that `IPrint2` has three methods, `set_page`, `print_page`,
    and `print_doc`. Since the `IPrint2` interface is an `IPrint` interface, this
    means that when you implement the `IPrint2` interface, you also implement the
    `IPrint` interface, so you need to change the class to derive from the `IPrint2`
    interface to add the new functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The other two methods on the `IPrint2` interface already exist on this class
    from the implementation of the `IPrint` interface. Now, a client can obtain both
    `IPrint` pointers and `IPrint2` pointers from instances of this class. You have
    extended the class, and yet the older client code will still compile.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft's **Component Object Model** (**COM**) takes this concept a step further.
    COM is based upon interface programming, so COM objects are only ever accessed
    through interface pointers. The extra step is that this code can be loaded into
    your process using a dynamic loaded library, or in another process on your machine
    or on another machine, and since you use interface programming, the objects are
    accessed in *exactly* the same way regardless of their location.
  prefs: []
  type: TYPE_NORMAL
- en: Class relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inheritance appears to be an ideal way to reuse code: you write it once in
    as generic way possible and then derive a class from the base class and reuse
    the code, specializing it if necessary. You will find, however, a lot of advice
    against this. Some people will tell you that inheritance is the worst way possible
    to reuse code and you should use composition instead. In fact, the situation is
    somewhere between the two: inheritance offers some benefits, but it should not
    be treated as the best or only solution.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to get carried away with designing a class library, and there
    is a general principle to bear in mind: the more code you write, the more maintenance
    you (or someone else) will have to do. If you change a class, all the other classes
    that depend upon it will change.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the highest level, you should be aware of three main issues to avoid:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rigidity**: It is too hard to change a class because any change will affect
    too many other classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fragility**: When you change your class, it could cause unexpected changes
    in other classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Immobility**: It is hard to reuse the class because it is too dependent on
    other classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This occurs when you have tight coupling between classes. In general, you should
    design your classes to avoid this and interface programming is an excellent way
    to do this because an interface is simply a behavior and not an instance of a
    specific class.
  prefs: []
  type: TYPE_NORMAL
- en: Such problems occur when you have *dependency inversion*, that is, higher level
    code, using components, becomes dependent upon the details of how the lower level
    components are implemented. If you have code that performs some action and then
    logs the result if you write that logging to use a specific device (say the `cout`
    object), then the code is rigidly coupled to, and dependent upon, that logging
    device and you have no option in the future to change to another device. If you
    abstract the functionality, typically, through an interface pointer-then you break
    this dependency enabling the code to be used with other components in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Another principle is that in general you should design your classes to be extendable.
    Inheritance is quite a brute force mechanism to extend a class because you are
    creating a whole new type. If the functionality only needs to be refined, then
    inheritance can be an overkill. A more lightweight form of refining an algorithm
    is to pass a method pointer (or a functor), or an interface pointer to the method
    of a class for that method to call at an appropriate time to refine how it works.
  prefs: []
  type: TYPE_NORMAL
- en: For example, most sort algorithms require that you pass a method pointer to
    perform comparisons of two objects of the type that it is sorting. The sort mechanism
    is generic and does the work of ordering the objects in the most efficient manner,
    but it bases this on you telling it how to order the two objects. It is excessive
    to write a new class for every type since the majority of the algorithm remains
    the same.
  prefs: []
  type: TYPE_NORMAL
- en: Using mixin classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **mixin** technique allows you to provide extensibility to classes without
    the lifetime issues of composition or the heavyweight aspect of raw inheritance.
    The idea here is that you have a library with specific functionality that can
    be added to an object. One way to do this is to apply it as a base class with
    `public` methods, and so if the derived class publicly derives from that class,
    it will also have those methods as `public` methods. This works fine unless the
    functionality requires that the derived class performs some functionality too
    in those methods, in which case the documentation of the library will require
    that the derived class overrides the method, calls the base class implementation,
    and adds their own code to the method to complete the implementation (the base
    class method could be called before, or after the extra derived class code, and
    the documentation would have to specify this). We have seen this used several
    times so far in this chapter, and it is a technique used by some older class libraries,
    for example, Microsoft'sÂ **Foundation Classes library** (**MFC**). Visual C++
    makes this easier because it generates MFC code with a wizard tool and there are
    comments about where the developer should add their code.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this approach is that it requires the developer deriving from
    the base class implements specific code and follows the rules.
  prefs: []
  type: TYPE_NORMAL
- en: There is a possibility that the developer will write code that compiles and
    runs, but since it is not written to the desired rules, it has the wrong behavior
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: A mixin class turns this concept on its head. Instead of the developer deriving
    from a base class provided by the library and extending the functionality provided,
    the mixin class provided by the library *is derived from a class provided by the
    developer*. This solves several problems. First, the developer will have to provide
    specific methods as required by the documentation, otherwise the mixin class (which
    will use those methods) will not compile. The compiler is enforcing the rules
    of the class library author to require that the developer using the library provides
    specific code. Second, the methods on the mixin class can call the base class
    methods (provided by the developer) exactly where it needs them. The developer
    using the class library is no longer provided with detailed instructions about
    how their code is developed, other than that, they have to implement certain methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how can this be achieved? The class library author does not know about
    the code that the client developer will write and they do not know about the names
    of the classes a client developer will write, so they cannot derive from such
    classes. C++ allows you to provide a type through a template parameter so that
    the class is instantiated using this type at compile time. With mixin classes,
    the type passed through a template parameter is the name of a type that will be
    used as the base class. The developer simply provides a class with the specific
    methods and then creates a specialization of the mixin class using their class
    as the template parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'This class is used in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `mixin` class implements a method called `something` and
    it calls a base class method called `something`. This means that a client developer
    using the functionality of the mixin class must implement a method with this name
    and with the same prototype, otherwise the mixin class cannot be used. The client
    developer writing the `impl` class does not know how or where their code will
    be used, just that they have to provide methods with specific names and prototypes.
    In this case, the `mixin::something` method calls the base class method in the
    code between the functionality that it provides, the writer of the `impl` class
    does not need to know this. The output of this code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This shows that the `mixin` class can call the `impl` class where it thinks
    is appropriate. The `impl` class only has to provide the functionality; the `mixin`
    class determines how it is used. In fact, any class that implements a method with
    the right name and prototype can be provided as a parameter to the template of
    the `mixin` class-even another mixin class!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be used like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `mixin` and `mixin2` classes know nothing about each other, other
    than the fact that the appropriate methods are implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Since the mixin class cannot be used without the type provided by the template
    parameter, they are sometimes called abstract subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: 'This works fine if the base class only has a default constructor. If the implementation
    requires another constructor, then the mixin must know what constructor to call
    and must have appropriate parameters. Also, if you chain the mixins, then they
    get coupled through the constructors. One way to get around this is to use two
    stage construction, that is, provide a named method (say, `init`) used to initialize
    data members in the object after construction. The mixin classes will still be
    created using their default constructors as earlier, and so there will be no coupling
    between the classes, that is, the `mixin2` class will know nothing about the data
    members of `mixin` or those of `impl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This works because you can call a public base class method as long as you qualify
    the name of the method. The parameter list in these three `init` methods can be
    different. However, this does pose the problem that the client now has to initialize
    all the base classes in the chain.
  prefs: []
  type: TYPE_NORMAL
- en: This is the approach that Microsoft's **ActiveX Template Library** (**ATL**)
    (now part of MFC) uses to provide implementation of standard COM interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Using polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following example, we will create code that simulates a team of C++ developers.
    The code will use interfaces to decouple the classes so that it is possible to
    change the services that a class uses without changing that class. In this simulation,
    we have a manager managing a team, so a property of the manager is their team.
    Further, every worker, whether a manager or a team member have some common properties
    and behaviors--they all have a name and a job position and they all do work of
    some kind.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder for the chapter and in that folder, create a file called `team_builder.cpp`,
    and since this application will use a `vector`, smart pointers, and files, add
    the following lines to the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The application will have command-line parameters, but for the time being,
    just provide an empty copy of the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to define interfaces, so before the `main` function, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'This is just syntactic sugar, but it makes the code a bit more readable to
    show the purpose of the abstract classes. Under this, add the following interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'All the workers will implement the first interface, which gives access to their
    name and job position and a method that tells them to do some work. The two types
    of workers we will define are a manager who manages a team by scheduling their
    time and a developer who writes code. The manager has a `vector` of `IWork*` pointers,
    and since these pointers will be to objects created on the free store, the `vector`
    members are smart pointers wrapping these pointers. This is saying that the manager
    maintains the lifetime of these objects: while the manager object exists; so will
    their team.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first action is to create a helper class that does the basic work of a
    worker. The reason for this will be apparent later in the example. This class
    will implement the `IWork` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'A `worker` object must be created with a name and job position. We will also
    have a helper class for a manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `do_work` method is implemented in terms of the virtual function,
    `manage_team`, which means that a derived class only needs to implement the `manage_team`
    method since it will inherit the `do_work` method from its parent and method dispatching
    will mean the correct method is called. The rest of the class is straightforward,
    but note that the constructor calls the base class constructor to initialize the
    name and job position (a manager is, after all, a worker) and that the `manager`
    class has a function to add items to the team as shared in smart pointers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this out, we need to create a `manager` class that manages developers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'This overrides calls to the base class constructor passing the name of the
    project manager and a literal describing the job. The class also overrides `manage_team`
    to say what the manager actually does. At this point, you should be able to create
    a `project_manager` and add some members to their team (use the `worker` objects,
    you''ll create developers in a moment). Add the following to the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will compile, but there will be no output when it runs, so create
    a method to print out a manager''s team:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'This function shows how useful interfaces are. You can pass any worker to the
    function, and it will print out the information relevant to all workers (name
    and job position). It then asks the object if it is a manager by requesting the
    `IManage` interface. The function can only get the manager behavior (in this case,
    having a team) if the object implements this interface. At the end of the `main`
    function, after the last call to the `program_manager` object, call this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile this code (remember to use the `/EHsc` switch) and run the code. You
    will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will add a level of polymorphism, so add the following classes before
    the `print_team` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'You can change the `main` function so that rather than using `worker` objects,
    you use `cpp_developer` for Bill, Chris, and Dave and `database_admin` for Edith:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: You can now compile and run the code and see that not only can you add different
    types of objects to the manager's team, but you will also get the appropriate
    information printed through the `IWork` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next task is to add code to serialize and deserialize these objects. Serialization
    means writing the object''s state (and type information) to a stream and deserialization
    will take that information and create a new object of the appropriate type and
    with the specified state. To do this, every object must have a constructor that
    takes an interface pointer to a deserialzer object, and the constructor should
    call this interface to extract the state of the object being created. Further,
    such classes should implement a method to serialize and write an object''s state
    to a serializer object. Let''s first look at serialization. At the top of the
    file, add the following interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The forward declaration is needed because the `ISerializer` interface uses the
    `IWork` interface. The first interface, `ISerializer`, is implemented by an object
    that provides serialization services. This could be based on a file, a network
    socket, a database, or whatever you want to use to store the object. The underlying
    storage mechanism is unimportant to the user of this interface; all that is important
    is that the interface can store a string and it can store an entire object passed
    using an `IWork` interface pointer or a collection of such objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The objects that can be serialized must implement the `ISerializable` interface
    and this has a single method that takes an interface pointer to the object that
    will provide the serialization service. After the definition of the interfaces,
    add the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: This class provides the `ISerializer` interface for a file, so the `write_string`
    method uses the `ifstream` insertion operator to write the string on a single
    line in the file. The `write_worker` method writes the worker object to the file.
    To do this, it first asks the worker object if it can serialize itself by casing
    the `IWork` interface an `ISerializable` interface. If the worker object implements
    this interface, the serializer can ask the worker object to serialize itself by
    passing the `ISerializer` interface pointer to the `serialize` method on the worker
    object. It is up to the worker object to determine the information that must be
    serialized. The worker object knows nothing about the `file_writer` class other
    than the `ISerializer` interface, and the `file_writer` class knows nothing about
    the worker object, other than that it implements the `IWork` and `ISerializable`
    interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: If the worker object is serializable, the first thing that the `write_worker`
    method does is obtain type information about the object. The `IWork` interface
    will be on a class (`project_manager`, `cpp_developer`, or `database_admin`) and
    so dereferencing the pointer will give the `typeid` operator access to the class
    type information. We store the raw type name in the serializer because it is compact.
    Once the type information is serialized, we ask the object to serialize itself
    by calling the `serialize` method on its `ISerializable` interface. The worker
    object will store whatever information it wants.
  prefs: []
  type: TYPE_NORMAL
- en: A manager object will need to serialize their team and they do this by passing
    a collection of worker objects to the `write_workers` method. This indicates that
    the objects being serialized are an array by writing them between two markers,
    `[[` and `]]`. Note that because the container has `unique_ptr` objects, there
    is no copy constructor because that would imply shared ownership. So instead,
    we access the items through the index operator, which will give us a reference
    to the `unique_ptr` object within the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, for every class that can be serialized, you must derive the class from
    `ISerializable` and implement the `serialize` method. The class inheritance tree
    means that every class for a type of worker derives from the `worker` class, so
    we only need this class to inherit from the `ISerializable` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The convention is that a class only serializes its own state and delegates
    to its base class to serialize the base class object. At the top of the inheritance
    tree is the `worker` class, so at the bottom of this class, add the following
    interface method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: This simply serializes the name and job position to the serializer. Note that
    the worker object does not know what the serializer will do with this information
    and does not know which class provides the `ISerializer` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of the `cpp_developer` class, add this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: The `cpp_developer` class does not have any additional state, so it delegates
    the serialization to its parent class. If the developer class had a state, then
    it would serialize this state after serializing the base object. Add exactly the
    same code to the bottom of the `database_admin` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `project_manager` class also calls its base class, but this is `manager`,
    so add the following to the bottom of the `project_manager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The `manager::serialize` is more complicated because this class has state that
    should be serialized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The first action is to serialize the base class: a `worker` object. Then the
    code serializes the state of the `manager` object, which means serializing the
    `team` data member by passing this collection to the serializer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to test the serialization, create a method above the `main` method
    and move the `project_manager` code to the new method and add code to serialize
    the objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code creates a `file_writer` object for the specified file, obtains
    the `ISerializer` interface on that object, and then serializes the project manager
    object. If you have other teams, you can serialize them to the file before closing
    the `writer` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main` function will take two parameters. The first is the name of the
    file and the second is a character, `r` or `w` (to read or write the file). Add
    the following code to replace the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now compile this code and run it, giving the name of a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a file called `cpp_team.txt` containing information about
    the team; type it at the command-line with `**type cpp_team.txt**`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: This file is not intended to be read by humans, but as you can see, it has one
    piece of information on each line and each serialized object is preceded by the
    type of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you will write the code to deserialize an object. The code needs a class
    that will read the serialization data and return worker objects. This class is
    tightly coupled to the serializer class, but it should be accessed through an
    interface so that it is not coupled to the worker objects. After the declaration
    of the `ISerializable` interface, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The first method obtains a serialization string and the other two methods obtain
    a single object and a collection of objects. Since these worker objects will be
    created on the free store, these methods use smart pointers. Every class can serialize
    itself, and so now you will make each serializable class able to deserialize itself.
    To do this, for every class that implements `ISerializable`, add a constructor
    that takes an `IDeserializer` interface pointer. Start with the `worker` class;
    add the following public constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Essentially, this reverses what the `serialize` method does, it reads the name
    and position string from the deserializer *in the same order* in which they were
    passed to the serializer. Since the `cpp_developer` and `database_admin` classes
    have no state, they do not need to do any other deserializing work other than
    call the base class constructor. For example, add the following public constructor
    to the `cpp_developer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Add a similar constructor to the `database_admin` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Managers have a state, so thereÂ is a bit more work to deserialize them. Add
    the following to the `manager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'The initializer list constructs the base class and after this is run, the constructor
    initializes the `team` collection with zero or more worker objects by calling
    `read_workers` on the `IDeserializer` interface. Finally, the `project_manager`
    class derives from the `manager` class, but adds no extra state, so add the following
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, every serializable class can deserialize itself, the next action is to
    write the deserializer class that will read a file. After the `file_writer` class,
    add the following (note that two methods are not implemented inline):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor opens the specified file and the destructor closes it. The
    `read_string` interface method reads a line from the file and returns it as a
    string. The main work is carried out in the two interface methods not implemented
    here. The `read_workers` method will read a collection of `IWork` objects and
    put them into the collection passed by reference. This method will call the `read_worker`
    method for every object in the file and put them in the collection, and so the
    main work of reading the file is carried out in this method. The `read_worker`
    method is the only part of the class that has any coupling to the serializable
    classes, and because of this, it has to be defined below the definition of the
    worker classes. Above the `serialize` global function, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: The `read_workers` method will read each object from the file using the `read_worker`
    method, which returns each object in a `unique_ptr` object. We want to put this
    object into the container, but because there should be exclusive ownership of
    the pointer, we need to move the ownership into the object in the container. There
    are two ways to do this. The first way is simply to use the call to `read_worker`
    as the parameter to `push_back`. The `read_worker` method returns a temporary
    object, which is an rvalue, so the compiler will use move semantics when creating
    the object in the container. We do not do this because the `read_worker` method
    may return a `nullptr` (which we want to test for), so instead we create a new
    `unique_ptr` object (move semantics will pass ownership to this object), and once
    we have tested that this object is not a `nullptr`, we call the Standard Library
    function, `move`, to move copy the object into the container.
  prefs: []
  type: TYPE_NORMAL
- en: If the `read_worker` method reads the end marker of an array, it returns a `nullptr`
    and hence the `read_workers` method loops, reading each worker and putting them
    in the collection until a `nullptr` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `read_worker` method like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: The first line reads the type information of the worker object from the file
    so that it knows what object to create. Since the file will have markers to indicate
    the array of team members, the code has to detect these. If the start of the array
    is detected, the marker string is ignored and the next line is read to get the
    type of the first object in the team. If the end marker is read, then this is
    the end of the array so a `nullptr` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for a `worker` object is shown here. The `if` statement tests to check
    whether the type string is the same as the raw name of the `worker` class. If
    it is, then we must create a `worker` object and request that it deserializes
    itself by calling the constructor that takes an `IDeserializer` pointer. The `worker`
    object is created on the free store and the `dynamic_cast` operator is called
    to obtain the `IWork` interface pointer, which is then used to initialize a smart
    pointer object. The constructor for the `unique_ptr` is `explicit`, so you have
    to call it. Now add similar code for all the other serializable classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you need to create a `file_reader` and deserialize a file. After the
    `serialize` function, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'This code simply creates a `file_reader` object based on the file name and
    then reads each worker object from the file printing out the object and, if it
    is a `project_manager`, prints out their team. Finally, add a line in the `main`
    function to call this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can compile the code and use it to read in the serialization file with
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: (Note the `r` parameter.) The code should print out the objects that you serialized
    to the file.
  prefs: []
  type: TYPE_NORMAL
- en: The previous example has shown that you can write serializable objects that
    do not know about the mechanism that is used to serialize them. If you want to
    use a different mechanism than a flat file (for example, an XML file or to a database),
    you do not need to alter any of the worker classes. Instead, you write an appropriate
    class that implements the `ISerializer` interface and the `IDeserailizer` interface.
    If you need to create another worker class, all you need to do is alter the `read_worker`
    method to deserialize objects of that type.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you saw how to use C++ inheritance to reuse code and provide
    an is-a relationship between objects. You also saw how this can be used to implement
    polymorphism, where related objects can be treated as having the same behavior
    while still maintaining the ability to call each object's methods, and interfaces
    that group together behaviors. In the next chapter, you'll see the features of
    the C++ Standard Library and the various utility classes it provides.
  prefs: []
  type: TYPE_NORMAL
