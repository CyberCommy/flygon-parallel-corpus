- en: Signal Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Signals provide a fundamental infrastructure in which any process can be notified
    of a system event asynchronously. They can also be engaged as communication mechanisms
    between processes. Understanding how the kernel provides and manages smooth throughput
    of the entire signal-handling mechanism lets us gain more grounding on the kernel.
    In this chapter, we shall pile on our understanding of signals, right from how
    processes can usher them to how the kernel deftly manages the routines to ensure
    signal events tick. We shall look at the following topics in great detail:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of signals and their types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process-level signal-management calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signal data structures in process descriptors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kernel's signal generation and delivery mechanisms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Signals** are short messages delivered to a process or a process group. The
    kernel uses signals to notify processes about the occurrence of a system event;
    signals are also used for communication between processes. Linux categorizes signals
    into two groups, namely general-purpose POSIX (classic Unix signals) and real-time
    signals. Each group consists of 32 distinct signals, identified by a unique ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Signals in the general-purpose category are bound to a specific system event
    and are named appropriately through macros. Those in the real-time category aren''t
    bound to a specific event, and are free for applications to engage for process
    communication; the kernel refers to them with generic names: `SIGRTMIN` and `SIGRTMAX`.'
  prefs: []
  type: TYPE_NORMAL
- en: Upon generation of a signal, the kernel delivers the signal event to the destination
    process, which in turn can respond to the signal as per the configured action,
    called **signal disposition**.
  prefs: []
  type: TYPE_NORMAL
- en: The following is the list of actions that a process can set up as its signal
    disposition. A process can set up any one of the actions as its signal disposition
    at a point in time, but it can switch between these actions any number of times
    without any restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Kernel handler**: The kernel implements a default handler for each signal.
    These handlers are available to a process through the signal handler table of
    its task structure. Upon reception of a signal, a process can request execution
    of the appropriate signal handler. This is the default disposition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Process defined handler:** A process is allowed to implement its own signal
    handlers, and set them up to be executed in response to a signal event. This is
    made possible through the appropriate system call interface, which allows the
    process to bind its handler routine with a signal. On occurrence of a signal,
    the process handler would be invoked asynchronously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ignore:** A process is also allowed to ignore the occurrence of a signal,
    but it needs to announce its intent to ignore by invoking the appropriate system
    call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kernel-defined default handler routines can execute any of the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ignore**: Nothing happens.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Terminate**: Kill the process, that is, all threads in the group (similar
    to `exit_group`). The group leader (only) reports the `WIFSIGNALED` status to
    its parent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Coredump**: Write a core dump file describing all threads using the same
    `mm` and then kill all those threads'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stop**: Stop all the threads in the group, that is, the `TASK_STOPPED` state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Following is the summarized table that lists out actions executed by default
    handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Signal-management APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Applications are provided with various APIs for managing signals; we shall
    take a look at few of the important ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Sigaction()`: User-mode processes use the POSIX API `sigaction()` to examine
    or change the disposition of a signal. This API provides a variety of attribute
    flags that can further define the behavior of a signal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`int signum` is the identifier number of a recognized `signal`. `sigaction()`
    examines and sets the action to be associated with this signal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const struct sigaction *act` can be assigned with the address of a `struct
    sigaction` instance. The action specified in this structure becomes the new action
    bound to the signal. When the *act* pointer is left uninitialized (NULL), the
    current disposition is left unchanged.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`struct sigaction *oldact` is an outparam and needs to be initialized with
    the address of an uninitialized `sigaction` instance; `sigaction()` returns the
    action currently associated with the signal through this argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Following are the various `flag` options:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SA_NOCLDSTOP`: This flag is relevant only while binding the handler for `SIGCHLD`.
    It''s used to disable `SIGCHLD` notifications for stop (`SIGSTP`) and resume (`SIGCONT`)
    events on the child process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SA_NOCLDWAIT`: This flag is relevant only while binding the handler for the
    `SIGCHLD` or setting its disposition to `SIG_DFL`. Setting this flag causes the
    child process to be instantly destroyed on termination rather than having it in
    a *zombie* state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SA_NODEFER`: Setting this flag causes the generated signal to be delivered
    even if the corresponding handler is in execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SA_ONSTACK`: This flag is relevant only while binding a signal handler. Setting
    this flag causes the signal handler to use an alternate stack; the alternate stack
    must be set up by the caller process through the `sigaltstack()` API. In the absence
    of an alternate stack, the handler will be invoked on the current stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SA_RESETHAND`: When this flag is applied with `sigaction()`, it makes the
    signal handler one-shot, that is, the action for the specified signal is reset
    to `SIG_DFL` for subsequent occurrences of this signal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SA_RESTART`: This flag enables the re-entry of system call operations, interrupted
    by the current signal handler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SA_SIGINFO`: This flag is used to indicate to the system that the signal handler
    is assigned--the `sa_sigaction` pointer of the `sigaction` structure instead of
    `sa_handler`. Handlers assigned to `sa_sigaction` receive two additional arguments:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The first argument is `signum`, to which the handler is bound. The second argument
    is an outparam that is a pointer to an object of type `siginfo_t`, which provides
    additional information about the source of the signal. Following is the full definition
    of `siginfo_t`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`Sigprocmask()`: Apart from changing the signal disposition, which specifies
    the action to be executed on receipt of a signal, applications are also allowed
    to block or unblock signal delivery. Applications might need to carry out such
    operations while executing critical code blocks without preemption by an asynchronous
    signal handler. For instance, a network communication application might not want
    to handle signals while entering a code block that initiates a connection with
    its peers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sigprocmask()` is a POSIX API, used to examine, block, and unblock signals.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Any occurrence of blocked signals is queued in a per-process pending signals
    list. The pending queue is designed to hold one occurrence of a blocked general-purpose
    signal while it queues every occurrence of a real-time signal. User-mode processes
    can probe for pending signals using the `sigpending()` and `rt_sigpending()` APIs.
    These routines return a list of pending signals into an instance pointed to by
    the `sigset_t` pointer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The operations are applicable for all signals except `SIGKILL` and `SIGSTOP`;
    in other words, processes are not allowed to alter the default disposition or
    block `SIGSTOP` and `SIGKILL` signals.
  prefs: []
  type: TYPE_NORMAL
- en: Raising signals from a program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`kill()` and `sigqueue()` are POSIX APIs through which a process can raise
    a signal for another process or process group. These APIs facilitate utilization
    of signals as **process-communication** mechanisms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'While both APIs provide arguments to specify the receiver `PID` and `signum`
    to be raised, `sigqueue()` provides an additional argument (union signal) through
    which *data* can be sent to the receiver process along with the signal. The destination
    process can access the data through `struct siginfo_t` (`si_value`) instances.
    Linux extends these functions with native APIs that can queue the signal to a
    thread group, or even to a lightweight process (LWP) in a thread group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Waiting for queued signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When applying signals for process communication, it might be more appropriate
    for a process to suspend itself until the occurrence of a specific signal, and
    resume execution on the arrival of a signal from another process. The POSIX calls
    `sigsuspend()`, `sigwaitinfo()`, and `sigtimedwait()` provide this functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'While all of these APIs allow a process to wait for a specified signal to occur,
    `sigwaitinfo()` provides additional data about the signal through the `siginfo_t`
    instance returned through the `info` pointer. `sigtimedwait()` extends the functionality
    by providing an additional argument that allows the operation to time out, making
    it a bounded wait call. The Linux kernel provides an alternate API that allows
    the process to be notified about the occurrence of a signal through a special
    file descriptor called `signalfd()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: On success, `signalfd()` returns a file descriptor, on which the process needs
    to invoke `read()`, which blocks until any of the signals specified in the mask
    occur.
  prefs: []
  type: TYPE_NORMAL
- en: Signal data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The kernel maintains per-process signal data structures to keep track of, *signal
    disposition,* *blocked signals*, and *pending signal queues*. The process task
    structure contains appropriate references to these data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Signal descriptors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recall from our earlier discussions in the first chapter that Linux supports
    multi-threaded applications through lightweight processes. All LWPs of a threaded
    application are part of a *process group* and share signal handlers; each LWP
    (thread) maintains its own pending, and blocked signal queues.
  prefs: []
  type: TYPE_NORMAL
- en: The **signal** pointer of the task structure refers to the instance of type
    `signal_struct`, which is the signal descriptor. This structure is shared by all
    LWPs of a thread group and maintains elements such as a shared pending signal
    queue (for signals queued to a thread group), which is common to all threads in
    a process group.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure represents the data structures involved in maintaining
    shared pending signals:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Following are a few important fields of `signal_struct`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Blocked and pending queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`blocked` and `real_blocked` instances in the task structure are bit masks
    of blocked signals; these queues are per-process. Each LWP in a thread group thus
    has its own blocked signal mask. The `pending` instance of the task structure
    is used to queue private pending signals; all signals queued to a normal process
    and a specific LWP in a thread group are queued into this list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure represents the data structures involved in maintaining
    private pending signals:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Signal handler descriptor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `sighand` pointer of the task structure refers to an instance of the struct
    `sighand_struct`, which is the signal handler descriptor shared by all processes
    in a thread group. This structure is also shared by all processes created using
    `clone()` with the `CLONE_SIGHAND` flag. This structure holds an array of `k_sigaction`
    instances, each wrapping an instance of `sigaction` that describes the current
    disposition of each signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure represents the signal handler descriptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Signal generation and delivery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A signal is said to be **generated** when its occurrence is enqueued, to list
    of pending signals in the task structure of the receiver process or processes.
    The signal is generated (on a process or a group) upon request from a user-mode
    process, kernel, or any of the kernel services. A signal is considered to be **delivered**
    when the receiver process or processes are made aware of its occurrence and are
    forced to execute the appropriate response handler; in other words, signal delivery
    is equal to initialization of the corresponding handler. Ideally, every signal
    generated is assumed to be instantly delivered; however, there is a possibility
    of delay between signal generation, and it eventual delivery. To facilitate possible
    deferred delivery, the kernel provides separate functions for signal generation
    and delivery.
  prefs: []
  type: TYPE_NORMAL
- en: Signal-generation calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The kernel provides two separate group of functions for signal generation:
    one set for generating signals on individual process and another for process thread
    groups.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the list of important functions to generate signals on a process:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`send_sig()`: Generates a specified signal on a process; this function is used
    widely by kernel services'
  prefs: []
  type: TYPE_NORMAL
- en: '`end_sig_info()`: Extends `send_sig()` with additional `siginfo_t` instances'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`force_sig()`: Used to generate priority non-maskable signals which cannot
    be ignored or blocked'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`force_sig_info()`: Extends `force_sig()` with additional `siginfo_t` instances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these routines eventually invoke the core kernel function `send_signal()`
    which is programmed to generate a specified signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the list of important functions to generate signals on a process
    group:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kill_pgrp()`: Generates the specified signal on all thread groups in a process
    group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kill_pid()`: Generates the specified signal to a thread group identified by
    a PID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kill_pid_info()`: Extends `kill_pid()` with additional *`siginfo_t`* instances'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these routines invoke a function `group_send_sig_info()` which eventually
    invokes `send_signal()` with appropriate parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `send_signal()` function is the core signal-generation function; it invokes
    the `__send_signal()` routine with appropriate arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Following are important steps executed by `__send_signal()`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check for the source of the signal from the `info` argument. If signal generation
    was initiated by the kernel for non-maskable `SIGKILL` or `SIGSTOP`, it immediately
    sets the appropriate bit of the sigpending bitmask, sets the `TIF_SIGPENDING`
    flag, and initiates the delivery process by waking up the target thread:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoke the `__sigqeueue_alloc()` function, which checks if the number of pending
    signals for the receiver process is less than the resource limit. If true, it
    increments the pending signal counter and returns the address of the `struct sigqueue`
    instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Enqueue the `sigqueue` instance into the pending list and fill out the signal
    information into `siginfo_t`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the appropriate signal bit in the pending signal''s bitmask, and attempt
    signal delivery by invoking `complete_signal(),` which in turn sets the `TIF_SIGPENDING`
    flag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Signal delivery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After a signal is **generated** by updating appropriate entries in the receiver's
    task structure, through any of the previously mentioned signal-generation calls,
    the kernel moves into delivery mode. The signal is instantly delivered if the
    receiver process was on CPU and has not blocked the specified signal. Priority
    signals `SIGSTOP` and `SIGKILL` are delivered even if the receiver is not on CPU
    by waking up the process; however, for the rest of the signals, **delivery** is
    deferred until the process is ready to receive signals. To facilitate deferred
    delivery, the kernel checks for nonblocked pending signals of a process on return
    from **interrupt** and **system calls** before allowing a process to resume user-mode
    execution. When the process scheduler (invoked on return from interrupt and exceptions)
    finds the `TIF_SIGPENDING` flag set, it invokes the kernel function `do_signal()`
    to initiate delivery of the pending signal before resuming the user-mode context
    of the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon entry into kernel mode, the user-mode register state of the process is
    stored in the process kernel stack in a structure called `pt_regs` (architecture
    specific):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `do_signal()` routine is invoked with the address of `pt_regs` in the kernel
    stack. Though `do_signal()` is meant to deliver nonblocked pending signals, its
    implementation is architecture specific.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the x86 version of `do_signal()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`do_signal()` invokes the `get_signal()` function with the address of an instance
    of type `struct ksignal` (we shall briefly consider important steps of this routine,
    skipping other details). This function contains a loop that invokes `dequeue_signal()`
    until all non-blocked pending signals from both private and shared pending lists
    are dequeued. It begins with lookup into the private pending signal queue, starting
    from the lowest-numbered signal, and follows into pending signals in the shared
    queue, and then updates the data structures to indicate that the signal is no
    longer pending and returns its number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'For each pending signal returned by `dequeue_signal())`, `get_signal()` retrieves
    the current signal disposition through a pointer of type `struct ksigaction *ka`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If signal disposition is set to `SIG_IGN`, it silently ignores the current
    signal and continues iteration to retrieve another pending signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If disposition is not equal to `SIG_DFL`, it retrieves the address of **sigaction**
    and initializes it into arguments `ksig->ka` for further execution of the user-mode
    handler. It further checks for the `SA_ONESHOT (SA_RESETHAND)` flag in the user's
    **sigaction** and, if set, resets the signal disposition to `SIG_DFL`, breaks
    out of the loop, and returns to the caller. `do_signal()` now invokes the `handle_signal()`
    routine to execute the user-mode handler (we shall discuss this in detail in the
    next section).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If disposition is set to `SIG_DFL`, it invokes a set of macros to check for
    the **default action** of the kernel handler. Possible default actions are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Term**: Default action is to terminate the process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ign**: Default action is to ignore the signal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Core**: Default action is to terminate the process and dump core'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stop**: Default action is to stop the process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cont**: Default action is to continue the process if it is currently stopped'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: First, the macro `sig_kernel_ignore` checks for the default action ignore. If
    true, it continues loop iteration to look for the next pending signal. The second
    macro `sig_kernel_stop` checks for the default action stop; if true, it invokes
    the `do_signal_stop()` routine, which puts each thread in the process group into
    the `TASK_STOPPED`state. The third macro `sig_kernel_coredump` checks for the
    default action dump; if true, it invokes the `do_coredump()` routine, which generates
    the coredump binary file and terminates all the processes in the thread group.
    Next, for signals with default action terminate, all threads in the group are
    killed by invoking the `do_group_exit()` routine.
  prefs: []
  type: TYPE_NORMAL
- en: Executing user-mode handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recall from our discussion in the previous section that `do_signal()` invokes
    the `handle_signal()` routine for delivery of pending signals whose disposition
    is set to user handler. The user-mode signal handler resides in the process code
    segment and requires access to the user-mode stack of the process; therefore,
    the kernel needs to switch to the user-mode stack for executing the signal handler.
    Successful return from the signal handler requires a switch back to the kernel
    stack to restore the user context for normal user-mode execution, but such an
    operation would fail since the kernel stack would no longer contain the user context
    (`struct pt_regs`) since it is emptied on each entry of the process from user
    to kernel mode.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure smooth transition of the process for its normal execution in user
    mode (on return from the signal handler), `handle_signal()` moves the user-mode
    hardware context (`struct pt_regs`) in the kernel stack into the user-mode stack
    (`struct ucontext`) and sets up the handler frame to invoke the `_kernel_rt_sigreturn()`
    routine during return; this function copies the hardware context back into the
    kernel stack and restores the user-mode context for resuming normal execution
    of the current process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure depicts the execution of a user-mode signal handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Setting up user-mode handler frames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To set up a stack frame for a user-mode handler, `handle_signal()` invokes `setup_rt_frame()`
    with the address of the instance of `ksignal`, which contains the `k_sigaction`
    associated with the signal and the pointer to `struct pt_regs` in the kernel stack
    of the current process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is x86 implementation of `setup_rt_frame()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'It checks for the specific variant of x86 and invokes the appropriate frame
    setup routine. For further discussion, we shall focus on `__setup_rt_frame()`,
    which applies for x86-64\. This function populates an instance of a structure
    called `struct rt_sigframe` with information needed to handle the signal, sets
    up a return path (through the `_kernel_rt_sigreturn()` function), and pushes it
    into the user-mode stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `*pretcode` field of the `rt_sigframe` structure is assigned the return
    address of the signal-handler function, which is the `_kernel_rt_sigreturn()`
    routine. `struct ucontext uc` is initialized with `sigcontext`, which contains
    the user-mode context copied from `pt_regs` of the kernel stack, bit array of
    regular blocked signals, and floating point state. After setting up and pushing
    the `frame` instance to the user-mode stack, `__setup_rt_frame()` alters `pt_regs`
    of the process in the kernel stack to hand over control to the signal handler
    when the current process resumes execution. The **instruction pointer (ip)** is
    set to the base address of the signal handler and the **stack** **pointer (sp)**
    is set to the top address of the frame pushed earlier; these changes cause the
    signal handler to execute.
  prefs: []
  type: TYPE_NORMAL
- en: Restarting interrupted system calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We understood in [Chapter 1](part0020.html#J2B80-7300e3ede2f245b0b80e1b18d02a323f),
    *Comprehending Processes, Address Space, and Threads* that user-mode processes
    invoke *system calls* to switch into kernel mode for executing kernel services.
    When a process enters a kernel service routine, there is a possibility of the
    routine being blocked for availability of resources (for example, wait on exclusion
    lock) or occurrence of an event (such as interrupts). Such blocking operations
    require the caller process to be put into the `TASK_INTERRUPTIBLE,` `TASK_UNINTERRUPTIBLE`,
    *or* `TASK_KILLABLE` state. The specific state effected depends on the choice
    of blocking call invoked in the system calls.
  prefs: []
  type: TYPE_NORMAL
- en: If the caller task is put into the `TASK_UNINTERRUPTIBLE` state, occurrences
    of signals on that task are generated, causing them to enter the pending list,
    and are delivered to the process only after completion of the service routine
    (on its return path to user mode). However, if the task was put into the `TASK_INTERRUPTIBLE`
    state, occurrences of signals on that task are generated and an immediate delivery
    is attempted by altering its state to `TASK_RUNNING`, which causes the task to
    wake up on a blocked system call even before the system call is completed (resulting
    in the system call operation to fail). Such interruptions are indicated by returning
    the appropriate failure code. The effect of signals on a task in the `TASK_KILLABLE`
    state is similar to `TASK_INTERRUPTIBLE`, except that wake-up is only effected
    on occurrence of the fatal `SIGKILL` signal.
  prefs: []
  type: TYPE_NORMAL
- en: '`EINTR`*,* `ERESTARTNOHAND`*,* `ERESTART_RESTARTBLOCK`*,* `ERESTARTSYS`, or
    `ERESTARTNOINTR` are various kernel-defined failure codes; system calls are programmed
    to return appropriate error flags on failure. Choice of error code determines
    whether failed system call operations are restarted after the interrupting signal
    is handled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'On return from an interrupted system call, the user-mode API always returns
    the `EINTR` error code, irrespective of the specific error code returned by the
    underlying kernel service routine. The remaining error codes are used by the signal-delivery
    routines of the kernel to determine whether interrupted system calls can be restarted
    on return from the signal handler.The following table shows the error codes for
    when system call execution gets interrupted and the effect it has for various
    signal dispositions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is what they mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '**No Restart**: The system call will not be restarted. The process will resume
    execution in user mode from the instruction that follows the system call (int
    $0x80 or sysenter).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Auto Restart**: The kernel forces the user process to re-initiate the system
    call operation by loading the corresponding syscall identifier into *eax* and
    executing the syscall instruction (int $0x80 or sysenter).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Explicit Restart**: The system call is restarted only if the process has
    enabled the `SA_RESTART` flag while setting up the handler (through sigaction)
    for the interrupting signal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Signals, though a rudimentary form of communication engaged by processes and
    kernel services, provide an easy and effective way to get asynchronous responses
    from a running process on occurrence of various events. By understanding all core
    aspects of signal usage, their representation, data structures and kernel routines
    for signal generation and delivery, we are now more kernel aware and also better
    prepared to look at more sophisticated means of communication between processes,
    in a later part of this book. After having spent the first three chapters on processes
    and their related aspects, we shall now delve into other subsystems of the kernel
    to notch up our visibility. In the next chapter, we will build our understanding
    of one of the core aspects of the kernel, the memory subsystem.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the next chapter, we will go through comprehending step by step many
    critical aspects of memory management such as memory initialization, paging and
    protection, and kernel memory allocation algorithms, among others.
  prefs: []
  type: TYPE_NORMAL
