- en: '*Chapter 3*: Building a Slider Puzzle Game with Tests'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：使用测试构建滑块拼图游戏'
- en: In the previous chapter, we created a simple GitHub app with Vue that had some
    components added to it. In this chapter, we will build a simple slider puzzle
    game. The game's goal is to rearrange parts of a picture till it looks like what
    we expect. It will have a timer to calculate the elapsed time and will display
    it on the screen. Once we rearrange the image's parts correctly, we will see a
    **'You Win'** message, and the elapsed time will be recorded in local storage
    if it is in the top 10 fastest times. We have multiple puzzles that we can choose
    from so that we can have more variety in our game. This makes it more interesting
    than just having one puzzle.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用Vue创建了一个简单的GitHub应用，并添加了一些组件。在本章中，我们将构建一个简单的滑块拼图游戏。游戏的目标是重新排列图片的部分，直到它看起来像我们期望的样子。它将有一个计时器来计算经过的时间，并在屏幕上显示出来。一旦我们正确地重新排列了图像的部分，我们将看到一个“你赢了”的消息，并且如果它是前10名最快的时间，经过的时间将被记录在本地存储中。我们有多个拼图可以选择，这样我们的游戏就会更加有趣。这比只有一个拼图更有趣。
- en: To build the apps, we will build components with computed properties and timers
    to calculate the elapsed time. Also, some components will get and set data from
    local storage. Whenever we get data from local storage, the results will be displayed.
    We will use local storage to store the fastest times. Local storage can only store
    strings, so we will convert the result into a string and store it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建应用程序，我们将构建具有计算属性和计时器的组件来计算经过的时间。此外，一些组件将从本地存储中获取和设置数据。每当我们从本地存储中获取数据时，结果将被显示出来。我们将使用本地存储来存储最快的时间。本地存储只能存储字符串，因此我们将把结果转换为字符串并存储起来。
- en: We will use a timer to time when the player wins the game, and we will use computed
    properties to determine when the player wins the game. Also, to make sure that
    our game works like it should, we will add unit tests for each part to test each
    component automatically.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用计时器来计时玩家赢得游戏的时间，并使用计算属性来确定玩家赢得游戏的时间。此外，为了确保我们的游戏能够正常运行，我们将为每个部分添加单元测试，以自动测试每个组件。
- en: 'In this chapter, we will dig deeper into components and cover the following
    topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入研究组件，并涵盖以下主题：
- en: Understanding the basics of components and mixins
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解组件和混合的基础知识
- en: Setting up our Vue project
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置我们的Vue项目
- en: Creating the components for shuffling pictures
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用于洗牌图片的组件
- en: Letting users rearrange the slides
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让用户重新排列幻灯片
- en: Calculating the score based on timing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据时间计算得分
- en: Unit testing with Jest
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jest进行单元测试
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The source code for this chapter is located at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter03](https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter03).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码位于[https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter03](https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter03)。
- en: Understanding the basics of components and mixins
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解组件和混合的基础知识
- en: There is more to components than what we did in [*Chapter 2*](B14405_02_ePub_RK.xhtml#_idTextAnchor023),
    *Building a Vue 3 Progressive Web App*, to create the GitHub progress web app.
    These components were the most basic parts. We will use timers with our components,
    rather than just having components that get data and display it. Also, we will
    look at when and how to use computed properties so that we can create reactive
    properties that have values that are derived from other reactive properties. This
    saves us from creating extra methods that we don't need or using directives unnecessarily.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 组件还有比我们在[*第2章*](B14405_02_ePub_RK.xhtml#_idTextAnchor023)中所做的更多，*构建一个 Vue 3
    渐进式 Web 应用*，来创建 GitHub 渐进式 Web 应用。这些组件是最基本的部分。我们将在我们的组件中使用定时器，而不仅仅是获取数据并显示它的组件。此外，我们将看看何时以及如何使用计算属性，以便我们可以创建从其他响应式属性派生值的响应式属性。这样可以避免创建我们不需要的额外方法或不必要地使用指令。
- en: Furthermore, we will look at how to use computed properties to return values
    that are derived from other reactive properties. **Computed properties** are methods
    that return values that are derived from one or more other reactive properties.
    They are reactive properties themselves. The most common usage for them is getters.
    However, computed properties can have both getters and setters. Their return values
    are cached so that they don't run until one or more reactive properties have their
    values updated. They are useful for replacing complex template expressions and
    methods in an efficient manner.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将看看如何使用计算属性来返回从其他响应式属性派生的值。**计算属性**是返回值的方法，这些值是从一个或多个其他响应式属性派生而来的。它们本身也是响应式属性。它们最常见的用法是作为getter。然而，计算属性既可以有getter也可以有setter。它们的返回值被缓存，以便在一个或多个响应式属性的值更新之前不会运行。它们可用于以高效的方式替换复杂的模板表达式和方法。
- en: Another thing that components can do is emit custom events. An event can contain
    one or more payloads emitted with the event. They have their own event name, and
    we can listen to the events by listening to the event with the `v-on` directive.
    We can get the emitted payload with the `$event` variable or the parameters of
    the event handler methods.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 组件还可以发出自定义事件。一个事件可以包含一个或多个与事件一起发出的有效负载。它们有自己的事件名称，我们可以通过使用`v-on`指令来监听事件。我们可以使用`$event`变量或事件处理程序方法的参数来获取发出的有效负载。
- en: Another important part of a Vue 3 app is **tests**. When we mention tests, they
    are usually automated tests. Tests come in many forms and are useful for catching
    various kinds of bugs. They are often used for catching regressions, which are
    bugs that are created after we change the code that is already part of our app.
    We can check for regressions with a few kinds of tests. The smallest tests we
    can create are **unit tests**, which test a component and its parts in isolation.
    It works by mounting our component in a test environment. Any dependencies that
    prevent our tests from running in isolation are mocked so that we can run our
    tests in isolation. This way, we can run our tests in any environment and in any
    order.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 3 应用的另一个重要部分是**测试**。当我们提到测试时，通常是指自动化测试。测试有许多形式，对捕捉各种类型的错误都很有用。它们经常用于捕捉回归，即在我们更改已经成为应用一部分的代码后创建的错误。我们可以通过几种测试来检查回归。我们可以创建的最小测试是**单元测试**，它测试一个组件及其部分的隔离。它通过在测试环境中挂载我们的组件来工作。任何阻止我们的测试隔离运行的依赖项都被模拟，以便我们可以在隔离环境中运行我们的测试。这样，我们可以在任何环境和任何顺序下运行我们的测试。
- en: Each test is independent, so we shouldn't have any issues running them anywhere,
    even without an internet connection. This is important because they are supposed
    to be portable. Also, external resources such as API data and timers are very
    volatile. They are also asynchronous, which makes them hard to test. Therefore,
    we must make sure that we don't need them for our tests since we want consistency
    in the results.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Vue comes with support for JavaScript test frameworks such as **Jest** and **Mocha**.
    This is one of the great benefits of using the Vue CLI to create our Vue project.
    We don't have to create all the scaffolding of the test code ourselves.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Another kind of test is *end-to-end* tests. These tests simulate how a user
    would use our app. We usually have an environment that is created from scratch
    and then taken down to run these tests. This is because we want fresh data in
    our tests at all times. The tests must be able to run in a consistent manner.
    We need consistent data for this to be done if we are going to use the app like
    the user.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will mainly look at unit tests for our frontend app. They
    can provide DOM interactions like we do with end-to-end tests, but they are faster
    and a lot smaller. They also run a lot faster since we don't have to create a
    clean environment each time a test is run. The environment's creation and user
    interaction tests will always be slower than unit tests. Therefore, we should
    have many unit tests and a few end-to-end tests for testing the most critical
    parts of our app.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Vue project
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've learned the basics about computed properties and getters and
    setters, we are ready to look deeper at the component parts that we will need
    and create the project.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the project, we use the Vue CLI again. This time, instead of selecting
    the default options, we must choose a few options. But before we do that, we will
    create a project folder called `vue-example-ch3-slider-puzzle`. Then, we must
    go into the folder and run the following commands with `npm`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must install the Vue CLI globally so that we can create and run our
    project with it:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we can go into our project folder and run the following command to create
    our project:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Equivalently, we can run the following commands with Yarn:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must install the Vue CLI globally so that we can create and run our
    project with it:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, we can go into our project folder and run the following command to create
    our project:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In either case, we should see the Vue CLI command-line program with instructions
    on how to choose the items. If we are asked if we want to create the project in
    the current folder, we can type *Y* and press *Enter* to do so. Then, we should
    see the project types that we can create our project with. We should choose `Manually
    select features`, and then `Vue 3` to create a Vue 3 project:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种情况，我们都应该看到Vue CLI命令行程序并获得如何选择项目的说明。如果我们被问及是否要在当前文件夹中创建项目，我们可以输入*Y*并按*Enter*来执行。然后，我们应该看到我们可以使用的项目类型，我们应该选择`Manually
    select features`，然后选择`Vue 3`来创建一个Vue 3项目：
- en: '![Figure 3.1 – Selecting the project type to create in the Vue CLI wizard'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1 - 在Vue CLI向导中创建项目类型的选择'
- en: '](image/Figure_3.1_B14405.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.1_B14405.jpg)'
- en: Figure 3.1 – Selecting the project type to create in the Vue CLI wizard
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 - 在Vue CLI向导中创建项目类型的选择
- en: On the next screen, we should see what we can add to the project. Choose `Unit`
    `Testing,` and then you need to choose `Testing` `with` `Jest` so that we can
    add tests to our app.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个屏幕上，我们应该看到我们可以添加到项目中的内容。选择`Unit` `Testing`，然后您需要选择`Testing` `with` `Jest`，这样我们就可以为我们的应用程序添加测试。
- en: 'This project will come with tests for many components once we''ve finished
    writing the code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了编写代码，这个项目将为许多组件提供测试：
- en: '![Figure 3.2 – The options we should choose for this project'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.2 - 我们应该为这个项目选择的选项'
- en: '](image/Figure_3.2_B14405.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.2_B14405.jpg)'
- en: Figure 3.2 – The options we should choose for this project
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 - 我们应该为这个项目选择的选项
- en: Once we let the Vue CLI finish creating the project, we should see the code
    files in the `src` folder. The tests should be in the `tests/unit` folder. The
    Vue CLI saved us lots of effort from creating the test code all by ourselves.
    It comes with an example test that we can expand from.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们让Vue CLI完成项目的创建，我们应该在`src`文件夹中看到代码文件。测试应该在`tests/unit`文件夹中。Vue CLI为我们节省了大量精力，因为我们不需要自己编写测试代码。它带有一个我们可以扩展的示例测试。
- en: 'Once we''ve picked these options, we can start creating our app. In this project,
    we will get some pictures from Unsplash, which provides us with royalty-free images.
    Then, we will get the images and cut them up into nine pieces so that we can display
    them in the `slider puzzle` component. We need both the whole image and the cut
    pieces. For this example, we will get the images from the following links:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们选择了这些选项，我们就可以开始创建我们的应用程序。在这个项目中，我们将从Unsplash获取一些图片，该网站为我们提供了免版税的图片。然后，我们将获取这些图片并将它们分成九个部分，以便我们可以在`slider
    puzzle`组件中显示它们。我们需要整张图片和切割后的部分。在这个例子中，我们将从以下链接获取图片：
- en: '[https://unsplash.com/photos/EfhCUc_fjrU](https://unsplash.com/photos/EfhCUc_fjrU)'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://unsplash.com/photos/EfhCUc_fjrU](https://unsplash.com/photos/EfhCUc_fjrU)'
- en: '[https://unsplash.com/photos/CTvtrspsPQs](https://unsplash.com/photos/CTvtrspsPQs)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://unsplash.com/photos/CTvtrspsPQs](https://unsplash.com/photos/CTvtrspsPQs)'
- en: '[https://unsplash.com/photos/XoCyW2JVmiE](https://unsplash.com/photos/XoCyW2JVmiE)'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://unsplash.com/photos/XoCyW2JVmiE](https://unsplash.com/photos/XoCyW2JVmiE)'
- en: When we go to each page, we must click the **Download** button to download the
    images. Once we've downloaded the images, we must go to [https://www.imgonline.com.ua/eng/cut-photo-into-pieces.php](https://www.imgonline.com.ua/eng/cut-photo-into-pieces.php)
    to cut the images into nine pieces automatically.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进入每个页面时，我们必须点击**下载**按钮来下载图片。一旦我们下载了图片，我们必须转到[https://www.imgonline.com.ua/eng/cut-photo-into-pieces.php](https://www.imgonline.com.ua/eng/cut-photo-into-pieces.php)自动将图片切成九块。
- en: In *section 1*, we select our image file. In *section 2*, we set both **Parts
    in width** and **Parts in height** to `3`. This way, we can divide our image into
    nine pieces. Once we have done that, we can download the ZIP file that is generated
    and then extract all the images into a folder. This should be repeated for each
    image.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Once we have all the whole and cut image pieces, we should put them all into
    the `src/assets` folder of Vue 3 project folder that we just created. This way,
    we can access the images from our app and display them. The first image shows
    a pink flower, so the whole image is named `pink.jpg` and the cut images are in
    the `cut-pink` folder. The filenames that are generated for the cut images remain
    unchanged. The second image is a purple flower, so the whole image is named `purple.jpg`
    and the cut image folder is named `cut-purple`. The third image is a red flower.
    So, it is named `red.jpg` and the folder containing the cut pieces of the image
    is named `cut-red`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have taken care of the images, we can create our components.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: First, we must remove `HelloWorld.vue` from the `src/components` folder since
    we don't need it anymore. We must also remove any reference to it from the `App.vue`
    file.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in the `components` folder, we must create the `Puzzles.vue` file to
    let us select the puzzle. It has a template so that we can display the puzzles
    we select. In the `component options` object, we have an array that contains the
    puzzles data to display. Also, we have a method that lets us emit the event to
    our parent component, which is the `App.vue` component. This way, we can display
    the right puzzle in the slider puzzle component that we will create. To do that,
    in `src/components/Puzzles.vue`, we must add the following template code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, we must add the following script and style tags:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the `component options` object, we have the `data()` method, with the puzzle's
    reactive property between the script tags. It has an array of objects with the
    `id`, `image`, and `title` properties. The `id` property is a unique ID that we
    use when we render the entries with the `v-for` directive. We also emit the ID
    to `App.vue` so that we can pass it to our slide puzzle component from there as
    a prop. `title` is the title we display on the template in a human - readable
    way.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: In the `methods` property, we have a `selectPuzzle()` method that takes the
    puzzle object. It calls `this.$emit` to emit the puzzle-changed event. The first
    argument is `name`. The second argument is the `payload` property that we want
    to emit in the event. We can listen to the event in the parent component by adding
    a `v-on` directive to the element wherever this component is referenced.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在`methods`属性中，我们有一个`selectPuzzle()`方法，它接受谜题对象作为参数。它调用`this.$emit`来触发puzzle-changed事件。第一个参数是`name`。第二个参数是我们想要在事件中触发的`payload`属性。我们可以通过在父组件中为元素添加`v-on`指令来监听事件，无论这个组件在哪里被引用。
- en: In the template, we have the `title` displayed with the `h1` component. The
    `v-for` directive loops through the items in the puzzle's `array` reactive property
    and displays them. As usual, we need the `key` prop for each entry to be set to
    a unique ID for Vue 3 to properly keep track of the values. We must also add a
    `class` attribute so that we can style the rows. To display the image, we can
    call `require` so that Vue 3 can resolve the path directly. The Vue CLI uses Webpack
    so that it can load the image as a module. We can set it as the value of the `src`
    prop and it will display the image. We load the whole images and display them.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中，我们使用`h1`组件显示`title`。`v-for`指令循环遍历谜题的`array`响应属性中的项目并显示它们。像往常一样，我们需要为每个条目设置`key`属性，以便为Vue
    3正确跟踪值设置唯一ID。我们还必须添加一个`class`属性，以便我们可以样式化行。要显示图像，我们可以调用`require`，这样Vue 3可以直接解析路径。Vue
    CLI使用Webpack，因此它可以将图像作为模块加载。我们可以将其设置为`src`属性的值，它将显示图像。我们加载整个图像并显示它们。
- en: Also, in the row, we have a button that calls the `selectPuzzle()` method when
    we click on it. This will set the choice of the puzzle and propagate it to the
    slider puzzle component that we will create so that we can see the correct puzzle
    displayed.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在行中，我们有一个按钮，当我们点击它时调用`selectPuzzle()`方法。这将设置谜题的选择并将其传播到我们将创建的滑块谜题组件，以便我们可以看到正确的谜题显示。
- en: '`.row img select` has its width set to `100px` to display a thumbnail of the
    whole image. Also, we can display the buttons in a way that they are aligned with
    the other child elements.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`.row img select`的宽度设置为`100px`，以显示整个图像的缩略图。此外，我们可以以一种与其他子元素对齐的方式显示按钮。'
- en: Next, we must create the `src/components/Records.vue` file to add a component
    that contains the speed records. This provides a list of fastest times for winning
    the game. The fastest time records are stored in local storage for easy access.
    In this component, all we do is display the components.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须创建`src/components/Records.vue`文件，以添加一个包含速度记录的组件。这提供了一个最快完成游戏的时间列表。最快的时间记录存储在本地存储中，以便轻松访问。在这个组件中，我们只是显示组件。
- en: 'To create this component, we must write the following code in `src/components/Records.vue`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这个组件，我们必须在`src/components/Records.vue`中编写以下代码：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the `component` object, we have the `getRecords()` method, which obtains
    the fastest time records from local storage. The `localStorage.getItem()` method
    gets data by its key. The argument is the key that maps to the data that we want
    to get. It returns a string with the data. Therefore, to convert the string into
    an object, we must call `JSON.parse` to parse the JSON string into an object.
    It should be an array since we will create an array and stringify it into a JSON
    string before we record it. Local storage can only hold strings; so, this is a
    required step.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在`component`对象中，我们有`getRecords()`方法，它从本地存储中获取最快的时间记录。`localStorage.getItem()`方法通过其键获取数据。参数是映射到我们想要获取的数据的键。它返回一个包含数据的字符串。因此，为了将字符串转换为对象，我们必须调用`JSON.parse`将JSON字符串解析为对象。它应该是一个数组，因为我们将创建一个数组并将其字符串化为JSON字符串，然后记录它。本地存储只能保存字符串；因此，这是一个必需的步骤。
- en: Once we've retrieved the records from local storage, we can set it as the value
    of the `this.records` reactive property. In case there is no item with the `records`
    key in local storage, we must set the default to an empty array. This way, we
    always get an array assigned to `this.records`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们从本地存储中检索到记录，我们可以将其设置为`this.records`响应式属性的值。如果本地存储中没有带有`records`键的项目，我们必须将默认值设置为空数组。这样，我们总是将一个数组分配给`this.records`。
- en: Also, we have the `beforeMount` hook, which lets us get the records before the
    component mounts. This way, we will see the records when the component is mounted.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还有`beforeMount`钩子，它让我们在组件挂载之前获取记录。这样，当组件挂载时，我们将看到记录。
- en: In the template, we show the speed records with the `v-for` directive to loop
    through the items and display them. The `v-for` directive in the array entry has
    the first item in the parentheses. The second item in the parentheses is the index.
    We can set the `key` prop to the index since they are unique, and we are not moving
    the entries around. We display both in the list.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中，我们使用`v-for`指令显示速度记录，以循环遍历项目并显示它们。数组条目中的`v-for`指令在括号中有第一个项目。括号中的第二个项目是索引。我们可以将`key`属性设置为索引，因为它们是唯一的，而且我们不会移动条目。我们在列表中显示两者。
- en: Also, we have a button that calls the `getRecords` method when we click it to
    get the latest entries.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们有一个按钮，当我们点击它时调用`getRecords`方法以获取最新条目。
- en: Now that we've created the simplest components, we can move on and create the
    slider puzzle component.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了最简单的组件，我们可以继续创建滑块拼图组件。
- en: Creating the components for shuffling pictures
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建洗牌图片的组件
- en: The slider puzzle game provides the slider puzzle where the player shuffles
    the tiles into a picture to win, the elapsed time display, the logic for rearranging
    the puzzles, the logic to check if we win, and a timer to calculate the elapsed
    time since the game started.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 滑块拼图游戏提供了滑块拼图，玩家将拼图洗牌成图片以赢得比赛，显示经过的时间，重新排列拼图的逻辑，检查我们是否赢得比赛的逻辑，以及计算自游戏开始以来经过的时间的计时器。
- en: To calculate the elapsed time easily, we can use the `moment` library. To install
    the library, we can run `npm install moment`. Once we have installed the package,
    we can begin writing the necessary code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了轻松计算经过的时间，我们可以使用`moment`库。要安装该库，我们可以运行`npm install moment`。一旦我们安装了包，我们就可以开始编写必要的代码。
- en: Let's create the `src/components/SliderPuzzle.vue` file. The full code for this
    file can be found at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter03/src/components/SliderPuzzle.vue](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter03/src/components/SliderPuzzle.vue).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建`src/components/SliderPuzzle.vue`文件。该文件的完整代码可以在[https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter03/src/components/SliderPuzzle.vue](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter03/src/components/SliderPuzzle.vue)找到。
- en: 'We will start by creating the component with the `script` tag:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过`script`标签创建组件：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: First, we import the `moment` library to calculate the elapsed time. Next, we
    define the `correctPuzzleArray` variable and assign it to an array with the correct
    order of the files. We check against this array to determine if the player has
    won the game.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入`moment`库来计算经过的时间。接下来，我们定义`correctPuzzleArray`变量，并将其分配给一个具有文件正确顺序的数组。我们根据这个数组来确定玩家是否赢得了比赛。
- en: Then, we move on to creating the object for the component options. The `props`
    property contains our own prop. `puzzleId` is a string with the ID of the puzzle
    the player is playing. We must make sure that it is a string. We set its default
    value to `'cut-pink'` so that we always have a puzzle set.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们开始创建组件选项的对象。`props`属性包含我们自己的属性。`puzzleId`是一个包含玩家正在玩的谜题的ID的字符串。我们必须确保它是一个字符串。我们将其默认值设置为`'cut-pink'`，这样我们就始终有一个谜题集。
- en: 'The `data()` method contains our initial states. We return an object with them.
    This way, we make sure that the values of the reactive properties are always isolated
    from the other components in our app. The `correctPuzzleArray` reactive property
    is just what we defined earlier. We just set it to a property so that it becomes
    a reactive property. This makes it usable with our `isWinning` computed property
    since we want the value to update when this array updates:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`data()`方法包含我们的初始状态。我们返回一个包含它们的对象。这样，我们可以确保响应属性的值始终与我们应用程序中的其他组件隔离。`correctPuzzleArray`响应属性就是我们之前定义的。我们只是将其设置为一个属性，使其成为一个响应属性。这使它可以与我们的`isWinning`计算属性一起使用，因为我们希望在此数组更新时更新值：'
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`shuffledPuzzleArray` is a copy of the `correctPuzzleArray` reactive property,
    but the items are shuffled so that the player has to rearrange the items to win
    the game. To create the value for the property, first, we must make a copy of
    the `correctPuzzleArray` array with the spread operator. Then, we must call `sort`
    with a `callback`. `callback` is a function that generates a number between `-0.5`
    and `0.5` with `Math.random()` – `0.5`. We need a random number between that range
    so that the values sort randomly. `callback` is a comparator function. It can
    take two parameters; that is, the previous and current array entry, so that we
    can compare them:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`shuffledPuzzleArray`是`correctPuzzleArray`响应属性的副本，但项目被洗牌，以便玩家必须重新排列项目才能赢得游戏。为了创建属性的值，首先我们必须用扩展运算符复制`correctPuzzleArray`数组。然后，我们必须使用`callback`调用`sort`。`callback`是一个使用`Math.random()`生成介于`-0.5`和`0.5`之间的数字的函数。我们需要一个在这个范围内的随机数，以便值随机排序。`callback`是一个比较函数。它可以接受两个参数；也就是说，前一个和当前数组条目，这样我们就可以比较它们：'
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Since we are sorting items randomly, we don't need to do any comparison. If
    the comparator callback returns a negative number or `0`, then the order of the
    items is unchanged. Otherwise, the order of the items in the array we are sorting
    is switched around. The `sort()` method returns a new array with the entries sorted.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们是随机排序物品，所以不需要进行任何比较。如果比较器回调返回负数或`0`，则项目的顺序不变。否则，我们要排序的数组中的项目顺序会改变。`sort()`方法返回一个按顺序排列的新数组。
- en: The `indexesToSwap` reactive property is used to add the index of the image
    filenames that we want to swap. When we click the `swap()` method, we push a new
    value to the `indexesToSwap` reactive property so that we can swap the two items
    with the given index when there are two items in the `indexesToSwap` array.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`indexesToSwap`响应属性用于添加我们想要交换的图像文件名的索引。当我们点击`swap()`方法时，我们向`indexesToSwap`响应属性推送一个新值，这样当`indexesToSwap`数组中有两个项目时，我们就可以交换这两个项目。'
- en: The `timer` reactive property may contain the object of the timer that's returned
    by the `setInterval` function. The `setInterval` function lets us run code periodically.
    It takes a callback with the code we want to run as the first argument. The second
    argument is the time between each call of the callback in milliseconds.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`timer`响应属性可能包含由`setInterval`函数返回的计时器对象。`setInterval`函数让我们周期性地运行代码。它接受一个包含我们想要运行的代码的回调作为第一个参数。第二个参数是回调之间的时间间隔，以毫秒为单位。'
- en: The `startDateTime` reactive property contains the date and time when the game
    started. It is a `Date` instance that contains the current time. The `currentDateTime`
    reactive property has the `Date` instance with the current date and time. It is
    updated as the game is processing within the `callback` property we pass into
    the `setInterval` function.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`startDateTime`响应属性包含游戏开始时的日期和时间。它是一个包含当前时间的`Date`实例。`currentDateTime`响应属性具有当前日期和时间的`Date`实例。随着游戏在我们传递给`setInterval`函数的`callback`属性中进行处理，它会被更新。'
- en: The `data()` method contains the initial values of all the reactive properties.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'The `computed` property contains the computed properties. Computed properties
    are synchronous functions that return some values that are based on other reactive
    properties. Computed properties are reactive properties themselves. Their values
    are updated when the reactive properties that are referenced within the computed
    property functions that are referenced are updated. We defined three computed
    properties in this component: `isWinning`, `elapsedDiff`, and `elapsedTime`.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: The `isWinning` computed property is the property that contains the state of
    the game. If it returns `true`, then the player wins the game. Otherwise, the
    player hasn't won the game. To check if the player has won the game, we loop through
    the `correctPuzzleArray` reactive property and check if each entry of it is the
    same as the one in the `shuffledPuzzleArray` reactive property array.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '`correctPuzzleArray` contains the correct items listed. So, if each item in
    the `shuffledPuzzleArray` array''s reactive property matches the entries in `correctPuzzleArray`,
    then we know that the player has won. Otherwise, the player hasn''t won. Therefore,
    if there are any differences between `correctPuzzleArray` and `shuffledPuzzleArray`,
    then it returns false. Otherwise, it returns true.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: The `elapsedDiff` computed property calculates the elapsed time in milliseconds.
    This is where we use the `moment` library to calculate the elapsed time from `startDateTime`
    to `currentDateTime`. We use the `moment` library to do this calculation since
    it makes our job a lot easier. It has a `diff()` method that we can use to calculate
    the difference between this and another `moment` object. The difference in milliseconds
    is returned.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Once we've calculated the `elapsedDiff` computed property, we can use it to
    format the elapsed with `moment` into a human-readable time format; that is, HH:mm:ss.
    The `elapsedTime` computed property has the computed property return a string
    with the formatted elapsed time. The `moment.utc()` method is a function that
    takes a timespan in UTC, then returns a `moment` object where we can call the
    `format()` method to let us calculate the time.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have defined all our reactive and computed properties, we can define
    our methods so that we can rearrange our slides into the correct picture.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Rearranging the slides
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can add the required `methods` for the `SliderPuzzle.vue` component by writing
    the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The logic is defined in the `methods` property. We have the `swap()` method
    to let us swap the cut image slides. The `start()` method lets us reset the reactive
    properties into their initial states, shuffle the cut photo slides, and then start
    the timer to calculate the elapsed time. We also check if the player has won each
    time the timer code is run. The `stop()` method lets us stop the timer. The `resetTime()`
    method lets us reset `startDateTime` and `currentDateTime` to their current date
    time. The `recordSpeedRecords()` method lets us record the time that the player
    took to win the game if they are in the top 10.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: We start with the logic to swap the slides by defining the `swap()` method.
    It takes an argument, which is the index of one of the slides that we want to
    swap. When the player clicks on a slide, this method is called. This way, we add
    the index of one of the items we want to swap with the other to the `indexesToSwap`
    computed property. So, if the player clicks on two slides, then their positions
    will be swapped with each other.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: The `swap()` method body checks if the `indexesToSwap` reactive property has
    less than two slide indexes inside it. If there's less than two, then we call
    `push` to append the slide to the `indexesToSwap` array. Next, if there are indexes
    in the `indexesToSwap` reactive property array, then we do the swapping.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'To do the swapping, we destructure the indexes from the `indexToSwap` reactive
    property. Then, we use our destructuring assignment again to do the swapping:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To swap the items in an array, we just have to assign one with `index2` of `shuffledPuzzleArray`
    to the item with `index1`. Then, the item that is originally in `index1` of `shuffledPuzzleArray`
    is put into the `index2` slot of `shuffledPuzzleArray` in the same way. Finally,
    we make sure that we empty the `indexesToSwap` array so that we can let the player
    swap another pair of slides. Since `shuffledPuzzleArray` is a reactive property,
    it is automatically rendered in the template as it updates with the `v-for` directive
    in the template.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: The `start()` method lets us start the timer for calculating the elapsed time
    between when the **Start** button is clicked to start the game and the current
    date and time until the game is finished or when the user clicks the **Quit**
    button. First, the method resets the `startDateTime` and `currentDateTime` reactive
    properties by setting those values to the current date time, which we get by instantiating
    the `Date` constructor. Then, we shuffle the slides by making a copy of `correctPuzzleArray`,
    and then calling sort as we did previously to sort the copy of the `correctPuzzle`
    array. Also, we set the `indexesToSwap` property to an empty array to clear any
    items that are present so that we start afresh.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Once we've done all the resetting, we can call `setInterval` to start the timer.
    This will update the `currentDateTime` reactive property with the current date
    and time so that we can calculate the `elapsedDiff` and `elapsedTime` computed
    properties. Next, we check the `isWinning` reactive property to check if it is
    true. If it is, then we call the `this.recordSpeedRecords` method to record the
    fastest time if the player has won.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: If the player wins, as indicated by `isWinning` being `true`, we can also call
    the `stop()` method to stop the timer. The `stop()` method just calls the `resetTime()`
    method to reset all the times. Then, it calls `clearInterval` to clear the timer.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'To display the slider puzzle, we can add the `template` tag:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we can add the required styles by writing the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the `styles` tag, we have the styles for styling the slider puzzle. We need
    the slider puzzle so that we can display three slides in a row and three rows
    altogether. This way, we display all the slides in a 3x3 grid. The `row` class
    has the property set to `flex` so that we can use flexbox to lay out the slides.
    We also set the `flex-wrap` property to `wrap` so that we can wrap any overflowing
    items to the next row. `max-width` is set to `90vw` so that the slider puzzle
    grid will stay on the screen.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: The `column` class has the `flex-grow` property set to `1` so that it is one
    of three items displayed in the row.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: In the template, we display our `title` for the game with the `h1` element.
    We have a **Start Game** button that calls the `start()` method when we click
    on the button to start the game timer. Also, we have a **Quit** button to call
    the `stop()` method when we click on it to stop the timer. The `elapsedTime` computed
    property is displayed like any other reactive property. And if the user wins,
    as indicated by the `isWinning` reactive property returning true, we will see
    the **'You Win'** message.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: To display the slides, we just loop through all the `shuffledPuzzleArray` reactive
    properties with the `v-for` directive and render all the slides. When we click
    on each slide, the `swap()` method is called with the index. And once we have
    two indexes in the `indexesToSwap` reactive property, we swap the slides. The
    `key` prop is set to the filename since they are unique. To display the slide
    images, we call `require` with the path of the image so that we display the images.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Since we have the flexbox styles to display the items three in a row and in
    three rows, all nine images will automatically be displayed in a 3x3 grid. Now
    that we have the slider puzzle game logic out of the way, all we have to add is
    the logic that records the timing score in local storage.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the score based on timing
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is done in the `recordSpeedRecords()` method. It gets the records by getting
    the local storage item with the *key* records from the local storage. Then, we
    get the `elapsedTime` and `elapsedDiff` reactive property values and push them
    into the `records` array.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Next, we sort the records with the `sort()` method. This time, we are not sorting
    the items randomly. Rather, we are sorting them by the `elapsedDiff` reactive
    property's timespan, which is measured in milliseconds. We pass in a callback
    with the `a` and `b` parameters, which are the previous and current array entries,
    respectively, and we return the difference between them. This way, if it returns
    a negative number or 0, then the order between them is unchanged. Otherwise, we
    switch the order. Then, we call `slice` with the first and last index to include
    it in the returned array that we assigned to the `sortedRecords` constant. The
    `slice()` method returns an array with the item in the first index included all
    the way up to the last index, minus `1`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we *stringify* the arrays with the `JSON.stringify()` method to convert
    the `sortedRecords` array into a string. Then, we call `localStorage.setItem`
    to put the item into an item with the `'records'` key.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we must change the contents of the `App.vue` file to the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We add the components we created earlier to render them on the screen. `selectedPuzzleId`
    has the ID of the puzzle we selected by default.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have all the code, we can run the project by running `npm run serve`
    in our project folder if we haven''t already. Then, when we go to the URL that
    is indicated by the Vue CLI, we will see the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Screenshot of the slider puzzle game'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.3_B14405.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – Screenshot of the slider puzzle game
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've finished the web app's code, we have to find an easy way to test
    all its parts.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing with Jest
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is an important part of any app. When we refer to tests, we usually
    mean automated tests. These are tests that we can run in quick repetition to make
    sure that our code is not broken. When any tests fail, we know that our code did
    not do what it was doing before. Either we created a bug, or the tests are outdated.
    Because we can run them quickly, we can write many of them and run them as we
    build our code.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: This is much preferred to manual tests, which must be done by a person doing
    the same actions over and over again. Manual tests are boring for the tester,
    they are error-prone, and are very slow. It is just not a pleasant experience
    for anyone. Therefore, it is better to write as many automated tests as possible
    to minimize the manual tests.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: If the instructions that are shown in the Vue CLI are followed, it is very easy
    to add skeleton test code without doing any extra work. The files for unit tests
    should be automatically generated for us. We should have a `tests/unit` folder
    in our code to separate our test code from our production code.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '**Jest** is a JavaScript test framework that we can run unit tests with. It
    provides us with a useful API that lets us describe our tests groups and define
    our tests. Also, we can mock any external dependencies that are normally used,
    such as timers, local storage, and states, easily. To mock the `localStorage`
    dependency, we can use the `jest-localstorage-mock` package. We can install it
    by running `npm install jest-localstorage-mock –save-dev`. The `–save-dev` flag
    lets us save the package as a development dependency so that it is only installed
    in the development environment and nowhere else. Also, in the `package.json` file,
    we will add a `jest` property to it as a `root` property. To do that, we can write
    the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We have these properties in `package.json` so that when we run our tests, the
    `localStorage` dependency will be mocked out so that we can check if its methods
    have been called. Together with the other properties, our `package.json` file
    should look something like the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Once we are done with that, we can add our tests.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Adding a test for the Puzzles.vue component
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we must remove the existing files from the `tests/unit` folder. Then,
    we can start writing our tests. We can start by writing tests for the `Puzzles.vue`
    component. To do that, we must create the `tests/unit/puzzles.spec.js` file and
    write the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `describe` function takes a string with the description of our test group
    in a string. The second argument is a callback with the tests inside it. The `describe`
    function creates a block that groups several related tests together. Its main
    purpose is to make the test results easier to read on our screens.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: The `it()` function lets us describe our tests. It is also known as the `test()`
    method. Its first argument is the `name` property of the test in string form.
    The second argument is a callback function with the test code. It also takes an
    optional third argument with `timeout` in milliseconds so that our tests won't
    be stuck running forever. The default timeout is 5 seconds.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: If a `promise` is returned from the `it` or `test` function, Jest will wait
    for the promise to resolve before the test completes. Jest also waits if we provide
    an argument to the `it` or `test` function, which is usually called `done`. The
    `done` function is called to indicate that the test is done if the `done` parameter
    is added to the `it` or `test` callback.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: The `it` or `test` function doesn't have to be inside the callback we pass into
    `describe`. It can also be called **standalone**. However, it is better to group
    related tests together with `describe` so that we can read the results more easily.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: The first test tests that when the **Play** button is clicked, the `puzzle-changed`
    event is emitted. As we can see from the `Puzzles.vue` component, the `puzzle-changed`
    event is emitted with the `this.$emit()` method. To create our test, we call `mount`
    to mount our component. It takes the component we want to test as its argument.
    It also takes a second argument with the object of component options that we want
    to override. In this test, since we are not overriding anything, we did not pass
    in anything as the second argument.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: The `mount()` method returns the `wrapper` object, which is the `wrapper` object
    for our component that we are testing. It has a few handy methods that we can
    use to do the testing. In this test, we call the `find()` method to get the HTML
    element with the given selector. It returns the HTML DOM object, which will call
    the `trigger()` method to trigger the event that we want in our test.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'This way, we can trigger events such as keyboard and mouse events to simulate
    user interaction. So, the following code is used to get the element with the `.play-button
    button` selector and then trigger the click event on it:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The last line of the test is used to check whether the `puzzle-changed` event
    is emitted. The `emitted()` method returns an object with properties that have
    names. These are the event names of the emitted events. The `toHaveProperty()`
    method lets us check if the property name we passed in as the argument is in the
    returned object. It is a property of the object that's returned by the `expect()`
    method.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: In the second test, we mount the component again and trigger the `click` event
    on the same element. Then, we call the `emitted()` method with the event name
    so that we can get the payload that is emitted with the event with the object
    it returns. The `puzzleChanged` array contains the payload that is emitted as
    the first element. Then, to check if the `puzzles[0].id` property is emitted,
    we have the check in our last line. The `wrapper.vm` property contains the mounted
    component object. Therefore, `wrapper.vm.puzzles` is the puzzle's reactive property
    of the `Puzzles` component. So, this means we are checking if the `id` property
    of the puzzle's reactive property from the `Puzzles` component has been emitted.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Adding a test for the Records component
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we must write tests for the `Records` component. To do that, we must
    create the `tests/unit/records.spec.js` file and write the following code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is where we use the `jest-localstorage-mock` package. All we have to do
    is to import the package file; then, the code in the file will run and mock the
    `localStorage` dependency for us. In the test, we call `shallowMount` to mount
    our `Records` component and then we can check if `localStorage.getItem` is called
    with the `'records'` argument. With the `jest-localstorage-mocks` package, we
    can pass in `localStorage.getItem` directly to expect it to do the check. The
    `toHaveBeenCalledWith()` method lets us check the argument that it is called with.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Since we called the `localStorage.getItem()` method in the `beforeMount()` method,
    this test should pass since we called it as we were loading the component.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Adding a test for the SliderPuzzle component
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, we must write some tests for the `SliderPuzzle` component. We will
    add the `tests/unit/sliderPuzzle.spec.js` file and write the following code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the `'inserts the index of the image to swap when we click on an image'`
    test, we mount the `SliderPuzzle` component and then trigger the `click` event
    on the `img` element. The `img` element is the first slide of the slider puzzle.
    The `swap()` method should be called so that the `indexesToSwap` reactive property
    has the index of the first image that's added. The `toBeGreaterThan()` method
    lets us check if the returned value of what we expected is greater than some number.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: In the `'swaps the image order when 2 images are clicked'` test, we mount the
    `SliderPuzzle` component again. Then, we get `wrapper.vm.shuffledPuzzleArray`
    to get the indexes that are in the earlier array and destructure their values.
    We will use it later to compare the values from the same array to see if they
    have been swapped once we've clicked on two images.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we trigger the click on the slides with the `wrapper.get()` method to
    get the image element. Then, we call the `trigger()` method to trigger the click
    events. Then, we check if the `indexesToSwap` reactive property has `0` for its
    length after the swapping is done. Then, in the last three lines, we get the items
    from `wrapper.vm.shuffledPuzzleArray` again and compare their values. Since the
    entries are supposed to be swapped after the two slides, we have the following
    code to check if swapping is actually done:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the `''starts timer when start method is called''` test, we mount the `SliderPuzzle`
    component again. This time, we call the `start()` method to make sure that the
    timer is actually created with `setInterval`. We also check if the `setInterval`
    function is called with a function and 1,000 milliseconds. To let us test anything
    with timers easily, which includes testing anything that calls `setTimeout` or
    `setInterval`, we call `jest.useFakeTimers()` to let us mock those functions so
    that our tests won''t interfere with the operations of the other tests:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `toHaveBeenCalledTimes()` method checks whether a function that we passed
    into the `expect()` method is called a given number of times. Since we called
    `jest.useFakeTimers(),` `setInterval` is actually a spy of the real `setInterval`
    function rather than the real version. We can only use spies for a function with
    `expect` and `toHaveBeenCalledTimes` and `toHaveBeenCalledWith`. So, the code
    we have will work. The `toHaveBeenLastCalledWith()` method is used to check the
    argument that our function spy is called with the given kind of argument. We make
    sure the first argument is a function and that the second argument is 1,000 milliseconds.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `''stops timer when stop method is called''` test, we do something similar
    by mounting the component and then calling the `stop()` method. We make sure `clearInterval`
    is actually called when we call the `stop()` method:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Next, we add the `'records record to local storage'` test. We make use of the
    `jest-localstorage-mock` library again to mock the `localStorage` dependency.
    We mount the `SliderPuzzle` component differently in this test. The second argument
    is an object that contains the `data()` method. This is the `data()` method that
    we have in the component's `options` object. We override the component's original
    reactive property values with what we pass in. The `currentDateTime` and `startDateTime`
    reactive properties are overridden so that we can set the date to what we want
    so that we can do the testing with them instead.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Then, we call the `wrapper.vm.recordSpeedRecords()` method to test if the `localStorage.setItem()`
    method is called. We call the method that is in the mounted component. Then, we
    create the `stringifiedRecords` JSON string so that we can compare that with what
    is being called with `localStrorage.setItem`. `toHaveBeenCalledWith` only works
    with `localStorage.setItem` because we imported the `jest-localstorage-mock` library
    to create a spy from the actual `localStorage.setItem()` method. This lets Jest
    check whether the method is called or not with the given arguments.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: To test if the timer is started when the **Start** button is clicked, we have
    the `'starts timer with Start button is clicked'` test. We just get the **Start**
    button by its ID with the `get()` method and trigger the `click` event on it.
    Then, we check that the `setInterval` function is called. Like with `localStorage`,
    we mock the `setInterval` function with the `jest.useFakeTimers()` method to create
    a spy from the actual `setInterval` function. This lets us check that it is called.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we have the `'stops timer with Quit button is clicked'` test to check
    if the `clearInterval` function is called if the **Quit** button is clicked.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have the `'shows the elapsed time'` test to mount the component
    with different values for the `currentDateTime` and `startDateTime` reactive properties.
    They are set to the values we want, and they will stay the way they are in the
    test. Then, to check if the `elapsedTime` computed property is displayed properly,
    we call the `wrapper.html()` method to return the rendered HTML in the wrapped
    component, and we check that it includes the elapsed time string we are looking
    for.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: To clean up the mocks after each test so that we start afresh after each test,
    we call the `jest.clearAllMocks()` method to clear all the mocks after each test.
    The `afterEach` function takes a callback that is run after each test is done.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Running all the tests
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To run the tests, we run `npm run test:unit`. By doing this, we''ll see something
    like the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Results of our unit tests'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.4_B14405.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – Results of our unit tests
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Since all the tests passed, the code in our project is doing what we expect
    it to. It only takes around 4 seconds to run all the tests, which is much faster
    than testing our code manually.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked deeper into components by defining the computed properties
    in our components. Also, we added tests for our components so that we can test
    the parts of our components individually. With the Vue CLI, we added test files
    and dependencies easily within our app.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Inside our components, we can emit events that propagate to the parent component
    with the `this.$emit()` method. It took a string with the event name. The other
    arguments are the payloads that we want to pass from the parent component to the
    child components.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: To add unit tests to our Vue 3 app and run the tests, we used the Jest test
    framework. Vue 3 adds its own specific APIs to Jest so that we can test Vue 3
    components with it. To test components, we mounted the component by using the
    `mount` and `shallowMount` functions. The `mount` function lets us mount the component
    itself, including the nested component. The `shallowMount` function only mounts
    the component itself without the child components. They both return a `wrapper`
    for our component so that we can use it to interact with the component to do the
    testing.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: We should make sure that our tests run in isolation. This is why we were mocking
    the external dependencies. We do not want to run any code that requires anything
    external to the tests and the project code to be available. Also, we had to make
    sure that we cleaned up any dependencies in our tests if needed. If there were
    any mocks, we had to clean them up so that they were not carried forward to another
    test. Otherwise, we may have tests that depend on other tests, which makes troubleshooting
    tests very difficult.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how to create a photo gallery app that
    saves data by sending the data we want to save to a backend API. We will introduce
    the use of Vue Router so that we can navigate to different pages.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
