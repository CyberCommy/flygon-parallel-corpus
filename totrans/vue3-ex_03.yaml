- en: '*Chapter 3*: Building a Slider Puzzle Game with Tests'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we created a simple GitHub app with Vue that had some
    components added to it. In this chapter, we will build a simple slider puzzle
    game. The game's goal is to rearrange parts of a picture till it looks like what
    we expect. It will have a timer to calculate the elapsed time and will display
    it on the screen. Once we rearrange the image's parts correctly, we will see a
    **'You Win'** message, and the elapsed time will be recorded in local storage
    if it is in the top 10 fastest times. We have multiple puzzles that we can choose
    from so that we can have more variety in our game. This makes it more interesting
    than just having one puzzle.
  prefs: []
  type: TYPE_NORMAL
- en: To build the apps, we will build components with computed properties and timers
    to calculate the elapsed time. Also, some components will get and set data from
    local storage. Whenever we get data from local storage, the results will be displayed.
    We will use local storage to store the fastest times. Local storage can only store
    strings, so we will convert the result into a string and store it.
  prefs: []
  type: TYPE_NORMAL
- en: We will use a timer to time when the player wins the game, and we will use computed
    properties to determine when the player wins the game. Also, to make sure that
    our game works like it should, we will add unit tests for each part to test each
    component automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will dig deeper into components and cover the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the basics of components and mixins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up our Vue project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the components for shuffling pictures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Letting users rearrange the slides
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating the score based on timing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing with Jest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source code for this chapter is located at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter03](https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter03).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the basics of components and mixins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is more to components than what we did in [*Chapter 2*](B14405_02_ePub_RK.xhtml#_idTextAnchor023),
    *Building a Vue 3 Progressive Web App*, to create the GitHub progress web app.
    These components were the most basic parts. We will use timers with our components,
    rather than just having components that get data and display it. Also, we will
    look at when and how to use computed properties so that we can create reactive
    properties that have values that are derived from other reactive properties. This
    saves us from creating extra methods that we don't need or using directives unnecessarily.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we will look at how to use computed properties to return values
    that are derived from other reactive properties. **Computed properties** are methods
    that return values that are derived from one or more other reactive properties.
    They are reactive properties themselves. The most common usage for them is getters.
    However, computed properties can have both getters and setters. Their return values
    are cached so that they don't run until one or more reactive properties have their
    values updated. They are useful for replacing complex template expressions and
    methods in an efficient manner.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing that components can do is emit custom events. An event can contain
    one or more payloads emitted with the event. They have their own event name, and
    we can listen to the events by listening to the event with the `v-on` directive.
    We can get the emitted payload with the `$event` variable or the parameters of
    the event handler methods.
  prefs: []
  type: TYPE_NORMAL
- en: Another important part of a Vue 3 app is **tests**. When we mention tests, they
    are usually automated tests. Tests come in many forms and are useful for catching
    various kinds of bugs. They are often used for catching regressions, which are
    bugs that are created after we change the code that is already part of our app.
    We can check for regressions with a few kinds of tests. The smallest tests we
    can create are **unit tests**, which test a component and its parts in isolation.
    It works by mounting our component in a test environment. Any dependencies that
    prevent our tests from running in isolation are mocked so that we can run our
    tests in isolation. This way, we can run our tests in any environment and in any
    order.
  prefs: []
  type: TYPE_NORMAL
- en: Each test is independent, so we shouldn't have any issues running them anywhere,
    even without an internet connection. This is important because they are supposed
    to be portable. Also, external resources such as API data and timers are very
    volatile. They are also asynchronous, which makes them hard to test. Therefore,
    we must make sure that we don't need them for our tests since we want consistency
    in the results.
  prefs: []
  type: TYPE_NORMAL
- en: Vue comes with support for JavaScript test frameworks such as **Jest** and **Mocha**.
    This is one of the great benefits of using the Vue CLI to create our Vue project.
    We don't have to create all the scaffolding of the test code ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Another kind of test is *end-to-end* tests. These tests simulate how a user
    would use our app. We usually have an environment that is created from scratch
    and then taken down to run these tests. This is because we want fresh data in
    our tests at all times. The tests must be able to run in a consistent manner.
    We need consistent data for this to be done if we are going to use the app like
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will mainly look at unit tests for our frontend app. They
    can provide DOM interactions like we do with end-to-end tests, but they are faster
    and a lot smaller. They also run a lot faster since we don't have to create a
    clean environment each time a test is run. The environment's creation and user
    interaction tests will always be slower than unit tests. Therefore, we should
    have many unit tests and a few end-to-end tests for testing the most critical
    parts of our app.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Vue project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've learned the basics about computed properties and getters and
    setters, we are ready to look deeper at the component parts that we will need
    and create the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the project, we use the Vue CLI again. This time, instead of selecting
    the default options, we must choose a few options. But before we do that, we will
    create a project folder called `vue-example-ch3-slider-puzzle`. Then, we must
    go into the folder and run the following commands with `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must install the Vue CLI globally so that we can create and run our
    project with it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can go into our project folder and run the following command to create
    our project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Equivalently, we can run the following commands with Yarn:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must install the Vue CLI globally so that we can create and run our
    project with it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can go into our project folder and run the following command to create
    our project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In either case, we should see the Vue CLI command-line program with instructions
    on how to choose the items. If we are asked if we want to create the project in
    the current folder, we can type *Y* and press *Enter* to do so. Then, we should
    see the project types that we can create our project with. We should choose `Manually
    select features`, and then `Vue 3` to create a Vue 3 project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Selecting the project type to create in the Vue CLI wizard'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.1_B14405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – Selecting the project type to create in the Vue CLI wizard
  prefs: []
  type: TYPE_NORMAL
- en: On the next screen, we should see what we can add to the project. Choose `Unit`
    `Testing,` and then you need to choose `Testing` `with` `Jest` so that we can
    add tests to our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'This project will come with tests for many components once we''ve finished
    writing the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – The options we should choose for this project'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.2_B14405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – The options we should choose for this project
  prefs: []
  type: TYPE_NORMAL
- en: Once we let the Vue CLI finish creating the project, we should see the code
    files in the `src` folder. The tests should be in the `tests/unit` folder. The
    Vue CLI saved us lots of effort from creating the test code all by ourselves.
    It comes with an example test that we can expand from.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve picked these options, we can start creating our app. In this project,
    we will get some pictures from Unsplash, which provides us with royalty-free images.
    Then, we will get the images and cut them up into nine pieces so that we can display
    them in the `slider puzzle` component. We need both the whole image and the cut
    pieces. For this example, we will get the images from the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://unsplash.com/photos/EfhCUc_fjrU](https://unsplash.com/photos/EfhCUc_fjrU)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://unsplash.com/photos/CTvtrspsPQs](https://unsplash.com/photos/CTvtrspsPQs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://unsplash.com/photos/XoCyW2JVmiE](https://unsplash.com/photos/XoCyW2JVmiE)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we go to each page, we must click the **Download** button to download the
    images. Once we've downloaded the images, we must go to [https://www.imgonline.com.ua/eng/cut-photo-into-pieces.php](https://www.imgonline.com.ua/eng/cut-photo-into-pieces.php)
    to cut the images into nine pieces automatically.
  prefs: []
  type: TYPE_NORMAL
- en: In *section 1*, we select our image file. In *section 2*, we set both **Parts
    in width** and **Parts in height** to `3`. This way, we can divide our image into
    nine pieces. Once we have done that, we can download the ZIP file that is generated
    and then extract all the images into a folder. This should be repeated for each
    image.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have all the whole and cut image pieces, we should put them all into
    the `src/assets` folder of Vue 3 project folder that we just created. This way,
    we can access the images from our app and display them. The first image shows
    a pink flower, so the whole image is named `pink.jpg` and the cut images are in
    the `cut-pink` folder. The filenames that are generated for the cut images remain
    unchanged. The second image is a purple flower, so the whole image is named `purple.jpg`
    and the cut image folder is named `cut-purple`. The third image is a red flower.
    So, it is named `red.jpg` and the folder containing the cut pieces of the image
    is named `cut-red`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have taken care of the images, we can create our components.
  prefs: []
  type: TYPE_NORMAL
- en: First, we must remove `HelloWorld.vue` from the `src/components` folder since
    we don't need it anymore. We must also remove any reference to it from the `App.vue`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in the `components` folder, we must create the `Puzzles.vue` file to
    let us select the puzzle. It has a template so that we can display the puzzles
    we select. In the `component options` object, we have an array that contains the
    puzzles data to display. Also, we have a method that lets us emit the event to
    our parent component, which is the `App.vue` component. This way, we can display
    the right puzzle in the slider puzzle component that we will create. To do that,
    in `src/components/Puzzles.vue`, we must add the following template code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we must add the following script and style tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the `component options` object, we have the `data()` method, with the puzzle's
    reactive property between the script tags. It has an array of objects with the
    `id`, `image`, and `title` properties. The `id` property is a unique ID that we
    use when we render the entries with the `v-for` directive. We also emit the ID
    to `App.vue` so that we can pass it to our slide puzzle component from there as
    a prop. `title` is the title we display on the template in a human - readable
    way.
  prefs: []
  type: TYPE_NORMAL
- en: In the `methods` property, we have a `selectPuzzle()` method that takes the
    puzzle object. It calls `this.$emit` to emit the puzzle-changed event. The first
    argument is `name`. The second argument is the `payload` property that we want
    to emit in the event. We can listen to the event in the parent component by adding
    a `v-on` directive to the element wherever this component is referenced.
  prefs: []
  type: TYPE_NORMAL
- en: In the template, we have the `title` displayed with the `h1` component. The
    `v-for` directive loops through the items in the puzzle's `array` reactive property
    and displays them. As usual, we need the `key` prop for each entry to be set to
    a unique ID for Vue 3 to properly keep track of the values. We must also add a
    `class` attribute so that we can style the rows. To display the image, we can
    call `require` so that Vue 3 can resolve the path directly. The Vue CLI uses Webpack
    so that it can load the image as a module. We can set it as the value of the `src`
    prop and it will display the image. We load the whole images and display them.
  prefs: []
  type: TYPE_NORMAL
- en: Also, in the row, we have a button that calls the `selectPuzzle()` method when
    we click on it. This will set the choice of the puzzle and propagate it to the
    slider puzzle component that we will create so that we can see the correct puzzle
    displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '`.row img select` has its width set to `100px` to display a thumbnail of the
    whole image. Also, we can display the buttons in a way that they are aligned with
    the other child elements.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we must create the `src/components/Records.vue` file to add a component
    that contains the speed records. This provides a list of fastest times for winning
    the game. The fastest time records are stored in local storage for easy access.
    In this component, all we do is display the components.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create this component, we must write the following code in `src/components/Records.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the `component` object, we have the `getRecords()` method, which obtains
    the fastest time records from local storage. The `localStorage.getItem()` method
    gets data by its key. The argument is the key that maps to the data that we want
    to get. It returns a string with the data. Therefore, to convert the string into
    an object, we must call `JSON.parse` to parse the JSON string into an object.
    It should be an array since we will create an array and stringify it into a JSON
    string before we record it. Local storage can only hold strings; so, this is a
    required step.
  prefs: []
  type: TYPE_NORMAL
- en: Once we've retrieved the records from local storage, we can set it as the value
    of the `this.records` reactive property. In case there is no item with the `records`
    key in local storage, we must set the default to an empty array. This way, we
    always get an array assigned to `this.records`.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we have the `beforeMount` hook, which lets us get the records before the
    component mounts. This way, we will see the records when the component is mounted.
  prefs: []
  type: TYPE_NORMAL
- en: In the template, we show the speed records with the `v-for` directive to loop
    through the items and display them. The `v-for` directive in the array entry has
    the first item in the parentheses. The second item in the parentheses is the index.
    We can set the `key` prop to the index since they are unique, and we are not moving
    the entries around. We display both in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we have a button that calls the `getRecords` method when we click it to
    get the latest entries.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've created the simplest components, we can move on and create the
    slider puzzle component.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the components for shuffling pictures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The slider puzzle game provides the slider puzzle where the player shuffles
    the tiles into a picture to win, the elapsed time display, the logic for rearranging
    the puzzles, the logic to check if we win, and a timer to calculate the elapsed
    time since the game started.
  prefs: []
  type: TYPE_NORMAL
- en: To calculate the elapsed time easily, we can use the `moment` library. To install
    the library, we can run `npm install moment`. Once we have installed the package,
    we can begin writing the necessary code.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create the `src/components/SliderPuzzle.vue` file. The full code for this
    file can be found at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter03/src/components/SliderPuzzle.vue](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter03/src/components/SliderPuzzle.vue).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by creating the component with the `script` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: First, we import the `moment` library to calculate the elapsed time. Next, we
    define the `correctPuzzleArray` variable and assign it to an array with the correct
    order of the files. We check against this array to determine if the player has
    won the game.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we move on to creating the object for the component options. The `props`
    property contains our own prop. `puzzleId` is a string with the ID of the puzzle
    the player is playing. We must make sure that it is a string. We set its default
    value to `'cut-pink'` so that we always have a puzzle set.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `data()` method contains our initial states. We return an object with them.
    This way, we make sure that the values of the reactive properties are always isolated
    from the other components in our app. The `correctPuzzleArray` reactive property
    is just what we defined earlier. We just set it to a property so that it becomes
    a reactive property. This makes it usable with our `isWinning` computed property
    since we want the value to update when this array updates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`shuffledPuzzleArray` is a copy of the `correctPuzzleArray` reactive property,
    but the items are shuffled so that the player has to rearrange the items to win
    the game. To create the value for the property, first, we must make a copy of
    the `correctPuzzleArray` array with the spread operator. Then, we must call `sort`
    with a `callback`. `callback` is a function that generates a number between `-0.5`
    and `0.5` with `Math.random()` – `0.5`. We need a random number between that range
    so that the values sort randomly. `callback` is a comparator function. It can
    take two parameters; that is, the previous and current array entry, so that we
    can compare them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Since we are sorting items randomly, we don't need to do any comparison. If
    the comparator callback returns a negative number or `0`, then the order of the
    items is unchanged. Otherwise, the order of the items in the array we are sorting
    is switched around. The `sort()` method returns a new array with the entries sorted.
  prefs: []
  type: TYPE_NORMAL
- en: The `indexesToSwap` reactive property is used to add the index of the image
    filenames that we want to swap. When we click the `swap()` method, we push a new
    value to the `indexesToSwap` reactive property so that we can swap the two items
    with the given index when there are two items in the `indexesToSwap` array.
  prefs: []
  type: TYPE_NORMAL
- en: The `timer` reactive property may contain the object of the timer that's returned
    by the `setInterval` function. The `setInterval` function lets us run code periodically.
    It takes a callback with the code we want to run as the first argument. The second
    argument is the time between each call of the callback in milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: The `startDateTime` reactive property contains the date and time when the game
    started. It is a `Date` instance that contains the current time. The `currentDateTime`
    reactive property has the `Date` instance with the current date and time. It is
    updated as the game is processing within the `callback` property we pass into
    the `setInterval` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `data()` method contains the initial values of all the reactive properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `computed` property contains the computed properties. Computed properties
    are synchronous functions that return some values that are based on other reactive
    properties. Computed properties are reactive properties themselves. Their values
    are updated when the reactive properties that are referenced within the computed
    property functions that are referenced are updated. We defined three computed
    properties in this component: `isWinning`, `elapsedDiff`, and `elapsedTime`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `isWinning` computed property is the property that contains the state of
    the game. If it returns `true`, then the player wins the game. Otherwise, the
    player hasn't won the game. To check if the player has won the game, we loop through
    the `correctPuzzleArray` reactive property and check if each entry of it is the
    same as the one in the `shuffledPuzzleArray` reactive property array.
  prefs: []
  type: TYPE_NORMAL
- en: '`correctPuzzleArray` contains the correct items listed. So, if each item in
    the `shuffledPuzzleArray` array''s reactive property matches the entries in `correctPuzzleArray`,
    then we know that the player has won. Otherwise, the player hasn''t won. Therefore,
    if there are any differences between `correctPuzzleArray` and `shuffledPuzzleArray`,
    then it returns false. Otherwise, it returns true.'
  prefs: []
  type: TYPE_NORMAL
- en: The `elapsedDiff` computed property calculates the elapsed time in milliseconds.
    This is where we use the `moment` library to calculate the elapsed time from `startDateTime`
    to `currentDateTime`. We use the `moment` library to do this calculation since
    it makes our job a lot easier. It has a `diff()` method that we can use to calculate
    the difference between this and another `moment` object. The difference in milliseconds
    is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Once we've calculated the `elapsedDiff` computed property, we can use it to
    format the elapsed with `moment` into a human-readable time format; that is, HH:mm:ss.
    The `elapsedTime` computed property has the computed property return a string
    with the formatted elapsed time. The `moment.utc()` method is a function that
    takes a timespan in UTC, then returns a `moment` object where we can call the
    `format()` method to let us calculate the time.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have defined all our reactive and computed properties, we can define
    our methods so that we can rearrange our slides into the correct picture.
  prefs: []
  type: TYPE_NORMAL
- en: Rearranging the slides
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can add the required `methods` for the `SliderPuzzle.vue` component by writing
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The logic is defined in the `methods` property. We have the `swap()` method
    to let us swap the cut image slides. The `start()` method lets us reset the reactive
    properties into their initial states, shuffle the cut photo slides, and then start
    the timer to calculate the elapsed time. We also check if the player has won each
    time the timer code is run. The `stop()` method lets us stop the timer. The `resetTime()`
    method lets us reset `startDateTime` and `currentDateTime` to their current date
    time. The `recordSpeedRecords()` method lets us record the time that the player
    took to win the game if they are in the top 10.
  prefs: []
  type: TYPE_NORMAL
- en: We start with the logic to swap the slides by defining the `swap()` method.
    It takes an argument, which is the index of one of the slides that we want to
    swap. When the player clicks on a slide, this method is called. This way, we add
    the index of one of the items we want to swap with the other to the `indexesToSwap`
    computed property. So, if the player clicks on two slides, then their positions
    will be swapped with each other.
  prefs: []
  type: TYPE_NORMAL
- en: The `swap()` method body checks if the `indexesToSwap` reactive property has
    less than two slide indexes inside it. If there's less than two, then we call
    `push` to append the slide to the `indexesToSwap` array. Next, if there are indexes
    in the `indexesToSwap` reactive property array, then we do the swapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do the swapping, we destructure the indexes from the `indexToSwap` reactive
    property. Then, we use our destructuring assignment again to do the swapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: To swap the items in an array, we just have to assign one with `index2` of `shuffledPuzzleArray`
    to the item with `index1`. Then, the item that is originally in `index1` of `shuffledPuzzleArray`
    is put into the `index2` slot of `shuffledPuzzleArray` in the same way. Finally,
    we make sure that we empty the `indexesToSwap` array so that we can let the player
    swap another pair of slides. Since `shuffledPuzzleArray` is a reactive property,
    it is automatically rendered in the template as it updates with the `v-for` directive
    in the template.
  prefs: []
  type: TYPE_NORMAL
- en: The `start()` method lets us start the timer for calculating the elapsed time
    between when the **Start** button is clicked to start the game and the current
    date and time until the game is finished or when the user clicks the **Quit**
    button. First, the method resets the `startDateTime` and `currentDateTime` reactive
    properties by setting those values to the current date time, which we get by instantiating
    the `Date` constructor. Then, we shuffle the slides by making a copy of `correctPuzzleArray`,
    and then calling sort as we did previously to sort the copy of the `correctPuzzle`
    array. Also, we set the `indexesToSwap` property to an empty array to clear any
    items that are present so that we start afresh.
  prefs: []
  type: TYPE_NORMAL
- en: Once we've done all the resetting, we can call `setInterval` to start the timer.
    This will update the `currentDateTime` reactive property with the current date
    and time so that we can calculate the `elapsedDiff` and `elapsedTime` computed
    properties. Next, we check the `isWinning` reactive property to check if it is
    true. If it is, then we call the `this.recordSpeedRecords` method to record the
    fastest time if the player has won.
  prefs: []
  type: TYPE_NORMAL
- en: If the player wins, as indicated by `isWinning` being `true`, we can also call
    the `stop()` method to stop the timer. The `stop()` method just calls the `resetTime()`
    method to reset all the times. Then, it calls `clearInterval` to clear the timer.
  prefs: []
  type: TYPE_NORMAL
- en: 'To display the slider puzzle, we can add the `template` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can add the required styles by writing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the `styles` tag, we have the styles for styling the slider puzzle. We need
    the slider puzzle so that we can display three slides in a row and three rows
    altogether. This way, we display all the slides in a 3x3 grid. The `row` class
    has the property set to `flex` so that we can use flexbox to lay out the slides.
    We also set the `flex-wrap` property to `wrap` so that we can wrap any overflowing
    items to the next row. `max-width` is set to `90vw` so that the slider puzzle
    grid will stay on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The `column` class has the `flex-grow` property set to `1` so that it is one
    of three items displayed in the row.
  prefs: []
  type: TYPE_NORMAL
- en: In the template, we display our `title` for the game with the `h1` element.
    We have a **Start Game** button that calls the `start()` method when we click
    on the button to start the game timer. Also, we have a **Quit** button to call
    the `stop()` method when we click on it to stop the timer. The `elapsedTime` computed
    property is displayed like any other reactive property. And if the user wins,
    as indicated by the `isWinning` reactive property returning true, we will see
    the **'You Win'** message.
  prefs: []
  type: TYPE_NORMAL
- en: To display the slides, we just loop through all the `shuffledPuzzleArray` reactive
    properties with the `v-for` directive and render all the slides. When we click
    on each slide, the `swap()` method is called with the index. And once we have
    two indexes in the `indexesToSwap` reactive property, we swap the slides. The
    `key` prop is set to the filename since they are unique. To display the slide
    images, we call `require` with the path of the image so that we display the images.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have the flexbox styles to display the items three in a row and in
    three rows, all nine images will automatically be displayed in a 3x3 grid. Now
    that we have the slider puzzle game logic out of the way, all we have to add is
    the logic that records the timing score in local storage.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the score based on timing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is done in the `recordSpeedRecords()` method. It gets the records by getting
    the local storage item with the *key* records from the local storage. Then, we
    get the `elapsedTime` and `elapsedDiff` reactive property values and push them
    into the `records` array.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we sort the records with the `sort()` method. This time, we are not sorting
    the items randomly. Rather, we are sorting them by the `elapsedDiff` reactive
    property's timespan, which is measured in milliseconds. We pass in a callback
    with the `a` and `b` parameters, which are the previous and current array entries,
    respectively, and we return the difference between them. This way, if it returns
    a negative number or 0, then the order between them is unchanged. Otherwise, we
    switch the order. Then, we call `slice` with the first and last index to include
    it in the returned array that we assigned to the `sortedRecords` constant. The
    `slice()` method returns an array with the item in the first index included all
    the way up to the last index, minus `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we *stringify* the arrays with the `JSON.stringify()` method to convert
    the `sortedRecords` array into a string. Then, we call `localStorage.setItem`
    to put the item into an item with the `'records'` key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we must change the contents of the `App.vue` file to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We add the components we created earlier to render them on the screen. `selectedPuzzleId`
    has the ID of the puzzle we selected by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have all the code, we can run the project by running `npm run serve`
    in our project folder if we haven''t already. Then, when we go to the URL that
    is indicated by the Vue CLI, we will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Screenshot of the slider puzzle game'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.3_B14405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – Screenshot of the slider puzzle game
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've finished the web app's code, we have to find an easy way to test
    all its parts.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing with Jest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is an important part of any app. When we refer to tests, we usually
    mean automated tests. These are tests that we can run in quick repetition to make
    sure that our code is not broken. When any tests fail, we know that our code did
    not do what it was doing before. Either we created a bug, or the tests are outdated.
    Because we can run them quickly, we can write many of them and run them as we
    build our code.
  prefs: []
  type: TYPE_NORMAL
- en: This is much preferred to manual tests, which must be done by a person doing
    the same actions over and over again. Manual tests are boring for the tester,
    they are error-prone, and are very slow. It is just not a pleasant experience
    for anyone. Therefore, it is better to write as many automated tests as possible
    to minimize the manual tests.
  prefs: []
  type: TYPE_NORMAL
- en: If the instructions that are shown in the Vue CLI are followed, it is very easy
    to add skeleton test code without doing any extra work. The files for unit tests
    should be automatically generated for us. We should have a `tests/unit` folder
    in our code to separate our test code from our production code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Jest** is a JavaScript test framework that we can run unit tests with. It
    provides us with a useful API that lets us describe our tests groups and define
    our tests. Also, we can mock any external dependencies that are normally used,
    such as timers, local storage, and states, easily. To mock the `localStorage`
    dependency, we can use the `jest-localstorage-mock` package. We can install it
    by running `npm install jest-localstorage-mock –save-dev`. The `–save-dev` flag
    lets us save the package as a development dependency so that it is only installed
    in the development environment and nowhere else. Also, in the `package.json` file,
    we will add a `jest` property to it as a `root` property. To do that, we can write
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We have these properties in `package.json` so that when we run our tests, the
    `localStorage` dependency will be mocked out so that we can check if its methods
    have been called. Together with the other properties, our `package.json` file
    should look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Once we are done with that, we can add our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a test for the Puzzles.vue component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we must remove the existing files from the `tests/unit` folder. Then,
    we can start writing our tests. We can start by writing tests for the `Puzzles.vue`
    component. To do that, we must create the `tests/unit/puzzles.spec.js` file and
    write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `describe` function takes a string with the description of our test group
    in a string. The second argument is a callback with the tests inside it. The `describe`
    function creates a block that groups several related tests together. Its main
    purpose is to make the test results easier to read on our screens.
  prefs: []
  type: TYPE_NORMAL
- en: The `it()` function lets us describe our tests. It is also known as the `test()`
    method. Its first argument is the `name` property of the test in string form.
    The second argument is a callback function with the test code. It also takes an
    optional third argument with `timeout` in milliseconds so that our tests won't
    be stuck running forever. The default timeout is 5 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: If a `promise` is returned from the `it` or `test` function, Jest will wait
    for the promise to resolve before the test completes. Jest also waits if we provide
    an argument to the `it` or `test` function, which is usually called `done`. The
    `done` function is called to indicate that the test is done if the `done` parameter
    is added to the `it` or `test` callback.
  prefs: []
  type: TYPE_NORMAL
- en: The `it` or `test` function doesn't have to be inside the callback we pass into
    `describe`. It can also be called **standalone**. However, it is better to group
    related tests together with `describe` so that we can read the results more easily.
  prefs: []
  type: TYPE_NORMAL
- en: The first test tests that when the **Play** button is clicked, the `puzzle-changed`
    event is emitted. As we can see from the `Puzzles.vue` component, the `puzzle-changed`
    event is emitted with the `this.$emit()` method. To create our test, we call `mount`
    to mount our component. It takes the component we want to test as its argument.
    It also takes a second argument with the object of component options that we want
    to override. In this test, since we are not overriding anything, we did not pass
    in anything as the second argument.
  prefs: []
  type: TYPE_NORMAL
- en: The `mount()` method returns the `wrapper` object, which is the `wrapper` object
    for our component that we are testing. It has a few handy methods that we can
    use to do the testing. In this test, we call the `find()` method to get the HTML
    element with the given selector. It returns the HTML DOM object, which will call
    the `trigger()` method to trigger the event that we want in our test.
  prefs: []
  type: TYPE_NORMAL
- en: 'This way, we can trigger events such as keyboard and mouse events to simulate
    user interaction. So, the following code is used to get the element with the `.play-button
    button` selector and then trigger the click event on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The last line of the test is used to check whether the `puzzle-changed` event
    is emitted. The `emitted()` method returns an object with properties that have
    names. These are the event names of the emitted events. The `toHaveProperty()`
    method lets us check if the property name we passed in as the argument is in the
    returned object. It is a property of the object that's returned by the `expect()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: In the second test, we mount the component again and trigger the `click` event
    on the same element. Then, we call the `emitted()` method with the event name
    so that we can get the payload that is emitted with the event with the object
    it returns. The `puzzleChanged` array contains the payload that is emitted as
    the first element. Then, to check if the `puzzles[0].id` property is emitted,
    we have the check in our last line. The `wrapper.vm` property contains the mounted
    component object. Therefore, `wrapper.vm.puzzles` is the puzzle's reactive property
    of the `Puzzles` component. So, this means we are checking if the `id` property
    of the puzzle's reactive property from the `Puzzles` component has been emitted.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a test for the Records component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we must write tests for the `Records` component. To do that, we must
    create the `tests/unit/records.spec.js` file and write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is where we use the `jest-localstorage-mock` package. All we have to do
    is to import the package file; then, the code in the file will run and mock the
    `localStorage` dependency for us. In the test, we call `shallowMount` to mount
    our `Records` component and then we can check if `localStorage.getItem` is called
    with the `'records'` argument. With the `jest-localstorage-mocks` package, we
    can pass in `localStorage.getItem` directly to expect it to do the check. The
    `toHaveBeenCalledWith()` method lets us check the argument that it is called with.
  prefs: []
  type: TYPE_NORMAL
- en: Since we called the `localStorage.getItem()` method in the `beforeMount()` method,
    this test should pass since we called it as we were loading the component.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a test for the SliderPuzzle component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, we must write some tests for the `SliderPuzzle` component. We will
    add the `tests/unit/sliderPuzzle.spec.js` file and write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the `'inserts the index of the image to swap when we click on an image'`
    test, we mount the `SliderPuzzle` component and then trigger the `click` event
    on the `img` element. The `img` element is the first slide of the slider puzzle.
    The `swap()` method should be called so that the `indexesToSwap` reactive property
    has the index of the first image that's added. The `toBeGreaterThan()` method
    lets us check if the returned value of what we expected is greater than some number.
  prefs: []
  type: TYPE_NORMAL
- en: In the `'swaps the image order when 2 images are clicked'` test, we mount the
    `SliderPuzzle` component again. Then, we get `wrapper.vm.shuffledPuzzleArray`
    to get the indexes that are in the earlier array and destructure their values.
    We will use it later to compare the values from the same array to see if they
    have been swapped once we've clicked on two images.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we trigger the click on the slides with the `wrapper.get()` method to
    get the image element. Then, we call the `trigger()` method to trigger the click
    events. Then, we check if the `indexesToSwap` reactive property has `0` for its
    length after the swapping is done. Then, in the last three lines, we get the items
    from `wrapper.vm.shuffledPuzzleArray` again and compare their values. Since the
    entries are supposed to be swapped after the two slides, we have the following
    code to check if swapping is actually done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `''starts timer when start method is called''` test, we mount the `SliderPuzzle`
    component again. This time, we call the `start()` method to make sure that the
    timer is actually created with `setInterval`. We also check if the `setInterval`
    function is called with a function and 1,000 milliseconds. To let us test anything
    with timers easily, which includes testing anything that calls `setTimeout` or
    `setInterval`, we call `jest.useFakeTimers()` to let us mock those functions so
    that our tests won''t interfere with the operations of the other tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `toHaveBeenCalledTimes()` method checks whether a function that we passed
    into the `expect()` method is called a given number of times. Since we called
    `jest.useFakeTimers(),` `setInterval` is actually a spy of the real `setInterval`
    function rather than the real version. We can only use spies for a function with
    `expect` and `toHaveBeenCalledTimes` and `toHaveBeenCalledWith`. So, the code
    we have will work. The `toHaveBeenLastCalledWith()` method is used to check the
    argument that our function spy is called with the given kind of argument. We make
    sure the first argument is a function and that the second argument is 1,000 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `''stops timer when stop method is called''` test, we do something similar
    by mounting the component and then calling the `stop()` method. We make sure `clearInterval`
    is actually called when we call the `stop()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Next, we add the `'records record to local storage'` test. We make use of the
    `jest-localstorage-mock` library again to mock the `localStorage` dependency.
    We mount the `SliderPuzzle` component differently in this test. The second argument
    is an object that contains the `data()` method. This is the `data()` method that
    we have in the component's `options` object. We override the component's original
    reactive property values with what we pass in. The `currentDateTime` and `startDateTime`
    reactive properties are overridden so that we can set the date to what we want
    so that we can do the testing with them instead.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we call the `wrapper.vm.recordSpeedRecords()` method to test if the `localStorage.setItem()`
    method is called. We call the method that is in the mounted component. Then, we
    create the `stringifiedRecords` JSON string so that we can compare that with what
    is being called with `localStrorage.setItem`. `toHaveBeenCalledWith` only works
    with `localStorage.setItem` because we imported the `jest-localstorage-mock` library
    to create a spy from the actual `localStorage.setItem()` method. This lets Jest
    check whether the method is called or not with the given arguments.
  prefs: []
  type: TYPE_NORMAL
- en: To test if the timer is started when the **Start** button is clicked, we have
    the `'starts timer with Start button is clicked'` test. We just get the **Start**
    button by its ID with the `get()` method and trigger the `click` event on it.
    Then, we check that the `setInterval` function is called. Like with `localStorage`,
    we mock the `setInterval` function with the `jest.useFakeTimers()` method to create
    a spy from the actual `setInterval` function. This lets us check that it is called.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we have the `'stops timer with Quit button is clicked'` test to check
    if the `clearInterval` function is called if the **Quit** button is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have the `'shows the elapsed time'` test to mount the component
    with different values for the `currentDateTime` and `startDateTime` reactive properties.
    They are set to the values we want, and they will stay the way they are in the
    test. Then, to check if the `elapsedTime` computed property is displayed properly,
    we call the `wrapper.html()` method to return the rendered HTML in the wrapped
    component, and we check that it includes the elapsed time string we are looking
    for.
  prefs: []
  type: TYPE_NORMAL
- en: To clean up the mocks after each test so that we start afresh after each test,
    we call the `jest.clearAllMocks()` method to clear all the mocks after each test.
    The `afterEach` function takes a callback that is run after each test is done.
  prefs: []
  type: TYPE_NORMAL
- en: Running all the tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To run the tests, we run `npm run test:unit`. By doing this, we''ll see something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Results of our unit tests'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.4_B14405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – Results of our unit tests
  prefs: []
  type: TYPE_NORMAL
- en: Since all the tests passed, the code in our project is doing what we expect
    it to. It only takes around 4 seconds to run all the tests, which is much faster
    than testing our code manually.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked deeper into components by defining the computed properties
    in our components. Also, we added tests for our components so that we can test
    the parts of our components individually. With the Vue CLI, we added test files
    and dependencies easily within our app.
  prefs: []
  type: TYPE_NORMAL
- en: Inside our components, we can emit events that propagate to the parent component
    with the `this.$emit()` method. It took a string with the event name. The other
    arguments are the payloads that we want to pass from the parent component to the
    child components.
  prefs: []
  type: TYPE_NORMAL
- en: To add unit tests to our Vue 3 app and run the tests, we used the Jest test
    framework. Vue 3 adds its own specific APIs to Jest so that we can test Vue 3
    components with it. To test components, we mounted the component by using the
    `mount` and `shallowMount` functions. The `mount` function lets us mount the component
    itself, including the nested component. The `shallowMount` function only mounts
    the component itself without the child components. They both return a `wrapper`
    for our component so that we can use it to interact with the component to do the
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: We should make sure that our tests run in isolation. This is why we were mocking
    the external dependencies. We do not want to run any code that requires anything
    external to the tests and the project code to be available. Also, we had to make
    sure that we cleaned up any dependencies in our tests if needed. If there were
    any mocks, we had to clean them up so that they were not carried forward to another
    test. Otherwise, we may have tests that depend on other tests, which makes troubleshooting
    tests very difficult.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how to create a photo gallery app that
    saves data by sending the data we want to save to a backend API. We will introduce
    the use of Vue Router so that we can navigate to different pages.
  prefs: []
  type: TYPE_NORMAL
