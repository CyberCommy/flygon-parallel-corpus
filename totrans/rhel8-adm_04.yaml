- en: '*Chapter 3*: Basic Commands and Simple Shell Scripts'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have your first **Red Hat Enterprise Linux (RHEL)** system running,
    you want to start using it, practicing, and getting comfortable with it. In this
    chapter, we will review the basics of logging into the system, navigating through
    it, and getting to know the basics in terms of its administration.
  prefs: []
  type: TYPE_NORMAL
- en: The set of commands and practices described in this chapter will be used on
    many occasions when managing systems, so it is important to study them with care.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Logging in as a user and managing multi-user environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing users with the su command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the command line, environment variables, and navigating through the filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding I/O redirection in the command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering output with grep and sed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing, creating, copying, and moving files and directories, links, and hard
    links
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using tar and gzip
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating basic shell scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using system documentation resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging in as a user and managing multi-user environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Login** is the process during which a user identifies themselves in the system,
    usually by providing a **username** and **password**, a couple of pieces of information
    often referred to as *credentials*.'
  prefs: []
  type: TYPE_NORMAL
- en: The system can be accessed in many ways. The initial case for this, which we
    are covering here, is how a user accesses it when they install a physical machine
    (such as a laptop) or via the virtualization software interface. In this case,
    we are accessing the system through a *console*.
  prefs: []
  type: TYPE_NORMAL
- en: 'During installation, the user was created with an assigned password, and no
    graphical interface was installed. We will access the system in this case via
    its *text console*. The first thing we are going to do is to log in to the system
    using it. Once we start the machine and the boot process is completed, we will
    enter, by default, the multi-user text mode environment in which we are being
    requested to provide our **login**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Login process, username request'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_03_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – Login process, username request
  prefs: []
  type: TYPE_NORMAL
- en: 'The blinking cursor will let us know that we are ready to enter our username,
    in this case `user`, and then press *Enter*. A line requesting the password will
    appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Login process, password request'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_03_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – Login process, password request
  prefs: []
  type: TYPE_NORMAL
- en: 'We may now type the user''s password to complete the log in and, by pressing
    *Enter* on your keyboard, start a session. Note that no character will be displayed
    on screen when typing the password to avoid eavesdropping on it. This would be
    the session running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Login process, login completed, session running'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_03_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – Login process, login completed, session running
  prefs: []
  type: TYPE_NORMAL
- en: Now we are fully logged in to the system with the *credentials* for the user
    named `user`. This will define what we can do in the system, which files we can
    access, and even how much disk space we have assigned.
  prefs: []
  type: TYPE_NORMAL
- en: The console can have more than one session. To make that possible, we have different
    terminals through which we can log in. The default terminal can be reached by
    simultaneously pressing the *Ctrl + Alt + F1* keys. In our case, nothing will
    happen as we are already in that terminal. We could move to the second terminal
    by pressing *Ctrl + Alt + F2*, to the third one by pressing *Ctrl + Alt + F3*,
    and so on for the rest of the terminals (by default, six are allocated). This
    way, we can run different commands in different terminals.
  prefs: []
  type: TYPE_NORMAL
- en: Using the root account
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Regular users will not be able to make changes to the system, such as creating
    new users or adding new software to the whole system. To do so, we need a user
    with administrative privileges and for that, the default user is `root`. This
    user always exists in the system and its identifier (`0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous installation, we have configured the root password, making
    the account accessible through the console. To use it by logging in the system,
    we only need to type, in one of the terminals shown, right next to `root`, then
    hit *Enter*, and then provide its `root`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Login process, login completed as root'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_03_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – Login process, login completed as root
  prefs: []
  type: TYPE_NORMAL
- en: Using and understanding the command prompt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The command line that appears once we have logged in and are waiting for our
    commands to be typed and run is called the **command prompt**.
  prefs: []
  type: TYPE_NORMAL
- en: In its default configuration, it will show the *username* and *hostname* between
    brackets to let us know with which user we are working. Next, we see the path,
    in this case `~`, which is the shortcut for the `/home/user` for `user`, and `/root`
    for `root`)
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part and, probably the most important one, is the symbol before the
    prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: The `$` symbol is used for regular uses with no administrative privileges.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `#` symbol is used for root or once a user has acquired administrative privileges.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Be careful when using a prompt with the `#` sign as you will be running as an
    administrator and the system will, very likely, not stop you from damaging it.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have identified ourselves in the system, we are logged in and have a
    running session. It is time to learn how to change from one user to the other
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Changing users with the su command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have entered a **multi-user system**, it is logical to think that we will
    be able to change between users. Even when this can be done easily by opening
    a session for each, sometimes we want to act as other users in the same session
    we are in.
  prefs: []
  type: TYPE_NORMAL
- en: To do so, we can use the `su` tool. The name of the tool is usually referred
    to as **Substitute User**.
  prefs: []
  type: TYPE_NORMAL
- en: Let's use that last session in which we logged in as `root` and turn ourselves
    into the `user` user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before doing so, we can always ask which user I am logged in with by running
    the `whoami` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can make the change from `root` to `user`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have a session as the `user` user. We could finish this session by using
    the `exit` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As you may have seen, when we are logged in as `root`, we can act as any user
    without knowing its password. But how can we impersonate `root`? We can do so
    by running the `su` command and specifying the `root` user. In this case, the
    root user''s password will be requested:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As `root` is the user with the ID `0` and the most important one, when running
    `su` without specifying the user we want to turn to, it will default to turning
    ourselves into `root`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Each user can define several options in their own environment, such as, for
    example, their preferred editor. If we want to fully impersonate the other user
    and take their preferences (or `-` after the `su` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we can switch from `root` to `user`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can observe, it behaves as if a new login was done, but within the same
    session. Now, let's move on to managing the permissions for the different users
    in the system, as addressed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding users, groups, and basic permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Multi-user environments are defined by being able to handle more than one user
    simultaneously. But in order to be able to administer the system resources, there
    are two capabilities that help with the tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Groups**: Can aggregate users and provide permission for them in blocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each user has a *primary group*.
  prefs: []
  type: TYPE_NORMAL
- en: By default, a group is created for each user and assigned to it as a primary
    with the same name as the username.
  prefs: []
  type: TYPE_NORMAL
- en: '`ugo`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The whole system comes with a set of permissions assigned by default to each
    file and directory. Be careful when changing them.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a principle in UNIX that Linux inherited that is: *everything is a
    file*. Even when there may be some corner cases to this principle, it stays true
    on almost any occasion. It means that a disk is represented as a file in the system
    (in other words, like `/dev/sdb` mentioned in the installation), a process can
    be represented as a file (under `/proc`) and many other components in the system
    are represented as files.'
  prefs: []
  type: TYPE_NORMAL
- en: This means that, when assigning permissions to files, we can also assign permissions
    to many other components and capabilities implemented by them by virtue of the
    fact that, in Linux, everything is represented as a file.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: '**POSIX** stands for **Portable Operating System Interface** and is a family
    of standards specified by the IEEE Computer Society: [https://en.wikipedia.org/wiki/POSIX](https://en.wikipedia.org/wiki/POSIX).'
  prefs: []
  type: TYPE_NORMAL
- en: Users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Users are a way of providing security limits to people as well as programs
    running in a system. There are three types of users:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Regular users**: Assigned to individuals to perform their job. They have
    restrictions applied to them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Superuser**: Also referred to as ''''root." This is the main administrative
    account in the system and has full access to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System users**: These are user accounts usually assigned to running processes
    or ''''daemons'''' to limit their reach within the system. System users are not
    intended to log in to the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users have a number called the **UID (User Id)** that the system uses to internally
    identify each one of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We previously used the `whoami` command to reveal which user we were working
    with, but to get more information, we will use the `id` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also check on the information related to other user accounts in the
    system, even to get info about `root`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s take a look at the information we have received for `user` by running
    `id`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`uid=1000(user)`: The user ID is the numeric identifier of the user in the
    system. In this case, it is `1000`. Identifiers of 1000 and above are used in
    RHEL for regular users, whereas 999 and below are reserved for system users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gid=1000(user)`: The group ID is the numeric identifier for the principal
    group assigned to the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`groups=1000(user),10(wheel)`: These are the groups that the user belongs to,
    in this case, ''''user'''' with `sudo` tool (to be explained later).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023`: This is the
    SELinux context for the user. It will define several restrictions in the system
    by using **SELinux** (to be explained in depth in [*Chapter 10*](B16799_10_Final_SK_ePub.xhtml#_idTextAnchor143),
    *Keeping Your System Hardened with SELinux*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ID-related data is stored in the system in the `/etc/passwd` file. Please note
    that this file is very sensitive and is better managed by using the tools related
    to it. In case we want to edit it, we will do so by using `vipw`, a tool that
    will ensure (among other things) that only one admin is editing the file at any
    one time. The `/etc/passwd` file contains the info of each user per line. This
    is the line for `user`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Each field is separated by a colon, `:` in each line. Let''s review what they
    mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '`user`: The username assigned to the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x`: The field for the encrypted password. In this case, it shows as `x` because
    it has moved to `/etc/shadow`, which is not directly accessible by regular users,
    to make the system more secure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1000` (first one): *The UID* value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1000` (second one): *The GID* value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`user`: A description of the account.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/home/user`: The home directory assigned to the user. This will be the default
    directory (or folder if you prefer) that the user will work on and where their
    preferences will be stored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/bin/bash`: The command interpreter for the user. Bash is the default interpreter
    in RHEL. Other alternatives, such as `tcsh,` `zsh`, or `fish` are available to
    be installed in RHEL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`/srv/finance` directory. When the finance team has a new hire, in order to
    provide them with access to that folder, we only need to add the user assigned
    to this person to the `finance` group (this also works if someone leaves the team;
    we will only have to remove their account from the `finance` group).'
  prefs: []
  type: TYPE_NORMAL
- en: Groups have a number called the **GID** that the system uses to identify them
    internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data for groups is stored in the system in the `/etc/group` file. To edit
    this file in a way that ensures consistency and avoids corruption, we must use
    the `vigr` tool. The file contains one group per line with different fields separated
    by a colon, `:`. Let''s take a look at the line for the `wheel` group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s review what each field means:'
  prefs: []
  type: TYPE_NORMAL
- en: '`wheel`: This is the name of the group. In this case, this group is special
    as it is configured to be used, by default, as the one to provide admin privileges
    to regular users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x`: This is the group password field. It''s currently obsolete and should
    always contain `x`. It is kept for compatibility purposes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`10`: This is the GID value for the group itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`user`: This is the list of the users belonging to that group (separated by
    commas, such as `user1`, `user2`, and `user3`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The types of groups are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Primary group**: This is the group assigned to the files newly created by
    the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Private group**: This is a specific group, with the same name as the user,
    that is created for each user. When adding a new user account, a private group
    will be automatically created for it. It is very common that the ''''primary group''''
    and ''''private group'''' are one and the same.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wheel` group for enabling admin privileges to users, or the `cdrom` group
    for providing access to CDs and DVD devices in the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To review `root`. We will use the `ls` command to list files and we will review
    the permissions associated with them. We will learn more on how to change permissions
    in [*Chapter 5*](B16799_05_Final_SK_ePub.xhtml#_idTextAnchor081), *Securing Systems
    with Users, Groups, and Permissions*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once logged in to the system as `root`, we can run the `ls` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This shows the files present in the *root user home directory*, represented
    by `~`. In this case, it shows the *kickstart* file created by *Anaconda* that
    we reviewed in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could get the long version of the list by appending the `-l` option to `ls`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We see the following in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '`total 4`: This is the total space, in kilobytes, occupied in the disk by the
    files (note that we are using 4K blocks, so every file under that size will occupy
    a minimum of 4K).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-rw-------.`: These are the permissions assigned to the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The structure of the permissions can be seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Linux permissions structure'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_03_005.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – Linux permissions structure
  prefs: []
  type: TYPE_NORMAL
- en: 'The first character is for the *special permissions* that the file may have.
    If it is a regular file, and has no special permission (as in this case), it will
    appear as `-`:'
  prefs: []
  type: TYPE_NORMAL
- en: Directories will appear with `d`. Consider that in Linux, everything is a file,
    and directories are a file with special permissions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Links, usually symbolic links, will appear with a `l`. These behave like a shortcut
    to a file from a different directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special permissions to run a file as a different user or group, called `s`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A special permission so that the owner can only remove or rename the file, called
    the `t`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next three characters, `rw-`, are the permissions for the *owner*:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one, `r`, is the read permission assigned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second one, `w`, is the write permission assigned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third one, `x`, not present and shown as `-`, is the executable permission.
    Note that executable permission for directories means being able to enter them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next three characters, `---`, are for the *group* permissions and work the
    same way as the owner permission. In this case, no group access is granted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final three characters, `---`, are the permissions for *others*, which
    means users and/or groups do not show as the ones assigned to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`1`: This indicates the number of **links** (hard links) to this file. This
    is intended, among other things, so that we do not delete a file used in another
    folder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`root`: This indicates the (first-time) owner of the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`root`: This indicates the (second-time) group assigned to the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1393`: This indicates the size in bytes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dec 7 16:45`: This indicates the date and time that the file was last modified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`anaconda-ks.cfg`: This indicates the filename.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we list a directory (referred to in other systems as *folder*), the output
    will show the contents of the directory itself. We can list the info for the directory
    itself with the `-d` `option`. Let''s now take a look at `/etc`, the directory
    that stores the system-wide configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it's quite easy to obtain information pertaining to files and
    directories in the system. Let's now learn more about the command line and how
    to navigate the filesystem, in order to move around the system easily, in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using the command line, environment variables, and navigating through the filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen before, once we *log in* to the system, we have access to the
    command line. It's important to navigate the command line and the filesystem well
    in order to feel comfortable in the environment and make the most of it.
  prefs: []
  type: TYPE_NORMAL
- en: Command line and environment variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The command line is provided by a program also known as *interpreter* or **shell**.
    It will behave differently depending on which shell we use, but in this section,
    we will cover the most widespread shell used in Linux and the one provided by
    default in RHEL: **bash**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple trick to know which shell you are using is to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `echo` command will show on screen the content of whatever we give to it.
    Some content needs to be *substituted* or *interpreted*, like environment variables.
    The content to be substituted starts with the `$` symbol. In this case, we are
    telling the system to `echo` the content of the `SHELL` variable. Let''s use it
    for other variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'These are **environment variables** that can be customized for every user.
    Let''s now check these for a different user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, you can always refer to `$USER` and it will be substituted with
    the current user, or to `$HOME` and it will be substituted by the directory dedicated
    to the user, also known as the **home directory**.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are some of the most common and important *environment variables*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16799_03_Table_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `~/.bashrc` file is the one that should be edited in order to change these
    values for the current user.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating the filesystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now it's time to move ourselves into the `/`. The rest of the content of the
    system will hang from that folder and any other disk or device to be accessed
    will be assigned a directory to be accessed.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The *root directory* and the *home directory* for the *root user* are two different
    things. The *root user* has assigned, by default, the home directory, `/root`,
    whereas the *root directory* is the mother of all directories in the system and
    is represented by `/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see which directory we are in by running the `pwd` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can change directory by using the `cd` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As you already know, there is a `~`. We can use this shortcut to go to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Some shortcuts for directories include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**"~":** This is the home of the current user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**".":** This is the current directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**"..":** This is the parent directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**"-":** This is the directory used previously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More details on managing files and directories in Linux and RHEL are available
    in the *Listing, creating, copying, and moving files and directories, links, and
    hard links* section.
  prefs: []
  type: TYPE_NORMAL
- en: Bash autocomplete
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Shortcuts are a faster way to reach commonly used directories or relative references
    to the current working directory. However, bash includes some capabilities to
    reach other directories in a fast way, which is called **autocompletion**. It
    relies on the *Tab* key (the one with two opposing arrows at the very left of
    your keyboard, right above *Caps Lock*).
  prefs: []
  type: TYPE_NORMAL
- en: 'When reaching a folder or a file, we can hit *Tab* to complete its name. For
    example, if we want to go to the `/boot/grub2` folder, we type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, when we hit the *Tab* key, this will autocomplete it to `/boot/`, even
    adding the final `/` as it is a directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we type the first letter of the directory we want to go to, `grub2`, which
    is `g`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, when we hit the *Tab* key, this will autocomplete it to `/boot/grub2/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now we can hit *Enter* and go there.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we press *Tab + Tab* (pressing *Tab* twice during complete), this will show
    a list of available targets to complete, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'It can also be used to complete commands. We can type a letter, for example,
    `h`, hit *Tab + Tab*, and this will show all the commands starting with `h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This capability can be extended to help complete other parts of our commands
    by installing the `bash-completion` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Previous commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a way to recover the last commands run, which is referred to as **history**,
    in case you want to re-run them again. Just press the *up arrow* key (the one
    with an arrow pointing up) and the previous commands will appear on screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'If there are too many commands in your history, you can search through them
    quickly by running the `history` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run any of those commands again by using the `!` command. Just run
    `!` with the number of the command and it will run again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The command `!!` will run the very last command again, no matter which number.
  prefs: []
  type: TYPE_NORMAL
- en: Now it is time to enjoy your superfast command line. Let's learn more on the
    structure of directories in Linux, to know where to go in order to find things,
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Filesystem hierarchy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Linux has a standard, maintained by the *Linux Foundation*, that defines the
    **filesystem hierarchy** and is used in almost every Linux distribution, including
    *RHEL*. This standard is known as **FHS**, or **Filesystem Hierarchy Standard**.
    Let''s review here the most important folders in the standard and the system itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16799_03_Table_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Previous versions of RHEL used to have `/bin` for the essential binaries and
    `/usr/bin` for the non-essential ones. Now, the content of both resides in `/usr/bin`.
    They also used `/var/lock` and `/var/run` for what is running in `/run`. In addition,
    they used to have `/lib` for the essential libraries and `/usr/lib` for the non-essential
    ones, which were consolidated into a single directory, `/usr/lib`. And last but
    not least, `/sbin` is the directory for the essential super-user binaries, and
    `/usr/sbin` is the directory for the non-essential ones merged under `/usr/sbin`.
  prefs: []
  type: TYPE_NORMAL
- en: When partitioning, we may well be asking ourselves, where does the disk space
    go?
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the allocation values for a ''''minimal'''' installation of RHEL
    8 and the recommendations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16799_03_Table_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It's important to become familiar with the main directories in the system in
    order to make the best of them. It is recommended to navigate through the different
    system directories and look at what's in them in order to become comfortable with
    the structure. In the next section, we will look at how to perform redirections
    on the command line to learn more about command and file interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding I/O redirection in the command line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already run several commands to ascertain information about the system,
    such as listing files with `ls`, and we have got some information, **output**,
    from the running command, including, for example, filenames and file sizes. That
    information, or *output*, can be useful, and we want to be able to work with it,
    store it, and manage it properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'When talking about command *output* and also **input**, there are three sources
    or targets for them that need to be understood:'
  prefs: []
  type: TYPE_NORMAL
- en: '**STDOUT**: Also known as **Standard Output**, this is where commands will
    put their regular messages to provide information on what they are doing. In a
    terminal, on an interactive shell (like the ones we are using so far), this output
    will show on screen. This will be the main output managed by us.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**STDERR**: Also known as **Standard Error**, this is where the commands will
    put their error messages to be processed. In our interactive shells, this output
    will also be shown on screen together with the standard output unless we specifically
    redirect it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**STDIN**: Also known as **Standard Input**, this is where the commands get
    data to be processed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will mention these in the next paragraphs to better understand them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way in which command input and output is used requires the following operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`|`: A **pipe** operator is used to get the output from one command and make
    it the input of the next command. It *pipes* data from one command to another.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>`: A **redirect** operator is used to put the output of a command into a
    file. If the file exists, it will be overwritten.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<`: **Reverse redirect** can be applied to use a file as input to a command.
    Using it won''t delete the file used as input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>>`: A **redirect and add** operator is used to append the output of a command
    into a file. If the file does not exist, it will be created with the output provided
    to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2>`: A **redirect STDERR** operator will only redirect the output sent to
    the error message handler. (Note, no space should be included between ''''2''''
    and ''''>'''' in order for this to work!)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1>`: A **redirect STDOUT** operator will only redirect the output sent to
    the standard output and not to the error message handler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>&2`: A **redirect to STDERR** operator will redirect the output to the standard
    error handler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>&1`: A **redirect to STDOUT** operator will redirect the output to the standard
    output handler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To better understand these, we will go through a number of examples in this
    section and the following one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get a list of files and put it in a file. First, we list the files in
    `/var`, using the `-m` option to separate entries with commas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we run the command again, redirecting the output to the `/root/var-files.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, no output is shown on screen, but we will be able to find the
    new file in the current working directory, in this case, `/root`, the newly created
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the content of the file on screen, we use the `cat` command, intended
    to concatenate the output for several files, but regularly used for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also add to this file the content of `/var/lib`. First, we can list
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to append this content to the `/root/var-files.txt` file, we use the `>>`
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `/root/var-files.txt` file now contains both the comma-separated list for
    `/var` and for `/var/lib`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can try to list a non-existing directory to see an error being printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The output we see is an error, and it is treated differently by the system
    than the regular messages. We can try to redirect the output to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that using the standard redirect, with a command providing an error
    message, will show the error message, via `STDERR`, on screen and create an empty
    file. This is because the file contains the output of the common information messages
    which are shown via `STDOUT`. We can still capture the output of the error, redirecting
    `STDERR`, by using `2>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now we can redirect the standard output and the error output independently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we want to count the number of files and directories in `/var`. For that,
    we are going to use the `wc` command, which stands for *word count,* with the
    option `-w` to focus on only counting words. To do so, we will redirect the output
    of `ls` to it by using a *pipe* represented by `|`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use it to count the entries in `/etc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Pipes, `|`, are great for reusing the output of one command, and sending it
    to another command to process that output. Now we know more about using the more
    common operators to redirect input and output. There are several ways to process
    that output and we will see more examples in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering output with grep and sed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `grep` command is heavily used (and commonly mistyped) in system administration.
    It helps when finding a pattern in a line, whether in a file or via **standard
    input** (**STDIN**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do a recursive search of the files in `/usr` with `find` and put it
    in `/root/usr-files.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it''s a file 1.9 MB in size, and it isn''t easy to go through
    it. There is a utility in the system called `gzip` and we want to know which files
    in `/usr` contain the `gzip` pattern. To do so, we run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have found all the files with `gzip` under the `/usr` directory
    by creating a file with all the content and searching though it with `grep`. Could
    we do the same without creating the file? Sure we can, by using a *pipe*. We can
    redirect the output of `find` to `grep` and get the same output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In this command, the standard output from `find` was sent to `grep` to process
    it. We can even count the number of instances of files with `wc`, but this time
    using the `-l` option to count the lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We have now concatenated two pipes, one to filter the output and another one
    to count it. We will find ourselves doing this kind of plumbing often when searching
    for, and finding, information in the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some very common options for `grep` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-i`: for **ignore-case**. This will match the pattern whether it''s uppercase
    or lowercase or a combination thereof.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-v`: for **invert match**. This will show all entries that do not match the
    pattern being searched for.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-r`: for **recursive**. We can tell grep to search for a pattern in all the
    files within a directory, while going through all of them (if we have permission).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is a way to also filter columns in the output provided. Let''s say we
    have a list of files in our home directory, and we want to see the size of it.
    We run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s say we only want the size, which is the fifth column, of the content
    that has `files` in its name. We can use `awk` for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `awk` tool will help us to filter according to the correct column. It is
    very useful for finding identifiers in processes or for getting a specific list
    of data in from a long output.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Consider that `awk` is super powerful in processing output and that we will
    use the minimal capability for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could replace the separator with `-F` and get a list of available users
    in the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `awk` and `grep` tools are very common processing tools in the life of a
    Linux sysadmin, and it is important to understand them well in order to manage
    the output provided by the system. We have applied the base knowledge to filter
    the output received by row and column. Let's now move on to how to manage files
    in a system so that we can better handle the stored output we have just generated.
  prefs: []
  type: TYPE_NORMAL
- en: Listing, creating, copying, and moving files and directories, links, and hard
    links
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important to know how to **manage files and directories** (also known
    as folders) in a system from the command line. It will serve as a basis for managing
    and copying important data such as configuration files or data files.
  prefs: []
  type: TYPE_NORMAL
- en: Directories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by creating a directory to keep some working files. We can do
    so by running `mkdir`, short for **make directory**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Folders can be deleted with the `rmdir` command, short for **remove directory**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'However, `rmdir` will only delete empty directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'How can we delete a directory and all the other files and directories it contains
    using the remove (`rm`) command? First, let''s just create and remove a single
    file, `var-files.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'To remove a full directory branch, including its contents, we may use the `-r`
    option, short for **recursive**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Be very careful when using recursive mode when deleting as there is neither
    a recovery command for it nor a trash bin to keep files that have been removed
    in the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the review table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16799_03_Table_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we know how to create and delete directories in a Linux system, let's
    start copying and moving content.
  prefs: []
  type: TYPE_NORMAL
- en: Copying and moving
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s copy some files to play with them using the `cp` (for `awk` examples
    copied to our home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'To copy more than one file at the same time, we have used `*` sign. This works
    in a way in which specifying the files one by one, we can just type `*` for everything.
    We can also type the initial characters and then `*`, so let''s try it by copying
    some more files using globbing, first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see that running `ls TR*` shows only those files that start with `TR`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'It will work the same way with the file ending:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it shows only those files ending in `.md`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can copy a full branch of files and directories with the *recursive* option
    for `cp`, which is `-r`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The recursive option is very useful for copying complete branches. We could
    also move directories or files easily with the `mv` command. Let''s put all our
    new directories together into a newly created directory called `docs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that with `mv`, you do not need to use the recursive option to
    manage a full branch of files and directories. It can also be used to rename files
    and/or directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a special command for creating empty files, which is `touch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'When applied to an existing file or folder, it will update its access time
    to the current one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check the review table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16799_03_Table_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now we know how to copy, delete, rename, and move files and directories, even
    full directory branches. Let's now take a look at a different way to work with
    them – links.
  prefs: []
  type: TYPE_NORMAL
- en: Symbolic and hard links
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can have the same file in two places using **links**. There are two types
    of links:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hard links**: There will be two entries (or more) to the same file in the
    filesystem. The content will be written once to disk. Hard links, for the same
    file, cannot be created in two different filesystems. Hard links cannot be created
    for directories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Symbolic links**: A symbolic link is created pointing to a file or directory
    in any place in the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both are created using the `ln`, for *link*, utility.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now create hard links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Check the increasing number of references to the file (in bold in the previous
    example).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s create a symbolic link to a directory with `ln -s` (*s for symbolic*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Check how the symbolic link created is treated as a different type when listing
    it, as it starts with `l` for *link* (in bold in the previous example) instead
    of `d` for *directory* (also in bold in the previous example).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: When in doubt as to what to use, be it a hard link or a symbolic link, use the
    symbolic link as the default choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the review table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16799_03_Table_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, creating links and symbolic links is super simple and can help
    in having access to the same file or directory from different locations. In the
    next section, we will cover how to pack and compress a set of files and directories.
  prefs: []
  type: TYPE_NORMAL
- en: Using tar and gzip
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we want to pack a full directory, including files, into a single
    file for backup purposes or simply to share it more easily. The command that can
    help aggregate files into one is `tar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to install `tar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We can try by creating, as `root`, a backup of the `/etc` directory branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check the options used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-c`: Short for create. TAR can put files together but also unpack them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-f`: Short for file. We specify that the next parameter will be working with
    a file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can try to unpack it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check the new option used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-x`: for extraction. It unpacks a TAR file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please realize that we created a directory called `tmp` to work on and that
    we pointed to the parent directory of `tmp` by using the `..` shortcut (which
    refers to the parent directory to the current working directory).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s `gzip` to compress a file. We can copy `/etc/services` and compress
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Please note that when using `gzip`, this will compress the specified file, adding
    the `.gz` extension to it and the original file will not be kept. Also, be aware
    that the newly created file is 1/5 of the size of the original file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To recover it, we can run `gunzip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can combine the two of them, packing and compressing them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This way, we pack and compress in two steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `tar` command is smart enough to be able to perform packing and compression
    in a single step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check the new option:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-z`: This compresses the newly created tar file with `gzip`. It is also applicable
    to decompress.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We may want to review that same option while decompressing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it's very easy to pack and compress files using `tar` and `gzip`.
    There are other available compression methods with higher rations, such as `bzip2`
    or `xz`, that you may want to try, too. Now, let's move on to combine all the
    commands that we have learned into a powerful way to automate – by creating shell
    scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Creating basic shell scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a system administrator, or sysadmin, there will be times when you want to
    run a series of commands more than once. You can do this manually by running each
    command every time; however, there is a more efficient way to do so, by creating
    a **s****hell script**.
  prefs: []
  type: TYPE_NORMAL
- en: A shell script is nothing more than a text file with a list of commands to be
    run, and a reference to the shell that will interpret it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, we will not cover how to use a **text editor**; however, we will
    provide three recommendations for text editors in Linux that could help:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Nano**: This is probably the easiest text editor to use for beginners. Lean,
    simple, and straightforward, you may want to start by installing it and giving
    it a try.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vi** or **Vim**: Vi is the default text editor available in RHEL, included
    even in the minimal install, and in many Linux distributions. Even if you are
    not going to use it every day, it''s good to familiarize yourselves with the basics
    of it as it will be present in almost any Linux system you will use. **Vim** stands
    for **vi-improved**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Emacs**: This is probably the most advanced and complex text editor ever.
    It can do everything and beyond, including reading emails or helping with a bit
    of psychoanalysis via **Emacs Doctor**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can create our first shell script by editing a new file called `hello.sh`
    with the following line as its content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can run it by using the `bash` **command interpreter** with the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a different way to do this where we do not need to type `bash`. We
    can add an initial line referencing the interpreter, so the file content for `hello.sh`
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are changing the permissions so as to make it executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'And we run it just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: We have created our first shell script. Congratulations!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The commands, in order to be run in any working directory, must be in the path,
    as stated by the `$PATH` variable. If our command (or shell script) is not in
    one of the directories specified in the path, we will specify the running directory,
    in this case, using the `.` shortcut for the current directory and the `/` separator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use some variables in it. We can define a variable by simply putting
    the name of it and the value we want for it. Let''s try replacing the word `world`
    with a variable. To use it, we prepend the `$` symbol to the name of the variable
    and it will be used. The script will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run the script, obtaining the same output as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: To have more clarity, when using the value of the variable, we will put the
    name of it between curly braces, `{`''and ''`}`, and take this as a good practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous script will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Now we know how to create a basic script, but we may want to have a deeper control
    of it by using some programmatic capabilities, starting with loops. Let's go for
    it!
  prefs: []
  type: TYPE_NORMAL
- en: for loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What if we want to run the same command over a list of places? That's what a
    `for` **loop** is used for. It can help iterate over a set of elements, such as
    a list or a counter, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `for` loop syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`for`: To specify the iteration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`do`: To specify the action'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`done`: To close the loop'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can define a space-separated list to try it and iterate through it with
    our first `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run it. The output will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Using the `for` loop can be very interesting when `$(` and `)`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Backticks, `'`, can also be used to run a command and get its output as a list,
    but we will stick to the previous expression for clarity.
  prefs: []
  type: TYPE_NORMAL
- en: 'One example of the external command to be used can be `ls`. Let''s create the
    `txtfiles.sh` script with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Make it executable and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: You see how we can now iterate over a set of files, including, for example,
    changing their names, finding and replacing content in them, or simply making
    a specific backup of a selection of files.
  prefs: []
  type: TYPE_NORMAL
- en: We've seen several ways in which to iterate a list with the `for` loop, which
    can be very useful when it comes to automating tasks. Now, let's move on to another
    programmatic capability in scripts – conditionals.
  prefs: []
  type: TYPE_NORMAL
- en: if conditionals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, we may want to execute something different for one of the elements
    in a list, or if a `if` conditional for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `if` conditional syntax is `if`: to specify the condition.'
  prefs: []
  type: TYPE_NORMAL
- en: Conditions are usually specified between brackets, `[` and `]`.
  prefs: []
  type: TYPE_NORMAL
- en: '`then`: To specify the action'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fi`: To close the loop'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s change our previous `hello.sh` script to say `hello to Madrid` in Spanish,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a problem; it only says `hello to Madrid`. What happens if we want
    to run the previous code on the ones not matching the condition? That''s when
    we extend the conditional using `else` for the items that do not match. The syntax
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`else`: This is used as a `then` element when the condition is *not* matched.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And now we have an example of a conditional using `else`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'And now we can run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: As you see, it's simple to use the conditionals in a script and provide a lot
    of control on the conditions under which a command is run. We now need to control
    when something may not be running correctly. That's what the exit codes (or error
    codes) are for. Let's go for it!
  prefs: []
  type: TYPE_NORMAL
- en: Exit codes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a program is run, it provides an `$?`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at it by running `ls hello.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: When the program runs OK, the *exit code* is zero, `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens when we try to list a file that doesn''t exist (or run any other
    command incorrectly, or that is having issues)? Let''s try listing a `nonexistent`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: You see, the *exit code* is different to zero. We will go to the documentation
    and check the number associated with it to understand the nature of the issue.
  prefs: []
  type: TYPE_NORMAL
- en: When running a command in a script, check for the exit code and act accordingly.
    Let's now review where to find further information on the commands, such as exit
    codes or other options, in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using system documentation resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The system includes resources to help you while working with it and guide you
    to improve your sysadmin skills. This is referred to as the **system documentation**.
    Let''s check three different resources available by default in your RHEL installation:
    man pages, info pages, and other documents.'
  prefs: []
  type: TYPE_NORMAL
- en: Man pages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most common resource used to obtain documentation is `man`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Almost any utility installed in the system has a man page to help you use it
    (in other words, specifying all the options for the tools and what do they do).
    You can run `man tar` and check the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: You can see in it (navigate with the *arrow* keys, space bar, and/or *Page Up*
    and *Page Down*) and exit it by hitting the letter `q` (for *quit*).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are sections in the `man` page on related topics. It is pretty simple
    to search those by using the `apropos` command. Let''s see this for `tar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it matches not only `tar` but also `start`. This isn't perfect,
    but it can provide helpful information related to tar, such as `gpgtar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Man pages have a section. As you can see in the previous example, for `tar`,
    there are manual pages in two sections, one for the command-line utility (section
    1), and one for the archiving format (section 5):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'We can access the page in section 5 to understand the format by running the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can see the `tar format` page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: You can see that manual pages are a great resource for learning more about the
    typical commands being used. This is also a fantastic resource as regards the
    **Red Hat Certified System Administrator** exam. One recommendation is to review
    all man pages for the commands shown previously in this chapter, as well as for
    the forthcoming chapters. Consider man pages the main information resource in
    the system. Let's now review other information resources available.
  prefs: []
  type: TYPE_NORMAL
- en: Info pages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Info pages** are usually more descriptive than man pages and are more interactive.
    They help more in getting started on a topic.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can try to get `info` for the `ls` command by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the info page for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Info pages can *redirect to other topics, shown underlined,* and these can be
    followed by putting the cursor over them and hitting *Enter*.
  prefs: []
  type: TYPE_NORMAL
- en: As with man pages, press `q` to quit.
  prefs: []
  type: TYPE_NORMAL
- en: Please take some time to review the info pages for the main topics covered in
    this chapter (in several cases, info pages will not be available, but the ones
    that are could be very valuable).
  prefs: []
  type: TYPE_NORMAL
- en: What if we do not find a man or info page for a topic? Let's cover this in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Other documentation resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For other documentation resources, you can go to the `/usr/share/doc` directory.
    There, you will find other documents that come with the tools installed in the
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how many items we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: You can see that there are 219 directories available under `/usr/share/doc`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a good example, let''s enter the `bash` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s take a look at the `INTRO` file using `less` to read it (remember,
    you use `q` to quit):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: This is a good read for a better understanding of bash. Now you have a lot of
    documentation resources that you will be able to be use during your daily tasks
    as well as in the **RHCSA** exam.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned in this chapter how to log in to a system with a user and with
    `root`, understanding the basics of permissions and security. We are now also
    more comfortable using the command line with autocomplete, navigating through
    the directories and files, packing, and unpacking them, redirecting command output
    and parsing it, and even automating processes with shell scripts. More importantly,
    we have a way to obtain information on what we are doing (or want to do) available
    in any RHEL system with the included documentation. These skills are the basis
    of the upcoming chapters. Don't hesitate to revisit this chapter if you feel stuck
    or if your progress is not as fast as you thought.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it is time to extend your knowledge to encompass more advanced topics in
    the upcoming chapters. In the following chapter, you will be getting used to the
    *tools for regular operations*, in which you will review the most common actions
    taken when managing a system. Enjoy!
  prefs: []
  type: TYPE_NORMAL
