- en: Chapter 7. Applications, Tiles, Tasks, and Notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Windows Store applications are different from traditional desktop applications
    in a number of aspects. Store apps live inside a secure container, with well-defined
    ways of interacting with the outside world, such as other applications, the operating
    system, or something on the network. These apps are also imposed by several restrictions,
    unlike anything in the desktop app world. Knowing these restrictions and ways
    to handle them by cooperation with Windows, is key to a successful and well-behaving
    Windows Store application.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by examining the execution model of Store apps, and the way it differs
    from classic desktop apps. Then we'll take a look at some of the unique features
    of Store apps, such as live tiles and other notification mechanisms. Finally,
    we'll look at ways in which an application can do work even if it's not the currently
    running app, by using various forms of background tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Application lifecycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Store applications are managed by the Windows operating system with strict
    rules that need to be considered when developing apps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Only one app can be in the foreground at any single time (the notable exception
    being the "snap view": one app takes most of the screen, while another takes a
    width of 320 pixels; this is discussed in [Chapter 9](ch09.html "Chapter 9. Packaging
    and the Windows Store"), *Packaging and the Windows Store*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other apps are automatically suspended by Windows, meaning they get no CPU time;
    the memory they occupy, however, is preserved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If Windows detects shortage of memory, it may terminate the first suspended
    app; if memory is still tight, it will terminate the second suspended app, and
    so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These rules are there to ensure that the foreground application has full access
    to the CPU and other resources, while also conserving battery power as much as
    possible. The complete app lifecycle can be illustrated with the following state
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Application lifecycle](img/5022_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At first, an app is not running. Then the user launches the application, typically
    by clicking or tapping on its tile on the Start Screen. This causes the `Application::OnLaunched`
    virtual method to be invoked; this is where the app should initialize and present
    the main user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The default code provided by Visual Studio for the `OnLaunched` method creates
    a `Frame` element that becomes the `Content` of the current `Window` (the one
    and only application window). Then a call is made to `Frame::Navigate` with the
    type name of `MainPage`, which causes `MainPage` to appear as expected.
  prefs: []
  type: TYPE_NORMAL
- en: The application is now in the running state, and the user can interact with
    the app. If the user switches to another application by pressing *Alt* + *Tab*,
    or going to the Start Screen and activating another app tile (or switches to another
    app by swiping from the left), our app is no longer in the foreground. If after
    5 seconds, the user does not switch back to the app, it's suspended by the OS.
    Before that happens, the `Application::Suspended` event is fired. This is a chance
    for the app to save state, in case the app is terminated later. The app is given
    no more than 5 seconds to save state; if it takes longer, the app is terminated.
    Assuming all is well, the app is suspended.
  prefs: []
  type: TYPE_NORMAL
- en: 'The current state of the app can be viewed in **Task Manager**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Application lifecycle](img/5022_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To view the application's status in **Task Manager**, first select the **View**
    menu and then **Status Values,** and click on **Show suspended status** (it's
    off by default).
  prefs: []
  type: TYPE_NORMAL
- en: Once suspended, the application may be resumed because the user switched back
    to it. This causes the `Resuming` event to fire on the `Application` object. In
    most cases, the app has nothing to do, because the app was retained in memory,
    so nothing has been lost. In cases where the UI should refresh due to stale data,
    the `Resuming` event can be used for that (for example, an RSS reader would refresh
    data because the app could have been suspended for hours, or even days).
  prefs: []
  type: TYPE_NORMAL
- en: While suspended, the application may be terminated by Windows because of low
    memory resources. The application gets no notification that this happened; this
    makes sense, as the app cannot use any CPU cycles while it's suspended. If the
    user activates the app again, `OnLaunched` is called, providing the opportunity
    to restore state with the help of the `LaunchActivatedEventArgs::PreviousExecutionState`
    property. One possible value is `ApplicationExecutionState::Terminated`, indicating
    the app was closed from the suspended state, and so state restoration should be
    attempted.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Individual pages within the app may want to be notified when the app is about
    to be suspended or resumed. This can be done in a constructor of `Page` by accessing
    the global `Application` object with `Application::Current`. A typical suspension
    registration may look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Saving and restoring the state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If, and when, the application is suspended, it's the application's responsibility
    to save whatever state is needed, in case Windows decides to terminate the application
    before it's resumed. This is done in response to the `Application::Suspending`
    event that can be handled on the application level and/or the page level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have a movie review application that allows users to review movies.
    A simple UI may exist that looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Saving and restoring the state](img/5022_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If the user switches to another app, the app will be suspended after 5 seconds
    have elapsed and the user does not switch back. We can use the `Windows::Storage::ApplicationData`
    class to access a local settings store or a local folder (for more complex storage
    requirements) to save the state of the preceding `TextBox` elements so that it
    can be restored should the application be terminated unexpectedly by Windows.
    First, we need to register for the `Suspending` event in the `MainPage` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MovieReview` class represents a review (implements `INotifyPropertyChanged`
    as discussed in [Chapter 5](ch05.html "Chapter 5. Data Binding"), *Data Binding*),
    and the `TextBox` elements bind to its three properties. If the app is suspended,
    the following is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The code uses the `ApplicationData::LocalSettings` property (an `ApplicationDataContainer`
    object), which manages a collection of key/value pairs (with optional inner containers),
    exposed through the `Values` property.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The types that can be stored in this way are limited to the basic WinRT types,
    and do not include custom types, such as `MovieReview`. It's possible to create
    some code that serializes such an object to XML or JSON and then saves it as a
    string.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the application is indeed terminated, state needs to be restored. This can
    be done on the `Page::OnNavigatedTo` override, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: To test this, we can run the app without the Visual Studio debugger. However,
    if we need to debug the code, there is a slight problem. When the app is being
    debugged, it will never enter a suspended state. This is to allow the developer
    to switch to Visual Studio and look at code while the app is in the background
    and still be able to switch to it at any time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can force the app to go into suspension by using the Visual Studio toolbar
    button that allows suspending, resuming, and terminating the app (and invoking
    background tasks, as we''ll see in the section *Background tasks* later in this
    chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Saving and restoring the state](img/5022_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Determining application execution states
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the application is activated, it may be because it's being launched by
    the user (there are other options, such as implemented contracts, as we'll see
    in the next chapter). It's usually important to learn why the application has
    been closed the last time around. If it was terminated, state should have restored.
    If, on the other hand, it was closed by the user, perhaps the state should have
    cleared, as the user is expecting the app to start afresh.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can determine this previous state using the `LaunchActivatedEventArgs::PreviousExecutionState`
    property available on the application''s `OnLaunched` method override:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s useful to write the state to the `LocalSettings` container so that other
    entities (typically pages) can access this information after `OnLaunched` is done.
    This allows our restore code to query this state and act accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Enums are also forbidden from being stored directly, but can be cast to an `int`
    and then stored.
  prefs: []
  type: TYPE_NORMAL
- en: State store options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous code samples used the `ApplicationData::LocalSettings` property.
    This uses a store local to the machine (and the current user and application),
    meaning that on another device running Windows 8, even if the same user is logged
    in, the same state will not be available.
  prefs: []
  type: TYPE_NORMAL
- en: WinRT provides an alternative, which allows settings to roam across devices
    by being stored within the Microsoft cloud service using the `ApplicationData::RoamingSettings`
    property. Working with this property is exactly the same as with `LocalSettings`;
    it's automatically synchronized with the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Synchronization with the cloud can only work if the user has logged in to the
    system with his Microsoft ID (formerly Live ID), and not a "normal" username/password.
  prefs: []
  type: TYPE_NORMAL
- en: '`LocalSettings` and `RoamingSettings` are useful for simple key/value pairs.
    If more complex data needs to be stored, we can create a folder (`StorageFolder`
    object) that we can use by creating `StorageFile` objects, more folders, and so
    on, as needed. This is available by accessing other `ApplicationData` properties:
    `LocalFolder`, `RoamingFolder`, and `TemporaryFolder` (`TemporaryFolder` stores
    information until the app terminates, and is not usually useful for application
    state management).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Files stored in the local application store (`ApplicationData::LocalFolder`)
    can be accessed with a URI that starts with `ms-appdata:///local/` followed by
    the relative path of the file; replace `local` with `roaming` to access the roaming
    store. These URIs can be used in XAML, as well as in code.
  prefs: []
  type: TYPE_NORMAL
- en: Helper classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some of the Visual Studio 2012 project templates, such as Grid App, provide
    two classes that can help in state management: `SuspensionManager` and `LayoutAwarePage`.
    These provide the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Can manage a navigation pages stack, saved as XML in a local folder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LayoutAwarePage` must be used as the base page class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can save/restore this state automatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interested readers should refer to the source code for more information
    on these classes.
  prefs: []
  type: TYPE_NORMAL
- en: Live tiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the unique characteristics of Windows Store apps is the use of tiles
    on the Start Screen. These tiles can contain images and text, but these need not
    be constant and can change. Through various mechanisms to provide live and meaningful
    information, draw the user to tapping/clicking on the tile, to access the app
    itself. In this section, we'll take a look at creating and manipulating tiles.
  prefs: []
  type: TYPE_NORMAL
- en: Setting application tile defaults
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The defaults of an application tile can be set in the application manifest,
    which is easily accessible through the Visual Studio user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting application tile defaults](img/5022_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Two sizes of tiles are available, the standard and the wide. If a wide logo
    image is available, it will be shown by default and the user will be able to change
    that to a standard tile (and vice versa) by right clicking on the tile (or swiping
    from the bottom) and selecting the relevant option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting application tile defaults](img/5022_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The standard tile image should be 150 px x 150 px and the wide tile image should
    be 310 px x 150 px. If these sizes are not supplied, Visual Studio will issue
    a warning and the images will be stretched/shrunk as needed.
  prefs: []
  type: TYPE_NORMAL
- en: The **Short name** will appear on top of the tiles selected within the **Show
    name** combobox (**All Logos**, **No logos**, **Standard logo only**, and **Wide
    logo only**). The **Foreground text** option selects light or dark text and the
    background color selected will be used for transparent images (PNG files) and
    for some other dialogs, as the default background color.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An application should not define a wide tile unless the app plans to provide
    meaningful and interesting content within that tile. Just using a large static
    image is a bad idea; users will expect the tile to provide something more.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the tile's contents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A tile can be updated by the running application. The updated tile will retain
    its contents even if the application is closed. Updating a tile involves creating
    some XML that specifies parts of the tile, which can include images and text in
    various layouts. There are also peek tile options that alternate between two tile
    sets. The first thing we need to do is select an appropriate tile template from
    an extensive, predefined set of templates. Each template is represented by an
    XML string that needs to be sent as the actual update.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tile templates exist for standard and wide tiles; these are represented by
    the `Windows::UI::Notifications::TileTemplateType` enumeration. Here''s an example
    of the generic XML needed for a wide tile with one text item, known as `TileWideImageAndText01`
    (the enum value):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted element and inner text need to be updated with the required
    new content.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The complete template list and XML schemas can be found at [http://msdn.microsoft.com/EN-US/library/windows/apps/hh761491(v=vs.10).aspx](http://msdn.microsoft.com/EN-US/library/windows/apps/hh761491(v=vs.10).aspx).
  prefs: []
  type: TYPE_NORMAL
- en: 'After selecting the required template, we can retrieve the associated XML with
    the following code (no need to build the whole XML manually):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The returned value is a `Windows::Data::Xml::Dom::XmlDocument`, representing
    the resulting XML. Now, we need to tweak the XML with the required updates. In
    this example, we''ll change the image and text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The code uses the WinRT XML DOM API to manipulate the XML. The image is set
    to a local image, but remote images (`http://...`) work just as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step would be to create a tile updater for the app, build the tile
    notification and do the actual update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the resulting wide tile:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating the tile''s contents](img/5022_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding code updates the wide tile only, leaving the standard tile unchanged.
    To change the standard tile as well, we can add another `<binding>` element to
    the `<visual>` element, with the appropriate XML for the required standard tile.
    This will make both changes.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling cycle updates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One interesting feature of live tiles is the ability to cycle up to five tile
    updates, working with the last five by default. The following code will enable
    tile cycling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If a particular tile should be replaced (instead of the first update being dropped),
    a tile may be tagged with a unique value, using the `TileNotification::Tag` property,
    identifying the exact tile to replace.
  prefs: []
  type: TYPE_NORMAL
- en: Tile expiration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A tile can be set to expire at some point in the future, by setting the `TileNotification::ExpirationTime`
    property. When the time comes, the tile reverts to its default state.
  prefs: []
  type: TYPE_NORMAL
- en: Badge updates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **badge** is a small notification symbol, located at the lower-right part
    of a tile. It can be a number in the range 1 to 99, or one of a set of predefined
    glyphs. It's typically used to show a status, such as network connectivity (if
    applicable for the app) or the number of pending messages (in a messaging app).
  prefs: []
  type: TYPE_NORMAL
- en: 'Updating a badge is very similar to updating a tile—it''s based on an XML string
    that contains a single element (`<badge>`), manipulated to get the desired result.
    Here''s the required code that updates a badge with a numeric value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The variable `count` is used as the numeric value.
  prefs: []
  type: TYPE_NORMAL
- en: Creating secondary tiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The application tile (primary tile) can be accompanied by secondary tiles. These
    typically represent deep links into the application. For example, a weather app
    may use secondary tiles for extra locations where weather is important to update
    or a Store app can use secondary tiles as links to specific products.
  prefs: []
  type: TYPE_NORMAL
- en: In any case, the user is the only entity that can allow secondary tiles to actually
    be pinned to the Start Screen or unpinned from the Start Screen. Usually, some
    UI within the app allows the user to pin a secondary tile, but this can only happen
    if the user provides consent—otherwise the tile is not pinned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet creates a secondary tile and asks the user if he/she
    wants it pinned to the Start Screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SecondaryTile` constructor used by the preceding code accepts the following
    arguments in order (they can also be set using properties):'
  prefs: []
  type: TYPE_NORMAL
- en: A unique tile ID that can later be used to identify the tile (for unpinning
    purposes, for example)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A short name (required) that will show in the system-provided consent dialog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A display name (recommended)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tile activation arguments that help in determining what to do if the application
    is invoked through the secondary tile (more on that in a moment)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logo URI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Calling `SecondaryTile::RequestCreateAsync` presents a standard system dialog
    (based on the tile''s creation arguments), asking the user''s permission to actually
    create and pin the tile:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating secondary tiles](img/5022_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A secondary tile can be retrieved given its unique ID, by using a `SecondaryTile`
    constructor that accepts an ID only. Other options include calling the static
    `SecondaryTile::FindAllAsync` to get a list of all secondary tiles created by
    the app.
  prefs: []
  type: TYPE_NORMAL
- en: The `SecondaryTile::RequestDeleteAsync` method shows a system dialog, requesting
    the user to consent to a tile deletion.
  prefs: []
  type: TYPE_NORMAL
- en: Updating a secondary tile is done in much the same way as it is with the primary
    tile (tile and badge). The only difference is with the updater, created with `TileUpdateManager::CreateTileUpdaterForSecondaryTile`
    (for tile updates) and `BadgeUpdateManager::CreateBadgeUpdaterForSecondaryTile`
    (for badge updates).
  prefs: []
  type: TYPE_NORMAL
- en: Activating a secondary tile
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When a secondary tile is tapped or clicked, the application launches as usual.
    Since a secondary tile is supposed to provide a shortcut to a specific location
    within the app, this scenario must be recognized and handled in the `Application::OnLanuched`
    override. Here''s an example code that looks for arguments passed at launch time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The code assumes that `DeepPage.xaml` is the relevant page to show, in case
    a secondary tile activation is detected.
  prefs: []
  type: TYPE_NORMAL
- en: Using toast notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Toasts** are small pop-up windows that show important information pertaining
    to an application that may or may not be running at the time. It appears at the
    top-right corner of the screen—the user can tap (or click) on it to run or switch
    to the application, or the user can close (dismiss) the toast as being unimportant
    now, or if the user is not in front of the computer right now, the toast will
    be gone after a few seconds, making the user miss the toast altogether.'
  prefs: []
  type: TYPE_NORMAL
- en: Toasts are somewhat intrusive, as they pop up regardless of the currently executing
    application (the current app can be the classic desktop or even the lock screen).
    This means toasts should be used sparingly, where they really make sense. A typical
    usage is to notify the user for an incoming message in a chat app or a new e-mail.
  prefs: []
  type: TYPE_NORMAL
- en: Toast notifications can be turned off on an app by app basis, by selecting the
    **Settings** charm and then selecting **Permissions**. Toasts can also be disabled
    globally, by going to the **Windows PC** settings and selecting **Notifications**.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make toast notifications work, the app should declare in its manifest that
    it''s toast capable (the **Application UI** tab in the manifest view in Visual
    Studio):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using toast notifications](img/5022_07_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Raising a toast notification is somewhat similar to tiles. First, we select
    a predefined template using the `ToastTemplateType` enumeration and then build
    an appropriate XML based on that template (the content is available through the
    `ToastNotificationManager::GeTemplateContent` method). Next, we create a `ToastNotification`
    object, passing the final XML. Finally, we call `ToastNotificationManager::CreateToastNotifier()->Show`,
    passing the `ToastNotification` object.
  prefs: []
  type: TYPE_NORMAL
- en: Toast options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Toasts can be scheduled to a future point in time by using the `ScheduledToastNotification`
    class instead of `ToastNotification`. The second argument to the constructor is
    a `DateTime` value indicating when the toast should be raised. The `Show` method
    must be replaced with `AddToSchedule` for this to compile and work correctly.
  prefs: []
  type: TYPE_NORMAL
- en: A second constructor to `ScheduledToastNotification` provides a way to show
    a recurring toast, with a time interval between pop ups (between 1 minute and
    60 minutes) and a number of times to show the toast (1 to 5).
  prefs: []
  type: TYPE_NORMAL
- en: Toasts can be standard (showing for 7 seconds) or long (showing for 25 seconds).
    Long toasts are appropriate when there is a human on the other side of the toast,
    such as an incoming call. To set it up, a `duration` attribute must be set to
    `long` within the toast XML.
  prefs: []
  type: TYPE_NORMAL
- en: Toasts play a default sound effect when shown. This effect can be changed to
    one of the set of predefined sounds available in Windows for this purpose. Again,
    this is accomplished by adding an `audio` element, with an `src` attribute set
    to one of the predefined sound strings (check the documentation for a complete
    list).
  prefs: []
  type: TYPE_NORMAL
- en: Push notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we've seen, an application can set its tile (and optional secondary tiles)
    in any way that's reasonable; it can even update the tiles if new information
    is received. But what happens if the application is suspended? How can it update
    its tile? Worse, the application may not be running at all. How would its tile
    get updated? Imagine a news app that may want its tile to reflect recent news.
  prefs: []
  type: TYPE_NORMAL
- en: One way to do this is with push notifications. As the name suggests, the notifications
    are pushed by a server onto the device that may or may not be running the app
    at the time. This is in contrast to a pull model, where some part of the app polls
    some server for new information. Push notifications are energy efficient and don't
    require the app to do anything special (apart from first registering for notifications
    as we'll see in a moment) to get the notifications.
  prefs: []
  type: TYPE_NORMAL
- en: Push notification architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Push notifications involve several participants, the application being just
    one of them. The push notification itself is sent from a Microsoft-provided service,
    the **Windows Notification Service** (**WNS**) hosted on Windows Azure. The other
    major entity is an application server that has the logic, or is controlled appropriately,
    to actually initiate push notifications. In the news app example, this would be
    a server that receives news updates and then spreads them around using push notifications
    to all registered client apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'The push notifications architecture is summarized in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Push notification architecture](img/5022_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The basic steps to set up push notifications are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The Windows Store application must register to receive notifications. It uses
    a WinRT API to call WNS and request a unique channel URI that identifies this
    app (technically the primary tile) for this user on this device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: WNS returns a unique channel URI to the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The app needs to pass the unique channel URI and some unique client identifier
    to the application server. A unique client ID is usually required because the
    channel URI can expire and will have to be renewed. The client ID remains the
    identity as far as the app server is concerned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The application server stores a list of all registered clients with their channel
    URIs. Later, when a notification needs to be sent, it will loop over the list
    and send the notifications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The application server needs to authenticate with WNS and get an authentication
    token in return, to be used as part of the push notification payload. This is
    a one-time operation, but may need to repeat as the token may expire in the future.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, when the application server logic decides to send a push notification
    (or is instructed by some external management app), it sends the notification
    as an HTTP POST request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: WNS receives the request and does the actual push notification to the client
    device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A push notification can change a live tile (the primary tile or a secondary
    tile), change the badge, or make a toast notification appear. It can even send
    raw, application-specific notifications that can run a background task registered
    for the app (background tasks will be discussed later in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll see examples for implementing the preceding steps
    to get push notifications up and running.
  prefs: []
  type: TYPE_NORMAL
- en: Building a push notification application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step for receiving push notifications is to get a unique URI from
    WNS. This is a fairly simple operation, involving a single method call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The call to returns a `PushNoticationChannel` object that is stored for later
    use in the `_channel` member variable. These types reside in the `Windows::Networking::PushNotifications`
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to register this URI with the application server, so let's
    take a look at that server first.
  prefs: []
  type: TYPE_NORMAL
- en: The application server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The application server can be built with any server-side technology, within
    the Microsoft stack or outside it. A typical server will expose some kind of service
    that clients can connect to and register their unique URIs for push notification
    (and perhaps other) purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we''ll build a WCF service hosted in IIS that will expose an
    appropriate operation for this purpose. The example assumes that the server manages
    movie information and wants to notify registered clients that a new movie is available.
    The WCF service interface would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IMoviesService` has two operations (modelled as methods):'
  prefs: []
  type: TYPE_NORMAL
- en: '`RegisterForPushNotification` is used to enlist an interested client as a target
    for push notifications. It passes a `ClientInfo` object that has the unique channel
    URI (obtained from the previous step) and some unique client ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `AddNewMovie` operation will be called later by some controller application
    to indicate that a new movie is available and consequently to invoke the push
    operation (we'll look at that in a moment).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**WCF** (**Windows Communication Foundation**) is a .NET-based technology for
    writing services and service clients and is beyond the scope of this book, as
    it has no direct relation to Windows 8 Store apps. WCF will be used for the server-side
    code, as it''s fairly well-known and easy enough to use, at least for these purposes;
    the code, naturally, is written in C#.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing such a service must do is obtain an authentication token from
    WNS, so it can actually perform push notifications. The first step to achieve
    this is to register the Windows 8 application and obtain two pieces of information:
    a security ID and a secret key. With these information in hand, we can contact
    WNS and request a token. To register the app we have to browse to [https://manage.dev.live.com](https://manage.dev.live.com),
    log in with our Microsoft ID (formerly Live ID), click on **Create application**,
    enter some unique application name, and then click on **Yes**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The application server](img/5022_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The result is a **security ID** (**SID**) and a secret key:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The application server](img/5022_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ll copy these and store them as simple constant or static fields in the
    service class implementation. The application name itself must be copied to the
    application manifest (in the **Packaging** tab), with some other details outlined
    on the web page. To make some of this easier, right-click on the project, select
    **Store**, and then select **Associate App with Store**. This will enter most
    information to the correct locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The application server](img/5022_07_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The code to obtain the authentication token would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The code is fairly uninteresting. It uses the specific format required for the
    authentication procedure. The `WebClient` class provides a simple way in .NET
    to make HTTP calls. The result of the call is a string representation of a JSON
    object, which is deserialized by the `Newtonsoft.Json.JsonConvert` class. Finally,
    the `access_token` field is the actual token we need, saved in the static variable
    `_token`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`JsonConvert` is part of the free `Json.NET` package, which can easily be installed
    using Nuget (right-click on the project in Visual Studio, select **Manage Nuget
    packages…**, search for `Json.Net`, and click on **Install**.'
  prefs: []
  type: TYPE_NORMAL
- en: The `dynamic` C# keyword allows (among other things) untyped access to objects,
    by late binding to the actual member (if it exists). The compiler is happy to
    defer type checking to runtime, thus an unrecognized member throws a runtime exception,
    as opposed to the usual compile time error.
  prefs: []
  type: TYPE_NORMAL
- en: Now that a token is obtained, it can be used to send push notifications.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The authentication token can actually expire, which can be discovered by examining
    the response from an actual push notification `POST` request, looking for the
    `Token expired` value for the `WWW-Authenticate` header. In that case, just call
    `GetToken` again to get a new token.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the server is ready, the client app needs to register its unique channel
    URI with the application service.
  prefs: []
  type: TYPE_NORMAL
- en: Registering for push notifications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Theoretically, this step is easy. Just call the `RegisterForPushNotification`
    method on the service, pass the required arguments, and you're done. Unfortunately,
    this is not as easy as we would liked in C++.
  prefs: []
  type: TYPE_NORMAL
- en: The app needs to make the correct network call (typically over HTTP) to the
    service. The simplest HTTP calls are based on REST, so it will be simpler if our
    service is configured to accept REST over HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**REST** (**Representational State Transfer**) is beyond the scope of this
    book. For our purposes, it means encoding the information on the HTTP URL as simple
    strings, with more complex information passed with the request body. This is in
    contrast to more complicated protocols, such as SOAP.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The WCF service we created is configured to accept REST calls because of the
    `[WebInvoke]` attributes, setting the URL suffix for each request. This also requires
    configuring a service host to use the `WebHttpBinding` WCF binding and the `WebHttp`
    behavior. This is accomplished via the `MovieWorld.svc` file, where the service
    is declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `Factory` attribute is the important (non-default) part.
  prefs: []
  type: TYPE_NORMAL
- en: The next challenge is to make a REST (or any HTTP) call from the C++ client
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, at the time of writing, there is no easy way to use a WinRT class
    that can make HTTP calls, something along the lines of `WebClient` and `HttpClient`
    in .NET. The documentation recommends using the low-level `IXMLHTTPRequest2` COM
    interface for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Although it's certainly possible, it's not easy. Fortunately, Microsoft created
    a C++ wrapper class, `HttpRequest`, which does most of the work for us. I've copied
    the class into the project almost as it is (made one slight modification), so
    now it's much easier to make HTTP calls.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`HttpRequest` is implemented in the `HttpRequest.h` or `HttpRequest.cpp` files,
    part of the `MovieApp` project, available with the downloadable source for this
    chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the HTTP request to register the app for push notifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The body consists of a `ClientInfo` object, serialized as XML with the `Uri`
    element having the unique channel URI obtained in the first step. The client ID
    here is encoded as a constant `123` as an example; in a real app, this would be
    generated as something unique for the app on this machine for this user. The strange
    port number is the local port IIS that is listening on where my service is hosted.
    Again, in a real app, this would be over port 80 (regular HTTP) or 443 (HTTPS).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An alternative way to issue an HTTP request is by using the C++ REST SDK (Casablanca)
    library; this was published to CodePlex at the time these lines were written.
    This library allows (among other things) working with HTTP requests in an easy
    and customizable way, somewhat similar to the .NET `HttpClient` class. The SDK
    can be found at [http://casablanca.codeplex.com/](http://casablanca.codeplex.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Issuing the push notification
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When the application server gets a call to its `AddNewMovie` method (as part
    of some logic in the server itself, or because some management application invoked
    the operation), it needs to send push notifications to all registered clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SendPushTileNotification` method looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The body of the message is a regular XML tile. In this case, it includes two
    lines of text:'
  prefs: []
  type: TYPE_NORMAL
- en: The first contains the year the movie was published
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second includes the movie name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The notification is an HTTP `POST` request, based on the unique channel URI,
    with some specific headers that must be set correctly. Also, notice the use of
    the authentication token obtained earlier from WNS.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `await` C# keyword allows waiting for an asynchronous operation without
    blocking the calling thread. This is similar to our use of the task`<T>` class
    with the `then` method. C# still looks easier to use.
  prefs: []
  type: TYPE_NORMAL
- en: The type of notification can change to toast or badge by changing the `X-WNS-Type`
    header to `wns/toast` and `wns/badge` respectively. The body, naturally, must
    be modified accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The sample code for this chapter includes a project named `MovieManager` that
    is used to add new movies that generate push notifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the original application tile (left) and the tile after a push notification
    of a new movie:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Issuing the push notification](img/5022_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The recently available Windows Azure Mobile Services provide easier ways of
    maintaining push notification clients and sending the notifications themselves
    (and other useful capabilities). Mobile Services are outside the scope of this
    book, but more information can be found at [http://www.windowsazure.com/en-us/develop/mobile/](http://www.windowsazure.com/en-us/develop/mobile/).
  prefs: []
  type: TYPE_NORMAL
- en: Push notifications for secondary tiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Secondary tiles can also be targets for push notifications. The main difference
    is the way a unique channel URI is obtained by the client app. It uses `CreatePushNotificationChannelForSecondaryTileAsync`
    with the tile ID, instead of `CreatePushNotificationChannelForApplicationAsync`
    (both static methods of the `PushNotificationChannelManager` class).
  prefs: []
  type: TYPE_NORMAL
- en: Background tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Windows Store applications may be suspended when the user switches to another
    app. The app may still want some work to happen even while the app is suspended
    and even terminated. This is the job of background tasks.
  prefs: []
  type: TYPE_NORMAL
- en: What is a task?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **task** is just a class that implements the `Windows::ApplicationModel::Background::IBackgroundTask`
    interface, having just one method, `Run`. This class must be placed in a separate
    project from the main application, in a **Windows Runtime Component** type project.
    This is essential, as tasks run in a separate process, and thus cannot be bound
    with the main app (so they are not suspended if the main app is suspended).
  prefs: []
  type: TYPE_NORMAL
- en: The main application needs to reference the project where the task(s) are located,
    and indicate via its manifest that these are indeed its tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An application can have any number of tasks implemented in one or more Windows
    Runtime Component projects.
  prefs: []
  type: TYPE_NORMAL
- en: A task must have exactly one trigger, specifying what triggers the task execution.
    A task can also have zero or more conditions that must be specified for the trigger
    to be usable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Only one trigger can be associated with a task, but it's possible to register
    another task that runs the same code, but configured with a different trigger.
    This effectively creates a task that can run with multiple triggers.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and registering a task
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step for creating a task is to create a Windows Runtime Component
    project with a class that implements the `IBackgroundTask` interface, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to add a reference to the task component from the main application
    project. The last prerequisite is to add the task to the main application''s manifest.
    This is done in the **Declarations** tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating and registering a task](img/5022_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A background task declaration is selected with the appropriate task type, which
    roughly means trigger type, as will be used later for actual registration in code.
    We'll discuss triggers in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: The **Entry point** field must be set to the full class name implementing the
    background task (`Tasks::SimpleTask` in this case).
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is an entry in the manifest XML in the `<extensions>` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The main application must do the actual task registration on startup and it
    must do so only once. Registering a task with an existing task name throws an
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Registration involves the `BackgroundTaskBuilder` class and a trigger class
    with optional conditions. Here''s a piece of code registering the `SimpleTask`
    defined in the preceding code snippet to execute whenever an Internet connection
    is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: A trigger must be selected for a task; in this case, it's the generic `SystemTrigger`,
    based on a `SystemTriggerType` enumeration, which has values such as `InternetAvailable`,
    `UserPresent`, `UserAway`, `SmsReceived`, `TimeZoneChange`, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Conditions are optional; `SystemCondition` is currently the only one available,
    but it's generic as well, using the `SystemConditionType` enumeration. Values
    include `InternetAvailable`, `InternetUnavailable`, `UserPresent`, `UserNotPresent`,
    and others.
  prefs: []
  type: TYPE_NORMAL
- en: '`BackgroundTaskBuilder` holds the trigger and condition information, along
    with the task name and entry point. Then a call to `Register` does the actual
    registration with the system (returning a `BackgroundTaskRegistration` object).'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a task
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's use an application that allows the user to enter data, and that data is
    saved in the local folder. If the user is connected to the Internet, a background
    task should do some processing on the resulting files, such as uploading them
    to a server, doing some calculations, and so on. Eventually, the task will delete
    the files after being processed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s some simple code that the main app uses to save some data to files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The files are saved to a subfolder named `Movies` under the `LocalFolder`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tasks share the application''s local folder, effectively making it a communication
    mechanism. Here''s the task''s `Run` method implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The task begins by obtaining the `LocalFolder` location. Before the actual process
    begins, it obtains a *deferral* object by calling `IBackgroundTaskInstance::GetDeferral`.
    Why?
  prefs: []
  type: TYPE_NORMAL
- en: A task is normally considered done when the `Run` method terminates. If, however,
    the implementation invokes any asynchronous operations, the method will return
    to its caller sooner, making the task complete. Obtaining a deferral effectively
    holds off task completion until that time when a call to `BackgroundTaskDeferral::Complete`
    is made.
  prefs: []
  type: TYPE_NORMAL
- en: Next, comes the actual file processing. All the files in the `Movies` folder
    are enumerated using `StorageFolder::GetFilesAsync` and after each dummy processing,
    the file is deleted. Only then the entire task is done, and the deferral's `Complete`
    method can be invoked to indicate that the task is complete.
  prefs: []
  type: TYPE_NORMAL
- en: Task debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The available triggers and conditions are not easily satisfied in a development
    environment. We don't want to disconnect and reconnect the Internet; nor do we
    want to wait 15 minutes until a task with a `TimeTrigger` is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visual Studio provides a way to invoke a task at any point for debugging purposes.
    This functionality is located in the same toolbar button as suspension and resumption:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Task debugging](img/5022_07_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we place a breakpoint within the task's `Run` method, we can debug the task
    as usual. The `BackgroundTaskHost.exe` is the process instance that is hosting
    the application's tasks. This fact can be viewed in the debugger **Process** toolbar
    button or in Windows Task Manager.
  prefs: []
  type: TYPE_NORMAL
- en: Task progress and cancellation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A background task can run when the main app is running as well. One thing that's
    possible to do is indicate its progress from the background task's perspective.
    This is done using the `IBackgroundTaskInstance::Progress` property. If the main
    app is not running, nobody cares. If it is running, it can register for the `Progress`
    event (part of `IBackgroundTaskRegistration` that's returned upon successful registration
    of the task) and update the UI based on that progress.
  prefs: []
  type: TYPE_NORMAL
- en: When the task finishes, the `IBackgoundTaskRegistration::Completed` event fires
    so that the main app knows the task is done. If the main app is currently suspended,
    it will be notified when it resumes.
  prefs: []
  type: TYPE_NORMAL
- en: In some situations, Windows may cancel a running task. The `IBackgroundTaskInstance`
    exposes a `Canceled` event that a task can register for. If the task is cancelled,
    it must return within 5 seconds, or it will be terminated. The `Canceled` event
    provides a `BackgroundTaskCancellationReason` that specifies why the task was
    cancelled. Examples include `ServiceUpdate` (the main app is being updated) and
    `LoggingOff` (the user is logging off the system).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can use a Win32 event to notify our task that cancellation
    has been requested. First, we create the event object and register for the `Canceled`
    event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`_hCancelEvent` is a `HANDLE` type, created with `CreateEventEx`. Then the
    `Canceled` event is associated with a private `OnCancelled` method.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The classic Win32 API `CreateEvent` can't be used, as it's illegal in WinRT.
    `CreateEventEx` was introduced in Windows Vista, and can be considered as a superset
    of `CreateEvent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the task is being cancelled, we set the Win32 event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The task main processing code should examine the Win32 event and bail out as
    quickly as possible, if it''s signaled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Calling `WaitForSingleObject` with a zero timeout just examines the state of
    the event. If it's signaled, the return value is `WAIT_OBJECT_0` (otherwise, the
    return value is `WAIT_TIMEOUT`).
  prefs: []
  type: TYPE_NORMAL
- en: Playing background audio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some applications play audio, and users expect the audio to keep playing even
    if the user switches to another app; for example, a music playing app is expected
    to continue playing until told to stop by the user. A voice over IP app (such
    as Skype) is expected to maintain the other party's audio even if the user switches
    to another app. This is where the background audio task comes in.
  prefs: []
  type: TYPE_NORMAL
- en: Playing audio
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Audio playing can be easily achieved by using the `MediaElement` control (which
    can also play video). It should be placed somewhere in XAML so that it's part
    of a visual tree, although it has no visible parts when playing audio.
  prefs: []
  type: TYPE_NORMAL
- en: Actual playing is done by setting a URI to play using the `Source` property
    (or for files obtained from a `FileOpenPicker` by calling the `SetSource` method).
    Playing starts immediately unless the `AutoPlay` property is set to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Controlling playback is done with the `Play`, `Pause`, and `Stop` methods of
    `MediaElement`. Here''s an example of an audio file obtained from a `FileOpenPicker`.
    First, some basic UI for the `MediaElement` and playback control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnSelectedMediaFile` is implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Most of the code should be familiar by now. The filter of `FileOpenPicker` is
    set for MP3 files, and once selected, the call to `MediaElement::SetSource` readies
    the audio stream for playback.
  prefs: []
  type: TYPE_NORMAL
- en: 'Playing the stream is just a matter of calling `MediaElement::Play` at the
    `Play` button''s `Click` handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`OnPause` and `OnStop` are similarly implemented by calling `MediaElement::Pause`
    and `MediaElement::Stop` respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: Running the application now allows for selecting an MP3 file and playing it.
    Switching to another app, however, immediately stops playback.
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining background audio
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Making the application continue to play automatically in the background requires
    several steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the app manifest must be modified to indicate background audio is needed;
    this is done by adding a **Background Task** declaration and setting the **Audio**
    checkbox:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Maintaining background audio](img/5022_07_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The other required step is setting the **Start** page, as shown in the preceding
    screenshot. The next steps require adding some code:'
  prefs: []
  type: TYPE_NORMAL
- en: The `MediaElement::AudioCategory` property must be set to `AudioCategory::BackgroundCapableMedia`
    (for general background playback) or `AudioCategory::Communications` (for peer
    to peer communications, such as a chat).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register for static events of the `Windows::Media::MediaControl` class that
    indicate changes that may result from other applications using audio playback.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, we''ll change the `AudioCategory` property of the `MediaElement`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The result of this setting makes the app never enter suspension.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll register for the required events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'These events are fired by the system when the playback state changes due to
    a system-provided media control that is accessible with some keyboards and perhaps
    other gestures:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Maintaining background audio](img/5022_07_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Reacting to these events is not difficult. Here''s the code for the `PlayPressed`
    and `PlayPauseTogglePressed` events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The notifications are handled as commands for the app to play or pause playback
    as needed; correct implementation ensures consistent behavior across all audio
    playbacks on the system.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the events arrive on a thread pool thread, and since the `MediaElement`
    needs to be touched, the call must be marshalled to the UI thread using the `CoreDispatcher::RunAsync`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Handling the `PausePressed` and `StopPressed` events is similar.
  prefs: []
  type: TYPE_NORMAL
- en: Other events from the `MediaControl` class can be handled if appropriate, such
    as `NextTrackPressed` and `PreviousTrackPressed` .
  prefs: []
  type: TYPE_NORMAL
- en: Sound-level notifications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If a background app is playing audio and another foreground app starts playing
    audio, the system sends a `MediaControl::SoundLevelChanged` event to the background
    app. This event indicates what happened to the background app''s sound by looking
    at the `MediaControl::SoundLevel` property. Possible values are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Muted`: The app''s sound has been muted, so the app should pause its playback.
    This usually means a foreground app is playing audio.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Low`: The app''s sound level has gone low. This indicates a VoIP call came
    in, decreasing the app''s sound level. The app may want to pause playback until
    another `SoundLevelChanged` event fires that indicates full volume.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Full`: The app''s sound is at full volume. If the app was playing audio and
    had to pause it, now it''s time to resume playing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering for this event is optional, but can enhance the user experience
    and it indicates a well-behaving app.
  prefs: []
  type: TYPE_NORMAL
- en: Lock screen apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The lock screen (before a user logs in, or when the device is locked) allows
    for up to seven applications to be on it—these can have an icon (and even a text
    message); these apps are known as lock screen apps. The seven possible apps can
    be configured via control panel | **PC Settings** | **Personalize**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lock screen apps](img/5022_07_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Lock screen apps are considered more important by the system (because they
    are more important to the user), and consequently have some capabilities that
    cannot be obtained by non-lock screen apps. For example, some trigger types only
    work with lock screen apps:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TimeTrigger` can be used to do periodic work (minimum is 15 minutes).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PushNotificationTrigger` can be used to get a raw push notification that causes
    the task to execute (raw means any string, unrelated to tile, toast, or badge).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ControlChannelTrigger` can be used to keep a live connection to a remote server,
    even when the application is suspended; useful for Instant Messaging or video
    chat applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This last two trigger types make the task actually run inside the app process
    and not in the standard task hosting process.
  prefs: []
  type: TYPE_NORMAL
- en: There is actually another time-related trigger, `MaintenanceTrigger`. This one
    does not require a lock screen app, but it only functions if the device is connected
    to AC power. If it's disconnected, the task will not run. If it's disconnected
    while the task executes, the task will be cancelled.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make an application lock screen capable, a few things need to be set up:'
  prefs: []
  type: TYPE_NORMAL
- en: A wide logo must be set for the app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A badge logo must be set up as well; this is the default image that appears
    on the lock screen for the app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At least one background task must be declared (using the manifest's **Declarations**
    tab in Visual Studio) that uses a push notification trigger, a time trigger or
    a control channel trigger.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Lock screen notifications** option must be set to **Badge** or **Badge
    with Tile Text**:![Lock screen apps](img/5022_07_17.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requesting to set a lock screen app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the user can go to the app's settings and set it as a locked screen
    app, or go to the Windows personalization section and do the same. It's easier
    if the app asks the user (via a system-provided dialog), if it's ok for the app
    to become a lock screen app. This is accomplished with the `BackgroundExecutionManager::RequestAccessAsync`
    static method call. The result of the asynchronous call specifies whether the
    user accepted the suggestion or not (`BackgroundAccessStatus` enumeration).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the user denies, the dialog won't pop up when the application is run again;
    it will pop up again if the app is reinstalled.
  prefs: []
  type: TYPE_NORMAL
- en: Other common operations for lock screen apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lock screen apps typically perform the following operations during the app''s
    lifetime:'
  prefs: []
  type: TYPE_NORMAL
- en: Sending badge updates (shown on the lock screen)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending tile updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receiving and processing raw push notifications that are used to execute app-specific
    logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raising a toast notification (that's shown even on the lock screen)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The exact details of these operations are beyond the scope of this book (although
    the badge, tile, and toast update mechanisms are similar to those already discussed);
    more details can be found in the MSDN documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Background tasks limits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When executing, background tasks compete for CPU and network resources with
    the currently running foreground application, so they cannot run for an arbitrary
    length of time; the foreground app is the most important. Tasks are subject to
    the following constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: Lock screen app tasks get 2 seconds of CPU time every 15 minutes (actual running
    time, not wall clock time).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-lock screen apps receive 1 second of CPU time every 2 hours (again, actual
    running time).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network resources are unlimited when the device is running on AC power. Otherwise,
    some limitations may be in place depending on energy consumption.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tasks configured with `ChannelControlTrigger` or `PushNotificationTrigger` receive
    some resource guarantees, as they are deemed more important.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, there is a global pool of CPU and network resources that can be
    used by any application. This pool is refilled every 15 minutes. This means that
    even if a task needs more than 1 second to run (non-lock screen app), it may get
    the extra CPU time, provided the pool is not exhausted. Naturally, the task can't
    rely on this pool, as other tasks may have already exhausted it.
  prefs: []
  type: TYPE_NORMAL
- en: Background transfers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It should be clear at this point that a suspended application can't do anything
    by itself, unless it has some background tasks working on its behalf. One of the
    operations that an app may need to perform is a lengthy download or upload of
    files. If the app becomes suspended, the download or upload operations cannot
    proceed. If the app is terminated, whatever was already downloaded goes away.
    Clearly, there must be a better way.
  prefs: []
  type: TYPE_NORMAL
- en: WinRT provides a way to do background transfers (downloads and uploads) even
    if the app is suspended, by using a separate process to do the actual transfers
    (`BackgroundTransferHost.exe`). This capability allows the app to make a lengthy
    transfer without requiring the user to stay with the app for the entire transfer
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Example – downloading a file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s a simple example that starts a download operation targeted to a file
    in the user''s documents location (error handling omitted):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The code assumes `_url` is a `TextBox` where the user entered a URL for a file
    that he/she wants to download. First, the filename is created based on the end
    phrase of the URL after the last slash. Then, the file is created in the documents
    folder of the user. Note that to get this capability, it must be declared in the
    manifest, and for the documents library, at least one file extension must be selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example – downloading a file](img/5022_07_18.jpg)![Example – downloading
    a file](img/5022_07_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the `Video`, `Music`, and `Pictures` libraries, declaring file associations
    is not needed.
  prefs: []
  type: TYPE_NORMAL
- en: Next, a `BackgroundDownloader` instance is created, and a call to its `CreateDownload`
    is made, passing the URL to download and the target file. This call returns a
    `DownloadOperation` object, without the download actually being started. To start
    the download, `DownloadOperation::StartAsync` is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the download is away, it''s useful to know how it progresses. Here''s
    a revised code that sets up progress reporting (the difference is from the `StartAsync`
    call):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we''re actually looking at the result of `StartAsync`, returning
    an object implementing `IAsyncOperationWithProgress<DownloadOperation, DownloadOperation>`
    and we set up the `Progress` property with an appropriate delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `DownloadOperation::Progress` property returns a simple structure (`BackgroundDownloadProgress`)
    with fields such as `TotalBytesToReceive`, `BytesReceived`, and `Status` (`Running`,
    `Completed`, `Cancelled`, and so on). The preceding code uses these values for
    a `ProgressBar` control (`_progress`) and `TextBlock` (`_status`).
  prefs: []
  type: TYPE_NORMAL
- en: Note that the notification is not arriving on the UI thread, so any updates
    to the UI must be marshalled to the UI thread by using the `Page::Dispatcher`
    property (of the type `Windows::UI::Core::CoreDispatcher`) with a call to `RunAsync`
    that accepts a delegate that is guaranteed to execute on the UI thread.
  prefs: []
  type: TYPE_NORMAL
- en: If the app is terminated, the transfer stops as well, but the data downloaded
    so far is not lost. When the app is started again, its job is to look up all its
    incomplete transfers and resume them. This can be done by calling the static `BackgroundDownloader::GetCurrentDownloadsAsync`,
    getting back a list of those incomplete downloads, and then attaching to each
    one (for example, progress report) and, of course, resuming the downloads.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find a complete example of this in the Background Transfer sample available
    at [http://code.msdn.microsoft.com/windowsapps/Background-Transfer-Sample-d7833f61](http://code.msdn.microsoft.com/windowsapps/Background-Transfer-Sample-d7833f61).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Windows Store applications are unlike desktop applications in many ways. This
    chapter dealt with the application lifecycle—the app may get suspended and even
    terminated, all controlled by the OS.
  prefs: []
  type: TYPE_NORMAL
- en: Live tiles, badge updates, and toast notifications are some of the more unique
    features of Windows Store apps—desktop apps don't have these powers (although
    desktop apps can create their own toast-like pop ups). Used wisely, these can
    add a lot of traction to a Store app, luring the user into the app frequently.
  prefs: []
  type: TYPE_NORMAL
- en: Background tasks provide a way around the involuntary suspension/termination
    scenarios, so that some control is maintained even when the app is not in the
    foreground. Still, this is pretty restricted, to keep the main app responsive
    and maintain good battery life. Tasks are an important ingredient in non-trivial
    apps, and so should be used wisely.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll take a look at ways a Windows Store app can better
    integrate with Windows and indirectly communicate with other applications by implementing
    contracts and extensions.
  prefs: []
  type: TYPE_NORMAL
