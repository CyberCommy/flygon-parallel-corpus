- en: Configuring Microservices with Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''re moving into the practical and real-world area of microservices
    configuration. Configuration is a big part of building complex distributed systems.
    In general, configuration concerns any aspect of the system that the code should
    be aware of, but that isn''t encoded in the code itself. Here are the topics we
    will discuss in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is configuration all about?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing configuration the old-fashioned way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing configuration dynamically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring microservices with Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a solid understanding of the value
    of configuration. You will also have learned the many ways to configure software
    both statically and dynamically, as well as the special configuration options
    that Kubernetes provides (one of its best features). You will have also gained
    the insights and knowledge to benefit from the flexibility and control Kubernetes
    provides you as a developer and operator.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look at a lot of Kubernetes manifests and will extend
    the capabilities of Delinkcious. There will be no need to install anything new.
  prefs: []
  type: TYPE_NORMAL
- en: The code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As usual, the code is split between two Git repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code samples at [https://github.com/PacktPublishing/Hands-On-Microservices-with-Kubernetes/tree/master/Chapter05](https://github.com/PacktPublishing/Hands-On-Microservices-with-Kubernetes/tree/master/Chapter05)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the updated Delinkcious application at [https://github.com/the-gigi/delinkcious/releases/tag/v0.3](https://github.com/the-gigi/delinkcious/releases/tag/v0.3)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is configuration all about?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Configuration is a very overloaded term. Let''s define it clearly for our purpose
    here: configuration mostly refers to operational data that''s needed for computation.
    The configuration may be different between environments. Here are some typical
    configuration items:'
  prefs: []
  type: TYPE_NORMAL
- en: Service discovery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environment-specific metadata
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secrets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third-party configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feature flags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timeouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rate limits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various defaults
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, the code that processes the input data utilizes configuration data
    to control operational aspects of the computation, but not algorithmic aspects.
    There are special cases where, via configuration, you can switch between different
    algorithms at runtime, but that's crossing into gray areas. Let's keep it simple
    for our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: When considering configuration, it's important to think about who is supposed
    to create and update the configuration data. It may or may not be the developer
    of the code—for example, rate limits may be determined by a DevOps team member,
    but feature flags will be set by the developer. Also, in different environments,
    different people may modify the same value. You'll typically have the most restrictions
    in production.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration and secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Secrets are credentials that are used to access databases and other services
    (internal and/or external). Technically, they are configuration data, but in practice,
    because of their sensitivity, they often need to be encrypted at rest and controlled
    more carefully. It is common to have secrets stored and managed separately from
    regular configurations.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will consider only nonsensitive configuration. In the next
    chapter, we will discuss secrets in detail. Kubernetes also separates configuration
    from secrets at the API level.
  prefs: []
  type: TYPE_NORMAL
- en: Managing configuration the old-fashioned way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When I say the old-fashioned way, I mean pre-Kubernetes static configuration.
    But as you''ll see, the old-fashioned way is sometimes the best way, and is often
    well supported by Kubernetes too. Let''s go over the various ways to configure
    a program, consider their pros and cons, and when they are appropriate. The configuration
    mechanisms we will cover here are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: No configuration (convention over configuration)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command-line arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environment variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While Delinkcious is implemented mostly in Go, we will use different programming
    languages to demonstrate the configuration options just for fun and variety.
  prefs: []
  type: TYPE_NORMAL
- en: Convention over configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, you don''t really need configuration; the program can just make some
    decisions, document them, and that''s that. For example, the name of the directory
    of the output file could be configurable, but the program can just decide that
    it''s going to *output* and that''s that. The upside of this approach is that
    it is very predictable: you don''t have to think about configuration, and just
    by reading the code of the program, you know exactly what it does and where everything
    is supposed to be. The operators have very little work to do. The downside is
    that if more flexibility is needed, you have no recourse (for example, maybe there
    isn''t enough space on the volume the program is running on).'
  prefs: []
  type: TYPE_NORMAL
- en: Note that convention over configuration doesn't mean that there is no configuration
    at all. It means that you can reduce the amount of configuration when using convention.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a little Rust program that prints the Fibonacci sequence up to 100
    to the screen. By convention, it makes the decision that it will not go over 100\.
    You can''t configure it to print more or fewer numbers without changing the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Command-line flags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Command-line flags or arguments are a staple of programming. When you run your
    program, you provide arguments that the program uses to configure itself. There
    are pros and cons of using them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pros**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Very flexible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Familiar and available in every programming language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are established best practices for short and long options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Works well with interactive usage documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cons**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arguments are always strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Need to quote arguments that contain spaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Difficult to deal with multiline arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restrictions on the number of command-line arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restrictions on the size of each argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command-line arguments are often used for input in addition to configuration.
    The boundaries between input and configuration can be a little murky sometimes.
    In most cases, it doesn't really matter, but it can make it confusing to users
    that just want to pass their input to a program through a command-line argument
    and are presented with a large and confusing array of configuration options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a little Ruby program that writes the Fibonacci sequence up to a number that''s
    provided as a command-line argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Environment variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Environment variables are another favorite. They are useful when your program
    runs in an environment that may be set up by another program (or a shell script).
    Environment variables are typically inherited from the parent environment. They
    are also used for running interactive programs when the user always wants to provide
    the same option (or set of options) to the program. Instead of typing a long command
    line with the same options again and again, it is much more convenient to set
    an environment variable once (maybe even in your profile) and just run the program
    with no arguments. A good example is the AWS CLI, which allows you to specify
    many configuration options as environment variables (for example, `AWS_DEFAULT_REGION`
    or `AWS_PROFILE`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a little Python program that writes the Fibonacci sequence up to a
    number that is provided as an environment variable. Note that the `FIB_LIMIT`
    environment variable is read as a string and the program has to convert it into
    an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Configuration files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configuration files are particularly useful when you have a lot of configuration
    data, especially when that data has a hierarchical structure. In most cases, it
    would be too overwhelming to configure an application with tens or even hundreds
    of options via command-line arguments or environment variables. Configuration
    files have another advantage, which is that you can chain multiple configuration
    files. Often, applications have a search path where they look for configuration
    files, such as `/etc/conf`, and then the `home` directory and then the current
    directory. This provides a lot of flexibility since you have common configuration
    while you're also able to override some parts per user or per run.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration files are great! You should think about what format is best for
    your use case. There are many options. Configuration file formats follow trends,
    and every few years a new star shines. Let's review some of the older formats,
    as well as some of the newer ones.
  prefs: []
  type: TYPE_NORMAL
- en: INI format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'INI files were once all the rage on Windows. INI stands for **initialization**.
    Mucking around with `windows.ini` and `system.ini` to get something working was
    very common in the eighties. The format itself was very simple and included sections
    with sets of key–value pairs and comments. Here is a simple INI file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The Windows API has functions for reading and writing INI files, so a lot of
    Windows applications used them as their configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: XML format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'XML ([https://www.w3.org/XML/](https://www.w3.org/XML/)) is a W3C standard
    that was very popular in the nineties. It stands for **eXtensible Markup Language**,
    and it was used for *everything*: data, documents, APIs (SOAP), and, of course,
    configuration files. It is very verbose, and its main claim to fame is that it
    is self-describing and contains its own metadata. XML had schemas and many standards
    built on top of it. At some point, people thought that it would replace HTML (remember
    XHTML?). That''s all in the past now. Here is a sample XML configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: JSON format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JSON ([https://json.org/](https://json.org/)) stands for **JavaScript Object
    Notation**. It became popular with the growth of dynamic web applications and
    REST APIs. Its conciseness compared to XML was a breath of fresh air, and it quickly
    took over the industry. Its claim to fame is that it translates one-to-one to
    JavaScript objects. Here is a simple JSON file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: I personally never liked JSON as a configuration file format; it doesn't support
    comments, it is unnecessarily strict about extra commas at the end of arrays,
    and serializing dates and times to JSON is always a struggle. It is also pretty
    verbose, with all the quotes, parentheses, and the need to escape many characters
    (although it is not as bad as XML).
  prefs: []
  type: TYPE_NORMAL
- en: YAML format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You've seen a lot of YAML ([https://yaml.org/](https://yaml.org/)) already in
    this book, since the Kubernetes manifests are often written as YAML. YAML is a
    superset of JSON, but it also provides a much more concise syntax that is extremely
    human readable, as well as many more features, such as references, the autodetection
    of types, and support for aligned multiline values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a sample YAML file with more fancy features than you typically see
    in a normal Kubernetes manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: YAML is not as popular as JSON, but it slowly gathered momentum. Big projects
    such as Kubernetes and AWS CloudFormation use YAML (alongside JSON, because it's
    a superset) as their configuration format. CloudFormation added YAML support later;
    Kubernetes started with YAML.
  prefs: []
  type: TYPE_NORMAL
- en: It is currently my favorite configuration file format; however, YAML has its
    gotchas and critics, especially when you're using some of its more advanced features.
  prefs: []
  type: TYPE_NORMAL
- en: TOML format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enter TOML ([https://github.com/toml-lang/toml](https://github.com/toml-lang/toml))—**Tom's
    Obvious Minimal Language**. TOML is like an INI file on steroids. It is the least
    known of all the formats, but it has started to gain momentum since it is used
    by Cargo, Rust's package manager. TOML is between JSON and YAML on the expressiveness
    spectrum. It supports autodetected data types and comments, but it's not as powerful
    as YAML. That said, it is the easiest for humans to read and write. It supports
    nesting mostly via dot notation as opposed to indentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a TOML file; see how readable it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Proprietary formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some applications just come up with their own formats. Here is a sample configuration
    file for an Nginx web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: I don't recommend inventing yet another poorly conceived configuration format
    for your application. Between JSON, YAML, and TOML you should find the sweet spot
    between expressiveness, human readability, and familiarity. Also, there are libraries
    in all languages to parse and compose those familiar formats.
  prefs: []
  type: TYPE_NORMAL
- en: Don't invent your own configuration format!
  prefs: []
  type: TYPE_NORMAL
- en: Hybrid configuration and defaults
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have reviewed the primary configuration mechanisms:'
  prefs: []
  type: TYPE_NORMAL
- en: Convention over configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command-line arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environment variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These mechanisms are not mutually exclusive. Many applications will support
    some and even all of them. Very often, there will be a configuration resolution
    mechanism where a configuration file has a standard name and location, but you
    will still be able to specify a different configuration file via an environment
    variable and override even that for a specific run using a command-line argument.
    You don't have to look very far. Kubectl is a program that looks for its configuration
    file in `$HOME/.kube` by default; you can specify a different file via the `KUBECONFIG` environment
    variable. You can specify a special config file for a particular command by passing
    the `--config` command-line flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking of which, kubectl uses YAML as its configuration format as well. Here
    is my Minikube configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Kubectl supports multiple clusters/contexts in the same config file. You can
    switch between them via `kubectl use-context`; however, many people who work regularly
    with multiple clusters don't like to keep them all in the same config file, and
    prefer to have a separate file for each cluster and then switch between them using
    the `KUBECONFIG` environment variable or by passing `--config` on the command-line.
  prefs: []
  type: TYPE_NORMAL
- en: Twelve factor app configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Heroku was one of the pioneers of cloud platform as a service. In 2011, they
    published the 12 factor methodology for building web applications. It's a pretty
    solid approach, and was very innovative at the time. It also happened to be the
    best way to build applications that could be deployed easily on Heroku itself.
  prefs: []
  type: TYPE_NORMAL
- en: For our purposes, the most interesting part of their website is the config section,
    which can be found at [https://12factor.net/config](https://12factor.net/config).
  prefs: []
  type: TYPE_NORMAL
- en: In short, they recommend that web services and applications always store the
    configuration in environment variables. This is a safe but somewhat limited guideline.
    It means that the service has to be restarted whenever a configuration changes,
    and suffers from the general limitations of environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: Later, we will see how Kubernetes supports configuration as environment variables
    and configuration as configuration files, as well as a few special twists. But
    first, let's discuss dynamic configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Managing configuration dynamically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, the configuration options we have discussed have been static. You have
    to restart and, in some cases (such as with embedded configuration files), redeploy
    your service to change its configuration. The nice thing about restarting your
    service when the configuration changes is that you don't have to worry about the
    impact of the new configuration changes on the in-memory state and the processing
    of in-flight requests because you're starting from scratch; however, the downside
    is that you lose all your in-flight requests (unless you are using a graceful
    shutdown) and any warmed-up caches or one-time initialization work, which could
    be substantial. You can mitigate this somewhat, though, by using rolling updates
    and blue-green deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding dynamic configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dynamic configuration means that the service keeps running with the same code
    and the same in-memory state, but it can detect that the configuration has changed,
    and will dynamically adjust its behavior according to the new configuration. From
    the operator's perspective, when the configuration needs to change, they can just
    update the central configuration store and don't need to force a restart/redeployment
    of a service whose code didn't change.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to understand that this is not a binary choice; some configuration
    may be static, and when it changes, you must restart the service, but some other
    configuration items may be dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: Since dynamic configuration can change the behavior of the system in a way that
    is not captured by source control, it's a common practice to keep a history and
    audit of who changed what and when. Let's look at when you should use dynamic
    configuration and when you shouldn't!
  prefs: []
  type: TYPE_NORMAL
- en: When is dynamic configuration useful?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dynamic configuration is useful in the following cases:'
  prefs: []
  type: TYPE_NORMAL
- en: If you just have a single instance of your service, then restarting means a
    mini-outage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have feature flags that you want to switch back and forth quickly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have services where initialization or dropping in-flight requests is
    expansive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your service doesn't support advanced deployment strategies, such as rolling
    updates, or blue-green or canary deployments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When redeploying a new configuration file may pull in unrelated code changes
    from source control that are not ready for deployment yet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When should you avoid dynamic configuration?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: However, dynamic configuration is not a panacea for all situations. If you want
    to play it totally safe, then restarting your service when configuration changes
    makes things easier to comprehend and analyze. That being said, microservices
    are often simple enough that you can grasp all the implications of configuration
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following situations, it may be better to avoid dynamic configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: Regulated services where configuration change must go through a vetting and
    approval process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Critical services where the low risk of static configuration trumps any benefit
    of dynamic configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A dynamic configuration mechanism doesn't exist and the benefits don't justify
    the development of such a mechanism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Existing system with a large number of services where the benefits of migration
    to a dynamic configuration doesn't justify the cost
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced deployment strategies provide the benefits of dynamic configuration
    with static configuration and restarts/redeployments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The added complexity of keeping track of and auditing configuration changes
    is too high
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remote configuration store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the options for dynamic configuration is a remote configuration store.
    All service instances can periodically query the configuration store, check whether
    the configuration has changed, and read the new configuration when it does. Possible
    options include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Relational databases (Postgres, MySQL)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key–value stores (Etcd, Redis)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shared filesystems (NFS, EFS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, if all/most of your services already work with a particular type
    of store, it is often simpler to put your dynamic configuration there. An anti-pattern
    is to store the configuration in the same store as the service-persistent store.
    The problem here is that the configuration will be spread across multiple data
    stores, and some configuration changes are central. It will be difficult to manage,
    keep track of, and audit configuration changes across all services.
  prefs: []
  type: TYPE_NORMAL
- en: Remote configuration service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A more advanced approach is to create a dedicated configuration service. The
    purpose of this service is to provide a one-stop shop for all configuration needs.
    Each service will only have access to its configuration, and it's easy to implement
    control mechanisms for each and every configuration change. The downside of a
    configuration service is that you need to build it and maintain it. It can become
    a **single point of failure** (**SPOF**) too, if you're not careful.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have covered the many options for system configurations in great
    detail. Now, it's time to study what Kubernetes brings to the table.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring microservices with Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With Kubernetes or any container orchestrator, you have an interesting mix
    of configuration options. Kubernetes runs your containers for you. There is no
    way to set different environment options and command-line arguments for a specific
    run because Kubernetes decides when and where to run your container. What you
    can do is embed configuration files in your Docker image or change the command
    it is running; however, that means baking a new image for each configuration change
    and deploying it to your cluster. It''s not the end of the world, but it''s a
    heavyweight operation. You can also use the dynamic configuration options I mentioned
    earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: Remote configuration store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remote configuration service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, Kubernetes has some very neat tricks when it comes to dynamic configuration.
    The most innovative dynamic configuration mechanism is ConfigMaps. You can also
    get much fancier with custom resources. Let's dive in.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Kubernetes ConfigMaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ConfigMaps are Kubernetes resources that are managed by Kubernetes per namespace,
    and can be referenced by any pod or container. Here is the ConfigMap for the `link-manager`
    service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `link-manager` deployment resource imports it into the pod by using the
    `envFrom` key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The effect of this is that the key–value pairs in the ConfigMap''s `data` section
    are projected as environment variables when the `link-manager` service runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how Argo CD visualizes that the `link-manager` service has a ConfigMap.
    Note the top box named `link-service-config`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b71de303-e97d-4664-a197-b5c73ba0ac54.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can even drill down and inspect the ConfigMap itself from the Argo CD UI
    by clicking on the ConfigMap box. Very slick:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9bb535b3-a36d-4b39-ac03-0f0f9932b31a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that since the ConfigMap is consumed as environment variables, this is
    static configuration. If you want to change any of it, you''ll need to restart
    the service. In Kubernetes, this can be done in a couple of ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Killing the pods (the replica set of the deployment will create new pods)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting and recreating the deployment (this has the same effect, but you don't
    need to kill pods explicitly)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying some other change and redeploying
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see how the code uses it. This code can be found at [svc/link_manager/service/link_manager_service.go](https://github.com/the-gigi/delinkcious/blob/14c91f1c675dea9729d80876a3798897b925712a/svc/link_service/service/link_service.go#L37):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `os.Getenv()` standard library function gets `PORT` and `MAX_LINKS_PER_USER`
    from the environment. This is great because it allows us to test the service outside
    of the Kubernetes cluster and still configure it properly. For example, the link
    service end-to-end test—which is designed for local testing outside of Kubernetes—sets
    the environment variables before launching the social graph manager and the `link-manager`
    services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've looked at how Delinkcious uses ConfigMaps, let's move on to the
    nuts and bolts of working with ConfigMaps.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and managing ConfigMaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kubernetes gives you multiple ways to create ConfigMaps:'
  prefs: []
  type: TYPE_NORMAL
- en: From command-line values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From one or more files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From a whole directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By directly creating a ConfigMap YAML manifest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the end, all ConfigMaps are a set of key–value pairs. What the keys and
    values are depends on the method of creating the ConfigMap. When playing with
    ConfigMaps, I find it useful to use the `--dry-run` flag so that I can see what
    ConfigMap will be created before committing to actually creating it. Let''s look
    at some examples. Here is how to create a ConfigMap from command-line arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This method should be used mostly for playing around with ConfigMaps. You have
    to specify each config item individually with a cumbersome `--from-literal` argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a ConfigMap from a file is a much more viable method. It works well
    with the GitOps concept, where you can keep a history of the source configuration
    files that are used to create your ConfigMaps. We can create a very simple YAML
    file called `comics.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s create a ConfigMap from this file using the following command
    (well, just a dry `run`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s interesting here is that the entire contents of the file are mapped
    to a single key: `comics.yaml`. The value is the entire contents of the file.
    The `|+` in YAML means that the following multiline block is one value. If we
    add additional `--from-file` arguments, then each file will have its own key in
    the ConfigMap. Similarly, if the argument to `--from-file` is a directory, then
    each file in the directory becomes a key in the ConfigMap.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s look at a manually constructed ConfigMap. It''s not that difficult
    to do this: just add a bunch of key–value pairs under the `data` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created dedicated `SUPERHERO` and `VILLAIN` keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how pods can consume these ConfigMaps. The pod gets its environment
    from the `env-config` ConfigMap. It executes a command that watches the values
    of the `SUPERHERO` and `VILLAIN` environment variables and every two seconds echos
    the current values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The ConfigMap must be created before the pod is started!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `kubectl` command is super useful for checking the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the values match the ConfigMap. But what happens if we change
    the ConfigMap? The `kubectl edit configmap` command lets you update an existing
    ConfigMap in your editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve changed the superhero and villain to Batman and Joker. Let''s verify
    the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The new values are there. Let''s check our pod logs. Nothing should change
    because the pod consumes the ConfigMap as environment variables that can''t be
    changed from the outside while the pod is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we delete and recreate the pod, the picture is different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'I saved the best for last. Let''s look at some dynamic configuration in action.
    The pod named `some-other-pod` is consuming the ConfigMap called `file-config`
    as a file. First, it creates a volume called `config-volume` that gets populated
    from the `file-config` ConfigMap. Then, this volume is mounted into `/etc/config`.
    The command that''s running is simply watching the `/etc/config/comics` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the `file-config` ConfigMap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: It has a key called `comics` (the filename), and the value is a multiline YAML
    string with superhero and villain entries (`Doctor Strange` and `Thanos`). When
    all is said and done, the contents of the comics key under the ConfigMap `data`
    section will be mounted inside the container as the `/etc/config/comics` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s verify this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This is looking good so far. Now for the main attraction. Let''s change the
    contents of the ConfigMap to the superhero Wonder Woman and villain Medusa. We''ll
    use the `kubectl apply` command this time instead of deleting and recreating the
    ConfigMap. The ConfigMap is updated properly, but we also get a warning for our
    efforts (it''s OK to ignore this):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note the preceding annotation. It's interesting that it stores the last applied
    change, which is available in the data and not the previous values for historical
    context.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's check the logs again *without* restarting the pod!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Yes, this has been a great success! The pod now prints the updated configuration
    information with no need to restart.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have demonstrated how dynamic configuration works using
    ConfigMaps mounted as files. Let's look at what we should do when the configuration
    needs of large-scale systems are developed by multiple teams over long periods
    of time.
  prefs: []
  type: TYPE_NORMAL
- en: Applying advanced configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For large-scale systems with lots of services and lots of configuration, you
    may want to have services that consume multiple ConfigMaps. This is separate from
    the fact that a single ConfigMap may contain multiple files, directories, and
    literal values, in any combination. For example, each service may have its own
    specific configuration, but it might also use some shared libraries that need
    to be configured as well. In this scenario, you can have one ConfigMap for the
    shared library and a separate ConfigMap for each service. In this case, the services
    will consume both their ConfigMap and the shared library's ConfigMap.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common scenario is to have different configuration for different environments
    (development, staging, and production). Since in Kubernetes each environment typically
    has its own namespace, you need to be creative here. ConfigMaps are scoped to
    their namespace. This means that even if your configuration across environments
    is identical, you still need to create a copy in each namespace. There are various
    solutions that you can use to manage this proliferation of configuration files
    and Kubernetes manifests in general. I will not get into the details of these,
    and will just mention some of the more popular options here in no particular order:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Helm**: [https://helm.sh/](https://helm.sh/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kustomize**: [https://kustomize.io/](https://kustomize.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jsonnet**: [https://jsonnet.org/articles/kubernetes.html](https://jsonnet.org/articles/kubernetes.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ksonnet**: [https://github.com/ksonnet/ksonnet](https://github.com/ksonnet/ksonnet)
    (not maintained anymore)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also build some tooling yourself to do this. In the next section, we'll
    look at another alternative, which is very cool but more complicated—custom resources.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes custom resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes is a very extensible platform. You can add your own resources to
    the Kubernetes API and enjoy all the benefits of the API machinery, including
    kubectl support to manage them. Yes, it's that good. The first thing you need
    to do is define a custom resource, also known as a CRD. The definition will specify
    endpoints on the Kubernetes API, the version, scope, kind, and the names that
    are used to interact with resources of this new type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a superheroes CRD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Custom resources are available from all namespaces. The scope is relevant when
    constructing the URL from which it will be available and when deleting all objects
    from a namespace (a namespace scope CRD will be deleted with its namespace).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create some superhero resources. The `antman` superhero has the same
    API version and kind that is defined in the superheroes CRD. It has a name in
    `metadata`, and `spec` is totally open. You can define whatever fields you want
    there. In this case, the fields are `superpower` and `size`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check out the Hulk. It''s very similar, but also has a color field in
    its `spec`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create the whole gang, starting with the CRD itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s examine them with `kubectl`. We can use the short name, `hr`, here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also check the details of the superheroes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This is cool, but what can you do with custom resources? Well, a lot. If you
    think about it, you get a free CRUD API with CLI support and reliable persistent
    storage. Just invent your object model and create, get, list, update, and delete
    as many custom resources as you want. But it goes much further: you can have your
    own controller that watches over your custom resources and takes action when needed.
    This is actually how Argo CD works, as you can see from the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: How does that help with configuration? Since custom resources are available
    across the cluster, you can use them for shared configuration across namespaces.
    CRDs can serve as centralized remote configuration services, as we discussed earlier
    in the *Dynamic configuration* section, but you don't need to implement anything
    yourself. Another option is to create a controller that watches over these CRDs
    and then copies them to proper ConfigMaps for each namespace automatically. You
    are only limited by your imagination with Kubernetes. The bottom line is that
    for large complicated systems where managing configuration is a large endeavor,
    Kubernetes gives you tools to scale your configuration. Let's turn our attention
    to one aspect of configuration that often causes a lot of difficulties on other
    systems—service discovery.
  prefs: []
  type: TYPE_NORMAL
- en: Service discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kubernetes has built-in support for service discovery, without any additional
    work having to be done on your part. Each service has an endpoints resource that
    Kubernetes keeps up to date with the addresses of all the backing pods for that
    service. Here are the endpoints for a single node Minikube cluster. Note how each
    pod has its own IP address, even though there is only one physical node. This
    demonstrates the vaunted flat networking model of Kubernetes. Only the Kubernetes
    API server has a public IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Normally, you don't deal directly with the endpoints resource. Each service
    is automatically exposed to other services in the cluster via both DNS and environment
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: If you deal with the discovery of external services running outside the Kubernetes
    cluster, then you're on your own. A good approach could be to add them to a ConfigMap
    and update it when those external services need to change. If you need to manage
    secret credentials to access those external services (which is very likely), it's
    best to put those in Kubernetes secrets, which we will cover in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed everything related to configuration, not including
    secret management. First, we considered classic configuration, and then we looked
    at dynamic configuration, focusing on remote configure stores and remote configuration
    services.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we discussed Kubernetes-specific options and in particular ConfigMaps.
    We went over all the ways a ConfigMap can be created and managed. We also saw
    how a pod can consume a ConfigMap as either environment variables (static configuration)
    or as configuration files in mounted volumes that get updated automatically when
    the corresponding ConfigMap is modified by an operator. Finally, we looked at
    even more powerful options, such as custom resources, and discussed the special
    yet very important case of service discovery. At this point, you should have a
    clear picture of configuration in general, and the available options to configure
    microservices either traditionally or in Kubernetes-specific ways.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at the crucial topic of security. Microservice-based
    systems that are deployed in Kubernetes clusters often provide essential services
    and manage critical data. Securing both the data and the system itself is, in
    many cases, a top priority. Kubernetes provides multiple mechanisms across different
    layers to assist in building secure systems when following best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some resources for you to use so that you can understand the fine
    details of the concepts and mechanisms we discussed in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**12 Factor Apps**: [https://12factor.net/](https://12factor.net/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Program Configuration in Python**: [http://www.drdobbs.com/open-source/program-configuration-in-python/240169310](http://www.drdobbs.com/open-source/program-configuration-in-python/240169310)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Building a dynamic configuration service**: [https://www.compose.com/articles/building-a-dynamic-configuration-service-with-etcd-and-python/](https://www.compose.com/articles/building-a-dynamic-configuration-service-with-etcd-and-python/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extending Kubernetes (video)**: [https://www.youtube.com/watch?v=qVZnU8rXAEU](https://www.youtube.com/watch?v=qVZnU8rXAEU)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
