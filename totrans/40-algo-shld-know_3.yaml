- en: Recommendation Engines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*![](assets/b4fc1c9d-6a64-4b2a-853a-d10b5a53826a.png)*Recommendation engines
    are a way of using information available about user preferences and product details
    to provide informed recommendations. The objective of a recommendation engine
    is to understand the patterns of similarities among a set of items and/or to formulate
    the interactions between the users and items.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter starts with presenting the basics of recommendation engines. Then,
    it discusses various types of recommendation engines. Next, this chapter discusses
    how recommendation engines are used to suggest items and products to different
    users and the various limitations of recommendation engines. Finally, we will
    learn to use recommendation engines to solve a real-world problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following concepts are discussed in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing recommendation engines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of recommendation engines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the limitations of recommendation systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Areas of practical application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A practical example—creating a recommendation engine to recommend movies to
    subscribers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be able to understand how to use recommendation
    engines to suggest various items based on some preference criteria.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by looking into the background concepts of recommendation engines.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing recommendation systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recommendation systems represent the methods that researchers originally developed
    to predict items that a user is most likely to be interested in. The ability of
    recommendation systems to give personalized suggestions on items makes them perhaps
    the most important technology in the context of the online purchasing world.
  prefs: []
  type: TYPE_NORMAL
- en: When used in e-commerce applications, recommendation engines uses sophisticated
    algorithms to improve the shopping experience for shoppers and allows service
    providers to customize products according to the preferences of the users.
  prefs: []
  type: TYPE_NORMAL
- en: In 2009, Netflix offered 1 million dollars to anyone who could provide an algorithm
    that could improve its existing recommendation engine (Cinematch) by more than
    10%. The prize was won by BellKor's Pragmatic Chaos team.
  prefs: []
  type: TYPE_NORMAL
- en: Types of recommendation engines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Generally, there are three different types of recommendation engines:'
  prefs: []
  type: TYPE_NORMAL
- en: Content-based recommendation engines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collaborative filtering engines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hybrid recommendation engines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content-based recommendation engines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basic idea of the content-based recommendation engine is to suggest items
    similar to those in which the user has preceding shown interest. The effectiveness
    of content-based recommendation engines is dependent on our ability to quantify
    the similarity of an item to others.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look into the following diagram. If **User 1** has read **Doc 1**, then
    we can recommend **Doc 2** to the user, which is similar to **Doc 1:**
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/085cbec3-1d5a-4bc1-9b87-52474dfa09c4.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, the problem is how to determine which items are similar to each other.
    Let's look into a couple of methods of finding similarities between different
    items.
  prefs: []
  type: TYPE_NORMAL
- en: Finding similarities between unstructured documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One way of determining the similarities between different documents is by first
    processing the input documents. The resultant data structure after processing
    unstructured documents is called a **Term Document Matrix** (**TDM**), which is
    shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e9f0d053-8d92-424c-8fec-1bea05859e38.png)'
  prefs: []
  type: TYPE_IMG
- en: A TDM has all of the glossary of words as rows and all of the documents as the
    columns. It can be used to establish which documents are similar to the other
    documents based on the selected distance measure. Google News, for example, suggests
    news to a user based on its similarity to a news item the user has already shown
    interest in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have a TDM, there are two ways of quantifying the similarity between
    the documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using frequency counts**: This means that we assume that the importance of
    a word is directly proportional to the frequency of each word. This is the simplest
    way of calculating importance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using TFIDF** (short for **T****erm Frequency–Inverse Document Frequency**):
    This is a number that calculates the importance of each word in the context of
    the problem we are trying to solve. It is a multiple of two terms:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Term Frequency** (**TF**): This is the number of times a word or a term appears
    in a document. Term frequency directly correlates with the importance of a word.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inverse Document Frequency** (**IDF**): First, **Document Frequency** (**DF**)
    is the number of documents containing the term we are searching for. As the opposite
    of DF, IDF gives us the measure of uniqueness a word represents and correlates
    that with its importance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As TF and IDF both quantify the importance of a word in the context of the problem
    we are trying to solve, their combination, TF-IDF, is a good measure of the importance
    of each word and is a more sophisticated alternative to using simple frequency
    counts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a co-occurrence matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This method is based on the assumption that if two items are bought together
    most of the time, then they are likely to be similar or at least belong to the
    same category of items that are usually purchased together.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if people are using shaving gel and a razor together most of the
    time, then if someone buys a razor, it makes sense to suggest that person will
    buy shaving gel as well*.*
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s analyze the historical buying patterns of these four users:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Razor** | **Apple** | **Shaving cream** | **Bike** | **Hummus** |'
  prefs: []
  type: TYPE_TB
- en: '| Mike | 1 | 1 | 1 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Taylor | 1 | o | 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Elena | 0 | 0 | 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| Amine | 1 | 0 | 1 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: 'This will create the following co-occurrence matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Razor** | **Apple** | **Shaving cream** | **Bike** | **Hummus** |'
  prefs: []
  type: TYPE_TB
- en: '| Razor | - | 1 | 3 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Apple | 1 | - | 1 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Shaving cream | 3 | 1 | - | 1 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Bike | 1 | 0 | 1 | - | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Hummus | 1 | 1 | 2 | 1 | - |'
  prefs: []
  type: TYPE_TB
- en: The preceding co-occurrence matrix summarizes the likelihood of buying two items
    together. Let's see how we can use it.
  prefs: []
  type: TYPE_NORMAL
- en: Collaborative filtering recommendation engines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The recommendations from collaborative filtering are based on the analysis
    of the historical buying patterns of users. The basic assumption is that if two
    users show interest in mostly the same items, we can classify both users as similar.
    In other words, we can assume the following:'
  prefs: []
  type: TYPE_NORMAL
- en: If the overlap in the buying history of two users exceeds a threshold, we can
    classify them as similar users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at the history of similar users, the items that do not overlap in the
    buying history become the basis of future recommendations through collaborative
    filtering.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, let''s look at a specific example. We have two users,  **Mike**
    and **Elena**, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e1b17be1-78f8-46da-bcba-8a3912708c84.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Both Mike and Elena have shown interest in exactly the same documents, **Doc1**
    and **Doc2**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on their similar historical patterns, we can classify both of them as
    similar users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If Elena now reads **Doc3**, then we can suggest **Doc3** to Mike as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that this strategy of suggesting items to the users based on their history
    will not always work.
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume that Elena and Mike showed interest in **Doc1**, which was about
    photography (because they share a love of photography). Also, both of them showed
    interest in **Doc2**, which was about cloud computing, again, because both of
    them have an interest in the subject. Based on collaborative filtering, we classified
    them as similar users. Now Elena starts reading **Doc3**, which is a magazine
    on women's fashion. If we follow the collaborative filtering algorithm, we will
    suggest Mike read it, who may not have much interest in it.
  prefs: []
  type: TYPE_NORMAL
- en: Back in 2012, the American superstore, Target, was experimenting with the use
    of using collaborative filtering for recommending products to buyers. The algorithm
    classified a father similar to his teen-aged daughter based on their profiles.
    Target ended up sending a discount coupon for diapers, baby formula, and crib
    to the father. He was not aware of his daughter's pregnancy.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the collaborative filtering algorithm does not depend on any other
    information and is a standalone algorithm, based on the changing behaviors of
    users and collaborative recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: Hybrid recommendation engines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have discussed content-based and collaborative-filtering-based recommendation
    engines. Both types of recommendation engines can be combined to create a hybrid
    recommendation engine. To do so, we follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Generate a similarity matrix of the items.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate preference matrices of the users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate recommendations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look into these steps one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a similarity matrix of the items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In hybrid recommendation, we start by creating a similarity matrix of items
    using content-based recommendation. This can be done by using the co-occurrence
    matrix or by using any distance measure to quantify the similarities between items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that we currently have five items. Using content-based recommendations,
    we generate a matrix that captures the similarities between items and looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/506040b2-df72-412f-bad9-9061bc10a49c.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's see how we can combine this similarity matrix with a preference matrix
    to generate recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: Generating reference vectors of the users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Based on the history of each of the users of the system, we will produce a preference
    vector that captures those users' interests.
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume that we want to generate recommendations for an online store named
    *KentStreetOnline*, which sells 100 unique items. KentStreetOnline is popular
    and has 1 million active subscribers. It is important to note that we need to
    generate only one similarity matrix with dimensions of 100 by 100\. We also need
    to generate a preference vector for each of the users; this means that we need
    to generate 1 million preference vectors for each of the 1 million users.
  prefs: []
  type: TYPE_NORMAL
- en: Each entry of the performance vector represents a preference for an item. The
    value of the first row means that the preference weight for **Item 1** is **4**.
    For example, the value of the second row means that there is no preference for
    **Item 2**.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is graphically shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c159ced5-502a-4f5e-9092-b364e75b7b15.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's look into how we can generate recommendations based on the similarity
    matrix, S, and the user preference matrix, U.
  prefs: []
  type: TYPE_NORMAL
- en: Generating recommendations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make recommendations, we can multiply the matrices. Users are more likely
    to be interested in an item that co-occurs frequently with an item that they gave
    a high rating to:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Matrix[S] x Matrix[U] = Matrix[R]*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This calculation is shown graphically in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ce30323d-894b-4b7a-b4c9-65adb8a387bd.png)'
  prefs: []
  type: TYPE_IMG
- en: A separate resultant matrix is generated for each of the users. The numbers
    in the recommendation matrix, *Matrix[R]*, quantify the predicted interest of
    a user in each of the items. For example, in the resultant matrix the fourth item
    has the highest number, 58\. So this item is highly recommended for this particular
    user.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look into the limitations of different recommender systems.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the limitations of recommender systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recommendation engines use predictive algorithms to suggest recommendations
    to a bunch of users. It is a powerful technology, but we should be aware of its
    limitations. Let's look into the various limitations of recommendation systems.
  prefs: []
  type: TYPE_NORMAL
- en: The cold start problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is obvious that, for collaborative filtering to work, we need to have historical
    data about user preferences. For a new user, we may not have any data, so our
    user similarity algorithm will be based on assumptions that may not be accurate.
    For content-based recommendations, we may not have the details about the new items
    right away. This requirement of having data about items and users to generate
    high-quality recommendations is called the **cold start problem**.
  prefs: []
  type: TYPE_NORMAL
- en: Metadata requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Content-based methods require explicit item descriptions to measure similarity.
    Such explicitly-detailed descriptions may not be available, affecting the quality
    of the predictions.
  prefs: []
  type: TYPE_NORMAL
- en: The data sparsity problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Across an enormous number of items, a user will have rated only a few items,
    resulting in a very sparse user/item rating matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon has around a billion users and a billion items. Amazon's recommendation
    engine is said to have the sparsest data for any recommendation engine in the
    world.
  prefs: []
  type: TYPE_NORMAL
- en: Bias due to social influence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Social influence can play an important role in recommenders. Social relations
    can be seen as an influencing factor on a user's preferences. Friends tend to
    purchase similar items as well as give similar ratings.
  prefs: []
  type: TYPE_NORMAL
- en: Limited data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A limited number of reviews makes it difficult for recommender systems to accurately
    measure user similarities.
  prefs: []
  type: TYPE_NORMAL
- en: Areas of practical applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s have a look where recommendation systems are applied in the practical
    world:'
  prefs: []
  type: TYPE_NORMAL
- en: Two-thirds of the movies on Netflix are recommended.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thirty-five percent of Amazon's sales come from recommendations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On Google News, recommendations generate 38 percent more click-through.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attempts to predict a user's preference for an item is based on past ratings
    of other items.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can suggest courses to university students based on their needs and preferences.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can match resumes to jobs on online job portals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's try to use a recommendation engine to solve a real-world problem.
  prefs: []
  type: TYPE_NORMAL
- en: Practical example – creating a recommendation engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's build a recommendation engine that can recommend movies to a bunch of
    users. We will be using data put together by the GroupLens Research research group
    at the University of Minnesota.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will import the relevant packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s import the `user_id` and `item_id` datasets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We merge the two DataFrames by the movie ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The header of the df DataFrame, after running the preceding code, looks like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/25808f2a-8fef-49e7-8e0e-e7f6ec14b479.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The details of the columns are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '****userid****:The unique ID of each of the users'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '**movieid**: The unique ID of each of the movies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**rating**: Ratings of each of the movies from 1 to 5'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**timestamp**: The timestamp when the movie was rated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**title**:The title of the movie'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**genres**: The genre of the movie'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To look into the summary trends of the input data, let''s compute the mean
    and count of ratings per movie using `groupby` by the `title` and `rating` columns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/9561fa50-6ff3-4136-bf48-4c1b7c56b208.png).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now prepare data for the recommendation engine. For that, we will transform
    the dataset into a matrix, which will have the following characteristics:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Movie titles will be columns.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`User_id` will be the index.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ratings will be the value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will use the `pivot_table` function of the DataFrame to get it done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that the preceding code will generate a very sparse matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s use this recommendation matrix that we have created to recommend
    movies. For that, let''s consider a particular user who has watched the movie,
    *Avatar (2009)*. First, we will find all of the users that have shown interest
    in *Avatar (2009)*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try to suggest the movies that correlate with *Avatar (2009)*.
    For that, we will calculate the correlation of the `Avatar_user_rating` DataFrame
    with `movie_matrix`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives out the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f0a29140-c9eb-4a17-96ad-f586ea608d86.png)'
  prefs: []
  type: TYPE_IMG
- en: This means that we can use these movies as recommendations for the user.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about recommendation engines. We studied the selection
    of the right recommendation engine based on the problem that we are trying to
    solve. We also looked into how we can prepare data for recommendation engines
    to create a similarity matrix. We also learned how recommendation engines can
    be used to solve practical problems, such as suggesting movies to users based
    on their past patterns.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on the algorithms that are used to understand
    and process data.
  prefs: []
  type: TYPE_NORMAL
