- en: Chapter 5. Creating Unique and Randomized Game Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we're going to make our classes more random. We touched on
    a similar subject matter in [Chapter 3](ch03.html "Chapter 3. Using RNG with C++
    Data Types"), *Using RNG with C++ Data Types*, by giving the player random stats,
    so we'll continue further down that path and build bigger, more versatile procedural
    classes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Having game items generated randomly is a great way to bring versatility and
    replayability to a game. For example, all the weapons in Borderlands are generated
    randomly; each chest and loot drop will contain a unique item. It brings an element
    of unknown to the game, and each time you find an item there's no knowing what
    it could be.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Giving objects random sprites
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating random traits for our player
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigning stats randomly
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Procedurally generating a range of game items
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a random player character
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html "Chapter 3. Using RNG with C++ Data Types"), *Using
    RNG with C++ Data Types*, we gave our player random stats. Let's continue and
    develop the `player` object further. We'll give our `player` a random class, and
    use this to set an appropriate sprite and stats. We'll also give the player random
    traits that will buff certain stats.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a player class
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by assigning the player a random class. The first step is to define
    an enumerator that will define the possible classes. We''ll place this with the
    rest of the enumerators in `Util.h`:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, in the constructor of the `player` class, we'll select one of these classes
    at random. To do this, we need to generate a number from 0 to 3, and use it as
    an index in the enumerator. We'll also create a variable to hold the selection
    in case we wish to use it later.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by declaring the variable in `Player.h`, as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We couldn't call this variable just 'class', as it's a keyword in C++. Keep
    keywords in mind when naming variables to avoid such clashes
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'In the constructor, let''s generate the random index and set the class as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It's as simple as that. Every time a player is now created, a random class will
    be selected, which can be used to implement different behavior and looks.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: An overview of sprites and textures
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we start working with objects' sprites, let's just take a moment to look
    at how sprites and textures are handled in our game. As you may already know,
    to draw objects in SFML we need a sprite and a texture resource. When we want
    to change the sprite, we actually just need to change the `sf::Texture` object
    to which `sf::sprite` is holding a reference. Given this, sprites are stored in
    the object that they belong to, and textures are stored in a single, `static texture
    manager class`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '`Textures` are an expensive and heavy resource, so keeping them in all in a
    single object, and interacting with them only via references, is ideal. It means
    that we don''t have to worry about moving them or them making objects heavy. The
    `TextureManager` class is used in the following way:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: To add a `texture` to a game, we statically call `TextureManager::AddTexture`
    and pass the path to the sprite that we want to load, and the function returns
    the index of the texture in the manager class.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To get a `texture` out of the `manager`, we statically call `TextureManager::GetTexture`,
    passing the `ID` of the `texture` that we want as the only parameter. In return,
    we get a reference to the `texture` if it exists.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What this all means for our game is that instead of storing `textures` in objects,
    we instead store their texture manager IDs. Whenever we want the actual `texture`,
    we just call the `TextureManager::GetTexture` function, as previously described.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `texture resource manager` class does some other clever stuff such as avoiding
    the loading of the same textures twice. I advise you to take a look at the class
    and employ the same approach in your own games to ensure resources are handled
    correctly.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Setting an appropriate sprite
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that the `player` class has a random class generated, let's update the sprite
    to reflect this. The player is animated, and therefore has a collection of eight
    texture IDs that are defined in an array.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'As it currently stands, the player loads the same fixed set of textures:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let's update this so that if we generate a warrior we will load the warrior
    textures, and if we load a mage we'll load the mage textures, and so on. This
    could be achieved by simply using the player's class in a switch statement to
    load the appropriate textures.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this will create lots of duplicate code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For each class type we would have the same code repeated, with the only change
    being the name of the class in the resource. Taking this into consideration, we
    can approach this from a better angle and generate resource paths during the runtime.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Try implementing this yourself before reading the following code. If you get
    stuck, the code is always here, and you may even come up with your own approach!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll declare a string variable that can hold the name of the class, and set
    this by performing a `switch` statement on the player''s class once it is set.
    We can then load textures using this variable instead of a fixed class name:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, every time we load the game, the player will be a random class and have
    a matching sprite to show that, as shown in the following screenshot.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting an appropriate sprite](img/B04920_05_01.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
- en: 'Now that the player class is set, we can update the UI and player projectile
    to reflect it. To do so, we''ll need to get the player class from the player.
    So, let''s first add a simple getter function to the player class. Don''t forget
    the declaration:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'These are simple changes; instead of having fixed code, we can switch the player''s
    class and load the correct sprites in each case. Let''s start with the projectile.
    The sprite for this is set in `Game::Initialize`, and all that we have to do now
    is choose the right sprite for the class:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, let's move on to the player UI. At the top-left of the screen we have the
    player's stats, and one of these sprites shows the player. Since the class is
    dynamic, we need to update this sprite accordingly. This sprite is set in `Game::LoadUI`,
    and it will be set in a way that is similar to how we set the projectile. We'll
    leave this as an exercise for you to complete on your own.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Buffing the player stats
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that the player has a class, another thing that we can do is to buff stats
    accordingly. We'll do this by giving certain values an initial value before we
    distribute the player's stat points as usual.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'We already have a `switch` statement that we''re using to load the appropriate
    textures, so we can add the code to this. As usual, we won''t hard-code this value,
    but we will leave it to the RNG gods, as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With this we can make certain classes more likely to have higher stat points
    in a given skill, and by using a random number we can induce yet more randomness
    and variance in the `player` objects that we can create.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Random character traits
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have five stats in the game, namely `Attack`, `Defense`, `Strength`, `Dexterity`,
    and `Stamina`. Let's create traits that affect each of these so that each character
    will be predisposed to certain stats and therefore certain play styles! This will
    mean that players have to change their gameplay to suit every character that they
    generate.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to start by defining these traits, so let''s create an enumerator to
    do so. We''ll declare the following in `Util.h`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we need to create a variable in the `player` class that will store the
    currently active traits. We''ll give the player two traits, so will declare an
    array of that size. However, instead of hard-coding the value, we''ll create a
    static `const` to define the trait count, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We always want to make code as flexible as possible. Therefore, working with
    a static `const` with an appropriate name is preferred over a hard-coded value
    in this case.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Feel free to give the player more traits; simply create a larger array and
    amend the code as required as we move forward. Now, let''s define the variable
    that will hold the traits:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To assign traits randomly to a player, we now need to generate two random numbers
    and use them as indices from the `PLAYER_TRAIT` enumerator. We'll encapsulate
    this behavior in its own function. That way, we can change the player's traits
    at will while the game is running.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s declare the following function in the `Player` class:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We need this function to generate two indices and then use them in a switch
    statement to increase the appropriate stat, much like what we did when determining
    the `player` class. Let''s get this added, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: While this approach succeeds in generating random traits, it has a big flaw;
    there is no check to ensure that two unique traits are generated. We could give
    a player five traits, and though it's quite unlikely, we could give them the same
    one five times. One of the exercises at the end of the chapter is to amend this,
    ensuring that only unique trait indices are generated. I highly suggest giving
    it a go.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'With this function written, we now just need to make a call to it in the constructor
    of our player:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Every time a player is now created, they will have two randomly selected traits.
    The final step is to draw the player traits in the UI. For that, we're going to
    need to get the traits from the player and modify the stat sprites.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Returning the player traits array
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The traits are stored in an array, and C++ does not allow us to return an entire
    array from a function. To get around this, we need to do some funky stuff. So,
    let's quickly branch off and take a look at how we can tackle this problem.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, the following function needs to be declared in `Player.h`, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We''ll give it the following definition:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Tip
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be aware that this function means that the player trait variables can be altered.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'An array is simply a collection of values that are stored sequentially in the
    memory. The following diagram shows how this looks:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '![Returning the player traits array](img/B04920_05_02.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
- en: 'Taking this into consideration, if we return the address of the first element,
    we can then find the rest of the value by reading the following memory sequentially.
    To demonstrate this, have a look at the following two lines, which work in the
    same way:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: So, while we don't return the full array, we do return the first element, and
    that's all we need. We can now access the array in the same way as we normally
    would.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Setting trait sprites
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All that's left now is to draw the traits in the main `Game` class. We have
    already drawn the player's stats at the bottom of the window. So, to indicate
    the one that has been buffed by a trait, we can make the sprite bigger and switch
    to its alternate texture. Stat sprites are loaded and initialized in the `Game::LoadUI`
    function.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start, we need to know how many traits the player has. So, let''s
    add a quick `GetTraitCount()` function in the `player` object to give us this
    information; don''t forget to add the declaration to Player.h also:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, in `Game::LoadUI`, once we have loaded the stat sprites, we can make a
    call to this function and construct a loop to iterate that number of times, as
    follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we need to check each trait, and set its sprite scale to `1.2f` to make
    it slightly bigger than its neighbors. We''ll also switch to its alternate texture
    with a white background. This has already been set up in the project, so all that
    we need to do is make the switch in the following way:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now if we run the game, we can clearly see which sprites are currently been
    buffed by traits, as shown in the following screenshot. We hooked up their behavior
    earlier. So we know that these icons are having an effect on the character''s
    stats:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting trait sprites](img/B04920_05_03.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
- en: Procedurally generating an enemy class
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the player is well and truly generated procedurally, let's apply some
    of this to the enemies. We currently have two main enemy classes, namely `Slime`
    and `Humanoid`. `Slime` is a simple slime enemy, but our `humanoid` class is here
    for us to expand upon. Currently, the class loads the sprites of a skeleton, but
    let's make it so that it can be a number of humanoid-like enemies; in our case,
    it will be either a goblin or a skeleton.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: We could have made individual classes for these enemies, but since most of their
    code will be the same, it doesn't make sense. Instead, we have this ambiguous
    `humanoid` class that can take the form of a humanoid enemy. All that we need
    to do is change the sprite, and the way we distribute stats if we want them to
    play differently. From this we can create a great number of different enemies
    from a `single` class. We'll use this same approach on potions soon!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, we''ll start by defining an enumerator in `Util.h` to denote the different
    types of humanoid enemies:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, if we cast our minds back to the `player` constructor, we generated a class
    and performed a switch on that variable to perform class-dependent behavior. We'll
    use the exact same approach here. We'll generate a random enemy type from the
    enumerator that we just defined, and then set the sprites and stats accordingly.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Humanoid::Humanoid`, let''s select a random humanoid type and create a
    string to hold the name of the enemy, as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With this done, if you run the game now, you will see that there are both goblin
    and skeleton enemies that are spawning from a `single` class, as shown in the
    following screenshot:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![Procedurally generating an enemy class](img/B04920_05_04.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: Procedural items
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the player and enemies have been taken care of, let's turn our attention
    to items. We have a number of classes that can have their member variables assigned
    randomly. We'll set up the `potion` class the way we set up the `humanoid` class,
    where we created a number of distinct objects from a `single` class.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Random Gem and Heart classes
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll start with the smallest classes, namely `Heart` and `Gem`. These are very
    simple classes that have a single variable that is currently hard-coded. Let's
    update this so that their values are randomly generated every time they are created.
    Since we want this to happen each time an object is created, we'll place it in
    the items' constructors.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Gem::Gem`, we''ll make the following change:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In `Heart::Heart`, we''ll make the following change:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If we run the game now, and have a quick look around, you will see that these
    items provide different score and health values. Perfect!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![Random Gem and Heart classes](img/B04920_05_05.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: Random gold class
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the last two items, we simply generated a random value. With the gold item,
    we're going to take this a little further. We will use this random value to determine
    the sprite that the object should have.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we will split the total gold value range into three bands. We will
    define a lower range, an upper range, and that leaves everything else for the
    middle range. For example, if we were to generate a gold value between 0 and 10,
    we could have the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Anything less than 3 is small
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anything over 7 is large
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anything else is medium
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By doing this, we can set a sprite that matches the gold value. We''ll put
    this code in the constructor, because it''s code that should be called every time
    we create a gold object, and we''ll never need to call its behavior manually:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can see that we generate a random gold value, then simply use a couple
    of `if` statements to define our ranges. Let''s run the game again and check out
    the gold objects. You will see that their sprites vary, and with that, so does
    the amount of gold that they are worth when picked up:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '![Random gold class](img/B04920_05_06.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
- en: The random potion class
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the biggest class update, we'll turn our attention to the `potion` class.
    This class currently has a fixed sprite and doesn't give the player anything.
    With the `humanoid` class, we can generate a random type and essentially create
    two different enemies from a `single` class. We're going to use this same approach
    for the potions.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Creating a random potion
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start, let''s define an enumerator in `Util.h` that denotes all potion types.
    We''ll create one for each stat, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To save a lot of typing, the potion class already has the member variables and
    the `getter` functions for each possible stat, we just need to use them. One thing
    that we will add is a variable to hold the potion type, and a function to return
    it. We'll need this information when picking the object up!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s declare the following in `Potion.h`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`GetPotionType` is a simple `getter` function, so before moving forward let''s
    quickly give it a body:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If we look at the initializer list for Potion, you'll notice it sets all of
    the stat variables to 0\. From this point we can select a random type and set
    its sprite and corresponding stat, leaving the rest at their default value of
    0 as we won't use them.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'To start we''ll generate a random value to denote its type, and create a variable
    that we''ll use to store the sprite path. The following code needs to go in `Potion::Potion`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'With a type selected, we can switch this value, set the appropriate stat, and
    give `spriteFilePath` the appropriate resource path, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, we just need to set the item sprite and type in the following way,
    and we''re done. Note that this type is different from the potion type:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If we run our game now, and kill a couple of enemies until we get a potion
    drop, we should see that the potion type changes. From a single class we''ve created
    5 potions, created at runtime, that give buffs also generated at runtime:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a random potion](img/B04920_05_07.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
- en: Determining potion pickups
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have a `single` class that has five different potential buffs, we
    need to determine the potion that we're picking up. This is where the `Potion::GetType`
    function comes in handy. When we come in contact with a `potion` object, we can
    check what type of `potion` it is and use that to determine which stats getter
    function that we will call.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we pick up a `potion` and its type is `POTION::ATTACK`, then
    we know that we need to call the `Potion::GetAttack` function. The item pickup
    code lies in the `Game::UpdateItems` function. In this function, we check for
    collisions with the object and check what type of item it is.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'When we have determined that we have picked up a potion, we need to call the
    `Potion::GetPotionType` function, but we have a problem. Since we are utilizing
    polymorphism to store all the items in a single collection, the type of the potion
    item at this point is `Item`. To get access to the `Potion::GetPotionType` function,
    we need to cast the item using `dynamic_cast`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are unsure about why we're using `dynamic_cast` here and `static_cast`
    elsewhere, read up on the different types of casts.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get this case added to the pickup code in `Game::UpdateItems`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We''ve now identified that we''ve picked up a `potion` and `cast` that item
    to a `potion` object. Next, we can check the type of the potion and call the appropriate
    `getter` function to get the `potion` value. Finally, we''ll update the corresponding
    stat in the player, as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With this the potion system is complete. From a `single` class we've created
    five distinct potions, and all the values have been generated randomly.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To help you test your knowledge of this chapter''s content, the following are
    a few exercises that you should work on. They are not imperative to the rest of
    the book, but working on them will help you assess your strengths and weaknesses
    in the material covered:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Add your own trait to the `player` class. There is a spare trait resource included
    in the project that you can use.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给`player`类添加你自己的特性。项目中包含了一个备用的特性资源，你可以使用。
- en: When generating `player` traits, we identified that it was possible to give
    the player the same trait multiple times. Improve the `Player::SetRandomTraits`
    function so that that's no longer possible.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在生成`player`特性时，我们发现可能会多次给玩家相同的特性。改进`Player::SetRandomTraits`函数，使这种情况不再可能。
- en: The stats that we have given to the player and enemies aren't hooked up to how
    much damage they deal or take. Hook these stats up so that they affect the player
    and enemy to a greater extent.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们给玩家和敌人的属性并没有与他们造成或承受多少伤害挂钩。将这些属性挂钩起来，使它们对玩家和敌人产生更大的影响。
- en: Summary
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at how to make game objects unique and random, giving
    them random properties, sprites, and variations. With this approach, the range
    of possible items that a game can generate is almost endless. When we have multiple
    classes that differ only slightly, we can design ambiguous classes that are highly
    flexible and greatly increase variety.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了如何使游戏对象独特和随机化，赋予它们随机属性、精灵和变化。通过这种方法，游戏可以生成的物品种类几乎是无限的。当我们有多个类只有轻微不同时，我们可以设计模糊的类，这些类非常灵活，大大增加了多样性。
- en: In the next chapter, we're going to step up our procedural efforts. We'll move
    away from the simple setting of member variables randomly, and we'll experiment
    with the creation of procedural art and graphics. We'll create textures procedurally
    for enemies, and alter the level sprites to give a unique feel to each floor of
    the dungeon.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将加强我们的程序化工作。我们将摆脱简单地随机设置成员变量的方式，尝试创建程序化艺术和图形。我们将为敌人程序化地创建纹理，并改变关卡精灵，为地牢的每一层赋予独特的感觉。
