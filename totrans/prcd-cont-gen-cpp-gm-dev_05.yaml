- en: Chapter 5. Creating Unique and Randomized Game Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we're going to make our classes more random. We touched on
    a similar subject matter in [Chapter 3](ch03.html "Chapter 3. Using RNG with C++
    Data Types"), *Using RNG with C++ Data Types*, by giving the player random stats,
    so we'll continue further down that path and build bigger, more versatile procedural
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: Having game items generated randomly is a great way to bring versatility and
    replayability to a game. For example, all the weapons in Borderlands are generated
    randomly; each chest and loot drop will contain a unique item. It brings an element
    of unknown to the game, and each time you find an item there's no knowing what
    it could be.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Giving objects random sprites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating random traits for our player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigning stats randomly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Procedurally generating a range of game items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a random player character
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html "Chapter 3. Using RNG with C++ Data Types"), *Using
    RNG with C++ Data Types*, we gave our player random stats. Let's continue and
    develop the `player` object further. We'll give our `player` a random class, and
    use this to set an appropriate sprite and stats. We'll also give the player random
    traits that will buff certain stats.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a player class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by assigning the player a random class. The first step is to define
    an enumerator that will define the possible classes. We''ll place this with the
    rest of the enumerators in `Util.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, in the constructor of the `player` class, we'll select one of these classes
    at random. To do this, we need to generate a number from 0 to 3, and use it as
    an index in the enumerator. We'll also create a variable to hold the selection
    in case we wish to use it later.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by declaring the variable in `Player.h`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We couldn't call this variable just 'class', as it's a keyword in C++. Keep
    keywords in mind when naming variables to avoid such clashes
  prefs: []
  type: TYPE_NORMAL
- en: 'In the constructor, let''s generate the random index and set the class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It's as simple as that. Every time a player is now created, a random class will
    be selected, which can be used to implement different behavior and looks.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of sprites and textures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we start working with objects' sprites, let's just take a moment to look
    at how sprites and textures are handled in our game. As you may already know,
    to draw objects in SFML we need a sprite and a texture resource. When we want
    to change the sprite, we actually just need to change the `sf::Texture` object
    to which `sf::sprite` is holding a reference. Given this, sprites are stored in
    the object that they belong to, and textures are stored in a single, `static texture
    manager class`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Textures` are an expensive and heavy resource, so keeping them in all in a
    single object, and interacting with them only via references, is ideal. It means
    that we don''t have to worry about moving them or them making objects heavy. The
    `TextureManager` class is used in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: To add a `texture` to a game, we statically call `TextureManager::AddTexture`
    and pass the path to the sprite that we want to load, and the function returns
    the index of the texture in the manager class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To get a `texture` out of the `manager`, we statically call `TextureManager::GetTexture`,
    passing the `ID` of the `texture` that we want as the only parameter. In return,
    we get a reference to the `texture` if it exists.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What this all means for our game is that instead of storing `textures` in objects,
    we instead store their texture manager IDs. Whenever we want the actual `texture`,
    we just call the `TextureManager::GetTexture` function, as previously described.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `texture resource manager` class does some other clever stuff such as avoiding
    the loading of the same textures twice. I advise you to take a look at the class
    and employ the same approach in your own games to ensure resources are handled
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Setting an appropriate sprite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that the `player` class has a random class generated, let's update the sprite
    to reflect this. The player is animated, and therefore has a collection of eight
    texture IDs that are defined in an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'As it currently stands, the player loads the same fixed set of textures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Let's update this so that if we generate a warrior we will load the warrior
    textures, and if we load a mage we'll load the mage textures, and so on. This
    could be achieved by simply using the player's class in a switch statement to
    load the appropriate textures.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this will create lots of duplicate code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For each class type we would have the same code repeated, with the only change
    being the name of the class in the resource. Taking this into consideration, we
    can approach this from a better angle and generate resource paths during the runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Try implementing this yourself before reading the following code. If you get
    stuck, the code is always here, and you may even come up with your own approach!
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll declare a string variable that can hold the name of the class, and set
    this by performing a `switch` statement on the player''s class once it is set.
    We can then load textures using this variable instead of a fixed class name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time we load the game, the player will be a random class and have
    a matching sprite to show that, as shown in the following screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting an appropriate sprite](img/B04920_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that the player class is set, we can update the UI and player projectile
    to reflect it. To do so, we''ll need to get the player class from the player.
    So, let''s first add a simple getter function to the player class. Don''t forget
    the declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'These are simple changes; instead of having fixed code, we can switch the player''s
    class and load the correct sprites in each case. Let''s start with the projectile.
    The sprite for this is set in `Game::Initialize`, and all that we have to do now
    is choose the right sprite for the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's move on to the player UI. At the top-left of the screen we have the
    player's stats, and one of these sprites shows the player. Since the class is
    dynamic, we need to update this sprite accordingly. This sprite is set in `Game::LoadUI`,
    and it will be set in a way that is similar to how we set the projectile. We'll
    leave this as an exercise for you to complete on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Buffing the player stats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that the player has a class, another thing that we can do is to buff stats
    accordingly. We'll do this by giving certain values an initial value before we
    distribute the player's stat points as usual.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already have a `switch` statement that we''re using to load the appropriate
    textures, so we can add the code to this. As usual, we won''t hard-code this value,
    but we will leave it to the RNG gods, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: With this we can make certain classes more likely to have higher stat points
    in a given skill, and by using a random number we can induce yet more randomness
    and variance in the `player` objects that we can create.
  prefs: []
  type: TYPE_NORMAL
- en: Random character traits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have five stats in the game, namely `Attack`, `Defense`, `Strength`, `Dexterity`,
    and `Stamina`. Let's create traits that affect each of these so that each character
    will be predisposed to certain stats and therefore certain play styles! This will
    mean that players have to change their gameplay to suit every character that they
    generate.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to start by defining these traits, so let''s create an enumerator to
    do so. We''ll declare the following in `Util.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to create a variable in the `player` class that will store the
    currently active traits. We''ll give the player two traits, so will declare an
    array of that size. However, instead of hard-coding the value, we''ll create a
    static `const` to define the trait count, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We always want to make code as flexible as possible. Therefore, working with
    a static `const` with an appropriate name is preferred over a hard-coded value
    in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Feel free to give the player more traits; simply create a larger array and
    amend the code as required as we move forward. Now, let''s define the variable
    that will hold the traits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: To assign traits randomly to a player, we now need to generate two random numbers
    and use them as indices from the `PLAYER_TRAIT` enumerator. We'll encapsulate
    this behavior in its own function. That way, we can change the player's traits
    at will while the game is running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s declare the following function in the `Player` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We need this function to generate two indices and then use them in a switch
    statement to increase the appropriate stat, much like what we did when determining
    the `player` class. Let''s get this added, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: While this approach succeeds in generating random traits, it has a big flaw;
    there is no check to ensure that two unique traits are generated. We could give
    a player five traits, and though it's quite unlikely, we could give them the same
    one five times. One of the exercises at the end of the chapter is to amend this,
    ensuring that only unique trait indices are generated. I highly suggest giving
    it a go.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this function written, we now just need to make a call to it in the constructor
    of our player:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Every time a player is now created, they will have two randomly selected traits.
    The final step is to draw the player traits in the UI. For that, we're going to
    need to get the traits from the player and modify the stat sprites.
  prefs: []
  type: TYPE_NORMAL
- en: Returning the player traits array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The traits are stored in an array, and C++ does not allow us to return an entire
    array from a function. To get around this, we need to do some funky stuff. So,
    let's quickly branch off and take a look at how we can tackle this problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, the following function needs to be declared in `Player.h`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll give it the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be aware that this function means that the player trait variables can be altered.
  prefs: []
  type: TYPE_NORMAL
- en: 'An array is simply a collection of values that are stored sequentially in the
    memory. The following diagram shows how this looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Returning the player traits array](img/B04920_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Taking this into consideration, if we return the address of the first element,
    we can then find the rest of the value by reading the following memory sequentially.
    To demonstrate this, have a look at the following two lines, which work in the
    same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: So, while we don't return the full array, we do return the first element, and
    that's all we need. We can now access the array in the same way as we normally
    would.
  prefs: []
  type: TYPE_NORMAL
- en: Setting trait sprites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All that's left now is to draw the traits in the main `Game` class. We have
    already drawn the player's stats at the bottom of the window. So, to indicate
    the one that has been buffed by a trait, we can make the sprite bigger and switch
    to its alternate texture. Stat sprites are loaded and initialized in the `Game::LoadUI`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start, we need to know how many traits the player has. So, let''s
    add a quick `GetTraitCount()` function in the `player` object to give us this
    information; don''t forget to add the declaration to Player.h also:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in `Game::LoadUI`, once we have loaded the stat sprites, we can make a
    call to this function and construct a loop to iterate that number of times, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to check each trait, and set its sprite scale to `1.2f` to make
    it slightly bigger than its neighbors. We''ll also switch to its alternate texture
    with a white background. This has already been set up in the project, so all that
    we need to do is make the switch in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if we run the game, we can clearly see which sprites are currently been
    buffed by traits, as shown in the following screenshot. We hooked up their behavior
    earlier. So we know that these icons are having an effect on the character''s
    stats:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting trait sprites](img/B04920_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Procedurally generating an enemy class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the player is well and truly generated procedurally, let's apply some
    of this to the enemies. We currently have two main enemy classes, namely `Slime`
    and `Humanoid`. `Slime` is a simple slime enemy, but our `humanoid` class is here
    for us to expand upon. Currently, the class loads the sprites of a skeleton, but
    let's make it so that it can be a number of humanoid-like enemies; in our case,
    it will be either a goblin or a skeleton.
  prefs: []
  type: TYPE_NORMAL
- en: We could have made individual classes for these enemies, but since most of their
    code will be the same, it doesn't make sense. Instead, we have this ambiguous
    `humanoid` class that can take the form of a humanoid enemy. All that we need
    to do is change the sprite, and the way we distribute stats if we want them to
    play differently. From this we can create a great number of different enemies
    from a `single` class. We'll use this same approach on potions soon!
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, we''ll start by defining an enumerator in `Util.h` to denote the different
    types of humanoid enemies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we cast our minds back to the `player` constructor, we generated a class
    and performed a switch on that variable to perform class-dependent behavior. We'll
    use the exact same approach here. We'll generate a random enemy type from the
    enumerator that we just defined, and then set the sprites and stats accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Humanoid::Humanoid`, let''s select a random humanoid type and create a
    string to hold the name of the enemy, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'With this done, if you run the game now, you will see that there are both goblin
    and skeleton enemies that are spawning from a `single` class, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Procedurally generating an enemy class](img/B04920_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Procedural items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the player and enemies have been taken care of, let's turn our attention
    to items. We have a number of classes that can have their member variables assigned
    randomly. We'll set up the `potion` class the way we set up the `humanoid` class,
    where we created a number of distinct objects from a `single` class.
  prefs: []
  type: TYPE_NORMAL
- en: Random Gem and Heart classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll start with the smallest classes, namely `Heart` and `Gem`. These are very
    simple classes that have a single variable that is currently hard-coded. Let's
    update this so that their values are randomly generated every time they are created.
    Since we want this to happen each time an object is created, we'll place it in
    the items' constructors.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Gem::Gem`, we''ll make the following change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In `Heart::Heart`, we''ll make the following change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If we run the game now, and have a quick look around, you will see that these
    items provide different score and health values. Perfect!
  prefs: []
  type: TYPE_NORMAL
- en: '![Random Gem and Heart classes](img/B04920_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Random gold class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the last two items, we simply generated a random value. With the gold item,
    we're going to take this a little further. We will use this random value to determine
    the sprite that the object should have.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we will split the total gold value range into three bands. We will
    define a lower range, an upper range, and that leaves everything else for the
    middle range. For example, if we were to generate a gold value between 0 and 10,
    we could have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Anything less than 3 is small
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anything over 7 is large
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anything else is medium
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By doing this, we can set a sprite that matches the gold value. We''ll put
    this code in the constructor, because it''s code that should be called every time
    we create a gold object, and we''ll never need to call its behavior manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that we generate a random gold value, then simply use a couple
    of `if` statements to define our ranges. Let''s run the game again and check out
    the gold objects. You will see that their sprites vary, and with that, so does
    the amount of gold that they are worth when picked up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Random gold class](img/B04920_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The random potion class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the biggest class update, we'll turn our attention to the `potion` class.
    This class currently has a fixed sprite and doesn't give the player anything.
    With the `humanoid` class, we can generate a random type and essentially create
    two different enemies from a `single` class. We're going to use this same approach
    for the potions.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a random potion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start, let''s define an enumerator in `Util.h` that denotes all potion types.
    We''ll create one for each stat, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: To save a lot of typing, the potion class already has the member variables and
    the `getter` functions for each possible stat, we just need to use them. One thing
    that we will add is a variable to hold the potion type, and a function to return
    it. We'll need this information when picking the object up!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s declare the following in `Potion.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`GetPotionType` is a simple `getter` function, so before moving forward let''s
    quickly give it a body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If we look at the initializer list for Potion, you'll notice it sets all of
    the stat variables to 0\. From this point we can select a random type and set
    its sprite and corresponding stat, leaving the rest at their default value of
    0 as we won't use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start we''ll generate a random value to denote its type, and create a variable
    that we''ll use to store the sprite path. The following code needs to go in `Potion::Potion`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'With a type selected, we can switch this value, set the appropriate stat, and
    give `spriteFilePath` the appropriate resource path, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we just need to set the item sprite and type in the following way,
    and we''re done. Note that this type is different from the potion type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run our game now, and kill a couple of enemies until we get a potion
    drop, we should see that the potion type changes. From a single class we''ve created
    5 potions, created at runtime, that give buffs also generated at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a random potion](img/B04920_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Determining potion pickups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have a `single` class that has five different potential buffs, we
    need to determine the potion that we're picking up. This is where the `Potion::GetType`
    function comes in handy. When we come in contact with a `potion` object, we can
    check what type of `potion` it is and use that to determine which stats getter
    function that we will call.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we pick up a `potion` and its type is `POTION::ATTACK`, then
    we know that we need to call the `Potion::GetAttack` function. The item pickup
    code lies in the `Game::UpdateItems` function. In this function, we check for
    collisions with the object and check what type of item it is.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we have determined that we have picked up a potion, we need to call the
    `Potion::GetPotionType` function, but we have a problem. Since we are utilizing
    polymorphism to store all the items in a single collection, the type of the potion
    item at this point is `Item`. To get access to the `Potion::GetPotionType` function,
    we need to cast the item using `dynamic_cast`:'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are unsure about why we're using `dynamic_cast` here and `static_cast`
    elsewhere, read up on the different types of casts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get this case added to the pickup code in `Game::UpdateItems`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve now identified that we''ve picked up a `potion` and `cast` that item
    to a `potion` object. Next, we can check the type of the potion and call the appropriate
    `getter` function to get the `potion` value. Finally, we''ll update the corresponding
    stat in the player, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: With this the potion system is complete. From a `single` class we've created
    five distinct potions, and all the values have been generated randomly.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To help you test your knowledge of this chapter''s content, the following are
    a few exercises that you should work on. They are not imperative to the rest of
    the book, but working on them will help you assess your strengths and weaknesses
    in the material covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Add your own trait to the `player` class. There is a spare trait resource included
    in the project that you can use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When generating `player` traits, we identified that it was possible to give
    the player the same trait multiple times. Improve the `Player::SetRandomTraits`
    function so that that's no longer possible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The stats that we have given to the player and enemies aren't hooked up to how
    much damage they deal or take. Hook these stats up so that they affect the player
    and enemy to a greater extent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how to make game objects unique and random, giving
    them random properties, sprites, and variations. With this approach, the range
    of possible items that a game can generate is almost endless. When we have multiple
    classes that differ only slightly, we can design ambiguous classes that are highly
    flexible and greatly increase variety.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to step up our procedural efforts. We'll move
    away from the simple setting of member variables randomly, and we'll experiment
    with the creation of procedural art and graphics. We'll create textures procedurally
    for enemies, and alter the level sprites to give a unique feel to each floor of
    the dungeon.
  prefs: []
  type: TYPE_NORMAL
