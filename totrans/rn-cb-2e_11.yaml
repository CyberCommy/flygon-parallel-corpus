- en: Adding Native Functionality - Part I
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Exposing custom iOS modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering custom iOS view components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exposing custom Android modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering custom Android view components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the core principles in React Native development is writing JavaScript
    to build truly native mobile applications. To accomplish this, many native APIs
    and UI components are exposed through an abstraction layer and are accessed through
    the React Native bridge. While the React Native and Expo teams continue to improve
    and expand on the already impressive APIs that currently exist, through the native
    APIs we can access functionality that isn't available otherwise, such as vibration,
    contacts, and native alerts and toasts.
  prefs: []
  type: TYPE_NORMAL
- en: By exposing the native view components, we're able to leverage all of the rendering
    performance the device has to offer, as we're not going through a WebView as in
    a hybrid app. This gives a native look and feel that adapts to the platform the
    user is running the app on. With React Native, we're already able to render many
    native view components including maps, lists, input fields, toolbars, and pickers.
  prefs: []
  type: TYPE_NORMAL
- en: While React Native comes with many built-in native modules and view components,
    we're sometimes in a position where we need some custom functionality leveraging
    the native application layer that isn't provided out of the box. Fortunately,
    there's an extremely rich open source community supporting React Native that not
    only contributes to the library itself, but also publishes libraries that export
    some common native modules and view components. If you can't find a first- or
    third-party library to accomplish what you need, you can always build it yourself.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll cover recipes that go over exposing custom native functionality,
    whether it's an API or view component, on both platforms.
  prefs: []
  type: TYPE_NORMAL
- en: There will be a lot of generated code in the native portions of the code we'll
    be using in these recipes. The code blocks provided throughout this chapter will,
    like in previous chapters, continue to display all of the code used in a particular
    step, whether it's added by us or generated, unless stated otherwise. This is
    intended to ease the burden of understanding the context of a piece of code, and
    facilitates the discussion of these pieces of generated code when further explanation
    is warranted.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing custom iOS modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you begin developing more interesting and complex React Native applications,
    you could possibly reach a point where executing certain code would be only possible
    (or significantly improved) in the native layer. This allows for executing data
    processing that's faster in the native layer when compared with JavaScript, and
    for accessing certain native functionality that isn't otherwise exposed, such
    as file I/O, or leveraging existing native code from other applications or libraries
    in your React Native app.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will walk you through the process of executing some native Objective-C
    or Swift code and communicating with the JavaScript layer. We'll build a native
    `HelloManager` module that will greet our user with a message. We'll also show
    how to execute native Objective-C and Swift code, taking in arguments, and showing
    several ways of communicating back with the UI (or JavaScript) layer.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we'll need a new empty, pure React Native application. Let's
    call it `NativeModuleApp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll also make use of the `react-native-button` library.
    This library will allow us to work with a  `Button` component that''s more sophisticated
    than the React Native counterparts. It can be installed with `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Or it can be installed using `yarn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll start by opening the iOS Project in Xcode. The project file has an `.xcodeproj`
    file extension and is located in the `ios/` directory in the root of the project.
    In our case, the file will be called `NativeModuleApp.xcodeproj`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to make a new file by selecting and right-clicking on the group/folder
    that matches the project name, then clicking on New File... as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/1776e333-b5bc-43a0-ab3d-71974adfe908.png)'
  prefs: []
  type: TYPE_IMG
- en: We'll be making a Cocoa class, so select Cocoa Class and click Next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ll use `HelloManager` for the Class name and set the Subclass of to NSObject,
    and the Language as Objective-C as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/708e04f5-1712-4fa8-9e96-aa63650ed06c.png)'
  prefs: []
  type: TYPE_IMG
- en: After clicking Next, we'll be prompted to choose the directory for the new class.
    We want to save it to the `NativeModuleApp` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Creating this new Cocoa class has added two new files to the project: a header
    file (`HelloManager.h`) and an implementation file (`HelloManager.m`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the header file (`HelloManager.h`), you should see some generated code
    implementing the new `HelloManager` protocol. We need to import the React `RCTBridgeModule`
    library as well. The file should ultimately look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation file (`HelloManager.m`) houses the functionality of our
    module. In order for our React Native app to be able to access this module from
    the JavaScript layer, we need to register it with the React Bridge. This is done
    by adding `RCT_EXPORT_MODULE()` after the `@implementation` tag. Also note that
    the header file should already be imported into this file as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to add the function we''ll be exporting to the React Native app. We''ll
    create a `greetUser` method that will take two arguments, `name` and `isAdmin`.
    These arguments will be used to create a greeting message using string concatenation
    and then send it back to the JavaScript layer via `callback`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re ready to switch over to the JavaScript layer, which will have a UI that
    will invoke the native `HelloManager greetUser` method we''ve just created, then
    display its output. Fortunately, the React Native bridge does all of the heavy
    lifting for us and leaves us with a simple-to-use JavaScript object that mimics
    the `NativeModules` API. In this example, we''ll be using `TextInput` and `Switch`
    to provide `name` and the `isAdmin` value for the native modules method. Let''s
    start with out imports in `App.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `NativeModules` component we imported to get the `HelloManager`
    protocol we created from the native layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create the `App` component and define the initial `state` object. We''ll
    add a `greetingMessage` property for saving the message received from the native
    module, `userName` for storing the entered user name, and an `isAdmin` Boolean
    for representing whether the user is an administrator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re ready to start building the `render` method. First, we''ll need a `TextInput`
    component for getting a user name from the user, and a `Switch` component for
    toggling the `isAdmin` state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The UI will also need `Button` for submitting the callback to the native module
    and a `Text` component for displaying the message returned from the native module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With the UI rendering the necessary components, we''re ready to wire up the  `onPress`
    handler of `Button` to a call to the native layer. This function passes the `displayResults`
    class method as the third parameter, which is the callback to be used by the native
    `greetUser` function. We''ll define `displayResults` in the next step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`displayResults` will need to do two things: `blur` the `TextInput` using the
    `refs` associated with the component and set `greetingMessage` on `state` to the `results`
    returned from the native module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step is adding the styles to the layout and styling the app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have a working React Native app that''s able to communicate directly
    with the native iOS layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/b60dc2de-a7fd-4c7c-a1fd-d757beaa4cb9.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The app we built in this recipe will serve as the foundation for many of the
    following recipes in this chapter. It's also the method Facebook uses to implement
    many bundled React Native APIs.
  prefs: []
  type: TYPE_NORMAL
- en: There are several important concepts to keep in mind going forward. Any native
    module class we want to use in the JavaScript layer has to extend `RCTBridgeModule`,
    as it contains functionality for registering our class onto the React Native bridge.
    We register our class with the `RCT_EXPORT_MODULE` method call, which registers
    methods on the module once the module has been registered. Registering the module
    along with its respective methods and properties is what allows us to interface
    with the native layer from the JavaScript layer.
  prefs: []
  type: TYPE_NORMAL
- en: The `greetUser` method is executed when the button is pressed. This function
    in turn makes a call to `HelloManager.greetUser`, passing the `userName` and `isAdmin`
    properties from `state` and the `displayResults` function as a callback. `displayResults`
    sets the new `greetingMessage` on `state`, causing the UI to be refreshed and
    the message to be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An explanation of how React Native applications boot up: [https://levelup.gitconnected.com/wait-what-happens-when-my-react-native-application-starts-an-in-depth-look-inside-react-native-5f306ef3250f](https://levelup.gitconnected.com/wait-what-happens-when-my-react-native-application-starts-an-in-depth-look-inside-react-native-5f306ef3250f)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A deep dive into how React Native events actually work: [https://levelup.gitconnected.com/react-native-events-in-gory-details-what-happens-on-the-way-to-listeners-2cee6c55940c](https://levelup.gitconnected.com/react-native-events-in-gory-details-what-happens-on-the-way-to-listeners-2cee6c55940c)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering custom iOS view components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While it's very important to leverage the devices processing power in executing
    code on the native layer in our React Native application, it's equally important
    to leverage its rendering power to show native UI components. React Native can
    render any UI component that's an implementation of `UIView` inside an application.
    These components can be lists, form fields, tables, graphics, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we'll create a React Native application titled `NativeUIComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll take a native `UIButton` and expose it as a React Native
    view component. You'll be able to set the button label and attach a handler for
    when it's pressed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start by opening the iOS project in Xcode. The project file is located
    in the `ios/` directory of the project and should be called `NativeUIComponent.xcodeproj`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select and right-click on the group that matches your project name and click
    on New File...:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/0b0b6694-a324-4ad7-8931-abab7e95d2f0.png)'
  prefs: []
  type: TYPE_IMG
- en: We'll be making a Cocoa class, so select Cocoa Class and click Next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ll be creating a button, so let''s name the Class `Button` and set the Subclass
    of to UIView and the Language as Objective-C:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/cbed707c-06cb-4418-b991-ac0cb10187cd.png)'
  prefs: []
  type: TYPE_IMG
- en: After clicking Next, we'll be prompted to choose the directory for the new class.
    We want to save it to the `NativeUIComponent` directory to create the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We're also going to need a `ButtonViewManager` class as well. You can repeat
    steps 2 to 5 with `ButtonViewManager` as the class name and `RCTViewManager` as
    the subclass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we''re going to implement our `Button` UI class. In the header (`Button.h`)
    file, we''ll import `RCTComponent.h` from React and add an `onTap` property to
    wire up our tap event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s work on the implementation file (`Button.m`). We''ll start by creating
    references for our `UIButton` instance and the string that will hold the button
    label:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The bridge will look for a setter for the `buttonText` property. This is where
    we''ll set the `UIButton` instance title field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `Button` will accept an `onTap` event handler from the React Native app.
    We need to wire this to our `UIButton` instance through an action selector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to instantiate the `UIButton` and place it inside a React `Subview`.
    We''ll call this method `layoutSubviews`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s import the React `RCTViewManager` in the `ButtonViewManager.h` header
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to implement our `ButtonViewManager`, which will interface with
    our React Native application. Let''s work on the implementation file (`ButtonViewManager.m`)
    to make this happen. We use `RCT_EXPORT_VIEW_PROPERTY` to pass along the `buttonText` property
    and `onTap` method to the React Native layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We are ready to switch over to the React Native layer. We''re going to need
    a custom `Button` component, so let''s create a new `components` folder in the
    root of the project with a new `Button.js` file inside of it. We''ll also need
    to import the `requireNativeComponent` component from React Native for interfacing
    with our native UI component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Button` component will grab the native `Button` module we created earlier
    via the `requireNativeComponent` React Native helper. The call takes a string
    to be used as the component''s name in the React Native layer as the first parameter,
    and the second takes the `Button` component in the file, effectively wiring the
    two together:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re ready to build out the main `App` component in the `App.js` file in
    the root of the project. We''ll start with the imports, which will include the `Button`
    component we created in the last two steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define the `App` component and the initial `state` object. The `count`
    property will keep track of the number of times the `Button` component has been
    pressed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re ready to define the `render` method, which will just consist of the
    `Button` component, along with a `Text` element for displaying the current button
    press count:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You may recall that the `Button` component we created has an `onTap` property,
    which takes a callback function. In this case we''ll just use this function to
    increase the counter that lives on `state`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s wrap up this recipe with a few basic styles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The app is complete! When the button is pressed, the function passed to `onTap` will
    be executed, increasing the counter by one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/c4d79bfc-c22f-48dd-95d7-19221383b3e1.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we exposed a basic native UI component. This is the same method
    by which all of the UI components built into React Native (for example, `Slider`,
    `Picker`, and `ListView`) were created.
  prefs: []
  type: TYPE_NORMAL
- en: The most important requirement in creating UI components is that your `ViewManager`
    extends `RCTViewManager` and returns an instance of `UIView`. In our case, we're
    wrapping `UIButton` with a React-specific `UIView` extension, which improves our
    ability to layout and style the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next important factor is sending properties and reacting to component events.
    In step 13, we used the `RCT_EXPORT_VIEW_PROPERTY` method provided by React Native
    to register the `buttonText` and `onTap` view properties that will come from the
    JavaScript layer to the `Button` component. That `Button` component is then created
    and returned to be used in the JavaScript layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Exposing custom Android modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, you'll find the need for React Native applications to interface with
    native iOS and Android code. Having discussed integrating native iOS modules,
    now it's time to cover the equivalent recipes in Android.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will take us through writing our first Android native module. We're
    going to create a `HelloManager` native module with a `greetUser` method that
    takes `name` and an `isAdmin` Boolean as arguments, which will return a greeting
    message that we'll display in the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we'll need to create another pure React Native app. Let's name
    this project `NativeModuleApp` as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also be making use of the `react-native-button` library again, which
    can be installed with `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, it can be installed using `yarn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll start by opening the new project's Android code in Android Studio. From
    the Android Studio welcome screen, you can select Open an existing Android Studio
    project, then select the `android` directory inside of the project folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the project has loaded, let''s open the project explorer (that is, the
    directory tree) on the left side of Android Studio and expand the package structure
    to find the Java source files, which should live in  `app/java/com.nativemoduleapp`.
    The folder should already have two `.java` files in it, `MainActivity` and `MainApplication`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/f26cf594-e058-4d2d-a1d4-c4fdfca09273.png)'
  prefs: []
  type: TYPE_IMG
- en: Right-click on the com.nativemoduleapp package, select New | Java Class, and
    name the class `HelloManager`. Also, be sure to set the Kind field to Class:![](assets/013c754f-9fee-45fe-bc62-489f19635a05.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll also need a `HelloPackage` class in the same directory. You can repeat
    steps 2 and 3 to create this class, simply applying the new name and keeping the
    Kind field set to Class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s start by implementing our `HelloManager` native module. We''ll start
    with the `package` name and the dependencies we''ll need in this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`ReactContextBaseJavaModule` is the base class for all React Native modules,
    so we''ll be creating the `HelloManager` class as a subclass of it. We also need
    to define a `getName` method, which is used for registering native modules with
    the React Native bridge. This is one difference from the iOS native module implementations,
    as those are defined via class name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve set up our `HelloManager` native module, it''s time to add
    the `greetUser` method to it, which will expect as arguments `name`, `isAdmin`,
    and the callback that will be executed to send the message to the React Native
    layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Another step that''s unique to Android is having to register the native module
    with the application, which is a two-step process. The first step is to add our
    `HelloManager` module to the `HelloPackage` class we created earlier. We''ll start
    with the dependencies for `HelloPackage.java`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of `HelloPackage` simply follows the pattern provided by
    the official documentation ([https://facebook.github.io/react-native/docs/native-modules-android.html](https://facebook.github.io/react-native/docs/native-modules-android.html)).
    The most important piece here is the call to `modules.add`, where a new instance
    of `HelloManager` is passed in with `reactContext` as its parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The second step in registering the native module with the React Native app
    is to add `HelloPackage` to the `MainApplication` module. Most of the code here
    is generated by the React Native bootstrapping process. The `getPackages` method
    needs to be updated to take both `new MainReactPackage()` and `new HelloPackage()`
    as arguments passed to `Arrays.asList`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re all done on the Java portion of this recipe. We need to build our UI,
    which will invoke the native `HelloManager greetUser` method and display its output.
    In this example, we''ll be using `TextInput` and `Switch` to provide `name` and
    the `isAdmin` value for the native module method. This is the same functionality
    as we implemented on iOS in the *Exposing custom iOS modules* recipe. Let''s get
    to building out `App.js`, starting with the dependencies we''ll need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to make a reference to the `HelloManager` object that lives on the
    imported `NativeModules` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create the `App` class and the initial `state`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re ready to define the component''s `render` function. This piece of code
    will not be described in great detail, as it''s basically the same `render` function
    defined in the *Exposing custom iOS modules* recipe at the beginning of this chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'With the UI rendering the necessary components, we now need to wire up the `onPress`
    handler of `Button` to make the native call via `HelloManager.greetUser`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll add styles to layout and style the app. Again, these are the same styles
    as used in the *Exposing custom iOS modules* recipe at the beginning of this chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The final app should look similar to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/7eb97b69-1929-45c0-adb7-a2d689e5b051.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe covers the foundation for much of what we'll be doing with adding
    native Android modules in future recipes. All native module classes need to extend
    `ReactContextBaseJavaModule`, implement the constructor, and define the `getName`
    method. All methods that should be exposed to the React Native layer need to have
    the `@ReactMethod` annotation. Creating a React Native Android native module has
    more overhead as compared with iOS, since you have to also wrap your module in
    a class that implements `ReactPackage` (in this recipe, that's the `HelloPackage`
    module), and register the package with the React Native project. This is done
    in steps 7 and 8.
  prefs: []
  type: TYPE_NORMAL
- en: In the JavaScript portion of the recipe, the `greetUser` function is executed
    when the user presses the `Button` component. This, in turn, makes a call to `HelloManager.greetUser`,
    passing along the `userName` and `isAdmin` properties from `state` and the `updateGreetingMessage` method
    as a callback. The `updateGreetingMessage` sets the new `greetingMessage` on `state`,
    causing a refresh of the UI and the message to be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering custom Android view components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One reason React Native has gained so much popularity so far is its ability
    to render truly native UI components. With native UI components on Android, we're
    able to leverage not only the GPU rendering power, but we also get the native
    look and feel of native components, including native fonts, colors, and animations.
    Web and hybrid applications on Android use CSS polyfills to simulate a native
    animation but, in React Native, we can get the real thing.
  prefs: []
  type: TYPE_NORMAL
- en: We'll need a new pure React Native app for this recipe. Let's name it `NativeUIComponent`.
    In this recipe, we'll take a native `Button` and expose it as a React Native view
    component.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start by opening the Android project in Android Studio. In the Android
    Studio welcome screen, select Open an existing Android Studio project and open
    the `android` directory of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the project explorer and expand the package structure until you can see
    the Java source files (for example, `app/java/com.nativeuicomponent`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/ea40d86e-ce4c-419a-a7fc-6ded42199f2c.png)'
  prefs: []
  type: TYPE_IMG
- en: Right-click on the package and select New | Java Class. Use `ButtonViewManager`
    for the class name and set the Kind field to Class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the same method to also create a `ButtonPackage` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s begin implementing our `ButtonViewManager` class, which must be a subclass
    of `SimpleViewManager<View>`. We''ll start with the imports and define the class
    itself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The file class name `ButtonViewManager` follows the Android naming convention
    of adding the suffix `ViewManager` to any `View` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start the class definition with the `getName` method that returns the
    string name we''re assigning the component, which in this case is `ButtonView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `createViewInstance` method is required for defining how React should initialize
    the module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '`setButtonText` will be used from the properties on the React Native element
    to set the text on the button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onClick` method defines what will happen when the button is pressed. This
    method uses `RCTEventEmitter` to handle receiving events from the React Native
    layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like in the last recipe, we need to add `ButtonViewManager` to `ButtonPackage`;
    however, this time, we''re defining it as `ViewManager` and not `NativeModule`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step in the Java layer is adding `ButtonPackage` to `MainApplication`.  `MainApplication.java`
    already has quite a bit of boilerplate code in it, and we''ll only need to change
    the `getPackages` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Switching over to the JavaScript layer, let''s build out our React Native app.
    First, let''s create a new `Button` component in `components/Button.js` in the
    project''s root directory. This is where the native button will live inside the
    React Native layer of the app. The `render` method uses the native button as `ButtonView`,
    which we''ll define in the next step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create the native button as a React Native component with the `requireNativeComponent`
    helper, which takes three parameters: the string `ButtonView` to define the components
    name, the `Button` component defined in the previous step, and the options object.
    There''s more information on this object in the *How it works...* section at the
    end of this recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re ready to define the `App` class. Let''s start with dependencies, including
    the `Button` component created previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The `App` component in this recipe is essentially the same as the *Rendering
    custom iOS view components* recipe earlier in this chapter. The custom `onTap`
    property is fired when the `Button` component is pressed, adding `1` to the `count`
    property on `state`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add a few styles to layout and size the app''s UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The final app should look similar to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/c356c27a-7bdc-4589-ba9e-4c510bdf34db.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When defining a native view, as we did with the `ButtonViewManager` class, it
    must extend `SimpleViewManager` and render a type that extends `View`. In our
    recipe, we rendered a `Button` view, and we used the `@ReactProp` annotation for
    defining properties. When we need to communicate back to the JavaScript layer,
    we fire an event from the native component, which we implemented in *step 9* of
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 12*, we created an `onChange` listener, which will execute the event
    handler passed in from the Android layer (`event.nativeEvent.message`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding the use of the `nativeOnly` option on *step 13*, from the React Native
    documents:'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes you'll have some special properties that you need to expose for the
    native component, but don't actually want them as part of the API for the associated
    React component. For example, `Switch` has a custom `onChange` handler for the
    raw native event, and exposes an `onValueChange` handler property that is invoked
    with just the Boolean value, rather than the raw event. Since you don't want these
    native only properties to be part of the API, you don't want to put them in `propTypes`,
    but if you don't, you'll get an error. The solution is simply to call them out
    via the `nativeOnly` option.
  prefs: []
  type: TYPE_NORMAL
