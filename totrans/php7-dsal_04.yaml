- en: Constructing Stacks and Queues
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In everyday life, we use two of the most common data structures. We can assume
    that these data structures are inspired by the real-world, but they have very
    important effects in the computing world. We are talking about stack and queue
    data structures. We stack our books, files, plates, and clothes on a daily basis,
    whereas we maintain queues for ticket counters, bus stops, and shopping checkouts.
    Also, we have heard about message queue in PHP, one of the most used features
    in high-end applications. In this chapter, we are going to explore the different
    implementations of popular stack and queue data structures. We are going to learn
    about queues, priority queues, circular queues, and double-ended queues in PHP.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Understanding stack
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The stack is a linear data structure that follows the **Last-In** , **First-Out**
    (**LIFO** ) principle. This means that there is only one end for the stack, which
    is used to add items and remove items from the structure. The addition of new
    items in the stack is known as push, and push whilst removing an item is known
    as pop. Since we only have one end to operate, we are always going to push an
    item at that end, and when we pop, the last item from that end will be popped
    up. The top most elements in the stack that are also at the very beginning of
    the stack end are known as the top. If we consider the following image, we can
    see that after each pop and push operation, the top changes. Also, we are performing
    the operation at the top of the stack, not at the beginning or middle of the stack.
    We have to be careful about popping an element when the stack is empty, as well
    as pushing an element when the stack is full. We might have a stack overflow if
    we want to push more elements than its capacity.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00027.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
- en: 'From our earlier discussion, we now know that we have four basic operations
    in a stack:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '**Push** : add an item at the top of the stack.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pop** : remove the top item of the stack.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Top** : returns the top item of the stack. It is not the same as pop, as
    it does not remove the item, it just gets the value for us.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**isEmpty** : checks whether the stack is empty or not.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let us implement the stack using PHP, but in different ways. First, we will
    try to implement the stack using PHP's built-in array function. Then we will look
    at how to build a stack without using PHP's built-in functions, but by using some
    other data structures, such as linked lists.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a stack using PHP array
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we will create an interface for the stack so that we can use it in different
    implementations, and can ensure that all implementations have some similarity
    to each other. Let us write the simple interface for the stack:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As we can see from the preceding interface, we kept all stack functions inside
    the interface because the class that it is implementing must have all these mentioned
    functions, otherwise, else a fatal error will be thrown during runtime. Since
    we are implementing the stack using a PHP array, we are going to use some existing
    PHP functions for push, pop, and top operations. We are going to implement the
    stack in such a way that we can define the size of the stack. If there is no item
    in the array and we still want to pop, it will throw an underflow exception, and
    if we try to push more items than its capacity allows, then an overflow exception
    will be thrown. Here is the code for a stack implementation using an array:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now let us go through the code we have written for the stack. We named the
    stack implementation `Books` , but we can name it anything we want as long as
    it''s a valid class name. First, we construct the stack using the `__construct()`
    method with an option to limit the number of items we can store in the stack.
    The default value is set at `20` . The next method defines the pop operation:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `pop` method will return a string if the stack is not empty. We use the
    empty method we defined in the stack class for this purpose. If the stack is empty,
    we throw an `UnderFlowException` from SPL. If there is no item to pop, we can
    prevent that operation from taking place. If the stack is not empty, we use the
    `array_pop` function from PHP to return the last item from the array.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: In the push method, we do the opposite of pop. First, we check whether or not
    the stack is full. If it is not, we add the string item at the end of the stack
    using the `array_push` function of PHP. If the stack is full, we throw an `OverFlowException`
    from SPL. The `top` method returns the top most element of the stack. The `isEmpty`
    method checks whether or not the stack is empty.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Since we are following PHP 7, we are using both scalar type declarations at
    method level and return types for methods.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use our just implemented stack class, we have to think of an example
    where we can use all these operations. Let us write a small program to make a
    book stack. Here is the code for this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We have created an instance for our book stack, and for keeping our programming
    book titles in it. We have three push operations. The last inserted book name
    is `"MySQL workbench tutorial"` . If we pop after three push operations, we will
    have this title name as the return. After that, the top will return `"Mastering
    JavaScript"` , which will become the top item once the pop operation has been
    performed. We are nesting the whole code in a `try...catch` block so that we can
    handle the exception thrown by the overflow and underflow. The preceding code
    will have the following output:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now let us focus on the complexities of the different stack operations we have
    just completed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Understanding complexity of stack operations
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is the time complexity of different stack operations. For the worst case,
    the time complexities for stack operations are as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | **Time Complexity** |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
- en: '| pop | `O(1)` |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
- en: '| push | `O(1)` |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
- en: '| top | `O(1)` |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
- en: '| isEmpty | `O(1)` |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
- en: Since the stack operates at one end that remembers the top of the stack all
    the time, if we want to search for an item in the stack, it means we have to search
    through the whole list. It is the same for accessing a particular item in the
    stack. Although it is not good practice to use stack for these sorts of operations,
    if we want to do so, we have to remember that the time complexity is based on
    more than general stack operations.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | **Time Complexity** |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
- en: '| Access | `O(n)` |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
- en: '| Search | `O(n)` |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
- en: The space complexity for stack is always `O(n)` .
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have seen how to implement stack using a PHP array and it's built-in
    function line `array_pop` and `array_push` . But we could have ignored the built-in
    functions and implemented it with manual array operations, or we could have used
    the `array_shift` and `array_unshift` built-in functions.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Implementing stack using linked list
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 3](text00065.html) , *Using Linked Lists* , we learned how to implement
    linked lists. We saw that in a linked list we can insert a node at the end, remove
    it from the end, insert it into the middle of the list, at the beginning, and
    so on. If we consider the insert at the end and remove at the end operations of
    a single linked list data structure, we can easily perform something similar with
    stack. So let us use our `LinkedList` class from the previous chapter to implement
    with the stack. This is how the code will look:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let us go through each of the code blocks to understand what is happening here.
    If we start from the top, we can see that in the `constructor` method, we are
    creating a new `LinkedList` object and assigning it to our stack property instead
    of the array in the previous example. We are assuming that the `LinkedList` class
    is autoloaded, or the file is included in the script. Let us now focus on the
    push operation. The push operation is as simple as it can get. We just need to
    insert a new node in the linked list. Since we do not have any size limit for
    the linked list, we are not checking any overflow here.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'In our linked list implementation, there was no method for displaying the last
    node. We had inserted a new last node and removed the previous last node, but
    here, we need to get the value of the last node without deleting it. In order
    to achieve that functionality, which is exactly the top operation for our stack,
    we can utilize the `getNthNode` method along with `getSize` from the `LinkedList`
    implementation. This way, we can get the node. But we have to remember one thing:
    we want the string value of the node, not the full node object. That is why we
    return the data property of the returned node.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the top operation, the pop operation also needs to return the last
    node''s data before removing it from the list. In order to achieve that, we use
    the `top()` method and then the `deleteLast()` method from the `LinkedList` class.
    Now let us run a sample code to use this newly implemented `BookList` class for
    stack operations. Here is the code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It looks quite similar to the last example we ran, but here we are trying to
    do two pop operations and then the top one. So the output will look like the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If we know the basic behavior of the stack and how to achieve it, we can use
    an array, linked list, doubly linked list to implement stack. Since we have already
    seen the array and linked list implementations, we are now going to explore the
    SPL implementation of a stack, which actually uses a doubly linked list.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Using SplStack class from SPL
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we are not interested in implementing our own version of a stack, we can
    use the existing SPL implementation for stacks. It is very easy to use and requires
    minimal code to write. As we already know, `SplStack` uses `SplDoublyLinkedList`
    . It has all possible operations to push, pop, move forward, backward, shift,
    unshift, and so on. In order to implement the same example we saw previously,
    we have to write the following lines:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Yes, it is this simple to build a stack using the `SplStack` class. It is up
    to us to decide whether we want to implement it using a PHP array, a linked list,
    or a built-in class, such as `SplStack` .
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Real life usage of stack
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stack has many usages in modern day applications. Whether in browser histories
    or in the popular development term stack trace, stack is used everywhere. Now
    we are going to try to solve a real-world problem using stack.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Nested parentheses matching
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we are solving mathematical expressions, the first thing we need to consider
    is the correctness of nested parentheses. If the parentheses are not nested properly,
    then calculation might not be possible, or may be wrong. Let us look at some examples:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00028.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: 'From the preceding expressions, only the first one is correct; the other two
    are incorrect, as the parentheses are not nested properly. In order to identify
    whether or not the parentheses are nested, we can use stack to implement the solution.
    Here is the pseudo algorithm for the implementation:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we look at the pseudocode, it looks very simple. The goal is to ignore any
    numbers, operands, or empty spaces from the string and only consider the parentheses,
    curly braces, and brackets. If they are opening brackets, we will push into the
    stack. If they are closing brackets, we are going to pop the stack. If the popped
    parenthesis is not the opening one we are trying to match, then it is not valid.
    At the end of the loop, the stack should be empty if the string is valid. But
    if the stack is not empty, then there are extra parentheses, so the string is
    not valid. Now let us convert this to a program:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看伪代码，看起来非常简单。目标是忽略字符串中的任何数字、操作数或空格，并只考虑括号、大括号和方括号。如果它们是开放括号，我们将推入堆栈。如果它们是闭合括号，我们将弹出堆栈。如果弹出的括号不是我们要匹配的开放括号，则它是无效的。循环结束时，如果字符串有效，则堆栈应为空。但是如果堆栈不为空，则有额外的括号，因此字符串无效。现在让我们将其转换为程序：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now let us run the three examples we discussed earlier:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运行我们之前讨论的三个示例：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This will produce the following output, which is exactly what we wanted:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生我们想要的以下输出：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Understanding queue
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解队列
- en: 'The queue is another special linear data structure that follows the **First-In**
    , **First-Out** (**FIFO** ) principle. There are two ends for the operation: one
    to append to the queue and one to remove from the queue. This is different from
    a stack, where we used one end for both the add and remove operations. The insertion
    will always be at the back or rear section. The removal of an element will take
    place from the frontend. The process of adding a new element to the queue is known
    as enqueue and the process of removing an element is known as dequeue. The process
    of looking at the front element of the queue without removing the element is known
    as a peek, similar to the top operation of a stack. The following figure depicts
    a representation of a queue:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 队列是另一种遵循**先进先出**（**FIFO**）原则的特殊线性数据结构。操作有两端：一个用于向队列追加，一个用于从队列中移除。这与堆栈不同，堆栈中我们使用一个端口进行添加和移除操作。插入将始终在后部或后部进行。元素的移除将从前端进行。向队列添加新元素的过程称为入队，移除元素的过程称为出队。查看队列前端元素而不移除元素的过程称为peek，类似于堆栈的top操作。以下图示表示队列的表示：
- en: '![](Image00029.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00029.jpg)'
- en: 'Now, if we define an interface for a queue, it will look like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们为队列定义一个接口，它将如下所示：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now we can implement the queue using different methods, as we did for the stack.
    First, we are going to implement the queue using a PHP array, followed by `LinkedList`
    , and then `SplQueue` .
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用不同的方法实现队列，就像我们为堆栈所做的那样。首先，我们将使用PHP数组实现队列，然后是`LinkedList`，然后是`SplQueue`。
- en: Implementing a queue using PHP array
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PHP数组实现队列
- en: 'We are now going to implement the queue data structure using a PHP array. We
    have already seen that we can use the `array_push()` function to add an element
    at the end of the array. In order to remove the first element of the array, we
    can use the `array_shift()` function of PHP, and for the peek function, we can
    use the `current()` function of PHP. Here is how the code will look, based on
    our discussion:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用PHP数组来实现队列数据结构。我们已经看到我们可以使用`array_push()`函数将元素添加到数组的末尾。为了删除数组的第一个元素，我们可以使用PHP的`array_shift()`函数，对于peek函数，我们可以使用PHP的`current()`函数。根据我们的讨论，代码将如下所示：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, we are maintaining the same principle we did for the stack. We want to
    define a fixed-size queue, with checking of overflow and underflow. In order to
    run the queue implementation, we can consider using it as an agent queue for a
    call center application. Here is the code to utilize our queue operations:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们保持了与堆栈相同的原则。我们希望定义一个固定大小的队列，并检查溢出和下溢。为了运行队列实现，我们可以考虑将其用作呼叫中心应用程序的代理队列。以下是利用我们的队列操作的代码：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will produce the following output:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Implementing a queue using linked list
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用链表实现队列
- en: 'As we did with the stack implementation, we are going to use our linked list
    implementation in [Chapter 3](text00065.html) , *Using Linked Lists* , to implement
    the queue here. We can use the `insert()` method to ensure that we are always
    inserting at the end. We can use `deleteFirst()` for a dequeue operation and `getNthNode()`
    for a peek operation. Here is the sample implementation of a queue using a linked
    list:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 与堆栈实现一样，我们将在[第3章](text00065.html)中使用我们的链表实现，*使用链表*，在这里实现队列。我们可以使用`insert()`方法来确保我们始终在末尾插入。我们可以使用`deleteFirst()`进行出队操作，使用`getNthNode()`进行查看操作。以下是使用链表实现队列的示例实现：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Using SplQueue class from SPL
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SPL中的SplQueue类
- en: 'If we do not want any hard time implementing queue functionalities, and are
    happy with a built-in solution, we can use the `SplQueue` class for any of our
    basic queue needs. We have to remember one thing: that there is no peek function
    available in the `SplQueue` class. We have to use the `bottom()` function to get
    the first element of the queue. Here is the simple queue implementation for our
    `AgentQueue` using `SplQueue` :'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想费力实现队列功能，并且满意于内置解决方案，我们可以使用`SplQueue`类来满足我们的基本队列需求。我们必须记住一件事：`SplQueue`类中没有peek函数可用。我们必须使用`bottom()`函数来获取队列的第一个元素。以下是使用`SplQueue`为我们的`AgentQueue`实现的简单队列实现：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Understanding priority queue
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解优先队列
- en: A priority queue is a special type of queue where items are inserted and removed
    based on their priority. In the programming world, the use of the priority queue
    is immense. For example, say that we have a very large e-mail queue system where
    we send a monthly newsletter through a queue system. What if we need to send an
    urgent email to a user using the same queue functionality? Since the general queue
    principle is to add the item at the end, the process of sending that message will
    be very much delayed. In order to solve the problem, we can use the priority queue.
    In such a case, we assign a priority to each node and sort them based on that
    priority. An item with higher priority will go to the top of the list and will
    be dequeued earlier.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: We can take two approaches in building a priority queue.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Ordered sequence
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we plan an ordered sequence for a priority queue, it can have either an ascending
    or a descending order. The positive side of having an order sequence is that we
    can quickly find the maximum or remove the maximum priority item, as we can find
    it using `O(1)` complexity. But the insertion will take more time, as we have
    to check each element in the queue to place the item in the right position based
    on its priority.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Unordered sequence
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The unordered sequence does not require us to go through each queue element
    in order to place the newly added element. It is always added to the rear as a
    general queue principle. As a result, we can achieve the enqueue operation with
    `O(1)` complexity. But if we want to find or remove the highest priority element,
    then we have to go through each element to find the right one. As a result, it
    is not very search-friendly.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Now we are going to write code to implement the priority queue using an ordered
    sequence with a linked list.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Implementing priority queue using linked list
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have seen a linked list using only one value, which is the node
    data. Now we need to pass another value that will be the priority. In order to
    achieve that, we need to change our `ListNode` implementation:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we have both the data and the priority as part of the node. In order to
    allow this priority to be considered during the insert operation, we also need
    to change our `insert()` implementation inside the `LinkedList` class. Here is
    the modified implementation:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As we can see, our `insert` method has been changed to take both the data and
    the priority during the insert operation. As usual, the first process is to create
    a new node and increment the node count. There can be three possibilities for
    insertion, shown as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: The list is empty, so the new node is the first node.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list is not empty, but the new item has the highest priority, so. So it
    becomes the first node and the previous first node follows it.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list is not empty and the priority is not the highest, so it inserts the
    new node inside the list, or maybe at the end of the list.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our implementation, we have considered all three possibilities, three facts.
    As a result, we always have the highest priority item at the beginning of the
    list. Now let us run the `AgentQueue` implementation with this new code, as shown
    in the following example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If there was no priority, then the queue should have been `Fred` , `John` ,
    `Keith` , `Adiyan` , and `Mikhael` . But since we have added priorities to the
    list, the output is:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Since `Adiyan` has the highest priority, it is placed at the beginning of the
    queue, even though it was inserted in the fourth place in the queue.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Implement a priority queue using SplPriorityQueue
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'PHP already has a built-in support for implementing a priority queue using
    SPL. We can use the `SplPriorityQueue` class to implement our priority queues.
    Here is the sample previous example using a linked list, but this time we are
    choosing SPL:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This will produce the same result as the linked list example. The added advantage
    of extending to our own `MyPQ` class is that we can define whether we want to
    sort it in ascending or descending order. Here, we are choosing a descending order,
    sorting using a PHP combined comparison operator, or the spaceship operator.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, priority queues are implemented using heap. When we move on
    to the heap chapter, we will also implement a priority queue using heap.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a circular queue
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we use a standard queue, every time we dequeue an item, we have to re-buffer
    the whole queue. In order to solve this problem, we can use a circular queue,
    where the rear is followed by the front, forming a circle. This special type of
    queue requires a special calculation for the enqueue and dequeue operations, with
    consideration of the rear, front, and limit of the queue. Circular queues are
    always fixed queues, and are also known as circular buffers, or ring buffers.
    The following figure shows a representation of a circular queue:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00030.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: 'We can implement a circular queue using a PHP array. Since we have to calculate
    the positions of the rear and front part, the array can be used efficiently for
    this purpose. Here is an example of a circular queue:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Since we are considering `0` as a front marker, the total size of the queue
    will be of the `limit -1` .
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Creating a double - ended queue (deque)
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have implemented queues where one end is used for enqueuer, and
    is known as the rear, and the other end is used for dequeuer, and is known as
    the front. So, in general, each end should be used for a specific purpose. But
    what if we need to enqueuer and dequeuer from both ends? This is possible by using
    a concept called the double-ended queue or deque. In deque, both ends can be used
    for enqueue and dequeue operations. If we look at our queue implementation using
    linked list, we find that we can insert at last, insert at first, delete at last,
    and delete at first using our linked list implementation. If we implement a new
    deque class based on that, we can easily achieve our desired goals. The following
    figure depicts a double-ended queue:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00031.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
- en: 'Here is the implementation of a deque:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now we are going to use this class to check the operations of a double-ended
    queue:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If we look at the preceding code example, first we add `Fred` at the front,
    then we add `John` at the front again. So the sequence is now `John` , `Fred`
    . Then we add `Keith` at the back, followed by `Adiyan` at the back. So now we
    have the sequence `John` , `Fred` , `Keith` , `Adiyan` . Lastly, we add `Mikhael`
    at the beginning. So the final sequence is `Mikhael` , `John` , `Fred` , `Keith`
    , `Adiyan` .
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are performing a dequeue from the back first, `Adiyan` will be out
    first, and then `Mikhael` from the front. The new peek at the front will be `John`
    . Here is the output when you run the code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Summary
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stacks and queues are one of the most used data structures. In future algorithms
    and data structures, we can use these abstract data types in different ways. In
    this chapter, we learned of the different ways of implementing stacks and queues,
    along with the different types of queues. In the next chapter, we are going to
    talk about recursion - a special way to solve bigger problems by dividing them
    into smaller instances.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
