- en: Chapter 5. Category Theory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Thomas Watson was famously quoted as saying, "I think there is a world market
    for maybe five computers". That was in 1948\. Back then, everybody knew that computers
    would only be used for two things: math and engineering. Not even the biggest
    minds in tech could predict that, one day, computers would be able to translate
    Spanish to English, or simulate entire weather systems. At the time, the fastest
    machine was IBM''s SSEC, clocking in at 50 multiplications per second, the display
    terminal wasn''t due until 15 years later and multiple-processing meant multiple
    user terminals sharing a single processor. The transistor changed everything,
    but tech''s visionaries still missed the mark. Ken Olson made another famously
    foolish prediction when, in 1977, he said "There is no reason anyone would want
    a computer in their home".'
  prefs: []
  type: TYPE_NORMAL
- en: It seams obvious to us now that computers are not just for scientists and engineers,
    but that's hindsight. The idea that machines can do more than just math was anything
    but intuitive 70 years ago. Watson didn't just fail to realize how computers could
    transform a society, he failed to realize the transformative and evolving powers
    of mathematics.
  prefs: []
  type: TYPE_NORMAL
- en: But the potential of computers and math was not lost on everybody. John McCarthy
    invented **Lisp** in 1958, a revolutionary algorithm-based language that ushered
    in a new era in computing. Since its inception, Lisp was instrumental in the idea
    of using abstraction layers—compilers, interpreters, virtualization—to push forward
    the progression of computers from hardcore math machines to what they are today.
  prefs: []
  type: TYPE_NORMAL
- en: From Lisp came **Scheme**, a direct ancestor of JavaScript. Now that brings
    us full circle. If computers are, at their core, machines that just do math, then
    it stands to reason that a math-based programming paradigm would excel.
  prefs: []
  type: TYPE_NORMAL
- en: 'The term "math" is being used here not to describe the "number crunching" that
    computers can obviously do, but to describe *discrete mathematics*: the study
    of discrete, mathematical structures such as statements in logic or the instructions
    of a computer language. By treating code as a discrete mathematical structure,
    we can apply concepts and ideas in math to it. This is what has made functional
    programming so instrumental in artificial intelligence, graph search, pattern
    recognition and other big challenges in computer science.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will experiment with some of these concepts and their applications
    in everyday programming challenges. They will include:'
  prefs: []
  type: TYPE_NORMAL
- en: Category theory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Morphisms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maybes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lenses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these concepts, we'll be able to write entire libraries and APIs very easily
    and safely. And we'll go from explaining category theory to formally implementing
    it in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Category theory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Category theory is the theoretical concept that empowers function composition.
    Category theory and function composition go together like engine displacement
    and horsepower, like NASA and the space shuttle, like good beer and a mug to pour
    it in. Basically, you can't have one without the other.
  prefs: []
  type: TYPE_NORMAL
- en: Category theory in a nutshell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Category theory really isn't too difficult a concept. Its place in math is large
    enough to fill up an entire graduate-level college course, but its place in computer
    programming can be summed up quite easily.
  prefs: []
  type: TYPE_NORMAL
- en: Einstein once said, "If you can't explain it to a 6-year-old, you don't know
    it yourself". Thus, in the spirit of explaining it to a 6-year-old, *category
    theory is just connecting the dots*. Although it may be grossly over-simplifying
    category theory, it does do a good job of explaining what we need to know in a
    straightforward manner.
  prefs: []
  type: TYPE_NORMAL
- en: First you'll need to know some terminology. **Categories** are just sets with
    the same type. In JavaScript, they're arrays or objects that contain variables
    that are explicitly declared as numbers, strings, Booleans, dates, nodes, and
    so on. **Morphisms** are pure functions that, when given a specific set of inputs,
    always return the same output. **Homomorphic operations** are restricted to a
    single category, while **polymorphic operations** can operate on multiple categories.
    For example, the homomorphic function *multiplication* only works on numbers,
    but the polymorphic function addition can work on strings too.
  prefs: []
  type: TYPE_NORMAL
- en: '![Category theory in a nutshell](../images/00004.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The following diagram shows three categories—A, B, and C—and two morphisms—*ƒ*
    and *ɡ*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Category theory tells us that, when we have two morphisms where the category
    of the first one is the expected input of the other, then they can be *composed*
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Category theory in a nutshell](../images/00005.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The *ƒ o g* symbol is the composition of morphisms *ƒ* and *g*. Now we can just
    connect the dots.
  prefs: []
  type: TYPE_NORMAL
- en: '![Category theory in a nutshell](../images/00006.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: And that's all it really is, just connecting dots.
  prefs: []
  type: TYPE_NORMAL
- en: Type safety
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s connect some dots. Categories contain two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Objects (in JavaScript, types).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Morphisms (in JavaScript, pure functions that only work on types).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These are the terms given to category theory by mathematicians, so there is
    some unfortunate nomenclature overloading with our JavaScript terminology. **Objects**
    in category theory are more like variables with an explicit data type and not
    collections of properties and values like in the JavaScript definition of objects.
    **Morphisms** are just pure functions that use those types.
  prefs: []
  type: TYPE_NORMAL
- en: So applying the idea of category theory to JavaScript is pretty easy. Using
    category theory in JavaScript means working with one certain data type per category.
    Data types are numbers, strings, arrays, dates, objects, Booleans, and so on.
    But, with no strict type system in JavaScript, things can go awry. So we'll have
    to implement our own method of ensuring that the data is correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four primitive data types in JavaScript: numbers, strings, Booleans,
    and functions. We can create *type safety functions* that either return the variable
    or throw an error. *This fulfils the object axiom of categories*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: However, there's a lot of repeated code here and that isn't very functional.
    Instead, we can create a function that returns another function that is the type
    safety function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can use them to ensure that our functions behave as expected.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let's look at a meatier example. If we want to check the length of a Unix timestamp
    that is returned by the JavaScript function `Date.parse(),` not as a string but
    as a number, then we'll have to use our `str()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Functions like this that explicitly transform one type to another (or to the
    same type) are called *morphisms*. *This fulfils the morphism axiom of category
    theory*. These forced type declarations via the type safety functions and the
    morphisms that use them are everything we need to represent the notion of a category
    in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Object identities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There''s one other important data type: objects.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: However, objects are different. They can be inherited. Everything that is not
    a primitive—numbers, strings, Booleans, and functions—is an object, including
    arrays, dates, elements, and more.
  prefs: []
  type: TYPE_NORMAL
- en: There's no way to know what type of object something is, as in to know what
    sub-type a JavaScript 'object' is, from the `typeof` keyword, so we'll have to
    improvise. Objects have a `toString()` function that we can hijack for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Again, with all the objects out there, we should implement some code re-use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'These will be very useful for our next topic: functors.'
  prefs: []
  type: TYPE_NORMAL
- en: Functors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While morphisms are mappings between types, *functors* are mappings between
    categories. They can be thought of as functions that lift values out of a container,
    morph them, and then put them into a new container. The first input is a morphism
    for the type and the second input is the container.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The type signature for functors looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This says, "give me a function that takes `a` and returns `b` and a box that
    contains `a`(s), and I'll return a box that contains `b`(s).
  prefs: []
  type: TYPE_NORMAL
- en: Creating functors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It turns out we already have one functor: `map()`. It grabs the values within
    the container, an array, and applies a function to it.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: However, we'll need to write it as a global function and not as a method of
    the array object. This will allow us to write cleaner, safer code later on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This example seems like a contrived wrapper because we're just piggybacking
    onto the `map()` function. But it serves a purpose. It provides a template for
    maps of other types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Arrays and functors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrays are the preferred way to work with data in functional JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Is there an easier way to create functors that are already assigned to a morphism?
    Yes, and it's called `arrayOf`. When you pass in a morphism that expects an integer
    and returns an array, you get back a morphism that expects an array of integers
    and returns an array of arrays.
  prefs: []
  type: TYPE_NORMAL
- en: It is not a functor itself, but it allows us to create functors from morphisms.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how to create functors by using morphism:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The interesting property of the `arrayOf` functor is that it works on type safeties
    as well. When you pass in the type safety function for strings, you get back a
    type safety function for an array of strings. The type safeties are treated like
    the *identity function* morphism. This can be very useful for ensuring that an
    array contains all the correct types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Function compositions, revisited
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions are another type of primitive that we can create a functor for. And
    that functor is called `fcompose`. We defined functors as something that takes
    a value from a container and applies a function to it. When that container is
    a function, we just call it to get its inner value.
  prefs: []
  type: TYPE_NORMAL
- en: We already know what function compositions are, but let's look at what they
    can do in a category theory-driven environment.
  prefs: []
  type: TYPE_NORMAL
- en: Function compositions are associative. If your high school algebra teacher was
    like mine, she taught you what the property *is* but not what it can *do*. In
    practice, compose is what the associative property can do.
  prefs: []
  type: TYPE_NORMAL
- en: '![Function compositions, revisited](../images/00007.jpeg)![Function compositions,
    revisited](../images/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can do any inner-compose, it doesn't matter how it's grouped. This is not
    to be confused with the commutative property. *ƒ o g* does not always equal *g
    o ƒ*. In other words, the reverse of the first word of a string is not the same
    as the first word of the reverse of a string.
  prefs: []
  type: TYPE_NORMAL
- en: What this all means is that it doesn't matter which functions are applied and
    in what order, as long as the input of each functions comes from the output of
    the previous function. But wait, if the function on the right relies on the function
    on the left, then can't there be only one order of evaluation? Left to right?
    True, but if it's encapsulated, then we can control it however we feel fit. This
    is what empowered lazy evaluation in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: '![Function compositions, revisited](../images/00009.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s rewrite function composition, not as an extension of the function prototype,
    but as a stand-alone function that will allow us to get more out of it. The basic
    form is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: But we'll need it to work on any number of inputs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've encapsulated the functions, we have control over them. We could
    rewrite the compose function such that *each function accepts another function
    as input, stores it, and gives back an object that does the same*. Instead of
    accepting an array as an input, doing something with it, and then giving back
    a new array for each operation, we can accept a single array for each element
    in the source, perform all operations combined (every `map()`, `filter()`, and
    so on, composed together), and finally store the results in a new array. This
    is lazy evaluation via function composition. No reason to reinvent the wheel here.
    Many libraries have a nice implementation of this concept, including the `Lazy.js`,
    `Bacon.js` and `wu.js` libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a lot more we can do as a result of this different model: asynchronous
    iteration, asynchronous event handling, lazy evaluation, and even automatic parallelization.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Automatic parallelization? There''s a word for that in the computer science
    industry: IMPOSSIBLE. But is it really impossible? The next evolutionary leap
    in Moore''s law might be a compiler that parallelizes our code for us, and could
    function composition be it?'
  prefs: []
  type: TYPE_NORMAL
- en: No, it doesn't quite work that way. The JavaScript engine is what is really
    doing the parallelization, not automatically but with well thought-out code. Compose
    just gives the engine the chance to split it into parallel processes. But that
    in itself is pretty cool.
  prefs: []
  type: TYPE_NORMAL
- en: Monads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Monads** are tools that help you compose functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Like primitive types, monads are structures that can be used as the containers
    that functors "reach into". The functors grab the data, do something to it, put
    it into a new monad, and return it.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three monads we''ll focus on:'
  prefs: []
  type: TYPE_NORMAL
- en: Maybes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lenses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So in addition to arrays (map) and functions (compose), we'll have five functors
    (map, compose, maybe, promise and lens). These are just some of the many other
    functors and monads that are out there.
  prefs: []
  type: TYPE_NORMAL
- en: Maybes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Maybes allow us to gracefully work with data that might be null and to have
    defaults. A maybe is a variable that either has some value or it doesn't. And
    it doesn't matter to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'On its own, it might seem like this is not that big a deal. Everybody knows
    that null-checks are easily accomplished with an `if-else` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: But with functional programming, we're breaking away from the procedural, line-by-line
    way of doing things and instead working with pipelines of functions and data.
    If we had to break the chain in the middle just to check if the value existed
    or not, we would have to create temporary variables and write more code. Maybes
    are just tools to help us keep the logic flowing through the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: To implement maybes, we'll first need to create some constructors.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we can write the `maybe` function. It returns a new function that either
    returns nothing or a maybe. *It is a functor*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: And we can also create a functor generator just like we did with arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: So `Maybe` is a monad, `maybe` is a functor, and `maybeOf` returns a functor
    that is already assigned to a morphism.
  prefs: []
  type: TYPE_NORMAL
- en: We'll need one more thing before we can move forward. We'll need to add a method
    to the `Maybe` monad object that helps us use it more intuitively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In its raw form, maybes can be used directly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Anything that returns a method that is then executed is complicated enough to
    be begging for trouble. So we can make it a little cleaner by calling on our `curry()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: But the real power of maybes will become clear when the dirty business of directly
    calling the `none()` and `just()` functions is abstracted. We'll do this with
    an example object `User`, that uses maybes for the username.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: And now we have a powerful and safe way to define defaults. Keep this `User`
    object in mind because we'll be using it later on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Promises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*The nature of promises is that they remain immune to changing circumstances.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '*- Frank Underwood, House of Cards*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In functional programming, we''re often working with pipelines and data flows:
    chains of functions where each function produces a data type that is consumed
    by the next. However, many of these functions are asynchronous: readFile, events,
    AJAX, and so on. Instead of using a continuation-passing style and deeply nested
    callbacks, how can we modify the return types of these functions to indicate the
    result? By wrapping them in *promises*.'
  prefs: []
  type: TYPE_NORMAL
- en: Promises are like the functional equivalent of callbacks. Obviously, callbacks
    are not all that functional because, if more than one function is mutating the
    same data, then there can be race conditions and bugs. Promises solve that problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should use promises to turn this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Into the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is from the README for *bluebird*: a full featured *Promises/A+*
    implementation with exceptionally good performance. *Promises/A+* is a specification
    for implementing promises in JavaScript. Given its current debate within the JavaScript
    community, we''ll leave the implementations up to the *Promises/A+* team, as it
    is much more complex than maybes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But here''s a partial implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now we can use the `promise()` functor to transform functions that take callbacks
    into functions that return promises.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Lenses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another reason why programmers really like monads is that they make writing
    libraries very easy. To explore this, let's extend our `User` object with more
    functions for getting and setting values but, instead of using getters and setters,
    we'll use *lenses*.
  prefs: []
  type: TYPE_NORMAL
- en: Lenses are first-class getters and setters. They allow us to not just get and
    set variables, but also to run functions over it. But instead of mutating the
    data, they clone and return the new data modified by the function. They force
    data to be immutable, which is great for security and consistency as well for
    libraries. They're great for elegant code no matter what the application, so long
    as the performance-hit of introducing additional array copies is not a critical
    issue.
  prefs: []
  type: TYPE_NORMAL
- en: Before we write the `lens()` function, let's look at how it works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: And here's how the `lens()` function works. It returns a function with get,
    set and mod defined. The `lens()` function itself is a functor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Let's try an example. We'll extend our `User` object from the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: jQuery is a monad
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you think all this abstract babble about categories, functors, and monads
    has no real-world application, think again. jQuery, the popular JavaScript library
    that provides an enhanced interface for working with HTML is, in-fact, a monadic
    library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `jQuery` object is a monad and its methods are functors. Really, they''re
    a special type of functor called *endofunctors*. **Endofunctors** are functors
    that return the same category as the input, that is, `F :: X -> X`. Each `jQuery`
    method takes a `jQuery` object and returns a `jQuery` object, which allows methods
    to be chained, and they will have the type signature `jFunc :: jquery-obj -> jquery-obj`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This is also what empowers jQuery's plugin framework. If the plugin takes a
    `jQuery` object as input and returns one as output, then it can be inserted into
    the chain.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how jQuery was able to implement this.
  prefs: []
  type: TYPE_NORMAL
- en: Monads are the containers that the functors "reach into" to get the data. In
    this way, the data can be protected and controlled by the library. jQuery provides
    access to the underlying data, a wrapped set of HTML elements, via its many methods.
  prefs: []
  type: TYPE_NORMAL
- en: The `jQuery` object itself is written as the result of an anonymous function
    call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this highly simplified version of jQuery, it returns a function that defines
    the `j` object, which is actually just an enhanced `init` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the same way that functors lift values out of a container, jQuery wraps the
    HTML elements and provides access to them as opposed to modifying the HTML elements
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: jQuery doesn't advertise this often, but it has its own `map()` method for lifting
    the HTML element objects out of the wrapper. Just like the `fmap()` method, the
    elements are lifted, something is done with them, and then they're placed back
    into the container. This is how many of jQuery's commands work in the backend.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Another library for working with HTML elements, Prototype, does not work like
    this. Prototype alters the HTML elements directly via helpers. Consequently, it
    has not faired as well in the JavaScript community.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing categories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's about time we formally defined category theory as JavaScript objects. Categories
    are objects (types) and morphisms (functions that only work on those types). It's
    an extremely high-level, totally-declarative way to program, but it ensures that
    the code is extremely safe and reliable—perfect for APIs and libraries that are
    worried about concurrency and type safety.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll need a function that helps us create morphisms. We''ll call it
    `homoMorph()` because they''ll be homomorphisms. It will return a function that
    expects a function to be passed in and produces the composition of it, based on
    the inputs. The inputs are the types that the morphism accepts as input and gives
    as output. Just like our type signatures, that is, `// morph :: num -> num ->
    [num]`, only the last one is the output.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `homoMorph()` function is fairly complex. It uses a closure (see [Chapter
    2](part0019_split_000.html#page "Chapter 2. Fundamentals of Functional Programming"),
    *Fundamentals of Functional Programming*) to return a function that accepts a
    function and checks its input and output values for type safety. And for that,
    it relies on a helper function: `checkTypes`, which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now let's formally define some homomorphisms.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we can bring it on home. The following example includes function composition,
    lenses, homomorphisms, and more.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is extremely declarative, safe, reliable, and dependable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What does it mean for code to be declarative? In imperative programming, we
    write sequences of instructions that tell the machine how to do what we want.
    In functional programming, we describe relationships between values that tell
    the machine what we want it to compute, and the machine figures out the instruction
    sequences to make it happen. Functional programming is declarative.
  prefs: []
  type: TYPE_NORMAL
- en: Entire libraries and APIs can be constructed this way that allow programmers
    to write code freely without worrying about concurrency and type safety because
    those worries are handled in the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: About one in every 2,000 people has a condition known as synesthesia, a neurological
    phenomenon in which one sensory input bleeds into another. The most common form
    involves assigning colors with letters. However, there is an even rarer form where
    sentences and paragraphs are associated with tastes and feelings.
  prefs: []
  type: TYPE_NORMAL
- en: For these people, they don't read word by word, sentence by sentence. They look
    at the whole page/document/program and get a sense for how it *tastes*—not in
    the mouth but in the *mind*. Then they put the parts of the text together like
    the pieces of a puzzle.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what it is like to write fully declarative code: code that describes
    the relationships between values that tells the machine what we want it to compute.
    The parts of the program are not instructions in line-by-line order. Synesthetics
    may be able to do it naturally, but with a little practice anyone can learn how
    to put the relational puzzle pieces together.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we looked at several mathematical concepts that apply to functional
    programming and how they allow us to build relationships between data. Next, we'll
    explore recursion and other advanced topics in JavaScript.
  prefs: []
  type: TYPE_NORMAL
