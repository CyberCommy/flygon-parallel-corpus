- en: Chapter 5. An In-Depth Look at Ansible Plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter introduced you to the Python API and various extension
    points provided by Ansible. By the time you reach this chapter, you should already
    know how a plugin is loaded by Ansible. The previous chapter listed the different
    types of Ansible plugins.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is a deep dive into what Ansible plugins are and how you can write
    your own custom Ansible plugin. In this chapter, we will discuss the different
    types of Ansible plugins in detail and explore them on a code level. Together,
    we will walk through the Ansible Python API, and you will use the extension points
    to write your own Ansible plugins.
  prefs: []
  type: TYPE_NORMAL
- en: 'As discussed in the previous chapter, the plugins are categorized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Lookup plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Action plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cache plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Callback plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connection plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Var plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filter plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Out of these plugins, the most commonly used are lookup plugins, callback plugins,
    var plugins, filter plugins, and connection plugins. Let's explore the plugins
    one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Lookup plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lookup plugins are designed to read data from different sources and feed them
    to Ansible. The data source can be either the local file system on the controller
    node or from an external data source. These may also be for file formats that
    are not natively supported by Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: If you decide to write your own lookup plugin, you need to drop it in one of
    the following directories for Ansible to pick it up during the execution of an
    Ansible playbook.
  prefs: []
  type: TYPE_NORMAL
- en: The directory named `lookup_plugins` in the project `Root`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In `~/.ansible/plugins/lookup_plugins/` or
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/usr/share/ansible_plugins/lookup_plugins/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, a number of lookup plugins are already available in Ansible. Let's
    discuss some of the most commonly used lookup plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Lookup pluginfile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the most basic type of lookup plugin available in Ansible. It reads
    through a file''s content on the controller node. The data read from the file
    can then be fed to the Ansible playbook as a variable. In its most basic form,
    usage of a file lookup is demonstrated in the following Ansible playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding playbook will read data off a local file, `test-file.txt`, from
    the playbook root directory into the variable `data`. This variable is then fed
    to the `task: debug` module and uses the data variable to print it on screen.'
  prefs: []
  type: TYPE_NORMAL
- en: Lookup plugin – csvfile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `csvfile` lookup plugin was designed to read data from a CSV file on the
    controller node. This lookup module is designed to take in several parameters,
    which are discussed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Default value | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `file` | `ansible.csv` | File to read data from. |'
  prefs: []
  type: TYPE_TB
- en: '| `delimiter` | TAB | Delimiter used in CSV file. Usually ''`,`''. |'
  prefs: []
  type: TYPE_TB
- en: '| `col` | `1` | Column number (index). |'
  prefs: []
  type: TYPE_TB
- en: '| `default` | Empty string | Returns this value if the requested key is not
    found in the CSV file |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s take an example of reading data from the following CSV file. The CSV
    file contains population and area details of different cities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This file lies in the controller node at the root of the Ansible play. To read
    off data from this file, the `csvfile` lookup plugin is used. The following Ansible
    play tries to read the population of Mumbai from the preceding CSV file.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ansible Play** : `test-csv.yaml`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Lookup plugin – dig
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `dig` lookup plugin can be used to run DNS queries against a **FQDN** (**Fully
    Qualified Domain Name**). You can customize the lookup plugin's output by using
    the different flags that are supported by the plugin. In its most basic form,
    it returns the IP of the given FQDN.
  prefs: []
  type: TYPE_NORMAL
- en: This plugin has a dependency on the `python-dns` package. This should be installed
    on the controller node.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Ansible play explains how to fetch the TXT records for any FQDN:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding Ansible play will fetch the TXT records in step one and any IPs
    associated with the FQDN `yahoo.com` in step two.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to perform reverse DNS lookups with the dig plugin by using
    the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Lookup plugin – ini
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ini` lookup plugin is designed to read data off a `.ini` file. The `ini`
    file in general is a collection of key-value pairs under defined sections. The
    `ini` lookup plugin supports the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Default value | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `type` | `ini` | Type of file. Currently supports two formats–ini and property.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `file` | `ansible.ini` | Name of file to read data from. |'
  prefs: []
  type: TYPE_TB
- en: '| `section` | `global` | Section of the `ini` file from which the specified
    key needs to be read from. |'
  prefs: []
  type: TYPE_TB
- en: '| `re` | `False` | If the key is a regular expression, set this to `true`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `default` | Empty string | If the requested key is not found in the `ini`
    file, return this. |'
  prefs: []
  type: TYPE_TB
- en: 'Taking an example of the following `ini` file, let''s try to read some keys
    using the `ini` lookup plugin. The file is named `network.ini`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following Ansible play will read off the keys from the `ini` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `ini` lookup plugin can also be used to read off values through a file that
    does not contain sections, for instance, a Java property file.
  prefs: []
  type: TYPE_NORMAL
- en: Loops – lookup plugins for iteration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are times when you may need to perform the same task over and over again.
    It might be the case of installing various dependencies for a package or multiple
    inputs that go through the same operation, for instance, checking and starting
    various services. Just like any other programming language provides a way to iterate
    over data to perform repetitive tasks, Ansible also provides a clean way to carry
    out the same operation. The concept is called looping and is provided by Ansible
    lookup plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Loops in Ansible are generally identified as those starting with `with_`. Ansible
    supports a number of looping options. Few of the most commonly used are discussed
    in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Standard loop – with_items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the simplest and most commonly used loop in Ansible. It is used to
    iterate over an item list and perform some operation on it. The following Ansible
    play demonstrates the use of the `with_items` lookup loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `with_items` loop supports the use of hashes where you can access the variables
    by using the item `<keyname>` in the Ansible playbook. The following playbook
    demonstrates the use of `with_items` to iterate over a given hash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding playbook will create two directories with the specified permission
    sets. If you look closely while accessing the `mode` key from `item`, there exists
    a block of code named | `int`. This is a `jinja2` filter, which is used to convert
    a string to an integer.
  prefs: []
  type: TYPE_NORMAL
- en: Do until loop–until
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This loop has the same implementation as that of any other programming language.
    It executes at least once and keeps executing unless a specific condition is reached.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lets take a look at the following code to understand the `do-until` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `clean-files.sh` script performs a cleanup operation on the specified directory
    and keeps only the latest five files. On every execution, it removes the oldest
    file and returns the number of files remaining in the directory being cleaned
    up as output on `stdout`. The script looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This operation will be retried a maximum of six times, with a delay of 10\.
    The loop exists once it finds a 5 in the number register variable.
  prefs: []
  type: TYPE_NORMAL
- en: If "retries" and "delay" are not specified explicitly, a task in such cases,
    by default, is retried three times with a delay of five.
  prefs: []
  type: TYPE_NORMAL
- en: Create your own lookup plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The previous chapter introduced you to the Python API and explained how various
    plugins are loaded by Ansible to be used in the Ansible play. This chapter covers
    some already available Ansible lookup plugins and explains how those can be used.
    This section will try to replicate a functionality of the `dig` lookup to get
    the IP address of a given FQDN. This will be done without using the `dnspython`
    library and will use the basic socket library for Python. The following example
    is only a demonstration of how you can write your own Ansible lookup plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is a lookup plugin; let's call it `hostip`.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there exists a class named `LookupModule`. Ansible identifies
    a Python file or module as a lookup plugin only when there is a class called `LookupModule`.
    The module takes in an argument hostname and checks if there exists an IP corresponding
    to it (that is, if it can be resolved to a valid IP address). If yes, it returns
    the IP address of the requested FQDN. If not, it returns `Invalid Hostname`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this module, place it in the `lookup_plugins` directory at the root
    of the Ansible play. The following playbook demonstrates how you can use the newly
    created `hostip` lookup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding play will loop through the list of websites and pass it as an
    argument to the `hostip` lookup plugin. This will in turn return the IP associated
    with the requested domain. You may have noticed that, there is an argument called
    `wantlist=True` that is also passed in while the `hostip` lookup plugin is called.
    This is to handle multiple outputs (that is, if there are multiple values associated
    with the requested domain, the values will be returned as a list). This makes
    it easy to iterate over the output values.
  prefs: []
  type: TYPE_NORMAL
- en: Callback plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Callbacks are one of the most widely used plugins with Ansible. They allow you
    to respond back to the events of an Ansible run during runtime. Callbacks are
    a type of plugin that is customized the most.
  prefs: []
  type: TYPE_NORMAL
- en: Though there are a few generic callback plugins, you most certainly may end
    up writing one yourself to address your requirements. This is because everyone
    has a different perception of what they want to do with the data. Ansible is not
    just a tool limited to configuration management and orchestration. You can do
    much more, for instance, collect data during the Ansible plays and process them
    later on. Callbacks provide a vast playground with possibilities to explore. It's
    all about what you want to do with the results.
  prefs: []
  type: TYPE_NORMAL
- en: This section, rather than going through the existing callback modules, will
    focus more on writing one.
  prefs: []
  type: TYPE_NORMAL
- en: Taking a scenario from previous chapters, you created your own `dmidecode` module,
    which executed on the target machines and returned a JSON of hardware specs. The
    module also supported a flag that allowed you to store this result in a JSON file
    on the target machine itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the scenario, there are two major concerns:'
  prefs: []
  type: TYPE_NORMAL
- en: You don't have a log of playbook execution. Everything is on `stdout`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even if you set the save flag to true while calling the `dmidecode` module,
    the results are stored on the target machine and not on the controller node. Post
    playbook execution, you'll have to collect these JSON files individually from
    each target host.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first point is an issue you never want in your production environment. You
    always want to have logs of the Ansible play. This will allow you to later trace
    back any failures that occurred during the playbook execution. There are a few
    generic callback plugins already available in the Ansible code repository for
    this purpose. The link [https://github.com/ansible/ansible/tree/devel/lib/ansible/plugins/callback](https://github.com/ansible/ansible/tree/devel/lib/ansible/plugins/callback)
    is where you can find some of the existing callback modules. You may choose one
    of them if they satisfy your needs. This section will not discuss the existing
    callback modules.
  prefs: []
  type: TYPE_NORMAL
- en: The second point is a major reason why people choose to develop their own callback
    plugins. It addresses the concern of what you actually want to do with the data.
    In this particular case, the module collects system information, which can come
    in handy later for audit purposes. In other cases, you might still want to process
    the collected information and logs of the Ansible play in order to determine cause
    of failure, generate reports, keep a track of production changes, and so on. There
    can be a number of possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: This section will address the second point by creating a custom callback plugin
    that can help you get back the JSON data from the target machine, which was generated
    by using the `dmidecode` module that you created in [Chapter 3](ch03.html "Chapter 3. Digging
    Deeper into Ansible Modules"), *Digging Deeper into Ansible Modules*.
  prefs: []
  type: TYPE_NORMAL
- en: Before diving into writing a callback module, it's important to know how a callback
    module works.
  prefs: []
  type: TYPE_NORMAL
- en: 'A callback module works on events that occur during a playbook execution. The
    various commonly used events as supported in Ansible are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`runner_on_failed`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`runner_on_ok`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`runner_on_skipped`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`runner_on_unreachable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`runner_on_no_hosts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`playbook_on_start`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events that have a name starting with `runner_` are specific to tasks. Events
    that have names starting with `playbook_` are specific to the entire playbook.
    Clearly, event names are self-explanatory; hence, we will not be going into detail
    of what every event means.
  prefs: []
  type: TYPE_NORMAL
- en: As described in the previous chapter, the callback plugin should have a class
    named `CallbackModule`, without which Ansible will not identify it as a callback
    plugin. Python API requires the `CallbackModule` class to identify a module as
    a callback plugin. This is required to differentiate between different Python
    files, as different Python modules may reside in the same directory and the callback
    plugin might be using methods from one of the Python modules in the same directory.
  prefs: []
  type: TYPE_NORMAL
- en: Having discussed the events and class requirements, it's time to get our hands
    dirty. Let's move on to writing a very basic callback plugin that integrates with
    the `dmidecode` module created in [Chapter 3](ch03.html "Chapter 3. Digging Deeper
    into Ansible Modules"), *Digging Deeper into Ansible Modules*.
  prefs: []
  type: TYPE_NORMAL
- en: If you remember, the Ansible play recorded the JSON output in a register named
    `dmi_data`. This data was then echoed on `stdout` by means of the debug module.
    The callback module thus needs to look for the `dmi_data` key during the playbook
    execution. This key will contain the output JSON. The callback plugin will attempt
    to dump this JSON data in a JSON file on the controller node and name it as either
    the target machine's IP or FQDN followed by the `.json` extension. The callback
    module is named `logvar` and needs to be placed in the `callback_plugins` directory
    at the root of the Ansible play.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Executing the `dmidecode` playbook after placing the above module in the `callback_plugins`
    directory in the root of Ansible play will result in output files named `<taget>.json`.
    These files contain the `dmidecode` information of the target machine as returned
    by the `dmidecode` module.
  prefs: []
  type: TYPE_NORMAL
- en: Var plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While writing an Ansible play, you most certainly will use some variables. It
    might be the host-specific `host_vars` or the commonly used `group_vars`. Any
    data that is read from these and fed to the Ansible playbook is done using the
    var plugins.
  prefs: []
  type: TYPE_NORMAL
- en: 'The var plugin is identified by the classname `VarModule`. If you explore the
    var plugin on a code level, inside the class, there are three methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`run`: This method should return both the host-specific vars as well as vars
    calculated from groups it is a member of'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_host_vars`: Returns host-specific variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_group_vars`: Returns group-specific variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connection plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Connection plugins define how Ansible connects to the remote machine. Ansible
    can be used to perform operations on various platforms by means of defining playbooks.
    Hence, for different platforms, you may require different connection plugins to
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Ansible ships with `paramiko_ssh`, native SSH, and a local connection
    plugin. Support for a docker has also been added. There are other less known,
    less used connection plugins, too, like chroot, jail zone, and libvirt.
  prefs: []
  type: TYPE_NORMAL
- en: A connection plugin is identified by its class connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore the Paramiko connection plugin on a code level. The connection
    class contains four major methods. These in turn call a few private functions
    for a few operations. The major methods are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`exec_command`: This method runs the requested command on the remote target.
    You may have a requirement to run commands using `sudo`, which requires a PTY
    by default. Paramiko handles this by passing `pty=True` by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`put_file`: This method takes in two parameters – the `in_path` and `out_path`.
    This function is used to copy over files from the local controller node to the
    remote target machine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fetch_file`: This method, similar to the `put_file` method, also takes in
    two parameters – the `in_path` and `out_path`. The method is used to fetch files
    from the remote machine to the local controller node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Close`: This function terminates the connection when the operation is complete.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filter plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible supports Jinja2 templating, but why not Jinja2 filters? You want it;
    Ansible has it!
  prefs: []
  type: TYPE_NORMAL
- en: Filter plugins are Jinja2 template filters that can be used to modify or transform
    the template expression from one form to another. Ansible already has a set of
    Jinja2 filters that come by default. For instance, `to_yaml` and `to_json`. Ansible
    also supports reading data from already formatted texts. For instance, if you
    already have a YAML file or a JSON file from which you need to read data, you
    can use the `from_json` or `from_yaml` filter.
  prefs: []
  type: TYPE_NORMAL
- en: You can also choose to convert a string to an integer by using the `int` filter,
    as demonstrated in the *Loops – lookup plugins for iteration* section while creating
    directories with defined permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss how and where the filters can be implemented to get even more
    out of Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Using filters with conditions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While running a script, a situation might occur where, based on the outcome
    of the previous step, you need to perform a particular step. This is where conditions
    come into the picture. In normal programming, you can use the `if-else` conditional
    statement. In Ansible, you need to check the output of the last command and apply
    a filter along with the `when` clause, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding script, the result of the execution of the shell script `test.sh`
    is stored in the register variable output. If the status is a success, the task
    will print `Success`; otherwise, it will print `Failed`.
  prefs: []
  type: TYPE_NORMAL
- en: Version comparison
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This filter can be used to check which version of the requested application
    is installed on the target host. It returns a `True` or `False` status. The version
    comparison filter accepts the following operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: IP address filter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The IP address filter can be used to check if the provided string is a valid
    IP address or not. You can even specify what protocol you are checking against:
    IPv4 or Ipv6.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following filter will check if the IP address is a valid Ipv4 address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same way, an IP address can be checked to see if it''s a valid Ipv6
    address or not by using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Understanding the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Python module is identified by Ansible as a filter plugin by looking for a
    class named `FilterModule`. Inside this class there exists one method named `filters`,
    which maps the filters to their corresponding file outside the `FilterModule`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a structure of the filter plugin if you choose to write one
    yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding sample code, in the filter method inside the `FilterModule`
    class, the `custom_filter` key maps to the `custom_filter` function outside the
    class.
  prefs: []
  type: TYPE_NORMAL
- en: The `custom_filter` function contains the actual filter implementation code.
    Ansible simply loads the `FilterModule` class and reads through the defined filters.
    The defined filters are then made available to the end user.
  prefs: []
  type: TYPE_NORMAL
- en: In the Ansible code base, any new suggestions for filters are normally added
    to the `core.py` file inside the filter plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter continued where [Chapter 4](ch04.html "Chapter 4. Exploring API"),
    *Exploring API* ended and picked up on how the Ansible Python API for plugins
    is implemented in the various Ansible plugins. Throughout this chapter, we discussed
    various types of plugins in detail, both from the implementation point and on
    a code level. The chapter also demonstrated how to write sample plugins by writing
    custom lookup and callback plugins. You should now be able to write your own custom
    plugins for Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will explore how to configure Ansible and fit together everything
    that has been discussed up until now. The chapter will also guide you on how to
    share your plugins and roles and explore some best practices to follow.
  prefs: []
  type: TYPE_NORMAL
