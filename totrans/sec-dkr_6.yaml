- en: Chapter 6. Using Docker's Built-in Security Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will take a look at working with Docker tools that can
    be used to secure your environment. We will be taking a look at both command-line
    tools as well as GUI tools that you can utilize to your advantage. We will cover
    the following items in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using TLS in your environments to help ensure that pieces are communicating
    securely
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using read-only containers to help protect the data in a container from being
    manipulated in some form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker security fundamentals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kernel namespaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux kernel capabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will cover the tools that can help you secure your Docker
    environment. These are options that are built into the Docker software, which
    you are already using. It's time to learn how to enable or utilize these such
    features to help give you the peace of mind in order to be sure that the communication
    is secure; this is where we will cover enabling TLS, which is a protocol that
    ensures privacy between applications. It ensures that nobody is listening in on
    the communication. Think of it as when you are watching a movie and people on
    the phone say, *is this line secure?* It's the same kind of idea when it comes
    to network communication. Then, we will look at how you can utilize the read-only
    containers to ensure that the data you are serving up can't be manipulated by
    anyone.
  prefs: []
  type: TYPE_NORMAL
- en: Using TLS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is highly recommended to use the Docker Machine to create and manage your
    Docker hosts. It will automatically set up the communication to use TLS. Here's
    how you can verify that the *default* host that was created by `docker-machine`
    indeed uses TLS.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the important factors is knowing if you are using TLS or not and then
    adjusting to use TLS if you are, in fact, not using TLS. The important thing to
    remember is that, nowadays, almost all the Docker tools ship with the TLS enabled,
    or if they don''t, they appear to be working towards this goal. One of the commands
    that you can use to check in order to see if your Docker host is utilizing the
    TLS is with the Docker Machine `inspect` command. In the following, we will take
    a look at a host and see if it is running with the TLS enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding output, we can focus on the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This shows us that if we were running **Swarm**, this host would be utilizing
    the secure `3376` port. Now, if you aren't using Docker Swarm, then you can disregard
    this line. However, if you are using Docker Swarm, then this line is important.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to take a step back, let''s identify what Docker Swarm is. Docker Swarm
    is native clustering within Docker. It helps in turning multiple Docker hosts
    into an easy-to-manage single virtual host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This shows us that this host is, in fact, using the certificates so we know
    that it is using TLS, but how do we know from just that? In the following section,
    we will take a look at how to tell that it is, in fact, using TLS for sure.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Machine also has the option to run everything over TLS. This is the most
    secure way of using Docker Machine in order to manage your Docker hosts. This
    setup can be tricky if you start using your own certificates. By default, Docker
    Machine stores your certificates that it uses in `/Users/<user_id>/.docker/machine/certs/`.
    You can see the location on your machine where the certificates are stored at
    from the preceding output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how we can achieve the goal of viewing if our Docker
    host is utilize TLS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is where we can tell that it is using TLS. The insecure port of Docker
    Machine hosts is the `2375` port and this host is using `2376`, which is the secure
    TLS port for Docker Machine. Therefore, this host is, in fact, using TLS to communicate,
    which gives you the peace of mind in knowing that the communication is secure.
  prefs: []
  type: TYPE_NORMAL
- en: Read-only containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With respect to the `docker run` command, we will mainly focus on the option
    that allows us to set everything inside the container as read-only. Let''s take
    a look at an example and break down what it exactly does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are running a `mysql` container and setting the entire container as
    read-only, except for the `/var/lib/mysql` directory. What this means is that
    the only location the data can be written inside the container is the `/var/lib/mysql`
    directory. Any other location inside the container won''t allow you to write anything
    in it. If you try to run the following, it would fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This can be extremely helpful if you want to control where the containers can
    write to or not write to. Make sure to use this wisely. Test thoroughly, as it
    can have consequences when the applications can't write to certain locations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember the Docker volumes we looked at in the previous chapters, where we
    were able to set the volumes to be read-only. Similar to the previous command
    with `docker run`, where we set everything to read-only, except for a specified
    volume, we can now do the opposite and set a single volume (or more, if you use
    more `-v` switches) to read-only. The thing to remember about volumes is that
    when you use a volume and mount it in a container, it will mount as an empty volume
    over the top of that directory inside the container, unless you use the `--volumes-from`
    switch or add data to the container in some other way after the fact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will mount a volume in `/opt/uploads` and set it to read-only. This can
    be useful if you don't want a running container to write to a volume in order
    to keep the data or configuration files intact.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last option that we want to look at, with regards to the `docker run` command
    is the `--device=` switch. This switch allows us to mount a device from the Docker
    host into a specified location inside the container. For doing so, there are some
    security risks that we need to be aware of. By default, when you do this, the
    container will get full the access: read, write, and the `mknod` access to the
    device''s location. Now, you can control these permissions by manipulating `rwm`
    at the end of the switch command.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at some of these and see how they work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will run the latest Ubuntu image and mount the `/dev/sdb`
    device inside the container at the `/dev/sdc2` location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This command will run the latest Ubuntu image and mount the `/dev/sdb1` device
    inside the container at the `/dev/sdc2` location. However, this one has the `:r`
    tag at the end of it that specifies that it's read-only and can't be written.
  prefs: []
  type: TYPE_NORMAL
- en: Docker security fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we looked into some Docker tools that you can use,
    such as TLS for communication, and using read-only containers to help ensure data
    isn't changed or manipulated. In this section, we will focus on some more options
    that are available from within the Docker ecosystem that can be used to help secure
    up your environments to another level. We will take a look at the kernel namespaces
    that provide another layer of abstraction by providing the running process to
    its own resources that appear only to the process itself and not to other processes
    that might be running. We will cover more about kernel namespaces in this section.
    We will then take a look at the control groups. Control groups, more commonly
    known as cgroups, give you the ability to limit the resources that a particular
    process has. We will then cover the Linux kernel capabilities. By that, we will
    look at the restrictions that are placed on containers, by default, when they
    are run using Docker. Lastly, we will take a look at the Docker daemon attack
    surface, risks that exist with the Docker daemon that you need to be aware of,
    and mitigation of these risks.
  prefs: []
  type: TYPE_NORMAL
- en: Kernel namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kernel namespaces provide a form of isolation for containers. Think of them
    as a container wrapped inside another container. Processes that are running in
    one container can't disrupt the processes running inside another container or
    let alone run on the Docker host that the container is operating on. The way this
    works is that each container gets its own network stacks to operate with. However,
    there are ways to link these containers together in order to be able to interact
    with each other; however, by default, they are isolated from each other. Kernel
    namespaces have been around for quite a while too, so they are a tried and true
    method of isolation protection. They were introduced in 2008 and at the time of
    writing this book, it's 2016\. You can see that they will be eight years old,
    come this July. Therefore, when you issue the `docker run` command, you are benefiting
    from a lot of heavy lifting that is going on behind the scenes. This heavy lifting
    is creating its own network stack to operate on. This is also shielding off the
    container from other containers being able to manipulate the container's running
    processes or data.
  prefs: []
  type: TYPE_NORMAL
- en: Control groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Control groups, or more commonly referred to as cgroups, are a Linux kernel
    feature that allows you to limit the resources that a container can use. While
    they limit the resources, they also ensure that each container gets the resources
    it needs as well as that no single container can take down the entire Docker host.
  prefs: []
  type: TYPE_NORMAL
- en: 'With control groups, you can limit the amount of CPU, memory, or disk I/O that
    a particular container gets. If we look at the `docker run` command''s help, let''s
    highlight the items that we can control. We will just be highlighting a few items
    that are particularly useful for the majority of users, but please review them
    to see if any others fit your environment, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding highlighted portions, these are just a few
    items that you can control on a per-container basis.
  prefs: []
  type: TYPE_NORMAL
- en: Linux kernel capabilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docker uses the kernel capabilities to place the restrictions that Docker places
    on the containers when they are launched or started. Limiting the root access
    is the ultimate agenda with these kernel capabilities. There are a few services
    that typically run as root, but can now be run without these permissions. Some
    of these include `SSH`, `cron`, and `syslogd`.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, what this means is that you don't need root in the server sense you
    typically think of. You can run with a reduced capacity set. This means that your
    root user doesn't need the privilege it typically needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the things that you might not need to enable anymore are shown in the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Performing mount operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using raw sockets, which will help to prevent spoofing of packets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating new devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the owner of files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Altering attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This helps due to the fact that if someone does compromise a container, then
    they can't escalate any more than what you are providing them. It will be much
    harder, if not impossible, to escalate their privileges from a running container
    to running Docker host. Due to such complexity, the attackers will probably look
    elsewhere than your Docker environments to try to attack. Docker also supports
    the addition and removal of capabilities, therefore, it's recommend to remove
    all the capabilities, except the ones that you intend to use. An example would
    be to use the `–cap-add net_bind_service` switch on your `docker run` command.
  prefs: []
  type: TYPE_NORMAL
- en: Containers versus virtual machines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hopefully, you trust your organization and all those who have access to these
    systems. You will most likely be setting up virtual machines from scratch. It
    is probably impossible to get the virtual machine from someone else due to its
    sheer size. Therefore, you will be aware of what is inside the virtual machine
    and what isn't. This being said, with the Docker containers, you will not be aware
    of what is there inside the image that you may be using for your container(s).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at deploying TLS to all the pieces of our Docker
    environment so that we can ensure that everything is communicating securely and
    the traffic can't be intercepted and then interpreted. We also understood how
    to utilize the read-only containers to our advantage in order to ensure the data
    that is being served up can't be manipulated. We then took a look at how to provide
    processes with their own abstraction of items, such as networks, mounts, users,
    and more. We then dove into control groups, or cgroups as their more commonly
    referred to as, as a way to limit the resources that a process or container has.
    We also took a look at the Linux kernel capabilities, that is, the restrictions
    that are placed on a container when it is started or launched. Lastly, we dove
    into mitigating risks against the Docker daemon attack surface.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at securing Docker with third-party tools
    and learn which third-party tools, beyond those offered by Docker, are out there
    to help secure your environments to help keep your application(s) secure when
    running on Docker.
  prefs: []
  type: TYPE_NORMAL
