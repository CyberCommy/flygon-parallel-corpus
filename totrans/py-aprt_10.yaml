- en: Chapter 5 – Exploring built in collection types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve already encountered some of the built-in collections
  prefs: []
  type: TYPE_NORMAL
- en: '`str` – the immutable string sequence of Unicode code points'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list` – the mutable sequence of objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dict` – the mutable dictionary mapping from immutable keys to mutable objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We’ve only scratched the surface of how these collections work, so we’ll explore
    their powers in greater depth in this chapter. We’ll also introduce three new
    built-in collections types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tuple` - the immutable sequence of objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`range` - for arithmetic progressions of integers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set` - a mutable collection of unique, immutable objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We won’t cover the `bytes` type any further here. We’ve already discussed its
    essential differences with `str`, and most of what we learn about `str` can also
    be applied to `bytes`.
  prefs: []
  type: TYPE_NORMAL
- en: This is not an exhaustive list of Python collection types, but it’s completely
    sufficient for the overwhelming majority of Python 3 programs you’ll encounter
    in the wild or are likely to write yourself.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we’ll be covering these collections in the order mentioned above,
    rounding things off with an overview of the *protocols* that unite these collections
    and which allow them to be used in consistent and predictable ways.
  prefs: []
  type: TYPE_NORMAL
- en: '`tuple` – an immutable sequence of objects'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tuples in Python are immutable sequences of arbitrary objects. Once created,
    the objects within them cannot be replaced or removed, and new elements cannot
    be added.
  prefs: []
  type: TYPE_NORMAL
- en: Literal tuples
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Tuples have a similar literal syntax to lists, except that they are delimited
    by parentheses rather than square brackets. Here is a literal tuple containing
    a string, a float and an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tuple element access
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can access the elements of a tuple by zero-based index using square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The length of a tuple
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can determine the number of elements in the tuple using the built-in `len()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Iterating over a tuple
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can iterate over it using a for-loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Concatenating and repetition of tuples
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can concatenate tuples using the plus operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can repeat them using the multiplication operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Nested tuples
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since tuples can contain any object, it’s perfectly possible to have nested
    tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We use repeated application of the indexing operator to get to the inner elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Single-element tuples
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sometimes a single element tuple is required. To write this, we can’t just
    use a simple object in parentheses. This is because Python parses that as an object
    enclosed in the precedence controlling parentheses of a math expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a single-element tuple we make use of the trailing comma separator
    which, you’ll recall, we’re allowed to use when specifying literal tuples, lists,
    and dictionaries. A single element with a trailing comma is parsed as a single
    element tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Empty tuples
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This leaves us with the problem of how to specify an empty tuple. In actuality
    the answer is simple, we just use empty parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Optional parentheses
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In many cases, the parentheses of literal tuples may omitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Returning and unpacking tuples
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This feature is often used when returning multiple values from a function.
    Here we make a function to return the minimum and maximum values of a sequence,
    the hard work being done by two built-in functions `min()` and `max()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Returning multiple values as a tuple is often used in conjunction with a wonderful
    feature of Python called *tuple unpacking*. Tuple unpacking is a so-called *destructuring
    operation* which allows us to unpack data structures into named references. For
    example, we can assign the result of our `minmax()` function to two new references
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This also works with nested tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Swapping variables with tuple unpacking
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Tuple unpacking leads to the beautiful Python idiom for swapping two (or more)
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The tuple constructor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Should you need to create a tuple from an existing collection object, such
    as a list, you can use the `tuple()` constructor. Here we create a `tuple` from
    a `list`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And here we create a tuple containing the characters of a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Membership tests
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Finally, as with most collection types in Python, we can test for membership
    using the `in` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'or non-membership with the `not in` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Strings in action
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We covered the `str` type at some length already in chapter two, but we’ll take
    time now to explore its capabilities in a more depth.
  prefs: []
  type: TYPE_NORMAL
- en: The length of a string
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As with any other Python sequence, we can determine the length of a string with
    the built-in `len()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![The sign for the railway station at Llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogoch
    on the Welsh island of Anglesey – the longest placename in Europe.](images/m05----llanfair.png)'
  prefs: []
  type: TYPE_IMG
- en: The sign for the railway station at Llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogoch
    on the Welsh island of Anglesey – the longest placename in Europe.
  prefs: []
  type: TYPE_NORMAL
- en: Concatenating strings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Concatenation of strings is supported using the plus operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'or the related augmented assignment operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![Newfoundland, the sixteenth largest island in the world, is one of relative
    few closed, triple-compound words in English.](images/m05----newfoundland.png)'
  prefs: []
  type: TYPE_IMG
- en: Newfoundland, the sixteenth largest island in the world, is one of relative
    few closed, triple-compound words in English.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that strings are immutable, so here the augmented assignment operator
    is binding a new string object to `s` on each use. The illusion of modifying `s`
    in place is achievable because `s` is a reference to an object, not an object
    itself. That is, although the string itself is immutable, the reference to it
    is mutable.
  prefs: []
  type: TYPE_NORMAL
- en: Joining strings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For joining large numbers of strings, avoid using the `+` or `+=` operators.
    Instead, the `join()` method should be preferred because it is substantially more
    efficient. This is because concatenation using the addition operator or it’s augmented
    assignment version can lead to the generation of large numbers of temporaries,
    with consequent costs for memory allocation and copies. Let’s see how `join()`
    is used.
  prefs: []
  type: TYPE_NORMAL
- en: '`join()` is a method on `str` which takes a collection of strings as an argument
    and produces a new string by inserting a separator between each of them. An interesting
    aspect of `join()` is how the separator is specified: it is the string on which
    `join()` is called.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As with many parts of Python, an example is the best explanation. To join a
    list of HTML color code strings into a semicolon separated string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, we call `join()` on the separator we wish to use – the semicolon – and
    pass in the list of strings to be joined.
  prefs: []
  type: TYPE_NORMAL
- en: 'A widespread and fast Python idiom for concatenating together a collection
    of strings is to `join()` using an empty string as the separator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Splitting strings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can then split strings up again using the `split()` method (which we’ve
    already encountered, but this time we’re going to provide it’s optional argument):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The optional argument lets you specify the string — not just the character
    — on which to split the string. So, for example, you could parse a hasty breakfast
    order by splitting on the word ‘and’:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Moment of zen
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](images/m05----zen-the-way-may-not-be-obvious.png)'
  prefs: []
  type: TYPE_IMG
- en: This use of `join()` is often confusing to the uninitiated, but with use, the
    approach taken by Python will be appreciated as natural and elegant.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Partitioning strings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Another very useful string method is `partition()` which divides a string into
    three sections; the part before a separator, the separator itself, and the part
    after the separator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `partition()` method returns a tuple, so this is commonly used in conjunction
    with tuple unpacking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Often, we’re not interested in capturing the separator value, so you might
    see the underscore variable name used. This is not treated in a special way by
    the Python language, but there’s an unwritten convention that the underscore variable
    is for unused or dummy values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This convention is supported by many Python-aware development tools which will
    suppress unused variable warnings for underscore.
  prefs: []
  type: TYPE_NORMAL
- en: String formatting
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One of the most interesting and frequently used string methods is `format()`.
    This supersedes, although does not replace, the string interpolation technique
    used in older versions of Python, and which we do not cover in this book. The
    `format()` method can be usefully called on any string containing so-called *replacement
    fields* which are surrounded by curly braces. The objects provided as arguments
    to `format()` are converted to strings and used to populate these fields. Here’s
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The field names, in this case `0` and `1`, are matched up with the positional
    arguments to `format()`, and each argument is converted to a string behind the
    scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'A field name may be used more than once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if the field names are used exactly once and in the same order as
    the arguments, they can be omitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If keyword arguments are supplied to `format()` then named fields can be used
    instead of ordinals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s possible to index into sequences using square brackets inside the replacement
    field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even access object attributes. Here we pass the whole `math` module
    to `format()` using a keyword argument (Remember – modules are objects too!),
    then access two of its attributes from within the replacement fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Format strings also give us a lot of control over field alignment and floating-point
    formatting. Here’s the same with the constants displayed to only three decimal
    places:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Other string methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We recommend you spend some time familiarizing yourself with the other string
    methods. Remember, you can find out what they are using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`range` – a collection of evenly spaced integers'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s move on and look at `range`, which many developers wouldn’t consider to
    be a collection^([12](chap21.xhtml#fn-range)), although we’ll see that in Python
    3 it most definitely is.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `range` is a type of sequence used for representing an arithmetic progression
    of integers. Ranges are created by calls to the `range()` constructor, and there
    is no literal form. Most typically we supply only the stop value, as Python defaults
    to a starting value of zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Ranges are sometimes used to create consecutive integers for use as loop counters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note that the stop value supplied to `range()` is one past the end of the sequence,
    which is why the previous loop didn’t print 5.
  prefs: []
  type: TYPE_NORMAL
- en: Starting value
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can also supply a starting value if we wish:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Wrapping this in a call to the `list()` constructor is a handy way to force
    production of each item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This so-called half-open range convention — with the stop value not being included
    in the sequence — at first seems strange, but it actually makes a lot of sense
    if you’re dealing with consecutive ranges because the end specified by one range
    is the start of the next one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Step argument
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Range also supports a step argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Note that in order to use the step argument, we must supply all three arguments.
    Range is curious in that it determines what its arguments mean by counting them.
    Providing only one argument means that the argument is the `stop` value. Two arguments
    are `start` and `stop`, and three arguments are `start`, `stop` and `step`. Python
    `range()` works this way so the first argument, `start`, can be made optional,
    something which isn’t normally possible. Furthermore the `range` constructor doesn’t
    support keyword arguments. You might almost describe it as unPythonic!
  prefs: []
  type: TYPE_NORMAL
- en: '![The arguably unPythonic constructor for range, where the interpretation of
    the arguments depends on whether one, two, or three are provided.](images/m05----range-constructor.png)'
  prefs: []
  type: TYPE_IMG
- en: The arguably unPythonic constructor for range, where the interpretation of the
    arguments depends on whether one, two, or three are provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not using `range`: `enumerate()`'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'At this point we’re going to show you another example of poorly styled code,
    except this time it’s one you can, and should, avoid. Here’s a poor way to print
    the elements in a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Although this works, it is most definitely unPythonic. Always prefer to use
    iteration over objects themselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need a counter, you should use the built-in `enumerate()` function which
    returns an iterable series of pairs, each pair being a `tuple`. The first element
    of each pair is the index of the current item and the second element of each pair
    is the item itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Even better, we can use tuple unpacking and avoid having to directly deal with
    the tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '`list` in action'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve already covered lists a little, and we’ve been making good use of them.
    We know how to create lists using the literal syntax, add to them using the `append()`
    method, and get at and modify their contents using the square brackets indexing
    with positive, zero-based indexes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Zero and positive integers index from the front of a list, so index four
    is the fifth element in the list.](images/m05----list-forward-index.png)'
  prefs: []
  type: TYPE_IMG
- en: Zero and positive integers index from the front of a list, so index four is
    the fifth element in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll take a deeper look.
  prefs: []
  type: TYPE_NORMAL
- en: Negative indexing for lists (and other sequences)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One very convenient feature of lists (and other Python sequences, for this
    applies to tuples too) is the ability to index from the end, rather than from
    the beginning. This is achieved by supplying *negative* indices. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '![Negative integers are −1 based backwards from the end, so index −5 is the
    last but fourth  element.](images/m05----list-reverse-index.png)'
  prefs: []
  type: TYPE_IMG
- en: Negative integers are −1 based backwards from the end, so index −5 is the last
    but fourth element.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is much more elegant than the clunky equivalent of computing a positive
    index, which you would otherwise need to use for retrieving that last element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that indexing with -0 is the same as indexing with 0 and returns the first
    element in the list. Because there is no distinction between 0 and negative zero,
    negative indexing is essentially one-based rather than zero-based. This is good
    to keep in mind if you’re calculating indices with even moderately complex logic:
    one-off errors can creep into negative indexing fairly easily.^([13](chap21.xhtml#fn-one-off))'
  prefs: []
  type: TYPE_NORMAL
- en: Slicing lists
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Slicing is a form of extended indexing which allows us to refer to portions
    of a list. To use it we pass the start and stop indices of a half-open range,
    separated by a colon, as the square-brackets index argument. Here’s how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: See how the second index is one beyond the end of the returned range.
  prefs: []
  type: TYPE_NORMAL
- en: '![The slice `[1:4]`. Slicing extracts part of a list. The slice range is half-open,
    so the value at the stop index is not included.](images/m05----slice-forward-indexes.png)'
  prefs: []
  type: TYPE_IMG
- en: The slice `[1:4]`. Slicing extracts part of a list. The slice range is half-open,
    so the value at the stop index is not included.
  prefs: []
  type: TYPE_NORMAL
- en: 'This facility can be combined with negative indices. For example, to take all
    elements except the first and last:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '![The slice `[1:-1]` is useful for excluding the first and last elements of
    a list.](images/m05----slice-backward-indexes.png)'
  prefs: []
  type: TYPE_IMG
- en: The slice `[1:-1]` is useful for excluding the first and last elements of a
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both the start and stop indices are optional. To slice all elements from the
    third to the end of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '![The slice `[3:]` retains all the elements from the fourth, up to and including
    the last element.](images/m05----slice-to-end.png)'
  prefs: []
  type: TYPE_IMG
- en: The slice `[3:]` retains all the elements from the fourth, up to and including
    the last element.
  prefs: []
  type: TYPE_NORMAL
- en: 'To slice all elements from the beginning up to, but not including, the third:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '![The slice `[:3]` retains all elements from the beginning of the list up to,'
  prefs: []
  type: TYPE_NORMAL
- en: but *not* including, the fourth element.](images/m05----slice-from-beginning.png)
  prefs: []
  type: TYPE_NORMAL
- en: The slice `[:3]` retains all elements from the beginning of the list up to,
    but *not* including, the fourth element.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that these two lists are complementary, and together form the whole list,
    demonstrating the convenience of the half-open range convention.
  prefs: []
  type: TYPE_NORMAL
- en: '![The slice `[:3]` and `[3:]` slices are complementary.](images/m05----complementary-slices.png)'
  prefs: []
  type: TYPE_IMG
- en: The slice `[:3]` and `[3:]` slices are complementary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since both start and stop slice indices are optional, it’s entirely possible
    to omit both and retrieve all of the elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This is a called a *full slice*, and it’s an important technique in Python.
  prefs: []
  type: TYPE_NORMAL
- en: '![The slice `[:]` is the full-slice and contains all of the elements from the
    list. It''s an important idiom for copying lists.](images/m05----full-slice.png)'
  prefs: []
  type: TYPE_IMG
- en: The slice `[:]` is the full-slice and contains all of the elements from the
    list. It’s an important idiom for copying lists.
  prefs: []
  type: TYPE_NORMAL
- en: Copying lists
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Indeed, the full slice is an important idiom for *copying* a list. Recall that
    assigning references never copies an object, but rather merely copies a reference
    to an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We deploy the full slice to perform a copy into a new list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'And confirm that the list obtained with the full slice has a distinct identity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Although it has an equivalent value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: It’s important to understand that although we have a new list object which can
    be independently modified, the elements within it are references to the same objects
    referred to by the original list. In the event that these objects are both mutable
    and modified (as opposed to replaced) the change will be seen in both lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'We show this full-slice list copying idiom because you are likely to see it
    in the wild, and it’s not immediately obvious what it does. You should be aware
    that there are other more readable ways of copying a list, such as the `copy()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Or a simple call to the list constructor, passing the list to be copied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Largely the choice between these techniques is a matter of taste. Our preference
    is for the third form using the list constructor, since it has the advantage of
    working with any iterable series as the source, not just lists.
  prefs: []
  type: TYPE_NORMAL
- en: Shallow copies
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You must be aware, however, that all of these techniques perform a *shallow*
    copy. That is, they create a new list containing references to the same objects
    as the source list, but they don’t copy the referred-to objects. To demonstrate
    this, we’ll use nested lists, with the inner lists serving as mutable objects.
    Here’s a list containing two elements, each of which is itself a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We copy this list using a full slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'and convince ourselves that we do in fact have distinct lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'with equivalent values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice, however, that the references within these distinct lists refer not
    only to *equivalent* objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'but, in fact, to the *same* object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '![Copies are shallow. When a list is copied the references to the containing
    objects (yellow diamonds) are copied, but the referred to objects (blue rectangles)
    are not.](images/m05----copies-are-shallow.png)'
  prefs: []
  type: TYPE_IMG
- en: Copies are shallow. When a list is copied the references to the containing objects
    (yellow diamonds) are copied, but the referred to objects (blue rectangles) are
    not.
  prefs: []
  type: TYPE_NORMAL
- en: 'This situation holds until we rebind the first element of `a` to a newly constructed
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the first elements of `a` and `b` refer to different lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '![The first elements of lists `a` and `b` are now uniquely owned, whereas the
    second elements are shared.](images/m05----unique-and-shared-elements.png)'
  prefs: []
  type: TYPE_IMG
- en: The first elements of lists `a` and `b` are now uniquely owned, whereas the
    second elements are shared.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second elements of both `a` and `b` still refer to the same object. We’ll
    demonstrate this by mutating that object through the `a` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'We see the change reflected through the `b` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '![Modifying an object referred to by two lists.](images/m05----mutating-shared-elements.png)'
  prefs: []
  type: TYPE_IMG
- en: Modifying an object referred to by two lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'For completeness, here is the final state of both the `a` and `b` lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '![The final state of list `a`.](images/m05----final-state-a.png)'
  prefs: []
  type: TYPE_IMG
- en: The final state of list `a`.
  prefs: []
  type: TYPE_NORMAL
- en: '![The final state of list `b`.](images/m05----final-state-b.png)'
  prefs: []
  type: TYPE_IMG
- en: The final state of list `b`.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to perform true deep copies of hierarchical data structures like
    this – which in our experience is a rarity – we recommend taking a look at the
    `copy` module in the Python Standard Library.
  prefs: []
  type: TYPE_NORMAL
- en: Repeating lists
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As for strings and tuples, lists support repetition using the multiplication
    operator. It’s simple enough to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'although it’s rarely spotted in the wild in this form. It’s most often useful
    for initializing a list of size known in advance to a constant value, such as
    zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Be aware, though, that in the case of mutable elements the same trap for the
    unwary lurks here, since repetition will repeat *the reference* to each element,
    without copying the value. Let’s demonstrate using nested lists as our mutable
    elements again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '![Repetition is shallow.](images/m05----repetition-is-shallow.png)'
  prefs: []
  type: TYPE_IMG
- en: Repetition is shallow.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now modify the third element of the outer list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'we see the change through all five references which comprise the outer list
    elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '![Mutating the repeated contents of a list. Any change to the object is reflected
    in every index of the outer list.](images/m05----repetition-mutation.png)'
  prefs: []
  type: TYPE_IMG
- en: Mutating the repeated contents of a list. Any change to the object is reflected
    in every index of the outer list.
  prefs: []
  type: TYPE_NORMAL
- en: Finding list elements with `index()`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To find an element in a list, use the `index()` method passing the object you’re
    searching for. The elements are compared for equivalence until the one you’re
    looking for is found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'If you search for a value that isn’t present, you receive a `ValueError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: We’ll learn how to handle such errors gracefully in chapter six.
  prefs: []
  type: TYPE_NORMAL
- en: Membership testing with `count()` and `in`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Another means of searching is to `count()` matching elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'If you just want to test for membership, you can use the `in` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'or non-membership with `not in`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Removing list elements by index with `del`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Elements are removed using a keyword with which we have not yet become acquainted:
    `del`. The `del` keyword takes a single parameter which is a reference to a list
    element and removes it from the list, shortening the list in the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Removing list elements by value with `remove()`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It’s also possible to remove elements by value, rather than by position, using
    the `remove()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'This is equivalent to the more verbose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Attempting to `remove()` an item which is not present will also cause a `ValueError`
    to be raised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Inserting into a list
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Items can be inserted into lists using the `insert()` method, which accepts
    the index of the new item and the new item itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Concatenating lists
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Concatenating lists using the addition operator results in a new list without
    modification of either of the operands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Whereas the augmented assignment operator `+=` modifies the assignee in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'A similar effect can also be achieved using the `extend()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Augmented assignment and the `extend()` method will work with any iterable series
    on the right-hand-side.
  prefs: []
  type: TYPE_NORMAL
- en: Rearranging `list` elements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we move on from lists, let’s look at two operations which rearrange
    the elements in place: reversing and sorting.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A list can be reversed in place by calling it’s `reverse()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'A list can be sorted in place, using the `sort()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sort()` method accepts two optional arguments, `key` and `reverse`. The
    latter is self explanatory and when set to `True` gives a descending sort:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The `key` parameter is more interesting. It accepts any *callable* object which
    is then used to extract a *key* from each item. The items will then be sorted
    according to the relative ordering of these keys. There are several types of callable
    objects in Python, although the only one we have encountered so far is the humble
    function. For example, the `len()` function is a callable object which is used
    to determine the length of a collection, such as a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following list of words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Out-of-place rearrangement
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sometimes an *in situ* sort or reversal is not what is required. For example,
    it may cause a function argument to be modified, giving the function confusing
    side effects. For out-of-place equivalents of the `reverse()` and `sort()` list
    methods you can use the `reversed()` and `sorted()` build-in functions which return
    a reverse iterator and a new sorted list respectively. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'and:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we used a list constructor to evaluate the result of `reversed()`.
    This is because `reversed()` returns an iterator, a topic which we’ll cover in
    much more detail later.
  prefs: []
  type: TYPE_NORMAL
- en: These functions have the advantage that they’ll work on any finite iterable
    source object.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll now return to dictionaries, which lie at the heart of many Python programs,
    including the Python interpreter itself. We briefly looked at literal dictionaries
    previously, seeing how they are delimited with curly braces and contain comma-separated
    key value pairs, with each pair tied together by a colon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '![A dictionary of URLs. The order of dictionary keys is not preserved.](images/m05----dictionary.png)'
  prefs: []
  type: TYPE_IMG
- en: A dictionary of URLs. The order of dictionary keys is not preserved.
  prefs: []
  type: TYPE_NORMAL
- en: 'The values are accessible via the keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Since each key is associated with exactly one value, and lookup is through keys,
    the keys must be unique within any single dictionary. It’s fine, however, to have
    duplicate values.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, the dictionary maintains pairs of references to the key objects
    and the value objects. The key objects *must* be immutable, so strings, numbers
    and tuples are fine, but lists are not. The value objects can be mutable, and
    in practice often are. Our example URL map uses strings for both keys and values,
    which is fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the other collections, there’s also a named constructor `dict()` which
    can convert other types to dictionaries. We can use the constructor to copy from
    an iterable series of key-value pairs stored in tuples, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Recall that the items in a dictionary are not stored in any particular order,
    so the order of the pairs within the list is not preserved.
  prefs: []
  type: TYPE_NORMAL
- en: 'So long as the keys are legitimate Python identifiers it’s even possible to
    create a dictionary directly from keyword arguments passed to `dict()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Again, the order of the keyword arguments is not preserved.
  prefs: []
  type: TYPE_NORMAL
- en: Copying dictionaries
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As with lists dictionary copying is shallow by default, copying only the references
    to the key and value objects, not the objects themselves. There are two means
    of copying a dictionary, of which we most commonly see the second. The first technique
    is to use the `copy()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The second is to pass an existing dictionary to the `dict()` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Updating dictionaries
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you need to extend a dictionary with definitions from another dictionary
    you can use the `update()` method. This is called on the dictionary to be updated
    and is passed the contents of the dictionary which is to be merged in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'If the argument to `update()` includes keys which are already present in the
    target dictionary, the values associated with these keys are replaced in the target
    by the corresponding values from the source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Iterating over dictionary keys
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we have seen in an earlier chapter, dictionaries are iterable and so can
    be used with for-loops. The dictionary yields only the *key* on each iteration,
    and it’s up to us to retrieve the corresponding value by lookup using the square-brackets
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the keys are returned in an arbitrary order which is neither the
    order in which they were specified nor any other meaningful sort order.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating over dictionary values
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we want to iterate over only the values, we can use the `values()` dictionary
    method. This returns an object which provides an iterable *view* onto the dictionary
    values without causing the values to be copied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: There is no efficient or convenient way to retrieve the corresponding *key*
    from a value, so we only print the values
  prefs: []
  type: TYPE_NORMAL
- en: 'In the interests of symmetry, there is also a `keys()` method, although since
    the iterating over the dictionary object directly yields the keys, this is less
    commonly used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Iterating over key-value pairs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Often though, we want to iterate over the keys and values in tandem. Each key-value
    pair in a dictionary is called an *item* and we can get hold of an iterable view
    of items using the `items()` dictionary method. When iterated the `items()` view
    yields each key-value pair as a tuple. By using tuple unpacking in the for-statement
    we can get both key and value in one operation without the extra lookup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Membership testing for dictionary keys
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The membership tests for dictionaries using the `in` and `not in` operators
    work on the keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Removing dictionary items
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As for lists, to remove an entry from a dictionary, we use the `del` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Mutability of dictionaries
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The keys in a dictionary should be immutable, although the values can be modified.
    Here’s a dictionary which maps the element symbol to a list of mass numbers for
    different isotopes of that element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: See how we split the dictionary literal over multiple lines. That’s allowed
    because the curly braces for the dictionary literal are open.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our string keys are immutable, which is a good thing for correct functioning
    of the dictionary. But there’s no problem with modifying the dictionary values
    in the event that we discover some new isotopes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Here, the augmented assignment operator is applied to the *list* object accessed
    through the ‘H’ (for hydrogen) key; the dictionary is not being modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, the dictionary itself is mutable; we know we can add new items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Pretty printing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'With compound data structures such as our table of isotypes, it can be helpful
    to have them printed out in a much more readable form. We can do this with the
    Python Standard Library pretty-printing module called `pprint`, which contains
    a function called `pprint`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that if we didn’t bind the `pprint` function to a different name `pp`,
    the function reference would overwrite the module reference, preventing further
    access to contents of the module^([14](chap21.xhtml#fn-overwrite)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: gives us a much more comprehensible display.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on from dictionaries and look at a new built-in data structure, the
    `set`.
  prefs: []
  type: TYPE_NORMAL
- en: '`set` – an unordered collection of unique elements'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `set` data type is an unordered collection of unique elements. The collection
    is mutable insofar as elements can be added and removed from the set, but each
    element must itself be immutable, very much like the keys of a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '![Sets are unordered groups of distinct elements.](images/m05----set.png)'
  prefs: []
  type: TYPE_IMG
- en: Sets are unordered groups of distinct elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sets have a literal form very similar to dictionaries, again delimited by curly
    braces, but each item is a single object, rather than a pair joined by a colon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that like a dictionary, the `set` is unordered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, sets have type `set`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: The set constructor
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Recall that somewhat confusingly, empty curly braces create an empty *dictionary*,
    rather than an empty set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'To create an empty set we must resort to the `set()` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: This is also the form Python echoes back to us for empty sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `set()` constructor can create a set from any iterable series, such as
    a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Duplicates in the input series are discarded. In fact, a common use of sets
    is to efficiently remove duplicate items from series of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Iterating over sets
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Naturally, sets are iterable, although the order is arbitrary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Membership testing of sets
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Membership is a fundamental operation for sets, and as with the other collection
    types is performed using the `in` and `not in` operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Adding elements to sets
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To add a single element to a set use the `add()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding an element that already exists has no effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: although neither does it produce an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiple elements can be added in one go from any iterable series, including
    another set, using the `update()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Removing elements from sets
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Two methods are provided for removing elements from sets. The first, `remove()`,
    requires that the element to be removed is present in the set, otherwise a `KeyError`
    is given:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'The second method, `discard()`, is less fussy and has no effect if the element
    is not a member of the set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Copying sets
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As with the other built-in collections, `set` sports a `copy()` method which
    performs a shallow copy of the set (copying references but not objects):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have already shown, the `set()` constructor may be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Set algebra operations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Perhaps the most useful aspect of the set type is the group of powerful set
    algebra operations which are provided. These allow us to easily compute set unions,
    set differences, and set intersections, and to evaluate whether two sets have
    subset, superset, or disjoint relations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate these methods, we’ll construct some sets of people according
    to various phenotypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '![Set algebra operations.](images/m05----set-algebra.png)'
  prefs: []
  type: TYPE_IMG
- en: Set algebra operations.
  prefs: []
  type: TYPE_NORMAL
- en: Union
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To find all the people with blond hair, blue eyes or both, we can use the `union()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Set union collects together all of the elements which are in either or both
    sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can demonstrate that `union()` is a commutative operation (that is, we can
    swap the order of the operands) using the value equality operator to check for
    equivalence of the resulting sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Intersection
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To find all the people with blond hair *and* blue eyes, we can use the `intersection()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: which collects together only the elements which are present in both sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is also commutative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Difference
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To identify the people with blond hair who *don’t* have blue eyes, we can use
    the `difference()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: This finds all the elements which are in the first set which are not in the
    second set.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is non-commutative because the people with blond hair who don’t have blue
    eyes are not the same as the people who have blue eyes but don’t have blond hair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Symmetric difference
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'However, if we want to determine which people have exclusively blond hair *or*
    blue eyes, but not both, we can use the `symmetric_difference()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: This collects all the elements which are in the first set *or* the second set,
    but not both.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can tell from the name, `symmetric_difference()` is indeed commutative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: Subset relationships
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![Set relationships.](images/m05----set-relationships.png)'
  prefs: []
  type: TYPE_IMG
- en: Set relationships.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, three predicate methods are provided which tell us about the relationships
    between sets. We can check whether one set is a subset of another using the `issubset()`
    method. For example, to check whether all of the people who can smell hydrogen
    cyanide also have blond hair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: This checks that all the elements of the first set are also present in the second
    set.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test whether all the people who can taste phenylthiocarbamide (PTC) can
    also smell hydrogen cyanide use the `issuperset()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: This checks that all the elements of the second set are present in the first
    set.
  prefs: []
  type: TYPE_NORMAL
- en: '![A representation of phenylthiocarbamide (PTC). It has the unusual property
    that it either tastes very bitter or is virtually tasteless, depending on the
    genetics of the taster.](images/m05----ptc.png)'
  prefs: []
  type: TYPE_IMG
- en: A representation of phenylthiocarbamide (PTC). It has the unusual property that
    it either tastes very bitter or is virtually tasteless, depending on the genetics
    of the taster.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test that two sets have no members in common, use the `isdisjoint()` method.
    For example, your blood type is either A or O, never both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Collection protocols
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Python, a protocol is a group of operations or methods that a type must support
    if it is to implement that protocol. Protocols needn’t be defined in the source
    code as separate interfaces or base classes as they would in a nominally typed
    language such as C# or Java. It’s sufficient to have an object provide functioning
    implementations of those operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can organize the different collections we have encountered in Python according
    to which protocols they support:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Protocol | Implementing collections |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Container | `str`, `list`, `dict`, `range`, `tuple`, `set`, `bytes` |'
  prefs: []
  type: TYPE_TB
- en: '| Sized | `str`, `list`, `dict`, `range`, `tuple`, `set`, `bytes` |'
  prefs: []
  type: TYPE_TB
- en: '| Iterable | `str`, `list`, `dict`, `range`, `tuple`, `set`, `bytes` |'
  prefs: []
  type: TYPE_TB
- en: '| Sequence | `str`, `list`, `tuple`, `range`, `bytes` |'
  prefs: []
  type: TYPE_TB
- en: '| Mutable Sequence | `list` |'
  prefs: []
  type: TYPE_TB
- en: '| Mutable Set | `set` |'
  prefs: []
  type: TYPE_TB
- en: '| Mutable Mapping | `dict` |'
  prefs: []
  type: TYPE_TB
- en: Support for a protocol demands specific behavior from a type.
  prefs: []
  type: TYPE_NORMAL
- en: Container protocol
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The *container* protocol requires that membership testing using the `in` and
    `not in` operators be supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Sized protocol
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *sized* protocol requires that the number of elements in a collection can
    be determined by calling `len(sized_collection)`
  prefs: []
  type: TYPE_NORMAL
- en: Iterable protocol
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Iteration is such an important concept that we’re devoting a whole chapter to
    it later in this book. In short, though, *iterables* provide a means for yielding
    elements one-by-one as they are requested.
  prefs: []
  type: TYPE_NORMAL
- en: 'One important property of *iterables* is that they can be used with for-loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Sequence protocol
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The *sequence* protocol requires that items can be retrieved using square brackets
    with an integer index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'that items can be searched for with `index()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'that items can be counted with `count()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'and that a reversed copy of the sequence can be produced with `reversed()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: In addition, the *sequence* protocol requires that the object support the *iterable*,
    *sized*, and *containers*.
  prefs: []
  type: TYPE_NORMAL
- en: Other protocols
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We won’t cover the *mutable sequence*, *mutable mapping*, and *mutable set*
    here. Since we have only covered one representative type of each protocol, the
    generality afforded by the protocol concept doesn’t gain us much at this juncture.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tuples are immutable sequence types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Literal syntax is optional parentheses around a comma-separated list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notable syntax for single element tuples utilizing the trailing comma.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuple unpacking - useful for multiple return values and swapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String concatenation is most efficiently performed with the `join()` method
    rather than the addition or augmented assignment operators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `partition()` method is a useful and elegant string parsing tool.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `format()` method provided a powerful means of replacing placeholders with
    stringified values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ranges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`range` objects represent arithmetic progressions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `enumerate()` built-in function is often a superior alternative to `range()`
    for generating loop counters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lists support indexing from the end of the list with negative indices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slice syntax allows us to copy all, or part, of a list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The full slice is a common Python idiom for copying lists, although the `copy()`
    method and `list()` constructor are less obscure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List (and other collection) copies in Python are shallow copies. References
    are copied, but the referenced objects are not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dictionaries map from keys to values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iteration and membership testing with dictionaries is done with respect to the
    keys.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `keys()`, `values()` and `items()` methods provide views onto the different
    aspects of a dictionary, allowing convenient iteration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets store an unordered collection of unique elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets support powerful set-algebra operations and predicates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The built in collections are can be organized according to which protocols they
    support, such as *iterable*, *sequence* and *mapping*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In passing we have also discovered that:'
  prefs: []
  type: TYPE_NORMAL
- en: Underscore is commonly used for dummy or superfluous variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `pprint` module supports pretty printing of compound data structures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
