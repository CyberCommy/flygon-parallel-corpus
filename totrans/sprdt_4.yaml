- en: Chapter 4. Adding Custom Functionality to JPA Repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned how we can manage our entities and create database queries with
    Spring Data JPA. We have also learned how we can sort and paginate query results.
    However, if we take a purist architectural point of view, we notice that the described
    solutions are not following the **separation of concerns** principle. In fact,
    our service layer contains code that reveals the inner workings of our repository
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: This is a trade off between architectural purity and productivity. As always,
    this choice has some consequences. If we have to migrate our application away
    from Spring Data JPA, we have to make changes to both the service and repository
    layer. However, how many times have we heard that the repository layer of an application
    has to be changed so radically? Exactly. These situations are very rare. Thus,
    this risk is worth taking when the reward is high.
  prefs: []
  type: TYPE_NORMAL
- en: 'The techniques described in this chapter can be used to hide the implementation
    specific details from our service layer but they have other applications as well.
    In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How we can add custom functionality to a single repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How we can add custom functionality to all repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will use the Querydsl example application created in Chapter 3, *Building
    Queries with Spring Data JPA*, as a starting point. Let''s first refresh our memory
    and spend a moment to review the structure of our example application. Our service
    layer consists of a single class called `RepositoryPersonService` that uses our
    repository interface called `ContactRepository`. The pagination and query building
    logic of our application is located at the service layer. This situation is illustrated
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding Custom Functionality to JPA Repositories](img/9045_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding custom functionality to a single repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to add custom functionality to a single repository is a useful feature
    when the added functionality is related only to a single entity. In this section,
    we will investigate how this can be done, and move the pagination and search logic
    from the service layer to the repository layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to add custom functionality to a single repository, we have to follow
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a custom interface that declares the custom methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the created interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a repository interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a service implementation that uses the custom functionality.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating the custom interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our first step is to create an interface that declares the custom repository
    methods. Since our goal is to move the pagination and search logic to the repository
    layer, we have to add the following methods to the created interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `List<Contact> findAllForPage(int pageIndex, int pageSize)` | Returns all
    contacts belonging to the requested page. |'
  prefs: []
  type: TYPE_TB
- en: '| `List<Contact> findContactsForPage(String searchTerm, int pageIndex, int
    pageSize)` | Returns all contacts that match with the given search term and belong
    to the requested page. |'
  prefs: []
  type: TYPE_TB
- en: 'The source code of the `PaginatingContactRepository` interface is given as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the created interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have now created an interface that specifies our custom repository methods.
    Our next step is to create an implementation of this interface and move all pagination
    and query building code from the service layer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: The repository infrastructure looks for the implementation of our custom interface
    from the same package where the interface is located. It is looking for a class,
    with name matching to a string that is created by appending a suffix to the simple
    name of the actual repository interface. By default the value of this suffix is
    `Impl`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can set the suffix by using either the `repository-impl-postfix` attribute
    of Spring Data JPA's `repositories` namespace element or the `repositoryImplementationPostfix`
    property of the `@EnableJpaRepositories` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the moment we are perfectly happy with the default suffix. Thus, the name
    of the class that implements our custom interface must be `ContactRepositoryImpl`.
    We can implement this class by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Write some plumbing code needed to configure the `QueryDslJpaRepository<T, ID>`
    class that is used to execute our queries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the methods declared in our custom interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring the repository class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this phase we will write the code that is needed to obtain an instance of
    the `QueryDslJpaRepository<Contact, Long>` class. This process has the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `@PersistenceContext` annotation to get a reference to the used entity
    manager.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an `init()` method and annotate it with the `@PostConstruct` annotation.
    This ensures that the method called after the bean has been constructed and the
    entity manager reference is injected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the `init()` method and create a new `QueryDslJpaRepository<Contact,
    Long>` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of our implementation is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the custom methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At the moment the created class cannot be compiled because we have not implemented
    the custom methods yet. Also, before we can implement these methods, we have to
    move the pagination logic from the service layer to the `ContactRepositoryImpl`
    class. Thus, this process has the following two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the pagination related code to our repository implementation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the custom repository methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we have to add the pagination related code to our repository. This means
    that we have to add both the `sortByLastNameAndFirstNameAsc()` and `buildPageSpecification()`
    methods to the `ContactRepositoryImpl` class. The implementations of these methods
    remain unchanged as we can see in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to write an implementation for the `findAllForPage()` method
    that is used to get a list of contacts belonging to a requested page. This means
    that we have to:'
  prefs: []
  type: TYPE_NORMAL
- en: Get a page specification by using the private `buildPageSpecification()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the contents of the requested page by calling the `findAll()` method of
    the repository and passing the page specification as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return a list of contacts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `findAllForPage()` method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Our last task is to provide an implementation for the `findContactsForPage()`
    method. The implementation of this method has the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the used search condition by calling the static `firstOrLastNameStartsWith()`
    method of the `ContactPredicates` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the page specification by calling the private `buildPageSpecification()`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the contents of the requested page by calling the `findAll()` method of
    the repository and providing the necessary parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return a list of contacts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `findContactsForPage()` method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Creating the repository interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have now implemented the custom functionality and it is time to add this
    functionality to our repository. We have to make two changes to the existing `ContactRepository`
    interface. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We can make the custom methods available to the users of our repository by extending
    the `PaginatingContactRepository` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because the service layer has no need for the specific methods from the Querydsl
    library anymore, we can remove the `QueryDslPredicateExecutor` interface from
    the list of extended interfaces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of our new repository interface is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Creating the service implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last step is to modify the `RepositoryContactService` class to use the
    custom functionality. This step has the following two phases:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the `buildPageSpecification()` and `sortByLastNameAndFirstNameAsc()`
    methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the `findAllForPage()` and `search()` methods to delegate the method
    call forward to our repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the modified methods is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: What did we just do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We just moved the pagination and search logic from the `RepositoryContactService`
    class to the `ContactRepositoryImpl` class and eliminated the dependency between
    our service layer and Querydsl. The outcome of our actions is illustrated in the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What did we just do?](img/9045_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding custom functionality to all repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes we have to add custom functionality to all repositories. In this section,
    we will learn how we can do this and create a custom repository method that is
    used to delete an entity by using its ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add custom functionality to all repositories by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a base interface that declares the custom methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the created interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a repository factory bean.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure Spring Data JPA to use our repository factory bean.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a repository interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a service class that uses the custom functionality.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating the base repository interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start by creating a base repository interface that declares the methods
    that are available in the actual repositories. We can do this by:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an interface that takes the type of the managed entity and the type
    of its ID as a type parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extending both the `JpaRepository<T, ID>` and `QueryDslPredicateExecutor<T>`
    interfaces in our base repository interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Annotating the interface with the `@NoRepositoryBean` annotation. This ensures
    that Spring Data JPA does not create a repository implementation for this interface.
    Another solution is to move this interface from the repository base package, but
    since it is often hard to find a logical place for it, we will not do it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding a `T deleteById(ID id)` method to this interface. This method returns
    the deleted entity, and it throws `NotFoundException` if no entity is found with
    the ID that is given as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s call this interface `BaseRepository`. Its source code is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the base repository interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next we have to write an implementation of the `BaseRepository<T, ID>` interface.
    This process includes the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class that implements the `BaseRepository<T, ID>` interface and extends
    the `QueryDslJpaRepository<T, ID>` class. This ensures that the class has access
    to the methods provided by the `JpaRepository<T, ID>` interface and that Querydsl
    can be used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a constructor that is used to simply pass the needed information forward
    to the superclass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the `deleteById()` method. First, this method obtains the deleted
    entity. If an entity is not found, this method throws `NotFoundException`. Otherwise
    this method deletes the found entity and returns the deleted entity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the created `GenericBaseRepository` class is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Creating the repository factory bean
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have implemented the custom functionality, we have to ensure that
    it is used when the concrete repository implementations are created. This means
    that we have to create a custom repository factory bean that replaces the default
    repository factory bean. Our repository factory bean has a single purpose: It
    will provide `GenericBaseRepository` as an implementation of all interfaces extending
    the `Repository` interface. We can create a custom repository factory bean by
    following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a skeleton of the repository factory bean class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a repository factory class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a builder method used to build new repository factories.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating the skeleton of the repository factory bean class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First we have to create the repository factory bean class. This class must
    extend the `JpaRepositoryFactoryBean<R, T, I>` class that is the default repository
    factory bean of Spring Data JPA. This class has three type parameters: the type
    of the repository, the type of the entity, and the type of the entity''s ID. The
    source code of the class skeleton is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Creating the repository factory inner class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The second step is to create the actual repository factory class. The implementation
    of this class includes the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the `BaseRepositoryFactory` class as a protected inner class to the `BaseRepositoryFactoryBean`
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the created class extend the `JpaRepositoryFactory` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override the `getTargetRepository()` method of the `JpaRepositoryFactory` class.
    This method is responsible for creating the actual repository implementations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override the `getRepositoryBaseClass()` method of the `JpaRepositoryFactory`
    class, which simply returns the class of the base repository implementation. We
    can ignore the metadata given as a parameter because that information is used
    by the `JpaRepositoryFactory` to decide whether it should return the `SimpleJpaRepository`
    or `QueryDslJpaRepository` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the repository factory inner class is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Creating the builder method for the repository factory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can create new instances of our custom repository factory class by overriding
    the `createRepositoryFactory()` method of the `JpaRepositoryFactoryBean` class
    in the `BaseRepositoryFactoryBean` class. This method simply creates a new instance
    of the `BaseRepositoryFactory` class and passes an entity manager reference as
    a constructor parameter. The source code of the overridden method is given as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Configuring Spring Data JPA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next we have to configure Spring Data JPA to use the custom repository factory
    bean when it is creating concrete implementations of repository interfaces. We
    can do this by using the `repositoryFactoryBeanClass` property of the `@EnableJpaRepositories`
    annotation. In other words, we have to add the following annotation to the `ApplicationContext`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we are using XML to configure our application, we can use the `factory-class`
    attribute of Spring Data JPA's `repositories` namespace element.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the repository interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have now made the custom functionality available to all repositories. Now
    we have to create a repository interface for the `Contact` entity. We can do this
    by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the `JpaRepository` and the `QueryDslPredicateExecutor` interfaces from
    the list of extended interfaces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extend the `BaseRepository<T, ID>` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `ContactRepository` interface is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the service layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because the old implementation of the `delete()` method of the `RepositoryContactService`
    class contained the same functionality as our new `deleteById()` repository method,
    we have to change the `delete()` method of the `RepositoryContactService` class
    to delegate the method call forward to the new repository method. The source code
    of our new `delete()` method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: What did we just do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We implemented a generic delete method that is automatically available to all
    repositories of our application. This eliminates the need to add entity specific
    delete logic to the service layer and reduces code duplication. We also created
    a custom repository factory that provides `GenericBaseRepository` as an implementation
    for our repository interface. The result of our work is illustrated in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What did we just do?](img/9045_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned that we can add custom functionality either
    to a single repository or to all repositories. However, this chapter also had
    another very important lesson. We noticed that adding custom functionality to
    repositories increases the complexity of our application and forces us to write
    boilerplate code that can be cumbersome to both implement and maintain. That is
    why we should use the techniques described in this chapter only when it is absolutely
    necessary.
  prefs: []
  type: TYPE_NORMAL
- en: This was the last chapter that describes the usage of Spring Data JPA. In the
    next chapter, we will learn how we can install Redis on a computer that runs a
    Unix-like operating system and set up a web application project that uses Redis
    as a data storage.
  prefs: []
  type: TYPE_NORMAL
