- en: Developing a Web-Based VR Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The advent of **virtual reality** (**VR**) and **augmented reality** (**AR**)
    technologies are transforming how users interact with software and, in turn, the
    world around them. The possible applications of VR and AR are innumerable, and
    though the game industry has been an early adopter, these rapidly developing technologies
    have the potential to shift paradigms across multiple disciplines and industries.
  prefs: []
  type: TYPE_NORMAL
- en: In order to demonstrate how the MERN stack paired with React 360 can easily
    add VR capabilities to any web application, we will discuss and develop a dynamic,
    web-based VR game in this and the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'By covering the following topics, this chapter will focus on defining the features
    of the VR game and developing the game view using React 360:'
  prefs: []
  type: TYPE_NORMAL
- en: VR game specifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key concepts for developing 3D VR applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with React 360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining game data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the game view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bundling the React 360 code for integration with the MERN skeleton
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MERN VR Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The MERN VR Game web application will be developed by extending the MERN skeleton
    and integrating VR capabilities using React 360\. It will be a dynamic, web-based
    VR game application, in which registered users can make their own games, and any
    visitor to the application can play these games:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7e939bf7-7e64-4628-851e-1699529a9d3e.png)'
  prefs: []
  type: TYPE_IMG
- en: The features of the game itself will be simple enough to expose the capabilities
    of introducing VR into a MERN-based application, without delving too deeply into
    advanced concepts of React 360 that may be used to implement more complex VR features.
  prefs: []
  type: TYPE_NORMAL
- en: The code to implement features of the VR game using React 360 is available on
    GitHub at [github.com/shamahoque/MERNVR](https://github.com/shamahoque/MERNVR). You
    can clone this code and run the application as you go through the code explanations
    in the rest of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Game features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each game in MERN VR Game will basically be a different VR world, where users
    can interact with 3D objects placed at different locations in the 360 degree panoramic
    world.
  prefs: []
  type: TYPE_NORMAL
- en: The gameplay will be similar to that of a scavenger hunt, and to complete each
    game, users will have to find and collect the 3D objects that are relevant to
    the clue or description for each game. This means the game world will contain
    some VR objects that can be collected by the player, and some VR objects that
    cannot be collected, but that may be placed by makers of the game as props or
    hints.
  prefs: []
  type: TYPE_NORMAL
- en: Focus of this chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will build out the game features using React 360, focusing
    primarily on concepts that will be relevant to implement the features defined
    earlier. Once the game features are ready, we will discuss how the React 360 code
    can be bundled and prepared to be integrated with the MERN application code developed
    in [Chapter 11](f9761c7c-dfc5-4247-9cfc-aaebc78b93da.xhtml), *Making the VR Game
    Dynamic Using MERN*.
  prefs: []
  type: TYPE_NORMAL
- en: React 360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React 360 makes it possible to build VR experiences using the same declarative
    and component-based approach in React. The underlying technology of React 360
    makes use of the Three.js JavaScript 3D engine to render 3D graphics with WebGL
    within any compatible web browser, and also provides access to VR headsets with
    the Web VR API.
  prefs: []
  type: TYPE_NORMAL
- en: Though React 360 builds on top of React and the apps run in the browser, React
    360 has a lot in common with React Native, thus making React 360 apps cross-platform.
    This also means concepts from React Native are also applicable for React 360\.
    Covering all the React 360 concepts is outside the scope of this book, hence we
    will focus on concepts required to build the game and integrate it with the MERN
    stack web application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with React 360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React 360 provides developer tools that make it easy to start developing a new
    React 360 project. The steps to get started are detailed in the React 360 docs,
    so we will only summarize the steps, and point out the files relevant to developing
    the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we already have Node installed for the MERN applications, we can start
    by installing the React 360 CLI tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Use this React 360 CLI tool to create a new application and install the required
    dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will add the application with all the necessary files in a folder named
    `MERNVR` in the current directory. Finally, we can go into this folder from the
    command line, and run the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `start` command will initialize the local development server, and the default
    React 360 application can be viewed in the browser at `http://localhost:8081/index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: To update the starter application and implement our game features, we will modify
    code mainly in the `index.js` file with some minor updates in the `client.js`
    file found in the `MERNVR` project folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default code in `index.js` for the starter application should be as follows,
    and it renders a Welcome to React 360 text in a 360 world in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This `index.js` file contains the application''s content and the main code.
    The code in `client.js` contains the boilerplate that connects the browser to
    the React application in `index.js`. The default `client.js` in the starter project
    folder should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This code basically executes the React code defined in `index.js`, essentially
    creating a new instance of React 360 and loading the React code by attaching it
    to the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: With the default React 360 project set up, and before modifying the code to
    implement the game, we will first look at some of the key concepts related to
    developing 3D VR experiences in the context of how these concepts are applied
    with React 360.
  prefs: []
  type: TYPE_NORMAL
- en: Key concepts for developing the VR game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before creating VR content and an interactive 360 degree experience for the
    game, it is important to first understand some key aspects of the virtual world
    and how React 360 components can be used to work with these VR concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Equirectangular panoramic images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The VR world for the game will be composed of a panoramic image which is added
    to the React 360 Environment as a background image.
  prefs: []
  type: TYPE_NORMAL
- en: Panorama images are generally 360 degree images or spherical panoramas projected
    onto a sphere that completely surrounds the viewer. A common and popular format
    for 360 degree panorama images is the equirectangular format. React 360 degree
    currently supports mono and stereo formats for equirectangular images.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about the 360 image and video support in React 360, refer to the
    React 360 docs at [facebook.github.io/react-360/docs/setup.html](https://facebook.github.io/react-360/docs/setup.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The image shown here is an example of an equirectangular, 360 degree panoramic
    image. To set the world background for a game in MERN VR Game, we will use this
    kind of image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/20b36d83-b289-48a3-9f24-a939524e8067.png)An equirectangular panoramic
    image consists of a single image with an aspect ratio of 2:1, where the width
    is twice the height. These images are created with a special 360 degree camera.
    An excellent source of equirectangular images is Flickr, you just need to search
    for the `equirectangular` tag.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the game world by setting the background scene using a equirectangular
    image in a React 360 Environment will make the VR experience immersive and transport
    the user to a virtual location. To enhance this experience and add 3D objects
    in this VR world effectively, we need to learn more about the layout and coordinate
    system relevant to the 3D space.
  prefs: []
  type: TYPE_NORMAL
- en: 3D position – coordinates and transforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to understand positions and orientation in the VR world space, in order
    to place 3D objects at desired locations, and to make the VR experience feel more
    real.
  prefs: []
  type: TYPE_NORMAL
- en: 3D coordinate system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For mapping in a 3D space, React 360 uses a three-dimensional meter based coordinate
    system similar to the OpenGL® 3D Coordinate System, allowing individual components
    to be transformed, moved, or rotated in 3D relative to the layout in their parent
    component.
  prefs: []
  type: TYPE_NORMAL
- en: The 3D coordinate system used in React 360 is a right-handed system. This means
    the positive x-axis is to the right, the positive y-axis is up, and the positive
    z-axis is backwards. This provides a better mapping with common coordinate systems
    of the world space in assets and 3D world modeling.
  prefs: []
  type: TYPE_NORMAL
- en: If we try to visualize the 3D space, the user starts out at the center of the
    **X-Y-Z** axes pictured in the next image. The **Z**-axis points forward toward
    the user and the user is looking out at the **-Z**-axis direction. The **Y**-axis
    runs up and down, whereas the **X**-axis runs from side to side.
  prefs: []
  type: TYPE_NORMAL
- en: 'The curved arrow in the image shows the direction of positive rotation values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/df215bc6-9a8f-4dfa-8e14-65b6d6f120d0.png)'
  prefs: []
  type: TYPE_IMG
- en: Transform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following two images, the 3D book object is placed in two different
    positions and orientations by changing the `transform` properties in the style
    attribute of the React 360 `Entity` component that is rendering the 3D object.
    The transform here is based on the transform style of React, which React 360 extends
    to be fully 3D, considering the X-Y-Z axes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c060ac74-3a84-4efe-8860-83ea3c525d15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `transform` properties are added to components in the `style` attribute
    as an array of keys and values in the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The transform commands and values relevant to the 3D objects to be placed in
    our games are `translate [x, y, z]`, with values in meters, `rotate [x, y, z]`,
    with values in degrees, and `scale`, to determine the size of the object across
    all axes. We will also utilize the matrix command, which accepts a value as an
    array of 16 numbers representing the translation, rotation, and scale values.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about the React 360 3D coordinates and transforms, take a look
    at the React 360 docs at [facebook.github.io/react-360/docs/setup.html](https://facebook.github.io/react-360/docs/setup.html).
  prefs: []
  type: TYPE_NORMAL
- en: React 360 components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React 360 provides a range of components that can be used out of the box to
    create the VR user interface for the game. Next, we will summarize the specific
    components that will be used to build out the game features.
  prefs: []
  type: TYPE_NORMAL
- en: Core components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The core components in React 360 include React Native''s built-in components:
    `Text` and `View`. In the game, we will use these two components to add content
    in the game world.'
  prefs: []
  type: TYPE_NORMAL
- en: View
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `View` component is the most fundamental component for building a user
    interface in React Native, and it maps directly to the native view equivalent
    on whatever platform React Native is running on. In our case, it will be `<div>`
    on the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `View` component is typically used as a container for other components,
    it can be nested inside other views and can have zero to many children of any
    type.
  prefs: []
  type: TYPE_NORMAL
- en: We will use `View` components to hold the game world view, and to add 3D object
    entities and text to the game.
  prefs: []
  type: TYPE_NORMAL
- en: Text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Text` component is a React Native component for displaying text and we
    will use it to render strings in a 3D space, by placing `Text` components in `View`
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Components for 3D VR experience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React 360 provides a set of its own components to create the VR experience.
    Specifically, we will use the `Entity` component to add 3D objects and a `VrButton`
    component to capture clicks from the user.
  prefs: []
  type: TYPE_NORMAL
- en: Entity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to add 3D objects to the game world, we will use the `Entity` component,
    which allows us to render 3D objects in React 360:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Files containing the specific 3D object''s information are added to the `Entity`
    component using a `source` attribute. The source attribute takes an object of
    key-value pairs to map resource file types to their locations. React 360 supports
    the Wavefront OBJ file format, a common representation for 3D models. So in the
    source attribute, the `Entity` component supports the following keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '`obj`: Location of an OBJ-formatted model'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mtl`: Location of an MTL-formatted material (the companion to OBJ)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The values for the `obj` and `mtl` properties point to the location of these
    files and can be static strings, `asset()` calls, `require()` statements, or URI
    strings.
  prefs: []
  type: TYPE_NORMAL
- en: OBJ (or .OBJ) is a geometry definition file format first developed by Wavefront
    Technologies. It is a simple data format that represents 3D geometry as a list
    of vertices and texture vertices. OBJ coordinates have no units, but OBJ files
    can contain scale information in a human-readable comment line. Learn more about
    this format at [paulbourke.net/dataformats/obj/](http://paulbourke.net/dataformats/obj/).MTL
    (or .MTL) are material library files that contain one or more material definitions,
    each of which includes the color, texture, and reflection map of individual materials.
    These are applied to the surfaces and vertices of objects. Learn more about this
    format at [paulbourke.net/dataformats/mtl/](http://paulbourke.net/dataformats/mtl/).
  prefs: []
  type: TYPE_NORMAL
- en: The `Entity` component also takes `transform` property values in the `style`
    attribute, so the objects can be placed at the desired positions and orientations
    in the 3D world space. In our MERN VR Game application, makers will add URLs pointing
    to the VR object files (both `.obj` and `.mtl`) for each of their `Entity` objects
    in a game, and also specify the `transform` property values to indicate where
    and how the 3D objects should be placed in the game world.
  prefs: []
  type: TYPE_NORMAL
- en: A good source of 3D objects is [https://clara.io/](https://clara.io/), with
    multiple file formats available for download and use.
  prefs: []
  type: TYPE_NORMAL
- en: VrButton
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `VrButton` component in React 360 will help to implement a simple, button-style,
    `onClick` behavior for the objects and `Text` buttons that will be added to the
    game. A `VrButton` is not visible in the view by default and will only act as
    a wrapper to capture events, but it can be styled in the same ways as a `View`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This component is a helper for managing click-type interactions from the user
    across different input devices. Input events that will trigger the click event
    include a space button press on the keyboard, a left-click on the mouse, and a
    touch on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: React 360 API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides the React 360 components discussed previously, we will utilize the APIs
    provided by React 360 to implement functionality such as setting the background
    scene, playing audio, dealing with external links, adding styles, capturing the
    current orientation of the user’s view, and using static asset files.
  prefs: []
  type: TYPE_NORMAL
- en: Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the `Environment` API to change the background scene from the React
    code using its `setBackgroundImage` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This method sets the current background image with the resource at the specified
    URL. When we integrate the React 360 game code with the MERN stack containing
    the game application backend, we can use this to set the game world image dynamically
    using image links provided by the user.
  prefs: []
  type: TYPE_NORMAL
- en: Native Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Native Modules in React 360 give the ability to access functionality only available
    in the main browser environment. In the game, we will use the `AudioModule` in
    Native Modules to play sounds in response to user activity, and the `Location`
    module that gives access to `window.location` in the browser to handle external
    links. These modules can be accessed in `index.js` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: AudioModule
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the user interacts with the 3D objects, we will play sounds based on whether
    the object can be collected or not, and also whether the game has been completed.
    The `AudioModule` in Native Modules allows adding sound to the VR world as background
    environmental audio, one-off sound effects, and spatialized audio. In our game,
    we will use environmental audio and one-off sound effects.
  prefs: []
  type: TYPE_NORMAL
- en: '**Environmental audio**: To play an audio on loop and set the mood when the
    game is successfully completed, we will use the `playEnvironmental` method that
    takes an audio file path as the `source` and `loop` option as a `playback` parameter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '**Sound effects**: To play a single sound once when the user clicks on 3D objects,
    we will use the `playOneShot` method that takes an audio file path as the `source`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `source` attribute in the options passed to `playEnvironmental` and `playOneShot`
    takes a resource file location to load the audio. It can be an `asset()` statement,
    or a resource URL declaration in the form of `{uri: ''PATH''}`.'
  prefs: []
  type: TYPE_NORMAL
- en: Location
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After we integrate the React 360 code with the MERN stack containing the game
    application backend, the VR game will be launched from the MERN server at a declared
    route containing the specific game's ID. Then, once a user completes a game, they
    will also have the option to leave the VR space, and go to a URL containing a
    list of other games. To handle these incoming and outgoing app links in the React
    360 code, we will utilize the `Location` module in Native Modules.
  prefs: []
  type: TYPE_NORMAL
- en: The `Location` module is essentially the `Location` object returned by the read-only `window.location` property
    in the browser. We will use the `replace` method and `search` property in the
    `Location` object to implement features related to external links.
  prefs: []
  type: TYPE_NORMAL
- en: '**Handling outgoing links**: When we want to direct the user out of the VR
    application to another link, we can use the `replace` method in `Location`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '**Handling incoming links**: When the React 360 app is launched from an external
    URL and after the registered component mounts, we can access the URL and retrieve
    its query string part using the `search` property in `Location`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: For the purpose of integrating this React 360 component with MERN VR Game, and
    dynamically loading game details, we will capture this initial URL to parse the
    game ID from a query parameter and then use it to make a read API call to the
    MERN application server. This implementation is elaborated upon in [Chapter 11](f9761c7c-dfc5-4247-9cfc-aaebc78b93da.xhtml),
    *Making the VR Game Dynamic Using MERN*.
  prefs: []
  type: TYPE_NORMAL
- en: StyleSheet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The StyleSheet API from React Native can also be used in React 360 to define
    several styles in one place rather than adding styles to individual components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The defined styles can be added to components as required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The default distance units for CSS properties, such as width and height, are
    in meters when mapping to 3D space in React 360, whereas the default distance
    units are in pixels for 2D interfaces, as in React Native.
  prefs: []
  type: TYPE_NORMAL
- en: VrHeadModel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`VrHeadModel` is a utility module in React 360 that simplifies obtaining the
    current orientation of the headset. Since the user is moving around in a VR space,
    when a desired feature requires that an object or text should be placed in front
    of or with respect to the user''s current orientation, it becomes necessary to
    know where exactly the user is currently gazing.'
  prefs: []
  type: TYPE_NORMAL
- en: In MERN VR Game, we will use this to show the game completed message to the
    user in front of their view, no matter where they end up turning to from the initial
    position.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the user may be looking up or down when collecting the final object,
    and the completed message should pop up wherever the user is gazing. To implement
    this, we will retrieve the current head matrix as an array of numbers using `getHeadMatrix()`
    from `VrHeadModel`, and set it as a value for the `transform` property in the
    style attribute of the `View` containing the game completed message.
  prefs: []
  type: TYPE_NORMAL
- en: Assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `asset()` functionality in React 360 allows us to retrieve external resource
    files, such as audio and image files. We will place the sound audio files for
    the game in the `static_assets` folder, to be retrieved using `asset()` for each
    audio added to the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: React 360 input events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to make the game interface interactive, we will utilize some of the
    input event handlers exposed in React 360\. Input events are collected from mouse,
    keyboard, touch, and gamepad interactions, and also with the `gaze` button click
    on a VR headset. The specific input events we will work with are the `onEnter`,
    `onExit`, and `onClick` events.
  prefs: []
  type: TYPE_NORMAL
- en: '**onEnter**: This event is fired whenever the platform cursor begins intersecting
    with a component. We will capture this event for the VR objects in the game, so
    the objects can start rotating around the Y-axis when the platform cursor enters
    the specific object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**onExit**: This event is fired whenever the platform cursor stops intersecting
    with a component. It has the same properties as the `onEnter` event and we will
    use it to stop rotating the VR object just exited.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**onClick**: The `onClick` event is used with the `VrButton` component, and
    is fired when there is click interaction with `VrButton`. We will use this to
    set click event handlers on the VR objects, and also on the game complete message
    to redirect the user out of the VR application to a link containing a list of
    games.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the VR-related concepts and React 360 components discussed in this section,
    we are ready to define the game data details and start implementing the complete
    VR game.
  prefs: []
  type: TYPE_NORMAL
- en: Game details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each game in MERN VR Game will be defined in a common data structure that the
    React 360 application will also adhere to when rendering the individual game details.
  prefs: []
  type: TYPE_NORMAL
- en: Game data structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The game data structure will hold details such as the game''s name, a URL pointing
    to the location of the equirectangular image for the game world, and two arrays
    containing details for each VR object to be added to the game world:'
  prefs: []
  type: TYPE_NORMAL
- en: '**name**: A string representing the name of the game'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**world**: A string with the URL pointing to the equirectangular image either
    hosted on cloud storage, CDNS, or stored on MongoDB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**answerObjects**: An array of objects containing details of the VR objects
    that can be collected by the player'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**wrongObjects**: An array of objects containing details of the other VR objects
    to be placed in the VR world that cannot be collected by the player'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Details of VR objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `answerObjects` array will contain details of the 3D objects that can be
    collected, and the `wrongObjects` array will contain details of 3D objects that
    cannot be collected. Each object will contain links to the 3D data resource files
    and `transform` style property values.
  prefs: []
  type: TYPE_NORMAL
- en: OBJ and MTL links
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The 3D data information resources for the VR objects will be added in the `objUrl`
    and `mtlUrl` keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '**objUrl**: Link to the `.obj` file for the 3D object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**mtlUrl**: Link to the accompanying `.mtl` file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `objUrl` and `mtlUrl` links may point to files either hosted on cloud storage,
    CDNS, or stored on MongoDB. For MERN VR Game, we will assume makers will add URLs
    to their own hosted OBJ, MTL, and equirectangular image files.
  prefs: []
  type: TYPE_NORMAL
- en: Translation values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The position of the VR object in the 3D space will be defined with the `translate`
    values in the following keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '**translateX**: Translation value of the object along the X-axis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**translateY**: Translation value of the object along the Y-axis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**translateZ**: Translation value of the object along the Z-axis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All translation values are numbers in meters.
  prefs: []
  type: TYPE_NORMAL
- en: Rotation values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The orientation of the 3D object will be defined with the `rotate` values in
    the following keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '**rotateX**: Rotation value of the object around the X-axis, in other words,
    turning the object up or down'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**rotateY**: Rotation value of the object around the Y-axis that would turn
    the object left or right'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**rotateZ**: Rotation value of the object around the Z-axis, making the object
    tilt forward or backward'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All rotation values are in numbers or string representations of a number in
    degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Scale value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `scale` value will define the relative size appearance of the 3D object:'
  prefs: []
  type: TYPE_NORMAL
- en: '**scale**: A number value that defines uniform scale across all axes'
  prefs: []
  type: TYPE_NORMAL
- en: Color
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the 3D object's material texture is not provided in an MTL file, the color
    value can define the default color of the object.
  prefs: []
  type: TYPE_NORMAL
- en: '**color**: A string value representing color values allowed in CSS'
  prefs: []
  type: TYPE_NORMAL
- en: With this game data structure capable of holding details of the game and its
    VR objects, we can implement the game in React 360 accordingly with sample data
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Static data versus dynamic data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the next chapter, we will update the React 360 code to fetch game data dynamically
    from the backend database. For now, we will start developing the game features
    here with dummy game data set to `state` with the defined game data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Sample data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For initial development purposes, the following sample game data can be set
    to state to be rendered in the game view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Building the game view in React 360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will apply the React 360 concepts, and use the game data structure to implement
    the game features by updating the code in `index.js` and `client.js`. For a working
    version, we will start with the state initialized using the sample game data from
    the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: '`/MERNVR/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Update client.js and mount to Location
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The default code in `client.js` attaches the mount point declared in `index.js`
    to the Default Surface in the React 360 app, where the Surface is a cylindrical
    layer for placing 2D UI. In order to use the 3D meter-based coordinate system
    for a layout in 3D space, we need to mount to a `Location` instead of a Surface.
    So update `client.js` to replace the `renderToSurface` with a `renderToLocation`.
  prefs: []
  type: TYPE_NORMAL
- en: '`/MERNVR/client.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You can also customize the initial background scene by updating the code `r360.compositor.setBackground(**r360.getAssetURL('360_world.jpg')**)` in
    `client.js` to use your desired image.
  prefs: []
  type: TYPE_NORMAL
- en: Defining styles with StyleSheet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In `index.js`, we will update the default styles created using `StyleSheet.create`
    with our own CSS rules, to be used with the components in the game.
  prefs: []
  type: TYPE_NORMAL
- en: '`/MERNVR/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: World background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to set the the game's 360 degree world background, we will update the
    current background scene using the `setBackgroundImage` method from the `Environment`
    API inside `componentDidMount`.
  prefs: []
  type: TYPE_NORMAL
- en: '`/MERNVR/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This will replace the default 360 background in the starter React 360 project
    with our sample game''s world image fetched from cloud storage. If you are editing
    the default React 360 application and have it running, refreshing the `http://localhost:8081/index.html` link
    on the browser should show an outer space background, that can be panned around
    using the mouse:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/84ae5823-42b5-4dae-b5d9-9cfb878804ee.png)'
  prefs: []
  type: TYPE_IMG
- en: To generate the preceding screenshot, the `View` and `Text` components in the
    default code were also updated with custom CSS rules to show this hello text on
    the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Adding 3D VR objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will add 3D objects to the game world using `Entity` components and the sample
    object details in the `answerObjects` and `wrongObjects` arrays.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will concatenate the `answerObjects` and `wrongObjects` arrays in
    `componentDidMount` to form a single array containing all the VR objects.
  prefs: []
  type: TYPE_NORMAL
- en: '`/MERNVR/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Then in the main view, we will iterate over the `vrObjects` array to add the
    `Entity` components with details of each object.
  prefs: []
  type: TYPE_NORMAL
- en: '`/MERNVR/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `obj` and `mtl` file links are added to `source` and the `transform` style
    details are applied in the `Entity` component's styles with `setModelStyles(vrObject,
    index)`.
  prefs: []
  type: TYPE_NORMAL
- en: '`/MERNVR/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `display` property will allow us to show or hide an object based on whether
    it has been already collected by the player or not.
  prefs: []
  type: TYPE_NORMAL
- en: The `translate` and `rotate` values will render the 3D objects in the desired
    positions and orientations across the VR world.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will update the `Entity` code further to enable user interactions with
    the 3D objects.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with VR objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to make the VR game objects interactive, we will use the React 360
    event handlers, such as `onEnter` and `onExit` with `Entity`, and `onClick` with
    `VrButton`, to add rotation animation and gameplay behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Rotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to add a feature that starts rotating a 3D object around its Y-axis
    whenever a player focuses on the 3D object, that is, the platform cursor begins
    intersecting with the `Entity` rendering the specific 3D object.
  prefs: []
  type: TYPE_NORMAL
- en: We will update the `Entity` component from the previous section to add the `onEnter`
    and `onExit` handlers.
  prefs: []
  type: TYPE_NORMAL
- en: '`/MERNVR/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The object will start rotating on enter, and stop when the platform cursor exits
    the object and it is no longer in the player's focus.
  prefs: []
  type: TYPE_NORMAL
- en: Animation with requestAnimationFrame
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `rotate(index)` and `stopRotate()` methods, we will implement rotation
    animation behavior using `requestAnimationFrame` for smooth animations on the
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: The `window.requestAnimationFrame()` method asks the browser to call a specified
    callback function to update an animation before the next repaint. With `requestAnimationFrame`,
    the browser optimizes the animations to make them smoother and more resource-efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `rotate` method, we will update the `rotateY` transform value of the
    given object at a steady rate on a set time interval with `requestionAnimationFrame`.
  prefs: []
  type: TYPE_NORMAL
- en: '`/MERNVR/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `requestAnimationFrame` will take the `rotate` method as a recursive callback
    function, then execute it to redraw each frame of the rotation animation with
    the new values, and in turn update the animation on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The `requestAnimateFrame` method returns a `requestID`, which we will use in
    `stopRotate` to cancel the animation in the `stopRotate` method.
  prefs: []
  type: TYPE_NORMAL
- en: '`/MERNVR/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This will implement the functionality of animating the 3D object only when
    it is in the viewer''s focus. As seen in the following image, the 3D Rubik''s
    cube rotates clockwise around its Y-axis while it is in focus:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/964de90f-5066-4af4-a817-058f9b65989a.png)Though not covered here,
    it is also worth exploring the React 360 Animated library, which can be used to
    compose different types of animations. Core components can be animated natively
    with this library, and it is possible to make other components animatable using
    `createAnimatedComponent()`. This library was originally implemented from React
    Native, and to learn more you can refer to the React Native documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: Clicking the 3D objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to register the click behavior on each 3D object added to the game,
    we need to wrap the `Entity` component with a `VrButton` component that can call
    the `onClick` handler.
  prefs: []
  type: TYPE_NORMAL
- en: We will update the `Entity` component added inside the `vrObjects` array iteration
    code, to wrap it with the `VrButton` component. The `VrButton` will call the `collectItem`
    method when clicked, and pass it the current object's details.
  prefs: []
  type: TYPE_NORMAL
- en: '`/MERNVR/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'When a 3D object is clicked, the `collectItem` method needs to perform the
    following actions with respect to the game features:'
  prefs: []
  type: TYPE_NORMAL
- en: Check whether the clicked object is an `answerObject` or a `wrongObject`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on the object type, play the associated sound
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the object is an `answerObject`, it should be collected and disappear from
    view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update collected objects list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check whether all instances of `answerObject` were successfully collected with
    this click
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If yes, show the game completed message to the player and play the sound for game
    completed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hence, the `collectItem` method will have the following structure and steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will look at the implementation for these steps.
  prefs: []
  type: TYPE_NORMAL
- en: Collecting the correct object on click
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a user clicks on a 3D object, we need to first check whether the clicked
    object is an answer object. If it is, this *collected* object will be hidden from
    view and a list of collected objects will be updated along with the total number
    to keep track of the user's progress in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check whether the clicked VR object is an `answerObject`, we will use the
    `indexOf` method to find a match in the `answerObjects` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If the `vrObject` is an `answerObject`, `indexOf` will return the array index
    of the matched object, otherwise it will return `-1` if no match is found.
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep track of collected objects in the game, we will also maintain an array
    of Boolean values in `collectedList`, and the total number of objects collected
    so far in `collectedNum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `collectedList` array, we will also determine which `Entity` component
    should be hidden from the view because the associated object was collected. The
    `display` style property of the relevant `Entity` will be set based on the Boolean
    value of the corresponding index in the `collectedList` array, while setting the
    style for the `Entity` component using the `setModelStyles` method, as shown earlier
    in the *Adding 3D VR objects* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following image, the treasure chest can be clicked to be collected as
    it is an `answerObject`, whereas the flower pot cannot be collected because it
    is a `wrongObject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a24e207b-ab10-4470-a0e4-4aa47c33fc0a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the treasure chest is clicked, it disappears from the view as the `collectedList`
    is updated, and we also play the sound effect for collection using `AudioModule.playOneShot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'But when the flower pot is clicked, and it is identified as a wrong object,
    we play another sound effect indicating it cannot be collected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'As the flower pot was identified to be a wrong object, the `collectedList`
    was not updated and it remains on the screen as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c8f40ddb-babd-44cf-8270-3966e0440f1d.png)'
  prefs: []
  type: TYPE_IMG
- en: The complete code in the `collectItem` method that executes all these steps
    when an object is clicked will be as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`/MERNVR/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: After a clicked object is collected, we will also check whether all the `answerObjects`
    have been collected, and the game is complete with the `checkGameCompleteStatus`
    method, as discussed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Game completed state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every time an `answerObject` is collected, we will check whether the total number
    of collected items is equal to the total number of objects in the `answerObjects`
    array to determine whether the game is complete by calling `checkGameCompleteStatus`.
  prefs: []
  type: TYPE_NORMAL
- en: '`/MERNVR/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If the game is indeed complete, we will perform the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Play the audio for game completed, using `AudioModule.playEnvironmental`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetch the current `headMatrix` value using `VrHeadModel` so it can be set as
    the transform matrix value for the `View` component containing the game completion
    message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the `display` style property of the message `View` to `flex`, so the message
    renders to the viewer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `View` component containing the message congratulating the player for completing
    the game will be added to the parent `View` component as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`/MERNVR/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The call to the `setGameCompletedStyle()` method will set the styles for the
    message `View` with the updated `display` value and `transform` matrix value.
  prefs: []
  type: TYPE_NORMAL
- en: '`/MERNVR/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This will render the `View` with the completion message at the center of the
    user''s current view, regardless of whether they are looking up, down, behind,
    or forward in the 360 degree VR world:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/895c5e99-6682-46fc-8b56-062dfd0f2fbf.png)'
  prefs: []
  type: TYPE_IMG
- en: The final text in the `View` message will act as a button, as we wrapped this
    `View` in a `VrButton` component that calls the `exitGame` method when clicked.
  prefs: []
  type: TYPE_NORMAL
- en: '`/MERNVR/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `exitGame` method will use the `Location.replace` method to redirect the
    user to an external URL that may contain a list of games.
  prefs: []
  type: TYPE_NORMAL
- en: The `replace` method can be passed any valid URL, and once this React 360 game
    code is integrated with the MERN VR Game application in [Chapter 11](f9761c7c-dfc5-4247-9cfc-aaebc78b93da.xhtml),
    *Making the VR Game Dynamic Using MERN*, `replace('/')` will take the user to
    the home page of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Bundling for production and integration with MERN
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have features of the VR game implemented and functional with sample
    game data, we can prepare it for production and add it to our MERN base application
    to see how VR can be added to an existing web application.
  prefs: []
  type: TYPE_NORMAL
- en: React 360 tools provide a script to bundle all the React 360 application code
    into a few files that we can just place on the MERN web server and serve as content
    at a specified route.
  prefs: []
  type: TYPE_NORMAL
- en: Bundling React 360 files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create the bundled files, we can run the following command from the React
    360 project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This generates compiled versions of the React 360 application files in a folder
    called `build`. The compiled bundle files are `client.bundle.js` and `index.bundle.js`.
    These two files, in addition to `index.html` and the `static-assets/` folder,
    make up the production version of the whole React 360 application that was developed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Integrating with MERN application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will need to add these three files and the `static_assets` folder to our
    MERN application, then make sure the bundle file references are accurate in `index.html`,
    and finally load the `index.html` at a specified route in the Express app.
  prefs: []
  type: TYPE_NORMAL
- en: Add the React 360 production files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With consideration to the folder structure in the MERN skeleton application,
    we will add the `static_assets` folder and the bundle files to the `dist/` folder
    to keep our MERN code organized and have all the bundles in the same location.
    The `index.html` file will be placed in a new folder, named `vr`, in the `server`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Updating references in index.html
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The generated `index.html` file, as shown here, references the bundle files,
    expecting these files to be in the same folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We need to update `index.html` to refer to the correct location of the `client.bundle.js`, `index.bundle.js`,
    and `static_assets` folders.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, update the reference to `client.bundle.js` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, update `React360.init` with the correct reference to `index.bundle.js`,
    and `assetRoot` set to the correct location of the `static_assets` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `assetRoot` will tell React 360 where to look for asset files when we use
    `asset()` to set resources in the components.
  prefs: []
  type: TYPE_NORMAL
- en: Now,  if we set up an Express route in the MERN application to return the `index.html`
    file in the response, then visiting the route in the browser will render the React
    360 game.
  prefs: []
  type: TYPE_NORMAL
- en: Trying out the integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test out this integration, we can set up an example route, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Then run the MERN server, and open the route in the browser at `localhost:3000/game/play`.
    This should render the React 360 game implemented in this chapter from within
    our MERN application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we used React 360 to develop a web-based VR game that can be
    easily integrated into MERN applications.
  prefs: []
  type: TYPE_NORMAL
- en: We began by defining simple VR features for the gameplay, then set up React
    360 for development, and looked at key VR concepts such as equirectangular panoramic
    images, 3D positions, and coordinate systems in the 360-degree VR world. We explored
    the React 360 components and API required to implement the game features, including
    components such as `View`, `Text`, `Entity`, and `VrButton`, along with the `Environment`, `VrHeadModel` and
    `NativeModules` APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we updated the code in the starter React 360 project to implement the
    game with sample game data, then bundled the code files and discussed how to add
    these compiled files to an existing MERN application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will develop the MERN VR Game application, complete
    with a game database and APIs so we can make the game developed in this chapter
    dynamic by fetching data from the game collection in MongoDB.
  prefs: []
  type: TYPE_NORMAL
