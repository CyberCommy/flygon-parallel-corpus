- en: Chapter 8. Exploit Development with Python, Metasploit, and Immunity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During research or in a rare engagement, you may need to develop or modify exploits
    to meet your needs. Python is a fantastic language to quickly prototype code for
    testing exploits or to help with the future modification of Metasploit modules.
    This chapter focuses on the methodology to write an exploit, not how to create
    specific exploits for these software products, so that more testing may be necessary
    to improve reliability. To begin, we need to understand how the **Central Processing
    Unit** (**CPU**) registers and how Windows memory is structured for executables
    when they run. Before that, on Windows XP Run Mode **Virtual Machine** (**VM**),
    you will need a few tools to test this out.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Download and install the following components on Windows XP Run: Mode VM, Python
    2.7, Notepad++, Immunity Debugger, MinGW (with all the basic packages), and Free
    MP3 CD Ripper version 1.0\. Also use your current Kali build to help generate
    the relevant details we are going to highlight as we go through this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with registers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This explanation is based on x86 systems and the relevant registers that process
    instruction sets for executables. We are not going to discuss in detail all registers
    for brevity, but we will describe the most important ones for the scope of this
    chapter. The registers that are specifically highlighted are 32-bits in size and
    are known as the extended registers.
  prefs: []
  type: TYPE_NORMAL
- en: They are extended because they have 16-bits added to the previous 16-bit registers.
    For example, the older 16-bit general purpose registers could be identified by
    simply removing the E from the front of the register name, so EBX also contains
    the 16-bit BX register. The BX register is actually the combination of two smaller
    8-bit registers, the BH and the BL. The H and the L signify the High Byte and
    the Low Byte register. There are extensive books written on this subject alone
    and replicating that information would not be directly useful to our purpose.
    Overall, registers are broken down into two forms for ease of understanding, the
    general purpose registers and the special purpose registers.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding general purpose registers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The four general purpose registers are the EAX, EBX, ECX, and EDX. The reason
    they are called general purposes registers is because mathematical operations
    and storage occur here. Keep in mind that anything can be manipulated, even the
    basic concepts of what the registers would normally be doing. For this description,
    though, the overall purpose is accurate.
  prefs: []
  type: TYPE_NORMAL
- en: The EAX
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The accumulator register is used for basic mathematical operations and the return
    value of a function.
  prefs: []
  type: TYPE_NORMAL
- en: The EBX
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The base register is another general purpose register, but unlike the EAX it
    is not intended for a specific purpose. As such, this register can be used for
    nominal storage as needed.
  prefs: []
  type: TYPE_NORMAL
- en: The ECX
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The counter register is used primarily for looping through functions and iterations.
    The ECX register can also be used for general storage.
  prefs: []
  type: TYPE_NORMAL
- en: The EDX
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The data register is used for higher mathematical operations, such as multiplication
    and division. This register also stores function variables throughout the processing
    of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding special purpose registers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These registers are the ones where the indexing and pointing is handled throughout
    the processing of the program. What this means to you is that this is where the
    magic happens for basic exploit writing - we are, in the end, trying to manipulate
    the overwrite of data here. This is done by orders of operations that happen in
    other registers.
  prefs: []
  type: TYPE_NORMAL
- en: The EBP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The base pointer tells you where the bottom of the stack is at. When a function
    is first called, this points to the top of the stack, or it is set to the old
    stack pointer value. This is because the stack has shifted or grown.
  prefs: []
  type: TYPE_NORMAL
- en: The EDI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The destination index register is for pointers to function.
  prefs: []
  type: TYPE_NORMAL
- en: The EIP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The instruction pointer is considered the goal of basic exploit writing. You
    are trying to overwrite the value of this stored point on the stack, because if
    you control this value, you control the next instruction to be executed by the
    CPU. So, when you see the developers or exploit writers talk about overwriting
    the data on the EIP register, understand that this is not a good thing. It means
    that some design of the program itself has failed.
  prefs: []
  type: TYPE_NORMAL
- en: The ESP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The stack pointer shows the current top of the stack, and this is modified as
    the program is run. So, as items are removed from the top of the stack as they
    are run, the ESP changes where it is pointing to. When new functions are loaded
    onto the stack, the EBP takes the old position of the ESP.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Windows memory structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Windows **Operating System (OS)** memory structure has a number of sections
    that can be broken down into high level components. To understand how to write
    exploits and take advantages of poor programming practices, we first have to understand
    these sections. The following details break this information down into manageable
    chunks. The following figure provides a representative diagram of the Windows
    memory structure for an executable.
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the Windows memory structure](img/B04315_08_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, each of these components is important, but the pieces we use with most
    exploit writing are the stack and the heap.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the stack and the heap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The stack is used for short term local storage in an ordered manner. Each time
    a function is called, or a thread, a unique stack is assigned of a fixed size
    for that function or thread. Once the function or thread has finished the operations,
    the stack is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: The heap, on the other hand, is where global variables and values are assigned
    in a relatively disorganized manner. The heap is shared by applications and the
    areas of memory are actually managed by the application or process. Once the application
    terminates that specific region of memory is freed. In this example, we are attacking
    the stack, not the heap.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep in mind that the exploit examples here are often written in Perl, though
    you can easily convert the code to Python, as highlighted in [Chapter 2](ch02.html
    "Chapter 2. The Basics of Python Scripting"), *The Basics of Python Scripting*.
  prefs: []
  type: TYPE_NORMAL
- en: To better understand the difference between the heap and the stack movement,
    see the following figure, which shows the adjustment as memory is allocated for
    global and local resources.
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the stack and the heap](img/B04315_08_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The stack builds up the data from bottom of the stack to the top. The growth
    goes from high memory addresses to low memory addresses. The heap is opposite
    of the stack as it grows in the other direction, toward the higher addresses.
  prefs: []
  type: TYPE_NORMAL
- en: To understand the way a program would be loaded onto the stack, we create a
    sample code snippet. With this code, you can see how the main function calls `function1`
    and the local variables as they are placed onto the stack. Pay attention to the
    way that the program would normally flow with calls to `function1` and how the
    data is placed on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![Understanding the stack and the heap](img/B04315_08_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code loaded on the stack would look similar to this, which highlights how
    the information components are presented. As you can see, the old Base Pointer
    is loaded on to the stack for storage and the new EBP is the old Stack Pointer
    value, since the top of the stack has shifted to its new location.
  prefs: []
  type: TYPE_NORMAL
- en: Items that are put onto the stack are pushed onto it, and items that are run
    or removed from the stack are popped off of it. A stack is a programmable concept
    known as a **Last In First Out** (**LIFO**) structure. Think of it as a stack
    of dishes; to effectively remove dishes you have to take them off the top by one
    or by sets, otherwise you risk breaking things. The safest way, of course, is
    one at a time, which takes longer, but it is traceable and effective. With an
    understanding of the most dynamic parts of the memory structure that we will be
    using to inject our code into, you need to understand the remaining areas of Windows
    memory that will function as the building blocks, which we will manipulate to
    get from injection to shell. Specifically, we are speaking of the program image
    and **Dynamic Link Libraries** (**DLL**).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember, we are attempting to inject shellcode into the memory, which we will
    then use to gain access to the system through a solution such as a Meterpreter.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the program image and dynamic-link libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Simply put, the program image is where the actual executable is stored in memory.
    **Portable Executable (PE)** is the defined format for the executable, which contains
    the executable and the DLL. Within the program image component of the memory,
    the following items are defined.
  prefs: []
  type: TYPE_NORMAL
- en: '`PE header`: This contains the definitions for the rest of the PE.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.text`: This component contains the code segment or the executable instructions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.rdata`: This is the read-only data segment, which contains static constants
    rather than variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.data`: When the executable is loaded into memory, this area contains the
    static variables after they have been initialized, the global variables and static
    local variables. This area is readable and writeable, but the size does not change
    at runtime, it is determined at execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.rsrc`: This section is where the resources for the executable are stored.
    This includes the icons, menus, dialogs, version information, fonts, and so forth.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many penetration testers manipulate the `.rsrc` component of an executable to
    change the format of payloads so that it appears as something else. This is often
    done to change the way a malicious payload appears on a **Universal Serial Bus
    (USB)** drive. Think about when you do a USB drop when you change your payload
    from looking like an executable to a folder. Most people would want to see what
    is in the folder and would be more likely to double click a fake folder than a
    suspicious executable. Tools like resource tuner make the manipulation of this
    section of the PE very easy.
  prefs: []
  type: TYPE_NORMAL
- en: The final component to understand here for the PE is the DLL, which encompasses
    Microsoft's concept of shared libraries. DLLs are similar to executables, but
    they cannot be called directly, and instead they have to be called by an executable.
    At its core, the idea of DLLs is to provide a method for the capabilities to upgrade
    without requiring the entire program to be recompiled when OS is updated.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this, many of the basic building blocks for system operations need
    to be referenced regardless of start-up cycle. This means that even if other components
    are going to be in different memory locations, many core DLLs will stay in the
    same referenced locations. Remember, programs require specific callable instructions
    and many of the foundational DLLs are loaded into the same regions of memory.
  prefs: []
  type: TYPE_NORMAL
- en: What you need to understand is that we will use these DLLs to find an instruction
    that is reliably put into the same location so that we can reference it. This
    means that across the systems and the reboots, the memory reference will work
    as long as the OS and **Service Pack (SP)** version are the same if you use OS
    DLLs. If you use DLLs that are completely native to the program, you will be able
    to use this exploit across OS versions. For this example, though, we are going
    to use OS DLLs. The discovered instruction will enable us to tell the system to
    jump to our shell code, and in turn, execute it.
  prefs: []
  type: TYPE_NORMAL
- en: The reason we have to do a reference code in DLL is because we will be unsure
    of the exact location that our code will be loaded into memory each time we initiate
    this attack, so we cannot tell the system our exact memory address to jump to.
    So, instead, we are going to load the stack with our code and then tell the program
    to jump to the top of it by referencing the position.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that this may change each time we execute the program and/or each reboot.
    The stack memory addresses are served as required per program, and we are attempting
    to inject our code directly into this running function's stack. So, we have to
    take advantage of the known and repeatable target instruction sets. We will explain
    the exact process of this in detail, but for now, just know that we use DLLs known
    instruction sets to jump to our shell code. From this area of memory, the other
    components are less important for our exploitation techniques highlighted here,
    but you need to understand them as they are referenced in your debuggers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The PE can be better understood from the following two older articles, *Peering
    Inside the PE: A Tour of the Win32 Portable Executable File Format*, found here
    [https://msdn.microsoft.com/en-us/magazine/ms809762.aspx](https://msdn.microsoft.com/en-us/magazine/ms809762.aspx),
    and An In-Depth Look into the Win32 Portable Executable File Format, found here
    [https://msdn.microsoft.com/en-us/magazine/cc301805.aspx](https://msdn.microsoft.com/en-us/magazine/cc301805.aspx).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the process environment block
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Process Environment Block** (**PEB**) is where nonkernel components of
    a running process are stored. Information that is needed by systems that should
    not have access to kernel components is stored in memory. Some **Host Intrusion
    Prevention Systems** (**HIPS**) monitor activities in this memory region to see
    if malicious activities are taking place. The PEB contains details related to
    the loaded DLLs, executables, access restrictions, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the thread environment block
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **Thread Environment Block (TEB)** is spawned for each thread that a process
    has established. The first thread is known as the primary thread and each thread
    after that has its own TEB. Each TEB share the memory allocations of the process
    that initiated them, but they can execute instructions in a manner that makes
    task completion more efficient. Since writeable access is required, this environment
    resides in the nonkernel block of the memory.
  prefs: []
  type: TYPE_NORMAL
- en: Kernel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the area of memory reserved for device drivers, the **Hardware Access
    Layer (HAL)**, the cache and other components that programs do not need direct
    access to. The best way to understand the kernel is that this is the most critical
    component of the OS. All communication is brokered as necessary through OS features.
    The attacks we are highlighting here do not depend on a deep understanding of
    the kernel. Additionally, a deep understanding of the Windows kernel would take
    a book of its own. After defining the memory locations, we have to understand
    how data is addressed within it.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding memory addresses and endianness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When looking at the memory, the data is represented in hexadecimal characters
    0 - F, each of which represents a value of 0 - 15\. For example, the value 0 in
    hexadecimal would be represented as 0000 in binary and the representation of F
    would be 1111 in binary.
  prefs: []
  type: TYPE_NORMAL
- en: Using hexadecimal makes it easier to read memory addresses and easier to write
    them as well. Since we have 32-bit memory addresses, there would be 32 positions
    for specific bits. Since each hexadecimal value represents four bits, the equivalent
    representation can be done in eight hexadecimal characters. Keep in mind these
    hexadecimal characters are paired so that they represent four pairs.
  prefs: []
  type: TYPE_NORMAL
- en: Intel x86 platforms use a little endian notation for the memory addressing,
    which means the least significant byte comes first. The memory address you read
    has to be reversed to generate the little endian equivalent. To understand manual
    conversion to little endian, take a look at the following image and note that
    you are reversing the order of the pairs, not the pairs themselves. This is because
    the pair represents a byte, and we order by the least significant byte first,
    not the bit, if that was the case the hexadecimal character would change as well,
    unless it was an A or F.
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding memory addresses and endianness](img/B04315_08_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Do not worry we have a cheat, you will often see that Perl exploits written
    with specific memory addresses loaded into variables with a `pack('V', 0xaa01f24d)`.
    This is a neat feature of Perl that allows you to load memory values in little
    endian notation directly into a variable. Python's equivalent is `struct.pack('<I',
    0xaa01f24d)`, which makes representation of memory addresses much simpler. If
    you look at your Metasploit modules, you can see the intended action as well represented
    in this manner `[target['Ret']].pack('V')`. This provides the return action for
    the specified target based on the memory address passed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You know when you run your exploit in Metasploit and you chose a target such
    as Windows XP SP3 or Windows 2008 R2\. That target is usually the specific memory
    address for the EIP to use to call a specific action. Typically, it is `jmp esp`
    to execute the injection, you will see more about reversing Metasploit modules
    later in this Chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We mentioned earlier that we are trying to overwrite the EIP register with a
    memory value that points to an instruction. That instruction will be chosen based
    on what data we can overwrite while we are building our exploit. The EIP is the
    one area in your exploit code, where you have to worry about Endianness; the rest
    of the exploit is straight forward.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The naming concept of **Little Endian** and **Big Endian** came from *Jonathan
    Swift's book Gulliver's Travels*. As a simple synopsis of the book, the Little
    Endians believed in breaking eggs from the small side of the egg and the Big Endians
    believed in breaking their eggs from the big side. This same concept is what has
    been applied to memory structure naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the manipulation of the stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand what we are trying to do with the writing of the exploit, you
    must understand what is happening in memory. We are going to inject data into
    an area of memory where there was no bound checking. This usually means that a
    variable was declared a specific size, and when data was copied into that variable
    there was no verification that the data would fit in it before copying.
  prefs: []
  type: TYPE_NORMAL
- en: This means that more data can be placed in a variable than what was intended.
    When that happens, the excess data spills into the stack and overwrites saved
    values. One of those saved values includes the EIP. The image below highlights
    how the injected data is pushed onto the stack and can move to overwrite the saved
    values.
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the manipulation of the stack](img/B04315_08_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We are going to flood the stack with a variety of characters to determine the
    area we need to overwrite. First, we will start with a large set of As, Bs, and
    Cs. The values we see while viewing our debugger data will tell us where on the
    stack we have landed. The differences in character types will help us better determine
    what size our unique character test needs to be. The following figure shows the
    combination of As, Bs, and Cs (that do not appear) on the stack as we overwrite
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the manipulation of the stack](img/B04315_08_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now after getting a general idea of where the EIP is, we can generate a unique
    patter with the size of the As and Bs added together. This unique pattern will
    be injected back into the vulnerable program. We can then take the unique value
    that overwrites the EIP register and compare it to our pattern. We determine how
    far down our large unique pattern that value falls and determine that is how much
    data is needed be pushed onto the stack to reach the EIP.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have identified where the EIP is, we can locate the instruction we want
    to reference in the EIP by examining the DLLs. Remember, DLLs that are a part
    of the program itself will be more portable, and your exploit will work in more
    than one version of Windows. Windows OS DLLs make writing exploits easier, because
    they are omnipresent and have the required instructions you are looking for.
  prefs: []
  type: TYPE_NORMAL
- en: In this version of the exploit, we are trying to Jump to the ESP as the available
    space is there, and it is easy to build an exploit to take advantage of it. If
    we were using one of the other registers, we would have to look for an instruction
    to jump to that register. We will then have to determine how much space is available
    from the manipulated register down to the EIP. That will help determine how much
    data needs to be filled in that area of the stack, as our shellcode will only
    fill in a small part of that area.
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowing this, we are going to sandwich our shell code with **No Operations**
    (**NOPs**). The NOPs that sit between the shellcode and the EIP are to offset
    the injected shellcode. So when instructions are loaded into the registers, they
    are loaded in appropriate chunks. Otherwise, the shellcode will be out of place.
    Finally, the sled that is loaded last onto the stack is there to take up the rest
    of the space, so when the Jump to ESP is called the code slides down from the
    top to the actual shellcode. See the following image to have a better understanding
    of where we are moving towards:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the manipulation of the stack](img/B04315_08_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With this basic understanding, we can start to work with the Immunity debugger
    on a poorly created C program.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding immunity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to first start with the way Immunity is setup. Immunity is an awesome
    debugger that is based in Python. So many of the plugins to include Mona are written
    in Python, which means if you need to change something, you just modify the scripts.
    The main screen for Immunity is split into four sections, and when you hook a
    process or execute a program you can see the output of the details, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding immunity](img/B04315_08_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This layout is the basic appearance in which you will spend most of your time.
    You can call different windows as necessary for reviewing other running components,
    such as DLLs. We will cover more of that later, but let us start with creating
    a basic buffer overflow.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding basic buffer overflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following C code lacks appropriate bound checking to enforce variable size
    restrictions on a copy. This is a rudimentary example of poor programming, but
    it is the basis for many exploits that are part of the Metasploit framework.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We take this code and place it into a file called `username_test.cpp`, and
    then compile it with MinGW, as shown following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding basic buffer overflow](img/B04315_08_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can then run newly compiled program to see it returns whatever text we provide
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding basic buffer overflow](img/B04315_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, start Immunity and open the `username_test.exe` binary with the argument
    test, as seen below. This does functionally the same thing as both the Python
    script and running it from the command line, which means that you can monitor
    the output from the debugger.
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding basic buffer overflow](img/B04315_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we need to provide more data than expected and attempt to trigger an overflow.
    This could easily be done here as we know the limits for this particular binary,
    but if we did not know this, we would have to take a relative guess. To do that,
    we should generate some data, such as a bunch of capital As, and see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: We could either repeatedly hold down the *Shift* key plus the letter A each
    time we wanted to generate the arguments, or we can create a generator to do a
    similar activity. We can, again, use Python to help us out here. See the simple
    code, which will create files of data as needed, which can be copied and pasted
    into the debugger.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of which can be seen in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding basic buffer overflow](img/B04315_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, copy and paste the data into the Immunity debugger arguments and step through
    the program as it runs with the *F7* key. After holding the key down for a period
    of time, you will start to see your binary run with the arguments provided as
    it is processed in the Registers Pane, and as it is processed, 41414141 will be
    picked up in the EAX register. Each of the 41 represents the **American Standard
    Code for Information Interchange** (**ASCII**) letter A. Once you finish running
    the program, you should see the EIP overflowed with the letter A.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The memory addresses you will see in this example will be different than those
    in your own environment, so you need to make sure to generate your final script
    with your memory addresses, not what you see in these images.
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding basic buffer overflow](img/B04315_08_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, we know that we have provided enough As to overwrite the EIP. This means
    that we have found that we can overwrite the EIP, but we have not provided it
    with anything useful to do, and we do not know where it actually is in the stack.
    Basically, this means that this activity crashed our program instead of doing
    what we wanted to - get a shell.
  prefs: []
  type: TYPE_NORMAL
- en: This brings up another point about crafting exploits; often exploits that are
    not well designed, or cannot be designed to work in the memory constraints in
    particular vulnerabilities, will produce a **Denial of Service** (**DoS**) condition.
    Our goal instead is to get a shell on the box, and to do that, we need to manipulate
    what is being pushed into the program. Keep in mind that when you consider services,
    there have been reports of **Remote Code Execution** (**RCE**) attacks available,
    and the only public exploits available result in DoS attacks. This means that
    the environment is very difficult to achieve shell access, or the researcher's
    capabilities to create an exploit in that environment may be limited.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you go along, if your registers have errors, such as the one in the following
    figure, you have not properly determined your buffer size for follow on development.
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding basic buffer overflow](img/B04315_08_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that you understand the basics of injecting data into the buffer and overflowing
    it, we can target a real vulnerable solution. We are going to use the Free MP3
    CD Ripper program for this example. This program provides very little tangible
    value in developing an exploit, but developing it is a relatively simple exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a basic buffer overflow exploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to exploit version 1 of the Free MP3 CD Ripper software program.
    To do this, we need to download and install the product from this location [http://free-mp3-cd-ripper.en.softonic.com/](http://free-mp3-cd-ripper.en.softonic.com/).
    To take advantage of this program's weakness, we are going to use the following
    Python script, which will generate a malicious .wav file that can be uploaded
    into the program. The data will be interpreted and will create an overflow condition
    that we can observe and attempt to tailor and build an exploit. As mentioned before,
    we are going to load up a number of different characters into this file so that
    we can guestimate the relative location of the stored EIP value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This script will fill the malicious wave file with four thousand As, one thousand
    Bs, and one thousand Cs. Now, open the program with Immunity, as shown following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing a basic buffer overflow exploit](img/B04315_08_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Generate the malicious wave file with your new Python script, as shown following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing a basic buffer overflow exploit](img/B04315_08_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, load up the new file with the vulnerable program, as shown following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing a basic buffer overflow exploit](img/B04315_08_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results of this is that we get a crash solidly in the Bs, as seen below,
    which means our EIP overwrite is somewhere between four thousand and five thousand
    characters.
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing a basic buffer overflow exploit](img/B04315_08_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Additionally, we see that we have Bs in EBX, EBP, ESI, and EDI, but what about
    ESP? We need to find room to place our shell code, and the easiest way to do that
    is to work with ESP. So, what we will do is dump the contents of that register—you
    do this by right clicking on the register and viewing the details in the bottom-left
    corner pane of Immunity as show by the two image components.
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing a basic buffer overflow exploit](img/B04315_08_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we have filled the ESP with Bs as well. We need to narrow down
    the locations that we can place our shellcode and location of EIP, so we are going
    to use Metasploit's `pattern_create.rb`. First, we need to find the EIP, so we
    are going to generate five thousand unique characters. When you use this script,
    you will be able to inject the data, and then identify the exact location of the
    overwrite. The figure below highlights how to generate a unique data set generation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing a basic buffer overflow exploit](img/B04315_08_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, copy the characters out of the output file, and feed them into the program
    again as a new `.wav` file. When we load the new `.wav` file in, we see the program
    again crashes and a value overwrites the EIP.
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing a basic buffer overflow exploit](img/B04315_08_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We need to copy that value and use it to determine the actual offset needed
    for our exploit using the `patter_offset.rb` script by feeding in the memory address
    and the number of characters that we originally asked for.
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing a basic buffer overflow exploit](img/B04315_08_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'So, now we update our fill variable to that value. We have to verify that this
    junk data is going to cause us to land directly on the EIP so that it can be overwritten.
    A test case can be executed to verify that we have pinpointed the EIP by setting
    it explicitly using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of that code produces the following results, which means that we
    have pinpointed our EIP location:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing a basic buffer overflow exploit](img/B04315_08_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, remember that we verified we overwrote the ESP during our testing. We are
    going to use the area between the ESP and EIP to hold our shell code. So, we are
    looking for the command `jmp esp`, and we are going to use Microsoft's shared
    libraries to do so. The DLLs are loaded and reused throughout each program cycle.
    That means that we can look at DLLs the program uses and attempt to find a memory
    location that can be used to reference the `jmp esp` command. We can then replace
    the EIP value with the memory location of the `jmp esp` instruction from a viable
    DLL.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you hit the *Alt* + *E*, you will be provided a new window, which contains
    the entire affected program DLLs and the system DLLs. See the following screenshot,
    which highlights those DLLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing a basic buffer overflow exploit](img/B04315_08_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Program and the system DLLs
  prefs: []
  type: TYPE_NORMAL
- en: 'We double-click the `kernel32.dll`, and then right-click to search for a specific
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing a basic buffer overflow exploit](img/B04315_08_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once we click on the command, we search for the operation instruction set `jmp
    esp`, which tells the program to jump to ESP.
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing a basic buffer overflow exploit](img/B04315_08_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We copy the results and get the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Next, we set the EIP to the address discovered. This address is a good target
    address because there are no bad characters, such as "\x00". Those characters
    would actually stop the complete execution of our code. There are a number of
    ways to test for bad characters, but there are a few standards we try to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: Null ("\x00")
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Form Feed ("\xFF")
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tab ("\x09")
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line Feed ("\x0A")
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Carriage Return ("\x0D")
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other characters can be tested for by fuzzing the application with lists of
    potentially bad characters. You inject these lists of character sets from "\x00"
    to "\xFF". When you see the application crash, you have identified a bad character.
    Delete the character from the tuple, store the value, and try again. Once this
    executes without crashing the attack via a bad character, you have determined
    all the viable bad characters. We can test for bad characters after we determine
    how big our remaining stack space is and the offset.
  prefs: []
  type: TYPE_NORMAL
- en: Next is the identification of the stack offset space. It would be ineffective
    to place the shellcode right after the EIP value in the exploit script. That may
    cause characters to be read out of order and, in turn, cause shellcode failure.
  prefs: []
  type: TYPE_NORMAL
- en: This is because if we jumped to the ESP and we did not take into consideration
    the slack space, we might offset the code. This means that full instruction sets
    would not be interpreted holistically. This would mean that our code would not
    execute properly. Additionally, if we were imprecise and stuck a ton of NOP data
    between the EIP and ESP, you may take up valuable space that could be used for
    your shellcode. Remember that stack space is limited, so being precise is beneficial.
  prefs: []
  type: TYPE_NORMAL
- en: To test for this, we can write a quick generator script, so we are not messing
    with our actual exploit script. This script helps us test for slack space between
    the EIP and the ESP.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We then run the same `pattern_create.rb` script, but just use 1000 characters
    instead of 5000\. Stick the output data into the data variable and run the generator
    script. Load the `exploit.wav` file into the program while monitoring it with
    Immunity, as done before. When the program again crashes, look at the dump of
    the ESP.
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing a basic buffer overflow exploit](img/B04315_08_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you view the dump, you will see that ten characters are offset initially.
    This means to make the execution of this code more reliable, we need to add a
    NOP of ten or more characters between the EIP and the shellcode. Now, we need
    to determine how much space we have in this location of the stack to inject our
    code. We look at our memory dump and we find the difference between the beginning
    and ending addresses to determine how much room we have. Taking the two addresses,
    we find that we have limited space to play with roughly - 320 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: If we were doing a single stage payload, there are a number of steps we can
    execute to verify that we are going to stay in range. We are doing a multiple
    stage payload, though, which means we need to have more than the space provided.
    This means we need to modify the stack size in real time, but before that, we
    should confirm that we can get code execution, and you need to understand what
    running out of stack space looks like.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know our stack space and our offset, we can adjust the script to
    search for potential bad characters. Next, we add a NOP sled at the end of the
    code to ensure the execution of the Jump to ESP slides until it hits executable
    code. We do this by calculating the entire area that we have to play with and
    subtracting the offset and the shellcode from it.
  prefs: []
  type: TYPE_NORMAL
- en: We then create a NOP sled that takes up the remaining area. The easiest way
    to execute this is by using an equation similar to this `nop = "\x90"*(320-len(shell)-len(offset))`.
    The updated Python code looks like the following. Using the Python following script
    we can test for bad characters; note that we had to do this after our initial
    sizing because our areas of issue are going to be in the remaining stack space.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We should generate our mock shellcode that the program is going to jump to.
    For an initial test case, you want to start with a simple example that will not
    have any other dependencies. So, we can tell the injected code to call an instance
    of `calc.exe`. To do that, all we have to do is use `msfvenom` to generate the
    shell code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: What this does is generate the shellcode in a format that can be placed in a
    Python tuple and removes potential bad characters `'\x00'`, `'\xff'`. Tools like
    `msfvenom` do this for us automatically by using encoders. An encoder's purpose
    is to remove bad characters; there is a big misconception that they are used to
    bypass HIPS like antivirus.
  prefs: []
  type: TYPE_NORMAL
- en: Years ago, basic signature analysis in HIPS might have not caught an exploit
    because it did not match a very specific signature. Today, security tool developers
    have gotten better and triggers are more analytical by design. So, the fallacy
    of encoders helping stop HIPS solutions from catching an exploit are finally dying
    off.
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing a basic buffer overflow exploit](img/B04315_08_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Our new exploit with the `calc.exe` code can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We then run the code to generate the new malicious `.wav` file, and then load
    it into the program to see if the EIP is overwritten and the `calc.exe` binary
    is executed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing a basic buffer overflow exploit](img/B04315_08_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So now that the basic exploit written, we can update it to establish a session
    shell through this weakness. First, we need to determine what payload size would
    be best for our exploit. This stack space overall is limited, so we can try and
    minimize our footprint initially, but as you will see this will not matter.
  prefs: []
  type: TYPE_NORMAL
- en: You can generate your payloads by guessing and checking with `msfvenom` and
    the `-s` flag, but this is inefficient and slow. You will find that as payloads
    are generated, they may not be compatible based on the payload type you choose
    and the encoders needed to remove bad characters and size the package, appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of playing the guessing game, we can determine a good starting point
    by running the `payload_lengths.rb` script in the `/usr/share/metasploit-framework/tools`
    directory. These scripts provides great details about the payload lengths, but
    consider that we are looking for small payloads below 300 characters if possible.
    So, we can run the script awk for the size of the payload and grep for payloads
    that are used in Windows environments, as shown following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing a basic buffer overflow exploit](img/B04315_08_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There were just under 40 results from this commands output, but some good options
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing a basic buffer overflow exploit](img/B04315_08_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On our Metasploit instance, we startup `exploit/multi/handler` that will receive
    the shell.
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing a basic buffer overflow exploit](img/B04315_08_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Then, we generate our new shell code a `windows/meterpreter/reverse_nonx_tcp`
    and replace our calculator code with it. We choose this payload type because it
    is a very small Meterpreter, which means that since we know our memory footprint
    could be limited, we have a better chance of success with this exploit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These examples have additional bad characters listed in them. Out of habit,
    I usually leave these in when generating payloads. Keep in mind the more bad characters
    you have, the more the encoder has to add operations that do functionally equivalent
    manipulations. This means as you encode more, your payload usually gets bigger.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the command is as follows, and it only has a size of 204 bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing a basic buffer overflow exploit](img/B04315_08_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When placed in the exploit code, we get the following Python exploit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed, we get following results, which shows the exploit generating
    a shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing a basic buffer overflow exploit](img/B04315_08_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, this example is simple and it may provide a local exploit to the system,
    but there is an issue our exploit fails because it runs out of space. As mentioned
    previously, we have to adjust the area where we are placing our shell code.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding stack adjustments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We showed that the code execution failed in mid-exploit because our stage two
    clobbered our stage one code in memory. So, we need more stack space to complete
    this exploit. We can either split our code up in memory if necessary or we can
    simply expand the space in the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is done by telling the system to add space to the ESP. You can do this
    in one of two ways: by adding negative space or subtracting positive space. The
    reason for this is because the stack grows from high address to low addresses
    as we mentioned earlier.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding stack adjustments](img/B04315_08_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, we see that we are clobbering the shellcode with this exploit, so we can
    compensate instead by telling the ESP to move to accommodate the necessary space.
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding stack adjustments](img/B04315_08_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To do this, we need to add a hexadecimal adjustment to the front of the shellcode.
    We are going to do this in two different ways. The first way we will highlight
    in this section. We will then explain the second manner of doing it as we reverse
    Metasploit payloads. First we need to figure out how to adjust the actual stack;
    we can do this with the `nasm_shell.rb in the /usr/share/metasploit-framework/tools/nasm_shell.rb`.
  prefs: []
  type: TYPE_NORMAL
- en: Stack adjustment of 80,000 means we are adding this value to the ESP. To do
    that, we need to calculate the ESP adjustment for 80,000, but for that calculation
    we need to change 80,000 to a hexadecimal value. The hexadecimal equivalent is
    13880.
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding stack adjustments](img/B04315_08_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use the built in Windows calculator to change from decimal to hexadecimal
    in scientific mode and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: This means we add the following code to our exploit to adjust the stack `adjustment
    = struct.pack('<I',0x81EC80380100)`. We then prepend the shellcode with the adjustment
    value `exploit = fill + eip + offset + adjustment + shell`. Finally, we remove
    our NOP sled, since this is not filling space that our secondary stage will encompass,
    the final code would be similar to this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: There is a problem with this method though. If your stack adjustment has bad
    characters in it you would need to eliminate those by encoding it. Since you are
    not usually modifying your stack adjustment at a later point, you can make it
    part of your shell and encode the entire block of code. We will go through that
    process when we reverse a Metasploit module.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure to add a comment in your code about your stack adjustment; otherwise,
    when you try to expand this exploit or use other payloads you are going to be
    very frustrated.
  prefs: []
  type: TYPE_NORMAL
- en: As a side benefit, if we do this method instead of using NOP sleds, it is less
    likely that the exploit will be caught by HIPS. Now that we have done all that,
    realize there is an easier way to gain access using a standard payload.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you still need NOPs for a real exploit, make sure to use the NOP generators
    available to you through Metasploit. Instead of using "\x90" instructions, the
    code does meaningless mathematical operations. These take up space on the stack
    and provide the same capability.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the purpose of local exploits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It should be noted that the same access could be achieved by executing a payload
    on the system. Generating such a payload would only require us to run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, start up a Python web server with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure highlights the output of the relevant commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the purpose of local exploits](img/B04315_08_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Then, achieve the desired results by downloading and executing the payload through
    a browser on the victims system.
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the purpose of local exploits](img/B04315_08_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So you may be asking yourself, Why did we create this exploit then? If the software
    we just created this exploit for was running as an administrator instead of the
    user we were logged into, then exploiting this solution would be more useful.
    The nature of this program though this scenario is unlikely. As such, generating
    a Metasploit module for an exploit this would not be very useful. Consider instead,
    this exercise is a perfect opportunity to write your first exploit.
  prefs: []
  type: TYPE_NORMAL
- en: There is another consideration when writing exploits, is depending on the program
    your exploit may not be reliable. This means that due to the nuances of the code
    your exploits may or may not consistently work. So, you will have to do substantive
    testing in lab environments prior to execution in real organizations.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding other exploit scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to writing malicious files that can be uploaded into a program,
    you may have to generate code that interacts with services over a standalone program
    that accepts arguments, a TCP service, or even a UDP service. Consider the previous
    program we just exploited, if it was different in nature we could exploit it still,
    and just the way the scripts interacted with it would be different. The following
    three examples show what the code would look if it met any of those criteria.
    Of course, the memory addresses and sizes would have to be adjusted for other
    programs you may come across.
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting standalone binaries by executing scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can even create Python script to wrap around programs that have arguments
    passed to them. That way you can build exploits using wrapper scripts, which inject
    code, as shown following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This form of exploit is the rarest you will encounter as it typically would
    not grant you any additional rights. When creating exploits like these, it is
    usually to see what additional accesses you may be granted through a whitelisted
    program verses user level permissions. Keep in mind, this type of exploit is much
    tougher to write than malicious files, TCP, or UDP services. On the other side
    of the spectrum, the most common exploit that you will likely write is a TCP service
    exploit.
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting systems by TCP service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most often, you will come across services that can be exploited over TCP. This
    means, for analysis, you would have to setup a test box, which had Immunity or
    some other debugger and the service running. You would have to attach Immunity
    to that service and test your exploit as you have done previously.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Had the TFTP service highlighted in [Chapter 7](ch07.html "Chapter 7. Cracking
    the Perimeter with Python"), *Cracking the Perimeter with Python*, been vulnerable
    to potential buffer overflow attacks, we would have looked at creating an exploit
    for the UDP service.
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting systems by UDP service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generating Exploits for UDP Services is very much like a TCP service. The only
    difference is you are working with a different communication protocol.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have seen the basics of the most common types of exploits you may
    write, let us look at reversing a Metasploit module.
  prefs: []
  type: TYPE_NORMAL
- en: Reversing Metasploit modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many times you may find that a service is exploitable, but the Metasploit module
    is not built to exploit that service version or the specific OS version. This
    is not uncommon, just think back to writing the exploit earlier. Depending on
    what DLLs may have been referenced, the module may not be updated for a specific
    OS. Additionally, if newer version of an OS comes out and the program or service
    is still viable, you may need to expand the module.
  prefs: []
  type: TYPE_NORMAL
- en: Think back to [Chapter 5](ch05.html "Chapter 5. Exploiting Services with Python"),
    *Exploiting Services with Python*, and how we did research to find if a Kernel
    was vulnerable. Consider how doing similar research may result in references to
    potential buffer overflow vulnerabilities. You can either start from scratch,
    or you can reverse a Metasploit module into a standalone Python script and easily
    test for the expanded capabilities. You can then incorporate the changes into
    the Metasploit module, or even create your own.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to reverse the Metasploit module for the Sami FTP Server 2.0.1,
    conceptually verses actually. For brevity, we are not going to show the entire
    code of the exploit, but you can examine it in your installation of Metasploit
    here at `/usr/share/metasploit-framework/modules/exploits/windows/ftp`. Additional
    details about this module can be found here at [http://www.rapid7.com/db/modules/exploit/windows/ftp/sami_ftpd_list](http://www.rapid7.com/db/modules/exploit/windows/ftp/sami_ftpd_list).
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to do when reversing a Metasploit module is to setup the actual
    exploit. This will reveal the necessary parameters that would be need to be set
    to exploit the actual service. As you can see we need usernames, passwords, and
    the relevant payload.
  prefs: []
  type: TYPE_NORMAL
- en: '![Reversing Metasploit modules](img/B04315_08_42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we look at the actual payload; I find it easier to copy it into a code
    editor like Notepad++. This allows you to see what brackets and delineations would
    normally be needed. Unlike previous examples of writing exploits, we are going
    to start with the actual shellcode, because this is going to take the most effort.
    So, look at the payload section of the actual Metasploit module.
  prefs: []
  type: TYPE_NORMAL
- en: '![Reversing Metasploit modules](img/B04315_08_43.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, there is a stack adjustment of 3500 to accommodate the placement
    of shellcode more accurately. You can again calculate this with the same method
    highlighted above. In the newer Metasploit modules, instead of `PrependEncoder`
    you will see `StackAdjustment` with a plus or minus value. So, you, as a module
    developer do not have to actually calculate the hexadecimal code.
  prefs: []
  type: TYPE_NORMAL
- en: Stack adjustment of `-3500` means we are adding this value to the ESP. To do
    that, we need to calculate the ESP adjustment for `-3500`, but for that calculation
    we need to change -`3500` to a hexadecimal value. The hexadecimal equivalent is
    `-0xDAC`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Reversing Metasploit modules](img/B04315_08_44.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we take that adjustment data and print it into a hexadecimal file.
  prefs: []
  type: TYPE_NORMAL
- en: '![Reversing Metasploit modules](img/B04315_08_45.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you saw in the payload section of the module, there are known bad characters.
    When we generate our initial payload, we will incorporate those into the payload
    generation. Now, we generate the payload with those features.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![Reversing Metasploit modules](img/B04315_08_46.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We verify that the payload was generated with the `hexdump` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The figure below shows the output of that payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reversing Metasploit modules](img/B04315_08_47.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To combine the stack adjustment code and the actual payload, we can do the
    method highlighted in the following figure, which shows the simplicity of this
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reversing Metasploit modules](img/B04315_08_48.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After executing this, we verify the combination of the two components, and as
    you can see the adjustment hexadecimal code was placed at the front of the shellcode.
  prefs: []
  type: TYPE_NORMAL
- en: '![Reversing Metasploit modules](img/B04315_08_49.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, encode the data into a usable format for the script removing bad characters
    we know typically break exploits.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting output is the actual shellcode that would be used for this exploit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reversing Metasploit modules](img/B04315_08_50.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we can start crafting our exploit using all the features in the Metasploit
    module. We are going to use the target code to extract the `Offset` and `Ret`
    data. The `Ret` holds the return address for the EIP, and the `Offset` provides
    the data necessary to adjust the placement of the shellcode.
  prefs: []
  type: TYPE_NORMAL
- en: '![Reversing Metasploit modules](img/B04315_08_51.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Generating the return address component of our exploit is very straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting up the offset can be different per module, and you may need to do additional
    mathematical operations to get the right value. So, always look at the actual
    exploit code as highlighted, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reversing Metasploit modules](img/B04315_08_52.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We see the offset has the length of the IP address removed from the size. This
    creates an updated offset value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We can see that junk data is generated with random text. So, we can generate
    our NOPs in a similar manner.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Next, we need to create the order of operations to inject the exploit code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see this has all been very straight forward using the knowledge leveraged
    in the previous sections. The last component is to setup the handler to interact
    with the FTP service.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The end result is a Python exploit that can be tested and run against the actual
    server. This gives a great starting point for testing as well. If you find Metasploit
    modules do not work perfectly, reversing them to create a standalone gives you
    the opportunity to troubleshoot possible issues.
  prefs: []
  type: TYPE_NORMAL
- en: Remember exploits have a rating system with how reliable they are. If the exploit
    has a lower reliability rating, it means that it may not produce the desired results
    consistently. This gives you the opportunity to try and improve the actual Metasploit
    module and contribute back to the community. For example, this exploit has a Low
    rating; consider testing and trying to improve it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now, this specific exploit was developed for Windows XP SP 3\. You can now use
    this code to try and target different platforms. A standalone Python exploit means
    you have the necessary capabilities to expand the exploit. You can then add additional
    targets to the Metasploit module. This can be done by modifying the following
    section of a module.
  prefs: []
  type: TYPE_NORMAL
- en: '![Reversing Metasploit modules](img/B04315_08_53.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following would be how the code in the actual module could be updated with
    other relevant targets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: From this example, we have seen how to reverse a Metasploit module to create
    a standalone exploit, which can be used to expand target selection and improve
    reliability in future exploits.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you choose to create new Metasploit modules or updates with different capabilities
    and you do not want to break your current install, you can load custom modules
    into Metasploit. Those details are well documented in the following location [https://github.com/rapid7/metasploit-framework/wiki/Loading-External-Modules](https://github.com/rapid7/metasploit-framework/wiki/Loading-External-Modules).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding protection mechanisms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are entire books dedicated to some of the tools out there for administrators
    and developers, which will prevent many exploits. They include items such as **Data
    Execution Prevention** (**DEP**), which would stop code like ours from working
    if the code and OS were configured to take advantage of it. This is done by preventing
    execution of data on the stack. We can bypass DEP by simply overwriting the **Structured
    Exception Handling** (**SEH**) to run our own code instead.
  prefs: []
  type: TYPE_NORMAL
- en: Stack Canaries, which are basically mathematical constructs in the stack, check
    when the return pointer is called. If the value has changed then something has
    gone wrong and an exception is raised. If an attacker determines the value the
    guard is checking for, it can be injected into the shellcode to prevent an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, there is **Address Space Layer Randomization** (**ASLR**), which randomizes
    locations in memory we take advantage of. ASLR is much tougher to beat than the
    other two, but it basically defeated by building your exploit in memory with components
    of shared libraries that have to maintain consistent memory locations. Without
    these consistent shared libraries, the OS would be unable to execute basic process
    initially. This technique is known as **Return-Oriented Programming** (**ROP**)
    chaining.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we gave an overview of Windows memory structures and how we
    try to take advantage of poor coding practices. We then highlighted how to generate
    your own exploits using Python code using targeted testing and proof of concept
    code. This chapter then rounded out, how to reverse Metasploit modules to create
    standalone exploits that can be used to improve current modules capabilities or
    generate new exploits. In the next chapter, we will highlight how to automate
    reporting of details found during a penetration test and how to parse **eXtensible
    Markup Language** (**XML**).
  prefs: []
  type: TYPE_NORMAL
