- en: Category Theory That Applies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In kindergarten, we learned how to read time. In advanced math, we learned how
    to abstract a 12-hour clock and called it a monad.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/86296f8a-78f5-4e16-aabe-f0677b0aa00e.png)'
  prefs: []
  type: TYPE_IMG
- en: In elementary school, we learned geometry, logical reasoning, and functions.
  prefs: []
  type: TYPE_NORMAL
- en: In high school, we learned algebra, linear, and quadratic equations. We were
    so busy going through the motions deep in the minutiae of our problems that we
    could see no use for any of it.
  prefs: []
  type: TYPE_NORMAL
- en: Check out the learning material used in K-12 education here: [https://www.ixl.com/math/kindergarten/match-analog-clocks-and-times](https://www.ixl.com/math/kindergarten/match-analog-clocks-and-times).
  prefs: []
  type: TYPE_NORMAL
- en: Fast forward to our day job. To appear smart, we often ask, *Will it scale?* No
    matter what *it* is.
  prefs: []
  type: TYPE_NORMAL
- en: Wondering how reading time and horizontal scaling are related? They are, deeply.
    We'll find out how in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goal in this chapter is to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Gain a working understanding of the category theory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Appreciate the deep connection between category theory, logic, and type theory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand what binding, currying and application means in the context of a
    lambda expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the different categories of homomorphisms and how to use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn to use composition techniques from category theory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand what interface-driven development is about
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the value of knowledge driven systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply our understanding of category theory to build better apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our goal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By the end of this chapter, we will see value in those math classes we took
    back in school. We'll understand how the things we learned in our high school
    math classes can be applied when horizontally scaling our software solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram implies that **Category Theory**, functional programming,
    and logic are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af0d7bae-4b90-4710-889d-4c9219795ef4.png)'
  prefs: []
  type: TYPE_IMG
- en: Huh?
  prefs: []
  type: TYPE_NORMAL
- en: I thought Category Theory was about a sets of objects and the arrows that connect
    them and that *Proof Theory* was about using logic to prove something. And we
    all know that function programming is about software. How can all three things
    be related?
  prefs: []
  type: TYPE_NORMAL
- en: This seems about as useful as all those math classes we had to take in school,
    right?
  prefs: []
  type: TYPE_NORMAL
- en: Your pessimism is understandable. Please proceed with an open mind and remain
    seated. Mathematics, logic, and computation. They are just three different ways
    to approach solving the same problems.
  prefs: []
  type: TYPE_NORMAL
- en: How can Category Theory, Proof Theory, and functional programming be the same
    thing? (and why care?)
  prefs: []
  type: TYPE_NORMAL
- en: '"Scientists derive satisfaction from figuring out the puzzle. It''s about the
    quest, not the grail."'
  prefs: []
  type: TYPE_NORMAL
- en: -Isaac Asimov
  prefs: []
  type: TYPE_NORMAL
- en: Break it down
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s break each part down to get a firm grasp of the breadth of our problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9dada6bb-5c8a-4b7f-b0ef-ef890939c86f.png)'
  prefs: []
  type: TYPE_IMG
- en: If the **WHY** is the motivation for building your application, then the **HOW**
    describes how our application is better, and the **WHAT** is our end product/application.
  prefs: []
  type: TYPE_NORMAL
- en: The **HOW** relates to how we, as humans, reason. This is the realm of the Category
    Theory.
  prefs: []
  type: TYPE_NORMAL
- en: The **WHAT** pertains to the specifics of what it is. This is the realm of mathematics
    and computation. We will use algebra to help define the **WHAT**. Later, we'll
    see that our work in algebra is directly transferable to functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: Algebra and the unknown
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Algebra is a branch of mathematics that is very similar to arithmetic. It uses
    the four main operations that math uses: addition, subtraction, multiplication,
    and division (+, -, /, *). Algebra also introduces a new element: the unknown.
    In math, the unknown is on the right-hand side of the equation. Remember math
    problems like *2 + 3*. The answer is unknown until we perform the math operation
    on the operands (2 and 3). In algebra, we use symbols in place of the unknown
    placeholder. An algebraic equation would be *2 + 3 = x*. That is an algebraic
    equation that states both sides of the equals sign are equivalent. The operands 2
    and 3 operands are known and the *x* is the unknown.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/832a593d-233b-49aa-8b4b-ee260b887556.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The goal in algebra is to solve the equation by determining the value(s) of
    the unknown symbol(s):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7fc1bd2c-f58e-43ab-bd01-cc5dbaa57828.png)'
  prefs: []
  type: TYPE_IMG
- en: Remember what our math teachers would do next?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ab780b7e-3e27-4043-9a82-0c8e985c3bdf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'They would swap the symbol and a number to make the problem more difficult
    for us to figure out! Then, they would give us more and more complicated equations
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d52b32c-b8c4-428b-9dd9-f5f20cd4b934.png)'
  prefs: []
  type: TYPE_IMG
- en: 'They forced us to perform multiple steps to simplify our problem. Since both
    sides must remain equal, we can visualize the problem using a weight balance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/effb217a-e403-47d7-bd83-928d602a7c3c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'How did we solve the more complicated problem? Answer: By chopping it up into
    smaller pieces that are easier to work with, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d8cd9ab-ed00-46ca-8f9f-7b394b90c310.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Algebra, not unlike in the real world, relies on rules for things to work properly.
    Here are the few rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule 1:** The variable *x* in an algebraic equation cannot represent two
    different values in the same equation at the same time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, if we have the equation, *x + x = 6*, the following is true: 1
    + 5 = 6; However, since *x* cannot represent the two different values in the same
    equation, the only value that would work for *x* is 3 (using 1 and 5 for x would
    violate *Rule 1*).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule 2:** If we want two variables to represent two different values, we
    must use two different symbols. For example, *x + y = 6.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule 3:** When the same variable symbol is used multiple times in the same
    equation, it represents the same value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule 4:** The default operation is multiplication. 2 * x is the same as 2x.
    So, if there is no operator, we can assume we are dealing with the default operation,
    multiplication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule 5:** Parenthesis can be used to group terms. If we see 3(2), that is
    the same as 3 * (2) which is the same as 3*2\. All three groupings of terms are
    equal to 6 (not 32).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/83e4b940-d0b1-4bec-bc59-af5c0c5a5bc4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Our job now is to break this problem down into smaller steps and figure out
    what the value of *x* is. (Hint: you''ve seen it before.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule 6:** Different symbols can represent the same value in the same equation,
    but they don''t have to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we saw, *x* and *y* have the same value, but only in the second if statement.
    As the value of *x* varies (from 0 to 1 to 2), the value of y varies (from **2**
    to **1** to **0**). That's the main reason why the symbols *x* and *y* are called
    **variables**. They can vary.
  prefs: []
  type: TYPE_NORMAL
- en: The way variables are handled in a Turing-based language as opposed to a Lambda
    calculus (pure functional programming) language is very different.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a Turing-based language like C, the value of a variable *x* is stored in
    a specific location in the memory in the computer running the C program. It can
    be a global variable, which means other running procedures can access and change
    (aka *mutate*) its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/03ec9444-a409-4ed5-aeb5-28754a909503.png)'
  prefs: []
  type: TYPE_IMG
- en: In a pure functional language like Haskell, values are never stored. New ones
    can be created and passed along the execution chain.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world application of algebra
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ever wondered what good are these equations?
  prefs: []
  type: TYPE_NORMAL
- en: They can be useful when trying to model things in the real world. Let's take
    some algebraic equations and graph their solutions. Graphing an equation is like
    using the results of equations (output of functions) to draw lines and curves
    that can be used to illustrate and/or predict things in real life.
  prefs: []
  type: TYPE_NORMAL
- en: Linear equation and the law of demand
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Linear equations can be used to describe things with straight line slopes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5508511d-bf5e-466d-8bd9-415f0cd5db81.png)'
  prefs: []
  type: TYPE_IMG
- en: The law of demand states that as the price of a product increases, the demand
    for that product will decrease. That's because people naturally avoid buying a
    product that will force them to forfeit the purchase of something else that they
    value more. The graph indicates that the demand curve is a downward slope. The
    lower the price, the more products will be sold.
  prefs: []
  type: TYPE_NORMAL
- en: Building architects use linear equations to determine slopes of roof lines and
    Google Maps uses linear equations to tell you how long your trip will take.
  prefs: []
  type: TYPE_NORMAL
- en: What do we know about linear equation functions like *f(x) = 3x + 2*?
  prefs: []
  type: TYPE_NORMAL
- en: For every input *x*, we get one and only one result. That's why if we were to
    input every possible number (as the value *x*), we get a line! And that's why
    vertical lines are difficult to achieve in geometry.
  prefs: []
  type: TYPE_NORMAL
- en: Quadratic equations all around us
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Equations like the following are said to be linear:'
  prefs: []
  type: TYPE_NORMAL
- en: '*y = x + 2*'
  prefs: []
  type: TYPE_NORMAL
- en: This is because all the variables are to the power of one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the **x** values of -**4** to **2**, we can easily calculate the **y**
    values, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1fca5de4-c1d2-41c0-9cf3-2e27fa08b086.png)'
  prefs: []
  type: TYPE_IMG
- en: If we were to input every possible *x* value (including those with decimals
    like 0.1, 0.11, 0.12, and so on), we'd get a straight line. We can say that the
    *domain* is the set of all possible *x* values and the *range* is the set of all
    possible *y* values. Note that any non-vertical or non-horizontal line is a function
    with its domain and range consisting of all real numbers.
  prefs: []
  type: TYPE_NORMAL
- en: It's easy to see that our preceding *f(x)* function is just a mapping from one
    set of numbers to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we use exponents of 2 or greater, then the equation is said to be quadratic.
    Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '*y = x² + 1*'
  prefs: []
  type: TYPE_NORMAL
- en: Function composition with linear and quadratic functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s compose our *f(x) = x² + 1* quadratic equation with our *g(x) = x +
    2* linear equation table. Here''s one way we could compose our two functions:
    *y = f(g(x))*. We''d say *y* equals *f-compose-g of x* or *y = f o g* where o
    is our composition operator. The way it works is that we assign a value for *x*,
    then we plug that value into *g*, compute g(x), and then plug the result into *f*.'
  prefs: []
  type: TYPE_NORMAL
- en: We input **1** to **g** and to express that as **g(1)**. We input **g(1)** to
    **f** to get **f(g(1))**.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00f1ce17-a629-47a5-a085-4bc46f044c95.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s make it work by replacing **g(1)** with the value that maps from **1**
    to **g(1)**, which is **3**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a84f18c7-5685-4f50-8cee-720ba4604019.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Replacing **g(1)** with **3**, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c096205-a9a5-43b9-afdf-37f1daa1a590.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When we input **3** to **g**, we evaluate the **x² + 1** or **3² + 1** expression, which
    equals **10**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be540442-e169-48c7-b312-7bca9d8d5953.png)'
  prefs: []
  type: TYPE_IMG
- en: So, **f(g(1))** equals **10**.
  prefs: []
  type: TYPE_NORMAL
- en: What if we reverse our nesting of functions like **g(f(1))**? Will we get the
    same answer?
  prefs: []
  type: TYPE_NORMAL
- en: '*f(1) = x2 + 1 = 1 + 1 = 2*'
  prefs: []
  type: TYPE_NORMAL
- en: '*g(2) = 4*'
  prefs: []
  type: TYPE_NORMAL
- en: We got *f(2)=4* from the preceding linear equation table.
  prefs: []
  type: TYPE_NORMAL
- en: Since *g(f(1)) = 10* and *f(g(1)) = 4*, we know that composing the same functions
    in a different order will likely give different results.
  prefs: []
  type: TYPE_NORMAL
- en: We also see that when we compose, we are either replacing a function/value with
    the corresponding/mapped value from a table or we are evaluating a function expression
    and replacing with that value. We've already seen how the referential integrity
    characteristic of our functions allow us to cache its value. So, after a function
    is evaluated the first time, all we're doing is a bunch of value replacements
    when we compose functions.
  prefs: []
  type: TYPE_NORMAL
- en: '"If A equals success, then the formula is A equals X plus Y and Z, with X being
    work, Y play, and Z keeping your mouth shut."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Albert Einstein'
  prefs: []
  type: TYPE_NORMAL
- en: More examples of quadratic equations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Are all of the following quadratic?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66fbf895-5ff8-41a3-b18a-1d83b930306f.png)'
  prefs: []
  type: TYPE_IMG
- en: Plot your own equations online at: [https://www.desmos.com/calculator](https://www.desmos.com/calculator)
  prefs: []
  type: TYPE_NORMAL
- en: The golden ratio
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let's look at one more fascinating quadratic equation. The Greeks believed that
    the rectangular shape, which had the most aesthetic proportions, was one where
    the large and the small rectangles have the same proportions.
  prefs: []
  type: TYPE_NORMAL
- en: This became known as the *golden rectangle*. The solution to *x² + x = 1* is
    *x = 1.61803398875*, which we'll shorten to *x = 1.61.*
  prefs: []
  type: TYPE_NORMAL
- en: The Greeks weren't the only ones that thought the golden ratio was perfect.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9298c91f-2a10-4957-9b8b-ecf7446368d5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When we look closely, we''ll see the Golden Ratio in business:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/451ac9b7-560d-4ad7-90c0-5b7e4e9f2a1f.png)'
  prefs: []
  type: TYPE_IMG
- en: Remember the Fibonacci sequence and its relationship to recursion from [Chapter
    1](../Text/Ch01.xhtml), *Pure Functional Programming in Go*? `0, 1, 1, 2, 3, 5,
    8, 13, 21, 34, 55, 89`. In this sequence, each term is the sum of the previous
    two terms. If we look closely, we'll see this sequence in nature. For example,
    lilies have 3 petals, buttercups 5, marigolds 13, asters 21\. Most daisies have
    34, 55 or 89 petals.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/391e2289-10cb-4ff3-8f73-fb0f05fdda2f.png)'
  prefs: []
  type: TYPE_IMG
- en: The seeds of a sunflower head radiate from its center in two families of interlaced
    spirals, one winding clockwise and the other counterclockwise. There are usually
    34 spirals twisting clockwise and 55 in the opposite direction.
  prefs: []
  type: TYPE_NORMAL
- en: The more we learn about the relationship between mathematics, programming, the
    arts and sciences and nature, the more evidence we find of the hand of a master
    architect at work around us.
  prefs: []
  type: TYPE_NORMAL
- en: The more we understand how systems around us work, the more patterns we see.
    Later, when we look closer at the category theory, we'll study the important patterns
    of decomposition (chopping problems up into small, comprehensible pieces) and
    composition (putting those pieces back together again). FP allows us to break
    a monolithic application down into a set of Lego building blocks that can be assembled
    in different configurations for different systems if desired, and we do can do
    so in an easy-to-understand, declarative manner.
  prefs: []
  type: TYPE_NORMAL
- en: Given the guarantees of immutability and referential transparency, the time
    at which an operation occurs is much less of a concern. This simplifies the combinatorial
    complexity of coding concurrent solutions. This also allows performance to be
    improved harmlessly by the use of parallelism, and it pays off in distributed
    systems, where time is not even perfectly defined.
  prefs: []
  type: TYPE_NORMAL
- en: Basic laws of algebra
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Study these basic laws of algebra. We'll see them again soon!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/03501ee4-0d7b-44ab-bd08-e79ffdc1527c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Later, you''ll learn that function composition has the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: It is associative
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is typically not commutative
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is distributive via *(g+h) ∘ f = g ∘ f+h ∘ f (g + h) ∘ f = g ∘ f + h ∘ f*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is typically not distributive via *f ∘ (g + h) = f ∘ g + f ∘ h*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Correspondence in mathematics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The category theory presents mathematics as abstractly as possible and removes
    all nonessential properties, providing a framework for all mathematics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember your math classes? Here are a few of the classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Branch of mathematics | Description |'
  prefs: []
  type: TYPE_TB
- en: '| Algebra | Algebra describes relationships between its elements using laws,
    for example, associative, commutative properties. There are different types of
    algebra, such as, linear, lie, commutative, and abstract. In algebra, we often
    replace numbers with letters in an equation. For example,The *1 + 2 = 3* form
    becomes *x + y = z*. Boolean algebra is another type of algebra in which the variables
    are truth values (true and false) instead of numbers. |'
  prefs: []
  type: TYPE_TB
- en: '| Geometry | Geometry studies the properties of shapes and position in space.
    It provides formulas for determining things such as the circumference of a circle
    (*c = 2πr*) and determining the area of various shapes. |'
  prefs: []
  type: TYPE_TB
- en: '| Logic | Logic provides rules of mathematical reasoning. Boolean algebra is
    a form of mathematical logic. |'
  prefs: []
  type: TYPE_TB
- en: '| Numerical analysis | Numerical analysis provides algorithms to approximate
    solutions to mathematical problems. It typically uses computing power to quickly
    get close to the true solution that might not be solvable manually. |'
  prefs: []
  type: TYPE_TB
- en: '| Calculus | Calculus is the application of the results proven in analysis.
    |'
  prefs: []
  type: TYPE_TB
- en: 'Mathematics is the study of data structures: shapes, numbers, groups, sets,
    and so on. We study their structure, their behaviors, and how they interact with
    each other.'
  prefs: []
  type: TYPE_NORMAL
- en: Curry, Howard, and Lambek discovered that all branches of mathematics are the
    exact same thing! They realized that at a certain level of abstraction, the structure
    of all mathematical theories are the same. We can morph the structure of our logic
    into category classes and we can change that structure into type theory. All morphisms,
    and hence all activities, in the universe can be described by the category theory.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when we consider a photon particle in an electromagnetic field,
    a soccer ball in flight, and a bouncy C (musical note), they don't seem to have
    much in common until we provide context. From the point of view of wave theory,
    they are all the same problem. Now, change or context to centripetal force; again,
    they are all the same problem, only in a different context. When we abstract away
    all the non-essential details, what remains is the mathematical structure.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of using abstraction in this way is that we begin to see connections
    between things that were previously hidden from view. When can create and use
    tools that allow us to contextualize problem sets in different ways. We have the
    full power of category theory to enlighten our way. Software engineers who understand
    these concepts are better equipped to perform data analytics. Software engineers
    who learn to apply functional programming concepts build more reliable solutions
    that scale horizontally across multiple cores and across multiple compute instances
    in their cloud native clusters. It's not difficult to see what all the fuss regarding
    functional programming is about, right?
  prefs: []
  type: TYPE_NORMAL
- en: Proof theory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Proof theory is a branch of mathematics where we make assumptions and apply
    logic to prove something. For example, if a and b can be proven to be true, then
    a is true and so is b.
  prefs: []
  type: TYPE_NORMAL
- en: Logical connectives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following table depicts logical connectives, in order of precedence:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Math name** | **English name** | **Go operator** | **Example**
    | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| ¬   | Negation | NOT | ! | ¬a | not a |'
  prefs: []
  type: TYPE_TB
- en: '| ∧ | Conjunction | AND | && | a ∧ b | a and b |'
  prefs: []
  type: TYPE_TB
- en: '| ⊕ | Exclusive disjunction | exclusive or (XOR) | NA | a ⊕ b | either a or
    b (but not both) |'
  prefs: []
  type: TYPE_TB
- en: '| ∨ | Disjunction | OR | &#124;&#124; | a ∨ b | a or b |'
  prefs: []
  type: TYPE_TB
- en: '| ∀ | Universal quantification | ∀ x: A(x) means A(x) is true for all x | NA
    | ∀a:A | all values a of type A |'
  prefs: []
  type: TYPE_TB
- en: '| ∃ | Existential quantification | ∃ x: A(x) means there is at least one x
    such that A(x) is true | NA | ∃a:A | there exists some value a of type A |'
  prefs: []
  type: TYPE_TB
- en: '| ⇒ | Material implication | Implies | NA | a ⇒ b | if a then b |'
  prefs: []
  type: TYPE_TB
- en: '| ⇔ | Material equivalence | a ⇔ b is true only if both a and b are false,
    or both a and b are true | NA | a ⇔ b | a if and only if b |'
  prefs: []
  type: TYPE_TB
- en: '| **≡** | Is defined as | a ≡ b means a is defined to be another name for b
    | NA | a ≡ b | a is logically equivalent to b |'
  prefs: []
  type: TYPE_TB
- en: '| ⊢ | Turnstile | a ⊢ b means a is provable from b | NA | a ⊢ b | a is provable
    from b |'
  prefs: []
  type: TYPE_TB
- en: NA = Not Applicable, that is, there is no symbol for this in Go.
  prefs: []
  type: TYPE_NORMAL
- en: There are other logic symbols, but these are some of the more important ones.
  prefs: []
  type: TYPE_NORMAL
- en: In software, we use logic by combining these symbols and other terms like variables
    to prove whether something is true.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example using quantification symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '`f: A ⇒ B` means `∀a:A∃b:B` such that `b = f(b)`'
  prefs: []
  type: TYPE_NORMAL
- en: In other words, there is a function from *A* to *B,* where for all values a
    of type *A,* there exists some value b of type *B* such that *b = f(a)*.
  prefs: []
  type: TYPE_NORMAL
- en: Logical inconsistency
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following function signature represents a function with logical inconsistency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The problem is that factorial is not defined for negative integers.
  prefs: []
  type: TYPE_NORMAL
- en: Partial function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If our function is not defined/consistent for all values in our domain, it's
    said to be a partial function (as opposed to a total function). If our function
    is inconsistent, then we run the risk of running into unexpected errors during
    runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main ways to solve this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: We can solve this inconsistency by reducing the size of our domain to only positive
    integers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use failure monads like either validation or disjunction to capture things
    that go wrong
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Truth table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The truth tables contains interpretations of a proposition. An interpretation
    is the calculation of the value of a proposition:'
  prefs: []
  type: TYPE_NORMAL
- en: '| a | b | ¬a | ¬b | a ∧ b | a ∨ b | a ⊕ b | a → b | a ↔ b |'
  prefs: []
  type: TYPE_TB
- en: '| T | T | F | F | T | T | F | T | T |'
  prefs: []
  type: TYPE_TB
- en: '| T | F | F | T | F | T | T | F | F |'
  prefs: []
  type: TYPE_TB
- en: '| F | T | T | F | F | T | F | T | F |'
  prefs: []
  type: TYPE_TB
- en: '| F | F | T | T | F | F | F | T | T |'
  prefs: []
  type: TYPE_TB
- en: '"The opposite of a correct statement is a false statement. The opposite of
    a profound truth may well be another profound truth."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Niels Bohr'
  prefs: []
  type: TYPE_NORMAL
- en: Conditional propositions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following propositions say the same thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '*If a, then b*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*a implies b*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*a → b*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*a ⇒ b*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The variable *a* is the hypothesis and *b* is the conclusion. The conclusion
    is always true, except when *a* is true and *b* is false. One way of thinking
    about this is: "If pigs could fly, then…" anything you conclude is true after
    such an obviously false statement. If *a* and *b* are both true, then obviously
    going from a to b will be true. However, if *a* is true and *b* is false, then
    when going from *a* to *b* we''ll end up with a false value.'
  prefs: []
  type: TYPE_NORMAL
- en: Logical equivalence
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now, we can use our truth table to determine the outcome of compound propositions.
    Since *¬a ∨ b* and *a → b* have the same truth values, they are said to be logically
    equivalent and we express that with the *¬a ∨ b ≡ a → b* equation.
  prefs: []
  type: TYPE_NORMAL
- en: '| a | b | ¬a | ¬a ∨ b | a → b |'
  prefs: []
  type: TYPE_TB
- en: '| T | T | F | T | T |'
  prefs: []
  type: TYPE_TB
- en: '| T | F | F | F | F |'
  prefs: []
  type: TYPE_TB
- en: '| F | T | T | T | T |'
  prefs: []
  type: TYPE_TB
- en: '| F | F | T | T | T |'
  prefs: []
  type: TYPE_TB
- en: A logically equivalent statement could be, "*If Jenny were sitting at her desk
    then she'd be at home*." That is a logical statement. A logical equivalent statement
    might be, "*If Jenny were not at home, then she would not be sitting at her desk*."
  prefs: []
  type: TYPE_NORMAL
- en: 'We create logical equivalences by creating a hypothesis and its conclusion.
    The preceding hypothesis is: "*If Jenny were sitting at her desk*, and the conclusion
    is "*she''d be at home*." We determine the truth of each and compare their truth
    (true or false).'
  prefs: []
  type: TYPE_NORMAL
- en: Converse of a conditional proposition
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s use a truth table to prove the `(a → b)∧(b → a) ≡ a ↔ b` equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '| a | b | a → b | b → a | (a → b)∧(b → a) | a ↔ b |'
  prefs: []
  type: TYPE_TB
- en: '| T | T | T | T | T | T |'
  prefs: []
  type: TYPE_TB
- en: '| T | F | F | T | F | F |'
  prefs: []
  type: TYPE_TB
- en: '| F | T | T | T | F | F |'
  prefs: []
  type: TYPE_TB
- en: '| F | F | T | T | T | T |'
  prefs: []
  type: TYPE_TB
- en: In other words, a biconditional proposition *(a ↔ b)* is equivalent to the conjunction
    of a conditional proposition *(a → b)* and its converse *(b → a)*.
  prefs: []
  type: TYPE_NORMAL
- en: Order matters
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Remember the statement: "*If Jenny were sitting at her desk, then she''d be
    at home?"*'
  prefs: []
  type: TYPE_NORMAL
- en: Its converse would be, "*If Jenny were at home then she'd be sitting at her
    desk*." The converse is created by swapping the hypothesis and conclusion. How
    does the converse change the logic of the sentence? (*Could "Jenny be at home,
    but not at her desk?"*) The same words in a different order can change the resulting
    truth value.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the inverse of a conditional can also change the logic. For example,
    consider the negative form of "*If Jenny were sitting at her desk, then she'd
    be at home,*" which is "*If Jenny were not sitting at her desk, then she would
    not be at home*." (Could Jenny be at home, but not at her desk?)
  prefs: []
  type: TYPE_NORMAL
- en: See how we can use truth tables to combine statements and determine its resulting
    truth value?
  prefs: []
  type: TYPE_NORMAL
- en: The Curry Howard isomorphism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Curry Howard Isomorphism said that types are propositions and programs are
    their proofs. A proposition is an assertion (declarative statement), which is
    either true or false (but not both).
  prefs: []
  type: TYPE_NORMAL
- en: Examples of propositions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the following examples of propositions:'
  prefs: []
  type: TYPE_NORMAL
- en: The equation 2 * 3 = 5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If it is storming outside, then I take an Uber to class; otherwise, I walk,
    and if it is sunny, then I ride my bicycle:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Variable** | **Clause** |'
  prefs: []
  type: TYPE_TB
- en: '| a | *It is storming outside* |'
  prefs: []
  type: TYPE_TB
- en: '| b | *I take an Uber to class* |'
  prefs: []
  type: TYPE_TB
- en: '| c | *I walk* |'
  prefs: []
  type: TYPE_TB
- en: '| d | *It is sunny* |'
  prefs: []
  type: TYPE_TB
- en: '| e | *I ride my bicycle* |'
  prefs: []
  type: TYPE_TB
- en: 'The following is the **written logic version**:'
  prefs: []
  type: TYPE_NORMAL
- en: '*a implies b and ((not a) implies (c and (d implies e)))*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the **logical symbols version**:'
  prefs: []
  type: TYPE_NORMAL
- en: '*(a ⇒ b) ∧ (¬a ⇒  (c ∧ (d⇒  e)))*'
  prefs: []
  type: TYPE_NORMAL
- en: Not propositions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following are the examples of not propositions:'
  prefs: []
  type: TYPE_NORMAL
- en: '*x = 5*  (this is not an assertion of truth, it''s an assignment)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*x + y = 5* (not enough information to be an assertion, answer depends on missing
    data)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Propositions can combine terms using connectives (and, or not).
  prefs: []
  type: TYPE_NORMAL
- en: Lambda calculus
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Alonzo Church brought formal logic, called **untyped Lambda calculus**, to computer
    science that includes substitution, abstraction, and application. Let's remember
    these terms and use them when implementing a lambda expression in Go later in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Why so formal?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Why do we care about adhering to the formalism and rules of logical (and algebraic)
    equations?
  prefs: []
  type: TYPE_NORMAL
- en: '"The irony is that the constraints of formalism is what liberates us to be
    our best."'
  prefs: []
  type: TYPE_NORMAL
- en: The importance of protocol
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Respecting your elders, saying "Yes, Ma''am" and "Yes Sir" is not just social
    formalism. That''s called *following protocol*. It helps us communicate in a consistent
    way. Following formalisms helps us to act appropriately. Examples of practicing
    the civil virtues include things like these:'
  prefs: []
  type: TYPE_NORMAL
- en: Being honest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintaining self-control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing kindness toward fellow human beings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we lead through an example of serving one another with transparency and
    kindness and to guard against greed and other forms of evil, we can freely engage
    with others in ways that are less likely to offend.
  prefs: []
  type: TYPE_NORMAL
- en: How does offensive language and inappropriate behavior from our leaders affect
    the strength of our society? What good comes from showing blatant disrespect toward
    officers of the law?
  prefs: []
  type: TYPE_NORMAL
- en: When everyone understands the importance of being polite and showing guarded
    generosity, we live in a strong social system in which we all have the opportunity
    to thrive. When we transfer this concept to our software development efforts,
    we end up with better solutions. The way we implement this system is through logic.
    If our systems are logically sound, then they will reliably help us achieve our
    goals.
  prefs: []
  type: TYPE_NORMAL
- en: Historical Events in Functional Programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The history of functional programming is nothing short of fascinating. Functional
    programming languages are based on an elegant yet simple mathematical foundation,
    Lambda calculus.
  prefs: []
  type: TYPE_NORMAL
- en: '"To understand a science, it is necessary to know its history."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Auguste Comte'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the discoveries that led up to Lambda calculus.
  prefs: []
  type: TYPE_NORMAL
- en: George Boole (1815 - 1864)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](img/2333ad17-4599-42b4-98d5-e0a0a31491d3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Logic came from ancient Greeks such as Aristotle and Euclid. Prior to Boole,
    logic was literally in Greek; it was expressed in the form of language. Boole
    was the first to translate logic into algebraic symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '*true = 1*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*false = 0*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*and = product (AxB)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*or = sum(A+B)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Augustus De Morgan (1806 - 1871)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](img/9b96a9e7-638f-4643-85a9-d800899098a9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'De Morgan''s Law stated that all logical operations can be expressed in terms
    of *and*, *or*, and *not.* Furthermore, all logical operations can also be expressed
    in terms of just *and* and *not*, or just *or* and *not*:'
  prefs: []
  type: TYPE_NORMAL
- en: '*a ∧ b = ¬ ( (¬ a) ∨ (¬ b) )*'
  prefs: []
  type: TYPE_NORMAL
- en: '*a ∨ b = ¬ ( (¬ a) ∧ (¬ b) )*'
  prefs: []
  type: TYPE_NORMAL
- en: The first equation says that *a* and *b* are both true if and only if at least
    one of *a* or *b* is false. The second equation says that at least one of *a*
    or *b* is true if and only if both a and b are false.
  prefs: []
  type: TYPE_NORMAL
- en: Friedrich Ludwig Gottlob Frege (1848 – 1925)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](img/e1582856-86da-4e72-b140-2ba4569797c8.png)'
  prefs: []
  type: TYPE_IMG
- en: Frege was a German mathematician who is considered by many as the father of
    analytic philosophy. He studied the use of functions in logic and was the first
    to use currying. Frege invented axiomatic predicate logic. Axioms are statements/propositions
    that we accept as true; they are so self-evident that no other reasoning could
    make it plainer. They are simple truths.
  prefs: []
  type: TYPE_NORMAL
- en: Modus Ponens
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following rule of propositional logic is called **Modus Ponens**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b284fb3-3e24-4fc5-b0f4-6cc51ee30d97.png)'
  prefs: []
  type: TYPE_IMG
- en: If the tree is still on the power line, then we have no power
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The tree is still on the power line
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have no power
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Charles Lutwidge Dodgson (1832 –1898)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](img/eded66d3-a4a0-4322-a6a9-eb0ff12189ad.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Charles Dodson (pen name: Lewis Carroll) authored several books in which he
    stripped away intuition and any preconception by manipulating logic, even if it
    seems like nonsense. Let''s look at the literary nonsense in his fiction book,
    *Alice in Wonderland*. Dodson often defied common sense by creating an entirely
    new world through the manipulation of language. The story maintained a balance
    between sense and nonsense, remaining logical, even though it appeared at times
    to be completely illogical. For example, as Alice moves within the back-to-front
    world of *Looking-Glass Land*, she discovers a book written in a seemingly unintelligible
    language:'
  prefs: []
  type: TYPE_NORMAL
- en: Twas brillig, and the slithy toves
  prefs: []
  type: TYPE_NORMAL
- en: Did gyre and gimble in the wabe:All mimsy were the borogoves,
  prefs: []
  type: TYPE_NORMAL
- en: And the mome raths outgrabe.
  prefs: []
  type: TYPE_NORMAL
- en: '"Beware the Jabberwock, my son!'
  prefs: []
  type: TYPE_NORMAL
- en: The jaws that bite, the claws that catch!Beware the Jubjub bird, and shun
  prefs: []
  type: TYPE_NORMAL
- en: The frumious Bandersnatch!"
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Through The Looking Glass*, Alice tries to keep up with the Red Queen;
    though constantly running, she remains in the same spot. Alice remarked:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Well, in our country*, said Alice, still panting a little, *you''d generally
    get to somewhere else—if you run very fast for a long time, as we''ve been doing.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Red Queen''s race is often used to illustrate deep concepts such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: Time travel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The relativistic effect on light from galaxies near the edge of the expanding
    observable universe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our efforts in the IT industry to adopt new technologies in an effort to keep
    up with our competitors (though years later, when looking back, we realize we
    did not actually improve our systems, we merely changed technologies sometimes
    to our detriment)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll later look at an FP library named **Fantasy Land**, which likely gets
    its name from the nonsense logic found in works such as Alice in Wonderland.
  prefs: []
  type: TYPE_NORMAL
- en: Alfred Whitehead and Bertrand Russell (1903)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](img/6a0ab236-9d97-4826-85bb-1168a5f6c5bb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In a letter Russell wrote to Frege, the proposed the *Barbers Paradox* found
    a problem with Frege''s logic:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given that a town''s only barber shaves everybody, except those who shave themselves.
    We can deduce two things:'
  prefs: []
  type: TYPE_NORMAL
- en: If a person does not shave her/himself, the barber will
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If person shaves her/himself, the barber won't
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The paradox is: *The barber cannot be shaven*.'
  prefs: []
  type: TYPE_NORMAL
- en: The first statement says that if the barber does not shave himself, then barber
    will shave himself. However, the second statement directly contradicts that first
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: Russell and Whitehead collaborated to prove/solve the Barber's Paradox and to
    prove that mathematics is a formal, logical framework. In 1912, they arrogantly
    produced a work entitled Principia Mathematica (that's the same name that Isaac
    Newton used to name his works that included the laws of motion, forming the foundation
    of classical mechanics, the law of universal gravitation, and a derivation of
    Kepler's laws of planetary motion).
  prefs: []
  type: TYPE_NORMAL
- en: Russell and Whitehead's work proved to be impractical (it includes a 450-page
    proof to show that *1 + 1 = 2*). The irony is that logical substitution was not
    formalized in their Principa Mathematica. (We'll look at what logical substitution
    means when we look at Lambda calculus.)
  prefs: []
  type: TYPE_NORMAL
- en: Moses Schonfinkel (1889–1942)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](img/0988b518-2c41-480b-979a-458cc54021a0.png)'
  prefs: []
  type: TYPE_IMG
- en: Schonfinkel was a Russian mathematician who invented combinatory logic around
    1924\. A combinator is a higher order function that uses only function application
    and earlier defined combinators to define a result from its arguments. This replacement
    technique reduced multiple function arguments to a single argument, and was later
    known as currying, after Haskell Curry.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table explains Schonfinkel combinators:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Definition** | **Acroymn - German** | **Function Type** |'
  prefs: []
  type: TYPE_TB
- en: '| λx. x | I - Identitatsfunktion | Identity |'
  prefs: []
  type: TYPE_TB
- en: '| λx,y. x | K - Konstanzfunktion | Constant |'
  prefs: []
  type: TYPE_TB
- en: '| λx,y,z. xz(yz) | S - Verschmelzungsfunktion | Amalgamation |'
  prefs: []
  type: TYPE_TB
- en: '| λx,y,z. xzy | T - Vertauschungsfunktion | Exchange |'
  prefs: []
  type: TYPE_TB
- en: '| λx,y,z. x(yz) | Z - Zusammensetzungsfunktion | Composition |'
  prefs: []
  type: TYPE_TB
- en: Haskell Curry - 1927
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](img/4d9ef818-a309-47a1-9273-b3b71a36ac30.png)'
  prefs: []
  type: TYPE_IMG
- en: Haskell Curry introduced Combinatory Logic in 1927 that eliminated the use of
    variables that change. It is based on combinators. A combinator is a higher order
    function that uses function application and previously defined combinators to
    produce a result from its arguments. Alonzo Church later devised a similar formalism
    called **The** **Lambda Calculus**, where lambda expressions represent functional
    abstractions are replaced by a limited set of combinators. For details, see *The
    Lambda Calculus* section later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Gerhard Gentzen (1936)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](img/59c2b39d-8398-497c-a4b0-dfdd513b4b1b.png)'
  prefs: []
  type: TYPE_IMG
- en: In 1936, a German mathematician named Gerhard Gentzen provided proof that first-order
    arithmetic (addition and multiplication) is consistent using primitive recursive
    arithmetic. Gentzen used sequent calculus, which is a conditional tautology (a
    series of true statements) to build arguments according to rules and procedures
    of inference ([https://en.wikipedia.org/wiki/Inference](https://en.wikipedia.org/wiki/Inference))
    with zero or more assertions. Note that sequent calculus is very similar to natural
    deduction, which is composed of one or more assertions.
  prefs: []
  type: TYPE_NORMAL
- en: Alonzo Church (1930, 1940)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](img/4b97339d-31a7-4eee-8bc2-0bb76d083a8d.png)'
  prefs: []
  type: TYPE_IMG
- en: Church read the Principa Mathematica and decided to improve upon it. Church
    applied formal mathematical logic to computer science using function abstraction
    and application using variable binding and substitution. In 1930, Church's released
    the first version of Lambda calculus, which formed the basis of what he called
    *effectively computable functions*.
  prefs: []
  type: TYPE_NORMAL
- en: In 1935, Kleene and Rosser proved that it was logically inconsistent. Church
    quickly responded with an improved version named *simply typed Lambda calculus*
    that fixed the issue of non-terminating programs with a typed system that defined
    the syntax of high order logic, but did not include recursive functions. Later,
    in 1940, Church invented The Lambda Calculus, which is composed only of functions,
    which does not concern itself with concrete values like strings and numbers. It
    works with only functions.
  prefs: []
  type: TYPE_NORMAL
- en: Functions can take functions and return functions. Haskell Curry intended Lambda
    calculus to be a foundation for mathematics. You need some form of recursive type
    to write any interesting kind of program in it. Haskell Curry's work with combinatory
    logic is a foundation of the functional programming language.
  prefs: []
  type: TYPE_NORMAL
- en: Alan Turing (1950)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](img/370f7a7f-06f9-4ae6-bb8f-9e8ee7a27690.png)'
  prefs: []
  type: TYPE_IMG
- en: At about the same time as Alonzo Church published his Lambda calculus, Alan
    Turing introduced the Turing machine, which could perform any computational task,
    that is, anything Lambda calculus could calculate. Turing completeness is an abstract
    statement of ability, rather than a prescription of specific language features
    used to implement that ability. The features used to achieve Turing completeness
    can be quite different; Fortran systems would use loop constructs or possibly
    even `goto` statements to achieve repetition. Pure functional languages like Haskell
    and Prolog use recursion.
  prefs: []
  type: TYPE_NORMAL
- en: MacLane and Eilenberg (1945)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](img/99d11550-5d85-4c95-b79d-14ca2aaa0c21.png)'
  prefs: []
  type: TYPE_IMG
- en: Saunders Mac Lane (left) and Samuel Eilenberg (right) introduced the concepts
    of categories, functors, and natural transformations in 1945 with their paper
    titled, *A general theory of natural equivalences*. In their study of algebraic
    topology, they gave explicit definitions for objects, maps, and composition of
    maps, with the goal of understanding the processes that preserve mathematical
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: John McCarthy (1950)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](img/12a0816c-2e09-42bf-9e0f-6751948d82db.png)'
  prefs: []
  type: TYPE_IMG
- en: Next came John McCarthy who published the paper *Recursive functions of symbolic
    expressions and their computation by machine, Part I* ([http://dl.acm.org/citation.cfm?id=367199](http://dl.acm.org/citation.cfm?id=367199)).
    In 1958, one of his students wrote an interpreter based on McCarthy's teachings,
    which became a programming language based on pure mathematics called Lisp. Lisp
    was the first functional language. The first popular computer languages based
    on type systems were Fortran and Cobol, which emerged in the 1950s.
  prefs: []
  type: TYPE_NORMAL
- en: Curry-Howard-Lambek Correspondence (1969)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](img/27c1437c-4e2a-484b-8124-71cd25d2a12f.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Curry, Howard, and Lambek** (**CHL**) discovered the one-to-one correspondence
    between objects in category theory, propositions in logic, and types in programming
    languages.'
  prefs: []
  type: TYPE_NORMAL
- en: CHL looked at the types of rules for natural deduction rules and typed Lambda
    calculus and discovered that they are identical.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8cd2fd21-a53f-4208-95b8-40e18110d956.png)'
  prefs: []
  type: TYPE_IMG
- en: If we remove the red terms in the preceding table, they are identical. Hence,
    Church's lambda types correspond one-to-one with Gentzen's logical formulas. Type
    checking is the same as proof checking.
  prefs: []
  type: TYPE_NORMAL
- en: Logic includes **and**, **or** and **implication** constructs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming has data records and function constructs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Category theory has arrows which are functions (that can also be data)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As an example of how they relate, consider that a proposition in logic can be
    true or false. Similarly, a type can be either inhabited or not. True propositions
    are inhabited. The void type is false. If we can produce an element of a type,
    then we have proven our proposition.
  prefs: []
  type: TYPE_NORMAL
- en: CHL realized that Cartesian closed categories, intuitionistic propositional
    logic, and the simply typed Lambda calculus are all essentially the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the correspondence table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Category theory** | **Logic theory** | **Type theory/Lambda calculus**
    |'
  prefs: []
  type: TYPE_TB
- en: '| Objects | Propositions | Types |'
  prefs: []
  type: TYPE_TB
- en: '| Morphisms | Proofs | Functions |'
  prefs: []
  type: TYPE_TB
- en: '| Equivalences between morphisms  | Equivalences between proofs | Beta-eta
    equivalences between Lambda calculus term |'
  prefs: []
  type: TYPE_TB
- en: All three areas of study arrived at the same discoveries independently, from
    different perspectives, but the mathematical structures they describe in each
    case are essentially identical.
  prefs: []
  type: TYPE_NORMAL
- en: Roger Godement (1958)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](img/52ea5534-e8b2-4367-a8fa-e5231c030e91.png)'
  prefs: []
  type: TYPE_IMG
- en: In 1958, Roger Godement wrote a book on the sheaf theory that first introduced
    the concept of monads. Sheaves are objects that capture local data about a manifold,
    yet in doing so, allows one to see global properties of space as a whole. What's
    a manifold? It's a geometric object, for example, the Earth. From where you stand
    or walk, it looks like it goes on for ever. However, if you walk around the Earth
    enough times, you'll realize that it's a sphere. What Godement called a **standard
    construction** was subsequently called a **monad** by Saunders Mac Lane, and that
    name stuck.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1ea00651-8b6f-4fd9-94aa-007f70088054.png)'
  prefs: []
  type: TYPE_IMG
- en: Moggi, Wadler, Jones (1991)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](img/8158a240-e97d-4e71-b61b-9115581c15e2.png) ![](img/950a9232-2aba-4255-b48a-3a3f186370d1.png) ![](img/9a6f4ab3-4e6a-435b-af45-08bdc0a79c95.png)'
  prefs: []
  type: TYPE_IMG
- en: In 1991, Eugenio Moggi wrote *Notions of computation and monads*, which introduced
    the concept of categorical semantics of computation in order to understand features
    in new programming languages. Languages often add new features to solve particular
    problems, but the features are rarely specified carefully in a formal way. In
    order to understand programs written in these languages, we need a framework to
    help us understand how information flows through our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Moggi described a category C and an endomorphic functor *f* with an object *A*.
  prefs: []
  type: TYPE_NORMAL
- en: '*A* is a type in *C*, where members are values of type *A*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*f* applies to *A* and returns another *A*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is amazing how far we have gone with so little. Less really is more!
  prefs: []
  type: TYPE_NORMAL
- en: 'Philip Wadler and Simon Peyton Jones and others began to use monads and it
    trickled down into the Haskell language. Now, monads are part of its standard
    library. Uses for monads include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Chain/link/connect/compose functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling side effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous/concurrent processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gibbons, Oliveira (2006)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](img/b2ca9753-13f3-44f3-b30d-56567aa82ce8.png)![](img/88fe78d2-ee02-4d64-95b9-53d6eabe9ff7.png)'
  prefs: []
  type: TYPE_IMG
- en: Gibbons and Oliveira explored an FP solution to the OOP iterator pattern. They
    used imperative iterations patterns and observed that data is mapped element-by-element
    with accumulation and can return an object of the same shape, that is, a transformed
    list of elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'They took Kernighan and Ritchie''s imperative wordcount program (in the following C#
    code) and created an alternative implementation using traversal operators and applicative
    functor techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an iteration example in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6aafb3c-b4ca-49fa-b299-73b4dd693ec7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Given that different traversals perform different functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Map element** | **Create state** | **Mapped dependent on
    state** | **State dependent on element** |'
  prefs: []
  type: TYPE_TB
- en: '| `collect` | X | X |  | X |'
  prefs: []
  type: TYPE_TB
- en: '| `disperse` | X | X | X |  |'
  prefs: []
  type: TYPE_TB
- en: '| `measure` | X | X |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `traverse` | X | X | X | X |'
  prefs: []
  type: TYPE_TB
- en: '| `reduce` |  | X |  | X |'
  prefs: []
  type: TYPE_TB
- en: '| `reduceConst` |  | X |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `map` | X |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: 'The computation is in this form (K is the type of computation and T is data
    type): `K[T]`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The nature of the following FP computations:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Computation** | **Description** | **New computations** | **Use computations**
    | **Functor map** |'
  prefs: []
  type: TYPE_TB
- en: '| `Option[T]` | 0 &#124;&#124; 1 element | Some(t) | Some(3) | change value
    |'
  prefs: []
  type: TYPE_TB
- en: '| `List[T]` | >= 0 elements | List(t) | List(1, 2, 3) | change values |'
  prefs: []
  type: TYPE_TB
- en: '| `Future[T]` | perform later | future(t) | future(sum) | change later |'
  prefs: []
  type: TYPE_TB
- en: '| `State[S, T]` | dependency on state | state(s => (s,t)) | state(s => (s,
    s+2)) | change t[x] |'
  prefs: []
  type: TYPE_TB
- en: '| `IO[T]` | external effects | IO(t) | IO(putStr("hi")) | modify action |'
  prefs: []
  type: TYPE_TB
- en: 'Starting with this applicative: `f(a, b) ==> f(K[a], K[b])` with this pointed
    `f(a:A, b:B):C  ==> fk: K[A => B => C]` and with currying:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Then, apply **f** to **a** and **b** **inside** **K**: `K(**f**) <*> K**(a**)
    <*> K(**b)**`
  prefs: []
  type: TYPE_NORMAL
- en: We can use applicative composition to compose functions with Traversables and
    show that transformations on iterators are applicative.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s the big picture. For the details, read their paper: [https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf](https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: The history of FP in a nutshell
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the 1930s, two very different approaches to solve computing problems emerged
    . The first school of thought rallied behind Alonzo Church. (Church developed
    Lambda calculus around 1929.) Church said that design should be top-down rather
    than bottom-up. He said we should start by treating all computation as the evaluation
    of mathematical functions and then remove abstractions to move toward the machine-level
    operations. The ability to control complexity via composition was arguably the
    main concern (definitely not performance). Languages that sprang from this line
    of thinking include ML, Lisp, SmallTalk, Erlang, Clojure and Haskell.
  prefs: []
  type: TYPE_NORMAL
- en: The other computing solution came from Alan Turing (a former student of Church,
    developed the Turing machine around 1937). Turing said that software design should
    first consider the hardware upon which the software would run. Later, abstraction
    could be  as needed to achieve the desired result. Performance was their paramount
    concern. Languages that sprang from this line of thought include Fortran, C, C++,
    C#, Pascal, and Java.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda calculus and Turing Machines are both Turing Complete. A Turing Complete
    machine is basically a general purpose computer (has if, then, else, branching
    logic and looping constructs like for or while loops and a way to read and write
    data) that can help us solve problems. Church proved that a Turing Machine can
    be implemented using Lambda calculus.
  prefs: []
  type: TYPE_NORMAL
- en: The Lambdas warned against the fragility of locking down the software design
    based on hardware that may be obsoleted. Until recently, the bottom up approach
    has won out. With the recent advent of multi-core computers and distributed processing
    environments, Lambda calculus is gaining ground.
  prefs: []
  type: TYPE_NORMAL
- en: Recently, Turing-based languages have begun to embrace the top down approach.
    For example, we began to see FP characteristics in Java 7\. More and more FP features
    are added to each subsequent version. We're also seeing FP constructs being added
    to Python, C++, C#, PHP, and more.
  prefs: []
  type: TYPE_NORMAL
- en: What is the most important concern today? Raw performance, or the ability to
    control complexity? As usual, It Depends, but given the industry shift to cloud
    computing environments, the ever increasing need to integrate with third-party
    libraries and even with other in-house departments, it looks like functional programming
    is not only catching on, it's taking over.
  prefs: []
  type: TYPE_NORMAL
- en: Where to go from here
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As the need to run applications concurrently in distributed cloud environments
    rises, so will the demand to build and maintain those solutions. We know that
    pure FP scales, but how can we use FP to improve overall performance and control
    its complexity?
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge is power. Keep learning. And apply what you know to build a better
    future.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functional Programming Resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.cambridge.org/core/journals/journal-of-functional-programming/](https://www.cambridge.org/core/journals/journal-of-functional-programming/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out today''s FP giants here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://scholar.google.com/citations?view_op=search_authors&hl=en&mauthors=label:functional_programming](https://scholar.google.com/citations?view_op=search_authors&hl=en&mauthors=label:functional_programming)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://learnyouahaskell.com/](http://learnyouahaskell.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://learnyousomeerlang.com/](http://learnyousomeerlang.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming language categories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we can see four categories of programming languages. The two big categories
    are imperative and declarative. When programming in a declarative language, we
    tell the computer what we want. For example, in the following declarative code,
    we tell the computer that we want to find a `Highlander` car.
  prefs: []
  type: TYPE_NORMAL
- en: A declarative example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following is an  example of declarative programming language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Contrast that with an imperative language with all code ceremony where we must
    construct a `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: An imperative example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following is an example of an imperative programming language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: An OOP example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Object-oriented programs** (**OOP**) consists of stateful objects that support
    object-related operations, called **methods**, whose implementation and internal
    structure is hidden. This means you can evolve or replace the internals of an
    object without the clients of that object also having to change. It also means
    that changes can occur to the hidden data without your knowledge, which, as we''ve
    seen, can be a bad thing. OOP also includes the idea of inheritance, where a new
    object could base its state and implementation on another object higher up in
    its hierarchy, which can cause your program to become rigid and more difficult
    to change. Here is a `Car` object and its `Add` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Venn diagram of four programming paradigms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that Go supports all three of those styles of programming. Originally,
    *idiomatic* Go programming style directed us to code using for loops. That is
    beginning to change. Similarly, Java was originally a mix of object-oriented and
    imperative coding styles. Java supported Generics in 2004 to provide type safety
    for collections and to eliminate the need of typecasting. 8 years later, Java
    added support for lambda expressions. The JDK's `java.util.stream` package leverages
    FP language features to provide aggregate operations on data structures like collections
    and arrays in a declarative and parallel-processing-friendly manner.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54d92dfb-ff8b-402b-abf7-f1322cbc39f3.png)'
  prefs: []
  type: TYPE_IMG
- en: Five generations of languages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another way to group programming languages is by their *generation*.
  prefs: []
  type: TYPE_NORMAL
- en: The first generation (1GL) language consists only of 1's and 0's which represent
    the on and off positions of electrical switches. The 1GL machine language is difficult
    for humans to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Assembly language (2GL) allows the programming to user words to represent operations
    and operands, for example, CMP means compare the data in the AX register with
    the number 99\. The result is stored in the the EFLAGS register and used by the
    jump (JL) command. 2GL's are specific to a particular processor family, that is,
    they are machine dependent.
  prefs: []
  type: TYPE_NORMAL
- en: A 3GL is a higher level language and most are not machine dependent. For example,
    Go is a 3GL. Go abstracts more details than a 2GL and allows us to program in
    more familiar notations. Go provides curly braces `{ }` to indicate blocks of
    code, control structures like if, switch and range and other abstractions such
    as functions and interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: A 4GL language are declarative. They allow us to declare what we want to compute,
    rather than telling the computer how to do it. This is yet another higher level
    of abstraction. For example in SQL we may write `SELECT * FROM USERS`  which says,
    give me all the columns and all the rows of data in the `USERS` table. We did
    not have to include and looping, order, parsing or any other details, we just
    said what we wanted.
  prefs: []
  type: TYPE_NORMAL
- en: A 5GL languages allow use to program using human languages like English. They
    are typically built on Lisp and emulate human-like qualities such as learning,
    reasoning, seeing and communicating.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/974bf050-7d90-4177-93c1-f64a648e14ff.png)'
  prefs: []
  type: TYPE_IMG
- en: The Forth language
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's look at the Forth language. It is imperative, but incorporates key FP
    aspects, such as abstraction, replacement and chaining functions. We can open
    a forth console and start typing commands and get results. Rather than hide the
    fact that the runtime will use a stack to push and pop operators and operands
    on and off the stack, it's built into the language. There are no anonymous functions.
    Forth uses *words* which act like named functions. Words can reference other words
    which provides a very elegant form of abstraction. Common stack operations in
    Forth work with the top two or three values on the stack and can change the order
    of things or duplicate things.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4bdc0e15-4166-49fd-84de-ab045e265255.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We define our a function name/word starting with a colon. Comments are enclosed
    in parentheses. `( x -- x-squared )` says our function/word will take one input
    off the stack (x) and return that value squared. We define a second word that
    takes the top two values from the stack and returns a result. To test, we type
    `3 squared .`, the "." means evaluate this expression. The result is 9 (3 duplicated
    and multiplied). Next, we type `2 3  sumOfSquares negate .` this pushes 2 and
    3 on the stack, executes squared (which returns 9 since 3 is on the top), swaps
    3 with 9 and runs square which takes the next value (2) and then evaluates "+"
    which takes the top two values on the stack (9 and 4). We chain the builtin word
    to get our result: -13.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re using a mac then you can install forth using `brew install forth`.
    For details and more Forth references, visit: [https://github.com/lawrencewoodman/awesome-forth](https://github.com/lawrencewoodman/awesome-forth)'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the FP languages, Forth is untyped. Also, Forth directly uses values
    on the stack rather than passing parameters. Forth is a compiled language with
    a small footprint and is often used for embedded programming application, for
    example, NASA space crafts. We'd probably not consider Forth for enterprise system
    development since it lacks type safety.
  prefs: []
  type: TYPE_NORMAL
- en: The LINQ language
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Most languages are multi-paradigm, meaning that depending on our coding style,
    we can use declarative, object-oriented and imperative features in the same program.
    Knowing when to use which style is more of an art than science. The more we learn,
    the better equipped we will be to make the right design choice, and the sooner
    in our development process we do it, the better. One final not, see the dotted
    line from imperative/declarative FoxPro to object-oriented Visual FoxPro? That''s
    Microsoft killing its competition; FoxPro was once a well designed multi-paradigm
    language. FoxPro''s procedural language was extended using **Language Integrated
    Query** (**LINQ**). LINQ added query expressions similar to SQL to the FoxPro
    language. For example, the scatter and gather commands were used with the prebaked
    context of manipulating a database table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: These **4th generation language** (**4GL**) features increased developer productivity
    and code consistency.
  prefs: []
  type: TYPE_NORMAL
- en: Type systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What comes to mind when we see the word *type?* Data type? Like integer, string,
    date, or a composite type (struct in Go) that can contain multiple fields of various
    data types..
  prefs: []
  type: TYPE_NORMAL
- en: What are they good for? When we compile our program, strongly typed language
    compilers can catch errors that might cause runtime errors or possibly worse,
    incorrect results that don't crash the program. For example, JavaScript uses type
    coercion to dynamically change data types of variables during runtime. The statement
    *MyBalance + 100.00* will equal *MyBalance100.00,* which might not be what we
    really want and may cause problems that are caught by online bank customers that
    complain that their balances don't add up. Weakly typed languages such as JavaScript
    and Ruby require much more rigorous testing than strongly typed language alternatives.
    Type systems not only detect errors in programs prior to running them, thereby
    increasing code quality, but they also help IDEs provide useful code navigation
    features.
  prefs: []
  type: TYPE_NORMAL
- en: The Lambda Calculus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lambda calculus is a logical system of rules for expressing computation using
    variable binding, abstraction, and function application. We can define anonymous
    functions and apply those functions. Lambda calculus would be limited if it weren't
    for recursion. Pure functional programming languages derived from lambda calculus
    include LISP, Haskell, and ML.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A lambda expression is an instance of a functional interface consisting of a
    set of terms. These terms can be variables like *x*, *y*, and *z*. These are not
    mutating variables, but rather placeholders for values or other lambda terms.
    The variable inside of x is applied to whatever it is bound to. The variable *x*
    is inside the term *t*. The lambda abstraction is defined as *λ x.t*.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we have the equation `f(x) = x2` and replace x with 5, we have
    *f(5) =  52*.
  prefs: []
  type: TYPE_NORMAL
- en: When the function *f* is applied to *x*, we get x². In our example, the function
    f is applied to the argument 5 and we get 52.
  prefs: []
  type: TYPE_NORMAL
- en: We can eliminate the parentheses for brevity and we have the term *f* applied
    to another term 5: `f 5 = 52`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we abstract, we remove information that we don''t need: *Lambda of x where
    x² is applied to 5*: `(λx.x2)  5 = 52`.'
  prefs: []
  type: TYPE_NORMAL
- en: We could use a term that is not a constant or a variable in place of 5\. *Lambda
    of x where x2 is applied to lambda of y + 1*: `(λx.x2) (λy.y + 1)  =  λy.(y +
    1)2`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have a new function. We passed a function to a function and got a function.
  prefs: []
  type: TYPE_NORMAL
- en: Since the lambda expression is an instance of a functional interface, when we
    write our code as though it were data we are effectively generating code with
    code.
  prefs: []
  type: TYPE_NORMAL
- en: When we only need to use a function once, it is usually more convenient to not
    give the function a name. In that case, it would be an anonymous function. Another
    name for the anonymous function is a *lambda expression*. Why create a new local
    function and then refer to the named function, when we can simply use a lambda
    expression?
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous function example and type inference
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First, let's look at what we mean by the term *anonymous function*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b6af684-3cd4-43dd-923a-6593b17e4dc3.png)'
  prefs: []
  type: TYPE_IMG
- en: Function literals in Go require us to declare its type (`int` in our preceding
    example). In pure functional languages like Haskell and even Java 8 and above,
    the compilers of those languages are able to infer the type of the lambda expression
    without requiring use to declare it inline. Those compilers need minimal information
    to infer the types of expressions at runtime. If the compiler sees an expression
    with an argument of 5 and the "+" operator, a language with type inference will
    not require us to specifically indicate that we are dealing with integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out an example of lambda expression type inference in Java 8 here: [https://www.youtube.com/watch?v=a8jvxBbswp4](https://www.youtube.com/watch?v=a8jvxBbswp4).'
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expression ingredients
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A lambda expression is an unnamed block of code with parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'A lambda expression consists of three things:'
  prefs: []
  type: TYPE_NORMAL
- en: A block of code *x + 2*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameters *x*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Values for the free variables (not defined inside the code block) *5*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lambda calculus uses the following three concepts to describe how to perform
    a unit of computation:'
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction (defining a *function*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding (defining a *variable*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application (executing a *function*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Variables that are unbound are referred to as *free variables*. Computation
    is achieved by performing single steps of reduction:'
  prefs: []
  type: TYPE_NORMAL
- en: Alpha reduction
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Beta reduction
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Eta reduction
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Consider the following untyped Lambda calculus statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(λx.xx)(λx.xx)`'
  prefs: []
  type: TYPE_NORMAL
- en: The lambda symbol (from whence the name is derived) "λ" binds the name. In the
    example, the first parenthetical captures a statement that binds the name x. The
    second parenthetical serves as an argument. During beta-reduction, when we are
    applying the function, the parameter is bound to the name x. This is just substitution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Confused? That''s understandable, since we are using a mixture of Greek and
    English to describe what the code does. Let''s look at some Go code that performs
    these steps for clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the *Lambda calculus Reduction steps* post for a more detailed description
    of the 3 steps: [https://stackoverflow.com/questions/34140819/lambda-calculus-reduction-steps](https://stackoverflow.com/questions/34140819/lambda-calculus-reduction-steps)'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've got some formalism out of the way, let's look at what it means
    in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing a lambda expression
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This is what happens when we evaluate a lambda expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dde71c7b-2c81-40f9-911d-863b0c4f5fee.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's describe our visualization.
  prefs: []
  type: TYPE_NORMAL
- en: First, we define our function as the *abstract* operation of *a + b*. This operation
    requires two values, a and b. Second, when we execute *add2 := add(2)* , we are
    binding the value 2 to the variable a. (*a* is technically a variable, but we
    treat it like a constant. Remember? Functional programming does not permit mutation.)
    Since our inner, anonymous function closes over a, the a variable's value is stored
    in the context of our closure structure and remains available for use later when
    we apply *b* and finally evaluate our *a + b* expression.
  prefs: []
  type: TYPE_NORMAL
- en: We define our add function to be of type *lambda*, that is, a function that
    accepts an int and returns an int. (Note that unlike our abstract add operation
    that requires two values, all of our functions accept only one argument and return
    only one value.) The output of our closure structure returns an expression representing
    the function definition f(b) = 2 + b.
  prefs: []
  type: TYPE_NORMAL
- en: We call our closure when we execute *three := add2(1)*, where *three* is a lambda,
    that is, it is a function that accepts an input function. That input function
    accepts an int, that is, 1 in our example. 1 is bound to the unbound terminal
    *b*. Now that we know that all of our variables are bound, that is, they all have
    values, we can evaluate our expression *2 + 1* and return the result *3:*
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd6cdb82-a8ca-464a-9411-04388ca837b0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In *step 1*, we define our `add` function. The `add` function accepts the argument
    `a` of type `int` and returns an anonymous function of type lambda.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2*, we call our lambda function and pass the integer 2\. 2 is accepted
    as argument a. We can say that add is partially invoked in this step and that
    the value 2 stored in a is curried. What we return is a *closure*, that is, a
    function that *closes over* the a variable.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 3*, we pass our free variable 1 to our `add2` lambda function. This
    is where the magic happens. `add2` is a variable that contains a function with
    the curried value 2\. When we pass 1 to that lambda, it assigns 1 to the free
    argument, which next gets assigned to the *b* argument of the inner, anonymous,
    application function where our *a + b* expression is evaluated and returned.
  prefs: []
  type: TYPE_NORMAL
- en: Pretty cool, huh? Go allows us to directly implement lambda expressions. Maybe
    this lambda closure application functionality will become part of Go's standard
    library one day. There's not much code here, but understanding it and then implementing
    it was challenging. However, now that we have it, we can reuse our `add2` function
    and pass it around like a variable. A variable that contains contextual data and
    logic. Sweet!
  prefs: []
  type: TYPE_NORMAL
- en: Granted our example was rudimentary, but consider all the naturally scalable
    reuse and compositional capabilities that we now have in our arsenal!
  prefs: []
  type: TYPE_NORMAL
- en: A Lambda calculus is like chocolate milk
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The closure is like the shot glass, chocolate syrup is like our curried variable *a.* Every
    shot glass partially filled with chocolate syrup is like our partially invoked
    lambda expression that we set aside, just waiting for the milk.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/93362ed5-e224-402d-86ca-394635707b45.png)'
  prefs: []
  type: TYPE_IMG
- en: When we add good ole' milk and stir, that's like passing the 1 and executing
    2 + 1\. The result (that is, 3) is a tasty treat called chocolate milk. For our
    lactose intolerant friends, we can take a glass of chocolate syrup (partially
    invoked function with curried chocolate syrup) and add almond milk. For our crazy
    lactose intolerant uncle, we can take another curried glass of chocolate syrup
    and add hemp milk. See, Lambda calculus isn't confusing after all; it's delicious!
  prefs: []
  type: TYPE_NORMAL
- en: Lambda examples in other languages
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s look at the same `add2` lambda function in a few other languages:'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Since JavaScript is a weakly typed language, we don''t need to specify that
    the type of our *a* and *b* variables are integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: JavaScript (ES6)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'ES6 provide arrow functions (also known as *fat arrow* functions) that provide
    a more concise syntax for writing function expressions. Fat arrows indicate an
    anonymous function and allow us to not type the keywords `function` and `return`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Ruby
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let's study lambda expressions in Ruby; it's quite insightful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ruby lets us define an anonymous lambda function in two ways. One uses the
    `lambda` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The other uses the stabby symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the IRB console, we can call the lambda expression like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: There's a lot we can do just with Ruby lambda. A Ruby lambda is a special kind
    of closure. Like Ruby blocks and procs, a Ruby lambda acts like a code snippet
    that can be passed around.
  prefs: []
  type: TYPE_NORMAL
- en: 'Where do we often see lambdas used with Ruby in real world applications? Ever
    worked with Rails? Ruby on Rails is a web application framework with an **Object
    Relational Mapping** (**ORM**) library named `ActiveRecord`. Ruby classes of type
    `ActiveRecord::Base` map to database tables. We call those Ruby classes models.
    They have a method named `scope` used for retrieving rows from their associated
    tables. We can define a scope using a lambda, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider seeding our tables, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use our `by_make` scope to retrieve only records containing Honda cars,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding, we are able to pass the key `id` value for a Honda (2) which
    the scope method passes to the lambda function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to leverage the full power of lambda expressions in Ruby, we''ll need
    to curry our function. For example, to call our `add` function from earlier with
    one parameter like we did in the JavaScript examples, we add the `curry` method
    to create a lexical scope for our anonymous lambda function. Next, we store it
    in a variable named `add2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The lambda provides a closure, that is, an anonymous, first class literal function
    that we store as a variable `add`. The curry adds a special ability to access
    other variables local to the scope in which that lambda was created.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can call the lambda expression in the `add2` variable by executing its call
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Look at the following call to the anonymous function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: What is immediately obviously different between that and the following call
    to the curried function?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Curried functions take one argument.
  prefs: []
  type: TYPE_NORMAL
- en: Why use currying instead of a regular function with multiple arguments?
  prefs: []
  type: TYPE_NORMAL
- en: 'A: How many arguments can you pass to the *regular* function?'
  prefs: []
  type: TYPE_NORMAL
- en: In this case it's rigidly set to two. However, if we use currying we can easily
    add more without breaking our interface. This is a powerful tool in our toolbox
    of composition. We can easily replace the pieces in our chain of function calls
    with more easily reusable functions.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we learned that a lambda expression is a curried, anonymous function.
    We just saw how those two concepts (anonymous and curried function) are defined
    and accessed in Ruby. In other languages, such as Go, while the syntax varies,
    the concepts remain the same.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of Type systems to FP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The purpose of a type system is to reduce bugs by defining the interfaces between
    the different functions in a program and verifying that those functions can be
    reliably connected. Types can be a simple as strings, ints, and booleans or can
    be a complex data structure with embedded fields and interfaces. Types can be
    checked at compile time or runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The Lambda Calculus was originally untyped, but Alonzo Church found that that
    though it was more expressive, it caused inconsistencies. So, Church introduced
    a typed version to simplify computation. We use type systems for similar reasons,
    that is, to improve determinism and to help prevent bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Since in FP a function is a data type, we need to define our functions' type
    for the type system.
  prefs: []
  type: TYPE_NORMAL
- en: A type system can also increase our programs' runtime performance. Go is a statically
    compiled language, so the data types are known at compile time. This makes type
    erasure possible. So, Go does not have to require our programs to carry around
    explicit type annotations. Contrast this to languages that support Generics. Generics
    employs a process called reification that allows programmers to pass generic data
    types, along with explicit type annotations, so that called functions that need
    to know their type can make the generic data a first class citizen, that is, convert
    it to an actual data type that the program recognizes.
  prefs: []
  type: TYPE_NORMAL
- en: The added complexity of reification and the performance degradation of using
    generics contradict Go's core principles of simplicity and performance.
  prefs: []
  type: TYPE_NORMAL
- en: Static versus dynamic typing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Go and other statically typed languages, such as C, C++, Java, and Scala,
    the compiler will catch type mismatches at compile time. In contrast, dynamically
    typed languages such as Ruby, SmallTalk, and Python catch these type errors at
    runtime and rely more on error handling to keep our programs from crashing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In statical yet dynamic typed languages, we can easily write a function definition
    without mentioning the data types, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This works great when we pass it the correct data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'However, runtime exceptions occur when we pass types that are compatible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Type inference
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Type inference is the process of determining the appropriate types for expressions
    based on how they are used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go can determine that the type of the variable a in the following examples
    is `int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Go properly infers data types in many scenarios, such as the one here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'However, since Go does not fully implement the Hindley-Milner type system,
    Go fails to infer the type of `b` in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Rather than inferring that the type of `b` is float64, Go reports the following
    compile errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: While it's unfortunate that Go's type system implementation is not perfect,
    it is understandable why it does not fully implement the HM type system. HM supports
    polymorphic functions. Go supports neither generics or polymorphic functions,
    nor parametric polymorphism. However, polymorphic list manipulation can be achieved
    in Go using the `interface{}` for any unknown types. We can store that in a slice
    of `interface{}`, that is, `[]interface{}` and use normal slice operations (append,
    copy, shift, and so on) on the list. When we later retrieve them from the slice,
    we'll need to cast the items to their appropriate type.
  prefs: []
  type: TYPE_NORMAL
- en: Haskell
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functional programming has been popularized largely as a result of Haskell (named
    after Haskell Curry), which is a programming language that was designed by a group
    of academics that are intimately familiar with the category theory. Since Haskell
    syntax is so clear and closely aligned with the original formal logical notations,
    we may see a few example in the following texts to help express category theory
    concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Things are a bit different in Haskell than they are in Go. For example, Haskell
    variables are immutable, that is, they are not allowed to change. We use them
    only as bindings to expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'I highly recommend learning Haskell. It''s a great, pure, functional programming
    language. Here are some good resources to get you started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.happylearnhaskelltutorial.com/](http://www.happylearnhaskelltutorial.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://learnyouahaskell.com/chapters](http://learnyouahaskell.com/chapters)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://haskellbook.com/](http://haskellbook.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://wiki.haskell.org/Tutorials](https://wiki.haskell.org/Tutorials)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In Haskell, we don''t implement the steps in our algorithms. Instead, we declare
    what our functions do. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: The sum of a list of numbers is zero plus the sum of all the numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The product of a list of numbers is one times the product of all the numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The factorial of a number is the product of all the numbers from 1 to that number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our new list is the result of adding two to all the numbers in our original
    list of numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Haskell, the our functions can only calculate a value and return it. This
    feature enables referential integrity. If a function is called more than once
    with the same parameters, it's guaranteed to return the same result every time.
    This allows the compiler to reason about our program's behavior and to improve
    its performance. This feature also allows us to compose our functions together
    to build more complex functions.
  prefs: []
  type: TYPE_NORMAL
- en: Haskell boils away the syntax and code ceremony that is non-essential.
  prefs: []
  type: TYPE_NORMAL
- en: Learning a bit of Haskell will help open our minds up to the new functional
    programming paradigms that we will cover in [Chapter 10](../Text/Ch10.xhtml),
    *Monoids, and Type Classes, and Generics*.
  prefs: []
  type: TYPE_NORMAL
- en: Type classes in Haskell
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Haskell is strongly typed and fully supports the HM type type system. Haskell
    has an additional layer above what we normally think of a type. Recall that a
    type defines the structure of the data stored in a variable of that type (`string`,
    `int`, user defined struct, and so on). A type class allows us to be more specific
    and specify not only what the data is, but also how it behaves.
  prefs: []
  type: TYPE_NORMAL
- en: Type classes define the sets of operations. A particular object may be an instance
    of a class and will have a method corresponding to each operation. Type classes
    may be arranged hierarchically, forming notions of superclasses and sub classes
    and permitting inheritance of operations/methods. A default method may also be
    associated with an operation.
  prefs: []
  type: TYPE_NORMAL
- en: Type classes are not objects; there is no internal mutable state. Type classes
    are type-safe; any attempt to apply a method to a value whose type is not in the
    required class will be detected at compile time. In other words, methods are not
    *looked up* at runtime, but are simply passed as higher order functions.
  prefs: []
  type: TYPE_NORMAL
- en: Like an interface declaration, a type class declaration defines a protocol for
    using an object, rather than defining an object itself. For example, a type is
    an instance of the Functor class if it is parameterized by another type where
    its values can be modified using the fmap function.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at Haskell's type class hierarchy here, we can see that a Monad is a
    Monoid, as well as an Applicative. So, we know that a Monad inherits operations
    from both.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d45754a8-9d77-4759-8e74-c075f70ec39b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So, we don''t need to add the int type to the argument signatures and we still
    get the type safety features to catch errors at compile time. The following defines
    a lambda function that adds 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'On the following, we''re in a Haskell REPL console, where we can enter Haskell
    commands interactively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b1d6450-db25-4f5d-8a7e-477955eab5f8.png)'
  prefs: []
  type: TYPE_IMG
- en: The lambda character allows us to define an anonymous function that performs
    the curry operation. We pass our lambda function to map, which is a high order
    function. Map transforms each element in our original list to a new list that
    results from adding 2 to each item in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Domains, codomains, and morphisms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we look closely, we can find ordered pairs of data all around us. Let''s
    look at some statistics of Lionel Messi. The following table shows how many goals
    Messi scored for 10 consecutive years:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a08f80c-2899-44e2-945e-3bf6fe3c15ce.png)'
  prefs: []
  type: TYPE_IMG
- en: We say that the domain is **set A:** `{2007, 2007, 2007, 2010, 2011, 2012, 2013,
    2014, 2015, 2016}` and the range (or codomain) is **set B:** `{5, 6, 7, 8, 10}`
    and that the ordered pairs are `{(2007,10), (2008, 6), (2008, 8), (2010, 5), (2011,
    8), (2012, 5), (2013, 5), (2014, 7), (2015, 6), (2016, 10)}`.
  prefs: []
  type: TYPE_NORMAL
- en: Each year maps to a number of goals scored.
  prefs: []
  type: TYPE_NORMAL
- en: If the year where x and y was calculated by calling a function named *f*, we
    could get y by calling f(x). For example, *f(2010) = 5* and *f(2016) = 10*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e13440e5-aeb8-4706-a959-d7f49fe0cedb.png)'
  prefs: []
  type: TYPE_IMG
- en: Does the following relation make sense?
  prefs: []
  type: TYPE_NORMAL
- en: How can Messi score exactly 6 goals and exactly 7 goals and exactly 10 goals
    in the same year? That makes no sense, right? (Right!)
  prefs: []
  type: TYPE_NORMAL
- en: We can say that the relation of *{(2007, 6), (2007, 7), (2007, 10)}* which is
    defined by our arrows is not a function because it contains ordered pairs with
    the same *x* value.
  prefs: []
  type: TYPE_NORMAL
- en: Set theory symbols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before moving forward with category theory, let''s get familiar with the symbols
    of set theory:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Symbol name** | **Meaning/definition** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| { } | Set | A collection of objects (also known as elements) | *A = {5,6,7,8},**B
    = {5,8,10}* |'
  prefs: []
  type: TYPE_TB
- en: '| &#124; | Such that | So that | *A = {x &#124; x ∈**ℝ, x<0}* |'
  prefs: []
  type: TYPE_TB
- en: '| A∩B | Intersection | Objects that belong to set A and set B | *A ∩ B = {5,8}*
    |'
  prefs: []
  type: TYPE_TB
- en: '| A∪B | Union | Objects that belong to set A or set B | *A ∪ B = {5,6,7,8,10}*
    |'
  prefs: []
  type: TYPE_TB
- en: '| A⊆B | Subset | A is a subset of B. Set A is included in set B | *{5,8,10}
    ⊆ {5,8,10}* |'
  prefs: []
  type: TYPE_TB
- en: '| A⊂B | Proper subset / Strict subset | A is a subset of B, but A is not equal
    to B | *{5,8} ⊂ {**5,8,10}* |'
  prefs: []
  type: TYPE_TB
- en: '| A⊄B | Not subset | Set A is not a subset of set B | *{8,15} ⊄ {8,10,25}*
    |'
  prefs: []
  type: TYPE_TB
- en: '| a∈A | Element of | Set membership | *A ={5,10,15}, 5 ∈ A* |'
  prefs: []
  type: TYPE_TB
- en: '| x∉A | Not element of | No set membership | *A ={5,10,15}, 2 ∉ A* |'
  prefs: []
  type: TYPE_TB
- en: '| (a,b) | Ordered pair | A collection of 2 elements |  |'
  prefs: []
  type: TYPE_TB
- en: '| A×B | Cartesian product | A set of all ordered pairs from A and B |  |'
  prefs: []
  type: TYPE_TB
- en: '| &#124;A&#124; | Cardinality | The number of elements of set A | *A ={5,10,15},
    &#124;A&#124;=3* |'
  prefs: []
  type: TYPE_TB
- en: '| Ø | Empty set | Ø = {} | *A = Ø* |'
  prefs: []
  type: TYPE_TB
- en: '| ↦ | Maps to | f: a ↦ b means the function f maps from the element a to the
    element b | *f: a ↦ f(a)* |'
  prefs: []
  type: TYPE_TB
- en: '| U | Universal set | set of all possible values |  |'
  prefs: []
  type: TYPE_TB
- en: '| ℕ[o] | Natural numbers / Whole numbers set (with zero) | ℕ[o] = {0, 1, 2,
    3, ...} | *0 ∈ ℕ[o]* |'
  prefs: []
  type: TYPE_TB
- en: '| ℕ[1] | Natural numbers / Whole numbers set (without zero) | ℕ[1] = {1, 2,
    3, 4, ...} | *5 ∈ ℕ[1]* |'
  prefs: []
  type: TYPE_TB
- en: '| ℤ | Integer numbers set | ℤ = {... -2, -1, 0, 1, 2, ..} | *-5 ∈ ℤ* |'
  prefs: []
  type: TYPE_TB
- en: '| ℝ | Real numbers set | ℝ= {x &#124; -∞ < x <∞} | *5.166667 ∈ ℝ* |'
  prefs: []
  type: TYPE_TB
- en: 'In set theory, we look at elements in a set. For example, set **A** may have
    2 elements: `{5, 6}` and set **B** may have 3 elements: `{7, 8, 10}`. A Cartesian
    product has every possible combination of each: `{(5, 7), (5, 8), (5, 10), (6,
    7), (6, 8), (6, 10)}`.'
  prefs: []
  type: TYPE_NORMAL
- en: In category theory, we no longer look at elements inside sets, we only look
    at the relationships between sets. In other words, we only look at the arrows.
  prefs: []
  type: TYPE_NORMAL
- en: Category theory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Category theory is a branch of mathematics that deals with structure, rather
    than with particulars. It deals with the kinds of structures that make programs
    composable.
  prefs: []
  type: TYPE_NORMAL
- en: Category theory is a branch of mathematics that is similar to Set theory. A
    basic example of a category is the category of sets, where the objects are sets
    and the arrows are functions from one set to another. Objects of a category need
    are typically sets, and arrows are typically functions. Any way of formalizing
    a mathematical concept so that it meets the basic conditions on the behavior of
    objects and arrows is a valid category.
  prefs: []
  type: TYPE_NORMAL
- en: I could not find an easy-to-understand resource for learning category theory.
    Most of what's out there is geared toward mathematicians. Though I did take a
    good number of advanced math classes in college, I am not a practicing mathematician.
    While understanding the logical and mathematical formalism is important (and we'll
    cover the enough to be conversant), what I really wanted was something that I
    could wrap my head around. I wanted practical information. I wondered, how can
    I implement this Lambda calculus in Go? How can I build better scalable software
    using these lambdas? How can I tease apart the details and compose a better application
    from smaller, simple pieces? Can I use this new found knowledge to better architect
    my big data/data analytics project? I hope this chapter does that for you.
  prefs: []
  type: TYPE_NORMAL
- en: Algebra of functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Category theory is the abstract algebra of functions. In fact, the Lambda calculus
    is a calculus for specifying, manipulating, and calculating functions. There is
    a deep connection between Lambda calculus and category theory. We're looking at
    the same thing from two different perspectives--from the logical, syntactic way
    on the Lambda calculus side and from a more algebraic, geometric perspective from
    category theory.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Abstract functions are any process, expression or assignment that can be read
    in a functional way. This is an abstract algebra of abstract functions.
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at set theoretical functions on sets in order to arrive at the basic
    principles of category theory.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll look at functions on set. Given sets are **A**, **B**, and **C**. And
    a function *f* going from ***A*** to **B**:'
  prefs: []
  type: TYPE_NORMAL
- en: '*f: A -> B *'
  prefs: []
  type: TYPE_NORMAL
- en: Official definition of a function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A function is a subset of Cartesian product of A and B, which is relation of
    *AxB* (*A cross B*):'
  prefs: []
  type: TYPE_NORMAL
- en: '*f is equal to or subset of AxB*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, f is a subset of pairs.
  prefs: []
  type: TYPE_NORMAL
- en: 'For all of A, there is a unique B (*b:B*) such that the subset *<a,b>* is a
    relation of that relation f:'
  prefs: []
  type: TYPE_NORMAL
- en: '*<a,b> ∈  f*'
  prefs: []
  type: TYPE_NORMAL
- en: Intuitive definition of a function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In a more intuitive way, we''ll think of the function f as: *taking an element
    of set A and returning an element of set B*.'
  prefs: []
  type: TYPE_NORMAL
- en: Function composition with sets
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Function composition is where we take the output of one function (*f: A → B*)
    and use it as input for another (*g: B → C*). Through the law of associativity,
    we know that if *A → B → C*, then this is true: *A → C*. (We can go from A to
    B to C or we can go from A directly to C.)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a47ca09-1a9b-49bc-998c-93ea6ccf9830.png)'
  prefs: []
  type: TYPE_IMG
- en: Composition operation example using travel expenses
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In the following composition table, we enter our budget for travelling from
    the US to Europe:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f36d0f4-d1cb-4cbc-a5dc-c5a4e96def82.png)'
  prefs: []
  type: TYPE_IMG
- en: If we travel from the US to Europe, we use the **f** arrow (function) to convert
    dollars to euros. If we travel from Europe to Mexico, we use the g arrow to convert
    euros to pesos. Here, the output of function f is the input to function **g**;
    this is called function composition.
  prefs: []
  type: TYPE_NORMAL
- en: If we decided to not travel to and from Europe and travel directly to Mexico
    from the US, we use the gof arrow. Either way, `f($) → g(€)  → ₱` or `f(g($))
    → ₱` , we still should get the same amount of pesos for our dollar!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed77bf35-b1ea-4c23-ad3f-7b5abeb4c213.png)'
  prefs: []
  type: TYPE_IMG
- en: A Category
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A category is defined by its objects and the arrows that connect the objects
    and all compositions.
  prefs: []
  type: TYPE_NORMAL
- en: For every two arrows (f and g), we must define their composition (**g** o **f**).
  prefs: []
  type: TYPE_NORMAL
- en: 'The elements/data of a category theory include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Categories**/**sets**: is a grouping of objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Objects**: dots/points/a primitive with no properties no structure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Morphisms**: (arrows) something that goes between two objects/elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We write objects with upper case letters (such as A, B, C, and so on). We write
    arrows in lower case letters (such as f, g, h, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Arrows have a beginning and an end. Objects in the beginning of the arrow are
    in the domain; arrows at the end arrows are in the range (also known as **codomain**).
  prefs: []
  type: TYPE_NORMAL
- en: Category axioms
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For each f, we have an arrow that goes from the domain of f to the codomain
    of **f**:'
  prefs: []
  type: TYPE_NORMAL
- en: '*f: dom(f) → cod(f)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'For each A, we have an identity arrow that goes from A to A:'
  prefs: []
  type: TYPE_NORMAL
- en: '*1A: A → A*'
  prefs: []
  type: TYPE_NORMAL
- en: For each composable pair, *A → B → C* we have a composition operation from *A
    → C*.
  prefs: []
  type: TYPE_NORMAL
- en: Category laws
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following are the category laws:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Associativity**: *h o (g o f) = (h o g) o f*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identity**: *f o 1A = f  = f o 1B*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unit**: Every composite is equal to itself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll look more closely at those laws later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: More rules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here are some more rules that apply to categories:'
  prefs: []
  type: TYPE_NORMAL
- en: We can have zero or more arrows between objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There can no more than one arrow from any object in the domain. Remember? x
    values must not be repeated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can put all compositions in a composition table (how we compose morphisms).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different compositions will give you different categories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects and arrows have no structure and no information; the composition has
    the information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Category theory is based on the more general notion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The s value of objects and morphisms. Objects generalize types and morphisms
    generalize functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A category does not take time into account.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also a spacial relationship between objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When it comes to programming and computers, time is important. For example,
    if we are studying the motion of a soccer ball in flight, the ball moves in an
    three dimensional (x,y,z) space with respect to time. If we wish to know the exact
    position of the ball with respect to time, we need to take time into account in
    our calculations.
  prefs: []
  type: TYPE_NORMAL
- en: More examples
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Here're a few examples to help get a better intuition about what a category
    is, what it means to be a category, what things are required, and what rules must
    be obeyed.
  prefs: []
  type: TYPE_NORMAL
- en: Invalid categories
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Here, we have two valid categories. The first one is of a car. The objects include
    the car itself, the car's model name, and the car's age. We show two identity
    morphisms. One arrow goes from a car to itself (upgrade a car and it's another
    car). The other arrow goes from the integer object to itself (the "++" operator
    means add one to the current value). We left off the arrow from the model name
    to itself, but it exists (a name is a name):=
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6ac962d-0694-441e-98c5-1e1bc6df014b.png)'
  prefs: []
  type: TYPE_IMG
- en: Why is this invalid? It looks like it composes, but does it really?
  prefs: []
  type: TYPE_NORMAL
- en: The next example should be a bit more obvious. (Funny, but obviously not a category.)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d5a6493-a646-4f48-8261-17fa621c07d5.png)'
  prefs: []
  type: TYPE_IMG
- en: There's a link from the Favorite's page (A) to the link on the Reddit home page
    (B), and one from there to the image (C), but not one from the Favorite's page
    (A) to the image (C).
  prefs: []
  type: TYPE_NORMAL
- en: Morphisms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A morphism is an arrow from one object (A, B, C in our example) in a category
    (our grouping of A, B, C). There can be more than one arrow from A to B (or from
    B to C, or A to C). Also, arrows can go from any object to itself; this is called
    the identity morphism.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/135cce5f-678e-4afe-970a-ad9a309dcbf2.png)'
  prefs: []
  type: TYPE_IMG
- en: f:A→B statement is a morphism (f) from A to B
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hom(A,B) is the collection of all arrows from A to B
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hom(A,B) is also known as the Hom-Set of A to B
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: idA:A→A is a morphism from A to A
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The behaviors of morphisms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's look at at a couple things we can do with morphisms. W can compose them
    and run the identity morphism to verify an object's identity.
  prefs: []
  type: TYPE_NORMAL
- en: Composition operation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Below, is our basic composition operation.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c00c08cc-ac82-4fb7-b920-bf841aa54bf8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The composition operation is *g o f,* *g after f *applies arg x (from **A**)
    to give us g applied to f applied to *x*: *(g o f)(x) = g(f(x)).*'
  prefs: []
  type: TYPE_NORMAL
- en: If *f(g(x)) = g(f(x))* for all *x*, then we can say that **f** and **g** commute
    under composition.
  prefs: []
  type: TYPE_NORMAL
- en: However, that's not typical. Function composition is generally not commutative.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take an example. Remember when we composed *f(x) = x + 2* with *g(x)
    = x2 + 1* earlier in the chapter? We solved *g(f(1)) = 10*, but what about *f(g(1))*?
    Does that also equal 10? Let''s see now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*g(1) = 1² + 1 = 2*  and *f(2) = 4*'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, no, our functions f and g are not associative: *g(f(1)) != f(g(1))*.'
  prefs: []
  type: TYPE_NORMAL
- en: Identity operation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Identity law of our category says the identity morphism of A is A.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31746fff-0c56-4b8d-86f5-6c20a024716b.png)'
  prefs: []
  type: TYPE_IMG
- en: Every object has a morphism pointing back to itself.
  prefs: []
  type: TYPE_NORMAL
- en: When we have more than one object, we denote which ID we're talking about with
    a subscript, for example, **idA**.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf1de571-5404-4247-892e-05a9839dfecb.png)'
  prefs: []
  type: TYPE_IMG
- en: This graph says *f o idA  = f*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, the morphism of **f** after **idA** is the same as the morphism
    of **f**. Here''s a concrete example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e7c29f9-e39a-4762-a3c8-c13a2de591ef.png)'
  prefs: []
  type: TYPE_IMG
- en: The identity morphism for the natural number 3 is a function that multiplies
    any number by
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce4eb718-cc2a-43fb-b69e-adac25484348.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There is a symmetric identity morphism: *idA o g = g  *'
  prefs: []
  type: TYPE_NORMAL
- en: Law of associativity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the following diagram, we see that we can get from A to C by way of the *g
    o f* composition.
  prefs: []
  type: TYPE_NORMAL
- en: From **C**, we can get to **D** using the **h** arrow, which we can write as *ho(gof)*.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this is the same as **h(f(g))**. This notation seems more intuitive
    than using the composition operation, but they mean the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4af522e-e395-47c1-b6aa-cf7a5855bca3.png)'
  prefs: []
  type: TYPE_IMG
- en: From the following diagram, we see that **ho(gof)** is the same as **(hog)of**.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, our category obeys the law of associativity. The next diagram is another
    illustration of the associativity of composition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8ef1f15-6cce-47ca-9a7b-f4f0c68ce59c.png)'
  prefs: []
  type: TYPE_IMG
- en: That diagram says that if the arrows exist from A→B→C→D, then if we start at
    A, we can use composition of functions to shortcut a set either by choosing the
    red path **ho(gof)** or the green path **(hog)of**.
  prefs: []
  type: TYPE_NORMAL
- en: Associativity helps us manage complexity. It is the basis for composition.
  prefs: []
  type: TYPE_NORMAL
- en: Only concerned with morphisms
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In a category theory, we only have objects and arrows between them.
  prefs: []
  type: TYPE_NORMAL
- en: We can compose functions by applying a function to an argument to get a result.
    Then, we apply another function to the result and so on, until we end up where
    we started.
  prefs: []
  type: TYPE_NORMAL
- en: We put all of our compositions in a table and only concern ourselves with the
    morphisms. It is the morphisms that define the interface for our application.
    What's important is how objects are connected/mapped.
  prefs: []
  type: TYPE_NORMAL
- en: Interface-driven development
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: One concept of the category theory that we can use when we develop software
    is that our design should be concerned only with interfaces, that is, the arrows/morphisms.
    We have seen the theme of composition repeated throughout this book. From Mozart
    compositions to function compositions with linear and quadratic functions, and
    later with finite state machines. We've seen that the way to solve complex problems
    is to break them apart into understandable pieces. We can then reach into our
    toolbox of pieces and compose elegant, reliable solutions. We design our **application
    programming interfaces** (**APIs**) to connect our pieces and can leverage concurrent
    programming constructs and concurrency-aware frameworks to arrange how the pieces
    work together to arrive at our desired result.
  prefs: []
  type: TYPE_NORMAL
- en: Design the architecture, name the components, document the details. Clear is
    better than clever. Don't communicate by sharing memory; share memory by communicating.
    Channels orchestrate; mutexes serialize. The bigger the interface, the weaker
    the abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: For more Go proverbs, visit: [https://www.youtube.com/watch?v=PAAkCSZUG1c](https://www.youtube.com/watch?v=PAAkCSZUG1c),
    and for *Concurrency Is Not Parallelism, *visit: [https://www.youtube.com/watch?v=cN_DpYBzKso](https://www.youtube.com/watch?v=cN_DpYBzKso).
  prefs: []
  type: TYPE_NORMAL
- en: More morphisms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The example below shows two identity morphisms and a morphism from A to B.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23f024a7-63fc-4025-98a4-01c54136f217.png)'
  prefs: []
  type: TYPE_IMG
- en: If we take A and any f to B and the Identity on **A (1A)**, then this composite
    f after the identity on A (**f** o **1A**) is equal to f.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s another way to look at it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6aff6f48-45d1-4bec-9b47-fa5e771a672b.png)'
  prefs: []
  type: TYPE_IMG
- en: If we take **A** and any **f** and we take the identity on **A**, then this
    composite **f** after the identity on **A** is equal to **f**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the morphism f from A to B:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb4c84db-0473-47b9-a902-db6132f6dc9d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And here''s a concrete example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/80334cbc-eb56-427b-a5ef-45d03bc822fc.png)'
  prefs: []
  type: TYPE_IMG
- en: The identity axiom says that if there is an arrow f from the identity of **A**
    to **B** and there is an arrow f from the identity of **B** to **B**, then the
    arrow from **A** to **B** is the same arrow **f**.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b4541002-bc1f-4737-8b81-9e5ebdcac7cf.png)'
  prefs: []
  type: TYPE_IMG
- en: The associativity axiom says that the composition of arrows is associative,
    which is another way of saying the diagram is commutative.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc412540-f44d-440d-8d2e-2c7edfdc8bf3.png)'
  prefs: []
  type: TYPE_IMG
- en: Therefore, for all arrows, 𝑓 ∶ 𝑎 → 𝑏, 𝑔 ∶ 𝑏 → 𝑐, and h ∶ 𝑐 → 𝑑, *h* ∘ 𝑔 ∘ 𝑓
    denotes *h* ∘ (𝑔 ∘ 𝑓).
  prefs: []
  type: TYPE_NORMAL
- en: 'And it follows the this is true: h∘(𝑔∘𝑓) = h∘𝑔∘𝑓 = (h∘𝑔)∘𝑓.'
  prefs: []
  type: TYPE_NORMAL
- en: A review of Category theory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Category theory is about composing functions.
  prefs: []
  type: TYPE_NORMAL
- en: '*A, B, C  = type = algebras/mathematical structure(homomorphisms)*'
  prefs: []
  type: TYPE_NORMAL
- en: Note that we no longer concern ourselves with the objects/elements inside the
    sets (only the arrows).
  prefs: []
  type: TYPE_NORMAL
- en: '*f = function = arrow that goes between objects (and maintains algebraic structure)*'
  prefs: []
  type: TYPE_NORMAL
- en: The **f** variable is a function that accepts arguments of type A and can, for
    example, return objects of type B.
  prefs: []
  type: TYPE_NORMAL
- en: '**Identity arrow** (**idA**) goes from A to A and does nothing. **f;g** (*composition*
    of 1 arrow after another) is a function that accepts arguments of type A and B,
    and returns C.'
  prefs: []
  type: TYPE_NORMAL
- en: '*idA;f  = f; idB  = f*'
  prefs: []
  type: TYPE_NORMAL
- en: There are three ways to compose two things: *(f;g);h = f;(g;h)*.
  prefs: []
  type: TYPE_NORMAL
- en: '*C (category C) = set* of all arrows in Category from A to C is in C.'
  prefs: []
  type: TYPE_NORMAL
- en: Even more correspondence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember the filter types (Read, Split, Transform, Merge, and Write) from our
    flow-based programming discussion in [Chapter 6](../Text/Ch06.xhtml), *Building
    on an Onion Architecture* (i*ncrease performance with pipelining*)? Let's see
    how flow-based programming corresponds to category theory, logic, and types.
  prefs: []
  type: TYPE_NORMAL
- en: Logic has and, or, and implication operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming has data records and function operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flow-based programming has merge, split, and transform operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/dd10fefd-97eb-44ef-9062-69e8a396270c.png)'
  prefs: []
  type: TYPE_IMG
- en: Category theory has arrows that are functions (that can also be data).
  prefs: []
  type: TYPE_NORMAL
- en: Just like a proposition in logic can be true or false, a type can be either
    inhabited or not. True propositions are inhabited. The void type is false. If
    we can produce an element of a type, then we have proven our proposition.
  prefs: []
  type: TYPE_NORMAL
- en: Table of morphisms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following table summarizes our basic operations, as well as our initial
    and terminal states:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/edad6217-bd3b-4f71-8daf-7d1a34def666.png)'
  prefs: []
  type: TYPE_IMG
- en: Morphism examples
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The *a → b* statement says that if we provide an element a to our function,
    then our function will produce an element of b. The same goes for logical implication:
    if a is true then b is true.'
  prefs: []
  type: TYPE_NORMAL
- en: If we have a function type *a ⇒ b* and pair it with an element of *a*, we get
    an element of b.
  prefs: []
  type: TYPE_NORMAL
- en: Modens ponens
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In Latin, modens ponens means, "the mode of affirming".
  prefs: []
  type: TYPE_NORMAL
- en: Type theory version
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*((a ⇒ b), a) → b* says that if we have function (a ⇒ b) and an argument a,
    it will produce b.'
  prefs: []
  type: TYPE_NORMAL
- en: Logic version
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If we know b follows from a and that a is true, then you can prove b.
  prefs: []
  type: TYPE_NORMAL
- en: '*a ⇒ b ∧ a → b*'
  prefs: []
  type: TYPE_NORMAL
- en: This is called Modens ponens also known as an implication.
  prefs: []
  type: TYPE_NORMAL
- en: Correspondence between logic and type theory
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Do you see the one-to-one correspondence between logic and type theory?
  prefs: []
  type: TYPE_NORMAL
- en: Add the category theory correspondence and we get the Curry Howard Lambek correspondence.
  prefs: []
  type: TYPE_NORMAL
- en: Cartesian closed category
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A cartesian closed category, where a product exists for any two elements and
    an exponential exists for any two elements, is a model for logic and type theory.
  prefs: []
  type: TYPE_NORMAL
- en: Though many categories have products and sums, only a few have map objects.
    Such categories are called cartesian closed categories.
  prefs: []
  type: TYPE_NORMAL
- en: There is a deep connection between λ-calculus, logic, and cartesian closed categories.
  prefs: []
  type: TYPE_NORMAL
- en: 'A **cartesian closed category** (**CCC**) is an abstraction having a small
    vocabulary with associated laws:'
  prefs: []
  type: TYPE_NORMAL
- en: The *category* part means we have a notion of *morphisms* each having a domain
    and codomain object. There is an identity morphism for and associative composition
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: The *cartesian* part means that we have products, with projection functions
    and an operator (`fst` or `snd` in Haskell) to combine two functions into a pair-producing
    function
  prefs: []
  type: TYPE_NORMAL
- en: The *closed* part means that we have a way to represent morphisms via objects,
    referred to as *exponentials*.
  prefs: []
  type: TYPE_NORMAL
- en: The corresponding operations are curry and apply. These exponential objects
    are first class functions.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions can be systematically translated into the CCC vocabulary.
  prefs: []
  type: TYPE_NORMAL
- en: A *CCC* is a category that is closed with respect to both products and exponentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what it looks like in terms of products and sums of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: See the correspondence to the following distributive law?
  prefs: []
  type: TYPE_NORMAL
- en: '*(a ∨ b) ∧ c = (a ∧c) ∨ (b ∧ c)*'
  prefs: []
  type: TYPE_NORMAL
- en: The objects in a CCC represent the types of the language, for example, strings,
    integers, and floats. The morphisms represent computable functions, for example,
    length(string). Exponential objects allow us to consider computable functions
    as the input to other functions.
  prefs: []
  type: TYPE_NORMAL
- en: Joachim Lambek discovered that the models of the simply typed λ-calculus (STLC) are
    exactly the cartesian closed categories (CCCs).
  prefs: []
  type: TYPE_NORMAL
- en: The generic type mechanism in Java is based on the generic type systems that
    originated in Lambda calculus. In fact, Java uses the Hindley-Milner Lambda calculus
    type inference, which is based on CCC.
  prefs: []
  type: TYPE_NORMAL
- en: We will revisit the topic of CCCs when we cover Mondads in a later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Unit type
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A tuple is a list of items that are ordered and immutable. You can select an
    element based on its position.
  prefs: []
  type: TYPE_NORMAL
- en: A unit type has exactly a one value. It is also known as the identity. The unit
    for multiplication is 1, for addition is 0, and for string concatenation, it is
    the empty string.
  prefs: []
  type: TYPE_NORMAL
- en: How many values can a type defined as a tuple of type `int` contain? Infinite
    (-∞, …, 0, 1, 2... ∞).
  prefs: []
  type: TYPE_NORMAL
- en: How many values can a type defined as the empty tuple contain? One. The *unit*
    is also represented as `()` in Haskell.
  prefs: []
  type: TYPE_NORMAL
- en: The value of a unit type is that you can use it in places where we might otherwise
    return nil (or null). We return a unit when we don't care what the value is. We
    don't return nil, we return a value; the unit value. All functions return values;
    no more null pointer exceptions! Now, we can chain functions and never worry that
    one on the middle with throw a null pointer exception and crash our program.
  prefs: []
  type: TYPE_NORMAL
- en: Homomorphism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s a Venn diagram depicting how the different categories of homomorphisms
    relate to one another:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/040b0267-99d7-46a0-89bd-6027ed1141fb.png)'
  prefs: []
  type: TYPE_IMG
- en: '| **Abbreviation** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Mono | Set of monomorphisms (injective) |'
  prefs: []
  type: TYPE_TB
- en: '| Epi | Set of epimorphism (surjective) |'
  prefs: []
  type: TYPE_TB
- en: '| Iso | Set of isomorphisms (bijective) |'
  prefs: []
  type: TYPE_TB
- en: '| Auto | Set of automorphisms (bijective and endomorphic) |'
  prefs: []
  type: TYPE_TB
- en: A homomorphism is a correspondence between set A (the domain) and set B (the
    codomain or range), so that each object in A determines a unique object in B and
    each object in B has an arrow/function/morphism pointing to it from A.
  prefs: []
  type: TYPE_NORMAL
- en: If operations, for example, addition and multiplication, are defined for A and
    B, it is required that they correspond. That is, *a * b* must correspond to *f(a)
    * f(b)*.
  prefs: []
  type: TYPE_NORMAL
- en: Homomorphisms preserve correspondence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Correspondence must be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single-valued**: The morphism must at least be a partial function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Surjective**: Each a in A has at least one f(a) in B'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Homomorphism is a way to compare two groups for structural similarities. It''s
    a function between two groups that preserve their structure. Suppose we have two
    groups, G and H. G and H have different group operations. Let''s also suppose
    that **G** has the group operation ☆ and H has the group operation (heart). Given
    any two elements in *G: a, b ∈ G*. And let''s suppose  a ☆ b = c. We also have
    a function f that maps **G** to *H: f: G→ H*. The elements a, b, and c are mapped
    to elements in H. The a variable maps to f(a), b maps to f(b), and c maps to f(c):'
  prefs: []
  type: TYPE_NORMAL
- en: '*f: a ↦ f(a)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*f: b ↦ f(b)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*f: c ↦ f(c)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The purpose of homomorphism is to find the structural similarities between two
    groups.
  prefs: []
  type: TYPE_NORMAL
- en: So, if in G, a ☆ b = c, then we like f(a) (heart) f(b) = f(c) in the group H.
  prefs: []
  type: TYPE_NORMAL
- en: 'a ☆ b = c  ⇒ f(a) (heart) f(b) = f(c) and since a ☆ b = c, we can substitute
    to get the definition of a homomorphism:'
  prefs: []
  type: TYPE_NORMAL
- en: f(a) (heart) f(b) = f(a ☆ b)
  prefs: []
  type: TYPE_NORMAL
- en: There's a way to compare two groups.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at an example. G is a group of real numbers (ℝ) with a group operator
    of addition (+) and identity operator 0, and H is a group of real numbers (ℝ)
    with a group operator of multiplication (*) and identity operator 1.
  prefs: []
  type: TYPE_NORMAL
- en: We can define the homomorphism that maps elements of G to H that maps element
    *a* to *ea*.
  prefs: []
  type: TYPE_NORMAL
- en: 'f: G ↦ H'
  prefs: []
  type: TYPE_NORMAL
- en: a ↦ ea
  prefs: []
  type: TYPE_NORMAL
- en: Let’s ensure that this is a homomorphism by verifying that f(a + b) = f(a) *
    f(b).
  prefs: []
  type: TYPE_NORMAL
- en: 'By the definition of f given above, this says that:'
  prefs: []
  type: TYPE_NORMAL
- en: '*ea + b = ea * ea*'
  prefs: []
  type: TYPE_NORMAL
- en: This is true. It is a rule of exponents. So, f is a homomorphism.
  prefs: []
  type: TYPE_NORMAL
- en: Homomorphic encryption
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Homomorphic encryption allows operations to be performed on ciphertexts without
    the knowledge of corresponding plaintexts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`EncryptFcn(a) (heart) EncryptFcn(b) = EncryptFcn(a ☆ b)`'
  prefs: []
  type: TYPE_NORMAL
- en: An example of homomorphic encryption
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Alice downloads a snippet of music she likes from an untrusted source and wants
    to use it to find the name of the song.
  prefs: []
  type: TYPE_NORMAL
- en: Bob has a song recognition capability and could identify the song for Alice.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f35c02e-f1fa-47a8-aea2-65a139641f39.png)'
  prefs: []
  type: TYPE_IMG
- en: The problem is that Alice and Bob do not trust each other.
  prefs: []
  type: TYPE_NORMAL
- en: Alice fears that if she gives Bob her snippet of music, Bob might turn her into
    the authorities. Bob could give Alice his music catalog but fears that she may
    sell it to his competitors.
  prefs: []
  type: TYPE_NORMAL
- en: The solution is for Alice to encrypt her music snippet and send that to Bob.
    Bob could find the encrypted result and send that back to Alice to decrypt.
  prefs: []
  type: TYPE_NORMAL
- en: Lesson learned
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We can perform complex collaborative operations without revealing private information
    through the use of cryptography and category theory.
  prefs: []
  type: TYPE_NORMAL
- en: Isomorphism
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, groups are more than just similar. If they are identical, they are
    isomorphic. Isomorphism is comprised of two Greek words that mean equal and form.
    In mathematics, isomorphism is a perfect one-to-one, bijective mapping between
    two groups (structures or sets). Every object in group A maps directly to an object
    in group B.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c7bccfb-c779-49ee-8b74-ef8456d4ad27.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In an isomorphism, every object in A is mapped to an object in B. The morphisms
    are also injective because no two objects from A map to the same object in B.
    So, if the objects in A are x, y, and z, then the following are not possible:
    `f(x) = f(y), f(x) = f(z), f(y) = f(z`). The only mappings we find are `x -> f(x),
    y -> f(y)`, and `z -> f(z)` and none of those three values are the same.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ca714ed-2a7f-4b8f-8901-90e60e05d3f6.png)'
  prefs: []
  type: TYPE_IMG
- en: This morphism is also surjective, since every object in codomain B has at least
    one mapping from domain A. Furthermore, since we have a one-to-one correspondence
    between every object in A and B. We can see that we've got both surjection and
    injection; this is also called a bijection.
  prefs: []
  type: TYPE_NORMAL
- en: Injective morphism
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An injective morphism is where every object in A maps to different object in
    B. Mappings to the same object in B are not allowed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/457eed58-25de-44a0-84e4-e59c467c3c5d.png)'
  prefs: []
  type: TYPE_IMG
- en: Surjective morphism
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Surjective morphism is where every object in the codomain B is connected to
    a morphism from the domain A. In other words, every object in B has the value
    of f(x), where x is in A. This mapping is called *many-to-one,* since there are
    more than one mappings from A to a single object in B.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11ce691e-4149-4c00-bcb1-02424b3399aa.png)'
  prefs: []
  type: TYPE_IMG
- en: Endomorphism
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If the objects are in the same set, the morphism is known as an endomorphism.
    In other words, the morphism maps back onto itself. An example of this would be
    a domain A of natural numbers (positive integers), morphisms comprised of addition
    and multiplication operations, and a range of B, which will consist of natural
    numbers. Another example would be the set of numbers 1 to 12 on a 12-hour analog
    clock.
  prefs: []
  type: TYPE_NORMAL
- en: SemiGroup homomorphism
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A semigroup is a set with an associative operation. Adding any two positive
    integers results in another positive integer; hence, addition is an associative
    property for natural numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Another example is a monoid with a unit morphism that acts as the identity operator.
    For example, the set of natural numbers and multiplication morphisms, whose unit
    morphism is the mutliplyByOne function, or the set of natural numbers and addition
    morphisms, whose unit morphism is the addZero function.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b2ebd323-545d-4c5e-bc53-b4ed8e6f2a06.png)'
  prefs: []
  type: TYPE_IMG
- en: SemiGroup Homomorphism Algebra
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider that we''re given semigroups (A, *) and (B, +) and a function f: A
    => B. Then f is a semigroup homomorphism if `f(x) + f(y) = f(x*y)` .'
  prefs: []
  type: TYPE_NORMAL
- en: Note that "+" is the operation in range B and "*" is the operation in the domain
    A.
  prefs: []
  type: TYPE_NORMAL
- en: So, a semigroup homomorphism is a mapping between two semigroups that preserve
    the semigroup operation.
  prefs: []
  type: TYPE_NORMAL
- en: Homomorphism table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following table contains the categories of homomorphisms that correspond
    to the Venn diagram of homomorphisms.
  prefs: []
  type: TYPE_NORMAL
- en: A → A
  prefs: []
  type: TYPE_NORMAL
- en: '| **Morphism** | **Description** | **Diagram** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| **Epi**- | Surjective "onto" |  ![](img/e87a0bfa-eb1d-43e5-8dde-ca3ba78923a3.png)A
    → B ⇉ C | ![](img/66fcffdf-715e-4006-ab7f-fe1b58b89f6d.png) |'
  prefs: []
  type: TYPE_TB
- en: '| **Mono**- | Injective "1 to 1" | ![](img/a9f4521c-a16d-4f3a-8cee-8ca21bbad66e.png)
    C ⇉ A → B | ![](img/548b8b4f-6993-45db-9c5f-de9bccad306c.png) |'
  prefs: []
  type: TYPE_TB
- en: '| **Iso**- | Bijective "onto" and "1 to 1" Bijective = Injective + Surjective'
  prefs: []
  type: TYPE_NORMAL
- en: Each element in the domain will have a corresponding element in the range (aka
    "codomain"). | ![](img/8a7d96d5-dfb8-411c-9bf2-004f464a61df.png) A ⇄ B | ![](img/a49eeef4-a5b0-451a-a4b5-12db3b88c0aa.png)An
    isomorphism between G and H. Ordered pairs:f(a) = 1, f(b) = 6,... f(j) = 7 |
  prefs: []
  type: TYPE_NORMAL
- en: '| **Endo**- | From a structure to itself. An endomorphism is an homomorphism
    whose domain equals the range. | ![](img/b0798445-c7ef-4428-961a-e611da50b5d2.png)
    A → A | ![](img/e791f956-01c1-4971-abf3-18b9fac98ea5.png)Same pixels, rearranged.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Auto**- | Bijective endomorphism is an endomorphism that is also an isomorphism;
    an isomorphism with itself. Automorphism = Bijective + Endomorphism | ![](img/e3fd3966-1a4f-40e2-95ee-82a616668e57.png)
    |'
  prefs: []
  type: TYPE_TB
- en: Car crash analogy
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We are looking at the same structures/ideas (decomposition, composition, transformation,
    and so on) from different points of view. Whether it's from a mathematical/algebraic/geometric,
    logical/syntactic, Lambda calculus or flow-based perspective, it's all the same
    thing. We just express the same concepts using different notations. It's sort
    of like asking four different individuals what they saw immediately after a car
    crash. They all saw the same thing, but the way it's expressed is differently.
    Considering all points of view can bring more clarity and provide better understanding.
  prefs: []
  type: TYPE_NORMAL
- en: Composable concurrency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functional programming is not only about composing functions and algebraic data
    structures--it makes concurrency composable--something that's virtually impossible
    with other programming paradigms.
  prefs: []
  type: TYPE_NORMAL
- en: How can we take what we've learned about morphisms and apply it to creating
    highly concurrent processing models? Suppose we start with a monolithic application
    with a single binary executable.
  prefs: []
  type: TYPE_NORMAL
- en: What if we can focus only on the morphisms, that is, the interface of inputs
    and outputs, in our system?
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider that we''re given the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Inputs and outputs can be mapped through isomorphisms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The state exists in the groupings of our objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Morphisms are stateless
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finite state machines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Can we assume that the finite state machines (FSMs) of our system exist within
    our groupings? (Where the FSM would be like the A and B groupings that we looked
    at previously.)
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine systematically decomposing our FSMs into the smallest possible
    components.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with our context component C, by observing behavior/morphisms and applying
    the Schreier Refinement Theorem and what we know about isomorphism, can we systematically
    decompose a large FSM into a grouping of the smallest possible FSMs of equivalent
    behavior?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/58656498-f5d8-4eaa-a080-27d33efe7f61.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s the first decomposition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/afc2b6a2-5122-4a0e-b4fb-944e69f840fd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s the second decomposition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2a1e98f-1552-4792-8863-295c8d222fa0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have been wiring up our components in parallel; we can also (de)compose
    them in serial:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1eda8918-5be2-4b15-bf96-50b5975b4582.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have a complete set of FSMs that comprise our system, we have filled
    our toolbox with the building blocks of our system. Now, we can rebuild our system
    by re-wiring our simple components and fitting them together in a distributed,
    microservice-based environment. Once we've tested our new configurations, we'll
    be in a position to deploy our building blocks and scale them horizontally.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ed090c6-eef5-447f-aa58-e29d8756aaea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This power and flexibility comes at some cost. In order to put our components
    to good use, we must build a framework to glue them together and sequence the
    work. We''ll need to think about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Compatibility of interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining how to partition our work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling morphisms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graph Database Example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Suppose we just got hired to build a graph database solution for a local college.
    First, we should build the information model. It might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2948b2f9-5f11-4f90-90ec-4572e5ee5c4e.png)'
  prefs: []
  type: TYPE_IMG
- en: Every course has one instructor and many students.
  prefs: []
  type: TYPE_NORMAL
- en: An instructor can teach more than one class.
  prefs: []
  type: TYPE_NORMAL
- en: An advisor has more than one student, but a student can have only one advisor.
  prefs: []
  type: TYPE_NORMAL
- en: A student may have more than one tutor, and a tutor may help more than one student.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/25d16cc6-3d4b-44b0-aa74-f384708ca0a0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have five sets of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Set | Description |'
  prefs: []
  type: TYPE_TB
- en: '| **A** | Instructors |'
  prefs: []
  type: TYPE_TB
- en: '| **B** | Courses |'
  prefs: []
  type: TYPE_TB
- en: '| **C** | Students |'
  prefs: []
  type: TYPE_TB
- en: '| **D** | Tutors |'
  prefs: []
  type: TYPE_TB
- en: '| **E** | Advisor |'
  prefs: []
  type: TYPE_TB
- en: 'Our actual database schema could look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5fa7cba4-1290-471a-9419-9f0973412b15.png)'
  prefs: []
  type: TYPE_IMG
- en: Using mathematics and category theory to gain understanding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's work with something we can relate to soccer!
  prefs: []
  type: TYPE_NORMAL
- en: How can we know the position of a ball in the air as it moves from Messi's foot
    into the goal?
  prefs: []
  type: TYPE_NORMAL
- en: Note that due to spin on the ball and the imbalance of air pressure, when in
    the air, the ball may curve left to right and up and sharply down.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out Messi''s curving goals here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/embed/CmSwaK6RsB4?start=11&end=15M](https://www.youtube.com/embed/CmSwaK6RsB4?start=11&end=15M)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/watch?v=rNlGmhFSkxw](https://www.youtube.com/watch?v=rNlGmhFSkxw)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Suppose we have a small soccer field with the dimensions of 50 yards X 100
    yards and a net that is 8 feet tall. The height of the goal is the z dimension:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23e24919-e68d-4ce3-8f42-78a4fc883f9f.png)'
  prefs: []
  type: TYPE_IMG
- en: If the sun is directly overhead and makes a shadow on the field, then we can
    know the x, y coordinates. If we can also measure the height of the ball as it
    moves, then we know the z coordinate. Combining both of those pieces of information,
    we can know the ball's position in the three-dimensional space.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/10f298af-00a0-4c58-a3d5-fab9db32b48c.png)'
  prefs: []
  type: TYPE_IMG
- en: The following diagram says that if we know A and B, then we also know C.
  prefs: []
  type: TYPE_NORMAL
- en: In category theory, this is called a product <f,g> of two sets of arrows, f
    and g.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/259b6ab1-3465-48a0-b5b9-6f1fcb129def.png)'
  prefs: []
  type: TYPE_IMG
- en: Given that first extracts A from AxB and second extracts B from AxB and h =
    <f,g>, we can say that `<f,g>; first = f` and `<f,g>; second = g.`
  prefs: []
  type: TYPE_NORMAL
- en: So, we have a commuting diagram. In other words, we have two paths <f,g> from
    C to AxB and first to A is equal to f, which goes from C to A, and vice versa
    for g.
  prefs: []
  type: TYPE_NORMAL
- en: The Universality Condition says that the only way to get from C to AxB is to
    apply <f,g> to C.
  prefs: []
  type: TYPE_NORMAL
- en: This diagram says that any arrow <f,g> is in one-to-one correspondence with
    the f and g arrows.
  prefs: []
  type: TYPE_NORMAL
- en: The cartesian product of the sets (C,A) x (C,B) is equal to the set (C, AxB).
  prefs: []
  type: TYPE_NORMAL
- en: In logic, this means if A is true and B is true then we know that A and B is
    true. So, the product is logical conjunction.
  prefs: []
  type: TYPE_NORMAL
- en: The identify function is depicted in the table. It says that the identity function
    of AxB is AxB. While this seems simple, it is important. The identity function
    is also known as the unit, which we've already discussed as it relates to types
    and will encounter again in the chapter about monads.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve seen the following laws for multiplication in elementary school:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Law** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| **Identity** | A x 1 = A and 1 x A = A |'
  prefs: []
  type: TYPE_TB
- en: '| **Associative** | A x (B x C) = (AxB) x C |'
  prefs: []
  type: TYPE_TB
- en: '| **Commutative** | A x B = B x A |'
  prefs: []
  type: TYPE_TB
- en: '| **Distributive** | A x (B + C) = (A x B) + (A x C) |'
  prefs: []
  type: TYPE_TB
- en: 'The following diagram depicts the identity law for a product in category theory.
    It says that the identity of AxB is the arrow pair of <first, second>:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7433e75-2208-463a-8fdd-9659fe677c75.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following diagram depicts the sum operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00fd4d03-b4ee-46ac-93b3-5c24cca35016.png)'
  prefs: []
  type: TYPE_IMG
- en: It says that there are two ways to build a sum, with inLeft or inRight.
  prefs: []
  type: TYPE_NORMAL
- en: In code, we'd need a case statement or an if/then statement to get the result.
  prefs: []
  type: TYPE_NORMAL
- en: The bracket in [f,g] indicates that the result is either f or g.
  prefs: []
  type: TYPE_NORMAL
- en: Our morphism must terminate if we are to have either a true sum or a true product.
  prefs: []
  type: TYPE_NORMAL
- en: Our diagram also says that an arrow from A+B is isomorphic with an arrow from
    A to C paired with an arrow from B to C; or formally, (A,C) x (B,C) = (A+B, C)
  prefs: []
  type: TYPE_NORMAL
- en: So, if we know A or we know B, we have proof of C. (This is also known as disjunction.)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/56e516dd-d44a-4fc2-a8b5-fc2ff0f466a2.png)'
  prefs: []
  type: TYPE_IMG
- en: The set theory equation is `A ∪ (B∩C) = (A∪B) ∩ (A∪C)`
  prefs: []
  type: TYPE_NORMAL
- en: For more information on distributive law, visit: [https://ncatlab.org/nlab/show/distributive+law](https://ncatlab.org/nlab/show/distributive+law).
  prefs: []
  type: TYPE_NORMAL
- en: Laws of exponentials for building a lambda expression
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Laws of exponentials for building a lambda expression are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2eadab28-61e4-4b84-a07b-32df3ae096bd.png)'
  prefs: []
  type: TYPE_IMG
- en: Table legend
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Gamma (Γ) represents the environment, that is, free variables paired with a
    bunch of types. We give names to free variables (for example, x of type A in the
    context, y of type B,...) and their type.
  prefs: []
  type: TYPE_NORMAL
- en: Turnstile (⊢) a ⊢ b means a is provable from b.
  prefs: []
  type: TYPE_NORMAL
- en: The term (M) represent expressions we write in a programming language.
  prefs: []
  type: TYPE_NORMAL
- en: We show types A and B.
  prefs: []
  type: TYPE_NORMAL
- en: For the top right law...
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Consider f represents the semantics (above) and curry(f) and we pair f and g
    to get A to B with a and apply it, categorically, exponentials give us implication
    A ⇒ B.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bottom left law:'
  prefs: []
  type: TYPE_NORMAL
- en: How do we know A implies B? By assuming A, we can prove B and we know A implies
    B.
  prefs: []
  type: TYPE_NORMAL
- en: If we know A implies B and we know A, then we can conclude B.
  prefs: []
  type: TYPE_NORMAL
- en: This is also known as modus ponens.
  prefs: []
  type: TYPE_NORMAL
- en: Sums and products
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What can we see when we compare the diagrams for sums and products?
  prefs: []
  type: TYPE_NORMAL
- en: If we were to flip the arrows, then they would be identical!
  prefs: []
  type: TYPE_NORMAL
- en: This is called a **Dual**. We say the *co* of a dual is the thing we started
    with.
  prefs: []
  type: TYPE_NORMAL
- en: Negation in logic is an example of a dual.
  prefs: []
  type: TYPE_NORMAL
- en: 'Category theory jokes:'
  prefs: []
  type: TYPE_NORMAL
- en: What are the morphisms in the category of cars? AUTO morphisms
  prefs: []
  type: TYPE_NORMAL
- en: A Priest, a Rabbi, and an Automorphism walk into a bar.... "I think we should
    talk, one-to-one", "We can't... He's onto us."
  prefs: []
  type: TYPE_NORMAL
- en: What does a categorical mathematician call a coconut?
  prefs: []
  type: TYPE_NORMAL
- en: Isomorphic equations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We have learned the following isomorphic equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '*(C,A) x (C,B) = (C, AxB)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*(A,C) x (C,B) = (A+B, C)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*(C x A,B) = (C, [A⇒B])*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In first equation, what does it mean to have an arrow from C to AxB?
  prefs: []
  type: TYPE_NORMAL
- en: 'A: We have a pair of arrows, an arrow from C to A and an arrow from C to B.'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly for 2 and 3.
  prefs: []
  type: TYPE_NORMAL
- en: If C is a finite set with exactly C objects in it, and A is a finite set with
    exactly A things in it, then how many ways are there to get from C to A?
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: There are A X C different ways of getting from C to A'
  prefs: []
  type: TYPE_NORMAL
- en: How many functions are there from n variables onto 2?
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: 2^n'
  prefs: []
  type: TYPE_NORMAL
- en: Do you see the direct correspondence between the categorical isomorphic equations
    and the laws of exponents we learned in high school?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/32d600db-94cd-4725-975e-11e08ba2f42e.png)'
  prefs: []
  type: TYPE_IMG
- en: Fun with Sums, Products, Exponents and Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s the sum of cows with tigers and elephants:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d09d84fa-bc0e-442f-9d00-d446a92579ae.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s a product of cows with tigers and elephants:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e47f7a3-ffd2-4eef-911c-c46aa6995979.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s the exponents of cows with tigers and elephants:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e0c100bd-258b-4e0a-85d0-e1b29eccf934.png)'
  prefs: []
  type: TYPE_IMG
- en: If we have a getCow method that will return DressedCows and if we have 3 types
    of DressedCows then if we call getCow then there are 3¹ possible DressedCows that
    it can return.
  prefs: []
  type: TYPE_NORMAL
- en: Note that functions with no arguments are Units. A Unit is a singleton type
    that carries no information. In [Chapter 9](../Text/Ch09.xhtml), *Functors, Monoids,
    and Generics*,we'll see how Units are useful when we build a 12-hour clock functor
    and when writing a reduce function. A Unit is our identity morphism.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/59258b9f-d2d3-4c07-9057-a4e290c32dd8.png)'
  prefs: []
  type: TYPE_IMG
- en: Looking at structures algebraically lets us find matching structure.
  prefs: []
  type: TYPE_NORMAL
- en: Once we've identified an isomorphism we have proven ways to optimize for memory
    usage, performance or data augmentation.
  prefs: []
  type: TYPE_NORMAL
- en: Proving what our code allows us to us it.
  prefs: []
  type: TYPE_NORMAL
- en: Proving what our code isn't prevents errors.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, types are a fundamental part of functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c98c2d34-9ad8-46ae-9eef-ac63311b2d70.png)'
  prefs: []
  type: TYPE_IMG
- en: Our sums are isomorphic to products. The tiger on the left and the tiger on
    the right are *dual* to each other. Same for the elephant and the football. A
    tiger's dual is called a cotiger. Similarly sums are called coproducts.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49b65af9-69c6-44f9-a54e-587422dd6d83.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A monomorphism is shown below. **f** is *monic*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c4d072d2-8e0a-48eb-afda-ac35b581e0fb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'An epimorphism is shown below. **f** is *epic*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/683a70a8-e237-437d-80da-329f9ae5366b.png)'
  prefs: []
  type: TYPE_IMG
- en: The following diagrams shows that monomorphisms are dual to epimorphisms.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1ea69afd-5d9c-4a33-ac71-924445c34667.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we don''t lose data going from tigers to elephants to tigers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1329f40-4346-491d-a223-6e3dcfdce68e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, we don''t lose data going from elephants to tigers to elephants:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a07790de-b31a-4a54-a638-354eba7e1b18.png)'
  prefs: []
  type: TYPE_IMG
- en: Then, our morphism are isomorphic.
  prefs: []
  type: TYPE_NORMAL
- en: Algebraic data structures give us certainty when move, map and transform data
    that we won't lose data.
  prefs: []
  type: TYPE_NORMAL
- en: It is essential to understand how our data structures are preserved during our
    workflows.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming brings us the certainty we need for data integrity as
    well as the composition we need to help manage complexity.
  prefs: []
  type: TYPE_NORMAL
- en: When Aubie goes to buy his tickets to the Iron Bowl he enters is order data...
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf534933-2b3f-4405-a547-dfe8e803e9a6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When he clicks the Submit button the data flows from one endpoint to another.
    As the data flows, it may be transformed in some way but the structure of the
    data is kept intact:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3371fc32-d0fd-4af0-a450-dd4bf550c046.png)'
  prefs: []
  type: TYPE_IMG
- en: Isomorphisms guarantee data integrity (no data loss). Computation uses data
    types to map morphisms. Interface definitions (using data types) allow us to connect
    functions. Immutable data structures can leverage memoization, improve concurrency,
    and reduce memory usage. Using FP in Go helps us to simplify our development process.
    We no longer need to worry about a whole classification of data/interface incompatibility
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Benefits of using FP an Go include better:'
  prefs: []
  type: TYPE_NORMAL
- en: performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: data reliability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: component reuse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: management of complexity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: resource utilization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Big data, knowledge-driven development, and data visualization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Big data implies there's a lot of data. When there is a lot of data, it becomes
    difficult to find meaning. The category theory helps us to remove the unimportant
    details and see the meaningful information that is there waiting to be discovered.
  prefs: []
  type: TYPE_NORMAL
- en: Data visualization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How can we apply what we've learned in the real world?
  prefs: []
  type: TYPE_NORMAL
- en: 'Composition sounds great but how can we go from this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e98700e3-ee70-46e4-80a7-14397eab3157.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And an I/O Monad:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4b578bfa-0468-4566-aacb-7195ff39ed43.png)'
  prefs: []
  type: TYPE_IMG
- en: To something useful.
  prefs: []
  type: TYPE_NORMAL
- en: We can read data from server logs and integrate a graphical user interface (GUI)
    that renders a presentation that our users can view and derive an understanding
    from the data that is presented in a meaningful way.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f8cd539c-5028-41c5-beba-08768c3f8845.png)'
  prefs: []
  type: TYPE_IMG
- en: What if our data had a corresponding schema?
  prefs: []
  type: TYPE_NORMAL
- en: 'Can we generalize the presentation of the data to different layouts? For example,
    spreadsheet programs allow their users to display different types of graphs based
    on the same set of rows and columns (pie charts, bar charts, and so on). If we
    can do that, then the following is feasible:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e31d8175-e4e2-47f5-916f-913f396bfe97.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the practical side of things, the data from our log files might feed into
    tables with rows and columns, much like a spreadsheet. From the category side,
    we could say that our schema is a Cartesian product of object instances and their
    attributes: Schema = Instances x Attributes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then combine our diagrams to get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/58bbf8fc-cd35-476b-9c12-b81ddf5c6ea0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, if we want to allow our users to input queries to gain a working knowledge
    of their domain, we could arrive at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f47ccad-f0b3-459c-bb7b-29424570d637.png)'
  prefs: []
  type: TYPE_IMG
- en: The category shown here defines a well-formed vizualisation process; if the
    arrows, objects, and data are accurate, then the diagram will commute. We can
    be confident that the knowledge we gain is reliable.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e8c54bb-9e39-431f-92c3-247822fe86cc.png)'
  prefs: []
  type: TYPE_IMG
- en: Knowledge-driven systems can make the difference between success and failure.
    Our proverbial hay stack could be every interaction, every gesture of body language/facial
    expression, words spoken, commitments kept/broken, and so on. If our key performance
    indicator is the health of our relationship, a knowledge-based system could sift
    through the minutia and highlight the one remark that mattered, "*I wish you would
    stop work and greet me when I arrive.*"
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we need to start with the correct data set. If our goal is to find
    the next great location to build a shopping mall, we could gather two data sets,
    one for all cell phone records and another of population demographics. Though
    both sets of data have copious amounts of data that don't provide guidance, if
    we build our system with rules designed to find the actionable needles of truth,
    the given geolocation information of both cell phone records and demographics
    combined with income statistics, our system could bring to light the most ideal
    locations for our investors.
  prefs: []
  type: TYPE_NORMAL
- en: You might be thinking, "*I can do that with my imperative language.*" Perhaps,
    but will it scale?
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned what we need to know about category theory to be
    dangerous. We walked through history together, learning how functional programming
    came to be what it is today. We looked at logical propositions and proofs, sets,
    objects, and arrows as well as Lambda calculus. We shared in the amazement of
    the correspondence between category theory, logic, and Lambda calculus. And you
    saw how to apply what you learned in real-world scenarios (such as the flight
    of a soccer ball and doing business with untrusted partners). Lastly, we gained
    insight into how to design knowledge-based systems to derive value from big data.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll dig deeper into pure functional programming. We'll
    see how to leverage category theory and class types to abstract away details in
    order to glean new insights. We'll look at functors, along with slightly stronger
    and more useful versions of functors called applicative functors. We'll also learn
    how to bring the world of side-effects under control using monads and monoids.
  prefs: []
  type: TYPE_NORMAL
