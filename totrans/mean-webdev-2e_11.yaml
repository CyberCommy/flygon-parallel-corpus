- en: Chapter 11. Automating and Debugging MEAN Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In previous chapters, you learned how to build and test your real-time MEAN
    application. You learned how to connect all the MEAN components and how to use
    test frameworks to test your application. While you can continue developing your
    application using the same methods used in the previous chapters, you can also
    speed up development cycles using supportive tools and frameworks. These tools
    will provide you with a solid development environment through automation and abstraction.
    In this chapter, you''ll learn how to use different community tools to expedite
    your MEAN application''s development. We''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using NPM scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Webpack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing ESLint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Nodemon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging your Express application using V8 inspector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging your Angular application's internals using Angular Augury
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using NPM scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you may have noticed, developing our application involves the operation
    of several tasks together. For instance, in order to run our application, we''ll
    need to transpile our Angular files and then run our Express application. This
    pattern will repeat itself and even get more complicated. To solve this, developers
    prefer to automate some of the application functionality and use supportive tools
    to speed up their work. Some developers prefer using third-party tools, such as
    Grunt or Gulp, also known as task runners; however, we already use a tool that
    allows us to run scripts, a tool called NPM. To understand this better, take a
    look at your `package.json` file''s `scripts` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, you already have five scripts to manage your application developments.
    In the following sections, we'll learn how to add more scripts and how to use
    this NPM feature to help you automate your daily job. We'll begin with the Webpack
    module bundler.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Webpack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Webpack is a popular module bundler created by Tobias Koppers. It has taken
    over the world of JavaScipt and has become one of the most used tools in our ecosystem.
    As an alternative to other module bundlers, such as SystemJS (which we used up
    until now), it has a pretty straightforward motivation: to simplify code bundling,
    modularizing big applications, and code splitting. However, after a few years
    of active development, it can now do much more, including features such as asset
    bundling, preprocessing, and optimization. In our modest introduction, though,
    we''ll learn how to simply replace SystemJS to bundle and load our Angular modules.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is highly recommended that you learn more about Webpack by visiting the official
    project page at [https://webpack.github.io/](https://webpack.github.io/).
  prefs: []
  type: TYPE_NORMAL
- en: Installing Webpack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can start configuring our Webpack implementation, we will need to
    install Webpack''s dependencies using `npm`. To do that, change your `package.json`
    file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, you added Webpack and a TypeScript loader to your `devDependencies`
    property. We also added a Webpack script to run Webpack in a "Watch" mode so that
    every change to our file is automatically updated. We then changed our NPM start
    script to use Webpack instead of transpiling our Angular files using the TypeScript
    command-line tool. To install your new dependencies, go to your application''s
    root folder and issue the following command in your command-line tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This will install the specified versions of Webpack and TypeScript loader in
    your project's `node_modules` folder. When the installation process is successfully
    finished, you will be able to use these modules to run Webpack and bundle your
    TypeScript modules. Next, you'll learn how to configure Webpack.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Webpack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to control Webpack''s execution, you will need to configure Webpack
    using a special configuration file placed in the root folder of your application.
    When executed, Webpack will automatically look for the default configuration file
    named `webpack.config.js` in the application''s root folder. You can also indicate
    your configuration file name using a command-line flag, but for simplicity, we''ll
    use the default filename. To start configuring Webpack, create a new file in your
    application root folder, and name it `webpack.config.js`. In your new file, paste
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, Webpack''s configuration file is used to set the way Webpack
    builds our modules. In this case, we used the following settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`entry`: This tells Webpack what the entry point of our application is. Don''t
    worry if you don''t recognize these files; we''ll create them in the next step.
    All you need to understand is that we bundle our application into three different
    files: our polyfills file, which will include all the polyfills-related modules,
    our vendor file, which will include all of our third-party modules—such as Angular
    core modules—and our application file, which will include our Angular application
    files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`devtool`: This tells Webpack which development tool to use; in this case,
    we want Webpack to create map files for transpiled application files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resolve`: This tells Webpack what kind of module extensions to resolve; in
    this case, it will include module imports without extensions, TypeScript, and
    JavaScript files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`output`: This sets the way Webpack saves the output files. Here, we tell it
    we want to create the bundled files in a `public/build` folder with a JavaScript
    file extension.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`module`: This is a list of modules Webpack will use. In our case, we tell
    Webpack to load all TypeScript files using the TypeScript loader we previously
    installed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`optimize`: This sets the way Webpack optimizes module bundling. In our case,
    we want Webpack to bundle every module once. This means that if Webpack finds
    a common module import in the Bootstrap file and the Vendor file, it will bundle
    it only once in the vendor file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that these properties are project-oriented, which means that it will change
    according to your requirements. We''ll continue by creating our missing files.
    First, go to your `public` folder and create a file named `polyfills.ts`. In this
    file, paste the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we included all of our polyfills libraries. Next, we''ll create
    a file named `vendor.ts`; in this file, paste the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we included all of our core modules of the Angular and RXJS
    libraries. To finish up, we''ll copy our previous `bootstrap.ts` file to the `public`
    folder. To do that, go to your `public` folder and create a file named `bootstrap.ts`.
    In this file, paste the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this is our application bootstrap file from previous chapters.
    All we have left to do is change our main application page. To do that, go to
    the `app/views/index.ejs` file and make the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we just replaced our older scripts with the new bundled script
    files. Once you are finished with these changes, your Webpack configuration should
    be ready for use! Use your command-line tool and navigate to the MEAN application''s
    root folder. Then, run your application by typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Once your application is running and Webpack finishes bundling your code, navigate
    to `http://localhost:3000/` and test your application. This is, of course, just
    a basic setup, so it is highly recommended that you continue learning about Webpack's
    other features.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing ESLint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In software development, linting is the identification of suspicious code usage
    using dedicated tools. In a MEAN application, linting can help you avoid common
    mistakes and coding errors in your daily development cycles; moreover, it will
    allow you to set a unified code styling across your team. The most commonly used
    linting tool in our ecosystem is called ESLint. ESLint is a pluggable linting
    utility originally created by Nicholas C. Zakas in 2013\. It allows us to lint
    our JavaScript code using a set of rules and preset configurations. We'll begin
    by installing the ESLint package in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is highly recommended that you learn more about ESLint by visiting the official
    project page at [http://eslint.org/](http://eslint.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Installing ESLint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can start configuring our ESLint execution, we will need to install
    the ESLint package using `npm`. To do that, change your `package.json` file as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, you added, ESLint package to your `devDependencies` property.
    You also added a `lint` script to run ESLint and a lint JavaScript file placed
    in your `app` and `config` folders. To install your new dependencies, go to your
    application''s root folder and issue the following command in your command-line
    tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This will install the specified version of the ESLint package in your project's
    `node_modules` folder. Next, you'll learn how to configure ESLint.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring ESLint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to control ESLint''s execution, you will need to configure it using
    a special configuration file placed in the root folder of your application. When
    executed, ESLint will automatically look for the default configuration file named
    `.eslintrc` in the application''s root folder. Create a new file in your application''s
    root folder and name it `.eslintrc`. In your new file, paste the following JSON
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this simple configuration basically tells ESLint that our code
    is written in ECMAScript 6\. However, ESLint can do so much more; for instance,
    you can tell ESLint to validate our code indentation by changing the configuration
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This will tell ESLint to expect a two space indentation in our code files.
    Moreover, usually, you''ll extend an existing configuration file using the `extend`
    property, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This will extend ESLint''s recommended rule set. However, these are just simple
    examples, so it is recommended that you continue learning about ESLint in order
    to find the best configuration for your project. To run your lint task, go to
    your command-line tool and execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The linting results should be reported in your command-line tool and will be
    similar to what is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring ESLint](img/B05071_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: ESLint results
  prefs: []
  type: TYPE_NORMAL
- en: ESLint is a powerful tool. However, in this form, you would need to run the
    `lint` task manually. A better approach would be to automatically run the lint
    task whenever you modify a file.
  prefs: []
  type: TYPE_NORMAL
- en: Using Nodemon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Running your application using the Node''s command-line tool may not seem like
    a redundant task. However, when continuously developing your application, you
    will soon notice that you stop and start your application server quite often.
    To help with this task, there is a common tool called Nodemon. Nodemon is a Node.js
    command-line tool that functions as a wrapper to the simple node command-line
    tool, but watches for changes in your application files. When Nodemon detects
    file changes, it automatically restarts the node server to update the application.
    To use Nodemon, you will need to modify your project''s `package.json` file, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we added the Nodemon package to our development dependencies.
    We also added two new scripts and changed our `start` script. The first script
    we added is `app:dev`, which runs the `lint` and `app` scripts. Next, we created
    a `nodemon` script, which watches all of our server JavaScript files and runs
    the `app:dev` script whenever a file is modified. In our `start` script, we just
    execute our Webpack and Nodemon scripts concurrently. This is it! All you have
    left to do is install the Nodemon package by going to your application root folder
    and issuing the following command in your command-line tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run your application using the regular `start` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This will start your application with the new setup. Try changing your Angular
    or Express application files; note that your application restarts if you change
    a server file and the way Webpack automatically compiles your code when you change
    an Angular file.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging Express with V8 inspector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Debugging the Express part of your MEAN application can be a complicated task.
    Fortunately, there is a great tool that solves this issue called V8 inspector.
    V8 Inspector is a debugging tool that uses the Blink (a WebKit Fork) Developer
    Tools. In fact, developers using Google''s Chrome browser are already familiar
    with it, in the form of the Chrome Developer Tools interface. The V8 inspector
    supports some pretty powerful debugging features:'
  prefs: []
  type: TYPE_NORMAL
- en: Source code file navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breakpoint manipulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stepping over, stepping in, stepping out, and resuming execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable and property inspection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Live code editing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To debug your application, you will need to access the V8 inspector interface
    using a compatible web browser. You will then be able to use it to debug your
    application code using the Chrome Developer Tools interface. To do that, all you
    have to do is add a debug script to your `package.json` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In your new script, all you did was run your application with two command-line
    flags. The `inspect` flag allows the attachment of the Chrome Developer Tools
    to our Node.js instance, and the `debug-brk` flag prevents Node.js from running
    your code before you attach the debugger. Next, we'll run our application using
    the new script and see how we can debug it.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use your new `debug` script, navigate to your application''s root folder
    and issue the following command in your command-line tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This will run your application in a debug mode and wait for you to attach the
    Chrome Developer Tools debugger. The output in your command-line tool should be
    similar to what is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging your application](img/B05071_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Running in Debug mode
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the `debug` script invites you to start debugging the application
    by visiting `chrome-devtools://…` using a compatible browser. Open this URL in
    Google Chrome, and you should see an interface similar to what is shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging your application](img/B05071_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Debugging with V8 inspector
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, you'll get a list of your project files in the left-hand side
    panel, a file content viewer in the middle panel, and a debug dashboard in the
    right-hand side panel. This means that your `debug` script is running properly
    and is identifying your Express project. You can start debugging your project
    by setting some breakpoints and testing your application's behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Node inspection will only work on browsers that use the Blink engine, such as
    Google Chrome or Opera. Furthermore, this feature is still experimental. So, it
    is recommended that you stay updated on the official Node.js documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging Angular applications with Angular Augury
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging most of the Angular part of your MEAN application is usually done
    in the browser. However, debugging the internal operations of Angular can be a
    bit trickier. For this purpose, a joint team from Google and Rangle.io created
    a Chrome extension called Angular Augury. Angular Augury extends the Chrome Developer
    Tools with a new tab where you can debug different aspects of your Angular application.
    Installing Angular Augury is quite straightforward. All you have to do is visit
    the Chrome web store at [https://chrome.google.com/webstore/detail/augury/elgalmkoelokbchhkhacckoklkejnhcd](https://chrome.google.com/webstore/detail/augury/elgalmkoelokbchhkhacckoklkejnhcd)
    and install the Chrome extension.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Angular Augury will work only on the Google Chrome browser.
  prefs: []
  type: TYPE_NORMAL
- en: Using Angular Augury
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you''re done installing Angular Augury, use Chrome to navigate to your
    application URL. Then, open the Chrome Developer Tools panel, and you should see
    an **Angular** tab. Click on it and a panel similar to what is shown in the following
    screenshot should open:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Angular Augury](img/B05071_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Angular Augury
  prefs: []
  type: TYPE_NORMAL
- en: The component tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our Angular application is built as a tree of components. Augury allows us
    to inspect these components in a hierarchical way; in order to understand this
    better, take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The component tree](img/B05071_11_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Augury Component Tree
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we''re inspecting the `ViewComponent` from our articles module.
    Since our components router is based on a simple hierarchy you can notice that
    we also see `AppComponent` and `ArticlesComponent`. On the right side you can
    notice we have two tabs: **Properties** and **Injector Graph**. In the **Properties**
    tab you''ll find the component state including the `article` and `user` properties
    and the component dependencies. The state is editable so it allows you to change
    your component state and see the impact on the rendering of `ViewComponent`. Furthermore,
    if we inspect `CreateComponent`, you''ll be able to see how Augury works with
    forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The component tree](img/B05071_11_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Augury with forms
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, you can inspect your form state and understand its internal
    status. If you edit the value of your form inputs, you''ll also be able to see
    it''s state updated live on the right pane. If you click on the **Injector Graph**
    option, you''ll be able to see how Angular''s injector works and the current component''s
    injected providers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The component tree](img/B05071_11_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Augury Injector Graph
  prefs: []
  type: TYPE_NORMAL
- en: Note how the `Router` and `ArticlesService` providers are injected to `CreateComponent`.
    In bigger applications, this will give you a better understanding of your project
    state.
  prefs: []
  type: TYPE_NORMAL
- en: Router tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To explore your Angular application routes, you can click on the **Router Tree**
    tab. Before you do that, you''ll need to inject the router provider inside your
    application component as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you do that, you''ll be able to see a panel similar to what is shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Router tree](img/B05071_11_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Augury Router tree
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the **Router Tree** tab allows you to understand your application
    routing scheme in an easy-to-understand graph.
  prefs: []
  type: TYPE_NORMAL
- en: Angular Augury is a simple yet powerful tool. Used right, it can save you a
    lot of time endlessly looking around and using console logging. Make sure you
    understand each tab and try to explore your application yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to automate your MEAN application's development
    and how to debug the Express and Angular parts of your application. We started
    with a brief explanation of NPM scripts. We then discussed Webpack and its powerful
    features, and you learned how to restart and lint your application automatically.
    Then, you learned how to use the V8 inspector tool to debug your Express code.
    Towards the end of this chapter, you learned about the Angular Augury Chrome extension.
    You went through Angular Augury's features and found out how to debug your Angular
    internals.
  prefs: []
  type: TYPE_NORMAL
- en: Since it's the last chapter of this book, you should now know how to build,
    run, test, debug, and easily develop your MEAN application.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is up to you.
  prefs: []
  type: TYPE_NORMAL
