- en: 'Chapter 10: Working with Azure Kubernetes Service'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we explored the world of container virtualization,
    and in particular Docker containers. This chapter is all about managing containerized
    workloads using **Azure Kubernetes Service** (**AKS**).
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is different from all the other chapters in this book. Until now,
    every chapter has been about infrastructure and providing a platform: the classic
    system administrator working in the cloud. Even *Chapter 9*, *Container Virtualization
    in Azure*, contained questions such as ''''How do we install Docker?'''' and ''''How
    do we get the container up and running?'''' The questions we''ll answer in this
    chapter are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How do we deploy and manage our workload during the development phase and afterward?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we scale up/down?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the availability options?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes provides an important answer to all of these questions. It is a solution
    that is used to automate important tasks such as the deployment, management, scaling,
    networking, and management of the availability of container-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes was originally designed by Google and is now maintained by the Cloud
    Native Computing Foundation ([https://www.cncf.io](https://www.cncf.io)). Microsoft
    is a big partner of this foundation and is an important contributor to Kubernetes
    projects in terms of money and code. Actually, one of the co-founders of Kubernetes,
    Brendan Burns, works for Microsoft and leads the teams that work on container
    orchestration within Microsoft. On top of that, Microsoft has started several
    open source projects with additional tooling for Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Because Microsoft is so heavily involved in Kubernetes, it is able to implement
    a version of Kubernetes in Azure that is fully upstream-compatible. This is also
    important for developers so that they can use a local Kubernetes installation
    to develop software, and when the development is done, release it to the Azure
    cloud.
  prefs: []
  type: TYPE_NORMAL
- en: AKS provides a fully managed containers-as-a-service solution for Kubernetes.
    This means that you don't have to think about the configuration, management, and
    upgrading of the Kubernetes software. The control plane is managed by Azure.
  prefs: []
  type: TYPE_NORMAL
- en: 'AKS makes it easy to deploy and manage Kubernetes within Azure: it can handle
    the complete maintenance process, from provisioning to keeping your applications
    up to date and upscaling as per your needs.'
  prefs: []
  type: TYPE_NORMAL
- en: Even the process of upgrading your Kubernetes cluster without any downtime can
    be done with AKS.
  prefs: []
  type: TYPE_NORMAL
- en: And last but not least, monitoring is available for every part of your Kubernetes
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you''ll be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Explain what Kubernetes and AKS are.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use AKS to deploy and manage your clusters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintain the complete life cycle of your applications in AKS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's go ahead and first understand what the technical requirements are
    before we actually start using AKS.
  prefs: []
  type: TYPE_NORMAL
- en: Technical Requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As stated in the introduction of this chapter, this chapter is different from
    all the other chapters and this affects the technical requirements. Until now,
    the technical requirements were simple: you just needed a bunch of virtual machines.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter needs a DevOps environment in which developers and operators are
    in the same team, working closely together, and where there is also someone who
    is doing both development- and operations-related tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another choice has to be made: where do we develop? Locally, or in the Azure
    cloud? Both are possible and it shouldn''t make any difference! Cost-wise, it
    may be better to do it on a workstation. In this chapter, it''s sort of assumed
    that you''re doing it locally. So, you''ll need a workstation (or virtual machine).
    We need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The Azure CLI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker and build tools.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some essential developer tools, such as Git.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some other tools, such as Helm, covered later on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A good **integrated development environment** (**IDE**). We prefer Microsoft
    **Visual Studio** (**VS**) Code with the Microsoft extensions for Docker and Kubernetes
    (only if a graphical interface is available; otherwise, use the Nano editor).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optionally, an orchestration tool such as Ansible. Please have a look at the
    Ansible `azure_rm_aks` and `8ks_raw` modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using WSL and VS Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use **Windows Subsystem for Linux** (**WSL**) and VS Code along with
    the VS Code Remote WSL extension to get a Linux development environment on your
    Windows desktop or laptop without the overhead of having a virtual machine. This
    will enable you to access your Linux files from PowerShell or CMD and your Windows
    files from Bash. VS Code is a source code editor that can run on various platforms
    and supports many languages. You can develop, run, and debug Linux-based applications
    from your favorite Windows platform using WSL and VS Code. WSL features can be
    enabled using PowerShell and by installing Linux from the Microsoft Store. VS
    Code is available for Windows and Linux and can be downloaded from [https://code.visualstudio.com/](https://code.visualstudio.com/).
    Since the configuration settings of VS Code are maintained across both Windows
    and Linux platforms, you can easily switch back and forth from Windows to Linux
    and Linux to Windows.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the step-by-step tutorial for WSL at [https://docs.microsoft.com/en-us/learn/modules/get-started-with-windows-subsystem-for-linux/](https://docs.microsoft.com/en-us/learn/modules/get-started-with-windows-subsystem-for-linux/)
    and a detailed installation guide at [https://docs.microsoft.com/en-us/windows/wsl/install-win10](https://docs.microsoft.com/en-us/windows/wsl/install-win10).
    You can configure default shells and choose between PowerShell and WSL when running
    on Windows, and you can choose Zsh or Bash on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are going to use Ubuntu 18.04 LTS Desktop edition. But you can use an Ubuntu
    18.04 LTS server in an Azure virtual machine as well. With all the knowledge that
    you''ve gained in the other chapters, it''s easy to transfer what we''ll be doing
    to other Linux distributions, macOS, and even Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, upgrade Ubuntu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the developer tools, including some other dependencies and `openssh`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: First, we are going to install the Azure CLI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can install the Azure CLI by running a single command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you can use the following instructions for manual installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Get the required package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Get and install the signing key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To install PowerShell and VS Code, we are using snaps, universal software packages
    similar to portable apps for Windows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use the following commands to install PowerShell Core:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Type `pwsh` to start PowerShell Core:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If the PowerShell Core starts successfully, you will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the pwsh command to start PowerShell Core](img/B15455_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: Starting PowerShell Core'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Install the Azure cmdlet for Azure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Install Docker:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the Docker version details as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting the Docker version details](img/B15455_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: Docker version details'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Stop Docker for now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: kubectl Installation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'kubectl is a command-line interface that can be used to manage your Kubernetes
    clusters. It can be used for many operations. For example, use `kubectl create`
    to create one or more files and use `kubectl delete` to delete resources from
    a file. We are going to use the Azure CLI to install `kubectl` and execute the
    following commands as root to grant the required permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'First, you need to download the latest release using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, make it executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, move it to your `PATH`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify the installation by asking for the version information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable autocompletion, which could save you from a lot of typing. For Bash
    and Zsh in `kubectl`, execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'For Zsh, execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: So far, we have installed the latest version of the kubectl binary with a `curl`
    command on Linux and enabled shell auto-completion for kubectl. We are now ready
    to use AKS.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you are using kubectl and you get error messages similar to `Error from
    server (NotAcceptable): unknown (get nodes)`, downgrade your client using `https://dl.k8s.io/v1.10.6/kubernetes-client-linux-amd64.tar.gz`.'
  prefs: []
  type: TYPE_NORMAL
- en: Though this is completely outside the scope of this book, we personally like
    to use the Zsh shell with a nice customization called Spaceship. The prompt gives
    you more insight into where you are and what you are doing while working with
    AKS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the quick installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Starting to Use AKS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Azure AKS makes it easy to deploy and manage your container applications. You
    can quickly define, deploy, and debug Kubernetes applications in addition to automatically
    containerizing your applications using Azure AKS. You can automate the monitoring,
    upgrading, repair, and scaling, which reduces the manual infrastructure maintenance.
    With kubectl installed, it''s time to set up and explore the Kubernetes environment
    in Azure:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a cluster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find information about the cluster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy a simple workload.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a Cluster with the Azure CLI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Kubernetes, we're going to work with clusters. A cluster contains a master
    or control plane that is in control of everything and one or more worker nodes.
    In Azure, we don't have to care about the master, only about the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s a good idea to make a new resource group for the purposes of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In this resource group, we will deploy our cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This command can take up to 10 minutes. As soon as you get your prompt back,
    verify it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the output, you''ll find a lot of information, such as the fully qualified
    domain name, the name of the cluster, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting the details of the cluster deployed](img/B15455_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: Details of the deployed cluster'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'There is a web interface available called Kubernetes Dashboard that you can
    use to access the cluster. To make it available, execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Point your browser to `http://127.0.0.1:8001`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Kubernetes Dashboard with the details of the cluster and the resource
    group](img/B15455_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.4: Kubernetes Dashboard'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `az` utility is tunneling the portal to your localhost. Press *Ctrl* + *C*
    to exit the tunnel.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to use the `kubectl` utility, we need to merge the configuration
    into the local configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the az aks get-credentials command to merge the configuration into
    the local configuration file](img/B15455_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.5: Merging the configuration into the local configuration file'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Thanks to our fancy Command Prompt, you can see that we switched from our local
    Kubernetes cluster to the cluster in Azure. To see the available clusters, execute
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing the available clusters using the kubectl config get-contexts command](img/B15455_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.6: Viewing the available clusters'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can switch to the other cluster using `kubectl config use-context <cluster>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also find information about your cluster using `kubectl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting the detailed information about the cluster using the kubectl cluster-info
    command](img/B15455_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.7: Information about the cluster'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We created a Kubernetes cluster here called `Cluster01` using the `az aks create`
    command. Now let''s list the nodes, which are the worker machines of Kubernetes
    and are managed by a master node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Listing the nodes with the kubectl get nodes command](img/B15455_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.8: Listing the nodes'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: First Deployment in AKS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'AKS allows you to build and deploy applications into a managed Kubernetes cluster,
    which manages the connectivity and availability of your containerized application.
    You can use a simple `kubectl create` command to deploy a Docker container in
    AKS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'And within seconds, there is a message: `deployment.apps/nginx created`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify the deployment using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the kubectl get deployment command to verify the deployment](img/B15455_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.9: Verifying the image deployment'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'When we executed the `run` command, the Docker container was deployed in the
    cluster. Or, more specifically, a pod was created with the container running in
    it. A pod is a group of containers with shared resources, such as storage and
    network resources and it also contains the specification for how to run the containers.
    To see the created pod, execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command returns the list of pod names, pod statuses
    (running, pending, succeeded, failed, or unknown), the number of restarts, and
    the uptime, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting the detials of the pods with the kubectl get pods command](img/B15455_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.10: Details of the pods'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Pods come and go; they are created dynamically while scaling up/down, among
    other things. Using the `explain` command, you can find all kinds of information
    about the pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s delete the pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Execute `kubectl get pods` again; you should see that a new pod is available.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'But actually, you shouldn''t care about the pod: the service is what''s important.
    A service is an object that makes the application accessible to the outside world.
    Behind the service, there are one or more pods. The service keeps tracks of the
    pods and their IP addresses, and it is an abstraction of a logical set of pods
    and their policies. You can use the following command to list all the services
    in a namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Listing all the services in a namespace with the get services command](img/B15455_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.11: Listing all the services in a namespace'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Only one service is found, `CLUSTER-IP`. More details can be found using the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '![Getting the description of the services within Kubernetes](img/B15455_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.12: Getting the description of the Kubernetes services'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let''s get rid of our first deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '![Executing the kubectl delete deployment nginx command to delete the first
    deployment](img/B15455_10_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.13: Deleting the first deployment'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let''s create a new one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '![Creating a new image for nginx](img/B15455_10_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.14: Creating a new nginx image'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Please note that we didn''t expose the ports. Let''s list the pods using `kubectl
    get pods`. To make the resource accessible, we add a service of the `LoadBalancer`
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Listing the pods and adding a service of the LoadBalancer type](img/B15455_10_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.15: Listing the pods and adding a service of the LoadBalancer type'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Use the `EXTERNAL-IP` address in your browser. It will show you the welcome
    page of `nginx`.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-Container Pods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A pod is also an abstraction layer used by Kubernetes to maintain the container.
    There are many use cases and real-world scenarios to have multiple containers
    in a single pod to support microservices container applications to communicate
    with each other, as shown in the following diagram. The persistent storage in
    this diagram shows how each container communicates for read and write operations
    during the life of the pod and the shared persistent storage data is lost when
    you delete the pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A block diagram depiciting the architecture of multi-container pods](img/B15455_10_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.16: Architecture of multi-container pods'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'But there are use cases that are based on the fact that a pod provides shared
    resources for the containers within the pod, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Containers with helper applications such as logging and monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reverse proxies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Until now, we used the `—image` parameter to create a simple pod. For a more
    complex pod, we need to make a specification in YAML format. Create a file called
    `myweb.yaml` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In this file, a shared volume is created, called `journal`. The `emptydir` directive
    makes sure that the volume is created while creating the pod.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify, execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This command executes in the `myweb` pod on the `nginx` container by using the
    `findmnt` command. We have created containers, pods, and shared storage. Now let's
    shift our focus to Helm, which is the package manager for Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The preceding option cannot be used as a cluster solution and you should probably
    mount one of the containers' filesystems as read-only using the `mountOptions`
    flag.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Helm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Helm ([https://helm.sh](https://helm.sh) and [https://github.com/helm](https://github.com/helm))
    is an application package manager for Kubernetes. You can compare it with `apt`
    and `yum` for Linux. It helps to manage Kubernetes using charts, which define,
    install, and upgrade the application you want to deploy on Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: There are many charts available in Helm's GitHub repository and Microsoft, which
    is one of the biggest contributors to this project, also provides a repository
    with examples.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Helm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are on an Ubuntu system, you have two choices—you can install Helm with
    a `snap` package or just download the binary from [https://github.com/kubernetes/helm/releases](https://github.com/kubernetes/helm/releases).
    Using the binary works for every Linux distribution, and the `snap` repository
    doesn''t always have the latest version of Helm. So, let''s use [https://github.com/helm/helm/releases](https://github.com/helm/helm/releases)
    to find the latest release of Helm and change `x` in the `helm-vx.x.x-linux-amd64.taz.gz`
    filename accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Always check for the latest release on the website and change the command accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'macOS users can use Brew ([https://brew.sh/](https://brew.sh/)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The client is installed, and with this client, we can deploy the server part,
    Tiller, into our Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '![Using the helm init command to deploy Tiller into the Kubernetes Cluster](img/B15455_10_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.17: Deploying Tiller into the Kubernetes Cluster'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Verify the versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Verifying the Helm version](img/B15455_10_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.18: Verifying the Helm version'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To allow Helm to get access to the Kubernetes cluster, a service account must
    be created with a corresponding role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the following screenshot, we created Tiller service account in
    the `kube-system` namespace using the `kubectl create` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating Tiller service account in the kube-system namespace](img/B15455_10_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.19: Creating Tiller service account in the kube-system namespace'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Grant cluster-admin access to Kubernetes resources to perform administrative
    tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the following screenshot, you can create a custom role based on
    your requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a custom role based with the kubectl create clusterrolebinding command](img/B15455_10_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.20: Creating a custom role'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Helm is the client installed on your local machine and Tiller is the server
    that is installed on your Kubernetes. To reconfigure Helm—that is, to make sure
    the version of Tiller matches with your local Helm—execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Helm Repository Management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A Helm repository is an HTTP server that can serve YAML files and consists
    of packaged charts and `index.yml` hosted on the same server. There are two repositories
    that are added during installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://kubernetes-charts.storage.googleapis.com/](https://kubernetes-charts.storage.googleapis.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: http://127.0.0.1:8879/charts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s add the repository from Microsoft:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '![Adding the repository from Microsoft](img/B15455_10_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.21: Adding the repository from Microsoft'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Check the available repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the helm repo list command to check the available repositories](img/B15455_10_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.22: Checking the available repositories'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To update the repository information, execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: You can also remove repositories using the `remove` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Applications with Helm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s see what is available in the repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The search result for wordpress giving the details about the chat version,
    app version, description and so on.](img/B15455_10_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.23: Searching the wordpress repository'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you want information about the chart, how to use it, the available parameters,
    and so on, you can use the `helm inspect` command. For now, we''re just going
    to deploy it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The installation output log from the preceding command contains the necessary
    details to access the `WordPress` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify the status of the Helm charts in the cluster using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command returns the revision name, update timestamp,
    status, chart, and its namespace as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the helm ls command to Verify the status of the Helm charts](img/B15455_10_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.24: Verifying the status of the Helm charts'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Review the previous output of the installation process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This command returns the deployment timestamp, namespace, and status, in addition
    to resource details such as `v1/PersistentVolumeClaim`, `v1/Service`, `extensions/Deployment`,
    `v1/Secret`, and the `connection` details of the database server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the helm status command to review the helm status](img/B15455_10_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.25: Reviewing the helm status'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'And, of course, `kubectl` will also show you the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using kubectl to get the deployment details](img/B15455_10_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.26: Using kubectl to get the deployment details'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of the `kubectl get service` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Output of the kubectl get service command](img/B15455_10_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.27: Output of the kubectl get service command'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let''s remove our deployment (the name can be found using `helm ls`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '![Removing the deployment with the helm delete command](img/B15455_10_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.28: Removing the deployment with the helm delete command'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To customize the application, execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, search for the WordPress settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Searching for the WordPress settings](img/B15455_10_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.29: Searching for the WordPress settings'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Create a YAML file, for instance, `custom.yaml`, with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, deploy the WordPress application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'You can verify the results using the `kubectl` command. First, get the Pod''s
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '![Verifying the deployment of the WordPress application with the kubectl get
    pod command](img/B15455_10_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.30: Verifying the deployment of the WordPress application'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'After that, execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '![Usign the kubectl describe pod command to get the description of the pod](img/B15455_10_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.31: Getting the pod description'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For instance, in the `Events` section, you'll see that the `docker.io/bitnami/wordpress:4-ol-7`
    image is pulled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clean everything up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Don't bother about the stateful sets (`sts`); they were created by this application
    to have an ordered deployment and shared persistent storage.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Helm Charts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Helm charts are similar to software packages used in Linux distributions and
    you can browse the package repository (chart) directory structure using the Helm
    client. There are many charts created for you, and it is also possible to create
    your own.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a working directory and make it ready for use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command should give you a similar output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a working directory and making it ready for use by first running
    cd myhelm and then executing ls -al command](img/B15455_10_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.32: Creating a working directory'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Some files and directories are created:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Chart.yaml` file: This file contains basic information about the chart.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `values.yaml` file: The default configuration value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `charts` directory: The dependency charts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `templates` directory: This is used to create manifest files for Kubernetes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, you can add a `LICENSE` file, a `README.md` file, and a file with
    requirements, `requirements.yaml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify `Chart.yaml` a little bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The file is more or less self-explanatory: the maintainers are optional. `appVersion`
    refers to the version of, in this example, nginx.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify the configuration with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Take some time to investigate the files in the `templates` directory and the
    `value.yaml` file. Of course, there is a reason why we used nginx as an example,
    because the files that are created by `helm create` also use nginx as an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, execute a dry run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This way, you can see the manifest that will be used to deploy the application.
    After that, you''re ready to install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'After the installation, we realized that looking at the dry run, there is something
    that is not OK: the version of nginx is `nginx: stable`, which is version 1.14.0\.
    Open the `values.yaml` file and change `tag: stable` to `tag: 1.15.2`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `helm ls` to find the name and update it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'A new pod will be created; the old one will be deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Finding the name of the pod and updating it by relacing the new pod with
    the old pod](img/B15455_10_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.33: Updating the pod version'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'There is even a `rollback` option if you want to revert back to your old version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: You just need to specify the release and revision to which you want to revert.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Draft
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Helm is typically something you're going to use, as a developer, on applications
    that are more or less production-ready and should be maintained. It's also most
    likely that you hosted the code on a version control system such as GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: This is where Draft ([https://github.com/Azure/draft](https://github.com/Azure/draft))
    comes in. It tries to streamline the process, starting with your code, in the
    Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: The tool is in heavy development. Draft is getting more popular and stable with
    new languages and features being added regularly.
  prefs: []
  type: TYPE_NORMAL
- en: If the development phase turns into something that seems to be usable, you can
    still use Draft, but it's more likely that you'll switch to Helm as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find out what programming languages are supported by Draft, you can execute
    the following commands after the installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Installing Draft
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To be able to use Draft, Helm must be installed and configured.
  prefs: []
  type: TYPE_NORMAL
- en: 'Get your copy from [https://github.com/Azure/draft/releases](https://github.com/Azure/draft/releases):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Always check for the latest release on the website and change the command accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'macOS users can install it with Brew:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that the developers who work on Helm are also involved with the
    development of Draft. In both cases, many of them are Microsoft developers. Similar
    to Helm, after installing the client, you have to initialize Draft:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This will install some default plugins and set up the repositories you can use
    within Draft.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the version with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'At the time of writing, its version is 0.16.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The output showing the Draft version as 0.16.0 ](img/B15455_10_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.34: Checking the Draft version'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The last step involves configuring a Docker repository, Docker Hub, or Azure.
    For the purposes of this book, we are using Azure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an **Azure container registry** (**ACR**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Log in to `LinuxStarACR`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '![Logging in to LinuxStarACR with the az acr login --name LinuxStarACR command](img/B15455_10_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.35: Logging in to LinuxStarACR'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Configure the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Log in to the registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Create trust between Draft and the ACR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: We have successfully installed Draft v0.16.0 and created ACR. Finally, we created
    trust between Draft and ACR. It's time to go ahead and start using Draft.
  prefs: []
  type: TYPE_NORMAL
- en: Using Draft
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s develop some simple Draft code. For this, we''ll create a directory
    and name it `mynode`. In this directory, we''ll create a file called `mynode.js`
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a simple web server that serves a page saying `Hello World!`. We''re
    in a very early stage of our development process. To create a `package.json` file,
    execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Fill in the information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to execute Draft:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '![Creating a Dockerfile using the draft create command](img/B15455_10_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.36: Creating a Dockerfile using the draft create command'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This will create a Dockerfile and all the information for Helm.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last line of the output, `Ready to sail`, actually means that you are ready
    to execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building and pushing the Docker image with the draft up command](img/B15455_10_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.37: Building and pushing the Docker image'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This will build the image and release the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `helm ls` will show the `mynode` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The output displaying the details of mynode application](img/B15455_10_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.38: Getting the details of mynode application'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Use `kubectl get services` to show the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying the service using kubectl get services command](img/B15455_10_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.39: Using kubectl get services to display the service'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Everything seems to be OK here, but `kubectl get pod` tells us otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the kubectl get pod command to check the status of the pod](img/B15455_10_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.40: Checking the status of the pod'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The `draft logs` command doesn''t show any errors. So, let''s find out what
    Kubernetes thinks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'It states `npm ERR! missing script: start`. On purpose, we made a mistake in
    the `package.json` file. Change the content, modifying the values as per the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the application by executing the following again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Connect to the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '![Connecting to the application with the draft connect command](img/B15455_10_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.41: Connecting to the application'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Open another terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The output must be `Hello World!`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Press *Ctrl* + *C* in the terminal, run `draft connect`, and remove the deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Check the cluster resources with `kubectl get all` and clean up, if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Kubernetes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've created a Kubernetes cluster, and we've learned about the `kubectl` utility
    and about some of the tools that are available to develop and maintain your applications
    in a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: So, if you look back at our three questions in the introduction of this chapter,
    we've answered the first question. In this section, we are going to answer the
    other two questions and also cover how to update the Kubernetes version.
  prefs: []
  type: TYPE_NORMAL
- en: Updating Applications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Earlier on, we used Helm and Draft to manage our application, which meant all
    the hard work was done for us. But you can also update the workload with the help
    of `kubectl`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, our cluster will be empty now, so let''s quickly deploy our `nginx`
    pod again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Have a good look at the deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The output showing that deployment of the nginx pod was successful](img/B15455_10_42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.42: Deploying the nginx pod'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This actually tells us that we wanted one instance, there is one running, it
    is up to date (the number of instances that were updated to match the desired
    capacity), and it is available. The version of nginx running is not the latest
    one, so we want to update it to version 1.17.5\. Execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the image to `nginx:1.17.5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Changing the image to nginx:1.17.5](img/B15455_10_43.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.43: Changing the image to nginx:1.17.5'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The **kubectl rollout** command can be used to manage your resource deployment.
    Some of the valid rollout options are status, history, pause, restart, resume
    and undo. **kubectl rollout status** displays the current status of a rollout
    whereas **kubectl rollout history** lists previous revisions and configurations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, even better, you can use the `describe` command, which provides
    you with a more detailed output than the preceding two commands combined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '![Getting more detailed output for the nginx deployment with the kubectl describe
    deployment command](img/B15455_10_44.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.44: Detailed information of the nginx deployment'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Another way to update the deployment is by using the `set image` command to
    roll out the updated nginx containers with the new version, 1.17.5, of your deployment
    by updating the image as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding screenshot, the nginx container image has
    been upgraded to version 1.17.5 successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling Applications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the moment, there is one pod running, but to handle all the load coming in,
    you may need more instances and to load balance the incoming traffic. To do so,
    you'll need replicas to define a specified number of pod replicas that are running
    at any given time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to `kubectl` and get the current deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting the status of the current deployment](img/B15455_10_45.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.45: Getting the status of the current deployment'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The desired (configured) state at this moment is `1`. The current situation
    is `1` and there is `1` available.
  prefs: []
  type: TYPE_NORMAL
- en: 'To scale up to three instances, execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Run `kubectl get deployments` again; after that, look at the available pods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '![The output showing the status of the available pods after scaling up](img/B15455_10_46.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.46: Checking the available pods after scaling up'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Create a load balancer service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '![The output showing the creation of a load balancer service](img/B15455_10_47.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.47: Creating a load balancer service'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now every HTTP request is taken by the load balancer and traffic is spread over
    the instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use autoscaling. First, install Metrics Server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Configure autoscaling: if the load is above `50` percent, an extra instance
    is created, to a maximum of `10`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, in this scenario, it makes sense to have at least two nodes available
    in your cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this process will take about 10 minutes. To view the status of the
    autoscaling, execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '![Using the kubectl get hpa command to view the status of the autoscaling](img/B15455_10_48.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.48: Listing the autoscalers'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Upgrading Kubernetes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with any software or application, you need to keep your Kubernetes clusters
    up to date by upgrading them regularly. Upgrading is very important to get the
    most recent bug fixes and all the critical security features along with the latest
    Kubernetes features. Having multiple nodes available is also necessary if you
    want to upgrade the Kubernetes control plane without downtime. The following steps
    will show you how to quickly upgrade your Kubernetes clusters.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, view the current version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '![The output displaying the current version of Kubernetes as 1.13.12](img/B15455_10_49.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.49: Viewing the current version of Kubernetes'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Ask for the versions available in your location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '![Getting the the versions available in the East US location](img/B15455_10_50.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.50: Available versions for East US location'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We can upgrade to version 1.14.8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Adding the `--no-wait` parameter has the effect that you'll get your prompt
    back almost directly.
  prefs: []
  type: TYPE_NORMAL
- en: This way, after about 3 minutes, you can start playing with `kubectl` to get
    the status of the nodes and pods (use the `-owide` parameter, for example, `kubectl
    get pods -o wide`) and find out that a new node has been created with the newest
    version. The workload is recreated on that node and the other node is updated.
    After that, the last one remaining is emptied and upgraded.
  prefs: []
  type: TYPE_NORMAL
- en: Persistent Storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, we stated that there are multiple ways to use persistent
    storage in our container, and we also referred to this in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes can configure persistent storage, but you have to provide it, for
    instance, via an NFS container or by implementing a StorSimple iSCSI Virtual Array
    (which is especially useful if you need read/write access from multiple containers).
    Even if you are using Azure Storage, there are many choices to make. Do you want
    to use disks or Azure Storage? Do you want to create them on the fly (dynamically)
    or use existing ones (statically)? Most of these questions are answered based
    on cost and the need for services such as replication, backup, and snapshots.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we want to cover the dynamic options; orchestration-wise, it's
    a better choice because you can do everything within Kubernetes (or using the
    tooling around it).
  prefs: []
  type: TYPE_NORMAL
- en: 'Whether you are using Azure Storage or disks, you''ll need a storage account
    in the same resource group as Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Please revisit *Chapter 2*, *Getting Started with the Azure Cloud*, for the
    syntax of the preceding command. Remember that the name must be unique.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Disk for Kubernetes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can dynamically or statically provision persistent volume for use with
    one or many Kubernetes pods in an AKS cluster. There are two storage classes:
    standard Azure disk (the default) and premium Azure disk, which is a managed premium
    storage class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a YAML file to create the storage class. This makes it possible
    to automatically provision the storage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply it with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Replace the filename with the name of the file you just created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another YAML file is needed to claim the persistent volume, or in other words,
    create it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note that the match is made in the annotations. Apply this file as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify the result with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '![Executing the kubectl get sc command to verify the creation of the storage
    class](img/B15455_10_51.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.51: Verifying the creation of the storage class'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To use the storage in a pod, you can use it in a similar way to the following
    example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Azure Files for Kubernetes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you mount your Azure disk with access mode type `ReadWriteOnce`, then
    it will be available to only a single pod in AKS. As such, you need to use Azure
    Files to share a persistent volume across multiple pods. The configuration for
    Azure Files is not that different than Azure Disk, as described in the preceding
    section. The YAML file to create the storage class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the persistent volume claim to provision the Azure file share by executing
    the following YAML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply these two YAML files as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: .
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the persistent volume claim to create Azure file](img/B15455_10_52.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.52: Using the persistent volume claim to create Azure file'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The result of executing the Azure file storage creation YAML and the storage
    volume claim YAML is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Verifying the creation of Azure files and Azure disks](img/B15455_10_53.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.53: Verifying the creation of Azure files and Azure disks'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you can see, the specification in the pod remains the same. With these step-by-step
    implementations, we have successfully created Azure disks and Azure files for
    our persistent storage requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This chapter was all about Kubernetes. We started this chapter by describing
    a possible work environment for a developer: a good workstation with tooling to
    start local development, even with Kubernetes locally installed. We used Ubuntu
    Desktop as an example, but in fact, it doesn''t really matter as long as you are
    happy with your development environment.'
  prefs: []
  type: TYPE_NORMAL
- en: With everything in place locally, we covered the configuration of Kubernetes
    clusters in Azure using the Azure CLI and PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: The deployment of workloads in Azure can be as simple as executing `kubectl
    run`, but more complex scenarios were also explored, such as multi-container applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a developer, two tools are available to help streamline your development
    process: Draft and Helm. Draft is used for the initial development phase, and
    Helm is used afterward to install and maintain the application.'
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes is a tool for managing your containers, making it easy to deploy,
    maintain, and update your workloads. Scalability is one of the advantages of using
    Kubernetes; it's even possible to automatically scale depending on the required
    CPU and memory resources.
  prefs: []
  type: TYPE_NORMAL
- en: The last section of this chapter covered the use of persistent storage in Kubernetes,
    actually providing you with a much better way than storing data in a container
    or attaching storage directly to a container.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going back to the Ops part of DevOps – that is, troubleshooting
    and monitoring your workloads, and by workloads, we mean virtual machines with
    Linux installed, containers, and AKS.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What is a pod?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What would be a good reason to create a multiple-container pod?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What methods can you use to deploy your application in Kubernetes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What methods can you use to update your application in Kubernetes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you need to create extra nodes in Kubernetes if you want to upgrade the control
    plane?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you think of any reason why you would want an iSCSI solution?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As an exercise, recreate the multi-container pod using persistent storage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The goal of this chapter was to provide a practical approach to get your workload
    running in the Azure cloud. We hope it's the beginning of a journey into the world
    of Kubernetes for you. There is so much more to discover!
  prefs: []
  type: TYPE_NORMAL
- en: Nigel Poulton, an author who has already written a great book about Docker,
    has also written a book about Kubernetes, *The Kubernetes Book*. It's a good starting
    point if you are really new to Kubernetes. Gigi Sayfan has written *Mastering
    Kubernetes*. Make sure you buy the second edition! Not only because the first
    edition was not that good, but just because it's a must-have and provides much
    more information than the first edition.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a developer, you should give *Kubernetes for Developers* a try: Joseph Heck
    can tell you much more about the development life cycle using Kubernetes, using
    examples in Node.js and Python. In the last chapter of his book, he mentions emerging
    projects such as Helm and Brigade. We hope this will be explored in more detail
    in a later edition, or maybe even in another book.'
  prefs: []
  type: TYPE_NORMAL
- en: Talking about Brigade, [https://brigade.sh](https://brigade.sh) is described
    on its own website as "*a tool for running scriptable, automated tasks in the
    cloud — as part of your Kubernetes cluster*." It's far beyond the scope of this
    book and it's more or less in the early stages of development. As a developer,
    you should invest some time in reading more about it and trying it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last but not least, another important source worth mentioning is the Open Service
    Broker for Azure (OSBA: [https://osba.sh](https://osba.sh)). It didn''t make it
    into this chapter because it''s not completely production-ready at the time of
    writing. OSBA is an open standard for communicating with external services such
    as databases and storage. It''s another solution for providing data to and storing
    data from your container.'
  prefs: []
  type: TYPE_NORMAL
