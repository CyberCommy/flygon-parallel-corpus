- en: Built-in Data Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置数据类型
- en: '"Data! Data! Data!" he cried impatiently. "I can''t make bricks without clay."– Sherlock
    Holmes – The Adventure of the Copper Beeches'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “数据！数据！数据！”他不耐烦地喊道。“没有黏土，我就无法制造砖块。”– 福尔摩斯 – 铜山毛榉的冒险
- en: Everything you do with a computer is managing data. Data comes in many different
    shapes and flavors. It's the music you listen to, the movies you stream, the PDFs
    you open. Even the source of the chapter you're reading at this very moment is
    just a file, which is data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你在计算机上所做的一切都是在管理数据。数据有许多不同的形状和风味。这是你听的音乐，你流媒体的电影，你打开的PDF。甚至你正在阅读的本章的来源只是一个文件，也就是数据。
- en: Data can be simple, an integer number to represent an age, or complex, like
    an order placed on a website. It can be about a single object or about a collection
    of them. Data can even be about data, that is, metadata. Data that describes the
    design of other data structures or data that describes application data or its
    context. In Python, *objects are abstraction for data*, and Python has an amazing
    variety of data structures that you can use to represent data, or combine them
    to create your own custom data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可以是简单的，比如用整数表示年龄，也可以是复杂的，比如在网站上下的订单。它可以是关于单个对象或关于它们的集合。数据甚至可以是关于数据的，也就是元数据。描述其他数据结构的设计或描述应用程序数据或其上下文的数据。在Python中，*对象是数据的抽象*，Python有各种各样的数据结构，你可以用它们来表示数据，或者组合它们来创建自己的自定义数据。
- en: 'In this chapter, we are going to cover the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下内容：
- en: Python objects' structures
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python对象的结构
- en: Mutability and immutability
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变性和不可变性
- en: 'Built-in data types: numbers, strings, sequences, collections, and mapping
    types'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置数据类型：数字、字符串、序列、集合和映射类型
- en: The collections module
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合模块
- en: Enumerations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举
- en: Everything is an object
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一切都是对象
- en: Before we delve into the specifics, I want you to be very clear about objects
    in Python, so let's talk a little bit more about them. As we already said, everything
    in Python is an object. But what really happens when you type an instruction like
    `age = 42` in a Python module?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入具体内容之前，我希望你对Python中的对象非常清楚，所以让我们再多谈一点关于它们。正如我们已经说过的，Python中的一切都是对象。但是当你在Python模块中输入`age
    = 42`这样的指令时，真正发生了什么呢？
- en: If you go to [http://pythontutor.com/](http://pythontutor.com/), you can type
    that instruction into a text box and get its visual representation. Keep this
    website in mind; it's very useful to consolidate your understanding of what goes
    on behind the scenes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你去[http://pythontutor.com/](http://pythontutor.com/)，你可以在文本框中输入该指令并获得其可视化表示。记住这个网站；它对于巩固你对幕后发生的事情的理解非常有用。
- en: 'So, what happens is that an object is created. It gets an `id`, the `type`
    is set to `int` (integer number), and the `value` to `42`. A name `age` is placed
    in the global namespace, pointing to that object. Therefore, whenever we are in
    the global namespace, after the execution of that line, we can retrieve that object
    by simply accessing it through its name: `age`.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，创建了一个对象。它得到了一个`id`，`type`设置为`int`（整数），`value`设置为`42`。一个名为`age`的名称被放置在全局命名空间中，指向该对象。因此，每当我们在全局命名空间中，在执行该行之后，我们可以通过简单地通过其名称访问它来检索该对象：`age`。
- en: 'If you were to move house, you would put all the knives, forks, and spoons
    in a box and label it *cutlery*. Can you see it''s exactly the same concept? Here''s
    a screenshot of what it may look like (you may have to tweak the settings to get
    to the same view):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你要搬家，你会把所有的刀、叉和勺子放在一个盒子里，贴上“餐具”的标签。你能看到这正是相同的概念吗？这是一个可能看起来像这样的屏幕截图（你可能需要调整设置以获得相同的视图）：
- en: '![](../images/00005.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00005.jpeg)'
- en: So, for the rest of this chapter, whenever you read something such as `name
    = some_value`, think of a name placed in the namespace that is tied to the scope
    in which the instruction was written, with a nice arrow pointing to an object
    that has an `id`, a `type`, and a `value`. There is a little bit more to say about
    this mechanism, but it's much easier to talk about it over an example, so we'll
    get back to this later.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章的其余部分，每当你读到诸如`name = some_value`这样的内容时，想象一下一个放置在命名空间中的名称，它与写入该指令的范围相关联，并且有一个漂亮的箭头指向具有`id`、`type`和`value`的对象。关于这个机制还有一些要说的，但是通过一个例子来谈论它要容易得多，所以我们稍后再回到这个问题。
- en: Mutable or immutable? That is the question
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变还是不可变？这是个问题
- en: A first fundamental distinction that Python makes on data is about whether or
    not the value of an object changes. If the value can change, the object is called
    **mutable**, while if the value cannot change, the object is called **immutable**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Python对数据所做的第一个基本区分是关于对象的值是否会改变。如果值可以改变，对象称为**可变**，而如果值不能改变，对象称为**不可变**。
- en: 'It is very important that you understand the distinction between mutable and
    immutable because it affects the code you write, so here''s a question:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是，你要理解可变和不可变之间的区别，因为它会影响你编写的代码，所以这里有一个问题：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding code, on the line `#A`, have I changed the value of age? Well,
    no. But now it''s `43` (I hear you say...). Yes, it''s `43`, but `42` was an integer
    number, of the type `int`, which is immutable. So, what happened is really that
    on the first line, `age` is a name that is set to point to an `int` object, whose
    value is `42`. When we type `age = 43`, what happens is that another object is
    created, of the type `int` and value `43` (also, the `id` will be different),
    and the name `age` is set to point to it. So, we didn''t change that `42` to `43`.
    We actually just pointed `age` to a different location: the new `int` object whose
    value is `43`. Let''s see the same code also printing the IDs:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，在`#A`行，我改变了age的值吗？嗯，没有。但现在是`43`（我听到你说...）。是的，是`43`，但`42`是一个整数，类型是`int`，是不可变的。因此，真正发生的是在第一行，`age`是一个名称，它被设置为指向一个`int`对象，其值为`42`。当我们输入`age
    = 43`时，真正发生的是创建了另一个对象，类型为`int`，值为`43`（此外，`id`将不同），并且名称`age`被设置为指向它。因此，我们并没有将`42`改为`43`。实际上，我们只是将`age`指向了一个不同的位置：值为`43`的新`int`对象。让我们看看相同的代码也打印出ID：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Notice that we print the IDs by calling the built-in `id` function. As you
    can see, they are different, as expected. Bear in mind that `age` points to one
    object at a time: `42` first, then `43`. Never together.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们通过调用内置的`id`函数打印了这些ID。如你所见，它们是不同的，这是预期的。请记住，`age`一次只指向一个对象：首先是`42`，然后是`43`。从来不会同时存在。
- en: 'Now, let''s see the same example using a mutable object. For this example,
    let''s just use a `Person` object, that has a property `age` (don''t worry about
    the class declaration for now; it''s there only for completeness):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看使用可变对象的相同例子。对于这个例子，让我们只使用一个`Person`对象，它有一个`age`属性（现在不用担心类的声明；它只是为了完整起见）：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this case, I set up an object `fab` whose `type` is `Person` (a custom class).
    On creation, the object is given the `age` of `42`. I'm printing it, along with
    the object `id`, and the ID of `age` as well. Notice that, even after I change
    `age` to be `25`, the ID of `fab` stays the same (while the ID of `age` has changed,
    of course). Custom objects in Python are mutable (unless you code them not to
    be). Keep this concept in mind; it's very important. I'll remind you about it
    throughout the rest of the chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我设置了一个`fab`对象，它的`type`是`Person`（一个自定义类）。在创建时，对象被赋予`42`的`age`。我打印它，以及对象的`id`，以及`age`的ID。请注意，即使我将`age`更改为`25`，`fab`的ID仍然保持不变（当然，`age`的ID已经改变了）。Python中的自定义对象是可变的（除非你编写代码使它们不可变）。记住这个概念；这是非常重要的。我会在本章的其余部分提醒你。
- en: Numbers
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字
- en: Let's start by exploring Python's built-in data types for numbers. Python was
    designed by a man with a master's degree in mathematics and computer science,
    so it's only logical that it has amazing support for numbers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从探索Python内置的数字数据类型开始。Python是由一位数学和计算机科学硕士设计的，因此它对数字有很好的支持是合乎逻辑的。
- en: Numbers are immutable objects.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 数字是不可变对象。
- en: Integers
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整数
- en: 'Python integers have an unlimited range, subject only to the available virtual
    memory. This means that it doesn''t really matter how big a number you want to
    store is: as long as it can fit in your computer''s memory, Python will take care
    of it. Integer numbers can be positive, negative, and 0 (zero). They support all
    the basic mathematical operations, as shown in the following example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Python整数具有无限范围，只受可用虚拟内存的限制。这意味着你想要存储的数字有多大并不重要：只要它能适应计算机的内存，Python就会处理它。整数可以是正数、负数和0（零）。它们支持所有基本的数学运算，如下例所示：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding code should be easy to understand. Just notice one important
    thing: Python has two division operators, one performs the so-called **true division**
    (`/`), which returns the quotient of the operands, and the other one, the so-called
    **integer division** (`//`), which returns the *floored* quotient of the operands.
    It might be worth noting that in Python 2 the division operator `/` behaves differently
    than in Python 3\. See how that is different for positive and negative numbers:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码应该很容易理解。只要注意一件重要的事情：Python有两个除法运算符，一个执行所谓的**真除法**(`//`)，返回操作数的商，另一个是所谓的**整数除法**(`//`)，返回操作数的*向下取整*商。值得注意的是，在Python
    2中，除法运算符`/`的行为与Python 3中不同。看看对于正数和负数的不同之处：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is an interesting example. If you were expecting a `-1` on the last line,
    don''t feel bad, it''s just the way Python works. The result of an integer division
    in Python is always rounded towards minus infinity. If, instead of flooring, you
    want to truncate a number to an integer, you can use the built-in `int` function,
    as shown in the following example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有趣的例子。如果你在最后一行期望得到`-1`，不要感到难过，这只是Python的工作方式。在Python中，整数除法的结果总是向负无穷大舍入。如果你想要将一个数字截断为整数，而不是向下取整，你可以使用内置的`int`函数，如下例所示：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that the truncation is done toward `0`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意截断是朝着`0`进行的。
- en: 'There is also an operator to calculate the remainder of a division. It''s called
    a modulo operator, and it''s represented by a percentage (`%`):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个运算符可以计算除法的余数。它被称为模运算符，用百分号(`%`)表示：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'One nice feature introduced in Python 3.6 is the ability to add underscores
    within number literals (between digits or base specifiers, but not leading or
    trailing). The purpose is to help make some numbers more readable, like for example `1_000_000_000`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.6中引入的一个很好的特性是在数字文字中添加下划线的能力（在数字或基数指示符之间，但不是在前导或尾随）。目的是帮助使一些数字更易读，比如`1_000_000_000`：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Booleans
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔值
- en: 'Boolean algebra is that subset of algebra in which the values of the variables
    are the truth values: true and false. In Python, `True` and `False` are two keywords
    that are used to represent truth values. Booleans are a subclass of integers,
    and behave respectively like `1` and `0`. The equivalent of the `int` class for
    Booleans is the `bool` class, which returns either `True` or `False`. Every built-in
    Python object has a value in the Boolean context, which means they basically evaluate
    to either `True` or `False` when fed to the `bool` function. We''ll see all about
    this in [Chapter 3](part0087.html#2IV0U0-2ddb708647cc4530a187c2c6c0e9acfe), *Iterating
    and Making Decisions*.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔代数是代数的一个子集，在其中变量的值是真值：真和假。在Python中，`True`和`False`是两个关键字，用于表示真值。布尔值是整数的一个子类，分别像`1`和`0`一样行为。布尔值的等价于`int`类的是`bool`类，它返回`True`或`False`。每个内置的Python对象在布尔上下文中都有一个值，这意味着当它们被传递给`bool`函数时，它们基本上会被评估为`True`或`False`。我们将在[第3章](part0087.html#2IV0U0-2ddb708647cc4530a187c2c6c0e9acfe)中详细了解这一切，*迭代和做决定*。
- en: 'Boolean values can be combined in Boolean expressions using the logical operators
    `and`, `or`, and `not`. Again, we''ll see them in full in the next chapter, so
    for now let''s just see a simple example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值可以使用逻辑运算符`and`、`or`和`not`组合成布尔表达式。我们将在下一章中详细介绍它们，所以现在让我们看一个简单的例子：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can see that `True` and `False` are subclasses of integers when you try
    to add them. Python upcasts them to integers and performs the addition:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，当你尝试将`True`和`False`相加时，它们是整数的子类。Python将它们提升为整数并执行加法：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Upcasting** is a type conversion operation that goes from a subclass to its
    parent. In the example presented here, `True` and `False`, which belong to a class
    derived from the integer class, are converted back to integers when needed. This
    topic is about inheritance and will be explained in detail in [Chapter 6](part0163.html#4REBM0-2ddb708647cc4530a187c2c6c0e9acfe),
    *OOP, Decorators, and Iterators*.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**向上转型**是一种从子类到其父类的类型转换操作。在这里介绍的例子中，`True`和`False`属于从整数类派生的类，当需要时会转换回整数。这个主题涉及继承，将在[第6章](part0163.html#4REBM0-2ddb708647cc4530a187c2c6c0e9acfe)
    *OOP, Decorators, and Iterators*中详细解释。'
- en: Real numbers
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实数
- en: 'Real numbers, or floating point numbers, are represented in Python according
    to the IEEE 754 double-precision binary floating-point format, which is stored
    in 64 bits of information divided into three sections: sign, exponent, and mantissa.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 实数，或浮点数，根据IEEE 754双精度二进制浮点格式在Python中表示，该格式存储在64位信息中，分为三个部分：符号、指数和尾数。
- en: 'Quench your thirst for knowledge about this format on Wikipedia: [http://en.wikipedia.org/wiki/Double-precision_floating-point_format](http://en.wikipedia.org/wiki/Double-precision_floating-point_format).'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在维基百科上了解有关这种格式的知识：[http://en.wikipedia.org/wiki/Double-precision_floating-point_format](http://en.wikipedia.org/wiki/Double-precision_floating-point_format)。
- en: 'Usually, programming languages give coders two different formats: single and
    double precision. The former takes up 32 bits of memory, and the latter 64\. Python
    supports only the double format. Let''s see a simple example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，编程语言给程序员提供两种不同的格式：单精度和双精度。前者占用32位内存，后者占用64位。Python仅支持双精度格式。让我们看一个简单的例子：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the calculation of the area, I wrapped the `radius ** 2` within braces. Even
    though that wasn't necessary because the power operator has higher precedence
    than the multiplication one, I think the formula reads more easily like that.
    Moreover, should you get a slightly different result for the area, don't worry.
    It might depend on your OS, how Python was compiled, and so on. As long as the
    first few decimal digits are correct, you know it's a correct result.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算面积时，我在`radius ** 2`外面加了括号。尽管这并不是必要的，因为幂运算符的优先级高于乘法运算符，但我认为这样公式读起来更容易。此外，如果你对面积得到了稍微不同的结果，不要担心。这可能取决于你的操作系统，Python是如何编译的等等。只要前几位小数正确，你就知道这是正确的结果。
- en: 'The `sys.float_info` struct sequence holds information about how floating point
    numbers will behave on your system. This is what I see on my box:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`sys.float_info`结构序列包含有关浮点数在您的系统上的行为的信息。这是我在我的电脑上看到的：'
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s make a few considerations here: we have 64 bits to represent float numbers.
    This means we can represent at most `2 ** 64 == 18,446,744,073,709,551,616` numbers
    with that amount of bits. Take a look at the `max` and `epsilon` values for the
    float numbers, and you''ll realize it''s impossible to represent them all. There
    is just not enough space, so they are approximated to the closest representable
    number. You probably think that only extremely big or extremely small numbers
    suffer from this issue. Well, think again and try the following in your console:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里做一些考虑：我们有64位来表示浮点数。这意味着我们最多可以用`2 ** 64 == 18,446,744,073,709,551,616`个数字来表示这些位数。查看浮点数的`max`和`epsilon`值，你会意识到不可能表示它们所有。空间不够，因此它们被近似到最接近的可表示数字。你可能认为只有极大或极小的数字才会受到这个问题的影响。好吧，再想一想，尝试在你的控制台上输入以下内容：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What does this tell you? It tells you that double precision numbers suffer from
    approximation issues even when it comes to simple numbers like `0.1` or `0.3`.
    Why is this important? It can be a big problem if you're handling prices, or financial
    calculations, or any kind of data that needs not to be approximated. Don't worry,
    Python gives you the **decimal** type, which doesn't suffer from these issues;
    we'll see them in a moment.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉你什么？它告诉你，双精度数甚至在处理简单的数字如`0.1`或`0.3`时也会受到近似问题的影响。为什么这很重要？如果你处理价格、金融计算或任何不需要近似的数据，这可能是一个大问题。不用担心，Python给了你**decimal**类型，它不会受到这些问题的影响；我们马上就会看到它们。
- en: Complex numbers
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复数
- en: Python gives you complex numbers support out of the box. If you don't know what
    complex numbers are, they are numbers that can be expressed in the form *a + ib*
    where *a* and *b* are real numbers, and *i* (or *j* if you're an engineer) is
    the imaginary unit, that is, the square root of *-1*. *a* and *b* are called,
    respectively, the *real* and *imaginary* part of the number.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Python为您提供了复数支持。如果你不知道什么是复数，它们是可以用*a + ib*的形式表示的数字，其中*a*和*b*是实数，*i*（或者如果你是工程师，是*j*）是虚数单位，即*-1*的平方根。*a*和*b*分别被称为数字的*实部*和*虚部*。
- en: 'It''s actually unlikely you''ll be using them, unless you''re coding something
    scientific. Let''s see a small example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可能不会经常使用它们，除非你在编写科学代码。让我们看一个小例子：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Fractions and decimals
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分数和小数
- en: 'Let''s finish the tour of the number department with a look at fractions and
    decimals. Fractions hold a rational numerator and denominator in their lowest
    forms. Let''s see a quick example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们结束数字部分的介绍，看一看分数和小数。分数以最简形式保存有理数的分子和分母。让我们看一个快速的例子：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Although they can be very useful at times, it's not that common to spot them
    in commercial software. Much easier instead, is to see decimal numbers being used
    in all those contexts where precision is everything; for example, in scientific
    and financial calculations.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们有时可能非常有用，但在商业软件中很少见。相反，更容易看到小数被用在所有那些需要精度的情境中；例如，在科学和金融计算中。
- en: It's important to remember that arbitrary precision decimal numbers come at
    a price in performance, of course. The amount of data to be stored for each number
    is far greater than it is for fractions or floats as well as the way they are
    handled, which causes the Python interpreter much more work behind the scenes.
    Another interesting thing to note is that you can get and set the precision by
    accessing `decimal.getcontext().prec`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，任意精度的十进制数当然会影响性能。每个数字要存储的数据量远远大于分数或浮点数，以及它们的处理方式，这会导致Python解释器在幕后做更多的工作。另一个有趣的事情是，您可以通过访问`decimal.getcontext().prec`来获取和设置精度。
- en: 'Let''s see a quick example with decimal numbers:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用十进制数看一个快速的例子：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that when we construct a `Decimal` number from a `float`, it takes on
    all the approximation issues `float` may come from. On the other hand, when the
    `Decimal` has no approximation issues (for example, when we feed an `int` or a
    `string` representation to the constructor), then the calculation has no quirky
    behavior. When it comes to money, use decimals.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们从`float`构造一个`Decimal`数字时，它会带有所有可能出现的近似问题。另一方面，当`Decimal`没有近似问题时（例如，当我们将`int`或`string`表示传递给构造函数时），则计算没有古怪的行为。在涉及货币时，请使用小数。
- en: This concludes our introduction to built-in numeric types. Let's now look at
    sequences.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们对内置数字类型的介绍。现在让我们来看看序列。
- en: Immutable sequences
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变序列
- en: 'Let''s start with immutable sequences: strings, tuples, and bytes.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从不可变序列开始：字符串、元组和字节。
- en: Strings and bytes
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串和字节
- en: Textual data in Python is handled with `str` objects, more commonly known as
    **strings**. They are immutable sequences of **Unicode code points**. Unicode
    code points can represent a character, but can also have other meanings, such
    as formatting data, for example. Python, unlike other languages, doesn't have
    a `char` type, so a single character is rendered simply by a string of length
    `1`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的文本数据是使用`str`对象处理的，更常见的是**字符串**。它们是**Unicode代码点**的不可变序列。Unicode代码点可以表示一个字符，但也可以有其他含义，例如格式化数据。与其他语言不同，Python没有`char`类型，因此单个字符只是一个长度为`1`的字符串。
- en: 'Unicode is an excellent way to handle data, and should be used for the internals
    of any application. When it comes to storing textual data though, or sending it
    on the network, you may want to encode it, using an appropriate encoding for the
    medium you''re using. The result of an encoding produces a `bytes` object, whose
    syntax and behavior is similar to that of strings. String literals are written
    in Python using single, double, or triple quotes (both single or double). If built
    with triple quotes, a string can span on multiple lines. An example will clarify
    this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode是处理数据的一种出色方式，应该用于任何应用程序的内部。但是，当涉及存储文本数据或在网络上传输文本数据时，您可能希望对其进行编码，使用适合您使用的介质的适当编码。编码的结果会产生一个`bytes`对象，其语法和行为类似于字符串。Python中的字符串文字使用单引号、双引号或三引号（单引号或双引号）编写。如果使用三引号构建，字符串可以跨多行。一个例子将澄清这一点：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In `#A` and `#B`, we print `str4`, first implicitly, and then explicitly, using
    the `print` function. A nice exercise would be to find out why they are different.
    Are you up to the challenge? (hint: look up the `str` function.)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在`#A`和`#B`中，我们打印`str4`，首先是隐式地，然后是显式地，使用`print`函数。一个很好的练习是找出它们为什么不同。您敢挑战吗？（提示：查找`str`函数。）
- en: 'Strings, like any sequence, have a length. You can get this by calling the
    `len` function:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串，像任何序列一样，都有一个长度。您可以通过调用`len`函数来获得这个长度：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Encoding and decoding strings
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码和解码字符串
- en: 'Using the `encode`/`decode` methods, we can encode Unicode strings and decode
    bytes objects. **UTF-8** is a variable length character encoding, capable of encoding
    all possible Unicode code points. It is the dominant encoding for the web. Notice
    also that by adding a literal `b` in front of a string declaration, we''re creating
    a *bytes* object:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`encode`/`decode`方法，我们可以对Unicode字符串进行编码和解码字节对象。**UTF-8**是一种可变长度的字符编码，能够编码所有可能的Unicode代码点。它是网络的主要编码。还要注意，通过在字符串声明前面添加文字`b`，我们正在创建一个*字节*对象：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Indexing and slicing strings
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引和切片字符串
- en: When manipulating sequences, it's very common to have to access them at one
    precise position (indexing), or to get a subsequence out of them (slicing). When
    dealing with immutable sequences, both operations are read-only.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作序列时，非常常见的是必须在一个精确的位置访问它们（索引），或者从它们中获取一个子序列（切片）。在处理不可变序列时，这两种操作都是只读的。
- en: 'While indexing comes in one form, a zero-based access to any position within
    the sequence, slicing comes in different forms. When you get a slice of a sequence,
    you can specify the `start` and `stop` positions, and the `step`. They are separated
    with a colon (`:`) like this: `my_sequence[start:stop:step]`. All the arguments
    are optional, `start` is inclusive, and `stop` is exclusive. It''s much easier
    to show an example, rather than explain them further in words:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然索引以一种形式出现，即零为基础的访问序列中的任何位置，但切片以不同的形式出现。当您获取序列的一部分时，可以指定`start`和`stop`位置以及`step`。它们用冒号（`:`）分隔，就像这样：`my_sequence[start:stop:step]`。所有参数都是可选的，`start`是包含的，`stop`是排他的。最好通过示例来展示，而不是用更多的文字来解释它们：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Of all the lines, the last one is probably the most interesting. If you don't
    specify a parameter, Python will fill in the default for you. In this case, `start`
    will be the start of the string, `stop` will be the end of the string, and `step`
    will be the default `1`. This is an easy and quick way of obtaining a copy of
    the string `s` (same value, but different object). Can you find a way to get the
    reversed copy of a string using slicing (don't look it up; find it for yourself)?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有行中，最后一行可能是最有趣的。如果您不指定参数，Python将为您填充默认值。在这种情况下，`start`将是字符串的开头，`stop`将是字符串的结尾，`step`将是默认值`1`。这是一种轻松快速地获取字符串`s`的副本的方法（相同的值，但不同的对象）。您能找到一种使用切片获取字符串的反向副本的方法吗（不要查找，自己找找）？
- en: String formatting
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串格式化
- en: 'One of the features strings have is the ability to be used as a template. There
    are several different ways of formatting a string, and for the full list of possibilities,
    I encourage you to look up the documentation. Here are some common examples:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串具有的一个特性是可以用作模板。有几种不同的格式化字符串的方法，对于所有可能性的完整列表，我鼓励您查阅文档。以下是一些常见的例子：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the previous example, you can see four different ways of formatting stings.
    The first one, which relies on the `%` operator, is deprecated and shouldn't be
    used any more. The current, modern way to format a string is by using the `format` string
    method. You can see, from the different examples, that a pair of curly braces
    acts as a placeholder within the string. When we call `format`, we feed it data
    that replaces the placeholders. We can specify indexes (and much more) within
    the curly braces, and even names, which implies we'll have to call `format` using
    keyword arguments instead of positional ones.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，您可以看到四种不同的格式化字符串的方法。第一种依赖于`%`运算符，已经被弃用，不应再使用。格式化字符串的当前、现代方式是使用`format`字符串方法。从不同的例子中可以看出，一对大括号在字符串中充当占位符。当我们调用`format`时，我们提供替换占位符的数据。我们可以在大括号中指定索引（以及更多），甚至名称，这意味着我们将不得不使用关键字参数而不是位置参数来调用`format`。
- en: Notice how `greet_positional_idx` is rendered differently by feeding different
    data to the call to `format`. Apparently, I'm into Python and coffee... big surprise!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`greet_positional_idx`通过向`format`调用提供不同的数据而呈现出不同的方式。显然，我喜欢Python和咖啡...大惊喜！
- en: 'One last feature I want to show you is a relatively new addition to Python
    (Version 3.6) and it''s called **formatted string literals**. This feature is
    quite cool: strings are prefixed with `f`, and contain replacement fields surrounded
    by curly braces. Replacement fields are expressions evaluated at runtime, and
    then formatted using the `format` protocol:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我想向您展示的最后一个特性是Python的一个相对较新的添加（版本3.6），它被称为**格式化字符串文字**。这个特性非常酷：字符串以`f`为前缀，并包含用大括号括起来的替换字段。替换字段是在运行时评估的表达式，然后使用`format`协议进行格式化：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Check out the official documentation to learn everything about string formatting
    and how powerful it can be.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 查看官方文档，了解有关字符串格式化以及它的强大功能的一切。
- en: Tuples
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组
- en: 'The last immutable sequence type we''re going to see is the tuple. A **tuple**
    is a sequence of arbitrary Python objects. In a tuple, items are separated by
    commas. They are used everywhere in Python, because they allow for patterns that
    are hard to reproduce in other languages. Sometimes tuples are used implicitly;
    for example, to set up multiple variables on one line, or to allow a function
    to return multiple different objects (usually a function returns one object only,
    in many other languages), and even in the Python console, you can use tuples implicitly
    to print multiple elements with one single instruction. We''ll see examples for
    all these cases:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到的最后一个不可变序列类型是元组。**元组**是任意Python对象的序列。在元组中，项目用逗号分隔。它们在Python中随处可见，因为它们允许在其他语言中难以复制的模式。有时元组被隐式使用；例如，一次设置多个变量，或者允许函数返回多个不同的对象（通常函数只返回一个对象，在许多其他语言中），甚至在Python控制台中，您可以隐式使用元组以一条指令打印多个元素。我们将看到所有这些情况的例子：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice that the membership operator `in` can also be used with lists, strings,
    dictionaries, and, in general, with collection and sequence objects.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，成员运算符`in`也可以与列表、字符串、字典以及一般的集合和序列对象一起使用。
- en: Notice that to create a tuple with one item, we need to put that comma after
    the item. The reason is that without the comma that item is just itself wrapped
    in braces, kind of in a redundant mathematical expression. Notice also that on
    assignment, braces are optional so `my_tuple = 1, 2, 3` is the same as `my_tuple
    = (1, 2, 3)`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，要创建一个只有一个项目的元组，我们需要在项目后面加上逗号。原因是，没有逗号，该项目只是自己包裹在大括号中，有点像冗余的数学表达式。还要注意，赋值时，大括号是可选的，所以`my_tuple
    = 1, 2, 3`和`my_tuple = (1, 2, 3)`是一样的。
- en: 'One thing that tuple assignment allows us to do, is *one-line swaps*, with
    no need for a third temporary variable. Let''s see first a more traditional way
    of doing it:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 元组赋值允许我们*一行交换*，不需要第三个临时变量。让我们首先看一种更传统的方法：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And now let''s see how we would do it in Python:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看我们如何在Python中做到这一点：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Take a look at the line that shows you the Pythonic way of swapping two values.
    Do you remember what I wrote in [Chapter 1](part0021.html#K0RQ0-2ddb708647cc4530a187c2c6c0e9acfe),
    *A Gentle Introduction to Python*? A Python program is typically one-fifth to
    one-third the size of equivalent Java or C++ code, and features like one-line
    swaps contribute to this. Python is elegant, where elegance in this context also
    means economy.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下显示Python交换两个值的Pythonic方式。你还记得我在[第1章](part0021.html#K0RQ0-2ddb708647cc4530a187c2c6c0e9acfe)中写的吗？Python程序通常只有等价的Java或C++代码的五分之一到三分之一大小，像一行交换这样的特性有助于实现这一点。Python是优雅的，这里的优雅也意味着经济。
- en: Because they are immutable, tuples can be used as keys for dictionaries (we'll
    see this shortly). To me, tuples are Python's built-in data that most closely
    represent a mathematical vector. This doesn't mean that this was the reason for
    which they were created though. Tuples usually contain an heterogeneous sequence
    of elements, while on the other hand, lists are most of the times homogeneous.
    Moreover, tuples are normally accessed via unpacking or indexing, while lists
    are usually iterated over.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们是不可变的，元组可以用作字典的键（我们很快就会看到这一点）。对我来说，元组是Python内置数据，最接近数学向量的。这并不意味着这就是它们被创建的原因。元组通常包含异构序列的元素，而另一方面，列表大多数情况下是同构的。此外，元组通常通过解包或索引访问，而列表通常是迭代的。
- en: Mutable sequences
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变序列
- en: 'Mutable sequences differ from their immutable sisters in that they can be changed
    after creation. There are two mutable sequence types in Python: lists and byte
    arrays. I said before that the dictionary is the king of data structures in Python.
    I guess this makes the list its rightful queen.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 可变序列与它们的不可变姐妹们的不同之处在于它们可以在创建后进行更改。Python中有两种可变序列类型：列表和字节数组。我之前说过字典是Python中数据结构的王者。我猜这使得列表成为它合法的女王。
- en: Lists
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: 'Python lists are mutable sequences. They are very similar to tuples, but they
    don''t have the restrictions of immutability. Lists are commonly used to storing
    collections of homogeneous objects, but there is nothing preventing you from store
    heterogeneous collections as well. Lists can be created in many different ways.
    Let''s see an example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Python列表是可变序列。它们与元组非常相似，但没有不可变性的限制。列表通常用于存储同类对象的集合，但没有什么阻止你存储异类集合。列表可以用许多不同的方式创建。让我们看一个例子：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the previous example, I showed you how to create a list using different techniques.
    I would like you to take a good look at the line that says `Python is magic`,
    which I am not expecting you to fully understand at this point (unless you cheated
    and you're not a novice!). That is called a **list ****comprehension**, a very
    powerful functional feature of Python, which we'll see in detail in [Chapter 5](part0142.html#47DFS0-2ddb708647cc4530a187c2c6c0e9acfe),
    *Saving Time and Memory*. I just wanted to make your mouth water at this point.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我向你展示了如何使用不同的技术创建列表。我希望你仔细看一下那一行，上面写着“Python is magic”，我不指望你现在完全理解它（除非你作弊了，你不是新手！）。这被称为**列表推导**，是Python非常强大的函数特性，我们将在[第5章](part0142.html#47DFS0-2ddb708647cc4530a187c2c6c0e9acfe)中详细讨论，*节省时间和内存*。我只是想在这一点上让你垂涎三尺。
- en: 'Creating lists is good, but the real fun comes when we use them, so let''s
    see the main methods they gift us with:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 创建列表是好的，但真正有趣的是当我们使用它们时，所以让我们看看它们赋予我们的主要方法：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The preceding code gives you a roundup of a list''s main methods. I want to
    show you how powerful they are, using `extend` as an example. You can extend lists
    using any sequence type:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码为你提供了列表主要方法的概述。我想向你展示它们有多强大，以`extend`为例。你可以使用任何序列类型来扩展列表：
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, let''s see what are the most common operations you can do with lists:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看你可以用列表做哪些最常见的操作：
- en: '[PRE28]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The last two lines in the preceding code are quite interesting because they
    introduce us to a concept called **operator ****overloading**. In short, it means
    that operators such as `+`, `-`. `*`, `%`, and so on, may represent different
    operations according to the context they are used in. It doesn't make any sense
    to sum two lists, right? Therefore, the `+` sign is used to concatenate them.
    Hence, the `*` sign is used to concatenate the list to itself according to the
    right operand.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码中的最后两行非常有趣，因为它们向我们介绍了一个叫做**运算符重载**的概念。简而言之，这意味着`+`、`-`、`*`、`%`等运算符根据它们所用的上下文可能代表不同的操作。对两个列表求和没有任何意义，对吧？因此，`+`号用于连接它们。因此，`*`号用于根据右操作数将列表连接到自身。
- en: 'Now, let''s take a step further and see something a little more interesting.
    I want to show you how powerful the `sorted` method can be and how easy it is
    in Python to achieve results that require a great deal of effort in other languages:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再进一步，看一些更有趣的东西。我想向你展示`sorted`方法有多强大，以及在Python中实现需要在其他语言中付出很大努力才能实现的结果有多容易：
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding code deserves a little explanation. First of all, `a` is a list
    of tuples. This means each element in `a` is a tuple (a 2-tuple, to be precise).
    When we call `sorted(some_list)`, we get a sorted version of `some_list`. In this
    case, the sorting on a 2-tuple works by sorting them on the first item in the
    tuple, and on the second when the first one is the same. You can see this behavior
    in the result of `sorted(a)`, which yields `[(1, 2), (1, 3), ...]`. Python also
    gives us the ability to control which element(s) of the tuple the sorting must
    be run against. Notice that when we instruct the `sorted` function to work on
    the first element of each tuple (by `key=itemgetter(0)`), the result is different:
    `[(1, 3), (1, 2), ...]`. The sorting is done only on the first element of each
    tuple (which is the one at position 0). If we want to replicate the default behavior
    of a simple `sorted(a)` call, we need to use `key=itemgetter(0, 1)`, which tells
    Python to sort first on the elements at position 0 within the tuples, and then
    on those at position 1\. Compare the results and you''ll see they match.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码值得解释一下。首先，`a`是一个元组的列表。这意味着`a`中的每个元素都是一个元组（准确地说是一个2元组）。当我们调用`sorted(some_list)`时，我们得到了`some_list`的排序版本。在这种情况下，对2元组的排序是通过对元组中的第一个项目进行排序，当第一个项目相同时，再对第二个项目进行排序。你可以在`sorted(a)`的结果中看到这种行为，它产生了`[(1,
    2), (1, 3), ...]`。Python还让我们有能力控制排序必须针对元组的哪个元素。请注意，当我们指示`sorted`函数在每个元组的第一个元素上工作时（通过`key=itemgetter(0)`），结果是不同的：`[(1,
    3), (1, 2), ...]`。排序仅在每个元组的第一个元素上进行（即在位置0的元素上）。如果我们想复制简单的`sorted(a)`调用的默认行为，我们需要使用`key=itemgetter(0,
    1)`，这告诉Python首先对元组中位置0的元素进行排序，然后对位置1的元素进行排序。比较结果，你会发现它们是匹配的。
- en: For completeness, I included an example of sorting only on the elements at position
    1, and the same but in reverse order. If you have ever seen sorting in Java, I
    expect you to be quite impressed at this moment.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，我包括了一个仅对位置1的元素进行排序的示例，以及相同但顺序相反的示例。如果你曾经见过Java中的排序，我相信你此刻会感到非常震惊。
- en: The Python sorting algorithm is very powerful, and it was written by Tim Peters
    (we've already seen this name, can you recall when?). It is aptly named **Timsort**,
    and it is a blend between **merge** and **insertion ****sort** and has better
    time performances than most other algorithms used for mainstream programming languages.
    Timsort is a stable sorting algorithm, which means that when multiple records
    have the same key, their original order is preserved. We've seen this in the result
    of `sorted(a, key=itemgetter(0))`, which has yielded `[(1, 3), (1, 2), ...]`,
    in which the order of those two tuples has been preserved because they have the
    same value at position 0.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Python排序算法非常强大，由Tim Peters编写（我们已经见过这个名字，你还记得吗？）。 它被称为**Timsort**，它是**merge**和**insertion
    sort**之间的混合，并且比大多数其他用于主流编程语言的算法具有更好的时间性能。 Timsort是一种稳定的排序算法，这意味着当多个记录具有相同的键时，它们的原始顺序被保留。
    我们在`sorted(a，key=itemgetter(0))`的结果中看到了这一点，它产生了`[(1, 3)，(1, 2)，...]`，其中这两个元组的顺序已被保留，因为它们在位置0处具有相同的值。
- en: Byte arrays
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字节数组
- en: To conclude our overview of mutable sequence types, let's spend a couple of
    minutes on the `bytearray` type. Basically, they represent the mutable version
    of `bytes` objects. They expose most of the usual methods of mutable sequences
    as well as most of the methods of the `bytes` type. Items are integers in the
    range [0, 256).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结我们对可变序列类型的概述，让我们花几分钟时间来了解`bytearray`类型。 基本上，它们代表了`bytes`对象的可变版本。 它们公开了大多数可变序列的常用方法以及`bytes`类型的大多数方法。
    项目是范围内的整数[0, 256)。
- en: 'When it comes to intervals, I''m going to use the standard notation for open/closed
    ranges. A square bracket on one end means that the value is included, while a
    round brace means it''s excluded. The granularity is usually inferred by the type
    of the edge elements so, for example, the interval [3, 7] means all integers between
    3 and 7, inclusive. On the other hand, (3, 7) means all integers between 3 and
    7 exclusive (hence 4, 5, and 6). Items in a `bytearray` type are integers between
    0 and 256; 0 is included, 256 is not. One reason intervals are often expressed
    like this is to ease coding. If we break a range *[a, b)* into *N* consecutive
    ranges, we can easily represent the original one as a concatenation like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到间隔时，我将使用开/闭范围的标准表示法。 一端的方括号表示包括该值，而圆括号表示不包括该值。 粒度通常由边缘元素的类型推断，因此，例如，间隔[3,
    7]表示3和7之间的所有整数，包括。 另一方面，（3, 7）表示3和7之间的所有整数不包括（因此4、5和6）。 `bytearray`类型中的项目是介于0和256之间的整数；
    0包括在内，256不包括在内。 表达间隔的一个原因通常是为了便于编码。 如果我们将范围*[a，b)*分成*N*个连续范围，我们可以轻松地将原始范围表示为这样的连接：
- en: '*[a,k[1])+[k[1],k[2])+[k[2],k[3])+...+[k[N-1],b)*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*[a，k[1])+[k[1]，k[2])+[k[2]，k[3])+...+[k[N-1]，b)*'
- en: The middle points (*k[i]*) being excluded on one end, and included on the other
    end, allow for easy concatenation and splitting when intervals are handled in
    the code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 中间点（*k[i]*）在一端被排除，在另一端被包括，这样在代码处理间隔时就可以轻松进行连接和拆分。
- en: 'Let''s see a quick example with the `bytearray `type:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个`bytearray`类型的快速示例：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see in the preceding code, there are a few ways to create a `bytearray`
    object. They can be useful in many situations; for example, when receiving data
    through a socket, they eliminate the need to concatenate data while polling, hence
    they can prove to be very handy. On the line `#A`, I created a `bytearray` named
    as `name` from the bytes literal `b'Lina'` to show you how the `bytearray` object
    exposes methods from both sequences and strings, which is extremely handy. If
    you think about it, they can be considered as mutable strings.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的代码中所看到的，有几种方法可以创建`bytearray`对象。 它们在许多情况下都很有用； 例如，当通过套接字接收数据时，它们消除了在轮询时连接数据的需要，因此它们可能非常方便。
    在`＃A`行，我创建了一个名为`name`的`bytearray`，从字节文字`b'Lina'`中显示了`bytearray`对象如何公开来自序列和字符串的方法，这非常方便。
    如果您仔细考虑，它们可以被视为可变字符串。
- en: Set types
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合类型
- en: Python also provides two set types, `set` and `frozenset`. The `set` type is
    mutable, while `frozenset` is immutable. They are unordered collections of immutable
    objects. **Hashability** is a characteristic that allows an object to be used
    as a set member as well as a key for a dictionary, as we'll see very soon.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Python还提供了两种集合类型，`set`和`frozenset`。 `set`类型是可变的，而`frozenset`是不可变的。 它们是不可变对象的无序集合。
    **可哈希性**是一个特性，允许对象被用作集合成员以及字典的键，我们很快就会看到。
- en: 'From the official documentation: <q class="calibre25">An object is hashable
    if it has a hash value which never changes during its lifetime, and can be compared
    to other objects. Hashability makes an object usable as a dictionary key and a
    set member, because these data structures use the hash value internally. All of
    Python’s immutable built-in objects are hashable while mutable containers are
    not.</q>'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 来自官方文档：<q class="calibre25">如果对象具有在其生命周期内永远不会更改的哈希值，并且可以与其他对象进行比较，则对象是可哈希的。
    可哈希性使对象可用作字典键和集合成员，因为这些数据结构在内部使用哈希值。 所有Python的不可变内置对象都是可哈希的，而可变容器则不是。</q>
- en: 'Objects that compare equally must have the same hash value. Sets are very commonly
    used to test for membership, so let''s introduce the `in` operator in the following
    example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对象比较相等必须具有相同的哈希值。 集合非常常用于测试成员资格，因此让我们在以下示例中引入`in`运算符：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding code, you can see two different ways to create a set. One creates
    an empty set and then adds elements one at a time. The other creates the set using
    a list of numbers as an argument to the constructor, which does all the work for
    us. Of course, you can create a set from a list or tuple (or any iterable) and
    then you can add and remove members from the set as you please.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，您可以看到创建集合的两种不同方法。 一个是创建一个空集合，然后逐个添加元素。 另一个是使用数字列表作为构造函数的参数创建集合，这样我们就可以完成所有工作。
    当然，您可以从列表或元组（或任何可迭代对象）创建集合，然后可以随意添加和删除集合中的成员。
- en: We'll look at iterable objects and iteration in the next chapter. For now, just
    know that iterable objects are objects you can iterate on in a direction.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中查看可迭代对象和迭代。现在，只需知道可迭代对象是可以按照某个方向进行迭代的对象。
- en: 'Another way of creating a set is by simply using the curly braces notation,
    like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种创建集合的方法是简单地使用大括号表示法，就像这样：
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Notice I added some duplication to emphasize that the resulting set won''t
    have any. Let''s see an example about the immutable counterpart of the set type,
    `frozenset`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我添加了一些重复，以强调结果集不会有任何重复。让我们看一个关于集合类型的不可变对应物`frozenset`的例子：
- en: '[PRE33]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, `frozenset` objects are quite limited in respect of their mutable
    counterpart. They still prove very effective for membership test, union, intersection,
    and difference operations, and for performance reasons.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`frozenset`对象在其可变对应物方面相当有限。它们仍然非常有效地用于成员测试、并集、交集和差集操作，出于性能原因。
- en: Mapping types – dictionaries
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射类型 - 字典
- en: Of all the built-in Python data types, the dictionary is easily the most interesting
    one. It's the only standard mapping type, and it is the backbone of every Python
    object.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有内置的Python数据类型中，字典很容易是最有趣的一个。它是唯一的标准映射类型，也是每个Python对象的支柱。
- en: 'A dictionary maps keys to values. Keys need to be hashable objects, while values
    can be of any arbitrary type. Dictionaries are mutable objects. There are quite
    a few different ways to create a dictionary, so let me give you a simple example
    of how to create a dictionary equal to `{''A'': 1, ''Z'': -1}` in five different
    ways:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '字典将键映射到值。键需要是可哈希的对象，而值可以是任意类型。字典是可变对象。有很多不同的方法来创建字典，所以让我给你一个简单的例子，演示如何以五种不同的方式创建一个等于`{''A'':
    1, ''Z'': -1}`的字典：'
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Have you noticed those double equals? Assignment is done with one equal, while
    to check whether an object is the same as another one (or five in one go, in this
    case), we use double equals. There is also another way to compare objects, which
    involves the `is` operator, and checks whether the two objects are the same (if
    they have the same ID, not just the value), but unless you have a good reason
    to use it, you should use the double equals instead. In the preceding code, I
    also used one nice function: `zip`. It is named after the real-life zip, which
    glues together two things taking one element from each at a time. Let me show
    you an example:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到那些双等号？赋值是用一个等号来完成的，而要检查一个对象是否与另一个对象相同（或者在这种情况下一次检查五个对象），我们使用双等号。还有另一种比较对象的方法，涉及`is`运算符，并检查两个对象是否相同（如果它们具有相同的ID，而不仅仅是值），但除非你有充分的理由使用它，否则应该使用双等号。在前面的代码中，我还使用了一个很好的函数：`zip`。它的名字来源于现实生活中的拉链，它将两个东西粘合在一起，每次取一个元素。让我给你举个例子：
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding example, I have created the same list in two different ways,
    one more explicit, and the other a little bit more Pythonic. Forget for a moment
    that I had to wrap the `list` constructor around the `zip` call (the reason is
    because `zip` returns an iterator, not a `list`, so if I want to see the result
    I need to exhaust that iterator into something—a list in this case), and concentrate
    on the result. See how `zip` has coupled the first elements of its two arguments
    together, then the second ones, then the third ones, and so on and so forth? Take
    a look at your pants (or at your purse, if you're a lady) and you'll see the same
    behavior in your actual zip. But let's go back to dictionaries and see how many
    wonderful methods they expose for allowing us to manipulate them as we want.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我以两种不同的方式创建了相同的列表，一种更加明确，另一种稍微更加Pythonic。暂时忘记我不得不在`zip`调用周围包装`list`构造函数的事实（原因是因为`zip`返回一个迭代器，而不是`list`，所以如果我想看到结果，我需要将该迭代器耗尽到某个东西中
    - 在这种情况下是一个列表），并专注于结果。看看`zip`是如何将其两个参数的第一个元素配对在一起的，然后是第二个元素，然后是第三个元素，依此类推？看看你的裤子（或者如果你是女士，看看你的钱包），你会看到你的拉链也有相同的行为。但让我们回到字典，看看它们为我们提供了多少精彩的方法来允许我们按照自己的意愿对它们进行操作。
- en: 'Let''s start with the basic operations:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基本操作开始：
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Notice how accessing keys of a dictionary, regardless of the type of operation
    we're performing, is done through square brackets. Do you remember strings, lists,
    and tuples? We were accessing elements at some position through square brackets
    as well, which is yet another example of Python's consistency.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，无论我们执行何种类型的操作，访问字典的键都是通过方括号进行的。你还记得字符串、列表和元组吗？我们之前也是通过方括号访问某个位置的元素，这是Python一致性的又一个例子。
- en: 'Let''s see now three special objects called dictionary views: `keys`, `values`,
    and `items`. These objects provide a dynamic view of the dictionary entries and
    they change when the dictionary changes. `keys()` returns all the keys in the
    dictionary, `values()` returns all the values in the dictionary, and `items()`
    returns all the *(key, value)* pairs in the dictionary.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看三个特殊的对象，称为字典视图：`keys`、`values`和`items`。这些对象提供了字典条目的动态视图，并且随着字典的更改而更改。`keys()`返回字典中的所有键，`values()`返回字典中的所有值，`items()`返回字典中的所有*(键，值)*对。
- en: 'According to the Python documentation: "*Keys and values are iterated over
    in an arbitrary order which is non-random, varies across Python implementations,
    and depends on the dictionary’s history of insertions and deletions. If keys,
    values and items views are iterated over with no intervening modifications to
    the dictionary, the order of items will directly correspond.*"'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Python文档：“*键和值以任意顺序进行迭代，这个顺序是非随机的，在Python的不同实现中会有所变化，并且取决于字典插入和删除的历史。如果在对键、值和项视图进行迭代时没有对字典进行干预修改，那么项的顺序将直接对应*”。
- en: 'Enough with this chatter; let''s put all this down into code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 够啰嗦了，让我们把这一切都写成代码：
- en: '[PRE37]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: There are a few things to notice in the preceding code. First, notice how we're
    creating a dictionary by iterating over the zipped version of the string `'hello'`
    and the list `[0, 1, 2, 3, 4]`. The string `'hello'` has two `'l'` characters
    inside, and they are paired up with the values `2` and `3` by the `zip` function.
    Notice how in the dictionary, the second occurrence of the `'l'` key (the one
    with value `3`), overwrites the first one (the one with value `2`). Another thing
    to notice is that when asking for any view, the original order is now preserved,
    while before Version 3.6 there was no guarantee of that.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: As of Python 3.6, the `dict` type has been reimplemented to use a more compact
    representation. This resulted in dictionaries using 20% to 25% less memory when
    compared to Python 3.5\. Moreover, in Python 3.6, as a side effect, dictionaries
    are natively ordered. This feature has received such a welcome from the community
    that in 3.7 it has become a legit feature of the language rather than an implementation
    side effect. A `dict` is ordered if it remembers the order in which keys were
    first inserted.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll see how these views are fundamental tools when we talk about iterating
    over collections. Let''s take a look now at some other methods exposed by Python''s
    dictionaries; there''s plenty of them and they are very useful:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'All these methods are quite simple to understand, but it''s worth talking about
    that `None`, for a moment. Every function in Python returns `None`, unless the
    `return` statement is explicitly used to return something else, but we''ll see
    this when we explore functions. `None` is frequently used to represent the absence
    of a value, and it is quite commonly used as a default value for arguments in
    function declaration. Some inexperienced coders sometimes write code that returns
    either `False` or `None`. Both `False` and `None` evaluate to `False` in a Boolean
    context so it may seem there is not much difference between them. But actually,
    I would argue there is quite an important difference: `False` means that we have
    information, and the information we have is `False`. `None` means *no information*.
    And no information is very different from information that is `False`. In layman''s
    terms, if you ask your mechanic,  *Is my car ready?*, there is a big difference
    between the answer, *No, it''s not* (`False`) and, *I have no idea* (`None`).'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'One last method I really like about dictionaries is `setdefault`. It behaves
    like `get`, but also sets the key with the given value if it is not there. Let''s
    see an example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'So, we''re now at the end of this tour. Test your knowledge about dictionaries
    by trying to foresee what `d` looks like after this line:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Don't worry if you don't get it immediately. I just wanted to encourage you
    to experiment with dictionaries.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our tour of built-in data types. Before I discuss some considerations
    about what we've seen in this chapter, I want to take a peek briefly at the `collections`
    module.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: The collections module
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When Python general purpose built-in containers (`tuple`, `list`, `set`, and
    `dict`) aren''t enough, we can find specialized container datatypes in the `collections`
    module. They are:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '| **Data type** | **Description** |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
- en: '| `namedtuple()` | Factory function for creating tuple subclasses with named
    fields |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
- en: '| `deque` | List-like container with fast appends and pops on either end |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
- en: '| `ChainMap` | Dictionary-like class for creating a single view of multiple
    mappings |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
- en: '| `Counter` | Dictionary subclass for counting hashable objects |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
- en: '| `OrderedDict` | Dictionary subclass that remembers the order entries were
    added |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
- en: '| `defaultdict` | Dictionary subclass that calls a factory function to supply
    missing values |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
- en: '| `UserDict` | Wrapper around dictionary objects for easier dictionary subclassing
    |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
- en: '| `UserList` | Wrapper around list objects for easier list subclassing |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
- en: '| `UserString` | Wrapper around string objects for easier string subclassing
    |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
- en: We don't have the room to cover all of them, but you can find plenty of examples
    in the official documentation, so here I'll just give a small example to show
    you `namedtuple`, `defaultdict`, and `ChainMap`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: namedtuple
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `namedtuple` is a tuple-like object that has fields accessible by attribute
    lookup as well as being indexable and iterable (it''s actually a subclass of `tuple`).
    This is sort of a compromise between a full-fledged object and a tuple, and it
    can be useful in those cases where you don''t need the full power of a custom
    object, but you want your code to be more readable by avoiding weird indexing.
    Another use case is when there is a chance that items in the tuple need to change
    their position after refactoring, forcing the coder to refactor also all the logic
    involved, which can be very tricky. As usual, an example is better than a thousand
    words (or was it a picture?). Say we are handling data about the left and right
    eyes of a patient. We save one value for the left eye (position 0) and one for
    the right eye (position 1) in a regular tuple. Here''s how that might be:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now let''s pretend we handle `vision` objects all the time, and at some point
    the designer decides to enhance them by adding information for the combined vision,
    so that a `vision` object stores data in this format: *(left eye, combined, right
    eye)*.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Do you see the trouble we''re in now? We may have a lot of code that depends
    on `vision[0]` being the left eye information (which it still is) and `vision[1]`
    being the right eye information (which is no longer the case). We have to refactor
    our code wherever we handle these objects, changing `vision[1]` to `vision[2]`,
    and it can be painful. We could have probably approached this a bit better from
    the beginning, by using a `namedtuple`. Let me show you what I mean:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If within our code, we refer to the left and right eyes using `vision.left`
    and `vision.right`, all we need to do to fix the new design issue is to change
    our factory and the way we create instances. The rest of the code won''t need
    to change:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You can see how convenient it is to refer to those values by name rather than
    by position. After all, a wise man once wrote, *Explicit is better than implicit* (can
    you recall where? Think *Zen* if you can't...). This example may be a little extreme;
    of course, it's not likely that our code designer will go for a change like this,
    but you'd be amazed to see how frequently issues similar to this one happen in
    a professional environment, and how painful it is to refactor them.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: defaultdict
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `defaultdict` data type is one of my favorites. It allows you to avoid
    checking if a key is in a dictionary by simply inserting it for you on your first
    access attempt, with a default value whose type you pass on creation. In some
    cases, this tool can be very handy and shorten your code a little. Let''s see
    a quick example. Say we are updating the value of `age`, by adding one year. If
    `age` is not there, we assume it was `0` and we update it to `1`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now let''s see how it would work with a `defaultdict` data type. The second
    line is actually the short version of a four-lines-long `if` clause that we would
    have to write if dictionaries didn''t have the `get` method (we''ll see all about
    `if` clauses in [Chapter 3](part0087.html#2IV0U0-2ddb708647cc4530a187c2c6c0e9acfe),
    *Iterating and Making Decisions)*:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Notice how we just need to instruct the `defaultdict` factory that we want an
    `int` number to be used in case the key is missing (we'll get `0`, which is the
    default for the `int` type). Also, notice that even though in this example there
    is no gain on the number of lines, there is definitely a gain in readability,
    which is very important. You can also use a different technique to instantiate
    a `defaultdict` data type, which involves creating a factory object. To dig deeper,
    please refer to the official documentation.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: ChainMap
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ChainMap` is an extremely nice data type which was introduced in Python 3.3\.
    It behaves like a normal dictionary but according to the Python documentation:
    "*is provided for quickly linking a number of mappings so they can be treated
    as a single unit<q class="calibre30">"</q>.* This is usually much faster than
    creating one dictionary and running multiple update calls on it. `ChainMap` can
    be used to simulate nested scopes and is useful in templating. The underlying
    mappings are stored in a list. That list is public and can be accessed or updated
    using the maps attribute. Lookups search the underlying mappings successively
    until a key is found. By contrast, writes, updates, and deletions only operate
    on the first mapping.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'A very common use case is providing defaults, so let''s see an example:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: I just love how Python makes your life easy. You work on a `ChainMap` object,
    configure the first mapping as you want, and when you need a complete dictionary
    with all the defaults as well as the customized items, you just feed the `ChainMap`
    object to a `dict` constructor. If you have never coded in other languages, such
    as Java or C++, you probably won't be able to appreciate fully how precious this
    is, and how Python makes your life so much easier. I do, I feel claustrophobic
    every time I have to code in some other language.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Enums
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Technically not a built-in data type, as you have to import them from the `enum`
    module, but definitely worth mentioning, are enumerations. They were introduced
    in Python 3.4, and though it is not that common to see them in professional code
    (yet), I thought I'd give you an example anyway.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'The official definition goes like this: "*An enumeration is a set of* *sy**mbolic*
    *names (members) bound to unique, constant values. Within an enumeration, the
    members can be compared by identity, and the enumeration itself can be iterated
    over*."'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'Say you need to represent traffic lights. In your code, you might resort to
    doing this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'There''s nothing special about the preceding code. It''s something, in fact,
    that is very common to find. But, consider doing this instead:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Ignoring for a moment the (relative) complexity of a class definition, you can
    appreciate how this might be more advantageous. The data structure is much cleaner,
    and the API it provides is much more powerful. I encourage you to check out the
    official documentation to explore all the great features you can find in the `enum`
    module. I think it's worth exploring, at least once.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Final considerations
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That's it. Now you have seen a very good proportion of the data structures that
    you will use in Python. I encourage you to take a dive into the Python documentation
    and experiment further with each and every data type we've seen in this chapter.
    It's worth it, believe me. Everything you'll write will be about handling data,
    so make sure your knowledge about it is rock solid.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Before we leap into [Chapter 3](part0087.html#2IV0U0-2ddb708647cc4530a187c2c6c0e9acfe), *Iterating
    and Making Decisions*, I'd like to share some final considerations about different
    aspects that to my mind are important and not to be neglected.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Small values caching
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we discussed objects at the beginning of this chapter, we saw that when
    we assigned a name to an object, Python creates the object, sets its value, and
    then points the name to it. We can assign different names to the same value and
    we expect different objects to be created, like this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the preceding example, `a` and `b` are assigned to two `int` objects, which
    have the same value but they are not the same object, as you can see, their `id`
    is not the same. So let''s do it again:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Oh, oh! Is Python broken? Why are the two objects the same now? We didn't do
    `a = b = 5`, we set them up separately. Well, the answer is performances. Python
    caches short strings and small numbers, to avoid having many copies of them clogging
    up the system memory. Everything is handled properly under the hood so you don't
    need to worry a bit, but make sure that you remember this behavior should your
    code ever need to fiddle with IDs.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: How to choose data structures
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we''ve seen, Python provides you with several built-in data types and sometimes,
    if you''re not that experienced, choosing the one that serves you best can be
    tricky, especially when it comes to collections. For example, say you have many
    dictionaries to store, each of which represents a customer. Within each customer
    dictionary, there''s an `''id'': ''code''` unique identification code. In what
    kind of collection would you place them? Well, unless I know more about these
    customers, it''s very hard to answer. What kind of access will I need? What sort
    of operations will I have to perform on each of them, and how many times? Will
    the collection change over time? Will I need to modify the customer dictionaries
    in any way? What is going to be the most frequent operation I will have to perform
    on the collection?'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'If you can answer the preceding questions, then you will know what to choose.
    If the collection never shrinks or grows (in other words, it won''t need to add/delete
    any customer object after creation) or shuffles, then tuples are a possible choice.
    Otherwise, lists are a good candidate. Every customer dictionary has a unique
    identifier though, so even a dictionary could work. Let me draft these options
    for you:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Some customers we have there, right? I probably wouldn't go with the tuple option,
    unless I wanted to highlight that the collection is not going to change. I'd say
    usually a list is better, as it allows for more flexibility.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Another factor to keep in mind is that tuples and lists are ordered collections.
    If you use a dictionary (prior to Python 3.6) or a set, you lose the ordering,
    so you need to know if ordering is important in your application.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: What about performances? For example, in a list, operations such as insertion
    and membership can take *O(n)*, while they are *O(1)* for a dictionary. It's not
    always possible to use dictionaries though, if we don't have the guarantee that
    we can uniquely identify each item of the collection by means of one of its properties,
    and that the property in question is hashable (so it can be a key in `dict`).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: If you're wondering what *O(n)* and *O(1)* mean, please Google `big O notation`.
    In this context, let's just say that if performing an operation *Op* on a data
    structure takes *O(f(n))*, it would mean that *Op* takes at most a time *t ≤ c
    * f(n)*  to complete, where *c* is some positive constant, *n* is the size of
    the input, and *f* is some function. So, think of *O(...)* as an upper bound for
    the running time of an operation (it can be used also to size other measurable
    quantities, of course).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Another way of understanding if you have chosen the right data structure is
    by looking at the code you have to write in order to manipulate it. If everything
    comes easily and flows naturally, then you probably have chosen correctly, but
    if you find yourself thinking your code is getting unnecessarily complicated,
    then you probably should try and decide whether you need to reconsider your choices.
    It's quite hard to give advice without a practical case though, so when you choose
    a data structure for your data, try to keep ease of use and performance in mind
    and give precedence to what matters most in the context you are in.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: About indexing and slicing
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the beginning of this chapter, we saw slicing applied on strings. Slicing,
    in general, applies to a sequence: tuples, lists, strings, and so on. With lists,
    slicing can also be used for assignment. I''ve almost never seen this used in
    professional code, but still, you know you can. Could you slice dictionaries or
    sets? I hear you scream, *Of course not!*. Excellent; I see we''re on the same
    page here, so let''s talk about indexing.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one characteristic about Python indexing I haven''t mentioned before.
    I''ll show you by way of an example. How do you address the last element of a
    collection? Let''s see:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If the list `a` has 10 elements, because of the 0-index positioning system
    of Python, the first one is at position 0 and the last one is at position 9\.
    In the preceding example, the elements are conveniently placed in a position equal
    to their value: `0` is at position 0, `1` at position 1, and so on.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in order to fetch the last element, we need to know the length of the whole
    list (or tuple, or string, and so on) and then subtract `1`. Hence: `len(a) -
    1`. This is so common an operation that Python provides you with a way to retrieve
    elements using **negative ****indexing**. This proves very useful when you do
    data manipulation. Here''s a nice diagram about how indexing works on the string
    `"HelloThere"` (which is Obi-Wan Kenobi sarcastically greeting General Grievous):'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00006.jpeg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
- en: Trying to address indexes greater than **9** or smaller than **-10** will raise
    an `IndexError`, as expected.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: About the names
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have noticed that, in order to keep the examples as short as possible,
    I have called many objects using simple letters, like `a`, `b`, `c`, `d`, and
    so on. This is perfectly OK when you debug on the console or when you show that
    `a + b == 7`, but it's bad practice when it comes to professional coding (or any
    type of coding, for that matter). I hope you will indulge me if I sometimes do
    it; the reason is to present the code in a more compact way.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: In a real environment though, when you choose names for your data, you should
    choose them carefully and they should reflect what the data is about. So, if you
    have a collection of `Customer` objects, `customers` is a perfectly good name
    for it. Would `customers_list`, `customers_tuple`, or `customers_collection` work
    as well? Think about it for a second. Is it good to tie the name of the collection
    to the datatype? I don't think so, at least in most cases. So I'd say if you have
    an excellent reason to do so, go ahead; otherwise, don't. The reason is, once
    that `customers_tuple` starts being used in different places of your code, and
    you realize you actually want to use a list instead of a tuple, you're up for
    some fun refactoring (also known as **wasted time**). Names for data should be
    nouns, and names for functions should be verbs. Names should be as expressive
    as possible. Python is actually a very good example when it comes to names. Most
    of the time you can just guess what a function is called if you know what it does.
    Crazy, huh?
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 2* of *Meaningful Names* of *Clean Code*, *Robert C. Martin*, *Prentice
    Hall* is entirely dedicated to names. It''s an amazing book that helped me improve
    my coding style in many different ways, and is a must-read if you want to take
    your coding to the next level.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've explored the built-in data types of Python. We've seen
    how many there are and how much can be achieved by just using them in different
    combinations.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: We've seen number types, sequences, sets, mappings, collections (and a special
    guest appearance by `Enum`), we've seen that everything is an object, we've learned
    the difference between mutable and immutable, and we've also learned about slicing
    and indexing (and, proudly, negative indexing as well).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: We've presented simple examples, but there's much more that you can learn about
    this subject, so stick your nose into the official documentation and explore.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Most of all, I encourage you to try out all the exercises by yourself, get your
    fingers using that code, build some muscle memory, and experiment, experiment,
    experiment. Learn what happens when you divide by zero, when you combine different
    number types into a single expression, when you manage strings. Play with all
    data types. Exercise them, break them, discover all their methods, enjoy them,
    and learn them very, very well.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: If your foundation is not rock solid, how good can your code be? And data is
    the foundation for everything. Data shapes what dances around it.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: The more you progress with the book, the more it's likely that you will find
    some discrepancies or maybe a small typo here and there in my code (or yours).
    You will get an error message, something will break. That's wonderful! When you
    code, things break all the time, you debug and fix all the time, so consider errors
    as useful exercises to learn something new about the language you're using, and
    not as failures or problems. Errors will keep coming up until your very last line
    of code, that's for sure, so you may as well start making your peace with them
    now.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is about iterating and making decisions. We'll see how actually
    to put those collections to use, and take decisions based on the data we're presented
    with. We'll start to go a little faster now that your knowledge is building up,
    so make sure you're comfortable with the contents of this chapter before you move
    to the next one. Once more, have fun, explore, break things. It's a very good
    way to learn.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
