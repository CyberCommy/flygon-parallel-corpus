- en: Password Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 4](part0049.html#1ENBI0-5a228e2885234f4ba832bb786a6d0c80), *Resources
    Discovery*, we learned how to write a basic web application, BruteForcer, to help
    us with resources discovery.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to learn about:'
  prefs: []
  type: TYPE_NORMAL
- en: How password attacks work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our first password BruteForcer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding support for digest authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Form-based authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How password attacks work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to take a look at what password cracking is; it
    is also known as password testing. We will cover the different approaches we can
    take when doing password cracking and finally, we're going to learn about password
    policies and account locking, which is important when planning a password attack.
  prefs: []
  type: TYPE_NORMAL
- en: Password cracking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Password cracking is the most common type of brute force attack against web
    applications. It is an attack against the login credentials, and it exploits the
    fact that passwords are usually weak, due to the fact that users need to remember
    them and they need a difficult-to-guess word.
  prefs: []
  type: TYPE_NORMAL
- en: Password cracking is usually done with a dictionary of known words, or more
    exactly, with a list of well-known and widely used passwords. These lists are
    created by taking the most used passwords from the list of passwords leaked from
    different online services. Password lists may also include variations of words,
    such as those generated by replacing letters with numbers such as O with zero,
    and I with one.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we plan a password attack, we have different options as to how to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vertical scanning**: The most common and most used is vertical scanning,
    which takes one username and tries all passwords in the dictionary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Horizontal scanning**: This is basically the opposite of vertical scanning.
    It takes a password and tests it against all usernames. This is usually done in
    order to prevent account locking after many invalid login attempts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Diagonal scanning**: This mixes a different username and password each time,
    reducing the possibility of the user being detected or blocked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Three-dimensional scanning**: Sometimes, diagonal scanning is not enough,
    and we need to go further in order to prevent detection. This is when three-dimensional
    scanning comes into play. This is a combination of horizontal, vertical, or diagonal,
    but in this case, we have multiple machines that we can launch our request on
    or HTTP proxies that will allow us to use different source IPs for each request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Four-dimensional scanning**: This adds a time delay per request on top of
    source IP rotation or distribution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Password policies and account locking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A password policy is a set of rules designed to enhance computer security by
    encouraging users to employ strong passwords and use them properly.
  prefs: []
  type: TYPE_NORMAL
- en: The password policy may either be advisory or mandated, such as via technical
    means, like forcing it at the time of account creation or when the password needs
    to be changed. The password policy can dictate the length of passwords, case sensitivity,
    mix of lower and upper case, characters allowed, characters, numbers and symbols,
    reuse of past passwords, how many previous passwords you can't use, blacklisted
    passwords, and very easy-to-guess words and combinations such as **password** and
    **123456**.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the password policy can define things such as how frequently you need
    to change your password and whether to lock the account after X number of wrong
    attempts. So, now we understand how a password policy works. We have to be careful
    when we launch a password cracking test, because we can end up blocking thousands
    of accounts, and that could mean the end of the penetration test and some problems
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: This is illegal to perform without authorization.
  prefs: []
  type: TYPE_NORMAL
- en: Our first password BruteForcer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to look at what basic authentication is, how it
    works, and then we're going to create our first password BruteForcer for this
    method. Finally, we're going to test the script against our victim web application.
  prefs: []
  type: TYPE_NORMAL
- en: Basic authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Basic authentication is one of the simplest techniques for enforcing access
    control to web application resources. It is implemented by adding special HTTP
    headers which is insecure by design, as the credentials are being sent encoded
    with the Base64 method. Encoded means that it can be reversed easily. For example,
    we can see what a basic authentication header looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The encoded string can be decoded and we found that the password being sent
    is equal to `admin123`.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, when you see a string that ends in equals, it could be a base64 encoding
    string.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the password cracker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create our password cracker:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's go back to the Atom editor and open the `back2basics.py` file. In `Section-5`,
    we can see that in the `import` area, we don't have anything new, and the structure
    of the script is pretty similar to the previous one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have the `start` function that will show the `banner`, and it will pass
    the command line and read the parameters—the same parameters, except we have the
    `user` parameter now. Then, it will invoke the function `launcher_thread` with
    the variables `passwords`, `threads`, `user`, and `url`, which correspond to the
    dictionary of passwords, the number of threads, the username to be used, and the
    target URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in `launcher_thread`, we have a `while` loop that will continue until
    we don''t have any words left in the array passwords:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So, for every word in the array, we do a `pop`, then we instantiate the `request_performer`
    class with the `n`, the `username`, and the `url`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `request_performer`, we define some attributes to the object, and then we
    execute the GET request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The important bit here is the `auth` parameter, which tells requests to use
    basic authentication with the provided username and password.
  prefs: []
  type: TYPE_NORMAL
- en: Then, if the status is `200`, we print that the password was found and used.
    We use the variable `hit` in order to determine if we found a valid password and
    to stop sending requests.
  prefs: []
  type: TYPE_NORMAL
- en: That's it; now, we have our first basic authentication BruteForcer. Let's try
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Before running it, remember the previous section, when we discovered different
    directories, and there was one that returned the status code of 401? This means
    that it is requesting authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'The directory was `/Admin`, and when we try to access it, we can see the authentication
    popup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s go to the Terminal. We''re going to run it with the following command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It is very simple, but this is only for demonstration purposes. We can see
    that the password for the user `admin` is `administrator` in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s try it on the website. You will be able to see that it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, you know how to perform a basic authentication password test in web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Adding support for digest authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to start learning about what digest authentication
    is. Then, we're going to modify our password BruteForcer to support this method,
    and finally, we're going to test the new script against our test web application.
  prefs: []
  type: TYPE_NORMAL
- en: What is digest authentication?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Digest authentication is a more secure option to basic authentication. It uses
    MD5 to do the hashing of the username and password plus a nonce. The **nonce**
    is used to prevent replay attacks, and it is sent by the server after the user
    requests a protected resource. The browser creates the response with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, the response is an **MD5** hash of **HA1** nonce **HA2**. The realm
    value defines a protection space. If the credentials work for a page in one realm,
    they will also work for other pages in that same realm. Now, let's add support
    for digest to our script.
  prefs: []
  type: TYPE_NORMAL
- en: Adding digest authentication to our script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go back to our editor and open the `back2digest.py` file. We added a
    few lines to include support for digest authentication. First, we added this import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code allows us to select the authentication. In a `request_performer`,
    we need to add a condition to check if the user chose to run a `digest` authentication
    attack or `basic`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We specify the different methods in the request instantiation. In the case of
    `digest`, it is slightly different as we need to specify `HTTPDigestAuth` in the
    `auth` parameter. Also, we need to add in the `start` function the handler of
    the new parameter, we add the `-m` in the `getopt` function, the new parameter
    that will manage the type of authentication method. And we'll add it to every
    function as a variable.
  prefs: []
  type: TYPE_NORMAL
- en: That's it. We should be able to test against the digest-protected resource.
    Let's do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to the Terminal but first, let''s check the resource `backoffice`
    that we found in the `robot.txt`. We can see that it needs authentication, and
    to the user it is exactly the same as basic authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look at the headers of the response that the server sent us. Click on
    the Open menu option on the right-hand side of the Mozilla browser, select Developer |
    Network, and then click on the Reload button. Cancel the Authentication Required
    window and select the row as shown in the following screenshot. We can see that
    there is a WWW- Authenticate header with a `Digest realm` parameter, the `nonce`,
    and the `algorithm= MD5`. So let''s go to the console to run our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00056.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s run it against the directory back office. We run the `back2digest.py`
    with the same parameters as before, but we change the resource to `/backoffice`
    instead of `/admin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We change the user to `administrator`, we keep `5` threads and the same dictionary, `pass.text`,
    and finally, a new parameter method indicating `digest`, and we run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00057.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: No luck this time. None of the combinations were valid; maybe the user doesn't
    exist. Let's try another user, `admin` for example. Let's run it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Great, we found the password for the user `admin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00058.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s try this in the browser now. Set the User Name as `admin`, and Password
    as `admin123`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00059.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Perfect, we're in. Not much to see in here. Now you have your password BruteForcer
    that can do basic and digest authentication. Congratulations! Let's continue adding
    more functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Form-based authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to learn how to brute force form-based authentication
    in web applications. We're going to start learning what form-based authentication
    is, and then we're going to modify one of our previous tools to enable this attack.
    Finally, we're going to test our script against the victim web application and
    fine tune it to improve the results.
  prefs: []
  type: TYPE_NORMAL
- en: Form-based authentication overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with a quick overview of form-based authentication. Form-based authentication
    is the most common and widely used method of authentication in web applications.
  prefs: []
  type: TYPE_NORMAL
- en: This method is not standardized as the previous two methods we learned were,
    which means that the implementation of this method will vary. Basically, the web
    application will present a form that will prompt the user for the username and
    password. Then, that data will go to the server where it will be evaluated, and
    if the credentials are valid, it will provide a valid session cookie to the user,
    and it will let the user access the protected resource.
  prefs: []
  type: TYPE_NORMAL
- en: Let's add this to our previous script. So, you're probably waiting for me to
    say let's go back to the editor and open the previous scripts, but no. Let's just
    stop for a minute and evaluate what our best option is here. We're going to deal
    with forms, and there is no standard as to how to handle authentication on forms,
    so we'll need to have good filtering in order to weed out the incorrect attempts
    and to be able to identify the good ones.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, instead of adding all the filtering code to the previous script,
    we add the post handling and payload handling to the `forzaBruta-forms.py` script
    from `Section 5`. So now, go back to the editor and open the file. Let's start
    adding the code to enable it to brute force login forms.
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t add a new `import`. We can go to the `start` function and add the
    `getopt` function for handling the post `payload`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this case, it will be the `-p`. If `-p` is present, we assign its value to
    the `payload` variable. We pass `payload` to `launcher_thread`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, inside the `launcher_thread`, we pass it again to `request_performer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We add the `payload` to the `init` function of `request_performer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'And then we check if the payload is empty or not. If it''s not empty, we replace
    the keyword `FUZZ` with the dictionary word, otherwise we don''t touch it and
    leave it as it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we go to the `run` method, and we need a conditional to tell us when
    to use `post` and when to use `get`. We can do this by checking if `self.payload`
    is empty, in which case we use `get`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If it is not empty, we'll be using the `post` request.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `post` request, we need the payload in the form of a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have it as a string with `&` and `=` signs, so we're going to replace
    the symbols with one space, then we're going to split the string using spaces,
    creating a list of elements.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we create a `post` request using that payload, and those are all the changes
    necessary to be able to perform password brute forcing on login forms. Now, it
    will be good to test it against our victim web application. Let's do it.
  prefs: []
  type: TYPE_NORMAL
- en: How do we set up a brute force attack against forms? Let's open a page that
    has the login form, in our case, `www.scruffybank.com/login.php`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We right-click on the page and we select View Page Source:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00060.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we need to find the form action, that is, where the credentials are going
    to be sent to be verified. In this case, it is `check_login.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00061.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We also need the names of the variables, in this case, `username` and `password`.
  prefs: []
  type: TYPE_NORMAL
- en: That's the data we need to set up our attack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to the Terminal and run the script with the following command
    line, `forzaBruta-forms.py`, followed by the same URL. This time, we change the
    login to `check_login.php`. We leave the threads as `5`. In this case, we have
    the `username` and `password` parameters in the payload of the `post`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to concatenate the parameters with an `&`. `weaksource.txt` is a list
    of the weakest passwords used by people in different services. Now, let''s fire
    this up. We can see that all of the results are `302`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00062.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So, filtering by code won't help us. We can filter out the `chars` equal to
    `2373` which we know are our failed attempts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify the code to filter the `chars` instead of the code with the command-line
    parameter `-c`. We change the code to filter by `chars`. Doing so, we can filter
    by `chars` without modifying much of the code. Go back to the editor and modify
    the line `self.hidecode !=code` to `self.hidecode != chars:`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s save this. Now, we change the command line to add `-c 2373` to filter
    all results out, and we run it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Sweet. We have our username and password:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00063.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations, you now know how to test password security against the three
    most common web application authentication methods! In this section, we also leveraged
    previous work.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the different authentication methods commonly
    used in web applications, and we created one tool to test basic and digest authentication.
    Finally, we created a login form authentication BruteForcer.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 6](part0070.html#22O7C0-5a228e2885234f4ba832bb786a6d0c80), *Detecting
    and Exploiting SQL Injection Vulnerabilities*, we're going to learn about detecting
    and exploiting SQL injection vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
