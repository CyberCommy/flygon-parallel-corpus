- en: Navigational Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll explore some of the most useful navigational object-oriented
    patterns and learn how to apply them in the Angular way. Navigational patterns
    are used to organize events that are related to the navigation of our users on
    our apps.
  prefs: []
  type: TYPE_NORMAL
- en: Angular is, by itself, an object-oriented framework, and it forces you to do
    most of your development in certain ways. For example, you are required to have
    components, services, pipes, and so on. Forcing these building blocks upon you contributes
    to building a good architecture, very much like what the Zend framework does for
    PHP, or Ruby on Rails for Ruby. Of course, in addition, frameworks are here to
    make your life easier and speed up development time.
  prefs: []
  type: TYPE_NORMAL
- en: While the Angular way of designing things is way above average, we can always
    do better. I do not claim that what I present in this chapter are the ultimate
    designs and that you will be able to use them to resolve anything from bakery
    one-pagers to dashboards for the Mars One mission—such a design doesn't exist,
    unfortunately—but it will definitively improve your toolbelt.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about the following patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: Model-view-controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Oh MVC, good ol' MVC. You served us well for many years. Now, people want you
    to retire, without fuss if possible. Even I can see how younger, unidirectional
    user interface architectures can outsmart you and make you look like a relic from
    the past.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll first describe what the model-view-controller is, regardless
    of the programming language used to implement it, and then we'll see the shortcomings
    of applying MVC for frontend programming. Finally, I'll present a way of implementing
    an MVC that makes sense with Angular in terms of ease of implementation, maintenance,
    and performance.
  prefs: []
  type: TYPE_NORMAL
- en: Model-view-controller at large
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The whole principle behind the model-view-controller design pattern is relatively
    simple. Indeed, as shown in the following diagram, it''s composed of three blocks:
    Model, View, and Controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/04b1d7a0-5b88-441d-9609-ff9d10b06920.png)Model-view-controller overview'
  prefs: []
  type: TYPE_NORMAL
- en: 'The components are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The Model stores the data required by the application according to commands
    sent by the Controller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Controller receives actions from the user (such as the click of a button)
    and directs model updates accordingly. It can also switch which view is used at
    any given moment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The View is generated and updated every time the model changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And that's it.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see what a simple MVC implementation would look like in pure TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s define a `Movie` class like we did back in [Chapter 3](fac4936a-292a-4b12-ac60-394bacad0f16.xhtml),
    *Classical Patterns*. In this version of the `Movie` class, we only have two attributes:
    `title` and `release_year`, which are defined using a TypeScript constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define a `Model` class that imports the `movie.ts` file, containing
    the `Movie` class, using the `reference` keyword. This model class, which will
    be responsible for updating the view, has a movie array and two methods. The first
    method, `addMovie(title:string, year:number)`, is `public` and appends a new movie
    at the end of the `movies` attribute. It also calls the second method of the class, `appendView(movie:Movie)`,
    which is `private`. This second method manipulates the view as per model-view-controller
    definition. The view manipulation is rather simple: we append a new `li` tag to
    the `#movie` element of the view. The content of the newly created `li` tag is
    a concatenation of the movie title and release year:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now define a controller for our pure TypeScript model-view-controller.
    The controller has a `private model:Model` attribute that is initiated in the
    constructor. In addition, a `click` method is defined. This method takes a `string`
    and a `number` in parameters for the title and the release year, respectively.
    As you can see, the `click` method forwards the title and the release year to
    the `addMovie` method of the model. Then, the controller''s job is done. It does
    not manipulate the view. You''ll also notice the last line of the `controller.ts`
    file: `let controller = new Controller();`. This line allows us to create an instance
    of the controller that the view can bind to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The last piece of our model-view-controller implementation would be the view.
    We have a bare-bones HTML form that, on submit, invokes the following: `controller.click(this.title.value,
    this.year.value); return false;`. `controller` has been defined in the `controller.ts`
    file with `let controller = new Controller();`. Then, for the parameters, we send
    `this.title.value` and `this.year.value`, where `this` refers to`<form>`. `title`
    and `year` refer to the fields for the title and the release year of the movie,
    respectively. We must also add `return false;` to prevent the page from reloading.
    Indeed, the default behavior of an HTML form, on submit, is to navigate to the
    action URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the header, we add the `mvc.js` script generated by the following command:
    `tsc --out mvc.js controller.ts model.ts movie.ts`. The generated JavaScript looks
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'On the execution side, at loading time, the HTML page would look like it does
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9e02495c-ab05-4190-b945-0a5e2e4f1ff5.png)Model-view-controller at
    loading point'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, if you use the form and add a movie, it''ll automatically impact the
    view and display the new movie:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c74733ae-6571-4505-bf42-3c75716c554e.png)Model-view-controller after
    using the form'
  prefs: []
  type: TYPE_NORMAL
- en: Model-view-controller limitations for the frontend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, why is the model-view-controller pattern not that widely used when it comes
    to frontend programming supported by frameworks such as Angular? First, if you
    are using Angular for an app that provides a service, you are likely to have a
    backend with which you exchange some sort of information. Then, if your backend
    also uses the model-view-controller design pattern, you''ll end up with the following
    hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/48faf0b9-64c8-4aff-8760-9aa8e7e2623f.png)Model-view-controller frontend
    and backend'
  prefs: []
  type: TYPE_NORMAL
- en: In this hierarchy, we have an MVC implementation on top of another MVC implementation.
    The implementations communicate with each other via an API service that sends
    requests to the backend controller and parses the resultant view. As a concrete
    example, if your user has to sign in to your app, they'll see the `signin` view
    on the frontend, which is powered by a `user` model and a `signin` controller.
    Once all of the information (email address, password) has been entered, the user
    clicks on the signin button. This click triggers a model update and the model
    then triggers an API call using the API service. The API service makes a request
    to the "user/signin" endpoint of your API. On the backend, the request is received
    by the `user` controller and forwarded to the `user` model. The backend `user`
    model will query your database to see if there is a matching user with the provided
    email address and password. Finally, a view will be output, containing the user
    information if the login was successful. Going back on the frontend, the API service
    will parse the produced view and return the relevant information to the frontend
    `user` model. In turn, the frontend `user` model will update the frontend `view`.
  prefs: []
  type: TYPE_NORMAL
- en: For some developers, that many layers and the fact that the architecture is
    kind of duplicated on the frontend and the backend just feels wrong, even though
    it brings maintainability through a well-defined separation-of-concerns.
  prefs: []
  type: TYPE_NORMAL
- en: The dual model-view-controller isn't the only concern. Another problem is that
    the frontend models will not be *pure* models as they must account for variables
    regarding the UI itself such as visible tab, forms validity, and so on. Hence,
    your frontend models tend to become hideous blobs of code where UI variables rub
    shoulders with the actual representation of your user.
  prefs: []
  type: TYPE_NORMAL
- en: Now, as always, you can avoid these traps and harness the advantages of the
    MVC pattern. Let's see how in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Angular's model-view-controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, I present an architecture for the MVC in Angular that proved
    itself. I used this architecture for the past 18 months at `toolwatch.io` (web,
    Android, and iOS). Obviously, the features we propose on the web version or on
    the mobile apps are the same and work in the same way. What changes are the views
    and the navigation schema.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram represents the overall architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5f5eae16-e4ec-49f1-b524-8fece9c61d58.png)MVC for Angular'
  prefs: []
  type: TYPE_NORMAL
- en: From top to bottom, we have the backend, the reusable pieces of the frontend,
    and the specialized frontend (mobile or web). As you can see, on the backend,
    nothing changes. We kept our classical MVC. Note that the frontend parts would
    work also with a non-MVC backend.
  prefs: []
  type: TYPE_NORMAL
- en: Our model will use that service to get, put, and delete a plain TypeScript object
    from the remote database through a hypothetical; JSON API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what our `user` TypeScript object looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing too fancy here; only a plain TypeScript object that contains two attributes:
    `email:_string` and `password:_string`. These two attributes are initialized in
    the constructor using the TypeScript inline declaration style. We also leverage
    the getter/setter of TypeScript in order to access the `_password:string` and
    `_email:string` attributes. You might have noticed that the TypeScript getters/setters
    look like C# properties. Well, Microsoft is one of the principal industrial investigators
    for TypeScript, so it makes sense.'
  prefs: []
  type: TYPE_NORMAL
- en: I do like the conciseness of the writing, especially when combined with the
    inline attribute declaration in the constructor. What I don't like, however, is
    the necessity for underscored variables names. The problem is that, once again,
    this TypeScript will be transpiled to JavaScript, and in JavaScript, variables
    and functions are a bit more abstract than, let's say, Java or C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'Indeed, in our current example, we could invoke the getter of the `User` class
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, TypeScript doesn''t care about the type of the target it''s
    calling. It can be a variable named `email` or a function named `email()`. Either
    way, it works. The underlying rationale behind these odd behaviors, for an object-oriented
    programmer that is that in JavaScript, is that it''s acceptable to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Consequently, we need to differentiate the actual variables of the function
    with different names, hence the `_`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to our MVC implementation now that we have a fool-proof user
    object to manipulate. Now, we can have a `user` model that manipulates the `user`
    POTO (plain old TypeScript object) and the necessary variable for the graphical
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Our model, named `UserModel`, receives an injection of an `APIService`. The
    implementation of the `APIService` is left to the reader as an exercise. In addition
    to the `APIService`, the `UserModel` owns the`user:User` and`loading:bool` attributes.
    The `user:User` represents the actual user with its password and email address.
    The `loading:bool`, however, will be used to determine whether or not a loading
    spinner should be visible in the view. As you can see, the `UserModel` defines
    the `signin` and `signup` methods. In these methods, we call the `getUser` and
    `postUser` methods of the `APIService`, which both take a user in an argument
    and return a promise containing said user that's been synchronized via the JSON
    API. On reception of these promises, we turn off the `loading:bool` spinner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the `APIService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `APIService` makes HTTP calls to parse a local JSON file containing the
    user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`getUser(email:string, password:string):Promise<User>` and `postUser(email:string,
    password:string):Promise<User>` are using promises, just like we showed you in
    the previous chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, there is the controller, which will also be a component in an Angular
    environment, as Angular components control the view that is displayed and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the controller (component) is really simple. We only have a
    reference to the model and we receive an injected `APIService` to be transfered
    to the model. Then, we have the `signinClick` and `signupClick` methods which
    receive user input from the view and transfer them to the model. The last piece,
    the view, looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have two forms: one for the signin and one for the signup. The forms
    are alike except for the `onsubmit` method they use. The signin form uses the
    `signinClick` method of our controller and the signup form uses the `signupClick`
    method. In addition to these two forms, we also have, on each form, a *font awesome*
    spinner that is only visible when the user model is *loading*. We achieve this
    by using the `[hidden]`Angular directive: `[hidden]="!model.loading"`. Similarly,
    the submit buttons are hidden when the model is loading.'
  prefs: []
  type: TYPE_NORMAL
- en: So, here it is, a functional MVC applied to Angular.
  prefs: []
  type: TYPE_NORMAL
- en: As I said at the beginning of this section, for me, the true usefulness of the
    MVC pattern in Angular comes from its extensibility. Indeed, leveraging the object-oriented
    aspect (and what comes with it) of TypeScript allows us to specialize controllers
    and models for different Angular applications. For example, if you have an Angular
    website and an Angular mobile application, as I do with `toolwatch.io`, then you
    have business logic you can use on both sides. It would be a shame to have two
    signins, two signups, and two of everything to code and maintain over time when
    we could have only one!
  prefs: []
  type: TYPE_NORMAL
- en: At `toolwatch.io`, for example, the web application uses standard Angular and
    we built the mobile applications using Ionic and Angular. Obviously, we have a
    lot of frontend logic shared between the mobile apps (Android and iOS) and the
    website. Ultimately, they tend to achieve the same purposes and functionalities.
    The only difference is the medium that's being used to utilize those functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, I loosely represent a more complete way of leveraging
    the MVC pattern with a focus on reusability and extensibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/76a03142-0e91-49ae-bae9-33027d6fd7ce.png)MVC for Angular'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, the backend stays as is. We have the same MVC pattern there. As
    a reminder, the MVC pattern on the backend is entirely up to you, and you could
    take advantage of the frontend MVC pattern with a functional Go backend, for example.
    What differs from the previous version of the MVC exposed here is the introduction
    of the *Reusable Frontend* part. In this part, we still have an API service in
    charge of consuming our JSON API. Then, we have a model that implements the `IModel`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This interface defines the `put`, `post`, `delete`, and `patch` methods that
    have to be implemented in the subsequent models. The `POTO` type that these methods
    take as parameters and return is the mother class for any domain model you have
    in your program. A domain model represents a synchronizable entity of your business
    logic such as the `User` we used before. The domain model and the model part of
    the model-view-controller are not to be confused. They are not the same thing
    at all. In this architecture, `User` would expend `POTO`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The model (of model-view-controller this time) contains a `POTO` in addition
    to implementing the `IModel` interface. It also contains the variables and methods
    you need to update your views. The implementation of the model itself is rather
    straightforward, as I showed earlier in this section. However, we can kick things
    up a notch by leveraging the generic aspect of TypeScript and envision the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have a generic `AbstractModel` that is constrained by `POTO`. This
    means that the actual instance of the `AbstractModel` generic class (known as
    a template in languages such as C++) is constrained to have a class specializing
    `POTO`. In other words, only domain models such as `User` can be used. So far,
    the separation of concern is excellent as well as its reusability. The last piece
    of the reusable part is the controller. In our signup/signin example, it would
    look very much like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now, why do we need an additional building block here, and why can't we use
    a simple Angular component as we did for the simpler version of the Angular model-view-controller?
    Well, the thing is that, depending on what you use on top of your Angular core
    (Ionic, Meteor, and so on), the component isn't necessarily the main building
    block. For example, in the Ionic2 world, you use `Pages`, which are their custom
    version of the classical component.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for example, the mobile part would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If need be, you can also extend `UserModel` and add some specialization, as
    shown in the preceding diagram. On the browser side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Once again, you can also extend `UserModel` and add some specialization. The
    only remaining block to cover is the view. To my despair, there is no way to use
    extends or a style file for that. Hence, we are doomed to have duplication of
    HTML files between clients unless the HTML file is exactly the same between the
    mobile app and the browser app. From experience, this doesn't happen very often.
  prefs: []
  type: TYPE_NORMAL
- en: The whole reusable frontend can be shipped as a Git submodule, a standalone
    library, or as an `NgModule`. I personally use the git submodule approach as it
    allows me to have two separate repositories while enjoying auto-refresh on the
    client I am working on when I perform a modification on the shared frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this model-view-controller also works if you have several frontends
    hitting the same backend instead of several types of frontends. For example, in
    an e-commerce setup, you may want to have differently branded websites to sell
    different products that are all managed in the same backend, like what's possible
    with Magento's views.
  prefs: []
  type: TYPE_NORMAL
- en: Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Redux is a pattern that allows you to manage your event and application states
    in a safe way. It allows you to make sure that your application-wide states, resulting
    from navigation events or not, are managed in a single, non-accessible place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, the states of your application are stored in a TypeScript interface.
    Following the example we used in the previous section, we will implement login/logout
    functionalities for a user using a custom `APIService` that consumes JSON. In
    our case, the application has only one state: `logged`. Consequently, the interface
    would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This interface only contains a single logged boolean. It might seem like overkill
    to have an interface for such a common variable, but you'll find it handy when
    your applications start to grow. The state of our application can only be manipulated
    through `Action`. Actions are a type of event within the redux framework that
    are triggered and intercepted by a `Reducer`. The `Reducer` intercepts the actions
    and manipulates the state of our application. The `Reducer` is the only place
    where changes in state can happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have had a quick overview of the redux pattern, it''s time to dive
    into its implementation. First, we will need to create a new Angular project and
    install the required packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**ng new ng-redux**`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**cd ng-redux**`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**npm install  – save redux @angular-redux/store**`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we will create our actions. As a reminder, actions are triggered by the
    application and intercepted by the `reducer` in order to manipulate application
    states. In our application, we only have two actions, login and logout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding code, the `LoginAction` class is an Angular service
    in the sense that it is injectable. Consequently, any one part of our architecture
    could receive a list of actions through the automated dependency injection mechanisms
    of Angular that were presented in the previous chapter. Another thing to note
    is that our two actions are returning, well, `Actions`. The `action` class is
    composed of a `type` field, and we use static string variables to populate them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next item on the list is the reducer, which intercepts triggered actions
    and manipulates the states of our application accordingly. The reducer can be
    implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'For now, our reducer only manages two actions: login and logout. On reception
    of an action, we check the action type with a switch statement and simply reverse
    the value of the logged state. Because of our interface, this is the only place
    where we can modify the application states. At first sight, it can be perceived
    as a bottleneck and a poor separation of concerns. Now, the bottleneck part, in
    the sense that all happens there, is by design. The main idea behind Redux is
    that complex stateful JavaScript applications are hard to manage, because the
    states of the application can change in multiple ways. For example, an asynchronous
    call and a navigation event can both change the overall states of the application
    in subtle and hard-to-debug ways. Here, using the Redux functionalities, everything
    is managed in the same place. For the separation of concerns argument, which is
    very much valid, nothing prevents us from manipulating the state (for example,
    `return { logged: !lastState.logged };` in our case) in well-named, loosely coupled
    functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our store, Redux, and actions are implemented, we can start to manipulate
    them inside our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'A lot is happening here. Let''s break it down piece by piece. First, there''s
    the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this constructor, we expect to receive an injection of `NgRedux<IAppState>`
    that manipulates our state and the `APIService` that is slightly modified from
    the previous section to accommodate our new pattern. Inside the constructor, we
    have the `ngRedux.select<boolean>('logged')` instruction, which allow us to access
    an observable of the logged variables from the `IAppState` interface. As you can
    see, by design, it's not possible to change the value of `logged` here, as you
    can only obtain an observable to it. Being an observable, we can subscribe to
    it and define a component when its value changes. In our case, we affect the value
    of the logged class member to the new value of the logged state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next comes the login and logout methods that serve as proxies to the `ApiService`
    calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can see the implementation of the `ngOnDestroy` function made mandatory
    by implementing the `OnDestroy` interface. While not obligatory, the `ngOnDestroy`
    function unsubscribes from the logged observer, which will save us a few milliseconds
    if the logged state changes and the component does not exist anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s have a look at the HTML that''s linked to our component. It is fairly
    simple and only displays the value of the logged state and two buttons that, you''ve
    guessed it, allow us to log in and out of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/041bba5d-4211-471a-add8-a961cb2fb961.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next item on the list is the modification of the `APIService` so that it
    uses our new patterns instead of the MVC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In this version, we use the same technique except we do not return promises
    anymore. Indeed, in this version, we simply dispatch actions to our reducer with
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'And:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Once again, the modification of the state is indirect; we simply dispatch an
    action that will be caught by the reducer rather than manipulate the state. In
    other words, it's safe and centralized to a single point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to adjust the main app module to reflect all our changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We first imported the `NgRedux` module and the `HttpModule`, which will be used
    in the application. Then, the constructor of the `AppModule` will receive an injected
    `NgRedux` instance and configure our Redux store. The store also receives a default
    state that we initialized earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we saw two patterns: Redux and MVC. Redux and the MVC can
    be used to achieve the same purposes (manage the states of our application in
    reaction to asynchronous events or user actions). Both patterns have advantages
    and shortcomings. The advantages of the MVC in the Angular application, from my
    point of view, is that everything is well defined and separated. Indeed, we have
    a domain object (`User`), a model (`UserModel`), and a view linked to a component.
    We saw that same model and domain object across many components and views in favor
    of reuse across apps. The problem is that it can get expensive to create new functionalities
    in our apps because you''ll have to create—or, at least, modify,—a good chunk
    of architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, whether by mistake or by design, if you share models across several
    components and services, it can be extremely painful to identify and eradicate
    the source of a bug. The Redux pattern is more recent and, most of all, more adapted
    to the JavaScript ecosystem, as it has been created for it. It's relatively easy
    to add functionalities in terms of state in our applications and to manipulate
    them in a safe way. From experience, I can assure you that bugs that entire teams
    are mystified by for days are much less frequent when using the Redux patterns.
    However, the separation of concerns within the application is less clear and you
    can end up with a thousand lines of Redux in the most complex application. Sure,
    we can create several reducers in addition to the root one, separate our stores
    with big functionalities, and create helper functions to manipulate our states.
    As it's not imposed by the patterns, more often than not, I found myself reviewing
    enormous reducers that are costly to refactor.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will investigate stability patterns for our Angular
    application, which will ensure that our applications continue to be usable when
    all odds are stacked against us.
  prefs: []
  type: TYPE_NORMAL
