- en: Chapter 12. Web Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll look at the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing web services with WSGI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Flask framework for RESTful APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing the query string in a request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making REST requests with urllib
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing the URL path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing a JSON request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing authentication for web services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Providing web services involves solving several interrelated problems. There
    are a number of applicable protocols that must be followed, each with its own
    unique design considerations. The core of web services are the various standards
    that define the HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: 'HTTP involves two parties; a client and a server:'
  prefs: []
  type: TYPE_NORMAL
- en: The client makes requests of the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server sends responses back to the client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The relationship is highly asymmetric. We expect a server to process concurrent
    requests from multiple clients. Because the client requests arrive asynchronously,
    the server cannot easily distinguish those requests that originate from a single
    human user. The idea of a human user's session is implemented by designing a server
    that provides a session token (or cookie) to track the human's sense of current
    state.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP protocol is flexible and extensible. One popular use case for HTTP
    is to serve content in the form of web pages. Web pages are generally encoded
    as HTML documents, often with links to graphics, style sheets, and JavaScript
    code. We've looked at parsing HTML in the *Reading HTML documents* recipe from
    [Chapter 9](text00099.html#page "Chapter 9. Input/Output, Physical Format, and
    Logical Layout") , *Input/Output, Physical Format, and Logical Layout* .
  prefs: []
  type: TYPE_NORMAL
- en: 'Serving web page content further decomposes into two kinds of content:'
  prefs: []
  type: TYPE_NORMAL
- en: Static content is essentially a download of files. A program such as GUnicorn,
    NGINGX, or Apache HTTPD can reliably serve static files. Each URL defines a path
    to a file, and the server downloads the file to the browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic content is built by an application as needed. In this case, we'll use
    a Python application to build unique HTML (or possibly the graphics) in response
    to a request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other very popular use case for HTTP is to provide web services. In this
    case, the standard HTTP requests and responses will exchange data in formats other
    than HTML. One of the most popular formats for encoding information is JSON. We've
    looked at processing JSON documents in the *Reading JSON documents* recipe from
    [Chapter 9](text00099.html#page "Chapter 9. Input/Output, Physical Format, and
    Logical Layout") , *Input/Output, Physical Format, and Logical Layout* .
  prefs: []
  type: TYPE_NORMAL
- en: Web services can be seen as a variation on using HTTP to serve dynamic content.
    A client can prepare documents in JSON. The server includes a Python application
    that creates response documents, also in JSON notation.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, the services have a very narrow focus. It's possible to bundle
    a service and database persistence into a single package. This might involve creating
    a server that has an NGINX-based web interface plus a database using MongoDB or
    Elastic. The entire package—web service plus persistence—can be called a **microservice**
    .
  prefs: []
  type: TYPE_NORMAL
- en: The documents exchanged by a web service encode a representation of an object's
    state. A client application in JavaScript may have an object state that is sent
    to a server. A server in Python may transfer a representation of object state
    to a client. This is called **Representational State Transfer** ( **REST** ).
    A service using REST processing is often called RESTful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Handling HTTP for HTML or JSON can be designed as a number of transformation
    functions. The idea is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The response is built from the request by some function, `F(r, s)` , which relies
    on the request plus some persistent state in a database on the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'These functions form nested shells or wrappers around a core service. For example,
    the core processing may be wrapped with additional steps to be sure that the user
    making the request is authorized to change the database state. We might summarize
    this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The authorization processing may be wrapped in processing to authenticate user''s
    credentials. All of this may be further wrapped in a shell that assures that the
    client application software expects responses in JSON notation. Using multiple
    layers like this can provide consistent operation for many different core services.
    The overall process might start looking like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This kind of design fits naturally with a stack of transformational functions.
    This idea gives us some guidance in ways to design complex web services that include
    many protocols and many rules for creating a valid response.
  prefs: []
  type: TYPE_NORMAL
- en: A good RESTful implementation should also provide a great deal of information
    about the service. One way to provide this information is through the OpenAPI
    specification. For information on the OpenAPI (Swagger) specification, see [http://swagger.io/specification/](http://swagger.io/specification/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: The core of the OpenAPI specification is a JSON schema specification. For more
    information on this, see [http://json-schema.org](http://json-schema.org) .
  prefs: []
  type: TYPE_NORMAL
- en: 'The two foundational ideas are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We write in JSON a specification for the requests that are sent to the service
    and the responses provided by the service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We provide the specification at a fixed URL, often `/swagger.json` . This can
    be queried by a client to determine the details of how the service works.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating Swagger documents can be challenging. The `swagger-spec-validator`
     project can help. See [https://pypi.python.org/pypi/swagger-spec-validator](https://pypi.python.org/pypi/swagger-spec-validator)
    . This is a Python package that we can use to confirm that a Swagger specification
    meets the OpenAPI requirements.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll look at a number of recipes for creating RESTful web
    services and also serving static or dynamic content.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing web services with WSGI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many web applications will have several layers. The layers can often be summarized
    into three common patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: A presentation layer might run on a mobile device or a website. This is the
    visible, external view.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An application layer is often implemented as web services. This layer does the
    processing for the web or mobile presentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A persistence layer handles retention of data and transaction state over a single
    session as well as across multiple sessions from a single user. This will support
    the application layer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Python-based website or web services application will adhere to the **Web
    Services Gateway Interface** ( **WSGI** ) standard. This provides a uniform way
    for a frontend web server such as Apache HTTPD, NGINX, or GUnicorn to use Python
    to provide the dynamic content.
  prefs: []
  type: TYPE_NORMAL
- en: Python has a wide variety of RESTful API frameworks. In the *Using the Flask
    framework for RESTful APIs* recipe, we'll look at Flask. In some cases, however,
    the core WSGI features are all we need.
  prefs: []
  type: TYPE_NORMAL
- en: How can we create applications that support layered composition following the
    WSGI standard?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The WSGI standard defines an overall framework for composable web applications.
    The idea behind this is to define each application so that it stands alone and
    can be trivially connected to other applications. The overall website is built
    from a collection of shells or wrappers.
  prefs: []
  type: TYPE_NORMAL
- en: This is a bare-bones approach to web server development. WSGI isn't a sophisticated
    framework; it's a minimal standard. We'll look at some ways to simplify the design
    using a better framework in the *Using the Flask framework for RESTful APIs* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'The essence of web services are the HTTP request and response. A server receives
    requests and creates responses. The HTTP request includes several pieces of data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The URL for the resource. A URL can be as complex as `http://www.example.com:8080/?query#fragment`
    . There are several parts to a URL:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The scheme `http` : This ends with `:` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The host `www.example.com` : This is prefixed with `//` . It may include an
    optional port number. In this case, it''s `8080` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The path to the resource: The `/`  character in this example. The path, in
    some form, is required. It is often more complex than a simple `/` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A query string prefaced with `?` : In this example, the query string is just
    the key `query` with no value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A fragment identifier prefaced with `#` : In this example, the fragment is
    `fragment` . For HTML documents, this can be the `id` value of a particular tag;
    the browser will scroll to the named tag.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Almost all of these URL elements are optional. We can make use of the query
    string (or the fragment) to provide additional format information about the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'The WSGI standard requires that the URL is parsed. The various pieces put into
    the environment. Each piece will be assigned a separate key:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Methods** : Common HTTP methods include `HEAD` , `OPTIONS` , `GET` , `POST`
    , `PUT` , and `DELETE` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Request headers** : The headers are additional information that support the
    request. Headers are used, for example, to define the kind of content that can
    be accepted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attached content** : A request might include input from an HTML form, or
    a file to be uploaded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The HTTP response is similar to a request in many ways. It contains response
    headers and the response body. The headers will include details such as the encoding
    of the content so that the client can render it correctly. If a server is providing
    HTML content and is maintaining a server session, then the cookies are sent in
    headers as part of each request and response.
  prefs: []
  type: TYPE_NORMAL
- en: 'WSGI is designed to help create application components that can be used to
    build larger and more sophisticated applications. A WSGI application generally
    acts like a wrapper, insulating other applications from bad requests, unauthorized
    users, or unauthenticated users. To do this, each WSGI application must follow
    a common, standard definition. Each application must be either a function or a
    callable object, that has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `environ` parameter is a dictionary that includes information about the
    request. This includes all of the HTTP details, plus the OS context, plus the
    WSGI server context. The `start_response` parameter is a function that must be
    called prior to returning the response body. This provides the status and the
    headers for the response.
  prefs: []
  type: TYPE_NORMAL
- en: The return value from the WSGI application function is the HTTP response body.
    This is generally a sequence of strings or an iterable over string values. The
    idea here is that a WSGI application might be part of a larger container that
    will stream the response in pieces from the server to the client as the response
    is being built.
  prefs: []
  type: TYPE_NORMAL
- en: Since all WSGI applications are callable functions, they can be composed easily.
    A complex web server might have several WSGI components to handle details of authentication,
    authorization, standard headers, audit logging, performance monitoring, and so
    on. These aspects are generally independent of the underlying content; they're
    universal features of all web applications or RESTful services.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll look at a relatively simple web service that emits playing cards from
    either a deck or a shoe. We''ll rely on the `Card` class definition from the *Optimizing
    small objects with __slots__* recipe from [Chapter 6](text00070.html#page "Chapter 6. Basics
    of Classes and Objects") , *Basics of Classes and Objects* . Here''s the core
    `Card` class with rank and suit information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We've defined a small base class for playing cards. Each instance of the class
    has two attributes, `rank` and `suit` . We've omitted the hash and comparison
    method definitions. To follow the *Creating a class that has orderable objects*
    recipe from [Chapter 7](text00079.html#page "Chapter 7. More Advanced Class Design")
    , *More Advanced Class Design* , this class would need a number of additional
    special methods. This recipe will avoid those complications.
  prefs: []
  type: TYPE_NORMAL
- en: We've defined a `to_json()` method that is handy for serializing this complex
    object into a consistent JSON format. This method emits a dictionary representation
    of the state of the `Card` . If we want to deserialize `Card` objects from JSON
    notation, we'll need to also create an `object_hook` function. We don't need it
    for this recipe, though, since we won't accept `Card` objects as input.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also need a `Deck` class as a container of `Card` instances. An instance
    of this class can create the `Card` instances as well as acting as a stateful
    object that can deal cards. Here''s the class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `create_deck()` method uses a generator to create all 52 combinations of
    the thirteen ranks and four suits. Each suit is defined by a single character:
    ♣, ♢, ♡, or ♠. The example spells out the Unicode character names using `\N{}`
    sequences.'
  prefs: []
  type: TYPE_NORMAL
- en: If a value of `n` is provided when creating the `Deck` instance, the container
    will create multiple copies of the 52-card deck. This multideck shoe is sometimes
    used to speed up play by reducing the time spent shuffling. Once the sequence
    of `Card` instances has been created, it is shuffled using the `random` module.
    For repeatable test cases, a fixed seed can be provided.
  prefs: []
  type: TYPE_NORMAL
- en: The `deal()` method will use the value of `self.offset` to determine where to
    start dealing. This value starts at `0` and is incremented after each hand of
    cards is dealt. The `hand_size` argument determines how many cards will be in
    the next hand. This method updates the state of the object by incrementing the
    value of `self.offset` so that the cards are dealt just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s one way to use this class to create `Card` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To create a sensible test, we provided a fixed seed value. The script created
    a single deck using `Deck()` . We can then deal a hand of five `Card` instances
    from the deck.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use this as part of a web service, we''ll also need to produce
    useful output in JSON notation. Here''s an example of how that would look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We've used `deck.deal(5)` to deal a hand with five more cards from the deck.
    The expression `list(card.to_json() for card in deck.deal(5))` will use the `to_json()`
    method of each `Card` object to emit the small dictionary representation of that
    object. The list of dictionary structure was then serialized into JSON notation.
    The `sort_keys=True` option is handy for creating a repeatable test case. It's
    not generally necessary for RESTful web services.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import needed modules and objects. We''ll use the `HTTPStatus` class because
    it defines the commonly-used HTTP status codes. The `json` module is required
    to produce JSON responses. We''ll also use the `os` module to initialize a random
    number seed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Import or define the underlying classes, `Card` and `Deck` . Generally, it's
    a good idea to define these as a separate module. The basic features should exist
    and be tested outside the web services environment. The idea is that web services
    should wrap existing, working software.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create objects that are shared by all sessions. The value of `deck` is a module
    global variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We've relied on the `os` module to examine the environment variables. If the
    environment variable `DEAL_APP_SEED` is defined, we'll seed the random number
    generator with the string value. Otherwise, we'll rely on the built-in randomization
    features of the `random` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the target WSGI application as a function. This function will respond
    to a request by dealing a hand of cards and then creating a JSON representation
    of the `Card` information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `deal_cards()` function deals the next group of cards from the `deck` .
    The OS environment can define a `HAND_SIZE` environment variable to change the
    size of the deal. The global `deck` object is used to perform the relevant processing.
  prefs: []
  type: TYPE_NORMAL
- en: The status line for a response is a string that has the numeric value and phrase
    for the HTTP status of `OK` . This can be followed by headers. This example includes
    the `Content-Type` header to provide information to the client; the content is
    a JSON document and that the bytes for this document are encoded using `utf-8`
    . Finally, the document itself is the return value from this function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For demonstration and debugging purposes, it''s helpful to build a server that
    runs the WSGI application. We''ll use the `wsgiref` module''s server. There are
    good servers defined in Werkzeug. Servers such as GUnicorn are even better:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Once the server is running, we can open a browser to see `http://localhost:8080/`
    . This will return a batch of five cards. Each time we refresh, we get a different
    batch of cards.
  prefs: []
  type: TYPE_NORMAL
- en: This works because entering a URL in the browser executes a `GET` request with
    a minimal set of headers. Since our WSGI application didn't require any specific
    headers, and responded to any HTTP method, it will return a result.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is a JSON document that represents five cards dealt from the current
    deck. Each card is represented with a class name, `rank` , and `suit` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We can create web pages with clever JavaScript programs to fetch batches of
    cards. These web pages and JavaScript programs can animate dealing, and include
    graphics for the card images.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The WSGI standard defines an interface between a web server and an application.
    This is based on the the Apache HTTPD **Common Gateway Interface** ( **CGI** ).
    The CGI was designed to run shell scripts or separate binaries. The WSGI is an
    enhancement to this legacy concept.
  prefs: []
  type: TYPE_NORMAL
- en: 'The WSGI standard defines the environment dictionary with a variety of information:'
  prefs: []
  type: TYPE_NORMAL
- en: A number of keys in the dictionary reflect the request after some preliminary
    parsing and data conversion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`REQUEST_METHOD` : The HTTP request method, such as `GET` or `POST` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SCRIPT_NAME` : The initial portion of the request URL''s path. This is generally
    taken as an overall application object or function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATH_INFO` : The remainder of the request URL''s path, designating a location
    of a resource. In this example, no path parsing is performed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QUERY_STRING` : The portion of the request URL that follows the `?` , if any:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONTENT_TYPE` : The contents of any Content-Type header value in the HTTP
    request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONTENT_LENGTH` : The contents of any Content-Length header value in the HTTP
    request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SERVER_NAME` and `SERVER_PORT` : The server name and port number from the
    request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SERVER_PROTOCOL` : The version of the protocol the client used to send the
    request. Typically, this will be something like `HTTP/1.0` or `HTTP/1.1` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The HTTP headers** : These will have keys that start with `HTTP_` and contain
    the header name in all uppercase letters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Generally the contents of a request are not the only data that''s required
    to create a meaningful response from a server. Often, additional information is
    required. This information generally includes two other kinds of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '**OS environment** : The environment variables that were in place when the
    service was started provide configuration details for the server. This could provide
    a path to a directory that contains static content. It could provide information
    used for authenticating users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WSGI server context** : These keys start with `wsgi.` and are always lowercase.
    The values include some additional information on the internal state of a server
    that adheres to the WSGI standard. There are two particularly interesting objects
    that upload files and logging support:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wsgi.input` : It is a file-like object. From this, the HTTP request body bytes
    can be read. This will often have to be decoded based on the `Content-Type` header.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wsgi.errors` : It is a file-like object to which error output can be written.
    This is the server''s log.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The return value from a WSGI function can be a sequence object or an iterable.
    Returning an iterable is the way a very large document can be built in pieces
    and downloaded via a number of smaller buffers.
  prefs: []
  type: TYPE_NORMAL
- en: This example WSGI application does not check the request path. Any path can
    be used to retrieve a hand of cards. A more sophisticated application might parse
    the path to determine information about the size of a hand being requested or
    the size of the deck from which the hand should be dealt.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A web service can be visualized as a number of common pieces that are connected
    together into nested shells or layers. The uniform interface for WSGI applications
    encourages this kind of composition of reusable features.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of common techniques that are used to protect and produce
    dynamic content. These techniques are cross-cutting concerns for web service applications.
    We have a few choices for this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We can write lots of `if` statements in a single application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can extract the common programming and create a common wrapper that separates
    security concerns from the construction of content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A wrapper is simply another WSGI application that doesn't produce a result directly.
    Instead, a wrapper hands off the work of producing results to another WSGI application.
  prefs: []
  type: TYPE_NORMAL
- en: We might, for example, need a wrapper that confirms that a JSON response is
    expected. This wrapper will distinguish requests for human-centric HTML from application-focused
    JSON.
  prefs: []
  type: TYPE_NORMAL
- en: To make more flexible applications, it's often helpful to use a callable object
    instead of a simple function. Doing this makes configuration of the various applications
    and wrappers considerably more flexible. We'll combine the idea of a JSON filter
    with a callable object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The outline of this object looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We'll create a callable object from this class definition by providing another
    app. The other app, `json_app` , will be wrapped by this callable object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This will wrap the original `deal_cards()` WSGI application. We can now use
    the composite `json_wrapper` object as a WSGI application. When the server calls
    `json_wrapper(environ, start_response)` , that will invoke the `__call__()` method
    of the object, which—in this example, will pass the request to the `deal_cards()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the more complete wrapper application. This wrapper will check the
    HTTP Accept header for the characters `"json"` . It will also check the query
    string for `?$format=json` to see if a JSON-formatted request was made. An instance
    of this class can be configured to reference the `deal_cards()` WSGI application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `__call__()` method checks the Accept header as well as the query string.
    If the string `json` appears anywhere in the HTTP Accept header, then the given
    application is invoked. The environment is updated to include header information
    used by this wrapper.
  prefs: []
  type: TYPE_NORMAL
- en: If the HTTP Accept header is not present or doesn't require a JSON response,
    then the query string is checked. This fall-back can be helpful because it is
    difficult to change the headers sent by a browser; using the query string is a
    browser-friendly alternative to the Accept header. The `parse_qs()` function will
    decompose the query string into a dictionary of keys and values. If the query
    string has `$format` as a key, then this is checked to see if the value includes
    `'json'` . If this is true, then the environment is updated with the format information
    found in the query string.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, the environment is modified when calling the wrapped application.
    The function being wrapped only needs to check the WSGI environment for format
    information. This wrapper object returns the response without any further modification.
  prefs: []
  type: TYPE_NORMAL
- en: If the request does not request JSON, then a `400 BAD REQUEST` response is sent
    with a simple text message. This will provide some guidance as to why the query
    was unacceptable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use this `JSON_Filter` wrapper class definition as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of making a server from `deal_cards()` , we''ve created an instance
    of the `JSON_Filter` class that references the `deal_cards()` function. This will
    behave almost exactly like the version shown earlier. The important difference
    is that this requires either an Accept header or a URL like this: `http://localhost:8080/?$format=json`
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This example has a subtle semantic issue. The `GET` method changes the state
    of the server. This is generally a bad idea.
  prefs: []
  type: TYPE_NORMAL
- en: Because we're looking at a browser, it's difficult to sort out problems. There
    isn't much debugging support available here. This means that `print()` functions
    as well as log messages are essential for debugging. Because of the way WSGI works,
    it's essential to print to `sys.stderr` . It is easier to work with Flask, which
    we'll show in the *Using the Flask framework for RESTful APIs* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP supports a number of methods, including `GET` , `POST` , `PUT` , and `DELETE`
    . Generally, it's sensible to map these methods to database **CRUD** operations;
    Create is done with `POST` , Retrieve is done with `GET` , Update is done with
    `PUT` , and Delete maps to `DELETE` . This means that a `GET` operation will not
    change the state of the database.
  prefs: []
  type: TYPE_NORMAL
- en: This leads to the idea that a web service's `GET` operation should be idempotent.
    A series of `GET` operations without any other `POST` , `PUT` , or `DELETE` operation
    should return the same result each time. In this recipe, each `GET` returns a
    different result. This is a semantic problem with using `GET` to deal cards.
  prefs: []
  type: TYPE_NORMAL
- en: For our purpose of demonstrating the basics, the distinction is minor. In a
    large and more complex web application, the distinction is an important consideration.
    Since the deal service is not idempotent, there's a point of view that suggests
    it should be accessed with the `POST` method.
  prefs: []
  type: TYPE_NORMAL
- en: To make it easy to explore using a browser, we've avoided checking the method
    in the WSGI application.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python has a wide variety of RESTful API frameworks. In the *Using the Flask
    framework for RESTful APIs* recipe, we'll look at the Flask framework.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are three places to look for detailed information on the overall WSGI
    standard:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PEP 3333** : See [https://www.python.org/dev/peps/pep-3333/](https://www.python.org/dev/peps/pep-3333/)
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Python standard library** : It includes the `wsgiref` module. This is
    the reference implementation in the standard library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Werkzeug project** : See [http://werkzeug.pocoo.org](http://werkzeug.pocoo.org)
    . This is an external library with numerous WSGI utilities. This is used widely
    to implement proper WSGI applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, see [http://docs.oasis-open.org/odata/odata-json-format/v4.0/odata-json-format-v4.0.html](http://docs.oasis-open.org/odata/odata-json-format/v4.0/odata-json-format-v4.0.html)
    for more information on JSON-formatting of data for web services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Flask framework for RESTful APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Implementing web services with WSGI* recipe, we looked at building RESTful
    APIs and microservices using the WSGI components available in the Python standard
    library. This leads to a large amount of programming to handle a number of common
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: How can we simplify all of the common web application programming and eliminate
    boilerplate code?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we'll need to add the Flask framework to our environment. This generally
    relies on using `pip` to install the latest release of Flask and the other related
    projects, `itsdangerous` , `Jinja2` , `click` , `MarkupSafe` , and `Werkzeug`
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'The installation looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We can see that `Jinja2` and `MarkupSafe` were already installed. The missing
    elements were located by `pip` , downloaded, and installed. Windows users won't
    use the `sudo` command.
  prefs: []
  type: TYPE_NORMAL
- en: Flask allows us to dramatically simplify our web services application. Instead
    of creating a large and possibly complex WSGI-compatible function or callable
    object, we can create a module with separate functions. Each function can handle
    a specific pattern of URL paths.
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at the same core card-dealing functions we had in the *Implementing
    web services with WSGI* recipe. The `Card` class defines a simple playing card.
    The `Deck` class defines a deck of cards.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because Flask handles the details of URL parsing for us, we can create a much
    more sophisticated web service quite easily. We''ll define a path that looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/dealer/hand/?cards=5` .'
  prefs: []
  type: TYPE_NORMAL
- en: 'This route has three important pieces of information:'
  prefs: []
  type: TYPE_NORMAL
- en: The first part of the path, `/dealer/` , is the overall web service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next part of the path, `hand/` , is a specific resource, a hand of cards.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The query string, `?cards=5` , defines the cards parameter for the query. This
    is the size of the hand being requested. This is limited to a range of 1 to 52
    cards. A value that's out of range will get a `400` status code because the query
    is invalid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import some core definitions from the `flask` package. The `Flask` class defines
    the overall application. The `request` object holds the current web request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `jsonify()` function will return a JSON-format object from a Flask view
    function. The `abort()` function returns an HTTP error status and ends processing
    of the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the underlying classes, `Card` and `Deck` . Ideally, these are imported
    from a separate module. It should be possible to test all of the features outside
    the web services environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to properly shuffle, we''ll also need the `random` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `Flask` object. This is the overall web services application. We''ll
    call the Flask application `''dealer''` , and we''ll also assign the object to
    a global variable, `dealer` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Create any objects used throughout the application. These can be assigned to
    the `Flask` object, `dealer` , as attributes. Be sure to create a unique name
    that doesn't conflict with any of Flask's internal attributes. The alternative
    is to use module globals.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Stateful global objects must be able to work in a multi-threaded environment,
    or threading must be explicitly disabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: For this recipe, the implementation of the `Deck` class is not thread-safe,
    so we'll rely on having a single-threaded server. The `deal()` method should use
    the `Lock` class from the `threading` module to define an exclusive lock to assure
    proper operation with concurrent threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a route—a URL pattern—to a view function that performs a specific request.
    This is a decorator, placed immediately in front of the function. It will bind
    the function to the Flask application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the view function, which retrieves data or updates the application state.
    In this example, the function does both:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Flask parses the string after the `?` in the URL—the query string—to create
    the `request.args` value. A client application or browser can set this value with
    a query string such as `?cards=13` . This will deal 13-card hands for bridge.
  prefs: []
  type: TYPE_NORMAL
- en: If the hand size value from the query string is inappropriate, the `abort()`
    function will end processing and return an HTTP status code of `400` . This indicates
    that the request was unacceptable. This is a minimal response, with no more detailed
    content.
  prefs: []
  type: TYPE_NORMAL
- en: The real work of the application is a single statement, `cards = dealer.deck.deal(hand_size)`
    . The idea here is to wrap existing functionality in a web framework. The features
    can be tested without the web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The response is handled by the `jsonify()` function: this creates a response
    object. The body of the response which will be a Python object represented in
    JSON notation. If we need to add headers to the response, we can update `response.headers`
    to include additional information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the main program which runs the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We've included the `debug=True` option to provide rich debugging information
    in the browser as well as the Flask log file. Once the server is running, we can
    open a browser to see `http://localhost:5000/` . This will return a batch of five
    cards. Each time we refresh, we get a different batch of cards.
  prefs: []
  type: TYPE_NORMAL
- en: This works because entering a URL in the browser executes a `GET` request with
    a minimal set of headers. Since our WSGI application didn't require any specific
    headers, and responded to all of the HTTP methods, it will return a result.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is a JSON document with five cards. Each card is represented by a
    class name, `rank` , and `suit` information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To see more than five cards, the URL can be modified. For example, this will
    return a bridge hand: `http://127.0.0.1:5000/dealer/hand/?cards=13` .'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Flask application consists of an application object with a number of individual
    view functions. In this recipe, we created a single view function, `deal()` .
    Applications often have numerous functions. A complex website may have many applications,
    each of which has many functions.
  prefs: []
  type: TYPE_NORMAL
- en: A route is a mapping between a URL pattern and a view function. This makes it
    possible to have routes which contain parameters that are used by the view function.
  prefs: []
  type: TYPE_NORMAL
- en: The `@flask.route` decorator is the technique used to add each route and view
    function into the overall Flask instance. The view function is bound into the
    overall application based on the route pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `run()` method of a `Flask` object does the following kinds of processing.
    This isn''t precisely how Flask works, but it provides a broad outline of the
    various steps:'
  prefs: []
  type: TYPE_NORMAL
- en: It waits for an HTTP request. Flask follow the WSGI standard, the request arrives
    in the form of a dictionary. For more information on WSGI, see the *Implementing
    web services with WSGI* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It creates a Flask `Request` object from the WSGI environment. The `request`
    object has all of the information from the request, including all of the URL elements,
    query string elements, and any attached documents.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flask then examines the various routes, looking for a route which matches the
    request's path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a route is found, then the view function is executed. The function creates
    a `Response` object. This is the return value from a view function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a route is not found, a `404 NOT FOUND` response is sent automatically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The WSGI pattern is followed to prepare status and headers to start sending
    the response. The `Response` object that was returned from the view function is
    then provided as a stream of bytes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Flask application can contain a number of methods that make it very easy to
    provide a web service. Flask exposes some of these methods as standalone functions
    that are implicitly bound to the request or the session. This makes it slightly
    simpler to write view functions.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the *Implementing web services with WSGI*  recipe, we wrapped the application
    in a generic test that confirmed that the request had one of two properties. We
    used the following two rules:'
  prefs: []
  type: TYPE_NORMAL
- en: An Accept header that required JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A query string with `$format=json` in it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we're writing a complex RESTful application server, we often want this kind
    of test applied to all of the view functions. We'd rather not repeat the code
    for this test.
  prefs: []
  type: TYPE_NORMAL
- en: We can—of course—combine the WSGI solution from the *Implementing web services
    with WSGI* recipe with the Flask application to build a composite application.
    We can also accomplish this entirely within Flask. The pure Flask solution is
    a bit simpler than the WSGI solution, making it desirable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve seen the Flask `@flask.route` decorator. Flask has a number of other
    decorators that can be used to define various stages in request and response processing.
    In order to apply a test to the incoming request, we can use the `@flask.before_request`
    decorator. All of the functions with this decoration will be invoked prior to
    the request being processed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: When a `@flask.before_request` decorator fails to return a value (or returns
    `None` ), then processing will continue. The routes will be checked, and a view
    function will be evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, if the Accept header includes `json`  or the `$format` query
    parameter is `json` , then the function returns `None` . This means that the normal
    view function will then be found to process the request.
  prefs: []
  type: TYPE_NORMAL
- en: When a `@flask.before_request` decorator returns a value, this is the final
    result, and processing stops. In this example, the `check_json()` function may
    return an `abort()` response, which will stop processing. The `abort()` response
    becomes the final response from the Flask application. This makes it very easy
    to return error messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use a browser''s address window to enter a URL like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://127.0.0.1:5000/dealer/hand/?cards=13&$format=json`'
  prefs: []
  type: TYPE_NORMAL
- en: This will return a 13-card hand, and the request now explicitly requests the
    result in JSON format. It is instructive to try other values for `$format` as
    well as omitting the `$format` key entirely.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This example has a subtle semantic issue. The `GET` method changes the state
    of the server. This is generally a bad idea.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP supports a number of methods that parallel database CRUD operations. Create
    is done with `POST` , Retrieve is done with `GET` , Update is done with `PUT`
    , and Delete maps to `DELETE` .
  prefs: []
  type: TYPE_NORMAL
- en: This idea then leads to the idea that a web services `GET` operation should
    be idempotent. A series of `GET` operations—without any other `POST` , `PUT` ,
    or `DELETE` —should return the same result each time. In this example, each `GET`
    returns a different result. Since the deal service is not idempotent, it should
    be accessed with the `POST` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it easy to explore using a browser, we''ve avoided checking the method
    in the Flask route. Ideally, the route decorator should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Doing this makes it difficult to use a browser to see that the service is working.
    In the *Making REST requests with urllib* recipe we'll look at creating a client,
    and switching to using `POST` for the method.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For background in web services, see the *Implementing web services with WSGI*
    recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See [http://flask.pocoo.org/docs/0.11/](http://flask.pocoo.org/docs/0.11/) for
    details of Flask.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See [https://www.packtpub.com/web-development/learning-flask-framework](https://www.packtpub.com/web-development/learning-flask-framework)
    to learn more about the Flask framework. Also, [https://www.packtpub.com/web-development/mastering-flask](https://www.packtpub.com/web-development/mastering-flask)
    has more information on mastering Flask.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing the query string in a request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A URL is a complex object. It contains at least six separate pieces of information.
    More information can be included via optional elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'A URL such as `http://127.0.0.1:5000/dealer/hand/?cards=13&$format=json` has
    several fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http` is the scheme. `https` is for secure connections using encrypted sockets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`127.0.0.1` can be called the authority, although network location is more
    commonly used. This particular IP address means the localhost and is a kind of
    loopback to the localhost. The name localhost maps to this IP address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`5000` is the port number, and is part of the authority.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/dealer/hand/` is the path to a resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cards=13&$format=json` is a query string, and it''s separated from the path
    by the `?` character.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The query string can be quite complex. While not an official standard, it''s
    possible (and common) for a query string to have a repeated key. The following
    query string is valid, though perhaps confusing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We've repeated the `cards` key. The web service will provide a thirteen-card
    hand and a five-card hand.
  prefs: []
  type: TYPE_NORMAL
- en: '[ *The author is unaware of any card games with hands of varying sizes. The
    lack of a good user story makes this example somewhat contrived.* ]'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ability to repeat a key breaks the possibility of a simple mapping between
    a URL query string and a built-in Python dictionary. There are several possible
    solutions to this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: Each key in the dictionary must be associated with a `list` that contains all
    of the values. This is awkward for the most common case where a key is not repeated;
    each list has only a single item. This solution is implemented via the `parse_qs()`
    in `urllib.parse` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each key is only saved once and the first (or last) value is kept, the other
    values are dropped. This is awful.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A dictionary not used. Instead the query string can be parsed into a list of
    *(key, value* *)* pairs. This also allows keys to be duplicated. For the common
    case with unique keys, the list can be converted to a dictionary. For the uncommon
    case, the duplicated keys can be handled some other way. This is implemented by
    the `parse_qsl()` in `urllib.parse` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is there a better way to handle a query string? Can we have a more sophisticated
    structure that behaves like a dictionary with single values for the common case,
    and a more complex object for the rare cases where a field key is duplicated and
    has multiple values?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Flask depends on another project, `Werkzeug` . When we install Flask using `pip`
    , the requirements will lead `pip` to also install the Werkzeug toolkit. Werkzeug
    has a data structure that provides an excellent way to handle query strings.
  prefs: []
  type: TYPE_NORMAL
- en: We'll modify the example in the *Using the Flask framework for RESTful APIs*
    recipe to use a somewhat more complex query string. We'll add a second route that
    deals multiple hands. The sizes of each hand will be specified in a query string
    that allows repeated keys.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Start with the *Using the Flask framework for RESTful APIs* recipe. We'll be
    adding a new view function to an existing web application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define a route—a URL pattern—to a view function that performs a specific request.
    This is a decorator, placed immediately in front of the function. It will bind
    the function to the Flask application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a view function that responds to requests sent to the particular route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Within the view function, extract the values of a unique key with the `get()`
    method or use ordinary `[]` syntax that is appropriate for the built-in dict type.
    This returns individual values without the complication of a list for the common
    case where the list would only have a single element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For repeated keys, use the `getlist()` method. This returns each of the values
    as a list. Here''s a view function that looks for a query string such as `?card=5&card=5`
    to deal two five-card hands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This function will get all of the `cards` keys from the query string. If the
    values are all integers, and each value is in the range 1 to 52 (inclusive), then
    the values are valid, and the view function will return a result. If there are
    no `cards` key values in the query, then four hands of 13 cards will be dealt.
  prefs: []
  type: TYPE_NORMAL
- en: 'The response will be a JSON representation of each hand as a small dictionary
    with two keys: a hand ID, and the cards from the hand.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a main program that runs the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the server is running, we can open a browser to see this URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:5000/?cards=5&cards=5&$format=json`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is a JSON document with two hands of five cards. We''ve elided some
    details to emphasize the structure of the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Because the web service parses the query string, it's trivial to add more complex
    hand sizes to the query string. The example includes the `$format=json` based
    on the *Using the Flask framework for RESTful APIs* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: If the `@dealer.before_request` function, `check_json()` , is implemented to
    check for JSON, then the `$format` is required. If the `@dealer.before_request`
    function, `check_json()` , is not implemented, then the additional information
    in the query string is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Werkzeug—`Multidict` class is a very handy data structure. This is an extension
    to the built-in dictionary. It allows multiple, distinct values for a given key.
  prefs: []
  type: TYPE_NORMAL
- en: We can build something like this using the `defaultdict` class from the `collections`
    module. The definition would be `defaultdict(list)` . The problem with this definition
    is that the value of every key is a list, even when the list only has a single
    item as a value.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage provided by the `Multidict` class are the variations on the `get()`
    method. The `get()` method returns the first value when there are many copies
    of a key or the only value when the key occurs only once. This has a default parameter,
    as well. This method parallels the method of the built-in `dict` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `getlist()` method, however, returns a list of all values for a given key.
    This method is unique to the `Multidict` class. We can use this method to parse
    more complex query strings.
  prefs: []
  type: TYPE_NORMAL
- en: One common technique that's used to validate query strings is to pop items as
    they are validated. This is done with the `pop()` and `poplist()` methods. These
    will remove the key from the `Multidict`  class. If any keys remain after checking
    all the valid keys, these extras can be considered syntax errors, and the web
    request rejected with `abort(HTTPStatus.BAD_REQUEST)` .
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The query string uses relatively simple syntax rules. There are one or more
    key-value pairs using `=`  as the punctuation between key and value. The separator
    between each pair is the `&`  character. Because of the meaning of other characters
    in parsing a URL, there is one other rule that's important—the keys and values
    must be encoded.
  prefs: []
  type: TYPE_NORMAL
- en: 'The URL encoding rules require that certain characters be replaced with HTML
    entities. The technique is called percent encoding. This means that when we put
    `&` into the value of a query string, it must be encoded as `%26` , here''s an
    example showing this encoding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The value `this&that`  was encoded to `this%26that` .
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a short list of characters which must have the `%` -encoding rules
    applied. This comes from the *RFC 3986* , refer to *section 2.2* , *Reserved Characters*
    . The list includes these characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Generally, the JavaScript code associated with a web page will handle encoding
    query strings. If we're writing an API client in Python, we need to use the `urlencode()`
    function to properly encode query strings. Flask handles the decoding automatically
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: There's a practical size limit on the query string. Apache HTTPD, for example,
    has a `LimitRequestLine` configuration parameter with a default value of `8190`
    . This limits the overall URL to this size.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the OData specifications ([http://docs.oasis-open.org/odata/odata/v4.0/](http://docs.oasis-open.org/odata/odata/v4.0/)
    ), there are several kinds of value that are suggested for the query options.
    This specification suggests that our web services should support the following
    kinds of query option:'
  prefs: []
  type: TYPE_NORMAL
- en: For a URL that identifies an entity or a collection of entities, the `$expand`
    and `$select` options can be used. Expanding a result means that the query will
    provide additional details. The select query will impose additional criteria on
    the collection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A URL that identifies a collection should support `$filter` , `$search` , `$orderby`
    , `$count` , `$skip` , and `$top` options. These don't make sense for a URL that
    returns a single item. The `$filter` and `$search` options accept complex conditions
    for finding data. The `$orderby` option defines a particular order to impose on
    the results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `$count` option changes the query fundamentally. It will return the count
    of items instead of the items themselves.
  prefs: []
  type: TYPE_NORMAL
- en: The `$top` and `$skip` options are used to page through data. If the count is
    large, it's common to use the `$top` option to limit the results to a specific
    number that will be shown on a web page. The value of the `$skip` option determines
    which page of data will be shown. For example, `$top=20$skip=40` would be page
    3 of the results—the top twenty after skipping 40.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, all URLs should support the `$format` option to specify the format
    of the result. We've been focusing on JSON, but a more sophisticated service might
    offer CSV output or even XML.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Using the Flask framework for RESTful APIs* recipe for the basics of
    using Flask for web services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the *Making REST requests with urllib* recipe, we'll look at how to write
    a client application that can prepare complex query strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making REST requests with urllib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A web application has two essential parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A client** : This can be a user''s browser, but may also be a mobile device
    app. In some cases, a web server may be a client of other web servers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A server** : This provides the web services and resources we''ve been looking
    at, in the *Implementing web services with WSGI* , *Using the Flask framework
    for RESTful APIs* , and *Parsing the query string in a request* recipes, as well
    as other recipes, such as *Parsing a JSON request* and *Implementing authentication
    for web services* .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A browser-based client will generally be written in JavaScript. Mobile apps
    are written in a variety of languages, with a focus on Java for Android devices
    and Objective-C with Swift for iOS devices.
  prefs: []
  type: TYPE_NORMAL
- en: There are several user stories that involve RESTful API clients written in Python.
    How can we create a Python program that is a client of RESTful web services?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll assume that we have a web server based on the *Implementing web services
    with WSGI* , *Using the Flask framework for RESTful APIs* , or *Parsing the query
    string in a request* recipe. We can write a formal specification for this server''s
    behavior in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This document provides us some guidance on how to consume these services using
    Python's `urllib` module. It also describes what the expected responses should
    be, giving us guidance on how to handle the responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the fields in this specification define a base URL. These three fields,
    in particular, provide this information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `produces`  and `consumes`  fields provide information that helps to build
    and verify the HTTP headers. The request `Content-Type` header must be a **Multipurpose
    Internet Mail Extensions** ( **MIME** ) type that the server consumes. Similarly,
    the request Accept header must specify a MIME type that the server produces. In
    both cases, we'll supply `application/json` .
  prefs: []
  type: TYPE_NORMAL
- en: The detailed service definitions are provided in the `paths` section of the
    specification. The `/hands` path, for example, shows the details of how to make
    a request for multiple hands. The path detail is a suffix for the `basePath` value.
  prefs: []
  type: TYPE_NORMAL
- en: When the HTTP method is `get` , then parameters are provided in the query. The
    `cards` parameter in the query provides an integer number of cards, and it can
    be repeated multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: The response will include at least the response described. In this case, the
    HTTP status will be `200` , and the body of the response has a minimal description.
    It's possible to provide a more formal schema definition for the response, we'll
    omit that from this example.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the `urllib` components that are required. We''ll be making URL requests,
    and building more complex objects, such as query strings. We''ll need the `urllib.request`
    and `urllib.parse` modules for these two features. Since the expected response
    is in JSON, then the `json` module will be useful as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the query string that will be used. In this case, all of the values
    happen to be fixed. In a more complex application, some might be fixed and some
    might be based on user inputs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the query to build the pieces of the full URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we're using a `ParseResult` object to hold the relevant parts
    of the URL. This class isn't graceful about missing items, so we must provide
    explicit `None` values for parts of the URL that aren't being used.
  prefs: []
  type: TYPE_NORMAL
- en: We could use `"http://127.0.0.1:5000/dealer/hand/?cards=5"` in our script. However,
    this condensed string is awkward to change. It's useful as a compact message when
    making the request, but it's not ideal for making flexible, maintainable, and
    testable programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this long constructor has the advantage of providing explicit values
    for each part of a URL. In more complex applications, the individual pieces are
    built from an analysis of the JSON Swagger specification document shown previously:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Build a final `Request` instance. We''ll use the URL built from a variety of
    pieces. We''ll explicitly provide an HTTP method (browsers tend to use `GET`  as
    a default). Also, we can provide explicit headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We've provided the HTTP Accept header to state MIME type results that will be
    produced by the server, and accepted by the client. We've provided the HTTP `Content-Type`
    header to state the request consumed by the server, and provided by our client
    script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a context to process the response. The `urlopen()` function makes the
    request, handling all of the complexities of the HTTP protocol. The final `result`
    object is available for processing as a response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Generally, there are three attributes of the response that are of particular
    interest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `status` is the final status code. We expect a HTTP status `200` for a normal
    request. The `headers` include all of the headers that are part of the response.
    We might, for example, want to check that the `response.headers['Content-Type']`
    really is `application/json` .
  prefs: []
  type: TYPE_NORMAL
- en: The value of `response.read()` are the bytes downloaded from the server. We'll
    often need to decode these to get proper Unicode characters. The `utf-8` encoding
    scheme is very common. We can use `json.loads()` to create a Python object from
    the JSON document.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run this, we''ll see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The initial `200` is the status, showing that everything worked properly. There
    were four headers provided by the server. Finally, the internal Python object
    was an array of small dictionaries that provided information about the cards which
    were dealt.
  prefs: []
  type: TYPE_NORMAL
- en: To reconstruct `Card` objects, we'd need to use a slightly more clever JSON
    parser. See the *Reading JSON documents* recipe in [Chapter 9](text00099.html#page
    "Chapter 9. Input/Output, Physical Format, and Logical Layout") , *Input/Output,
    Physical Format, and Logical Layout* .
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve built up the request through several explicit steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The query data started as a simple dictionary with keys and values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `urlencode()` function turned the query data into a query string, properly
    encoded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The URL as a whole started as individual components in a `ParseResult` object.
    This makes each piece visible, and changeable. For this particular API, the pieces
    are largely fixed. In other APIs, the path and the query portion of the URL might
    both have dynamic values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The request as a whole was built from URL, method, and a dictionary of headers.
    This example did not provide a separate document as the body of a request. If
    a complex document is sent, or a file is uploaded, this is also done by providing
    details to the `Request` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The step by step assembly isn't required for a simple application. In the simple
    cases, a literal string value for the URL might be acceptable. At the other extreme,
    a more complex application may print out intermediate results as a debugging aid
    to be sure that the request is being constructed correctly.
  prefs: []
  type: TYPE_NORMAL
- en: The other benefit of spelling out the details like this is to provide a handy
    avenue for unit testing. See [Chapter 11](text00120.html#page "Chapter 11. Testing")
    , *Testing* , for more information. We can often decompose a web client into request
    building and request processing. The request building can be tested carefully
    to be sure that all of the elements are set properly. The request processing can
    be tested with dummy results that don't involve a live connection to a remote
    server.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: User authentication is often an important part of a web service. For HTML-based
    websites—where user interaction is emphasized—people expect the server to understand
    a long-running sequence of transactions via a session. The person will authenticate
    themselves once (often with a username and password) and the server will use this
    information until the person logs out or the session expires.
  prefs: []
  type: TYPE_NORMAL
- en: For RESTful web services, there is rarely the concept of a session. Each request
    is processed separately, and the server is not expected to maintain a complex
    long-running transaction state. This responsibility shifts to the client application.
    The client is required to make appropriate requests to build up a complex document
    that can be presented as a single transaction.
  prefs: []
  type: TYPE_NORMAL
- en: For RESTful APIs, each request may include authentication information. We'll
    look at this in detail in the *Implementing Authentication for web services* recipe.
    For now, we'll look at providing additional details via headers. This will fit
    comfortably with our RESTful client script.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of ways that authentication information is provided to a
    web server:'
  prefs: []
  type: TYPE_NORMAL
- en: Some services use the HTTP `Authorization` header. When used with the Basic
    mechanism a client can provide a username and password with each request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some services will invent an entirely new header with a name such as API-Key.
    The value for this header might be a complex string that has encoded information
    about the requestor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some services will invent a header with a name such as `X-Auth-Token` . This
    may be used in a multi-step operation where a username and password credentials
    are sent as part of an initial request. The result will include a string value
    (a token) that can be used for subsequent API requests. Often, the token has a
    short expiration period and must be renewed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generally, these methods require the **Secure Socket Layer** ( **SSL** ) protocol.
    This is available as the `https` scheme. In order to handle the SSL protocol,
    the servers (and sometimes the clients) must have proper certificates. These are
    used as part of the negotiation between client and server to set up the encrypted
    socket pair.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of these authentication techniques have a feature in common—they rely on
    sending additional information in headers. They differ slightly in which header
    is used, and what information is sent. In the simplest case, we might have something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This hypothetical request would be for a web service that requires a password
    provided in an `X-Authentication` header. In the *Implementing Authentication
    for web services* recipe, we'll add an authentication feature to the web server.
  prefs: []
  type: TYPE_NORMAL
- en: The OpenAPI (Swagger) specification
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many servers will explicitly provide a specification as a file at a fixed, standard
    URL path of `/swagger.json` . The OpenAPI specification was formerly known as
    **Swagger** , and the filename that provides the interface reflects that history.
  prefs: []
  type: TYPE_NORMAL
- en: 'If provided, we can get a website''s OpenAPI specification in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Once we have the specification, we can use it to get the details for the service
    or resource. We can use the technical information in the specification to build
    URLs, query strings, and headers.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Swagger to the server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For our little demonstration server, one additional view function is required
    to provide the OpenAPI Swagger specification. We can update the `ch12_r03.py`
    module to respond to a request for `swagger.json` .
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several ways to handle this important information:'
  prefs: []
  type: TYPE_NORMAL
- en: A separate, static file. That's what's shown in this recipe. It's a very simple
    way to provide the required content.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s a view function we can add that will send a file. Of course, we also
    need to put the specification into the named file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The drawback of this approach is that the specification is separate from the
    implementation module.
  prefs: []
  type: TYPE_NORMAL
- en: Embed the specification as a large blob of text in the module. We could, for
    example, provide the specification as the docstring for the module itself. This
    provides a visible place to put important documentation, but it makes it more
    difficult to include docstring test cases at the module level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This view function sends the module docstring, assuming that the string is
    a valid JSON document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This has the disadvantage of requiring that we check the syntax of the docstring
    to be sure that it's valid JSON. This is in addition to validating that the module
    implementation actually conforms to the specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Python specification object in proper Python syntax. This can then
    be encoded into JSON and transmitted. This view function sends a `specification`
    object. This will have to be a valid Python object that can be serialized into
    JSON notation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In all cases, there are several benefits to having a formal specification available:'
  prefs: []
  type: TYPE_NORMAL
- en: Client applications can download the specification to fine-tune their processing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When examples are included, the specification becomes a series of test cases
    for both client and server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The various details of the specification can also be used by the server application
    to provide validation rules, defaults, and other details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Parsing the query string in a request* recipe introduces the core web service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Implementing Authentication for web services* recipe will add authentication
    to make the service more secure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing the URL path
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A URL is a complex object. It contains at least six separate pieces of information.
    More can be included as optional values.
  prefs: []
  type: TYPE_NORMAL
- en: 'A URL such as `http://127.0.0.1:5000/dealer/hand/player_1?$format=json` has
    several fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http` is the scheme. `https` is for secure connections using encrypted sockets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`127.0.0.1`  can be called the authority, although network location is more
    commonly used. This particular IP address means the localhost and is a kind of
    loopback to the localhost. The name localhost maps to this IP address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`5000` is the port number, and is part of the authority.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/dealer/hand/player_1` is the path to a resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$format=json` is a query string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The path to a resource can be quite complex. It's common in RESTful web services
    to use the path information to identify groups of resources, individual resources,
    and even relationships among resources.
  prefs: []
  type: TYPE_NORMAL
- en: How can we handle complex path parsing?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most web services provide access to some kind of resource. In the *Implementing
    Web services with WSGI* , *Using the Flask framework for RESTful APIs* , and *Parsing
    the query string in a request* recipes, the resource was identified on the URL
    path as a hand or hands. This is—in a way—misleading.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are actually two resources that are involved in those web services:'
  prefs: []
  type: TYPE_NORMAL
- en: A deck, which can be shuffled to produce one or more random hands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A hand, which was treated as a transient response to a request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To make matters even more confusing, the hand resource was created via a `GET`
    request instead of the more common `POST` request. This is confusing because a
    `GET` request is never expected to change the state of the server.
  prefs: []
  type: TYPE_NORMAL
- en: For simple explorations and technical spikes, `GET` requests are helpful. Because
    a browser can make `GET` requests, these are a good way to explore some aspects
    of web services design.
  prefs: []
  type: TYPE_NORMAL
- en: 'A redesign can provide explicit access to a randomized instance of the `Deck`
    class. One feature of the deck will be hands of cards. This parallels the idea
    of `Deck` as a collection and `Hands` as a resource within the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/dealer/decks` : A `POST` request will create a new deck object. The response
    to this request is taken that is used to identify the unique deck.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/dealer/deck/{id}/hands` : A `GET` request to this will get a hand object
    from the given deck identifier. The query string will specify how many cards.
    The query string can use the `$top` option to limit how many hands are returned.
    It can also use the `$skip` option to skip over some hands and get cards for later
    hands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These queries will require an API client. They can't easily be done from a browser.
    One possibility is to use Postman as a plug-in to the Chrome browser. We'll leverage
    the *Making REST requests with urllib* recipe as the starting point for a client
    to process these more complex APIs.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll decompose this into two parts: server and client.'
  prefs: []
  type: TYPE_NORMAL
- en: Server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Start with the *Parsing the query string in a request* recipe as a template
    for a Flask application. We''ll be changing the view functions in that example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Import any additional modules. In this case, we''ll use the `uuid` module to
    create a unique key for a shuffled deck:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also use the Werkzeug `BadRequest` response. This allows us to provide
    a detailed error message. This is a little nicer than using `abort(400)` for an
    erroneous request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the global state. This includes the collection of decks. It also includes
    the random number generator. For testing purposes, it can help to have a way to
    force a particular seed value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a route—a URL pattern—to a view function that performs a specific request.
    This is a decorator, placed immediately in front of the function. It will bind
    the function to the Flask application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We've defined the decks resource and limited the route to only handling `HTTP
    POST` requests. This narrows the semantics of this particular endpoint—a `POST`
    request generally means that the URL will create something new in the server.
    In this example, it creates a new instance in the collection of decks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the view function that supports this resource:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The `uuid1()` function will create a universally unique ID based on the current
    host and a randomly-seeded sequence generator. The string version of this is a
    long hexadecimal string that looks like `93b8fc06-5395-11e6-9e73-38c9861bf556`
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use this string as a key for creating a new instance of `Deck` . The
    response will be a small JSON document with two fields:'
  prefs: []
  type: TYPE_NORMAL
- en: The `status` field will be `'ok'` because everything worked. This allows us
    to perhaps provide other state information that includes warnings or errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `id` field has the ID string for the deck just created. This allows the
    server to have multiple, concurrent games, each of which is distinguished by a
    deck ID.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The response is created with the `make_response()` function so that we can provide
    an HTTP status of `201 CREATED` instead of the default of `200 OK` . This distinction
    is important because this request changes the state of the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a route that requires a parameter. In this case, the route will include
    the specific deck ID to deal from:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The `<id>` makes this a path template instead of a simple, literal path. Flask
    will parse the `/` characters and separate the `<id>` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a view function that has parameters which match the template. Since
    the template included `<id>` , the view function has a parameter named `id` as
    well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: If the value of the `id` parameter is not one of the keys to the decks collection,
    the function makes a `404 NOT FOUND` response. Rather than use the `abort()` function,
    this function uses `BadRequest` to include an explanatory error message. We could
    also have used the `make_response()` function in Flask.
  prefs: []
  type: TYPE_NORMAL
- en: The values of `$top` , `$skip` , and `cards` from the query string are also
    extracted by this function. For this example, all of the values happen to be integers,
    so the `int()` function is used for each value. A rudimentary sanity check is
    performed on the query parameters. An additional check is actually required, and
    the reader is encouraged to think through all of the possible bad parameters that
    might be used.
  prefs: []
  type: TYPE_NORMAL
- en: The `subset` variable is the portion of the deck being dealt. We've sliced the
    deck to start after `skip` sets of `cards` ; we've included just `top` sets of
    `cards` in this slice. From that slice, the `hands` sequence decomposes the subset
    into the `top` number of hands, each of which has `cards` in it. This sequence
    is converted to JSON via the `jsonify()` function, and is returned.
  prefs: []
  type: TYPE_NORMAL
- en: The default status is `200 OK` , which is appropriate here because this query
    is an idempotent `GET` request. Each time a query is sent, the same set of cards
    will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a main program that runs the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This will be similar to the client module from the *Making REST requests with
    urllib* recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the essential modules for working with RESTful APIs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s a sequence of steps to make the `POST` request that will create a
    new, shuffled deck. This starts by defining the URL in pieces, by creating a `ParseResult`
    object manually. This will be collapsed into a single string later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Build a `Request` object from the URL, method, and headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The default method is `GET` , which is unsuitable for this API request.
  prefs: []
  type: TYPE_NORMAL
- en: Send the request and process the response object. For debugging purposes, it
    can be helpful to print status and header information. Generally, we only need
    to be sure that the status was the expected `201` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The response document should be a JSON serialization of a Python dictionary
    with two fields, status and ID. This client confirms the status in the response
    is `ok`  before using the value in the `id` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: In many RESTful APIs, there will be a location header, which provides a URL
    that links to the object that was created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a URL that includes inserting the ID into a URL path, as well as providing
    some query string arguments. This is done by creating a dictionary to model the
    query string, and then building a URL using a `ParseResult` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: We've inserted the `id` value into the path using `"/decks/{id}/hands/".format(id=id)`
    . Another way to do this is `"/".join(["", "decks", id, "hands", ""])` . Note
    that the empty strings are a way to force the `"/"` to appear at the beginning
    and end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make the `Request` object using the full URL, the method, and the standard
    headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Send the request and process the response. We''ll confirm that the response
    is `200 OK` . The response can then be parsed to get the details of the cards
    that are part of the requested hand:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: When we run this, it will create a fresh, new `Deck` instance. Then it will
    deal four hands of 13 cards each. The query defines the exact number of hands
    and the number of cards in each hand.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The server defines two routes that follow a common pattern for a collection
    and an instance of the collection. It's typical to define collection paths with
    a plural noun, `decks` . Using a plural noun means that the CRUD operations are
    focused on creating instances within the collection.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the Create operation is implemented with a `POST` method of the
    `/dealer/decks` path. Retrieve could be supported by writing an additional view
    function to handle the `GET` method of the `/dealer/decks` path. This would expose
    all of the deck instances in the decks collection.
  prefs: []
  type: TYPE_NORMAL
- en: If Delete is supported, this could use the `DELETE` method of `/dealer/decks`
    . Update (using the `PUT` method) doesn't seem to fit with the idea of a server
    that creates random decks.
  prefs: []
  type: TYPE_NORMAL
- en: Within the `/dealer/decks` collection, a specific deck is identified by the
    `/dealer/decks/<id>` path. The design calls for using the `GET` method to fetch
    several hands of cards from the given deck.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining CRUD operations—Create, Update, and Delete—don't make much sense
    for this kind of `Deck` object. Once the `Deck` object is created, then a client
    application can interrogate the deck for various hands.
  prefs: []
  type: TYPE_NORMAL
- en: Deck slicing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The dealing algorithm makes several slices of a deck of cards. The slices are
    based on the fact that the size of a deck, *D* , must contain enough cards for
    the the number of hands, *h* , and the number of cards in each hand, *c* . The
    number of hands and cards per hand must be no larger than the size of the deck:'
  prefs: []
  type: TYPE_NORMAL
- en: '*h* × *c* ≤ *D*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The social ritual of dealing often involves cutting the deck, which is a very
    simple shuffle done by the non-dealing player. Traditionally, each  *h* ^(th)
    card is assigned to each hand, *H* [n] :'
  prefs: []
  type: TYPE_NORMAL
- en: '*H[n] =* { *D[n]* [+] *[h]* [×] *[i]*  :0 ≤ *i* < *c* }'
  prefs: []
  type: TYPE_NORMAL
- en: The idea in the preceding formula is that hand *H[n=0]*  has cards *H[0] = {
    D[0] , D[h] , D[2h] , ..., D[c×h ] }* , hand *H[n=1]*  has cards *H[1] = { D[1]
    , D[1+h] , D[1+2h] , ..., D[1+c×h] }* , and so on. This distribution of cards
    looks more fair than simply handing each player the next batch of *c* cards.
  prefs: []
  type: TYPE_NORMAL
- en: 'This isn''t really necessary, and our Python program deals cards in batches
    that are slightly easier to compute with Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '*H[n]* = { *D* [*n* × *c* +1] : 0 ≤ *i* < *c* }'
  prefs: []
  type: TYPE_NORMAL
- en: The Python code creates hand *H[n=0]*  with cards *H* [0] *=* { *D* [0] *, D*
    [1] *, D* [2] *, ..., D[c-]* [1] }, hand *H[n=1]*  has cards *H* [0 ] *=* { *D[c]
    , D[c+]* [1] *, D[c+]* [2] *, ..., D* [2c- *1*] }, and so on. Given a random deck,
    this is just as fair as any other allocation of cards. It's slightly simpler to
    enumerate in Python because it involves list slicing. For more information on
    slicing, see the *Slicing and dicing a list* recipe in [Chapter 4](text00048.html#page
    "Chapter 4. Built-in Data Structures – list, set, dict") , *Built-in Data Structures
    – list, set, dict* .
  prefs: []
  type: TYPE_NORMAL
- en: Client side
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The client side of this transaction is a sequence of RESTful requests:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ideally, the operations start with a `GET` to `swagger.json` to get the server''s
    specifications. Depending on the server, this may be as simple as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Then, there's a `POST` to create a new `Deck` instance. This requires creating
    a `Request` object so that the method can be set to `POST` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, there's a `GET` to get some hands from the deck instance. This can be
    done by tweaking the URL as a string template. It's slightly more general to work
    the URL as a collection of individual fields instead of a trivial string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are two ways to handle errors from RESTful applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a simple status response such as `abort(HTTPStatus.NOT_FOUND)` for a resource
    that's not found.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `make_response(message, HTTPStatus.BAD_REQUEST)` for a request that is in
    some way invalid. The message can provide needed details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For some other status codes, such as `403 Forbidden` , we might not want to
    provide too many details. In the case of an authorization issue, it's often a
    bad idea to provide too many details. For this, `abort(HTTPStatus.FORBIDDEN)`
    might be appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll look at some features that we should consider adding to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: Check for `JSON`  in the Accept header
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide a Swagger specification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's common to use a header to distinguish between RESTful API requests and
    other requests to a server. The Accept header can provide a MIME type that distinguishes
    requests for JSON content from requests for user-oriented content.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@dealer.before_request` decorator can be used to inject a function that
    filters each request. This filter can distinguish proper RESTful API requests
    based on the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: The Accept header includes a MIME type that includes `json` . Typically, the
    full MIME string is `application/json` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, we can make an exception for the `swagger.json` file. This can
    be treated as a RESTful API request irrespective of any other indicators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the additional code that implements this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This filter will simply return an uninformative `400 BAD REQUEST` response.
    To provide a more explicit error message might divulge too much information about
    the server's implementation. If it seems helpful, however, we can replace `abort()`
    with `make_response()` to return a more detailed error.
  prefs: []
  type: TYPE_NORMAL
- en: Providing a Swagger specification
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A well-behaved RESTful API provides the OpenAPI specification for the various
    services available. This is generally packaged in the `/swagger.json` route. This
    doesn't necessarily mean that a literal file is available. Instead, this path
    is used as a focus to provide the detailed interface specification in JSON notation
    following the Swagger 2.0 specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve defined the route, `/swagger.json` , and bound a function, `swagger3()`
    , to this route. This function will create a JSON representation of a global object,
    specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The `specification` object has the following outline. Important details have
    been replaced with `...` to emphasize the overall structure. The details are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The two paths correspond to the two `@dealer.route` decorators in the server.
    This is why it's often helpful to start the design of a server with a Swagger
    specification, and then build the code to meet specification.
  prefs: []
  type: TYPE_NORMAL
- en: Note the small syntax difference. Flask uses `/decks/<id>/hands` where the OpenAPI
    Swagger specification uses `/decks/{id}/hands` . This small thing means we can't
    trivially copy and paste between Python and Swagger documents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the `/decks` path. This shows the input parameters that come from the
    query string. It also shows the details of the `201` response that contains the
    deck ID information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The `/decks/{id}/hands` path has a similar structure. It defines all of the
    parameters that are available in the query string. It also defines the various
    responses; a `200` response that contains the cards and define the `404` response
    when the ID value was not found.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve omitted some of the details of the parameters for each path. We''ve
    also omitted details on the structure of the deck. The outline, however, summarizes
    the RESTful API:'
  prefs: []
  type: TYPE_NORMAL
- en: The `swagger` key must be set to `2.0` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `info` key can provide a great deal of information. This example only has
    the minimal requirements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `schemes` , `host` , and `basePath` fields define some of the common elements
    of the URLs used for this service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `consumes` field states what the request `Content-Type` should include.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `produces` field states both; that the request Accept header must state,
    as well as what the response `Content-Type` will be.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `paths` field identifies all of the paths that provide a response on this
    server. This shows the `/decks` and the `/decks/{id}/hands` paths.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `swagger3()` function transforms this Python object into JSON notation and
    returns it. This implements what appears to be a download of a `swagger.json`
    file. The content specifies the resources provided by the RESTful API server.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Swagger specification
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the client programming, we''ve used simple literal values for building the
    URL. The example looked like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Parts of this can come from the Swagger specification. We could, for example,
    use `specification['host']` and `specification['basePath']` instead of the `netloc`
    value and the first part of the `path` value. This use of the Swagger specification
    can provide a little bit of extra flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: The Swagger specification is meant for consumption by tools that are used by
    people to make design decisions. The real purpose it to drive automated testing
    of APIs. Often, Swagger specifications will contain detailed examples that can
    help to clarify how to write a client application.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Making REST requests with urllib* and *Parsing the query string in
    a request* recipes for more examples of RESTful web services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing a JSON request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many web services involve a request to create a new persistent object or make
    an update to an existing persistent object. In order to do these kinds of operation,
    the application will need input from the client.
  prefs: []
  type: TYPE_NORMAL
- en: A RESTful web service will generally accept input (and produce output) in the
    form of JSON documents. For more information on JSON, see the *Reading JSON documents*
    recipe in [Chapter 9](text00099.html#page "Chapter 9. Input/Output, Physical Format,
    and Logical Layout") , *Input/Output, Physical Format, and Logical Layout*
  prefs: []
  type: TYPE_NORMAL
- en: How can we parse JSON inputs from web clients? What's an easy way to validate
    the input?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll extend the Flask application from the  *Parsing the query string in
    a request*  recipe to add a user registration feature; this will add a player
    who can then request cards. The player is a resource that will involve the essential
    CRUD operations:'
  prefs: []
  type: TYPE_NORMAL
- en: A client can do a `POST` to the `/players` path to create a new player. This
    will include a payload of a document that describes the player. The service will
    validate the document, and if it's valid, create a new, persistent `Player` instance.
    The response will include the ID assigned to the player. If the document is invalid,
    a response will be sent back detailing the problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A client can do a `GET` to the `/players` path to get the list of players.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A client can do a `GET` to the `/players/<id>` path to get the details of a
    specific player.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A client can do a `PUT` to the `/players/<id>` path to update the details of
    a specific player. As with the initial `POST` , this requires a payload document
    that must be validated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A client can do a `DELETE` to the `/players/<id>` path to remove a player.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As with the *Parsing the query string in a request* recipe, we'll implement
    both the client and the server portion of these services. The server will handle
    the essential `POST` and `GET` operations. We'll leave the `PUT` and `DELETE`
    operations as exercises for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: We'll need a JSON validator. See [https://pypi.python.org/pypi/jsonschema/2.5.1](https://pypi.python.org/pypi/jsonschema/2.5.1)
    . This is particularly good. It's helpful to have a Swagger specification validator
    as well. See [https://pypi.python.org/pypi/swagger-spec-validator](https://pypi.python.org/pypi/swagger-spec-validator)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'If we install the `swagger-spec-validator` package, this also installs the
    latest copy of the `jsonschema` project. Here''s how the whole sequence might
    look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: We used the `pip` command to install the `swagger-spec-validator` package. This
    installation also checked that `jsonschema` , `setuptools` , and `six` were already
    installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a hint about using `--upgrade` . It can help to use a command such
    as this to upgrade a package: `pip install jsonschema --upgrade` . This might
    be necessary if there''s a version of `jsonschema` that''s below version 2.5.0.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll decompose this into three parts: Swagger specification, server, and
    client.'
  prefs: []
  type: TYPE_NORMAL
- en: Swagger specification
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here''s the outline of the Swagger specification:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The first fields are essential boilerplate for RESTful web services. The `paths`
    and `definitions` will be filled in with the URLs and the schema definitions that
    are part of the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the schema definition used to validate a new player. This goes inside
    the definition of the overall specification:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The overall input document is formally described as having a type of object.
    There are four properties of that object:'
  prefs: []
  type: TYPE_NORMAL
- en: A name, which is a string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An e-mail address, which is a string with a specific format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Twitter URL, which is a string with a given format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A year, which is a number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a few defined formats that are part of the JSON schema specification
    language. The `email` and `url` formats are widely used. The complete list of
    formats includes `date-time` , `hostname` , `ipv4` , `ipv6` , and `uri` . For
    details on defining a schema, see [http://json-schema.org/documentation.html](http://json-schema.org/documentation.html)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the overall `players` path that''s used to create a new player or get
    the entire collection of players:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: This path defines two methods—`post` and `get` . The `post` method has one parameter,
    called `player` . This parameter is the body of the request, and it follows the
    player schema provided in the definitions section.
  prefs: []
  type: TYPE_NORMAL
- en: The `get` method is shown without any parameters or any formal definition of
    the structure of the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the definition of a path to get details about a specific player:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: That path is similar to the one shown in the *Parsing the URL path* recipe.
    The `player` key is provided in the URL. The response when a player ID is valid
    is shown in detail. The response has a defined schema that also uses the player
    schema definition in the definitions section.
  prefs: []
  type: TYPE_NORMAL
- en: This specification will be part of the server. It can be provided by a view
    function defined in the `@dealer.route('/swagger.json')` route. It's often simplest
    to create a file with this specification document in it.
  prefs: []
  type: TYPE_NORMAL
- en: Server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Start with the *Parsing the query string in a request* recipe as a template
    for a Flask application. We''ll be changing the view functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Import the additional libraries required. We''ll use the JSON schema for validation.
    We''ll also compute hashes of strings to serve as useful external identifiers
    in URLs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the application and the database of players. We''ll use a simple global
    variable. A larger application might use a proper database server to save this
    information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the route for posting to the overall collection of `players` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the function that will parse the input document, validate the content,
    and then create the persistent `player` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'This function follows a common four-step design:'
  prefs: []
  type: TYPE_NORMAL
- en: Validate the input document. The schema is defined as part of the overall Swagger
    specification.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a key and confirm that it's unique. This is a key that's derived from
    the data. We might also create unique keys using the `uuid` module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persist the new document in the database. In this example, it's only a single
    statement, `players[id] = document` . This follows the ideal that a RESTful API
    is built around classes and functions that already provide a complete implementation
    of the features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a response document.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Define a main program that runs the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: We can add other methods to see multiple players or individual players. These
    will follow the essential designs of the *Parsing the URL path* recipe. We'll
    look at these in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This will be similar to the client module from the *Parsing the URL path* recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the essential modules for working with RESTful APIs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the URL in pieces by creating a `ParseResult` object manually. This
    will be collapsed into a single string later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an object that can be serialized to a JSON document and posted to the
    server. Studying `swagger.json` shows what this document''s schema must be. The
    `document` will include the required four properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll combine URL, document, method, and headers to create the complete request.
    This will use `urlunparse()` to collapse the URL parts into a single string. The
    `Content-Type` header alerts the server that we''re going to provide a text document
    in JSON notation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: We've included the `charset` option, which specifies the specific encoding used
    to create bytes from Unicode strings. Since `utf-8` encoding is the default, this
    isn't required. In the rare case that a different encoding is used, this shows
    how to provide the alternative.
  prefs: []
  type: TYPE_NORMAL
- en: 'Send the request and process the `response` object. For debugging purposes,
    it can be helpful to print the `status` and `headers` information. Generally,
    we only need to be sure that the `status` was the expected `201 CREATED` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: We've examined the response document to assure that it includes the two expected
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: We can also include other queries in this client. We might want to retrieve
    all players or retrieve a specific player. These will follow the design shown
    in the *Parsing the URL path* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Flask automatically examines inbound documents to parse them. We can simply
    use `request.json` to leverage the automated JSON parsing that's built-in to Flask.
  prefs: []
  type: TYPE_NORMAL
- en: If the input is not actually JSON, then the Flask framework will return a `400
    BAD REQUEST` response. This happens when our server application references the
    `json` property of the request. We can use a `try` statement to capture the `400
    BAD REQUEST` response object and make changes to it, or possibly return a different
    response.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve used the `jsonschema` package to validate the input document. This will
    check a number of features of the JSON document:'
  prefs: []
  type: TYPE_NORMAL
- en: It checks if the overall type of the JSON document matches the overall type
    of the schema. In this example, the schema required an object, which is a `{}`
    JSON structure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each property defined in the schema and present in the document, it confirms
    that the value in the document matches the schema definition. This means that
    the value fits one of the defined JSON types. If there are other validation rules
    like a format, or a range specification, or a number of elements for an array,
    these constraints are checked also. This check proceeds recursively through all
    levels of the schema.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there's a required list of fields, it checks that all of these are actually
    present in the document.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For this recipe, we've kept the details of the schema to a minimum. A common
    feature that we've omitted in this example is the list of required properties.
    We can also provide considerably more detailed attribute descriptions. The year,
    for example, should probably have a minimum value of `1900` .
  prefs: []
  type: TYPE_NORMAL
- en: We've kept the database update processing to a minimum in this example. In some
    cases, the database insert might involve a much more complex process where a database
    client connection is used to execute a command that changes the state of a database
    server. Ideally, the database processing is kept to a minimum—the application-specific
    details are often imported from a separate module and presented as RESTful API
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: In a larger application, there might be a `player_db` module that included all
    of the player database processing. This module would define all of the classes
    and functions. This would often provide the detailed schema definitions for a
    `player` object. The RESTful API service would import these classes, functions,
    and schema specifications and expose them for external consumers.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Swagger specification allows examples of response documents. This is often
    helpful in several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: It's common to start designing the sample document that is part of the response.
    Writing a schema specification that describes a document can be difficult and
    the schema validation feature helps to ensure that the specification matches the
    document.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the specification is complete, the next step is to write the server-side
    programming. It's helpful to have unit tests that leverage schema example documents.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For users of the Swagger specification, a concrete example of the response can
    be used to design the client, and write unit tests for the client-side programming.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use the following code to confirm that a server has a valid Swagger
    specification. If this raises an exception, either there''s no Swagger document
    or the document doesn''t properly fit the Swagger schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Location header
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `201 CREATED` response included a small document with some status information.
    The status information included the key that was assigned to the newly-created
    record.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s also common for a `201 CREATED` response to have an additional location
    header in the response. This header will provide a URL that can be used to recover
    the document which was created. For this application, the location would be a
    URL, like the following example: `http://127.0.0.1:5000/dealer/players/75f1bfbda3a8492b74a33ee28326649c`
    .'
  prefs: []
  type: TYPE_NORMAL
- en: The location header can be saved by a client. A complete URL is slightly simpler
    than creating a URL from a URL template and a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The server can build this header as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: This relies on the Flask `url_for()` function. This function takes the name
    of a view function, and any parameters that come from the URL path. It then uses
    the route for the view function to construct a complete URL. This will include
    all the information for the currently running server. After the header is inserted,
    the `response` object can be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Additional resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The server should be able to respond with a list of players. Here''s a minimal
    implementation that simply transforms the data into a large JSON document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: A more sophisticated implementation would support the `$top` and `$skip` query
    parameters to page through the list of players. Additionally, a `$filter` option
    might be useful to implement a search for a subset of players.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the generic query for all players, we need to implement a method
    that will return an individual player. This kind of view function is often just
    as simple, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: This function confirms that the given ID is a proper key value in the database.
    If the key is not in the database, the database document is transformed into JSON
    notation and returned.
  prefs: []
  type: TYPE_NORMAL
- en: Query for a specific player
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here''s the client processing required to locate a specific value in the database.
    This involves multiple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll create the URL for a particular player:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: We've built the URL from pieces of information. This is created as a `ParseResult`
    object with separate fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the URL, we can then create a `Request` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the `request` object, we can then make the request, and retrieve
    the response. We need to confirm that the response status is `200` . If so, we
    can then parse the body of the response to get the JSON document that describes
    a given player:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: If the player doesn't exist, the `urlopen()` function will raise an exception.
    We can enclose this in a `try` statement to capture the `403 NOT FOUND` exceptions
    that could be raised if the player ID doesn't exist.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here''s the general pattern for all client requests. This includes the explicit
    `try` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'There are actually two general kinds of exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lower-level exceptions** : This exception indicates that the server can''t
    be contacted. The `ConnectionError` exception is a common example of this lower-level
    exception. This is a subclass of the `OSError` exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The HTTPError exceptions from the urllib module** : This exception means
    that the overall HTTP protocol worked, but the response from the server was not
    a successful status code. Success is generally a value in the range `200` to `299`
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `HTTPError` exception has similar attributes to a proper response. It includes
    a status, headers, and a body.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In some cases, an `HTTPError` exception might be one of several expected responses
    from a server. It might not indicate an error or problem. It might simply be another
    meaningful status code.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Parsing the URL path* recipe for other examples of URL processing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Making REST requests with urllib* recipe shows other examples of query
    string processing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing authentication for web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Security, in general, is a pervasive issue. Every part of an application will
    have security considerations. Parts of the implementation of security will involve
    two closely-related issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication** : A client must provide some evidence of who they are. This
    might involve signed certificates or it might involve credentials like a username
    and password. It might involve multiple factors, such as an SMS message to a phone
    that the user should have access to. The web server must validate this authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization** : A server must define areas of authority and allocate these
    to groups of users. Furthermore, individual users must be defined as members of
    the authorization groups.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While it's technically possible to define authorization on an individual basis,
    this tends to become awkward as a site or application grows and changes. It's
    easier to define security for groups. In some cases, a group may (initially) have
    only a single individual.
  prefs: []
  type: TYPE_NORMAL
- en: Application software must implement authorization decisions. For Flask, the
    authorization can be part of each view function. The connection of individual
    to group and group to view function defines the resources available to any specific
    user.
  prefs: []
  type: TYPE_NORMAL
- en: Confusingly, the HTTP standards provide authentication credentials using the
    HTTP `Authorization` header. This may lead to some confusion because the header's
    name doesn't precisely reflect its purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a variety of ways that authentication details can be provided from
    a web client to a web server. Here are a few of the alternatives:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Certificates** : Certificates which are encrypted and include a digital signature
    as well as a reference to a **Certificate** **Authority** ( **CA** ): These are
    exchanged by the **Secure Socket Layer** ( **SSL** ). In some environments, both
    client and server must have certificates that are used for mutual authentication.
    In other environments, the server provides a certificate of authenticity, but
    the client does not. This is common for the `https` scheme. The server doesn''t
    verify the client''s certificate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Static API keys or tokens** : A web service might provide a simple, fixed
    key. This might be issued with advice to keep it secret, much like a password.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Usernames and passwords** : The web server might identify users by a username
    and password. User identity might be further confirmed using e-mail or SMS messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Third-party authentication** : This might involve using a service such as
    OpenID. For details, see [http://openid.net](http://openid.net) . This will involve
    a callback URL so that notification information can be returned by the OpenID
    provider.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, there's a question of how the user information gets loaded into
    a web server. Some websites are self-service, with users providing some minimal
    contact information and being granted access to the content.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, websites aren't self-service. A user might be carefully vetted
    before being allowed access. Access might involve contracts and fees for access
    to data or services. In some cases, one company will purchase licenses for their
    employees, providing a finite list of users who have access to a given suite of
    web services.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show a self-service application in which there is no defined
    set of users. This means that there must be a web service to create new users
    that doesn't require any authentication. All other services will require a properly
    authenticated user.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll implement a version of HTTP-based authentication using the `Authorization`
    header. There are two variations on this theme:'
  prefs: []
  type: TYPE_NORMAL
- en: '**HTTP basic authentication** : This uses a simple username and password string.
    It relies on the SSL layer to encrypt the traffic between client and server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTTP digest authentication** : This uses a much more complex hash of username,
    password, and a nonce provided by the server. The server computes the expected
    hash value. If the hash values match, then the same bytes were used to compute
    the hash, and the password must have been valid. This doesn''t require SSL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSL is frequently used by web servers to establish their authenticity. Because
    this technology is so pervasive, it means that HTTP basic authentication can be
    used. This is a huge simplification in RESTful API processing, since each request
    will include the `Authorization` header and secure sockets will be used between
    client and server.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring SSL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The details of getting and configuring certificates is outside of the realm
    of Python programming. The OpenSSL package provides tools for creating self-signed
    certificates that can be used for configuring a secure server. CAs such as Comodo
    Group and Symantec offer trusted certificates that are widely recognized by OS
    vendors, as well as the Mozilla Foundation.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two parts to creating a certificate with OpenSSL:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a private key file. This is generally done with the following OS-level
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: The `openssl genrsa 1024` command created a private key file, which was saved
    under the name `ssl.key` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a certificate using the key file. The following command is one way to
    handle this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: You are about to be asked to enter information that will be incorporated into
    your certificate request. What you are about to enter is what is called a **Distinguished
    Name**  ( **DN** ). There are quite a few fields but you can leave some blank.
    For some fields there will be a default value. If you enter `.` , the field will
    be left blank.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: The command `openssl req -new -x509 -nodes -sha1 -days 365 -key ssl.key` created
    the private certificate file, which was saved in `ssl.cert` . This certificate
    is privately signed, and doesn't have a CA. It provides only a limited set of
    features.
  prefs: []
  type: TYPE_NORMAL
- en: These two steps create two files: `ssl.cert` and `ssl.key` . We'll use these
    files below to secure the server.
  prefs: []
  type: TYPE_NORMAL
- en: Users and credentials
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order for users to be able to supply a username and a password, we''ll need
    to store this information on the server. There''s a very important rule about
    user credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Never store credentials. Never.
  prefs: []
  type: TYPE_NORMAL
- en: It should be clear that storing plain text passwords is an invitation to a security
    disaster. What's less obvious is that we can't even store encrypted passwords.
    When the key used to encrypt the passwords is compromised, that will lead to a
    loss of all of the user identities.
  prefs: []
  type: TYPE_NORMAL
- en: How can a user's password be checked if we do not store the password?
  prefs: []
  type: TYPE_NORMAL
- en: The solution is to store a hash instead of a password. The first time the password
    is created, the server saves the hashed summary. Each time after that, the user's
    input is hashed and compared with the saved hash. If the two hashes match, then
    the password must have been correct. What's central is the extreme difficulty
    of recovering a password from the hash.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a three-step process to create the initial hash value for a password:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a random `salt` value. Generally, 16 bytes from `os.urandom()` are used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `salt` plus the password to create a `hash` value. Generally, the `hashlib`
    is used for this. Specifically, `hashlib.pbkdf2_hmac()` . A specific digest algorithm
    is used for this, for example, `md5`  or` sha224` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the digest name, the `salt` , and the hashed bytes. Often this is combined
    into a single string that looks like—`md5$salt$hash` . The `md5` is a literal.
    The `$` separates the algorithm name, `salt` , and `hash` values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When a password needs to be checked, a similar process is followed:'
  prefs: []
  type: TYPE_NORMAL
- en: Given the username, locate the saved hash string. This will have a three-part
    structure of the digest algorithm name, saved salt, and hashed bytes. The elements
    may be separated by `$` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the saved salt plus the user-supplied candidate password to create a computed
    `hash` value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the computed hash bytes match the saved hash bytes, we know the digest algorithm
    and salt matched; therefore, the password must have matched as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll define a simple class to retain user information as well as the hashed
    password. We can use Flask's `g` object to save the user information during request
    processing.
  prefs: []
  type: TYPE_NORMAL
- en: Flask view function decorator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are several alternatives for handling the authentication checks:'
  prefs: []
  type: TYPE_NORMAL
- en: If every route has the same security requirements, then the `@dealer.before_request`
    function can be used to validate all `Authorization` headers. This would require
    some exception processing for the `/swagger.json` route and the self-service route
    that allows an unauthorized user to create their new username and password credentials.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When some routes require authentication and some don't, it works out well to
    introduce a decorator for the routes that need authentication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A Python decorator is a function that wraps another function to extend its
    functionality. The core technique looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: The idea is to replace a given function, The `function` in this example, with
    a new function, `decorated_function` . Within the body of the decorated function,
    it executes the original function. Some processing can be done before and some
    processing done after the function being decorated.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a Flask context, we''ll put our decorators after the `@route` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: We've wrapped the `view_function()` with the `@decorate` decorator. A decorator
    can check authentication to be sure that the user is known. We can do a wide variety
    of processing in these functions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll decompose this into four parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the `User` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a view decorator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an example client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the User class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This class definition provides an example of a definition of an individual
    `User` object:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import modules that are required to create and check the password:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Other useful modules include `json` so that a `User` object can be properly
    serialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the `User` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we''ll be changing some aspects of password generation and checking,
    we''ll provide two constants as part of the overall class definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: We'll use the **SHA-384** digest algorithm. This provides 64-byte summaries.
    We'll use 100,000 rounds for the **Password-Based Key Derivation Function 2**
    ( **PBKDF2** ) algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the time, we''ll create users from a JSON document. This will be a
    dictionary that can be turned into keyword argument values using `**` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Note that we don't expect to set the password directly. Instead, we'll set the
    password separately from creating the user document.
  prefs: []
  type: TYPE_NORMAL
- en: We've omitted additional authorization details, such as a list of groups to
    which the user belongs. We've also omitted an indicator showing that the password
    needs to be changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the algorithm for setting the password `hash` value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: We've built a random salt using `os.urandom()` . We've then built the complete
    `hash` value using the given digest algorithm, the password, and `salt` . We've
    used a configurable number of rounds.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the hash computation works in bytes, not Unicode characters. We've
    encoded the password into bytes using the `utf-8` encoding.
  prefs: []
  type: TYPE_NORMAL
- en: We assembled a string using the name of the digest algorithm, the salt, and
    the encoded `hash` value. We've used URL-safe `base64` encoding of the bytes so
    that the full, hashed password value can be displayed easily. It can be saved
    in any kind of database because it uses only `A-Z` , `a-z` , `0-9` , `-` and `_`
    .
  prefs: []
  type: TYPE_NORMAL
- en: Note that `urlsafe_b64encode()` creates a string of byte values. These must
    be decoded to see what Unicode characters they represent. We use the ASCII encoding
    scheme here because `base64` only uses sixty-four standard ASCII characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define an algorithm for checking a password hash value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: We've decomposed the password hash into `digest` , `salt` , and `expected_hash`
    value. Since the various parts were `base64` encoded, they must be decoded to
    recover the original bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the hash computation works in bytes, not Unicode characters. We've
    encoded the password into bytes using the `utf-8` encoding. The computed results
    of `hashlib.pbkdf2_hmac()` are compared with the expected results. If they match,
    then the passwords must have been the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a demonstration of how this class is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: This test case can be included in the class docstring. See the *Using docstrings
    for testing* recipe in [Chapter 11](text00120.html#page "Chapter 11. Testing")
    , *Testing* , for more information on this kind of test case.
  prefs: []
  type: TYPE_NORMAL
- en: In more complex applications, there may also be a definition for the collection
    of users. This often uses a database of some kind to facilitate locating users
    and inserting new users.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a view decorator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Import the `@wraps` decorator from `functools` . This helps define decorators
    by assuring that the new function has the original name and docstring copied from
    the function that is being decorated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to check passwords, we''ll need the `base64` module to help decompose
    the value of the `Authorization` header. We''ll also need to report errors and
    update the Flask processing context using the global `g` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the decorator. All decorators have this essential outline. We''ll replace
    the `processing here` part in the next step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the processing steps to examine the header. Note that every problem
    encountered simply aborts processing with the `401 UNAUTHORIZED` as the status
    code. To prevent hackers from exploring the algorithm, all of the results are
    identical even though the root causes are different:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a number of conditions that must be successfully passed:'
  prefs: []
  type: TYPE_NORMAL
- en: An `Authorization` header must be present
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The header must specify basic authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value must include a `username:password` string encoded using `base64`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The username must be a known username
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The computed hash from the password must match the expected password hash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any single failure leads to a `401 UNAUTHORIZED` response.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This parallels the server shown in the *Parsing a JSON request* recipe. There
    are some important modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the local self-signed certificate or purchase a certificate from a certificate
    authority. For this recipe, we'll assume the two filenames are `ssl.cert` and
    `ssl.key` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the modules required to build a server. Also import the `User` class
    definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Include the `@authorization_required` decorator definition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define a route with no authentication. This will be used to create new users.
    A similar view function was defined in the *Parsing a JSON request* recipe. This
    version requires a password property in the incoming document. This will be the
    plain-text password that''s used to create the hash. The plain text password is
    not saved anywhere; only the hash is retained:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: After creating the user, the password is set separately. This follows the pattern
    set by some applications where users are loaded in bulk. This processing might
    provide a temporary password for each user, which must be immediately changed.
  prefs: []
  type: TYPE_NORMAL
- en: Note that each user is assigned a cryptic ID. The assigned ID is computed from
    a hex digest of their Twitter handle. This is unusual, but it shows that there's
    a great deal of flexibility available.
  prefs: []
  type: TYPE_NORMAL
- en: If we wanted users to choose their own username, we'd need to add that to the
    request document. We would use that username instead of the computed ID value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a route for which authentication is required. A similar view function
    was defined in the *Parsing a JSON request* recipe. This version uses the `@authorization_required`
    decorator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Most of the other routes will have similar `@authorization_required` decorators.
    Some routes, such as the `/swagger.json` route, will not require authorization.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ssl` module defines the `ssl.SSLContext` class. The context can be loaded
    with the self-signed certificate and private key file created previously. The
    context is then used by the Flask object''s `run()` method. This will change scheme
    in the URL from `http://127.0.01:5000` to `https://127.0.0.1:5000` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Creating an example client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create an SSL context that will work with a self-signed certificate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: This context can be used with all `urllib` requests. This will politely ignore
    the lack of CA signature on the certificate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we use this context to fetch the Swagger specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the URL for creating a new player instance. Note that we must use `https`
    for the scheme. We''ve built a `ParseResult` object to show the various pieces
    of the URL separately:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a Python object that will be serialized into a JSON document. This schema
    is similar to the example shown in the *Parsing a JSON request* recipe. This includes
    one extra property, which is the plain text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Because the SSL layer uses an encrypted socket, sending a plain text password
    like this is feasible.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll combine URL, document, method, and headers to create the complete `Request`
    object. This will use `urlunparse()` to collapse the URL parts into a single string.
    The `Content-Type` header alerts the server that we''re going to provide a text
    document in JSON notation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'We can post this document to create a new player:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: The happy path will receive a `201` status response, and the user will be created.
    The response will include the assigned user ID plus a redundant status code.
  prefs: []
  type: TYPE_NORMAL
- en: If the user is a duplicate, or the document doesn't match the schema, then there
    will be an `HTTPError` exception raised. This may have useful error messages that
    can be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the assigned ID and the known password to create an `Authorization`
    header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Authorization` header has a two-word value: `b"BASIC " + credentials`
    . The word `BASIC` is required. The credentials must be a `base64` encoding of
    the `username:password` string. In this example, the username is a specific ID
    assigned when the user was created.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a URL to query all of the players. We''ve built a `ParseResult` object
    to show the various pieces of the URL separately:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'We can combine the URL, method, and headers into a single `Request` object.
    This includes the `Authorization` header, which has the `base64` encoding of username
    and password:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Request` object can be used to make the query from the server and process
    the response with `urllib` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: The expected status is `200` . The response should be a JSON document with a
    list of known `players` .
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three parts to this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using SSL to provide a secure channel** : This makes it possible to exchange
    usernames and passwords directly. Instead of the more complex HTTP digest authentication,
    we can use the simpler HTTP basic authentication scheme. There are a variety of
    other authentication schemes used by web services; most of them require SSL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using best practices for password hashing** : Saving passwords in any form
    is a security risk. Rather than save plain passwords, or even encrypted passwords,
    we only save a computed hash value of a password and a random salt string. This
    assures us that it''s nearly impossible to reverse engineer passwords from the
    hashed values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using a decorator** : It is used to distinguish between routes that require
    authentication and routes that do not require authentication. This allows a great
    deal of flexibility in creating a web service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In cases where all routes require authentication, we could add the password
    check algorithm to the `@dealer.before_request` function. This would centralize
    all authentication checks. It would also mean that a separate administrative process
    is required to define users and hashed passwords.
  prefs: []
  type: TYPE_NORMAL
- en: What's essential here is that the security check on the server is a simple `@authorization_required`
    decorator. It's very easy to be sure that it is in place on all view functions.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This server has a relatively simple set of authorization rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Most routes require a valid user. This was implemented by the presence of the
    `@authorization_required` decorator in the view function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `GET` for `/dealer/swagger.json` and a `POST` to `/dealer/players` do not
    require a valid user. This was implemented by the absence of an additional decorator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In many cases, we'll have a considerably more complex configuration of privileges,
    groups, and users. The principle of least privilege suggests that the users should
    be segregated into groups, and that each group has the fewest privileges possible
    to accomplish their goals.
  prefs: []
  type: TYPE_NORMAL
- en: This often means that we'll have an administrative group that creates new users,
    but has no other access to use the RESTful web services. Users can access the
    web services, but are unable to create any additional users.
  prefs: []
  type: TYPE_NORMAL
- en: 'This requires several changes to our data model. We should define user groups
    and assign users to those groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then expand the definition of `User` to include group membership:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'When we create a new instance of the `GroupUser` class, we can also assign
    them to a particular group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now expand our decorator to check the `groups` attribute of the authenticated
    user. A decorator with parameters is a bit more complex than a parameterless decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: A decorator with a parameter works by creating a concrete decorator that includes
    the parameter. The concrete decorator, `group_member_decorator` , will wrap a
    given view function. This will parse the `Authorization` header, locate the `GroupUser`
    instance and check the group membership.
  prefs: []
  type: TYPE_NORMAL
- en: We've used `# Check Password and determine user` as a placeholder for a refactored
    function to check the `Authorization` header. The core functionality of the `@authorization_required`
    decorator needs to be extracted into a stand-alone function so it can be used
    in several places.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then use this decorator as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: This narrows the scope of privilege for each individual view function. It provides
    assurance that the principle of least privilege is followed by the RESTful web
    services.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a command-line interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working with a site that has special administrator privileges, we often
    need to provide a way to create an initial administrative user. This user can
    then create all of the users with non-administrative privileges. This is often
    done with a CLI application which is run by the administrative user directly on
    the web server.
  prefs: []
  type: TYPE_NORMAL
- en: Flask supports this with a decorator that defines commands that must be run
    outside the RESTful web services environment. We can use `@dealer.cli.command()`
    to define a command that is run from the command line. This command can, for example,
    load the initial administrative user. A command might be created to load users
    from a list, also.
  prefs: []
  type: TYPE_NORMAL
- en: The `getpass` module is a way for an administrative user to provide their initial
    password in a way that won't be echoed on a terminal. This can provide confidence
    that the site's credentials are being processed securely.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Authentication header
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Web services that rely on an HTTP basic `Authorization` header can be supported
    in one of two common ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Build the `Authorization` header with the credentials and include this in each
    request. To do this, we need to provide the proper `base64` encoding of the string
    `username:password` . This alternative has the advantage of being relatively simple.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use the `urllib` features to provide the `Authorization` header automatically:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: We've created an instance of `HTTPBasicAuthHandler` . This is populated with
    all of the usernames and passwords that might be required. For complex applications
    that gather data from multiple sites, there may be more than one set of credentials
    added to the handler.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using `with urllib.request.urlopen(request) as response:` , we would
    now use `with password_opener(request) as response:` . The `Authorization` header
    is added to the request by the `password_opener` object.
  prefs: []
  type: TYPE_NORMAL
- en: This alternative has the advantage of being relatively flexible. We can switch
    to using `HTTPDigestAuthHandler` without any difficulties. We can also add additional
    usernames and passwords.
  prefs: []
  type: TYPE_NORMAL
- en: The realm information is sometimes confusing. A realm is a container for multiple
    URLs. When a server requires authentication, it will respond with a `401` status
    code. This response will include an `Authenticate` header that names a realm to
    which the credentials must belong. Since the realm contains multiple site URLs,
    the realm information tends to be extremely static. `HTTPBasicAuthHandler` uses
    the realm and URL information to choose which of the usernames and passwords to
    supply in the authorization response.
  prefs: []
  type: TYPE_NORMAL
- en: It's often necessary to write a technical spike that attempts a connection,
    and prints the headers on the `401` response just to see what the realm string
    is. Once the realm is known, `HTTPBasicAuthHandler` can be built. An alternative
    is to use the developer modes available in some browsers to examine the headers
    and see the details of the `401` response.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Proper SSL configuration of a server generally involves using certificates signed
    by a CA. This involves a certificate chain that starts with the server and includes
    certificates for the various authorities that issued the certificates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many web service implementations use servers such as GUnicorn or NGINX. These
    servers generally handle the HTTP and HTTPS issues outside our application. They
    can also handle complex chains and bundles of certificates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For details, see [http://docs.gunicorn.org/en/stable/settings.html#ssl](http://docs.gunicorn.org/en/stable/settings.html#ssl)
    and also [http://nginx.org/en/docs/http/configuring_https_servers.html](http://nginx.org/en/docs/http/configuring_https_servers.html)
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
