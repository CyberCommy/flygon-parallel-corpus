- en: Building a Network Scanner Using Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will build a network scanner that can identify the live
    hosts on the network and we will also expand it to include guessing the running
    operating system on each host and opened/closed ports. Usually, gathering this
    information requires multiple tools and some Linux ninja skills to get the required
    information but, using Python, we can build our own network scanner code that
    includes any tools and we can get a customized output.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the network scanner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a network scanner with Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing your code on GitHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the network scanner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A network scanner is used to scan a provided range of network IDs in both layer
    2 and layer 3\. It can send requests and analyze responses for hundreds of thousands
    of computers. Also, you can expand its functionality to show some shared resources,
    via Samba and NetBIOS protocols, and the content of unprotected data on servers
    running sharing protocols. Another usage for the network scanner in penetration
    testing is when a white hat hacker tries to simulate an attack on network resources
    to find vulnerabilities and to evaluate company security. The final goal of the
    penetration test is to generate a report with all of the weaknesses in the target
    system so the origin point can reinforce and enhance security policies against
    the potential real attack.
  prefs: []
  type: TYPE_NORMAL
- en: Building a network scanner with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python tools provide many native modules and support for working with sockets
    and TCP/IP in general. Additionally, Python can use the existing third-party commands
    available on the system to initiate the required scan and return the result. This
    can be done using the `subprocess` module that we discussed before, in [Chapter
    9](part0128.html#3Q2800-9cfcdc5beecd470bbeda046372f0337f), *Using the Subprocess
    Module*. A simple example is using Nmap to scan a subnet, as in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning, we imported the `subprocess` module to be used in our script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we defined the network that we want to scan with the `network` parameter.
    Notice that we used the CIDR notation, but we could use the subnet mask instead
    and convert that to CIDR notation using the Python `netaddr` module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Popen()` class inside `subprocess` is used to create an object that will
    send a regular Nmap command and scan the network. Notice that we added some flags, `-sP`,
    to tweak the Nmap operation and redirected the output to a special pipe created
    by `subprocess.PIPE`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we iterated over the created pipe and printed each line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The script output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](../images/00222.jpeg)**Access to network ports on Linux requires root
    access, or your account must belong to a sudoers group in order to avoid any problems
    in the script. Also, the `nmap` package should be installed on the system prior
    to running the Python code.'
  prefs: []
  type: TYPE_NORMAL
- en: This is a simple Python script and we can use the Nmap tool directly instead
    of using it inside Python. However, wrapping the Nmap (or any other system command)
    with Python code gives us the flexibility of tailoring the output and customizing
    it in any way. In the next section, we will enhance our script and add more functionality
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although the output of Nmap gives us an overview of the live hosts on the scanned
    network, we can enhance it and have a better output view. For example, I need
    to know the total number of hosts at the beginning of the output, then the IP
    address, MAC address, and MAC vendor for each one, but in tabular form, so I can
    easily locate any host and all of the information associated with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For that reason, I will design a function and name it `nmap_report()`. This
    function will take the standard output generated from the `subprocess` pipe and
    will extract the required information and format it in table format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Starting with the easiest part, we can get the number of live hosts by counting
    the `Host is up` occurrences in the passed output and assigning this to the `number_of_hosts`
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, Python has a nice module called `PrettyTable` which can create a text
    table and handle the cell sizing according to data inside it. The module accepts
    the table headers as a list and uses the `add_row()` function to add rows to the
    created table. So, the first thing is to import this module (after installing
    it, if it's not already installed). In our example, we will pass a list of three
    items (`IP`, `MAC`, `Vendor`) to the `PrettyTable` class (imported from the `PrettyTable`
    module) to create the table headers.
  prefs: []
  type: TYPE_NORMAL
- en: Now, to fill up this table, we will split the output on `\n` (carriage return).
    The split result will be a list, that we can iterate over to grab specific information
    such as MAC address and IP address. We used a few splitting and replace hacks
    to extract the MAC address alone. Also, we used the regular expression `search`
    function to get the IP address portion (or the hostname if DNS is enabled) from
    the output.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we added this information to the created `Host_Table` and continued
    to iterate over the next line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the full script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice we also added a pre-check to the `subprocess` command using the `netaddr.IPNetwork()`
    class. This class will validate whether the network is correctly formatted *before*
    executing the `subprocess` command, otherwise the class will raise an exception
    which should be handled by the `AddrFormatError` exception class and will print
    a customized error message to user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00223.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, if we change the network to an incorrect value (either the subnet mask
    is wrong or the network ID is not valid), the `IPNetwork()` class will throw an
    exception and this error message will be printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![](../images/00224.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Scanning the services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running services on a host machine typically open a port in the operating system
    and start listening to it in order to accept incoming TCP communication and start
    the three-way handshake. In Nmap, you can send an SYN packet on a specific port
    and, if the host responds with SYN-ACK, then the service is running and listening
    to the port.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test the HTTP port, for example in [google.com](https://www.google.com/),
    using `nmap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](../images/00225.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can use the same concept to discover the running services on the router.
    For example, the router that runs the BGP daemon will listen to port `179` for
    open/update/keep alive/notification messages. If you want to monitor the router,
    then the SNMP service should be enabled and should listen to incoming SNMP get/set
    messages. The MPLS LDP will usually listen to `646` for establishing a relationship
    with other neighbors. Here is a list of common services running on the router
    and their listening ports:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Service** | **Listening port** |'
  prefs: []
  type: TYPE_TB
- en: '| FTP | `21` |'
  prefs: []
  type: TYPE_TB
- en: '| SSH | `22` |'
  prefs: []
  type: TYPE_TB
- en: '| TELNET | `23` |'
  prefs: []
  type: TYPE_TB
- en: '| SMTP | `25` |'
  prefs: []
  type: TYPE_TB
- en: '| HTTP | `80` |'
  prefs: []
  type: TYPE_TB
- en: '| HTTPS | `443` |'
  prefs: []
  type: TYPE_TB
- en: '| SNMP | `161` |'
  prefs: []
  type: TYPE_TB
- en: '| BGP | `179` |'
  prefs: []
  type: TYPE_TB
- en: '| LDP | `646` |'
  prefs: []
  type: TYPE_TB
- en: '| RPCBIND | `111` |'
  prefs: []
  type: TYPE_TB
- en: '| NETCONF | `830` |'
  prefs: []
  type: TYPE_TB
- en: '| XNM-CLEAR-TEXT | `3221` |'
  prefs: []
  type: TYPE_TB
- en: We can create a dictionary with all of these ports and scan them using `subprocess`
    and Nmap. Then we use the returned output to create our table, which lists the
    open and closed ports for each scan. Also, with some additional logic, we can
    try to correlate information to guess the operating system type of the device
    function. For example, if the device is listening to port `179` (BGP port), then
    the device is most likely a network gateway and, if it listens to `389` or `636`,
    then the device is running an LDAP application and could be the company active
    directory. This will help us to create the proper attack against the device during
    the pen testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without further ado, let''s quickly put our idea and notes in the following
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We developed a function named `get_port_status()` to take the Nmap port scanning
    result and to search for the port status (open, closed, filtered, and so on) using
    the regular expression inside the `findall()` function. It returns the port status
    result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we added services ports mapped to the service name inside the `router_ports`
    dictionary, so we could access any port value using the corresponding service
    name (dictionary key). Also, we defined the router hosts' IP addresses inside
    the `live_hosts` list. Note that we can use the `nmap` with the `-sP` flag to
    get the live hosts, as we did before in a previous script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we can iterate over each IP address in the `live_hosts` list and execute
    the Nmap to scan each port in the `router_ports` dictionary. This requires a nested
    `for` loop, so for each device we iterate over a list of ports and so on. The
    result will be added to the `services_status` dictionary—the service name is a
    dictionary key while the port status is the dictionary value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we will add the result to `Router_Table` created using the `prettytable`
    module to get a nice-looking table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The script output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00226.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Sharing your code on GitHub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GitHub is a place where you can share your code and collaborate with others
    on a common project using Git. Git is a source version control platform invented
    and created by Linus Trovalds, who started Linux but had a problem maintaining
    Linux development with a large number of developers contributing to it. He created
    a de-centralized version control where anyone could get the entire code (called
    cloning or forking), make changes, then push them back to the central repository
    to be merged with other developers'' code. Git became the preferred method for
    many developers to work together on projects. You can learn how to code in Git
    interactively with this 15-minute course offered by GitHub: [https://try.github.io](https://try.github.io).'
  prefs: []
  type: TYPE_NORMAL
- en: GitHub is the website that hosts those projects, which is versioned using Git.
    It's like a developer social media platform, where you can track the code development,
    write a wiki, or raise an issue/bug report and get developer feedback on it. People
    on the same project can discuss the project progress and share code together to
    build a better and faster software. Also, some companies consider your code and
    repositories—shared in your account at GitHub—as an online resume that measures
    your skills and how you code in languages of interest.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an account on GitHub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing to do before sharing your code or downloading other codes is
    to create your account.
  prefs: []
  type: TYPE_NORMAL
- en: Head to [https://github.com/join?source=header-home](https://github.com/join?source=header-home)
    and choose a username, password, and email address, then click on the green Create
    an account button.
  prefs: []
  type: TYPE_NORMAL
- en: The second thing to do is to choose your plan. By default, the free plan is
    fine as it gives you unlimited public repositories and you can push any code developed
    in any languages you like. However, the free plan doesn't make your repository
    private and allows others to search for and download it. It's not a deal breaker
    if you're not working on secret or commercial projects in your company, however
    you need to make sure that you don't share any sensitive information, such as
    passwords, tokens, or public IP addresses in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and pushing your code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we're ready to share the code with others. The first thing after creating
    your GitHub account is to create a repository to host your files. Usually, you
    create one repository per project (not per file) and it contains project assets
    and files related to each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the + icon in the top-right, just beside your profile picture, to
    create a new repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00227.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You will be redirected to a new page where you can enter your repository name.
    Notice that you can choose any you like, but it shouldn't conflict with other
    repository in your profile. Also, you will be give a unique URL for this repo
    so anyone can access it. You can set the repo settings, such as whether it is
    public or private (only for paid plans), and if you want to initialize it with
    a README file. This file is written using **markdown** text formatting that includes
    information about your project, and steps for other developers to follow if they
    use your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you will have an option to add a `.gitignore` file where you tell
    Git to ignore tracking a certain type of file in your directory, such as logs,
    `pyc`, compiled files, video, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00228.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the end, your repo is created and you will be given a unique URL for it.
    Note this URL down as we will use it later when pushing files to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00229.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now it''s time to share your code. I will use the integrated Git functionality
    inside PyCharm to do the job although you can do the same steps in CLI. Also,
    there are many other GUI tools available (including one from GitHub itself) that
    can manage your GIT repo. I highly recommend that you do the Git training provided
    by GitHub ([https://try.github.io](https://try.github.io/)) before following these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to VCS | Import into Version Control | Create Git Repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00230.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Choose the folder where your project files are stored locally:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00231.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This will create a local Git repo in the folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Highlight all files that need to be tracked in the sidebar and right-click
    on them, then choose Git | Add:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00232.jpeg)PyCharm uses file color code to indicate the type
    of file tracked in Git. When the files are not tracked, it will color them red
    and when the files are added to Git, it will color them green. This allows you
    to easily know file status without running commands.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the remote repository in GitHub that will be mapped to the local repository
    by going to VCS | Git | Remotes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00233.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Enter the repo name and the URL you noted down when we created the repo; click
    OK twice to exit the window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00234.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The final step is to commit your code. Go to VCS | Git | Commit and from the
    opened popup window, select your tracked files, enter a descriptive message in
    the Commit Message section, and instead of hitting Commit, click on the small
    arrow beside it and choose Commit and Push. A dialog box might be opened telling
    you that your Git user Name Is Not Defined. Just enter your name and email and
    make sure the Set properties globally box is ticked and hit Set and Commit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00235.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The PyCharm gives you an option to push to Gerrit for code review. If you have
    one, you can also share your files in it. Otherwise, click on Push.
  prefs: []
  type: TYPE_NORMAL
- en: 'A notification message will appear telling you the push completed successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00236.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can refresh your GitHub repo URL from the browser and you will see all
    your files stored in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00237.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, whenever you make any change in the code inside the tracked files and commit,
    the changes will be tracked and added to the versioning system and will be available
    in GitHub for other users to download and comment on.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we built our network scanner, which can be used during authorized
    penetration testing, and learned how to scan different services and applications
    running on the device to detect their type. Also, we shared our code to GitHub
    so that we could keep different versions of our code and also allow other developers
    to use our shared code and enhance it, then share it again with others.
  prefs: []
  type: TYPE_NORMAL
