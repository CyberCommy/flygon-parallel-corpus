- en: '*Chapter 9*: Terminal I/O and Changing Terminal Behavior'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learn what a **TTY** (short for **TeleTYpewriter**) and
    a **PTY** (short for **Pseudo-TeletYpewriter**) are and how to get information
    about them. We also learn how to set their attributes. Then, we write a small
    program that takes input without echoing the text—perfect for a password prompt.
    We also write a program that checks the size of the current terminal.
  prefs: []
  type: TYPE_NORMAL
- en: A terminal can take many forms—for example, a terminal window in X (the graphical
    frontend); the seven terminals accessed with *Ctrl* + *Alt* + *F1* through *F7*;
    an old serial terminal; a dial-up terminal; or a remote terminal such as **Secure
    Shell** (**SSH**).
  prefs: []
  type: TYPE_NORMAL
- en: A **TTY** is a hardware terminal, such as the consoles accessed with *Ctrl*
    + *Alt* + *F1* through *F7*, or a serial console.
  prefs: []
  type: TYPE_NORMAL
- en: A `xterm`, `rxvt`, `tmux`. It could also be a remote terminal, such as SSH.
  prefs: []
  type: TYPE_NORMAL
- en: Since we all use terminals in our daily lives with Linux, knowing how to get
    information about them and control them can help us write better software. One
    such example is to hide the password in a password prompt.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Viewing terminal information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing terminal settings with `stty`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Investigating TTYs and PTYs and writing to them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking if it's a TTY
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a PTY
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disabling echo for password prompts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading the terminal size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll need all the usual tools, such as the `screen`. If you
    don't already have it, you can install it with your distribution's package manager—for
    example, `sudo apt-get install screen` for Debian/Ubuntu, or `sudo dnf install
    screen` for CentOS/Fedora.
  prefs: []
  type: TYPE_NORMAL
- en: All code samples for this chapter can be downloaded from [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch9](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch9).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following link to see the Code in Action video: [https://bit.ly/2O8j7Lu](https://bit.ly/2O8j7Lu)'
  prefs: []
  type: TYPE_NORMAL
- en: Viewing terminal information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll learn more about what TTYs and PTYs are and how to read
    their attributes and information. This will help us in our understanding of TTYs
    as we move forward in the chapter. Here, we learn how to find out which TTY or
    PTY we are using, where it lives on the filesystem, and how to read its attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are no special requirements for this recipe. We'll only use standard programs
    that are already installed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll explore how to find your own TTY, what attributes it
    has, where its corresponding file lives, and what kind of TTY it is:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by typing `tty` in your terminal. This will tell you which TTY you are
    using on the system. There can be many TTYs and PTYs on a single system. Each
    of them is represented by a file on the system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s examine that file. As we see here, it''s a special file type, called
    *character special*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s examine the terminal''s attributes with a program called `stty`.
    The `-a` option tells `stty` to display all attributes. The information we get
    is, for example, the size of the terminal (number of rows and columns); its speed
    (only important on serial terminals, dial-up, and so on); which *Ctrl* key combination
    is used for `-parenb`. All values without a minus sign, such as `cs8`, are enabled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s also possible to view another terminal''s attributes, assuming you own
    it, meaning the logged-in user must be you. If we try to view another user''s
    terminal, we get a *Permission denied* error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A single Linux system can have hundreds or thousands of logged-in users. Each
    of them is connected over a TTY or PTY. Back in the old days, this was often hardware
    terminals (TTYs) connected to the machine over serial lines. Nowadays, hardware
    terminals are pretty rare; instead, we log in over **SSH** or use terminal programs.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, the current user is logged in on a `/dev/pts/24`; that is *pts*,
    not *pty*. A PTY has two parts, a master and a slave. **PTS** stands for *pseudo-terminal
    slave*, and it's that part we connect to. The master part opens/creates the pseudo-terminal,
    but it's the slave that we use. We'll dig a bit deeper into this concept later
    in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The settings we used as an example in *Step 3* (`-parenb` and `cs8`) mean that
    `parenb` is disabled since it has a minus sign, and `cs8` is enabled. The `parenb`
    option will generate a parity bit and expect one back in the input. Parity bits
    were widely used in dial-up connections and serial communication. The `cs8` option
    sets the character size to 8 bits.
  prefs: []
  type: TYPE_NORMAL
- en: The `stty` program can be used to both view and set attributes for a terminal.
    In the next recipe, we'll return to `stty` to change some values.
  prefs: []
  type: TYPE_NORMAL
- en: As long as we are the terminal device owner, we can read and write to it, as
    we saw in the last step of the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's a lot of useful information in `man 1 tty` and `man 1 stty`.
  prefs: []
  type: TYPE_NORMAL
- en: Changing terminal settings with stty
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll learn how to change the settings (or attributes) of our
    terminal. In the previous recipe, we listed our current settings with `stty -a`.
    In this recipe, we'll change some of those settings, using the same `stty` program.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to change your terminal settings will enable you to adapt it according
    to your preference.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No special requirements exist for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we will change some of the settings for our current terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by turning off `whoami`, and get an answer. Notice that you won''t
    see the `whoami` command as you type it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To turn on echoing again, we type the same command again but without the minus
    sign. Notice that you won''t see the `stty` command when you type it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also change special key sequences—for example, usually, the EOF character
    is *Ctrl* + *D*. We can rebind that with a single dot (`.`) if we''d like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Type a single dot (`.`) now, and your current terminal will quit or log out.
    When you start a new terminal or log back in, the settings are back to normal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To save the settings for reuse later, we first make the necessary changes—for
    example, setting EOF to a dot. Then, we use `stty --save`. That option will print
    a long line of hexadecimal numbers—these numbers are the settings. So, to save
    them, we can redirect the output from `stty --save` to a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, log out by pressing a dot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Log back in (or re-open the terminal window). Try typing a dot, and nothing
    will happen. To reload our settings, we use the `my-tty-settings` file from the
    previous step. The `$()` sequence *expands* the command inside the parenthesis
    and is then used as an argument for `stty`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can once again try to log out by pressing a dot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A terminal is often a "dumb" device, and hence it requires lots of settings
    to make it work right. This is also one of those leftovers from the old days of
    hardware teletypewriters. The `stty` program is used to set attributes on a terminal
    device.
  prefs: []
  type: TYPE_NORMAL
- en: Options with a minus sign are negated—that is, disabled. Options without a minus
    sign are enabled. In our example, we first turned off echoing, a common practice
    for password prompts, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: There is no real way of saving the settings for a TTY, except for the way we
    saw here by saving it to a file and re-reading it later.
  prefs: []
  type: TYPE_NORMAL
- en: Investigating TTYs and PTYs and writing to them
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll learn how to list currently logged-in users, which TTYs
    they use, and which programs they are running. We'll also learn how to write to
    those users and terminals. As we'll see in this recipe, we can write to a **terminal
    device** just as if it were a file, assuming we have the correct permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to write to other terminals deepens understanding of how terminals
    work and what they are. It also enables you to write some interesting software
    and, above all, it will make you a better system administrator. It also teaches
    you about terminal security.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll start by investigating the logged-in users; then, we''ll learn how to
    send messages to them:'
  prefs: []
  type: TYPE_NORMAL
- en: To make things a bit more interesting, open up three to four terminal windows.
    If you're not using the **X-Window System**, log in on multiple TTYs. Or, if you
    are using a remote server, log in several times.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, type the `who` command in one of the terminals. You''ll get a list of
    all the logged-in users, which TTY/PTY they are using, and the date and time they
    logged in. In my example, I''ve logged in several times over SSH. If you are using
    a local machine with multiple `xterm` applications, you''ll see `(:0)` instead
    of the **Internet Protocol** (**IP**) address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s a similar command, `w`, that even shows which program the user on
    each terminal is currently using:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s find out which terminal we are using:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we know which terminal we are using, let''s send a message to another
    user and terminal. At the beginning of this book, I mentioned that everything
    is just a file or a process. This is true even for terminals. That means we can
    send data to a terminal using regular redirections:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The text *Hello* will now appear in the PTS2 terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sending messages to a terminal using `echo` only works if it''s the same user
    that''s logged in on the other terminal. For example, if I try to send a message
    to TTY1 where root is logged in, it doesn''t work—for a good reason:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'However, there exists a program that allows users to write to each other''s
    terminal, assuming they have allowed it. That program is called `write`. To allow
    or disallow messages, we use the `mesg` program. If you can log in as root (or
    some other user) on a terminal, do so, and then allow messages (the letter `y`
    stands for *yes*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, from another user, we can write to that user and terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: That message will now appear on TTY1, where root is logged in.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s another command that allows a user to write on *all* terminals. However,
    root is the only user that can write to users who have turned off messages. When
    logged in as root, issue the following command to write a message about a pending
    reboot to all logged-in users:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This will display a message, shown here, on all users'' terminals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since all the terminals are represented by files on the filesystem, it's easy
    to send messages to them. The regular permissions apply, however, to prevent users
    from writing to other users or snooping on their terminal.
  prefs: []
  type: TYPE_NORMAL
- en: With the `write` program, though, users can write messages to each other quickly,
    without needing any third-party software.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `wall` program is used to warn users of a pending reboot or shutdown. For
    example, if root issues the `shutdown -h +5` command to schedule a shutdown in
    5 minutes, all users will receive a warning. That warning is sent automatically,
    using the `wall` program.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information about the commands covered in this recipe, see the following
    manual pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`man 1 write`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`man 1 wall`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`man 1 mesg`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking if it's a TTY
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll start looking at some of the C functions to examine TTYs.
    Here, we mean TTY in the broadest sense, meaning both TTY and PTY.
  prefs: []
  type: TYPE_NORMAL
- en: The program we will write here will check if stdout is a terminal. If it's not,
    it will print an error message.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to check if stdin, stdout, or stderr are terminal devices will enable
    you to write error checks for programs that require a terminal to work.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we'll need the GCC compiler, the Make tool, and the generic
    Makefile. The generic Makefile can be downloaded from this chapter's GitHub folder,
    at https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch9.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we''ll write a small program that prints an error message if stdout is
    not a terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following small program in a file and save it as `ttyinfo.c`. We
    use two new functions here. The first one is `isatty()`, which checks if a `ttyname()`,
    which prints the terminal''s name connected to stdout (or actually the path):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try out the program. First, we run it without any redirections. The
    program will print the name of the terminal and the text *Hello world*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'But if we were to redirect file descriptor 1 to a file, it''s no longer a terminal
    (because that file descriptor is then pointing to a file and not a terminal).
    This will print an error message, but the *Hello world* message is still redirected
    to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To prove the point, we can "redirect" file descriptor 1 to `/dev/stdout`. Everything
    will then work as usual since file descriptor 1 is then once again stdout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Another step to prove the point is to redirect to our own terminal device.
    This will be similar to what we saw in the previous recipe when we used `echo`
    to print a text to a terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'For the sake of experimentation, let''s open up a second terminal. Find the
    TTY name of the new terminal with the `tty` command (in my case, it''s `/dev/pts/26`).
    Then, from the first terminal, run the `ttyinfo` program again, but redirect file
    descriptor 1 (stdout) to the second terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'No output will show up in the *current* terminal. However, on the *second*
    terminal, we see the program''s output, with the name of the second terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `STDOUT_FILENO` macro, which we used with both `isatty()` and `ttyname()`,
    is just the integer 1—that is, file descriptor 1.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that when we redirect stdout with a `>` sign, we redirect file descriptor
    1.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, file descriptor 1 is stdout, which is connected to your terminal.
    If we redirect file descriptor 1 with the `>` character to a file, it instead
    points to that file. Since the regular file isn't a terminal, we get an error
    message from the program (from the `isatty()` function's `errno` variable).
  prefs: []
  type: TYPE_NORMAL
- en: When we redirected file descriptor 1 back to `/dev/stdout`, it was once again
    stdout and no error message was printed.
  prefs: []
  type: TYPE_NORMAL
- en: In the last step, when we redirected the program's output to another terminal,
    all text got redirected to that terminal. Not only that—the name of the TTY printed
    by the program was indeed that second terminal's. The reason is that the terminal
    device connected to file descriptor 1 was indeed that terminal (`/dev/pts/26`,
    in my case).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information about the functions we used in the recipe, I recommend
    that you read `man 3 isatty` and `man 3 ttyname`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a PTY
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll create a `screen` and type away, and the characters will
    be printed to both the master and the slave. The slave is where the `screen` program
    is connected to, which is our terminal in this case. The master is usually quiet
    and runs in the background, but for demonstration purposes, we'll print the characters
    on the master as well.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to create a PTY enables you to write your own terminal applications,
    such as `xterm`, Gnome Terminal, `tmux`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you'll need the GCC compiler, the Make tool, and the `screen`
    program. Installation instructions for `screen` are found in the *Technical requirements*
    section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we''ll write a small program that creates a PTY. We''ll then connect
    to the slave end of this PTY—the PTS—using `screen`. We can then type characters,
    and they are printed back to us on the PTS:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by writing the program for this recipe. There are a lot of new
    concepts here, so the code is broken up into several steps. Write all of the code
    in a single file, called `my-pty.c`. We''ll start by defining `_XOPEN_SOURCE`
    (for `posix_openpt()`), and include all the header files we need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll start the `main()` function and define some variables we''ll need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time to create the PTY device with `posix_openpt()`. This will return
    a file descriptor, which we''ll save in `master`. Then, we run `grantpt()`, which
    sets the owner of the device to the current user, the group to *tty*, and changes
    the mode of the device to `620`. We must also unlock it with `unlockpt()` before
    using it. To know where we should connect, we also print the path to the slave
    device, using `ptsname()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create the main loop of the program. In the loop, we read a character
    from the PTS and then write it back again to the PTS. Here, we also print the
    character to the master so that we''ll see that it''s a master/slave pair. Since
    a terminal device is rather primitive, we must manually check for a **carriage
    return** character (the *Enter* key) and instead print a **newline** and a carriage
    return to make a new line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If no characters are received, the device connected to the slave has disconnected.
    If that is the case, we return, and hence exit from the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time to compile the program so that we can run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the program in your current terminal and make a note of the slave
    path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we move on to connect to it, let''s examine the device. Here, we''ll
    see that my user owns it, and it''s indeed a *character special* device, common
    for terminals:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open a new terminal and connect to the slave path you got from the master.
    In my case, it''s `/dev/pts/31`. To connect to it, we''ll use `screen`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can type away, and all the characters will be printed back to us. They
    will also appear on the master. To disconnect and quit `screen`, first hit *Ctrl*
    + *A* and then type a single *K*, as in kill. A question will then present to
    you (*Really kill this window [y/n]*); type *Y* here. You'll now see *Disconnected*
    in the terminal where you started `my-pty`, and the program will exit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We open a new PTY by using the `posix_openpt()` function. We set to both read
    and write using `O_RDWR`. By opening a new PTY, a new character device is created
    in `/dev/pts/`. It is that character device we later connected to using `screen`.
  prefs: []
  type: TYPE_NORMAL
- en: Since `posix_openpt()` returns a file descriptor, we can use all the regular
    system calls for file descriptors to read and write data, such as `read` and `write`.
  prefs: []
  type: TYPE_NORMAL
- en: A terminal device, such as the one we created here, is rather primitive. If
    we press *Enter*, the cursor will return to the start of the line. No new line
    will be created first. That's actually how the *Enter* key used to work. To solve
    this in our program, we check if the character read is a carriage return (that's
    what the *Enter* key sends), and if it is, we instead first print a newline character
    and then a carriage return.
  prefs: []
  type: TYPE_NORMAL
- en: If we only printed the newline character we would only get a new line, right
    under our current cursor. This behavior is a leftover from the old-school teletype
    devices with paper.After we have printed the current character (or newline and
    carriage return), we `fflush()`. The reason is that the character printed on the
    master end (where the `my-pty` program is running) isn't followed by a new line.
    Stdout is line-buffered, meaning it only flushes on a line break. But since we
    want to see each character as it's typed we must flush it on every character,
    using `fflush()`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There''s a lot of useful information in the manual pages. I particularly recommend
    you read the following manual pages: `man 3 posix_openpt`, `man 3 grantpt`, `man
    3 unlockpt`, `man 4 pts`, and `man 4 tty`.'
  prefs: []
  type: TYPE_NORMAL
- en: Disabling echo for password prompts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To protect users' passwords from shoulder surfing, it's always best to hide
    what they type. The way to hide a password from being displayed is to disable
    **echoing**. In this recipe, we'll write a simple password program with echoing
    disabled.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to disable echoing is key when writing programs that take some form
    of secret input, such as a password or a key.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you'll need the GCC compiler, the Make tool, and the generic
    Makefile.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we'll build a small program with a password prompt
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the code in this recipe will be rather long and some parts a bit arcane,
    I have split up the code into several steps. Note, however, that all code should
    go into a single file. Name the file `passprompt.c`. Let''s start with the `include`
    lines, the `main()` function, and the variables we''ll need. The struct named
    `term` of type `termios` is a special structure that holds the attributes for
    the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll start by disabling echoing, but first, we need to get all the
    current settings of the terminal by using `tcgetattr()`. Once we have all the
    settings, we modify them to disable echoing. The way we do it is to `ECHO`. The
    `~` sign negates a value. More on this in the *How it works…* section later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we write the code for the password prompt; nothing new here that we don''t
    already know:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, before we exit the program, we must turn on echoing again; otherwise,
    it will remain off even after the program has exited. The way to do that is to
    `ECHO`. This will reverse what we previously did:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s compile the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can try the program, and we''ll notice that we don''t see what we type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The way to make changes to the terminal with `tcsetattr()` is to get the current
    attributes with `tcgetattr()` and then modify them, and then finally apply those
    changed attributes to the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: The first argument to both `tcgetattr()` and `tcsetattr()` is the file descriptor
    we want to change. In our case, it's stdin.
  prefs: []
  type: TYPE_NORMAL
- en: The second argument to `tcgetattr()` is the struct where the attributes will
    be saved.
  prefs: []
  type: TYPE_NORMAL
- en: The second argument to `tcsetattr()` determines when the changes will have an
    effect. Here, we use `TCSAFLUSH`, which means that changes occur after all output
    is written, and all input received but not read will be discarded.
  prefs: []
  type: TYPE_NORMAL
- en: The third argument to `tcsetattr()` is the struct that contains the attributes.
  prefs: []
  type: TYPE_NORMAL
- en: To save and set attributes, we need a structure called `termios` (the same name
    as the header file we use). That structure contains five members, four of which
    are the modes. These are input modes (`c_iflag`), output modes (`c_oflag`), control
    mode (`c_cflag`), and local mode (`c_lflag`). What we change here is the local
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: First, we have the current attributes in the `c_lflag` member, which is an unsigned
    integer that's built up from a bunch of bits. Those bits are the attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Then, to turn off a setting—for example, echoing in our case—we negate the `ECHO`
    macro ("inverting" it) and then add it back to `c_lflag` with bitwise AND (the
    `&` sign).
  prefs: []
  type: TYPE_NORMAL
- en: The `ECHO` macro is `010` (octal 10), or 8 in decimal, which is `00001000` in
    binary (with 8 bits). Negated, it is `11110111`. A bitwise AND operation is then
    carried out on those bits with the other bits from the original settings.
  prefs: []
  type: TYPE_NORMAL
- en: The result of the bitwise AND operation is then applied to the terminal with
    `tcsetattr()`, which turns off echoing.
  prefs: []
  type: TYPE_NORMAL
- en: Before we end the program, we reverse the process by a bitwise OR operation
    on the new value with the `ECHO` value. Then, we apply that value with `tcsetattr()`,
    turning on echoing again.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are lots and lots of attributes we can set this way—for example, it's
    possible to disable flushing on interrupt and quit signals, and so on. The `man
    3 tcsetattr()` manual page has complete lists of macros to use for each of the
    modes.
  prefs: []
  type: TYPE_NORMAL
- en: Reading the terminal size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll continue digging around our terminal. Here, we write a
    funny little program that reports the size of the terminal live. As you resize
    your terminal window (assuming you are using an X console application), you'll
    instantly see the new size being reported.
  prefs: []
  type: TYPE_NORMAL
- en: To make this work, we'll make use of both a special `ioctl()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to use these two tools, escape sequences, and `ioctl()` will enable
    you to do some amusing things with the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make the most of this recipe, it's best to use an `xterm`, `rxvt`, *Konsole*,
    *Gnome Terminal*, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: You'll also need the GCC compiler, the Make tool, and the generic Makefile.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we will write a program that first clears the screen using a special
    escape sequence, then fetches the terminal''s size and prints to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code in a file and save it as `terminal-size.c`. The program
    uses an endless loop, so to quit the program, we must use *Ctrl* + *C*. On each
    iteration of the loop, we first clear the screen by printing a special *escape
    sequence*. Then, we get the terminal size with `ioctl()` and print the size on
    the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the program in a terminal window. As the program is running, resize
    the window. You''ll notice that the size is instantly updated. Quit the program
    with *Ctrl* + *C*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we define a structure name `termsize`, with the `winsize` type. We will
    save the terminal size in this structure later. The structure has two members
    (actually four, but only two are used). The members are `ws_row` for the number
    of rows and `wc_col` for the number of columns.
  prefs: []
  type: TYPE_NORMAL
- en: Then, to clear the screen, we use `printf()` to print a special escape sequence,
    `\033[1;1H\033[2J`. The `\033` sequence is the escape code. After the escape code,
    we have a `[` character, then we have the actual code telling the terminal what
    to do. The first one, `1;1H`, moves the cursor to position 1,1 (the first row
    and first column). Then, we use the `\033` escape code again so that we can use
    another code. First, we have the `[` character, just as before. Then, we have
    the `[2J` code, which means to erase the entire display.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have cleared the screen and moved the cursor, we use `ioctl()` to get
    the terminal size. The first argument is the file descriptor; here, we use stdout.
    The second argument is the command to send; here, it's `TIOCGWINSZ` to get the
    terminal size. These macros/commands can be found in the `man 2 ioctl_tty` manual
    page. The third argument is the `winsize` structure.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the sizes in the `winsize` structure, we print the values using
    `printf()`.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid draining the system resources, we sleep for 0.1 seconds before the
    next iteration.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `man 4 console_codes` manual page, there are lots and lots of other codes
    you can use. You can do everything from using colors to bold fonts, to moving
    the cursor, to ringing the terminal bell, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to print *Hello* in blinking magenta and then reset to the default
    values, you can use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note, though, that not all terminals can blink.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information about `ioctl()`, see both the `man 2 ioctl` and `man 2
    ioctl_tty` manual pages. The latter contains information about the `winsize` struct
    and the macros/commands.
  prefs: []
  type: TYPE_NORMAL
