- en: Installing an MQTT 3.1.1 Mosquitto Server
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装MQTT 3.1.1 Mosquitto服务器
- en: In this chapter, we will start our journey toward using the preferred IoT publish-subscribe
    lightweight messaging protocol in diverse IoT solutions, combined with mobile
    apps and web applications. We will learn how MQTT and its lightweight messaging
    system work.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始使用首选的物联网发布-订阅轻量级消息传递协议，在不同的物联网解决方案中与移动应用和Web应用程序相结合。我们将学习MQTT及其轻量级消息系统的工作原理。
- en: 'We will understand the MQTT puzzle: clients, servers (formerly known as brokers),
    and connections. We will learn the procedures to install an MQTT 3.1.1 Mosquitto
    server in Linux, macOS, and Windows. We will learn special considerations for
    running a Mosquitto server in the cloud (Azure, AWS, and other cloud providers).
    We will gain an understanding of the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将理解MQTT谜题：客户端、服务器（以前称为经纪人）和连接。我们将学习在Linux、macOS和Windows上安装MQTT 3.1.1 Mosquitto服务器的程序。我们将学习在云中运行Mosquitto服务器（Azure、AWS和其他云提供商）的特殊注意事项。我们将了解以下内容：
- en: Understanding convenient scenarios for the MQTT protocol
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解MQTT协议的便利场景
- en: Working with the publish-subscribe pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用发布-订阅模式
- en: Working with message filtering
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用消息过滤
- en: 'Understanding the MQTT puzzle: clients, servers, and connections'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解MQTT谜题：客户端、服务器和连接
- en: Installing a Mosquitto server on Linux
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Linux上安装Mosquitto服务器
- en: Installing a Mosquitto server on macOS
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在macOS上安装Mosquitto服务器
- en: Installing a Mosquitto server on Windows
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows上安装Mosquitto服务器
- en: Considerations for running a Mosquitto server in the cloud
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在云中运行Mosquitto服务器的注意事项
- en: Understanding convenient scenarios for the MQTT protocol
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解MQTT协议的便利场景
- en: Imagine that we have dozens of different devices that must exchange data between
    themselves. These devices have to request data from other devices, and the devices
    that receive the requests must respond with that data. The devices that request
    the data must process the data received from the devices that responded with the
    required data.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们有数十个不同的设备必须在它们之间交换数据。这些设备必须从其他设备请求数据，接收请求的设备必须用所需的数据做出响应。请求数据的设备必须处理来自响应所需数据的设备的数据。
- en: 'The devices are **Internet of Things** (**IoT**) boards that have dozens of
    sensors wired to them. We have the following IoT boards with different processing
    powers:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设备是物联网（IoT）板，上面连接了数十个传感器。我们有以下不同处理能力的物联网板：
- en: Raspberry Pi 3 Model B+
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Raspberry Pi 3 Model B+
- en: Qualcomm DragonBoard 410c
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qualcomm DragonBoard 410c
- en: Udoo Neo
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Udoo Neo
- en: BeagleBone Black
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BeagleBone Black
- en: Phytec phyBoard-i.MX7-Zeta
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Phytec phyBoard-i.MX7-Zeta
- en: e-con Systems eSOMiMX6-micro
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: e-con Systems eSOMiMX6-micro
- en: MinnowBoard Turbot Quad-Core
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MinnowBoard Turbot Quad-Core
- en: 'Each of these boards has to be able to send and receive data. In addition,
    we want a web application to be able to send and receive data. We want to send
    and receive data in near-real time over the internet, and we might face some network
    problems: our wireless networks are somewhat unreliable and we have some high-latency
    environments. Some devices have low power, many of them are powered by batteries,
    and their resources are scarce. In addition, we must be careful with the network
    bandwidth usage because some of the devices use metered connections.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些板都必须能够发送和接收数据。此外，我们希望Web应用程序能够发送和接收数据。我们希望能够在互联网上实时发送和接收数据，并且可能会遇到一些网络问题：我们的无线网络有些不可靠，而且有些高延迟的环境。一些设备功耗低，许多设备由电池供电，它们的资源有限。此外，我们必须小心网络带宽的使用，因为一些设备使用按流量计费的连接。
- en: A metered connection is a network connection where we have a limited amount
    of data usage per month. If we go over this amount of data, we get billed extra.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 按流量计费的连接是指每月有限的数据使用量的网络连接。如果超出此数据量，将额外收费。
- en: We can use HTTP requests and build a publish-subscribe model to exchange data
    between different devices. However, there is a protocol that has been specifically
    designed to be lighter than the HTTP 1.1 and HTTP/2 protocols. The **MQ Telemetry
    Transport** (**MQTT**) is better suited for a scenario in which many devices have
    to exchange data between themselves in near-real time over the internet and we
    need to consume the least network bandwidth possible. This protocol works better
    than HTTP 1.1 and HTTP/2 when unreliable networks are involved and connectivity
    is intermittent.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用HTTP请求并构建发布-订阅模型来在不同设备之间交换数据。然而，有一个专门设计的协议比HTTP 1.1和HTTP/2协议更轻。MQ Telemetry
    Transport（MQTT）更适合于许多设备在互联网上实时交换数据并且需要消耗尽可能少的网络带宽的场景。当涉及不可靠的网络和连接不稳定时，该协议比HTTP
    1.1和HTTP/2更有效。
- en: 'The MQTT protocol is a **machine-to-machine** (**M2M**) and IoT connectivity
    protocol. MQTT is a lightweight messaging protocol that works with a server-based
    publish-subscribe mechanism and runs on top of **TCP/IP** (**Transmission Control
    Protocol**/**Internet Protocol**). The following diagram shows the MQTT protocol
    on top of the TCP/IP stack:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT协议是一种机器对机器（M2M）和物联网连接协议。MQTT是一种轻量级的消息传递协议，使用基于服务器的发布-订阅机制，并在TCP/IP（传输控制协议/互联网协议）之上运行。以下图表显示了MQTT协议在TCP/IP堆栈之上的情况：
- en: '![](assets/2b55d99a-0dfd-49d7-8893-68b40101356c.png)The most popular versions
    of MQTT are 3.1.1 and 3.1\. In this book, we will work with MQTT 3.1.1\. Whenever
    we reference MQTT, we are talking about MQTT 3.1.1, the newest version of the
    protocol. The MQTT 3.1.1 specification has been standardized by the OASIS consortium.
    In addition, MQTT 3.1.1 became an ISO standard (ISO/IEC 20922) in 2016.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/2b55d99a-0dfd-49d7-8893-68b40101356c.png)MQTT最流行的版本是3.1.1和3.1。在本书中，我们将使用MQTT
    3.1.1。每当我们提到MQTT时，我们指的是MQTT 3.1.1，这是协议的最新版本。MQTT 3.1.1规范已经由OASIS联盟标准化。此外，MQTT
    3.1.1在2016年成为ISO标准（ISO/IEC 20922）。'
- en: 'MQTT is lighter than the HTTP 1.1 and HTTP/2 protocols, and therefore it is
    a very interesting option whenever we have to send and receive data in near-real
    time with a publish-subscribe model, while requiring the lowest possible footprint.
    MQTT is very popular in IoT, M2M, and embedded projects, but it is also gaining
    presence in web applications and mobile apps that require assured messaging and
    an efficient message distribution. As a summary, MQTT is suitable for the following
    application domains in which data exchange is required:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT比HTTP 1.1和HTTP/2协议更轻，因此在需要以发布-订阅模式实时发送和接收数据时，同时需要最小的占用空间时，它是一个非常有趣的选择。MQTT在物联网、M2M和嵌入式项目中非常受欢迎，但也在需要可靠消息传递和高效消息分发的Web应用和移动应用中占据一席之地。总之，MQTT适用于以下需要数据交换的应用领域：
- en: Asset tracking and management
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资产跟踪和管理
- en: Automotive telematics
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 汽车远程监控
- en: Chemical detection
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 化学检测
- en: Environment and traffic monitoring
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境和交通监测
- en: Field force automation
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现场力量自动化
- en: Fire and gas testing
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 火灾和气体测试
- en: Home automation
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 家庭自动化
- en: '**In-Vehicle Infotainment** (**IVI**)'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**车载信息娱乐**（**IVI**）'
- en: Medical
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 医疗
- en: Messaging
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息传递
- en: '**Point of Sale **(**POS**) kiosks'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**销售点**（**POS**）自助服务亭'
- en: Railway
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 铁路
- en: '**Radio-Frequency Identification **(**RFID**)'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**射频识别**（**RFID**）'
- en: '**Supervisory Control and Data Acquisition **(**SCADA**)'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控和数据采集**（**SCADA**）'
- en: Slot machines
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 老虎机
- en: 'As a summary, MQTT was designed to be suitable to support the following typical
    challenges in IoT, M2M, embedded, and mobile applications:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，MQTT旨在支持物联网、M2M、嵌入式和移动应用中的以下典型挑战：
- en: Be lightweight to make it possible to transmit high volumes of data without
    huge overheads
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻量化，使得能够在没有巨大开销的情况下传输大量数据
- en: Distribute minimal packets of data in huge volumes
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大量数据中分发最小的数据包
- en: Support an event-oriented paradigm with the asynchronous, bidirectional, low-latency
    push delivery of messages
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持异步、双向、低延迟推送消息的事件驱动范式
- en: Easily emit data from one client to many clients
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻松地从一个客户端向多个客户端发出数据
- en: Make it possible to listen for events whenever they happen (event-oriented architecture)
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使得能够在事件发生时监听事件（面向事件的架构）
- en: Support always-connected and sometimes-connected models
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持始终连接和有时连接的模式
- en: Publish information over unreliable networks and provide reliable deliveries
    over fragile connections
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不可靠的网络上发布信息，并在脆弱的连接上提供可靠的传递
- en: Work very well with battery-powered devices or require low power consumption
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非常适合使用电池供电的设备或需要低功耗
- en: Provide responsiveness to make it possible to achieve near-real-time delivery
    of information
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供响应性，使得能够实现信息的准实时传递
- en: Offer security and privacy for all the data
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为所有数据提供安全性和隐私
- en: Be able to provide the necessary scalability to distribute data to hundreds
    of thousands of clients
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够提供必要的可扩展性，将数据分发给数十万客户端
- en: Working with the publish-subscribe pattern
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用发布-订阅模式工作
- en: Before we dive deep into MQTT, we must understand the publish-subscribe pattern,
    also known as the pub-sub pattern. In the publish-subscribe pattern, a client
    that publishes a message is decoupled from the other client or clients that receive
    the message. The clients don't know about the existence of the other clients.
    A client can publish messages of a specific type and only the clients that are
    interested in that specific type of message will receive the published messages.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究MQTT之前，我们必须了解发布-订阅模式，也称为发布-订阅模式。在发布-订阅模式中，发布消息的客户端与接收消息的其他客户端或客户端解耦。客户端不知道其他客户端的存在。客户端可以发布特定类型的消息，只有对该特定类型的消息感兴趣的客户端才会接收到发布的消息。
- en: The publish-subscribe pattern requires a *server*, also known as a **broker**.
    All the clients establish a connection with the server. A client that sends a
    message through the server is known as the **publisher**. The server filters the
    incoming messages and distributes them to the clients that are interested in that
    type of received messages. Clients that register to the server as interested in
    specific types of messages are known as **subscribers**. Hence, both publishers
    and subscribers establish a connection with the server.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 发布-订阅模式需要一个*服务器*，也称为**代理**。所有客户端都与服务器建立连接。通过服务器发送消息的客户端称为**发布者**。服务器过滤传入的消息，并将其分发给对该类型接收消息感兴趣的客户端。向服务器注册对特定类型消息感兴趣的客户端称为**订阅者**。因此，发布者和订阅者都与服务器建立连接。
- en: 'It is easy to understand how things work with a simple diagram. The following
    diagram shows one publisher and two subscribers connected to a server:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单的图表很容易理解事物是如何工作的。以下图表显示了一个发布者和两个订阅者连接到服务器：
- en: '![](assets/987de943-ac68-4a91-af30-20bcdb0cca5b.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/987de943-ac68-4a91-af30-20bcdb0cca5b.png)'
- en: A **Raspberry Pi 3 Model B+** board with an altitude sensor wired to it is a
    publisher that establishes a connection with the server. A **BeagleBone Black**
    board and a **Udoo Neo** board are two subscribers that establish a connection
    with the server.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 连接有高度传感器的**树莓派3型B+**板是一个发布者，它与服务器建立连接。**BeagleBone Black**板和**Udoo Neo**板是两个订阅者，它们与服务器建立连接。
- en: The **BeagleBone Black** board indicates to the server that it wants to subscribe
    to all messages that belong to the **sensors/drone01/altitude** topic. The **Udoo
    Neo** board indicates the same to the server. Hence, both boards are subscribed
    to the **sensors/drone01/altitude** topic.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**BeagleBone Black**板向服务器指示要订阅属于**传感器/无人机01/高度**主题的所有消息。**Udoo Neo**板也向服务器指示相同的内容。因此，两个板都订阅了**传感器/无人机01/高度**主题。'
- en: A *topic* is a named logical channel, and it is also referred to as a channel
    or subject. The server will send subscribers only messages published to topics
    to which they are subscribed.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*主题*是一个命名的逻辑通道，也称为通道或主题。服务器只会向订阅了特定主题的订阅者发送消息。'
- en: The **Raspberry Pi 3 Model B+** board publishes a message with **100 feet**
    as the payload and **sensors/drone01/altitude** as the topic. This board, that
    is, the publisher, sends the publish request to the server.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: The data for a message is known as the **payload**. A message includes the topic
    to which it belongs and the payload.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'The server distributes the message to the two clients that are subscribed to
    the **sensors/drone01/altitude** topic: the **BeagleBone Black** and the **Udoo
    Neo** boards.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Publishers and subscribers are decoupled in space because they don't know each
    other. Publishers and subscribers don't have to run at the same time. The publisher
    can publish a message and the subscriber can receive it later. In addition, the
    publish operation isn't synchronized with the receive operation.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: A publisher requests the server to publish a message, and the different clients
    that have subscribed to the appropriate topic can receive the message at different
    times. The publisher can send a message as an asynchronous operation to avoid
    being blocked until the server receives the message. However, it is also possible
    to send a message to the server as a synchronous operation with the server and
    to continue the execution only after the operation was successful. In most cases,
    we will want to take advantage of asynchronous operations.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: A publisher that requires sending a message to hundreds of clients can do it
    with a single publish operation to a server. The server is responsible for sending
    the published message to all the clients that have subscribed to the appropriate
    topic. Because publishers and subscribers are decoupled, the publisher doesn't
    know whether any subscriber is going to listen to the messages it is going to
    send. Hence, sometimes it is necessary to make the subscriber become a publisher
    too and to publish a message indicating that it has received and processed a message.
    The specific requirements depend on the kind of solution we are building. MQTT
    offers many features that make our lives easier in many of the scenarios we have
    been analyzing. We will use these different features throughout the book.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Working with message filtering
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The server has to make sure that subscribers only receive the messages they
    are interested in. It is possible to filter messages based on different criteria
    in a publish-subscribe pattern. We will focus on analyzing *topic-based* filtering,
    also known as subject-based filtering.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Consider that each message belongs to a topic. When a publisher requests the
    server to publish a message, it must specify both the topic and the message. The
    server receives the message and delivers it to all the subscribers that have subscribed
    to the topic to which the message belongs.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: The server doesn't need to check the payload for the message to deliver it to
    the corresponding subscribers; it just needs to check the topic for each message
    that has arrived and needs to be filtered before publishing it to the corresponding
    subscribers.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: A subscriber can subscribe to more than one topic. In this case, the server
    has to make sure that the subscriber receives messages that belong to all the
    topics to which it has subscribed. It is easy to understand how things work with
    another simple diagram.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows two future publishers that haven''t published any
    messages yet, a server, and two subscribers connected to the server:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/289669b0-5c2b-4519-9e17-0b795fb48fcd.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
- en: A **Raspberry Pi 3 Model B+** board with an altitude sensor wired to it and
    a **Raspberry Pi 3** board with a temperature sensor wired to it will be the two
    publishers. A **BeagleBone Black** board and a **Udoo Neo** board are the two
    subscribers that establish a connection to the server.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'The **BeagleBone Black** board indicates to the server that it wants to subscribe
    to all the messages that belong to the **sensors/drone01/altitude** topic. The
    **Udoo Neo** board indicates to the server that it wants to subscribe to all the
    messages that belong to either of the following two topics: **sensors/drone01/altitude**
    and **sensors/drone40/temperature**. Hence, the **Udoo Neo** board is subscribed
    to two topics while the **BeagleBone Black** board is subscribed to just one topic.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows what happens after the two publishers connect and
    publish messages to different topics through the server:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/eebaf448-c739-4e3b-a6fc-c9ca3002a393.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
- en: 'The **Raspberry Pi 3 Model B+** board publishes a message with **120 feet**
    as the payload and **sensors/drone01/altitude** as the topic. The board, that
    is, the publisher, sends the publish request to the server. The server distributes
    the message to the two clients that are subscribed to the **sensors/drone01/altitude**
    topic: the **BeagleBone Black** and the **Udoo Neo** boards.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Raspberry Pi 3** board publishes a message with **75 F** as the payload
    and **sensors/drone40/temperature** as the topic. The board, that is, the publisher,
    sends the publish request to the server. The server distributes the message to
    the only client that is subscribed to the **sensors/drone40/temperature** topic:
    the **Udoo Neo** board. Thus, the **Udoo Neo** board receives two messages from
    the server, one that belongs to the **sensors/drone01/altitude** topic and one
    that belongs to the **sensors/drone40/temperature** topic.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows what happens after one publisher publishes a message
    to a topic through the server, and this topic has only one subscriber:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/08bb62ae-cc96-4a44-8dfa-3bd68cbc61c3.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: 'The **Raspberry Pi 3** board publishes a message with **76 F** as the payload
    and **sensors/drone40/temperature** as the topic. The board, that is, the publisher,
    sends the publish request to the server. The server distributes the message to
    the only client that is subscribed to the **sensors/drone40/temperature** topic:
    the **Udoo Neo** board.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the MQTT puzzle – clients, servers, and connections
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In versions of the MQTT protocol lower than 3.1.1, the MQTT server was known
    as an MQTT broker. Starting in MQTT 3.1.1, the MQTT broker was renamed the MQTT
    server, and therefore we will refer to it as the server. However, we must take
    into account that the documentation for MQTT servers, tools, and client libraries
    can use the old MQTT broker name to refer to the server. MQTT servers are also
    known as message brokers.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: The MQTT server uses the previously explained topic-based filtering to filter
    and distribute messages to the appropriate subscribers. There are many MQTT server
    implementations that provide additional message filtering features by providing
    custom plugins. However, we will focus on the features that are part of the MQTT
    protocol requirements.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: As previously explained, in MQTT publishers and subscribers are completely decoupled.
    Publishers and subscribers are MQTT clients that only establish a connection with
    the MQTT server. An MQTT client can be both a publisher and a subscriber at the
    same time, that is, the client can publish messages to specific topics and also
    receive messages that belong to topics to which the client has subscribed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: There are MQTT client libraries available for the most popular programming languages
    and platforms. One of the most important things that we must consider when we
    select the MQTT client library is the list of MQTT features that they support
    and the ones that we need for our solution. Sometimes, we can choose between many
    libraries for a specific programming language and platform, and some of them might
    not implement all the features. We will use the most complete libraries for modern
    Python versions that support a wide range of platforms throughout the book.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Any device that has a TCP/IP stack and is capable of using an MQTT library
    can become an MQTT client, that is, a publisher, a subscriber, or both a publisher
    and a subscriber. The MQTT library makes it possible for the device to talk to
    MQTT on top of TCP/IP and to interact with specific types of MQTT server. For
    example, any of the following can become an MQTT client, among other devices:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 任何具有TCP/IP协议栈并能够使用MQTT库的设备都可以成为MQTT客户端，即发布者、订阅者，或者既是发布者又是订阅者。MQTT库使设备能够在TCP/IP协议栈上与MQTT通信，并与特定类型的MQTT服务器进行交互。例如，以下设备都可以成为MQTT客户端，除其他设备外：
- en: An Arduino board
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Arduino板
- en: A Raspberry Pi 3 Model B+ board
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个树莓派3 Model B+板
- en: A BeagleBone Black board
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个BeagleBone Black板
- en: A Udoo Neo board
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Udoo Neo板
- en: An iPhone
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个iPhone
- en: An iPad
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个iPad
- en: An Android tablet
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个安卓平板电脑
- en: An Android smartphone
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个安卓智能手机
- en: A laptop running Windows
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行Windows的笔记本电脑
- en: A server running Linux
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行Linux的服务器
- en: A MacBook running macOS
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行macOS的MacBook
- en: There are many MQTT servers available for the most popular platforms, including
    Linux, Windows, and macOS. Many of them are servers that can work as MQTT servers
    and they also provide additional futures. An MQTT server might implement only
    a subset of the MQTT capabilities and might have specific limitations. Hence,
    it is very important to check all the capabilities we will require in our solution
    before selecting an MQTT server. As happens with other middleware, we have open
    source versions, free versions, and paid versions. Thus, we also have to make
    sure we select the appropriate MQTT server based on our budget and our specific
    needs.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 许多MQTT服务器适用于最流行的平台，包括Linux、Windows和macOS。其中许多是可以作为MQTT服务器工作并提供额外功能的服务器。MQTT服务器可能只实现MQTT功能的子集，并可能具有特定的限制。因此，在选择MQTT服务器之前，检查我们解决方案中所需的所有功能非常重要。与其他中间件一样，我们有开源版本、免费版本和付费版本。因此，我们还必须确保根据我们的预算和特定需求选择适当的MQTT服务器。
- en: Throughout this book, we will work with the Eclipse Mosquitto MQTT server ([http://www.mosquitto.org](http://www.mosquitto.org)).
    Mosquitto is an open source MQTT server with an EPL/EDL license that is compatible
    with MQTT versions 3.1.1 and 3.1\. We can take advantage of everything we learn
    with any other MQTT server, such as **Erlang MQTT Broker** (**EMQ**), also known
    as Emqttd ([http://www.emqtt.io](http://www.emqtt.io)), and HiveMQ ([http://hivemq.com](http://hivemq.com)),
    among others. In addition, we might use our knowledge to work with a cloud-based
    MQTT server such as CloudMQTT ([http://www.cloudmqtt.com](http://www.cloudmqtt.com))
    or the PubNub MQTT bridge ([http://pubnub.com](http://pubnub.com)). We will specifically
    work with cloud-based MQTT providers too.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用Eclipse Mosquitto MQTT服务器（[http://www.mosquitto.org](http://www.mosquitto.org)）。Mosquitto是一个开源的MQTT服务器，具有EPL/EDL许可证，与MQTT版本3.1.1和3.1兼容。我们可以利用我们学到的一切与其他MQTT服务器一起工作，比如**Erlang
    MQTT Broker**（**EMQ**），也称为Emqttd（[http://www.emqtt.io](http://www.emqtt.io)），以及HiveMQ（[http://hivemq.com](http://hivemq.com)），等等。此外，我们可能会利用我们的知识与基于云的MQTT服务器一起工作，比如CloudMQTT（[http://www.cloudmqtt.com](http://www.cloudmqtt.com)）或PubNub
    MQTT桥接器（[http://pubnub.com](http://pubnub.com)）。我们还将专门与基于云的MQTT提供商一起工作。
- en: The MQTT server is the central hub of the publish-subscribe model we previously
    analyzed. The MQTT server is responsible for the authentication and authorization
    of the MQTT clients that will be able to become publishers and/or subscribers
    after they are authenticated and authorized. So, the first thing that an MQTT
    client must do is to establish a connection with the MQTT server.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT服务器是我们之前分析的发布-订阅模型的中心枢纽。MQTT服务器负责对将能够成为发布者和/或订阅者的MQTT客户端进行身份验证和授权。因此，MQTT客户端必须做的第一件事就是与MQTT服务器建立连接。
- en: In order to establish a connection, the MQTT client must send a `CONNECT` control
    packet to the MQTT server with a payload that must include all the necessary information
    to initiate the connection and proceed with the authentication and authorization.
    The MQTT server will check the `CONNECT` packet, perform authentication and authorization,
    and send a response to the client with a `CONNACK` control packet that we will
    analyze in detail after understanding the `CONNECT` control packet. If the MQTT
    client sends an invalid `CONNECT` control packet, the server will automatically
    close the connection.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了建立连接，MQTT客户端必须向MQTT服务器发送一个带有有效载荷的`CONNECT`控制数据包，该有效载荷必须包括启动连接和进行身份验证和授权所需的所有必要信息。MQTT服务器将检查`CONNECT`数据包，执行身份验证和授权，并向客户端发送一个`CONNACK`控制数据包的响应，我们将在理解`CONNECT`控制数据包后详细分析。如果MQTT客户端发送了无效的`CONNECT`控制数据包，服务器将自动关闭连接。
- en: 'The following diagram shows the interaction between an MQTT client and an MQTT
    server to establish a connection:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了MQTT客户端与MQTT服务器之间建立连接的交互：
- en: '![](assets/38f3b9e7-aa98-49a9-8f4f-1eea5545a86f.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/38f3b9e7-aa98-49a9-8f4f-1eea5545a86f.png)'
- en: After a successful connection has been established between an MQTT client and
    an MQTT server, the server will keep the connection open until the client loses
    the connection or sends a `DISCONNECT` control packet to the server to close the
    connection.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在MQTT客户端和MQTT服务器之间建立成功连接后，服务器将保持连接开放，直到客户端失去连接或向服务器发送`DISCONNECT`控制数据包以关闭连接。
- en: 'The `CONNECT` control packet must include values for the following fields in
    the payload, and bits for a special flags byte that is included in the control
    packet. We want to understand the meaning of these fields and flags because we
    will be able to specify their values when we work with MQTT tools and MQTT client
    libraries in Python:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`CONNECT`控制数据包的有效载荷必须包括以下字段的值，以及包含在控制数据包中的特殊标志字节的位。我们希望理解这些字段和标志的含义，因为当我们使用Python中的MQTT工具和MQTT客户端库时，我们将能够指定它们的值：'
- en: '`ClientId`: The client identifier, also known as client ID, is a string that
    identifies each MQTT client that connects to an MQTT server. Each client that
    connects to the MQTT server must have a unique `ClientId`, and the server uses
    it to identify the state that it holds related to the MQTT session between the
    client and the server. If a client specifies an empty value as the `ClientId`,
    the MQTT server must generate a unique `ClientId` to identify the client. However,
    this behavior depends on the value specified for the `CleanSession` field.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClientId`：客户端标识符，也称为客户端ID，是一个字符串，用于标识连接到MQTT服务器的每个MQTT客户端。连接到MQTT服务器的每个客户端必须具有唯一的`ClientId`，服务器使用它来标识与客户端和服务器之间的MQTT会话相关的状态。如果客户端将空值指定为`ClientId`，MQTT服务器必须生成一个唯一的`ClientId`来标识客户端。但是，此行为取决于为`CleanSession`字段指定的值。'
- en: '`CleanSession`: The clean session flag is a Boolean value that specifies what
    happens after an MQTT client disconnects from the MQTT server and then reconnects.
    If `CleanSession` is set to `1` or `True`, the client indicates to the MQTT server
    that the session will only last as long as the network connection is alive. After
    the MQTT client disconnects from the MQTT server, any information related to the
    session is discarded. A new connection from the same MQTT client to the MQTT server
    will not use the data from the previous session and will be a new clean session.
    If `CleanSession` is set to `0` or `False`, we will work with a persistent session.
    In this case, the MQTT server stores all the subscriptions for the MQTT client
    and when the MQTT client disconnects, the MQTT server stores all the messages
    that arrive with specific quality of service levels that match the subscriptions
    that the MQTT client had at the time the disconnection occurred. This way, when
    the same MQTT client establishes a new connection with the MQTT server, the MQTT
    client will have the same subscriptions and will receive all the messages that
    it couldn''t receive when it lost the connection. We will dive deep into quality
    of service levels for messages and their relationship with the clean session flag
    or the persistent session option later in [Chapter 2](790c1d9a-c895-481e-a1c1-94ea07694cb4.xhtml), *Using
    Command-Line and GUI Tools to Learn How MQTT Works*.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CleanSession`：清理会话标志是一个布尔值，指定MQTT客户端从MQTT服务器断开连接然后重新连接后会发生什么。如果`CleanSession`设置为`1`或`True`，客户端向MQTT服务器指示会话只会持续到网络连接保持活跃。MQTT客户端从MQTT服务器断开连接后，与会话相关的任何信息都会被丢弃。同一MQTT客户端重新连接到MQTT服务器时，不会使用上一个会话的数据，而会创建一个新的清理会话。如果`CleanSession`设置为`0`或`False`，我们将使用持久会话。在这种情况下，MQTT服务器会存储MQTT客户端的所有订阅，当MQTT客户端断开连接时，MQTT服务器会存储与订阅匹配的特定服务质量级别的所有消息。这样，当同一MQTT客户端与MQTT服务器建立新连接时，MQTT客户端将拥有相同的订阅，并接收在失去连接时无法接收的所有消息。我们将在后面的[第2章](790c1d9a-c895-481e-a1c1-94ea07694cb4.xhtml)中深入探讨消息的服务质量级别及其与清理会话标志或持久会话选项的关系。'
- en: When the clean session flag is set to `0` or `False`, the client indicates to
    the server that it wants a persistent session. We just have to remember a clean
    session is the opposite of a persistent session.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当清理会话标志设置为`0`或`False`时，客户端向服务器指示它需要一个持久会话。我们只需要记住，清理会话是持久会话的相反。
- en: '`UserName`: If the client wants to specify a username to request authentication
    and authorization from the MQTT server, it must set the `UserName` flag to `1`
    or `True` and specify a value for the `UserName` field'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserName`：如果客户端想要指定一个用户名来请求MQTT服务器的认证和授权，它必须将`UserName`标志设置为`1`或`True`，并为`UserName`字段指定一个值。'
- en: '`Password`: If the client wants to specify a password to request authentication
    and authorization from the MQTT server, it must set the `Password` flag to `1`
    or `True` and specify a value for the `Password` field'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Password`：如果客户端想要指定一个密码来请求MQTT服务器的认证和授权，它必须将`Password`标志设置为`1`或`True`，并为`Password`字段指定一个值。'
- en: We will dedicate an entire chapter to MQTT security, and therefore we just mention
    the fields and the flags that are included in the `CONNECT` control packet.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专门为MQTT安全性撰写一整章，因此我们只提及`CONNECT`控制数据包中包含的字段和标志。
- en: '`ProtocolLevel`: The protocol level value indicates the MQTT protocol version
    that the MQTT client requests the MQTT server to use. Remember, we will always
    work with MQTT version 3.1.1.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProtocolLevel`：协议级别值指示MQTT客户端请求MQTT服务器使用的MQTT协议版本。请记住，我们将始终使用MQTT版本3.1.1。'
- en: '`KeepAlive`: `KeepAlive` is a time interval expressed in seconds. If the value
    for `KeepAlive` is not equal to `0`, the MQTT client commits to send control packets
    to the server within the time specified for `KeepAlive`. If the MQTT client doesn’t
    have to send any control packets, it must send a `PINGREQ` control packet to the
    MQTT server, a ping request to tell the MQTT server that the client connection
    is alive. The MQTT server responds to the `PINGREQ` control packet with a `PINGRESP`
    response to the MQTT client, a ping response to tell the MQTT client that the
    connection with the MQTT server is alive. The connection is closed when there
    is an absence of any of these control packets. If the value for `KeepAlive` is
    `0`, the keep-alive mechanism is turned off.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KeepAlive`：`KeepAlive`是以秒为单位表示的时间间隔。如果`KeepAlive`的值不等于`0`，MQTT客户端承诺在指定的`KeepAlive`时间内向服务器发送控制数据包。如果MQTT客户端不必发送任何控制数据包，它必须向MQTT服务器发送一个`PINGREQ`控制数据包，以告知MQTT服务器客户端连接仍然活跃。MQTT服务器会用`PINGRESP`响应控制数据包回应MQTT客户端，以告知MQTT客户端与MQTT服务器的连接仍然活跃。当缺少这些控制数据包时，连接将被关闭。如果`KeepAlive`的值为`0`，则保持活动机制将被关闭。'
- en: '`Will`, `WillQoS`, `WillRetain`, `WillTopic`, and `WillMessage`: These flags
    and fields allow the MQTT client to take advantage of the last will and testament
    feature of MQTT. If the MQTT client sets the `Will` flag to `1` or `True`, it
    specifies that it wants the MQTT server to store a last will message associated
    with the session. The `WillQoS` flag specifies the desired quality of service
    for the last will message, and the `WillRetain` flag indicates whether this message
    must be retained when it is published. If the MQTT client sets the `Will` flag
    to `1` or `True`, it must specify the topic for the `Will` message and the message
    in the `WillTopic` and `WillMessage` fields. If the MQTT client is disconnected
    or loses the connection with the MQTT server, the MQTT server will publish the
    message specified in the `WillMessage` field to the topic indicated in the `WillTopic`
    field with the chosen quality of service. We will analyze this feature in detail
    later.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Will，WillQoS，WillRetain，WillTopic和WillMessage：这些标志和字段允许MQTT客户端利用MQTT的遗嘱功能。如果MQTT客户端将Will标志设置为1或True，则指定它希望MQTT服务器存储与会话关联的遗嘱消息。WillQoS标志指定了遗嘱消息的期望服务质量，而WillRetain标志指示发布此消息时是否必须保留。如果MQTT客户端将Will标志设置为1或True，则必须在WillTopic和WillMessage字段中指定Will消息的主题和消息。如果MQTT客户端断开连接或与MQTT服务器失去连接，MQTT服务器将使用WillTopic字段中指定的主题以所选的服务质量发布WillMessage字段中指定的消息。我们将稍后详细分析此功能。
- en: 'The MQTT server will process a valid `CONNECT` control packet and it will respond
    with a `CONNACK` control packet. This control packet will include values for the
    following flags included in the header. We want to understand the meaning of these
    flags because we will be able to retrieve their values when we work with MQTT
    tools and MQTT client libraries:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT服务器将处理有效的CONNECT控制数据包，并将以CONNACK控制数据包作出响应。此控制数据包将包括标头中包含的以下标志的值。我们希望了解这些标志的含义，因为在使用MQTT工具和MQTT客户端库时，我们将能够检索它们的值：
- en: '`SessionPresent`: If the MQTT server received a connection request with the
    `CleanSession` flag set to `1` or `True`, the value for the `SessionPresent` flag
    will be `0` or `False` because no stored session will be reused. If the `CleanSession`
    flag was set to `0` or `False` in the connection request, the MQTT server will
    work with a persistent session, and the value for the `SessionPresent` flag will
    be `1` or `True` if the server had a persistent session for the client from a
    previous connection and retrieves it. Otherwise, `SessionPresent` will be `0`
    or `False`. The MQTT client that wanted to work with a persistent session can
    use the value of this flag to determine whether it has to request subscription
    to the desired topics, or whether the subscriptions have been restored from the
    persisted session.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'SessionPresent: 如果MQTT服务器收到了一个将CleanSession标志设置为1或True的连接请求，SessionPresent标志的值将为0或False，因为不会重用任何存储的会话。如果连接请求中的CleanSession标志设置为0或False，MQTT服务器将使用持久会话，并且如果服务器从先前的连接中为客户端检索到持久会话，则SessionPresent标志的值将为1或True。否则，SessionPresent将为0或False。想要使用持久会话的MQTT客户端可以使用此标志的值来确定是否必须请求订阅所需主题，或者订阅是否已从持久会话中恢复。'
- en: '`ReturnCode`: If the authorization and authentication passed and the connection
    was successfully established, the value for `ReturnCode` will be `0`. Otherwise,
    the return code will be different than `0` and the network connection between
    the client and the server will be closed. The following table shows the possible
    values for `ReturnCode` with their meanings:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'ReturnCode: 如果授权和认证通过，并且连接成功建立，ReturnCode的值将为0。否则，返回代码将不同于0，客户端和服务器之间的网络连接将被关闭。以下表格显示了ReturnCode的可能值及其含义：'
- en: '| **ReturnCode value** | **Description** |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: ReturnCode值 | 描述
- en: '| `0` |  The connection was accepted |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: 0 | 连接被接受
- en: '| `1` | The connection was refused because the MQTT server doesn''t support
    the MQTT protocol version requested by the MQTT client in the `CONNECT` control
    packet |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: 1 | 由于MQTT服务器不支持MQTT客户端在CONNECT控制数据包中请求的MQTT协议版本，连接被拒绝
- en: '| `2` | The connection was refused because the `ClientId` (client identifier)
    specified has been rejected |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: 2 | 由于指定的ClientId（客户端标识符）已被拒绝，连接被拒绝
- en: '| `3` | The connection was refused because the network connection was established
    but the MQTT service isn''t available |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: 3 | 由于网络连接已建立但MQTT服务不可用，连接被拒绝
- en: '| `4` | The connection was refused because the username or password values
    are malformed |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: 4 | 由于用户名或密码数值格式不正确，连接被拒绝
- en: '| `5` | The connection was refused because authorization failed |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: 5 | 由于授权失败，连接被拒绝
- en: Installing a Mosquitto server on Linux
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Linux上安装Mosquitto服务器
- en: 'Now, we will learn the necessary steps to install a Mosquitto server on the
    most popular operating systems: Linux, macOS, and Windows.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将学习在最流行的操作系统上安装Mosquitto服务器所需的步骤：Linux，macOS和Windows。
- en: It is extremely important to work with the latest available Mosquitto versions
    to make sure that many security vulnerabilities discovered in previous versions
    are addressed. For example, Mosquitto 1.4.15 addressed two important security
    vulnerabilities that affected versions 1.0 to 1.4.14 inclusive.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用最新版本的Mosquitto非常重要，以确保解决了先前版本中发现的许多安全漏洞。例如，Mosquitto 1.4.15解决了影响版本1.0至1.4.14（含）的两个重要安全漏洞。
- en: 'First, we will start with Linux; specifically, we will work with Ubuntu Linux.
    If you want to work with a different Linux distribution, you can find details
    about the installation procedure in the Mosquitto downloads section: [http://mosquitto.org/download](http://mosquitto.org/download).'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从Linux开始；具体来说，我们将使用Ubuntu Linux。如果您想使用其他Linux发行版，您可以在Mosquitto下载部分找到有关安装过程的详细信息：[http://mosquitto.org/download](http://mosquitto.org/download)。
- en: 'Follow these steps to install a Mosquitto server on Ubuntu Linux; take into
    account that you will require root privileges:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a Terminal window or use a secure shell to access Ubuntu and run the following
    command to add the Mosquitto repository:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You will see an output similar to the next lines (the temporary filenames will
    be different):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Run the following command to update the packages with the recently added Mosquitto
    repository:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You will see an output similar to the next lines. Note that the next lines
    show the output of an Ubuntu server running as a Windows Azure virtual machine,
    and therefore the output will be similar:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, run the following command to install the package for the Mosquitto server:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You will see an output similar to the next lines.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter `Y` and press *Enter* to answer the question and complete the installation
    process:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The last lines should include a line that says `Setting up mosquitto` followed
    by the version number, as shown in the following lines:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, run the following command to install the Mosquitto client packages that
    will allow us to run commands to publish messages to topics and subscribe to topic
    filters:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You will see an output similar to the next lines.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter `Y` and press *Enter* to answer the question and complete the installation
    process:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The last lines should include a line that says `Setting up mosquitto-clients` followed
    by the version number, as shown in the following lines:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, run the following command to check the status for the `mosquitto`
    service that was recently installed:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The first lines of the output should be similar to the following lines with
    an `active (running)` status displayed. The details after `CGroup` indicate the
    command line that started the service. The `-c` option followed by `/etc/mosquitto/mosquitto.conf`
    specifies that Mosquitto is using this configuration file:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can also run the following command to check whether the Mosquitto MQTT
    server is listening at the default port, `1883`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following lines show the results of the previous command that indicate
    the Mosquitto MQTT server has opened an IPv4 and an IPv6 listen socket on port
    `1883`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Installing a Mosquitto server on macOS
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to install a Mosquitto server on macOS, known as OS X prior
    to macOS Sierra:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t have Homebrew installed, open a Terminal window and run the command
    indicated on the Homebrew homepage, [http://brew.sh](http://brew.sh), to install
    this popular package manager for macOS. The following command will do the job.
    However, it is convenient to check the Homebrew homepage and check all the detailed
    instructions that are always updated with the newest versions of macOS that become
    available. If you already have Homebrew installed, move to the next step:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Open a Terminal window and run the following command to request Homebrew to
    install Mosquitto:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that in some cases, Homebrew might require additional software to be
    installed on your computer before you can install Mosquitto. If it is necessary
    to install additional software, such as Xcode command-line tools, Homebrew will
    provide you with the necessary instructions.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines show the last messages shown in Terminal that indicate
    that Homebrew has installed Mosquitto and the instructions to start the MQTT server:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After the Mosquitto installation has been completed, run the following command
    in a new Terminal window to launch Mosquitto with the default configuration file.
    The `-c` option followed by `/usr/local/etc/mosquitto/mosquitto.conf` specifies
    that we want to use this configuration file:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following is the output after you run the previous command:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The last lines indicate the Mosquitto MQTT server has opened an IPv4 and an
    IPv6 listen socket on the default TCP port, `1883`. Leave the Terminal window
    opened, because we need Mosquitto running on the local computer to work with the
    next examples.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Installing a Mosquitto server on Windows
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to install a Mosquitto server on Windows. Take into account
    that you will require Windows Vista or higher (Windows 7, 8, 8.1, 10, or greater).
    The instructions also work on Windows Server 2008, 2012, 2016, or greater:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the executable file listed under Binary Installation and Windows that
    provides the native build on the Mosquitto downloads web page: [http://mosquitto.org/download](http://mosquitto.org/download).
    For Mosquitto 1.4.15, the filename is `mosquitto-1.4.15-install-win32.exe`. You
    must click or tap on the filename and you will be redirected to the Eclipse repository
    with many mirror options, including a default recommendation, from which you can
    download the executable file.'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the previously downloaded executable file and the mosquitto Setup Wizard
    will display its welcome dialog box. Click Next > to continue. The setup wizard
    will display the dependencies that you must install: OpenSSL and pthreads. The
    dialog box will display the links that you can use to download and run installers
    for these two requirements, as shown in the following screenshot:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/2e12e15c-544b-484b-8719-da419fa7c04d.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
- en: If you don't have Win32 OpenSSL v1.0.2j Light installed on Windows, go to the
    Win32 OpenSSL web page, [http://slproweb.com/products/Win32OpenSSL.html](http://slproweb.com/products/Win32OpenSSL.html),
    and download the `Win32 OpenSSL v1.1.0g Light` file listed in a table under Download
    Win32 OpenSSL. Do not download the Win64 version, because you will need the Win32
    version to make it possible for Mosquitto to have its dependencies. If you already
    have Win32 OpenSSL v1.1.0g Light installed, advance to step 7\. For Win32 OpenSSL
    v1.1.0g Light, the filename is `Win32OpenSSL_Light-1_1_0g.exe`. Run the downloaded
    executable file and OpenSSL Light (32-bit) will display its welcome dialog box.
    Click Next > to continue.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The setup wizard will display the License Agreement. Read it, select I Accept
    the agreement, and click Next >. Select the folder in which you want to install
    OpenSSL Light (32-bit) if you don't want to use the default folder. Remember the
    folder you specify, because you will need to copy a few DLL files from this folder
    later. The default folder is `C:\OpenSSL-Win32`.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Next > to continue, specify a different Start Menu folder if necessary,
    and click Next >. Select The OpenSSL binaries (/bin) directory as the desired
    option for **Copy OpenSSL DLLs** to. This way, the installation will copy the
    DLLs to a `bin` subfolder within the previously specified folder, by default `C:\OpenSSL-Win32\bin`.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Next >** to continue. Review the selected installation options and click
    Install to complete the installation for OpenSSL Light (32-bit). Finally, consider
    a donation to the Win32 OpenSSL project and click **Finish** to exit setup.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to the following address in your web browser: [ftp://sources.redhat.com/pub/pthreads-win32/dll-latest/dll/x86](ftp://sources.redhat.com/pub/pthreads-win32/dll-latest/dll/x86).
    The browser will display many files for this FTP directory. Right-click on **pthreadVC2.dll**
    and save the file in your `Downloads` folder. You will have to copy this DLL to
    the Mosquitto installation folder later.'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, go back to the mosquitto Setup window and click **Next >** to continue.
    By default, Mosquitto will install the files and the Mosquitto Service. Leave
    the default components to install those selected and click **Next >** to continue.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the folder in which you want to install Mosquitto if you don't want to
    use the default folder. Remember the folder you specify, because you will need
    to copy a few DLL files to this folder later. The default folder is `C:\Program
    Files (x86)\mosquitto`. Click **Install** to complete the installation. Notice
    that the mosquitto Setup Wizard might display errors related to missing DLLs.
    We will fix this issue in the next steps. Once the installation has completed,
    click Finish to close the mosquitto Setup Wizard.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a File Explorer window and go to the `bin` subfolder within the folder
    in which you installed OpenSSL Light (32-bit), by default `C:\OpenSSL-Win32\bin`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy the following four DLLs: `libcrypto-1_1.dll`, `libeay32.dll`, `ssleay32.dll`,
    and `libssl-1_1.dll`. Now, go to the folder in which you installed Mosquitto and
    paste these four DLLs. By default, the Mosquitto installation folder is `C:\Program
    Files (x86)\mosquitto`. You will need to provide administrator permission to paste
    the DLLs in the default folder.'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a File Explorer window and go to your Downloads folder. Copy the pthreads
    DLL you downloaded in one of the previous steps, `pthreadVC2.dll`. Now, go to
    the folder in which you installed Mosquitto and paste this DLL. You will need
    to provide administrator permission to paste the DLL into the default Mosquitto
    installation folder.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that all the dependencies are included in the Mosquitto installation folder,
    it is necessary to run the installation again to make the Mosquitto setup configure
    the Windows service. Run the previously downloaded Mosquitto installation executable
    again. For Mosquitto 1.4.15, the filename is `mosquito-1.4.15-install-win32.exe`.
    Make sure you specify the same installation folder as the folder in which you
    copied the DLLs and that the `Service` component is activated. Click **Next >**
    many times and click **Install** to complete the configuration for the Windows
    service. Once the installation has completed, click Finish to close the mosquitto
    Setup Wizard.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the Services application in Windows and search for the service whose name
    is **Mosquitto Broker**. Right-click on the service name and select **Start**.
    The Status will change to **Running**. By default, the service is configured to
    have its **Startup Type** set to **Automatic**. If you don''t want to automatically
    start the Mosquitto Broker service, change the **Startup Type** to **Manual**.
    You will have to repeat the step you just did to manually start the service before
    working with Mosquitto on a Windows computer. Notice that the description for
    the service is MQTT v3.1 broker, as shown in the following screenshot. The description
    is outdated because the service provides an MQTT 3.1.1 server that is also compatible
    with MQTT 3.1:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/99ddba70-39f6-4886-9c6f-3e195f5724b0.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
- en: 'Open a Windows PowerShell or a Command Prompt window and run the following
    command to check whether the Mosquitto MQTT server is listening at the default
    TCP port, `1883`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following lines show the results of the previous command that indicate
    the Mosquitto MQTT server has opened an IPv4 and an IPv6 listen socket on port
    `1883`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Considerations for running a Mosquitto server in the cloud
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have worked with the default configuration for a Mosquitto server in Linux,
    macOS, and Windows. The Mosquitto server will work with TCP port `1883`. If you
    want to interact with the Mosquitto server from a different device or computer,
    you have to make sure that the firewall that is running on your computer has the
    appropriate configuration for this port number.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: When you run a Mosquitto server on a Linux or Windows virtual machine in the
    cloud, you also have to make sure that the virtual machine network filter that
    controls both inbound and outbound traffic has the appropriate configuration to
    allow inbound and outbound traffic on port `1883`. You must authorize inbound
    and outbound traffic on port `1883.`
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see whether you can answer the following questions correctly:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'MQTT runs on top of:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The MQIP protocol
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The TCP/IP protocol
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The IoT protocol
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The data for an MQTT message is known as:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Payload
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Packet
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upload
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In MQTT version 3.1.1, the broker is named:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: MQTT agent
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: MQTT client
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: MQTT server
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Mosquitto is:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A cloud-based MQTT server that is only available on Windows Azure
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A cloud-based MQTT server that is only available on Amazon Web Services
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An open source MQTT server compatible with MQTT versions 3.1.1 and 3.1
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The default TCP port that a Mosquitto server uses is:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`22`'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`1883`'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`9000`'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The rights answers are included in the [Appendix](d9cf708f-f027-4bfa-a2d2-9fd3653165d9.xhtml), *Solutions*.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we started our journey toward understanding the MQTT protocol.
    We understood convenient scenarios for this protocol, the details of the publish-subscribe
    pattern, and message filtering. We learned basic concepts related to MQTT and
    understood the different components: clients, servers or brokers, and connections.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: We learned to install a Mosquitto server on Linux, macOS, and Windows. We used
    the default configuration, as it allowed us to learn how everything works under
    the hood while using Mosquitto. Then, we will secure the server. This way, it
    will be easier for us to start using the client libraries in Python to publish
    MQTT messages and subscribe to MQTT topic filters.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our environment ready to start working with a still-unsecured
    Mosquitto server, we will work with command-line and GUI tools to learn how MQTT
    works in detail. We will learn MQTT basics, the specific vocabulary for MQTT,
    and its working modes, which are the topics that we are going to discuss in [Chapter
    2](790c1d9a-c895-481e-a1c1-94ea07694cb4.xhtml), *Using Command-Line and GUI Tools
    to Learn How MQTT Works*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
