- en: '*Chapter 2*: Implementing Vectors'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn the basics of vector math. Much of what you
    will code throughout the rest of this book relies on having a strong understanding
    of vectors. Vectors will be used to represent displacement and direction.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have implemented a robust vector library
    and will be able to perform a variety of vector operations, including component-wise
    and non-component-wise operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing vectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a vector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding component-wise operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding non-component-wise operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpolating vectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing vectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring more vectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Important information:'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to implement vectors in an intuitive, visual
    way that relies on code more than math formulas. If you are interested in math
    formulas or want some interactive examples to try out, go to [https://gabormakesgames.com/vectors.html](https://gabormakesgames.com/vectors.html).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing vectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a vector? A vector is an n-tuple of numbers. It represents a displacement
    measured as a magnitude and a direction. Each element of a vector is usually expressed
    as a subscript, such as *(V*0*, V*1*, V*2*, … V*N*)*. In the context of games,
    vectors usually have two, three, or four components.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a three-dimensional vector measures displacement on three unique
    axes: *x*, *y*, and *z*. Elements of vectors are often subscripted with the axis
    they represent, rather than an index. *(V*X*, V*Y*, V*Z*)* and *(V*0*, V*1*, V*2*)*
    are used interchangeably.'
  prefs: []
  type: TYPE_NORMAL
- en: When visualizing vectors, they are often drawn as arrows. The position of the
    base of an arrow does not matter because vectors measure displacement, not a position.
    The end of the arrow follows the displacement of the arrow on each axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, all of the arrows in the following figure represent the same vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1: Vector (2, 5) drawn in multiple locations'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.1_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.1: Vector (2, 5) drawn in multiple locations'
  prefs: []
  type: TYPE_NORMAL
- en: Each arrow has the same length and points in the same direction, regardless
    of where it is positioned. In the next section, you will start to implement the
    vector structure that will be used throughout the rest of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a vector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vectors will be implemented as structures, not classes. The vector struct will
    contain an anonymous union that allows the vector's components to be accessed
    as an array or as individual elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare the `vec3` structure and the function headers, create a new file,
    `vec3.h`. Declare the new `vec3` structure in this file. The `vec3` struct needs
    three constructors—a default constructor, one that takes each component as an
    element, and one that takes a pointer to a float array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The anonymous union in the `vec3` struct allows data to be accessed using `.x`,
    `.y`, and `.z` notation, or as a contiguous array using `.v`. Before moving on
    to implementing functions that work on the `vec3` struct, you need to consider
    comparing floating point numbers and whether or not to use an epsilon value.
  prefs: []
  type: TYPE_NORMAL
- en: Epsilon
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Comparing floating point numbers is difficult. Instead of comparing two floating
    point numbers directly, you need to compare them using an epsilon. An epsilon
    is an arbitrarily small positive number that is the minimum difference two numbers
    need to have to be considered different numbers. Declare an epsilon constant in
    `vec3.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Important note:'
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about floating point comparison at [https://bitbashing.io/comparing-floats.html](https://bitbashing.io/comparing-floats.html)
  prefs: []
  type: TYPE_NORMAL
- en: With the `vec3` structure created and the `vec3` epsilon defined, you are ready
    to start implementing some common vector operations. In the next section, you're
    going to start by learning and implementing several component-wise operations.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding component-wise operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Several vector operations are just component-wise operations. A component-wise
    operation is one that you perform on each component of a vector or on like components
    of two vectors. Like components are components that have the same subscript. The
    component-wise operations that you will implement are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Vector addition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vector subtraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vector scaling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiplying vectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dot product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at each of these in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Vector addition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adding two vectors together yields a third vector, which has the combined displacement
    of both input vectors. Vector addition is a component-wise operation; to perform
    it, you need to add like components.
  prefs: []
  type: TYPE_NORMAL
- en: 'To visualize the addition of two vectors, draw the base of the second vector
    at the tip of the first vector. Next, draw an arrow from the base of the first
    vector to the tip of the second vector. This arrow represents the vector that
    is the result of the addition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_2.2_B16191.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Vector addition'
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement vector addition in code, add like components of the input vectors.
    Create a new file, `vec3.cpp`. This is where you will define functions related
    to the `vec3` struct. Don''t forget to include `vec3.h`. Overload the `+ operator`
    to perform vector addition. Don''t forget to add the function signature to `vec3.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When thinking about vector addition, remember that a vector represents a displacement.
    When adding two vectors, the result is the combined displacement of both input
    vectors.
  prefs: []
  type: TYPE_NORMAL
- en: Vector subtraction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with adding vectors, subtracting vectors is also a component-wise operation.
    You can think of subtracting vectors as adding the negative of the second vector
    to the first vector. When visualized as an arrow, subtraction points from the
    tip of the second vector to the tip of the first one.
  prefs: []
  type: TYPE_NORMAL
- en: 'To visually subtract vectors, place both vectors so they share the same origin.
    Draw a vector from the tip of the second arrow to the tip of the first one. The
    resulting arrow is the subtraction result vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3: Vector subtraction'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.3_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.3: Vector subtraction'
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement vector subtraction, subtract like components. Implement the subtraction
    function by overloading the `-` operator in `vec3.cpp`. Don''t forget to add the
    function declaration to `vec3.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The steps and logic are very similar to vector addition. It might help to think
    of vector subtraction as adding a negative vector.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling vectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a vector is scaled, it only changes in magnitude, not direction. As with
    addition and subtraction, scaling is a component-wise operation. Unlike addition
    and subtraction, a vector is scaled by a scalar, not another vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visually, a scaled vector points in the same direction as the original vector,
    but it has a different length. The following figure shows two vectors: *(2, 1)*
    and *(2, 4)*. Both vectors share the same direction, but the magnitude of the
    second vector is longer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4: Vector scaling'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.4_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.4: Vector scaling'
  prefs: []
  type: TYPE_NORMAL
- en: To implement vector scaling, multiply every component of the vector by the given
    scalar value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the scale function by overloading the `*` operator in `vec3.cpp`.
    Don''t forget to add the function declaration to `vec3.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Negating a vector can be done by scaling the vector by *-1*. When negating a
    vector, the vector maintains its magnitude but changes its direction.
  prefs: []
  type: TYPE_NORMAL
- en: Multiplying vectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Vector multiplication can be considered a non-uniform scale. Instead of scaling
    every component of a vector by a scalar, to multiply two vectors, you scale every
    component of a vector by the like component of another vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can implement vector multiplication by overloading the `*` operator in
    `vec3.cpp`. Don''t forget to add the function declaration to `vec3.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The result generated by multiplying two vectors will have a different direction
    and magnitude.
  prefs: []
  type: TYPE_NORMAL
- en: Dot product
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The dot product is used to measure how similar two vectors are. Given two vectors,
    the dot product returns a scalar value. The result of the dot product has the
    following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: It is positive if the vectors point in the same direction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is negative if the vectors point in opposite directions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is *0* if the vectors are perpendicular.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If both input vectors have a unit length (you will learn about unit length vectors
    in the *Normal vectors* section of this chapter), the dot product will have a
    range of *-1* to *1*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dot product between two vectors, *A* and *B*, is equal to the length of
    *A* multiplied by the length of *B* multiplied by the cosine of the angle between
    the two vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_02_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The easiest way to calculate the dot product is to sum the products of like
    components in the input vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '*![](img/Formula_02_002.png)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `dot` function in `vec3.cpp`. Don''t forget to add the function
    definition to `vec3.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The dot product is one of the most used operations for video games. It's often
    used to check angles and in lighting calculations.
  prefs: []
  type: TYPE_NORMAL
- en: With the dot product, you have implemented the common component-wise operations
    of vectors. Next, you will learn about some of the non-component-wise operations
    that can be performed on vectors.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding non-component-wise operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Not all vector operations are component-wise; some operations require more
    math. In this section, you are going to learn how to implement common vector operations
    that are not component-based. These operations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: How to find the length of a vector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What a normal vector is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to normalize a vector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to find the angle between two vectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to project vectors and what rejection is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to reflect vectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the cross product is and how to implement it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at each one in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Vector length
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Vectors represent a direction and a magnitude; the magnitude of a vector is
    its length. The formula for finding the length of a vector comes from trigonometry.
    In the following figure, a two-dimensional vector is broken down into parallel
    and perpendicular components. Notice how this forms a right triangle, with the
    vector being the hypotenuse:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5: A vector broken down into parallel and perpendicular components'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.5_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.5: A vector broken down into parallel and perpendicular components'
  prefs: []
  type: TYPE_NORMAL
- en: The length of the hypotenuse of a right triangle can be found with the Pythagorean
    theorem, *A*2 *+ B*2 *= C*2\. This function extends to three dimensions by simply
    adding a *Z* component—*X*2 *+ Y*2 *+ Z*2 *= length*2\.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed a pattern here; the squared length of a vector equals
    the sum of its components. This could be expressed as a dot product—*Length*2*(A)
    = dot(A, A)*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Important note:'
  prefs: []
  type: TYPE_NORMAL
- en: Finding the length of a vector involves a square root operation, which should
    be avoided when possible. When checking the length of a vector, the check can
    be done in squared space to avoid the square root. For example, if you wanted
    to check if the length of vector *A* is less than *5*, that could be expressed
    as *(dot(A, A) < 5 * 5)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the square length function, sum the result of squaring each component
    of the vector. Implement the `lenSq` function in `vec3.cpp`. Don''t forget to
    add the function declaration to `vec3.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement the length function, take the square root of the result of the
    square length function. Take care not to call `sqrtf` with `0`. Implement the
    `lenSq` function in `vec3.cpp`. Don''t forget to add the function declaration
    to `vec3.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Important note:'
  prefs: []
  type: TYPE_NORMAL
- en: You can find the distance between two vectors by taking the length of the difference
    between them. For example, *float distance = len(vec1 - vec2)*.
  prefs: []
  type: TYPE_NORMAL
- en: Normalizing vectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A vector with a length of *1* is called a normal vector (or unit vector). Generally,
    unit vectors are used to represent a direction without a magnitude. The dot product
    of two unit vectors will always fall in the *-1* to *1* range.
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside from the *0* vector, any vector can be normalized by scaling the vector
    by the inverse of its length:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `normalize` function in `vec3.cpp`. Don''t forget to add the
    function declaration to `vec3.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `normalized` function in `vec3.cpp`. Don''t forget to add the
    function declaration to `vec3.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `normalize` function takes a reference to a vector and normalizes it in
    place. The `normalized` function, on the other hand, takes a constant reference
    and does not modify the input vector. Instead, it returns a new vector.
  prefs: []
  type: TYPE_NORMAL
- en: The angle between vectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If two vectors are of unit length, the angle between them is the cosine of
    their dot product:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_02_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If the two vectors are not normalized, the dot product needs to be divided
    by the product of the length of both vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_02_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To find the actual angle, not just the cosine of it, we need to take the inverse
    of the cosine on both sides, which is the arccosine function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_02_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Implement the `angle` function in `vec3.cpp`. Don''t forget to add the function
    declaration to `vec3.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Important note:'
  prefs: []
  type: TYPE_NORMAL
- en: The `acosf` function returns angles in radians. To convert radians to degrees,
    multiply by `57.2958f`. To convert degrees to radians, multiply by `0.0174533f`.
  prefs: []
  type: TYPE_NORMAL
- en: Vector projection and rejection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Projecting vector *A* onto vector *B* yields a new vector that has the length
    of *A* in the direction of *B*. A good way to visualize vector projection is to
    imagine that vector *A* is casting a shadow onto vector *B*, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6: Vector A casting a shadow onto vector B'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.6_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.6: Vector A casting a shadow onto vector B'
  prefs: []
  type: TYPE_NORMAL
- en: 'To calculate the projection of *A* onto *B* (*proj*B *A*), vector *A* must
    be broken down into parallel and perpendicular components with respect to vector
    *B*. The parallel component is the length of *A* in the direction of *B*—this
    is the projection. The perpendicular component is the parallel component subtracted
    from *A*—this is the rejection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7: Vector projection and rejection showing parallel and perpendicular
    vectors'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.7_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.7: Vector projection and rejection showing parallel and perpendicular
    vectors'
  prefs: []
  type: TYPE_NORMAL
- en: If the vector that is being projected onto (in this example, vector *B*) is
    a normal vector, then finding the length of *A* in the direction of *B* is a simple
    dot product between *A* and *B*. However, if neither input vector is normalized,
    the dot product needs to be divided by the length of vector *B* (the vector being
    projected onto).
  prefs: []
  type: TYPE_NORMAL
- en: Now that the parallel component of *A* with respect to *B* is known, vector
    *B* can be scaled by this component. Again, if *B* wasn't of unit length, the
    result will need to be divided by the length of vector *B*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rejection is the opposite of projection. To find the rejection of *A* onto
    *B*, subtract the projection of *A* onto *B* from vector *A*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `project` function in `vec3.cpp`. Don''t forget to add the function
    declaration to `vec3.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `reject` function in `vec3.cpp`. Don''t forget to declare this
    function in `vec3.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Vector projection and rejection are generally used for gameplay programming.
    It is important that they are implemented in a robust vector library.
  prefs: []
  type: TYPE_NORMAL
- en: Vector reflection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Vector reflection can mean one of two things: a mirror-like reflection or a
    bounce-like reflection. The following figure shows the different types of reflections:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8: A comparison of the mirror and bounce reflections'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.8_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.8: A comparison of the mirror and bounce reflections'
  prefs: []
  type: TYPE_NORMAL
- en: 'The bounce reflection is more useful and intuitive than the mirror reflection.
    To make a bounce projection work, project vector *A* onto vector *B*. This will
    yield a vector that points in the opposite direction to the reflection. Negate
    this projection and subtract it twice from vector A. The following figure demonstrates
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9: Visualizing a bounce reflection'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.9_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.9: Visualizing a bounce reflection'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `reflect` function in `vec3.cpp`. Don''t forget to add the function
    declaration to `vec3.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Vector reflection is useful for physics and AI. We won't need to use reflection
    for animation, but it's good to have the function implemented in case it is needed.
  prefs: []
  type: TYPE_NORMAL
- en: Cross product
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When given two input vectors, the cross product returns a third vector that
    is perpendicular to both input vectors. The length of the cross product equals
    the area of the parallelogram formed by the two vectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure demonstrates what the cross product looks like visually.
    The input vectors don''t have to be 90 degrees apart, but it''s easier to visualize
    them this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10: Visualizing the cross product'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.10_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.10: Visualizing the cross product'
  prefs: []
  type: TYPE_NORMAL
- en: Finding the cross product involves some matrix math, which will be covered in
    more depth in the next chapter. For now, you need to create a 3x3 matrix, with
    the top row being the result vector. The second and third rows should be filled
    in with the input vectors. The value of each component of the result vector is
    the minor of that element in the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'What exactly is the minor of an element in a 3x3 matrix? It''s the determinant
    of a smaller, 2x2 sub-matrix. Assuming you want to find the value of the first
    component, ignore the first row and column, which yields a smaller 2x2 sub-matrix.
    The following figure shows the smaller sub-matrix for each component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11: The submatrix for each component'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.11_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.11: The submatrix for each component'
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the determinant of a 2x2 matrix, you need to cross multiply. Multiply
    the top-left and bottom-right elements, then subtract the product of the top-right
    and bottom-left elements. The following figure shows this for each element of
    the resulting vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12: The determinant of each component in the result vector'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.12_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.12: The determinant of each component in the result vector'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `cross` product in `vec3.cpp`. Don''t forget to add the function
    declaration to `vec3.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The dot product has a relationship to the cosine of the angle between two vectors
    and the cross product has a relationship to the sine of the angle between the
    two vectors. The length of the cross product between the two vectors is the product
    of both vectors, lengths, scaled by the sine of the angle between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_02_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, you will learn how to interpolate between vectors using
    three different techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Interpolating vectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Two vectors can be interpolated linearly by scaling the difference between
    the two vectors and adding the result back to the original vector. This linear
    interpolation is often abbreviated to `lerp`. The amount to `lerp` by is a normalized
    value between *0* and *1*; this normalized value is often represented by the letter
    *t*. The following figure shows `lerp` between two vectors with several values
    for *t*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13: Linear interpolation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.13_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.13: Linear interpolation'
  prefs: []
  type: TYPE_NORMAL
- en: When *t = 0*, the interpolated vector is the same as the starting vector. When
    *t = 1*, the interpolated vector is the same as the end vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `lerp` function in `vec3.cpp`. Don''t forget to add the function
    declaration to `vec3.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Linearly interpolating between two vectors will always take the shortest path
    from one vector to another. Sometimes, the shortest path isn''t the best path;
    you may need to interpolate between two vectors along the shortest arc, instead.
    Interpolating on the shortest arc is called a spherical linear interpolation (`slerp`).
    The following figure shows the difference between the `slerp` and `lerp` processes
    for several values of *t*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.14: Comparing slerp and lerp'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.14_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.14: Comparing slerp and lerp'
  prefs: []
  type: TYPE_NORMAL
- en: To implement `slerp`, find the angle between the two input vectors. Assuming
    the angle is known, the formula for `slerp` is as follows
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_02_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Implement the `slerp` function in `vec3.cpp`. Don''t forget to add the function
    declaration to `vec3.h`. Take care of when the value of *t* is close to *0*, as
    `slerp` will yield unexpected results. When the value of *t* is close to *0*,
    fall back on `lerp` or normalized lerp (`nlerp`) (which will be covered next):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The last interpolation method to cover is `nlerp`. `nlerp` approximates `slerp`.
    Unlike `slerp`, `nlerp` is not constant in velocity. `nlerp` is much faster than
    `slerp` and easier to implement; just normalize the result of `lerp`. The following
    figure compares `lerp`, `slerp`, and `nlerp`, where *t = 0.25*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.15: Comparing lerp, slerp, and nlerp'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.15_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.15: Comparing lerp, slerp, and nlerp'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `nlerp` function in `vec3.cpp`. Don''t forget to add the function
    declaration to `vec3.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Generally, `nlerp` is a better choice than `slerp`. It's a very close approximation
    and much cheaper to calculate. The only time it makes sense to use `slerp` instead
    is if constant interpolation velocity is required. Throughout this book, you will
    be using `lerp` and `nlerp` to interpolate between vectors.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn how to use an epsilon value to compare vectors
    for equality and inequality.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing vectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last operation that needs to be implemented is vector comparison. Comparison
    is a component-wise operation; each element must be compared using an epsilon.
    Another way to measure whether two vectors are the same is to subtract them. If
    they were equal, subtracting them would yield a vector with no length.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overload the `==` and `!=` operators in `vec3.cpp`. Don''t forget to add the
    function declarations to `vec3.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Important note:'
  prefs: []
  type: TYPE_NORMAL
- en: Finding the right epsilon value to use for comparison operations is difficult.
    In this chapter, you declared `0.000001f` as the epsilon. This value is the result
    of some trial and error. To learn more about comparing floating point values,
    check out [https://bitbashing.io/comparing-floats.html](https://bitbashing.io/comparing-floats.html).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will implement vectors with two and four components.
    These vectors will only be used as a convenient way to store data; they won't
    actually need any math operations implemented on them.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring more vectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At some point later on in this book, you will need to utilize two- and four-component
    vectors as well. The two- and four-component vectors don't need any mathematical
    functions defined as they will be used exclusively as containers used to pass
    data to the GPU.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the three-component vector you have implemented, the two- and four-component
    vectors need to exist as both integer and floating point vectors. To avoid duplicating
    code, both structures will be implemented using a template:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, `vec2.h`, and add the definition of the `vec2` struct. All
    the `vec2` constructors are inline; there is no need for a `cpp` file. The `TVec2`
    struct is templated and `typedef` is used to declare `vec2` and `ivec2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, create a `vec4.h` file, which will hold the `vec4` structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The declaration of the `vec2`, `ivec2`, `vec4`, and `ivec4` structs are all
    very similar to the declaration of the `vec3` struct. All these structures can
    be accessed using component subscripts or as a pointer to a linear array of memory.
    They all have similar constructors, as well.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned the vector math required to create a robust
    animation system. Animation is a math-heavy topic; the skills you have learned
    in this chapter are required to complete the rest of this book. You implemented
    all the common vector operations for three-component vectors. The `vec2` and `vec4`
    structures don't have a full implementation like `vec3`, but they are only used
    to send data to the GPU.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will continue to learn more about game-related math
    by learning about matrices.
  prefs: []
  type: TYPE_NORMAL
