- en: '*Chapter 2*: Implementing Vectors'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn the basics of vector math. Much of what you
    will code throughout the rest of this book relies on having a strong understanding
    of vectors. Vectors will be used to represent displacement and direction.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have implemented a robust vector library
    and will be able to perform a variety of vector operations, including component-wise
    and non-component-wise operations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Introducing vectors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a vector
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding component-wise operations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding non-component-wise operations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpolating vectors
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing vectors
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring more vectors
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Important information:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to implement vectors in an intuitive, visual
    way that relies on code more than math formulas. If you are interested in math
    formulas or want some interactive examples to try out, go to [https://gabormakesgames.com/vectors.html](https://gabormakesgames.com/vectors.html).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Introducing vectors
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a vector? A vector is an n-tuple of numbers. It represents a displacement
    measured as a magnitude and a direction. Each element of a vector is usually expressed
    as a subscript, such as *(V*0*, V*1*, V*2*, … V*N*)*. In the context of games,
    vectors usually have two, three, or four components.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a three-dimensional vector measures displacement on three unique
    axes: *x*, *y*, and *z*. Elements of vectors are often subscripted with the axis
    they represent, rather than an index. *(V*X*, V*Y*, V*Z*)* and *(V*0*, V*1*, V*2*)*
    are used interchangeably.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: When visualizing vectors, they are often drawn as arrows. The position of the
    base of an arrow does not matter because vectors measure displacement, not a position.
    The end of the arrow follows the displacement of the arrow on each axis.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, all of the arrows in the following figure represent the same vector:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1: Vector (2, 5) drawn in multiple locations'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.1_B16191.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.1: Vector (2, 5) drawn in multiple locations'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Each arrow has the same length and points in the same direction, regardless
    of where it is positioned. In the next section, you will start to implement the
    vector structure that will be used throughout the rest of this book.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Creating a vector
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vectors will be implemented as structures, not classes. The vector struct will
    contain an anonymous union that allows the vector's components to be accessed
    as an array or as individual elements.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare the `vec3` structure and the function headers, create a new file,
    `vec3.h`. Declare the new `vec3` structure in this file. The `vec3` struct needs
    three constructors—a default constructor, one that takes each component as an
    element, and one that takes a pointer to a float array:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The anonymous union in the `vec3` struct allows data to be accessed using `.x`,
    `.y`, and `.z` notation, or as a contiguous array using `.v`. Before moving on
    to implementing functions that work on the `vec3` struct, you need to consider
    comparing floating point numbers and whether or not to use an epsilon value.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Epsilon
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Comparing floating point numbers is difficult. Instead of comparing two floating
    point numbers directly, you need to compare them using an epsilon. An epsilon
    is an arbitrarily small positive number that is the minimum difference two numbers
    need to have to be considered different numbers. Declare an epsilon constant in
    `vec3.h`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Important note:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about floating point comparison at [https://bitbashing.io/comparing-floats.html](https://bitbashing.io/comparing-floats.html)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: With the `vec3` structure created and the `vec3` epsilon defined, you are ready
    to start implementing some common vector operations. In the next section, you're
    going to start by learning and implementing several component-wise operations.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Understanding component-wise operations
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Several vector operations are just component-wise operations. A component-wise
    operation is one that you perform on each component of a vector or on like components
    of two vectors. Like components are components that have the same subscript. The
    component-wise operations that you will implement are as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Vector addition
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vector subtraction
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vector scaling
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiplying vectors
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dot product
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at each of these in more detail.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Vector addition
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adding two vectors together yields a third vector, which has the combined displacement
    of both input vectors. Vector addition is a component-wise operation; to perform
    it, you need to add like components.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'To visualize the addition of two vectors, draw the base of the second vector
    at the tip of the first vector. Next, draw an arrow from the base of the first
    vector to the tip of the second vector. This arrow represents the vector that
    is the result of the addition:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_2.2_B16191.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Vector addition'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement vector addition in code, add like components of the input vectors.
    Create a new file, `vec3.cpp`. This is where you will define functions related
    to the `vec3` struct. Don''t forget to include `vec3.h`. Overload the `+ operator`
    to perform vector addition. Don''t forget to add the function signature to `vec3.h`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When thinking about vector addition, remember that a vector represents a displacement.
    When adding two vectors, the result is the combined displacement of both input
    vectors.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Vector subtraction
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with adding vectors, subtracting vectors is also a component-wise operation.
    You can think of subtracting vectors as adding the negative of the second vector
    to the first vector. When visualized as an arrow, subtraction points from the
    tip of the second vector to the tip of the first one.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'To visually subtract vectors, place both vectors so they share the same origin.
    Draw a vector from the tip of the second arrow to the tip of the first one. The
    resulting arrow is the subtraction result vector:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3: Vector subtraction'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.3_B16191.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.3: Vector subtraction'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement vector subtraction, subtract like components. Implement the subtraction
    function by overloading the `-` operator in `vec3.cpp`. Don''t forget to add the
    function declaration to `vec3.h`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The steps and logic are very similar to vector addition. It might help to think
    of vector subtraction as adding a negative vector.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Scaling vectors
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a vector is scaled, it only changes in magnitude, not direction. As with
    addition and subtraction, scaling is a component-wise operation. Unlike addition
    and subtraction, a vector is scaled by a scalar, not another vector.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Visually, a scaled vector points in the same direction as the original vector,
    but it has a different length. The following figure shows two vectors: *(2, 1)*
    and *(2, 4)*. Both vectors share the same direction, but the magnitude of the
    second vector is longer:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4: Vector scaling'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.4_B16191.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.4: Vector scaling'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: To implement vector scaling, multiply every component of the vector by the given
    scalar value.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the scale function by overloading the `*` operator in `vec3.cpp`.
    Don''t forget to add the function declaration to `vec3.h`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Negating a vector can be done by scaling the vector by *-1*. When negating a
    vector, the vector maintains its magnitude but changes its direction.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Multiplying vectors
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Vector multiplication can be considered a non-uniform scale. Instead of scaling
    every component of a vector by a scalar, to multiply two vectors, you scale every
    component of a vector by the like component of another vector.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'You can implement vector multiplication by overloading the `*` operator in
    `vec3.cpp`. Don''t forget to add the function declaration to `vec3.h`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The result generated by multiplying two vectors will have a different direction
    and magnitude.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Dot product
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The dot product is used to measure how similar two vectors are. Given two vectors,
    the dot product returns a scalar value. The result of the dot product has the
    following properties:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: It is positive if the vectors point in the same direction.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is negative if the vectors point in opposite directions.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is *0* if the vectors are perpendicular.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If both input vectors have a unit length (you will learn about unit length vectors
    in the *Normal vectors* section of this chapter), the dot product will have a
    range of *-1* to *1*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'The dot product between two vectors, *A* and *B*, is equal to the length of
    *A* multiplied by the length of *B* multiplied by the cosine of the angle between
    the two vectors:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_02_001.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
- en: 'The easiest way to calculate the dot product is to sum the products of like
    components in the input vectors:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '*![](img/Formula_02_002.png)*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `dot` function in `vec3.cpp`. Don''t forget to add the function
    definition to `vec3.h`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The dot product is one of the most used operations for video games. It's often
    used to check angles and in lighting calculations.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: With the dot product, you have implemented the common component-wise operations
    of vectors. Next, you will learn about some of the non-component-wise operations
    that can be performed on vectors.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Understanding non-component-wise operations
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Not all vector operations are component-wise; some operations require more
    math. In this section, you are going to learn how to implement common vector operations
    that are not component-based. These operations are as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: How to find the length of a vector
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What a normal vector is
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to normalize a vector
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to find the angle between two vectors
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to project vectors and what rejection is
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to reflect vectors
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the cross product is and how to implement it
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at each one in more detail.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Vector length
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Vectors represent a direction and a magnitude; the magnitude of a vector is
    its length. The formula for finding the length of a vector comes from trigonometry.
    In the following figure, a two-dimensional vector is broken down into parallel
    and perpendicular components. Notice how this forms a right triangle, with the
    vector being the hypotenuse:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5: A vector broken down into parallel and perpendicular components'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.5_B16191.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.5: A vector broken down into parallel and perpendicular components'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: The length of the hypotenuse of a right triangle can be found with the Pythagorean
    theorem, *A*2 *+ B*2 *= C*2\. This function extends to three dimensions by simply
    adding a *Z* component—*X*2 *+ Y*2 *+ Z*2 *= length*2\.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed a pattern here; the squared length of a vector equals
    the sum of its components. This could be expressed as a dot product—*Length*2*(A)
    = dot(A, A)*:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'Important note:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Finding the length of a vector involves a square root operation, which should
    be avoided when possible. When checking the length of a vector, the check can
    be done in squared space to avoid the square root. For example, if you wanted
    to check if the length of vector *A* is less than *5*, that could be expressed
    as *(dot(A, A) < 5 * 5)*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the square length function, sum the result of squaring each component
    of the vector. Implement the `lenSq` function in `vec3.cpp`. Don''t forget to
    add the function declaration to `vec3.h`:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To implement the length function, take the square root of the result of the
    square length function. Take care not to call `sqrtf` with `0`. Implement the
    `lenSq` function in `vec3.cpp`. Don''t forget to add the function declaration
    to `vec3.h`:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Important note:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: You can find the distance between two vectors by taking the length of the difference
    between them. For example, *float distance = len(vec1 - vec2)*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Normalizing vectors
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A vector with a length of *1* is called a normal vector (or unit vector). Generally,
    unit vectors are used to represent a direction without a magnitude. The dot product
    of two unit vectors will always fall in the *-1* to *1* range.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside from the *0* vector, any vector can be normalized by scaling the vector
    by the inverse of its length:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `normalize` function in `vec3.cpp`. Don''t forget to add the
    function declaration to `vec3.h`:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Implement the `normalized` function in `vec3.cpp`. Don''t forget to add the
    function declaration to `vec3.h`:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `normalize` function takes a reference to a vector and normalizes it in
    place. The `normalized` function, on the other hand, takes a constant reference
    and does not modify the input vector. Instead, it returns a new vector.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: The angle between vectors
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If two vectors are of unit length, the angle between them is the cosine of
    their dot product:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_02_003.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: 'If the two vectors are not normalized, the dot product needs to be divided
    by the product of the length of both vectors:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_02_004.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
- en: 'To find the actual angle, not just the cosine of it, we need to take the inverse
    of the cosine on both sides, which is the arccosine function:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_02_005.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: 'Implement the `angle` function in `vec3.cpp`. Don''t forget to add the function
    declaration to `vec3.h`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Important note:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: The `acosf` function returns angles in radians. To convert radians to degrees,
    multiply by `57.2958f`. To convert degrees to radians, multiply by `0.0174533f`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Vector projection and rejection
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Projecting vector *A* onto vector *B* yields a new vector that has the length
    of *A* in the direction of *B*. A good way to visualize vector projection is to
    imagine that vector *A* is casting a shadow onto vector *B*, as shown:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6: Vector A casting a shadow onto vector B'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.6_B16191.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.6: Vector A casting a shadow onto vector B'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'To calculate the projection of *A* onto *B* (*proj*B *A*), vector *A* must
    be broken down into parallel and perpendicular components with respect to vector
    *B*. The parallel component is the length of *A* in the direction of *B*—this
    is the projection. The perpendicular component is the parallel component subtracted
    from *A*—this is the rejection:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7: Vector projection and rejection showing parallel and perpendicular
    vectors'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.7_B16191.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.7: Vector projection and rejection showing parallel and perpendicular
    vectors'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: If the vector that is being projected onto (in this example, vector *B*) is
    a normal vector, then finding the length of *A* in the direction of *B* is a simple
    dot product between *A* and *B*. However, if neither input vector is normalized,
    the dot product needs to be divided by the length of vector *B* (the vector being
    projected onto).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Now that the parallel component of *A* with respect to *B* is known, vector
    *B* can be scaled by this component. Again, if *B* wasn't of unit length, the
    result will need to be divided by the length of vector *B*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'Rejection is the opposite of projection. To find the rejection of *A* onto
    *B*, subtract the projection of *A* onto *B* from vector *A*:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `project` function in `vec3.cpp`. Don''t forget to add the function
    declaration to `vec3.h`:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Implement the `reject` function in `vec3.cpp`. Don''t forget to declare this
    function in `vec3.h`:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Vector projection and rejection are generally used for gameplay programming.
    It is important that they are implemented in a robust vector library.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Vector reflection
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Vector reflection can mean one of two things: a mirror-like reflection or a
    bounce-like reflection. The following figure shows the different types of reflections:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8: A comparison of the mirror and bounce reflections'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.8_B16191.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.8: A comparison of the mirror and bounce reflections'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'The bounce reflection is more useful and intuitive than the mirror reflection.
    To make a bounce projection work, project vector *A* onto vector *B*. This will
    yield a vector that points in the opposite direction to the reflection. Negate
    this projection and subtract it twice from vector A. The following figure demonstrates
    this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9: Visualizing a bounce reflection'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.9_B16191.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.9: Visualizing a bounce reflection'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `reflect` function in `vec3.cpp`. Don''t forget to add the function
    declaration to `vec3.h`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Vector reflection is useful for physics and AI. We won't need to use reflection
    for animation, but it's good to have the function implemented in case it is needed.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Cross product
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When given two input vectors, the cross product returns a third vector that
    is perpendicular to both input vectors. The length of the cross product equals
    the area of the parallelogram formed by the two vectors.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure demonstrates what the cross product looks like visually.
    The input vectors don''t have to be 90 degrees apart, but it''s easier to visualize
    them this way:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10: Visualizing the cross product'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.10_B16191.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.10: Visualizing the cross product'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Finding the cross product involves some matrix math, which will be covered in
    more depth in the next chapter. For now, you need to create a 3x3 matrix, with
    the top row being the result vector. The second and third rows should be filled
    in with the input vectors. The value of each component of the result vector is
    the minor of that element in the matrix.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'What exactly is the minor of an element in a 3x3 matrix? It''s the determinant
    of a smaller, 2x2 sub-matrix. Assuming you want to find the value of the first
    component, ignore the first row and column, which yields a smaller 2x2 sub-matrix.
    The following figure shows the smaller sub-matrix for each component:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11: The submatrix for each component'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.11_B16191.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.11: The submatrix for each component'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the determinant of a 2x2 matrix, you need to cross multiply. Multiply
    the top-left and bottom-right elements, then subtract the product of the top-right
    and bottom-left elements. The following figure shows this for each element of
    the resulting vector:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12: The determinant of each component in the result vector'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.12_B16191.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.12: The determinant of each component in the result vector'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `cross` product in `vec3.cpp`. Don''t forget to add the function
    declaration to `vec3.h`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The dot product has a relationship to the cosine of the angle between two vectors
    and the cross product has a relationship to the sine of the angle between the
    two vectors. The length of the cross product between the two vectors is the product
    of both vectors, lengths, scaled by the sine of the angle between them:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_02_006.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: In the next section, you will learn how to interpolate between vectors using
    three different techniques.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Interpolating vectors
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Two vectors can be interpolated linearly by scaling the difference between
    the two vectors and adding the result back to the original vector. This linear
    interpolation is often abbreviated to `lerp`. The amount to `lerp` by is a normalized
    value between *0* and *1*; this normalized value is often represented by the letter
    *t*. The following figure shows `lerp` between two vectors with several values
    for *t*:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13: Linear interpolation'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.13_B16191.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.13: Linear interpolation'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: When *t = 0*, the interpolated vector is the same as the starting vector. When
    *t = 1*, the interpolated vector is the same as the end vector.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `lerp` function in `vec3.cpp`. Don''t forget to add the function
    declaration to `vec3.h`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Linearly interpolating between two vectors will always take the shortest path
    from one vector to another. Sometimes, the shortest path isn''t the best path;
    you may need to interpolate between two vectors along the shortest arc, instead.
    Interpolating on the shortest arc is called a spherical linear interpolation (`slerp`).
    The following figure shows the difference between the `slerp` and `lerp` processes
    for several values of *t*:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.14: Comparing slerp and lerp'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.14_B16191.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.14: Comparing slerp and lerp'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: To implement `slerp`, find the angle between the two input vectors. Assuming
    the angle is known, the formula for `slerp` is as follows
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_02_007.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: 'Implement the `slerp` function in `vec3.cpp`. Don''t forget to add the function
    declaration to `vec3.h`. Take care of when the value of *t* is close to *0*, as
    `slerp` will yield unexpected results. When the value of *t* is close to *0*,
    fall back on `lerp` or normalized lerp (`nlerp`) (which will be covered next):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The last interpolation method to cover is `nlerp`. `nlerp` approximates `slerp`.
    Unlike `slerp`, `nlerp` is not constant in velocity. `nlerp` is much faster than
    `slerp` and easier to implement; just normalize the result of `lerp`. The following
    figure compares `lerp`, `slerp`, and `nlerp`, where *t = 0.25*:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.15: Comparing lerp, slerp, and nlerp'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.15_B16191.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.15: Comparing lerp, slerp, and nlerp'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `nlerp` function in `vec3.cpp`. Don''t forget to add the function
    declaration to `vec3.h`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Generally, `nlerp` is a better choice than `slerp`. It's a very close approximation
    and much cheaper to calculate. The only time it makes sense to use `slerp` instead
    is if constant interpolation velocity is required. Throughout this book, you will
    be using `lerp` and `nlerp` to interpolate between vectors.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn how to use an epsilon value to compare vectors
    for equality and inequality.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Comparing vectors
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last operation that needs to be implemented is vector comparison. Comparison
    is a component-wise operation; each element must be compared using an epsilon.
    Another way to measure whether two vectors are the same is to subtract them. If
    they were equal, subtracting them would yield a vector with no length.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'Overload the `==` and `!=` operators in `vec3.cpp`. Don''t forget to add the
    function declarations to `vec3.h`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Important note:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Finding the right epsilon value to use for comparison operations is difficult.
    In this chapter, you declared `0.000001f` as the epsilon. This value is the result
    of some trial and error. To learn more about comparing floating point values,
    check out [https://bitbashing.io/comparing-floats.html](https://bitbashing.io/comparing-floats.html).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will implement vectors with two and four components.
    These vectors will only be used as a convenient way to store data; they won't
    actually need any math operations implemented on them.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Exploring more vectors
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At some point later on in this book, you will need to utilize two- and four-component
    vectors as well. The two- and four-component vectors don't need any mathematical
    functions defined as they will be used exclusively as containers used to pass
    data to the GPU.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the three-component vector you have implemented, the two- and four-component
    vectors need to exist as both integer and floating point vectors. To avoid duplicating
    code, both structures will be implemented using a template:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, `vec2.h`, and add the definition of the `vec2` struct. All
    the `vec2` constructors are inline; there is no need for a `cpp` file. The `TVec2`
    struct is templated and `typedef` is used to declare `vec2` and `ivec2`:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Similarly, create a `vec4.h` file, which will hold the `vec4` structure:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The declaration of the `vec2`, `ivec2`, `vec4`, and `ivec4` structs are all
    very similar to the declaration of the `vec3` struct. All these structures can
    be accessed using component subscripts or as a pointer to a linear array of memory.
    They all have similar constructors, as well.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`vec2`，`ivec2`，`vec4`和`ivec4`结构的声明与`vec3`结构的声明非常相似。所有这些结构都可以使用组件下标或作为线性内存数组的指针来访问。它们的构造函数也非常相似。'
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have learned the vector math required to create a robust
    animation system. Animation is a math-heavy topic; the skills you have learned
    in this chapter are required to complete the rest of this book. You implemented
    all the common vector operations for three-component vectors. The `vec2` and `vec4`
    structures don't have a full implementation like `vec3`, but they are only used
    to send data to the GPU.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经学会了创建强大动画系统所需的向量数学知识。动画是一个数学密集型的主题；本章中学到的技能是完成本书其余部分所必需的。您已经为三维向量实现了所有常见的向量运算。`vec2`和`vec4`结构没有像`vec3`那样的完整实现，但它们只用于将数据发送到GPU。
- en: In the next chapter, you will continue to learn more about game-related math
    by learning about matrices.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将继续学习关于游戏相关数学的知识，学习关于矩阵的知识。
