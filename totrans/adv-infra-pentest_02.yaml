- en: Advanced Linux Exploitation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a clear understanding of the different penetration testing
    methodologies, phases, and requirements, the game is just starting. It is time
    to buckle your seat belt because, in this chapter, you will dive into securing
    the Linux environment, from a high-level overview of Linux infrastructure penetration
    testing, to discovering the dark depths of kernel vulnerabilities. This chapter
    outlines the skills and tools required to bulletproof Linux infrastructures.
  prefs: []
  type: TYPE_NORMAL
- en: Linux basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unix is an operating system developed by Bell Labs. Basically, it works on a
    command-line interface, and is designed for large systems. This operating system
    is not free, but it is proprietary and portable. Linux is a Unix clone developed
    by Linus Torvalds in 1991\. It is open source, and you can use it in anything
    that has a processor. Linux is flexible, and you can modify and implement it as
    it is licensed under a GNU **General Public License** (**GPL**).
  prefs: []
  type: TYPE_NORMAL
- en: Linux commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this subsection, let''s open the command line and execute some basic commands.
    In every Linux host, there are command-line interfaces named *shells* that interpret
    and execute typed commands and scripts. There are many shell environments, such
    as **Bourne Again Shell** (**Bash**, which is the most common shell), **C shell**
    (**csh**), **Korn shell** (**ksh**), and so on. To find the shells available for
    your environment, just open the command-line interface and type `cat /etc/shells`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s get around some vital basic Linux commands from the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pwd`: To know which directory you are in'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ls`: To list files in a directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cd`: To enter a directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mkdir`: To create a new directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rmdir`: To remove a directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`touch`: To create a new file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cat`: To read a file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cp`: To copy a file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mv`: To move a file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`man`: To be shown how to use a command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux is case-sensitive (to give users many command option possibilities `-T`, `-
    t`, `-a`, `- A`, and so on), so you need to check how you are writing every command.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a penetration tester, there are multiple important commands that you need
    to know in order to test the security posture of a Linux infrastructure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hostname`: Information about the host'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cat /proc/version`: Kernel information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uname -r`: Kernel release'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uname -a`: More detailed information about the system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cat /proc/cpuinfo`: Reads information about the processor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`echo $PATH`: Display information about the `PATH` variable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`history`: Display command history'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linux is provided with input/output redirection capabilities to facilitate
    tasks. It gives you the ability to manipulate the I/O streams using the following
    three types of streams:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Standard input (stdin)**: In this stream, the input is taken from the keyboard'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Standard output (stdout)**: This stream displays the result directly on the
    screen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Standard error (stderr)**: This is another type of standard output stream,
    but it carries error information instead of showing the output on the screen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redirection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Redirection is another Linux capability to enhance productivity. You can redirect
    the stream using simple symbols. You can redirect the output of a command to a
    text file using `>`, or `>>` if you want to append the file and not overwrite
    it; for example, `ls >  Simple_file.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, if you want to redirect a stream from one command to another, it is recommended
    to use the pipes like the following line, which lists the first two files in the
    current directory, `ls | head -2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Linux directory structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a standard structure for Linux directories. According to Linux, generally,
    everything is a file, even directories and devices. In order to work properly,
    Linux manages these files in a specific way under a hierarchical design:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/root`: All the files and directories start from this directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/home`: Contains personal files of all users'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/bin`: Contains all the binaries (executables)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sbin`: Like `/bin`, but it contains the system binaries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/lib`: Contains required library files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/usr`: Contains binaries used by a normal user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/opt`: Contains optional add-on applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/etc`: Contains all the required configuration files for the programs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/dev`: Contains device files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/media`: Contains files of temporary removable devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/mnt`: Contains mount point for filesystems'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/boot`: Contains boot loader files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/tmp`: Contains temporary files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/var`: Contains variable files, such as logs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/proc`: Contains information about the system processes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many types of file in Linux operation systems. Each file is represented
    by a specific symbol—directories, regular files, and sockets, which are communication
    techniques between applications.
  prefs: []
  type: TYPE_NORMAL
- en: Users and groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following subsection will cover the required Linux commands to manage user
    accounts and groups. To create a new user, use the `useradd` command; for example,
    `useradd <user>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, you are capable of adding more information about the new user, such as
    the related shell, the user directory, and expiration date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Every user must have a password, and in order to change the password, they
    need root access. To change a user password, use the `passwd` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To remove a user, use the `userdel` command. For example, `userdel -r <user>`, where
    the `-r` option is added to delete the files of the selected user.
  prefs: []
  type: TYPE_NORMAL
- en: Using groups is a technique for managing Linux accounts. Organizing users into
    groups is a security measure, and an isolation approach. To list all the groups
    in a Linux system, show the `group` file in the `/etc` directory using the `cat`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the screenshot, the `group` file contains all the groups
    in your Linux system. Just type `cat /etc/group`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: To create a new group, use the `newgrp` command `newgrp <Group_Name>`.
  prefs: []
  type: TYPE_NORMAL
- en: Permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linux is a multiuser operating system. To protect user accounts and groups,
    different rights are given to each user and group. There are three main permissions
    in a Linux system: read, write, and execution. These can be described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Read** is the ability to view a file and list the content if the target is
    a directory. It is represented by the letter (`r`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Write** allows a user to modify certain files and contents of a directory.
    It is represented by the letter (`w`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Execute** allows a user to run a script or a program and change directories.
    It is represented by the letter (`x`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are three types of permissions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Set User Identification** (**SUID**): When SUID is set, the file will be
    executed with the same permission as the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Set Group ID** (**SGID**): It is the same as SUID, but the file will be executed
    with the same permission as the group.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sticky Bit**: This permission is used when you can create, modify, or execute,
    but you can''t delete files of another user. Generally used on shared libraries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The chmod command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To change the permissions of a file, you need to use the `chmod` command, `chmod
    <letters> <file or directory>`. You can also use an octal format instead of letters, `chmod
    <octal format> <file or directory>`. To convert the permission from the letters
    format to the octal format, you need to convert every permission into a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Value** | **User** | **Group** | **Other** |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Read | Read | Read |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Write | Write | Write |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Execute | Execute | Execute |'
  prefs: []
  type: TYPE_TB
- en: 'Now, let''s take an example and see how to use the `chmod` command with the
    octal format in an easy way. Let''s suppose that we need to give the user the
    permission to read and write, the group only to read, and others only to execute.
    Then, the octal format will be `641`, because:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User**: *Read + Write = 6*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Group**: *Read = 4*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Other**: *Execute = 1*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final command will be: `chmod 641 <file>`
  prefs: []
  type: TYPE_NORMAL
- en: The chown command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, to change the owner of a file, use the `chown` command `chown user:group
    <file>`. To include all the contained files, add the option `-R` (recursive mode).
  prefs: []
  type: TYPE_NORMAL
- en: The chroot command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`chroot` is a technique for separating a non-root process and its children
    from the other system components. This isolation is designed in the Linux operating
    system, to make sure that when a subsystem is compromised, it won''t affect the
    entire system. The idea is to make the process think that it runs in the root
    folder, but in fact, it will be in a directory created by the administrator. So,
    let''s take a look at the required steps to build a chroot jail:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to create a new user and name it; for example, `prisoner`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Add the user to group root `gpasswd -a prisoner root`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can check whether you added the new user by verifying `/etc/group`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now create a new directory named `chroot`, and enter it
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create these folders:`bin`, `dev`, `etc`, `home`, `home/prisoner`, `lib`, `var`, `usr`,
    and `usr/bin`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here, at least the `bin` and `lib` directories are needed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, copy the `bash` utility using the `cp` command, `cp /bin/bash /chroot/bin`,
    including the required shared libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, use the `chroot` command to build the jail `chroot /chroot /bin/bash`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The power of the find command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discovered the importance of knowing how to extract
    the right information from a huge amount of data. When you are dealing with Linux,
    knowing how to find and extract information will help you use time efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: '`find` is a very useful command to help users locate any file based on defined
    criteria. The format of the `find` command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Wildcards are a great additional ability for helping users. They are inspired
    by the wild card term that describes the fact of assigning any value to a card.
    For example, when you use the asterisk wildcard (`*`) in a command, it means the
    `*` could be of any value such as the example here, to list all the text files
    in a directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot illustrates the output for the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The question mark (`?`) and square brackets ( `[xyz]` ) are also types of wildcards.
    Thus, the question mark represents only one value, whereas the brackets represent
    any of the values in between. There are some other representations such as `[:digit:] `:
    all  digits, ` [:upper:]`: all upper-case letters and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These are some other examples of find command usage for Linux exploitation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To display the bash history of the current user:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To find the root SUIDs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To display the files in `/var/log`, use the `ls /var/log` command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Jobs, cron, and crontab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Automation is an essential aspect of the Linux operating system. It is important for
    system administrators and also for penetration testers to automate many tasks
    to avoid wasting time in repeating them. As discussed in the previous chapter,
    penetration testing is a time-limited mission. So, good time management is an
    in-demand skill for every successful pentester. Linux gives users scheduling capabilities
    to run commands or scripts in a specific time, and in a repeatable manner. The
    cron utility is the key to achieve this. Cron gives you the ability to run a background
    job as a routine in a defined time. The following is a cron command format:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<Day of the week> <Month> <Day of the Month> <Hour> <Minutes> <Command>`'
  prefs: []
  type: TYPE_NORMAL
- en: 'All the cron jobs could be listed using `crontab -l`. They also could be found
    in `/etc/crontab`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Security models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Security models are specific mechanisms to represent security policies in a
    logical way. These models are based on the **Trusted Computing Base** (**TCB**),
    which is described in the US Department of Defense Standard 5200.28\. This standard
    is also known as the Orange Book. It presents TCB as trusted system components
    that are responsible for the access control to any system. TCB is limited by an
    fictional boundary called a *security perimeter*. Every connection between the
    TCB and other subsystem should be possible using secure channels sometimes named
    *security paths*. Security models are present to prevent unauthorized information
    flow. In other words, they assert that the information is flowing from a low-level
    security to a high level, and not the opposite. There are also other models named
    *noninterference models,* which focus on the behaviors done on each subject and
    not on the information flow. The following are some well-known security models:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bell-LaPadula Model**: This model is based on the confidentiality of an object.
    It dictates a no-read-up policy and no-write-down (the first is named *Simple
    Security Property*, and the second property is named *Star Security Property*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Biba Model**: This is a hierarchical system that concentrates on the integrity
    of the objects. It has two properties: the *Simple Integrity Axiom* which dictates
    a no-read-down policy, and the *Star Integrity Axiom* which dictate no-write-up
    policy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clark-Wilson Model**: This dictates that only authorized users should change
    the integrity of data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before exploring access controls, let''s discover some important terms in security
    controls. By definition, a control as a noun means an entity that checks based
    on a standard. Security controls are divided into three main categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Management security controls**: These use managerial techniques and planning
    to reduce the following risks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vulnerability analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pentesting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Risk analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Technical security controls**: This is also known as **operational security
    controls**. They use both technologies and awareness as safeguards. These are
    some examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firewalls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encryption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intrusion detection systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Antivirus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Training
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Physical security controls**: These are the physical safeguards used to protect
    the following data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cameras
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Biometrics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sensors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Access control models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Access controls are a form of technical security controls. Subjects and objects
    are two important terminologies. A subject is an active entity, such as an action
    (modification or access to a file, for example). An object is a static system
    entity, such as text file or a database. Basically, there are three types of access
    control models, described as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mandatory Access Control (MAC)**: The system checks the identity of a subject
    and its permissions with the object permissions. So usually, both subjects and
    objects have labels using a ranking system (top secret, confidential, and so on).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Discretionary Access Control (DAC)**: The object owner is allowed to set
    permissions to users. Passwords are a form of DAC.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Role-Based Access Control (RBAC)**: As its name indicates, the access is
    based on assigned roles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux attack vectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An attack is an actual act by a threat agent against assets of an information
    system. The path used to attack the target is called an **attack vector**. There
    are three main types of attack vector and threat:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Network threats**: This refers to the threat against the networks of the
    organization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Host threats**: These are the threats against the host, including hardware
    and the operating system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application threats**: This refers to the threat against the system programs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux enumeration with LinEnum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enumeration is a key for every successful attack. It is a critical phase in
    hacking systems, and a vital part of information gathering. During this phase,
    the attacker establishes a connection between them and the target (locally or
    remotely) to gather as much information as possible to decide on an attacking
    vector. To enumerate a Linux host, you can use a utility called **LinEnum**, and
    download it from [https://github.com/rebootuser/LinEnum.](https://github.com/rebootuser/LinEnum)
  prefs: []
  type: TYPE_NORMAL
- en: 'It is a useful shell script that gathers information about a Linux host using
    a checklist of at least 65 items, such as kernel and sensitive users information,
    in order to find an escalation point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows, for example, information about the logged user
    and the system groups (two items of the checklist):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: OS detection with Nmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step is to check whether the host is alive. To verify the state of
    a machine, type `nmap –sP <target>`; the target could be an IP address, or a range
    of addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Basically, the check is using an ICMP request, thus, many network administrators
    are blocking this protocol request due to firewalls and intrusion detection systems.
    Hence, penetration testers could use TCP or UDP requests (don''t worry; we will
    cover network aspects and protocols in the next chapter in a detailed way). To
    achieve it, you can use the nping utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Nmap has a great capability to detect operating systems, thanks to its huge
    database of footprinting based on TCP and UDP packets. To detect the OS, just
    use the `-O` Nmap option, `nmap –O <Target>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To detect the OS and services, use `nmap –n –A –T5 <target>`. It detects active
    services based on ports. The following are some services with their ports:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Services** | **Ports** |'
  prefs: []
  type: TYPE_TB
- en: '| `telnet` | `23` |'
  prefs: []
  type: TYPE_TB
- en: '| `ftp` | `21` |'
  prefs: []
  type: TYPE_TB
- en: '| `http` | `80` |'
  prefs: []
  type: TYPE_TB
- en: '| `pop3` | `110` |'
  prefs: []
  type: TYPE_TB
- en: '| `https` | `443` |'
  prefs: []
  type: TYPE_TB
- en: '| `ntp` | `123` |'
  prefs: []
  type: TYPE_TB
- en: '| `ldap` | `389` |'
  prefs: []
  type: TYPE_TB
- en: '| `postfix` | `25` |'
  prefs: []
  type: TYPE_TB
- en: '| `Imap` | `143` |'
  prefs: []
  type: TYPE_TB
- en: 'As a penetration tester, every step should be recorded; that is why Nmap is
    giving an output option to export the scan results. Just use the `-oN` option
    (you can choose between three formats: text (N), greppable (G), or XML (X) ): `nmap
    –n –A –T5 <target> -oN report.txt`.'
  prefs: []
  type: TYPE_NORMAL
- en: Privilege escalation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Privilege escalation** is the process of attempting to gain unauthorized
    high privilege, mostly trying to get root privilege. It is pivoting from the user
    account to the root account. In order to gain administrative privilege, the attacker
    exploits weakness in systems (programming bugs, misconfiguration, and so on).
    There are two types of privilege escalation: vertical and horizontal. When the
    attacker is moving from a lower privilege to a higher privilege, it is a vertical
    escalation. If he is moving from one account to another with the same privilege,
    it is a horizontal escalation. To achieve root permissions in Linux environment,
    attackers use many techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exploiting Linux services**: As discussed previously, attackers try to find
    bugs to leverage privileges. Linux services and configurations are good entry
    points for every hacker and penetration tester. We have the following examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**X11 service**: X11 is a graphical engine for Linux environments. Many interfaces
    can run on top of it, such as Gnome and KDE. The X11 service basically runs over 6000-60063
    ports. As discussed before, you can use Nmap to enumerate the host for active
    X11 services. One of the weaknesses of X11 is that an attacker can keylog every
    written information using an xspy tool, for example. The image here describes
    a Linux XServer environment:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Case study of Linux Bluetooth stack (BlueZ) information leak vulnerability –
    CVE-2017-1000250**:This vulnerability is a combination of a UserLand and a kernel
    land exploiting to leak information, including encryption keys in Bluetooth communications.
    The kernel-user vulnerability is a weakness in the lowest Bluetooth stack named
    L2CAP. It is a huge threat to many Bluetooth devices, including the ones that
    run Linux BlueZ: mobile, and IoT. To test the exploit on an android mobile, download
    it from this GitHub repository [https://github.com/ojasookert/CVE-2017-0785](https://github.com/ojasookert/CVE-2017-0785)
    and run the Python script: `./CVE-2017-0785.py TARGET=XX:XX:XX:XX:XX:XX`. Before
    that, make sure that you''ve installed the required Python libraries `pybluez`
    and `pwntools` using the `pip` utility as shown in the following screenshot:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Wildcards**: They could be deadly weapons. Researchers (back to the future:
    Unix Wildcards Gone Wild – Leon Juranic) show that wildcards can be used to inject
    arbitrary commands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SUID abuse**: This can be done using a program (such as Nmap) that requires
    root privilege to run other commands on the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****Linux kernel exploitation****: This is the most dangerous technique. If
    an attacker could exploit the kernel, he will get full control of the compromised
    system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux privilege checker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linux privilege checker is an enumeration tool with privilege escalation checking
    capabilities. To give it a try, download it from [http://www.securitysift.com/download/linuxprivchecker.py](http://www.securitysift.com/download/linuxprivchecker.py).
    You can download it using the `wget` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00046.gif)'
  prefs: []
  type: TYPE_IMG
- en: You can run it on your system by typing **`./linuxprivchecker.py`** or **`python linuxprivchecker.py`**.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00047.gif)'
  prefs: []
  type: TYPE_IMG
- en: Another tool for Unix and Linux operating systems is called unix-privesc-checker.
    It is available at [http://pentestmonkey.net/tools/audit/unix-privesc-check](http://pentestmonkey.net/tools/audit/unix-privesc-check).
  prefs: []
  type: TYPE_NORMAL
- en: Linux kernel exploitation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many motives for hacking, but nothing can be compared with the excitement
    of fully taking control of the systems. This can be done by exploiting the Linux
    kernel. Attacking the core of the system will make hackers feel on top of the
    world; that is why the kernel represents a high-priority target for every hacker.
  prefs: []
  type: TYPE_NORMAL
- en: UserLand versus kernel land
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most operating systems rely on a ring protection model. This model represents
    superposed conceptual rings varying from high to low privileges. There are four
    layers numbered from 0 to 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ring 3**: This layer is the usual interaction layer, with the user normally
    in the user mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ring 2**: This layer contains operations with low privilege.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ring 1**: This is the layer of input/output operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ring 0**: This is the most sensitive layer. The kernel resides in this layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Linux, like many recent operating systems, doesn''t rely exactly on a ring
    protection mechanism, but it is working on a two-layer mode: user mode, and kernel
    mode. The memory is divided into two sections and lands: UserLand and kernel land.
    The first is used by normal programs, so the processes in this land are using
    a limited part of memory. The second section is using all the memory, and it runs
    the most trusted codes.'
  prefs: []
  type: TYPE_NORMAL
- en: System calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'System calls, or *syscalls*, are the interfaces between the **UserLand** and
    the **kernel land**. It varies from an architecture to another; for example, in
    older processors, interrupts are used for transactions between the two spaces.
    Now, in newer architecture, optimized instructions are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00049.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Linux kernel subsystems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Linux kernel is composed of many components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory manager**: This is responsible for access to memory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Process scheduler**: This is responsible for managing processes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Virtual filesystem**: This represents a common file interface to a huge variety
    of devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network interface**: This manages network standard and networking devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inter-process communications**: This manages communication between many processes
    in a single system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Device drivers**: These are present to make the device hardware usable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A process is an instance of a program. When a program is loaded into memory,
    then it is named a **process**. A process could be in different states: new, running,
    waiting, ready, and terminated. In Linux, each process has an identity named `PID`.
    You can check them using the `ps` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Threads are like processes. Although processes are running on a separate memory
    space, threads are running on a shared memory. They can be scheduled for execution.
  prefs: []
  type: TYPE_NORMAL
- en: Security-Enhanced Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Security-Enhanced Linux** (**SELinux**) is a security project developed by
    the United States National Security Agency (NSA). It is a **Linux Security Module**
    (**LSM**) integrated in the Linux kernel, starting from 2.6.0 kernel release.
    It implements a mandatory access control (MAC) system to protect the environment.
    It specifies the policies of how users interact with the system. When a subject
    such as a process wants to request an action from a file, the SELinux security
    server check with the **access vector cache** (**AVC**) to grant access, thanks
    to a security policies database. It is an extra security layer on top of the normal
    Linux systems. The following is an illustration of a SELinux process workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can check the global configuration file of the SELinux under the `/etc/selinux`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Memory models and the address spaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Memory management is an important capability of every operating system. It
    is also integrated into Linux kernel. Linux manages memory in a virtual way. In
    other words, there is no correspondence between the physical memory addresses,
    and the addresses used and seen by the program. This technique gives the users
    and developers flexibility. Linux is dealing with the following five types of
    addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User virtual addresses**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Physical addresses**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bus addresses**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kernel logical addresses**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kernel virtual addresses**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The memory is divided into 4,096 byte memory chunks named pages, to facilitate
    internal handling. The 12 least significant bits are the offset; the rest is the
    page number. On the recent x86 architecture, Linux kernel divides the virtual
    space, usually 4 GB into 3 GB dedicated to UserLand, and 1 GB for kernel land.
    This operation is named **segmentation**. The kernel uses a page table for the
    correspondence between physical and virtual addresses. To manage the different
    regions of memory, it uses a **virtual memory area** (**VMA**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To show a memory map for a process, you can display the `/proc/1/maps` file
    using the `cat` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Linux kernel vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux kernel is the most critical component in Linux infrastructure. Thus, taking
    control of it will grant access to all the system and sensitive information. If
    hackers get root access to even the hardware, they will not be stopped from damaging
    the systems or stealing critical information. There are many kernel vulnerabilities
    classified based on the attack surface (memory, pointers, logic, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: NULL pointer dereference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'NULL pointer dereferences are availability exploits. Generally, they are caused
    by a NULL pointer error, and it results a `NullPointerException`. This exception
    is raised when a pointer, which is a programming object that refers to an address
    with value of NULL, is pointing to a valid memory space. To avoid this type of
    attack, you just need to evoke an exception handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00056.gif)'
  prefs: []
  type: TYPE_IMG
- en: Arbitrary kernel read/write
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arbitrary kernel read/write is a critical exploit that can be done by passing
    data to the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Case study CVE-2016-2443 Qualcomm MSM debug fs kernel arbitrary write
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This exploit is using a Linux branch for Qualcomm SoC on android named MSM.
    It is high and critical. It targets the debug filesystem also known as `debugfs`, which
    is a RAM-based file system generally used for debugging aims by making information
    available for user space. That is why it is a good entry to inject some information
    to the Linux kernel. This exploit gives you the ability to pass data to kernel
    causing a kernel panic via the echo command: `echo "41414141 42424242" > /sys/kernel/debug/mddi/reg`.'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, it will lead to an information leak.
  prefs: []
  type: TYPE_NORMAL
- en: Memory corruption vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Memory management is a vital component of Linux kernel. So, it is an important
    surface attack. The two major memory corruption exploits that are threats to the
    kernel and the Linux infrastructure in general are kernel stack, and kernel heap
    vulnerabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00057.jpeg),'
  prefs: []
  type: TYPE_NORMAL
- en: Kernel stack vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The stack is a special memory space. In programming, it is an abstract data
    type used to collect elements using two operations: push and pop. This section
    grows automatically, but when it becomes closer to another memory section, it
    will cause a problem and a confusion to the system. That is why attackers are
    using this technique to confuse the system with other memory areas.'
  prefs: []
  type: TYPE_NORMAL
- en: Kernel heap vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The heap is used for dynamic memory allocation. It resides in the RAM like
    the stack, but it is slower. The kernel heap is using the following three types
    of allocators:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SLAB**: This is a cache-friendly allocator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simple list of blocks** (**SLOB**): This is an allocator used in small systems.
    It uses a first-fit algorithm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SLUB**: It is the default Linux allocator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kernel heap exploits are dangerous because in most cases, the attacker doesn't
    need to prepare a Linux module debugging environment.
  prefs: []
  type: TYPE_NORMAL
- en: Race conditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programming with threads is not an easy mission when it comes to scheduling.
    The bug that occurs when many threads are racing to change the same data structure
    is named **race conditions**. In other words, it happens when two threats are
    trying to do the same job. To avoid race conditions, an atomic operation is needed.
    Thus, when an operation is started, it cannot be stopped or interrupted. Linux
    provides a solution named *Mutex*, which is the abbreviation of mutual exclusion
    object. Like its name indicates, mutexes are locks to prevent threads to perform
    simultaneously. The Dirty Cow (CVE-2016-5195) is a privilege escalation exploit
    found in Linux kernel based on race conditions. To download the exploit, you can
    check this GitHub repository at [https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs](https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot describes the steps for a C language exploit version
    for Dirty Cow (CVE-2016-5195):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00058.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Logical and hardware-related bugs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logical and hardware-related exploits are very dangerous. Imagine an attacker
    who can not only compromise the operating system, but also have full control on
    the hardware itself. It could be a disaster. Next, we will take a look at related
    hardware vulnerability that allows attackers to attack a Linux hardware infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Case study CVE-2016-4484 – Cryptsetup Initrd root Shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This exploit was presented in the Deepsec In-depth security conference 2016
    in Vienna. The talk was titled *Abusing LUKS to Hack the System*. During the session,
    the researcher showed a dangerous way to use a vulnerability in Cryptsetup to
    decrypt the host partition. This exploit gives you root access to the attacked
    machine, and the ability to do whatever with the disk. The vulnerability was caused
    by a mishandling of password check. Thus, when a user attempts to enter password
    more than three times, the system proceeds with the boot sequence normally:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00059.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Linux Exploit Suggester
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linux Exploit Suggester is a simple script developed by **PenturaLabs** to
    help penetration testers search for Linux vulnerabilities. Let''s download the
    tool from GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#git clone https://github.com/mzet-/linux-exploit-suggester`'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00060.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'The tool uses the `uname -r` command to collect information about the Linux
    OS release version and later give you a list of privilege escalation exploits
    for that specific release. If you already know the release version, you can enter
    it directly using the `-k` option, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00061.gif)'
  prefs: []
  type: TYPE_IMG
- en: And later, you can use a website such as [https://www.cvedetails.com ](https://www.cvedetails.com)to
    search for more information about founded vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00062.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Buffer overflow prevention techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many techniques implemented to avoid buffer overflow attacks. In the
    upcoming sections, we will cover some of the well-known mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: Address space layout randomization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Address space layout randomization** (**ASLR**) is a defense mechanism developed by
    the Pax Project against buffer overflow attacks. This memory-protection process
    randomizes the executable location when loaded in memory. Because, as we learned
    in the previous sections, if locations are predictable, then system exploitation
    will be easy. It started as a Linux patch in 2001, but later was integrated in
    many other operating systems. ASLR can be defeated using the following techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: Bruteforcing all the possible 256 addresses until the exploit works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating block of NOPs until we get a legitimate memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stack canaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stack canaries are used to detect buffer overflow attacks before they occur.
    Not to prevent them exactly, but they are implemented by compilers to make the
    exploitation more harder by using canaries in potentially vulnerable functions.
    The function prologue puts a value into the canary location and the epilogue checks
    to make sure that value is not altered.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00063.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Non-executable stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Non-executable stack** (**NX**) is a virtual memory protection mechanism
    to block shell code injection from executing on the stack by restricting a particular
    memory and implementing the NX bit. But this technique is not really worthy against
    return to lib attacks, although they do not need executable stacks.'
  prefs: []
  type: TYPE_NORMAL
- en: Linux return oriented programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Return oriented programming** (**ROP**) is a well-known technique to bypass
    most of the discussed protection mechanisms. It is done by finding what we call
    ROP gadgets (code snippets) and jump to them. In this technique, the attacker
    hijacks and manipulates program control flow and executes a chain of instructions
    that reside in memory to perform the attack. This is called ROP chaining.'
  prefs: []
  type: TYPE_NORMAL
- en: Linux hardening
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous sections, we discovered the required methods and tools to attack
    the Linux infrastructure. Now it is time to deploy safeguards and learn how to
    defend against these attacks and secure your infrastructure. To harden your Linux
    systems, you need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Update Linux kernel and applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid using insecure services such as FTP and telnet and use SFTP and OpenSSH
    instead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimize the attack surface by using only the needed applications and services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If possible, use SELinux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a strong password policy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep an eye on faillog records
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Harden `/etc/sysctl.conf`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use an authentication server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Center of Internet Security** (**CIS**) provides many hardening guides for
    a various number of operating systems including Linux. It is highly recommended
    to visit it: [https://www.cisecurity.org/](https://www.cisecurity.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00064.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, download the benchmark of your Linux distribution from this link [https://www.cisecurity.org/cis-benchmarks/](https://www.cisecurity.org/cis-benchmarks/).
    The following is the Debian hardening guide:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00065.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter concluded the different attack surfaces of Linux infrastructure,
    starting from the basic Linux commands, especially those necessary to perform
    system footprinting and enumeration. In later sections, we had the chance not
    only to learn the latest Linux exploitation techniques in addition to real-world
    study cases, but to also understand the theories and concepts behind every Linux
    security layer. We didn't stop there; as penetration testers, we had the opportunity
    to discover how to exploit the inner core of a Linux infrastructure. At the end
    of this chapter, we gained skills to operate and secure a Linux infrastructure
    from both an attacker and a defender's perspective. The next chapter will broaden
    your vision, giving you a clear understanding about how to penetrate large corporate
    networks and databases, from networking refresher terminologies to gaining the
    required skills to penetrate large-scale network companies.
  prefs: []
  type: TYPE_NORMAL
