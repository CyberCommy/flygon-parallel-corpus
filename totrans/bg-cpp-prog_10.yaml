- en: Diagnostics and Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software is complex; however, well you design your code, at some point you'll
    have to debug it, whether during the normal testing phases of developing your
    code, or when a bug report has been issued. It's prudent to design your code to
    make testing and debugging as straight forward as possible. This means adding
    tracing and reporting code, determining invariants and pre- and post-conditions,
    so that you have a starting point to test your code, and writing functions with
    understandable and meaningful error codes.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing your code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++ and C Standard Libraries have a wide range of functions that allow you
    to apply tracing and reporting functions so that you can test if code is handling
    data in expected ways. Much of these facilities use conditional compilation so
    that the reporting only occurs in debug builds, but if you provide the traces
    with meaningful messages they will form part of the documentation of your code.
    Before you can report on the behavior of your code, you first have to know what
    to expect from it.
  prefs: []
  type: TYPE_NORMAL
- en: Invariants and conditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Class invariants are conditions, the object state, that you know remain true.
    During a method call the object state will change, possibly to something that
    invalidates the object, but once a public method has completed, the object state
    must be left in a consistent state. There is no guarantee what order the user
    will call methods on a class, or even if they call methods at all, so an object
    must be usable whatever methods the user calls. The invariant aspects of an object
    applies on a method calls level: between method calls the object must be consistent
    and usable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, imagine you have a class that represents a date: it holds a day
    number between 1 and 31, a month number between 1 and 12, and a year number. The
    class invariant is that, whatever you do to objects of the date class, it will
    always hold a valid date. This means that users can safely use objects of your
    date class. It also means that other methods on the class (say, a method to determine
    how many days between two dates, `operator-`) can assume that the values in the
    date objects are valid, so those methods do not have to check the validity of
    the data they act upon.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, a valid date is more than the ranges 1 to 31 for days and 1 to 12
    for months, because not every month has 31 days. So, if you have a valid date,
    say 5 April 1997, and you call a `set_day` method to set the day number to 31,
    the class invariant condition has been violated since 31 April is not a valid
    date. If you want to change the values in a date object, the only safe way to
    do this is to change all the values: the day, month, and year--at the same time,
    because this is the only way to maintain the class invariance.'
  prefs: []
  type: TYPE_NORMAL
- en: One approach is to define a private method in debug builds that tests the invariant
    conditions for the class and ensures with asserts (see later) that the invariants
    are maintained. You can call such a method before a publicly-accessible method
    leaves to ensure that the object remains in a consistent state. Methods should
    also have defined pre- and post-conditions. Pre-conditions are conditions that
    you mandate are true before the method is called, and post-conditions are conditions
    that you guarantee are true after the method has completed. For the methods on
    a class, the class invariants are pre-conditions (because the state of the object
    should be consistent before the method is called) and the invariants are also
    a post-condition (because after the method has finished the object state should
    be consistent).
  prefs: []
  type: TYPE_NORMAL
- en: There are also pre-conditions that are the responsibility of the caller of a
    method. The pre-condition is a documented responsibility that the caller ensures.
    For example, the date class will have a pre-condition that day numbers are between
    1 and 31\. This simplifies the class code because methods that take a day number
    can assume that values passed are never out of range (although, because some months
    have fewer than 31 days, values may still not be valid). Again, in debug builds
    you can use asserts to check that such pre-conditions are true, and the tests
    in the assert will be compiled away in the release build. At the end of a method
    there will be post-conditions, that is, the class invariants will be maintained
    (and the state of the object will be valid), and the return value will be valid.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional compilation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As explained in [Chapter 1](318b7b93-7e5a-437b-95b3-9b6178ece82c.xhtml), *Starting
    with C++*, when your C++ program is compiled there is a pre-compilation step that
    collates all the file included in a C++ source file into a single file, which
    is then compiled. The pre-processor also expands macros and, depending on the
    value of symbols, includes some code and exclude others code.
  prefs: []
  type: TYPE_NORMAL
- en: In its simplest form, conditional compilation brackets code with `#ifdef` and
    `#endif` (and optionally using `#else`), so that the code between these directives
    is only compiled if the specified symbol has been defined.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You are guaranteed that only one of these lines will be compiled, and you are
    guaranteed that at least one of them will be compiled. If the symbol `TEST` is
    defined then the first line will be compiled and, as far as the compiler is concerned,
    the second line does not exist. If the symbol `TEST` is not defined, then the
    second line will be compiled. If you want to type these lines in the opposite
    order, you can use the `#ifndef` directive. The text provided through the conditional
    compilation can be C++ code, or it can be defined using other symbols in the current
    translation unit with `#define` or undefined existing symbols with `#undef`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `#ifdef` directive simply determines if the symbol exists: it does not
    test its value. The `#if` directive allows you to test an expression. You can
    set a symbol to have a value and compile specific code depending on the value.
    The expression must be integral, so a single `#if` block can test for several
    values using `#if` and multiple `#elif` directives and (at most) one `#else`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If the symbol is not defined then the `#if` directive treats the symbol as having
    a value of `0`; if you want to distinguish between these cases you can use the
    `defined` operator to test if a symbol is defined. At most, only one of the sections
    in the `#if`/`#endif` block will be compiled, and if a value is not matched then
    no code will be compiled. The expression can be a macro, in which case the macro
    will be expanded before the condition is tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three ways to define a symbol. The first way is out of your control:
    the compiler will define some symbols (typically with the `__` or `_` prefix)
    that give you information about the compiler and the compilation process. Some
    of these symbols will be described in a later section. The other two ways are
    entirely under your control--you can define symbols in a source file (or header
    file) using `#define` or you can define them on the command line using the `/D`
    switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This will compile the source code with the symbol `TEST` set to a value of `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will typically use conditional compilation to provide code that should
    not be used in production code, for example, extra tracing code to use in debug
    mode or when you are testing code. For example, imagine you have library code
    to return data from a database, but you suspect that the SQL statement in the
    library function is faulty and returning too many values. Here, you may decide
    to test, add code to log the number of values returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Trace messages like this pollute your user interface and you will want to avoid
    them in production code. However, in debugging they can be invaluable in determining
    where problems are occurring.
  prefs: []
  type: TYPE_NORMAL
- en: Any code that you call in debug mode, conditional code should be `const` methods
    (here `vector::size`), that is, they should not affect the state of any objects
    or the application data. You must ensure that the logic of your code is *exactly*
    the same in debug mode as in release mode.
  prefs: []
  type: TYPE_NORMAL
- en: Using pragmas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pragmas are compiler-specific and often are concerned with the technical details
    about the code sections in the object files. There are a couple of Visual C++
    pragmas that are useful in debugging code.
  prefs: []
  type: TYPE_NORMAL
- en: In general, you will want your code to compile with as few warnings as possible.
    The default warning for the Visual C++ compiler is `/W1`, which means that only
    the most severe warnings are listed. Increasing the value to 2, 3, or the highest
    value of 4 progressively increases the number of warnings that are given during
    a compilation. Using `/Wall` will give level-4 warnings and warnings that have
    been disabled by default. This last option, even for the simplest code, will produce
    a screen full of warnings. When you have hundreds of warnings useful error messages
    will be hidden between the reams of unimportant warnings. Since the C++ Standard
    Library is complex and uses some code that is decades old, there are some constructs
    that the compiler will warn you about. To prevent these warnings polluting the
    output from your builds, specific warnings in selective files have been disabled.
  prefs: []
  type: TYPE_NORMAL
- en: If you are supporting older library code, you may find that the code compiles
    with warnings. You may be tempted to reduce the warning levels using the compiler
    `/W` switch, but that will suppress all warnings higher than the ones you enable,
    and it applies equally to your code as to the library code that you may be including
    into your project. The `warning` pragma gives you a lot more flexibility. There
    are two ways to call this--you can reset the warning level to override the compiler
    `/W` switch and you can change the warning level of a particular warning or disable
    the warning reporting altogether.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, at the top of the `<iostream>` header is the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This says store the current warning level and, for the rest of this file (or
    until it is changed), make the warning level 3\. At the bottom of the file is
    the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This restores the warning level to that stored earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also change how one or more warnings are reported. For example, at
    the top of `<istream>` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The first part of this `pragma` is the specifier `disable`, which indicates
    that reporting of a warning type (in this case, 4189) is disabled. If you choose,
    you can change the warning level of a warning by using the warning level (`1`,
    `2`, `3`, or `4`) as the specifier. One use for this is to lower the warning level
    just for a piece of code that you are working on and then return it to its default
    level after the code. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This function shifts a char right by 8 bits, which will generate the level-1
    warning 4333 (*right shift by too large amount, data loss*). This is a problem
    and needs to be fixed, but for the time being, you want to compile the code without
    warnings from this code and so the warning level is changed to level 2\. Using
    the default warning level (`/W1`) the warning will not be shown. However, if you
    compile with a more sensitive warning level (for example, `/W2`) then this warning
    will be reported. This change in the warning level is only temporary because the
    last line resets the warning level back to its default (which is 1). In this case,
    the warning level is increased, meaning that you will only see it with a more
    sensitive warning level on the compiler. You can also reduce the warning level,
    which means that the warning is more likely to be reported. You can even change
    a warning level to `error` so the code will not compile while warnings of this
    type exist in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Adding informational messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you test and debug code you will inevitably come across places where you
    can see a potential problem but it has low priority compared to what you are working
    on. It is important to make a note of the issue so that you can address the problem
    at a later stage. In Visual C++, there are two ways to do this in a benign way
    and two ways that will generate an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first way is to add a `TODO:` comment, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The Visual Studio editor has a tool window called the **Task List**. This lists
    the comments in the project that start with one of the predetermined tasks (the
    defaults are `TODO`, `HACK`, and `UNDONE`).
  prefs: []
  type: TYPE_NORMAL
- en: If the Task List window is not visible, enable it via the View menu. The default
    setting in Visual Studio 2015 is to enable tasks in C++. This is not the case
    for earlier versions, but it can be enabled through the Tools menu, Options dialog
    and then Text Editor, C/C++, Formatting, View by setting Enumerate Comment Tasks
    to Yes. The list of task labels can be found on the Options dialog under the Environment,
    Task List item.
  prefs: []
  type: TYPE_NORMAL
- en: The Task List lists the tasks with the file and line number, and you can open
    the file and locate the comment by double-clicking on an entry.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second way to identify code that needs attention is the `message` pragma.
    As the name suggests, this simply allows you to place an informational message
    in your code. When the compiler comes across this pragma it simply puts the message
    on the output stream. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `test.cpp` file is compiled with this code and `/W1` (the default) warning
    level, the output will be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the string is printed just as the compiler sees it, and there
    is no indication of the file or line number in contrast to the warning message.
    There are ways to address this using compiler symbols.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the condition is important, you''ll want to issue an error and one way to
    do this is with the `#error` directive. When the compiler reaches this directive,
    it will issue an error. This is a serious action, so you will only use it when
    there is another option. You''ll most likely want to use it with a conditional
    compilation. A typical use is for code that can only be compiled with a C++ compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If you compile a file with this code using the `/Tc` switch to compile code
    as C then the `__cplusplus` preprocessor symbol will not be defined and an error
    will be generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++11 adds a new directive called `static_assert`. This is called like a function
    (and *calls* are terminated with a semicolon), but it is not a function because
    it is only used at compile time. Further, the directive can be used in places
    where function calls are not used. The directive has two parameters: an expression
    and a string literal. If the expression is `false` then the string literal will
    be outputted at compile time with the source file and line number and an error
    will be generated. At the simplest level, you could use this to issue a message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the first parameter is `false`, the directive will issue the error message
    during compilation. The same thing could be achieved with the `#error` directive.
    The `<type_traits>` library has various predicates for testing the properties
    of types. For example, the `is_class` template class has a simple template parameter
    that is a type, and if the type is a `class` then the `static` member `value`
    is set to `true`. If you have a templated function that should only be instantiated
    for classes, you could add this `static_assert`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'At compile time, the compiler will attempt to instantiate the function and
    instantiate `is_class` on that type using `value` to determine if the compilation
    should continue. For example, the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line will compile correctly because the compiler will instantiate
    a function, `func<string>,` and the parameter is a `class`. However, the second
    line will not compile because the function instantiated is `func<const char*>`
    and `const char*` is not a `class`. The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `static_assert` is on *line 25*, and hence this generates the error that
    `T must be a class`. *Line 39* is the first call to `func<const char*>` and gives
    context to the error.
  prefs: []
  type: TYPE_NORMAL
- en: Compiler switches for debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To allow you to single-step through a program with a debugger, you have to provide
    information to allow the debugger to associate machine code with source code.
    At the very least, this means switching off all optimizations, since in an attempt
    to optimize code the C++ compiler will rearrange code. Optimizations are switched
    off by default (so the using the `/Od` switch is redundant), but clearly, to be
    able to debug a process and single-step through C++ code you need to remove all
    the `/O` optimization switches.
  prefs: []
  type: TYPE_NORMAL
- en: Since the C++ Standard Library uses the C Runtime, you will need to compile
    your code to use the latter's debug builds. The switch you use depends on whether
    you are building a process or **Dynamic Link Library** (**DLL**), and whether
    you will statically link the C runtime or access it through a DLL. If you are
    compiling a process, you use `/MDd` to get the debug version of the C runtime
    in a DLL, and if you use `/MTd` you will get the debug version of the static linked
    C runtime. If you are writing a dynamic linked library, you have to use `/LDd`
    in addition to one of the C runtime switches (`/MTd` is the default). These switches
    will define a pre-processor symbol called `_DEBUG`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A debugger will need to know debugger symbolic information--the names and types
    of variables and the names of functions and line numbers associated with code.
    The accepted way to do this is through a file called a **program database**, with
    an extension of `pdb`. You use one of the `/Z` switches to generate a `pdb` file:
    the `/Zi` or `/ZI` switch will create two files, one with a name starting with
    `VC` (for example `VC140.pdb`) that contains the debugging information for all
    of the `obj` files, and a file with the name of the project that contains debugging
    for the process. If you compile without linking (`/c`) then only the first file
    is created. The Visual C++ project wizard will use `/Od /MDd /ZI` by default for
    debug builds. The `/ZI` switch means that a program database is created in a format
    that allows the Visual C++ debugger to perform `Edit` and `Continue`, that is,
    you can change some code and continue to single-step through the code without
    recompiling. When you compile for a release build, the wizard will use the `/O2
    /MD /Zi` switches, which means that the code is optimized for speed but a program
    database (without `Edit` and `Continue` support) will still be created. The code
    does not need the program database to run (in fact, you should not distribute
    it with your code), but it is useful if you have a crash report and need to run
    the release build code under the debugger.'
  prefs: []
  type: TYPE_NORMAL
- en: These `/Z` compiler switches assume the linker is run with the `/debug` switch
    (and if the compiler invokes the linker it will pass this switch). The linker
    will create the project program database from the debug information in the `VC`
    program database file.
  prefs: []
  type: TYPE_NORMAL
- en: This raises the question of why a release build file will need a program database.
    If you run a program under the debugger and look at the call stack, you will often
    see a long list of stack frames in operating system files. These usually have
    fairly meaningless names made up of the DLL name and some numbers and characters.
    It is possible to install the symbols (the `pdb` files) for Windows or, if they
    are not installed, instruct the Visual C++ debugger to download the symbols for
    a library being used from a computer on the network called a **symbol server**.
    These symbols are not the source code for the library, but they do give you the
    names of the functions and the types of the parameters, which gives you additional
    information about the state of the call stack at the point where you are single
    stepping.
  prefs: []
  type: TYPE_NORMAL
- en: Pre-processor symbols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get access to the tracing, asserts, and reporting facilities in your code,
    you have to enable the debugging runtime library, and this is done by using the
    `/MDd`, `/MTd`, or `/LDd` compiler switches, which will define the `_DEBUG` pre-processor
    symbol. The `_DEBUG` pre-processor symbol enables a lot of facilities, and conversely,
    not defining this symbol will help in optimizing your code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The C++ compiler will also provide information through some standard pre-processor
    symbols. Most of these are useful only for library writers, but there are some
    that you may want to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ANSI standard says that the `__cplusplus` symbol should be defined when
    the compiler is compiling code as C++ (rather than C), and it also specifies that
    the `__FILE__` symbol should contain the name of the file and that `__LINE__`
    symbol will have the line number at the point where you access it. The `__func__`
    symbol will have the current function name. This means that you can create tracing
    code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If this code is compiled for debugging (for example, `/MTd`) then the `cout`
    line will be put inline whenever `TRACE` is used; if the code is not compiled
    for debugging then `TRACE` will do nothing. The `__func__` symbol is simply the
    function name, it is not qualified, so if you use it in a class method it will
    provide no information about the class.
  prefs: []
  type: TYPE_NORMAL
- en: Visual C++ also defines Microsoft-specific symbols. The `__FUNCSIG__` symbol
    gives the complete signature including the class name (and any `namespace` names),
    the return type, and parameters. If you just want the fully qualified name, then
    you can use the `__FUNCTION__` symbol. A symbol that you will see frequently in
    the Windows header files is `_MSC_VER`. This has a number that is the version
    of the current C++ compiler, and it is used with a conditional compilation so
    that newer language features are only compiled with a compiler that supports them.
  prefs: []
  type: TYPE_NORMAL
- en: The Visual C++ project pages define *build macros* with names like `$(ProjectDir)`
    and `$(Configuration)`. These are used only by the MSBuild tool so they are not
    automatically available in a source file during compilation, however, if you set
    a pre-processor symbol to the value of a build macro, the value will be available
    through that symbol at compile time. The system environment variables are also
    available as build macros, so it is possible to use them to influence the build.
    For example, on Windows the system environment variable `USERNAME` has the name
    of the current logged on user so you could use it to set a symbol and then access
    that at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Visual C++ project pages, you can add a **Preprocessor Definition**
    on the C/C++ preprocessor project page called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in your code, you could add a line using this symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using a make file, or just invoking `cl` from the command line,
    you can add a switch to define the symbol like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Escaping the double quotes here is important because without them the quotes
    are eaten by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier, you saw how the `#pragma message` and `#error` directives can be used
    to put messages into the output stream of the compiler. When you compile code
    in Visual Studio the compiler and linker outputs will appear in the output window.
    If the message is in the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: where `path_to_source_file` is the full path to the file, `line` is the line
    number where the `message` appears. Then, when you double click on this line in
    the output window, the file will be loaded (if not already) and the insertion
    point placed on the line.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `__FILE__` and `__LINE__` symbols provide you with the information that
    you need to make `#pragma message` and `#error` directives more useful. Outputting
    `__FILE__` is simple because it is a string and C++ will concatenate string literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The macro is called as part of the pragma to format the message correctly;
    however, you cannot call the pragma from a macro because the `#` has a special
    purpose (that will be of use in a moment). The result of this code will be something
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Outputting `__LINE__` via a macro requires a bit more work because it holds
    a number. This issue is a common one in C, so there is a standard solution using
    two macros and the stringing operator, `#`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `STRING` macro is used to expand the `__LINE__` symbol to a number and the
    `STRING2` macro to stringify the number. The `AT_FILE` macro formats the entire
    string in the correct format.
  prefs: []
  type: TYPE_NORMAL
- en: Producing diagnostic messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The effective use of diagnostic messages is a broad topic, so this section will
    just give you the basics. When you design your code, you should make it easy to
    write diagnostic messages, for example, providing mechanisms to dump the contents
    of an object and providing access to the code that tests for class invariants
    and pre- and post-conditions. You should also analyze the code to make sure that
    appropriate messages are logged. For example, issuing a diagnostic message in
    a loop will often fill up your log files, making it difficult to read the other
    messages in the log file. However, the fact that something is consistently failing
    in a loop may in itself be an important diagnostic, as may be the number of attempts
    to carry out a failing act, so you may want to record that.
  prefs: []
  type: TYPE_NORMAL
- en: Using `cout` for diagnostic messages has the advantage of integrating these
    messages with your user output, so that you can see the final effects of the intermediate
    results. The disadvantage is that the diagnostic messages are integrated with
    the user output, and since there are usually a large number of diagnostic messages,
    these will completely swamp the user output of your program.
  prefs: []
  type: TYPE_NORMAL
- en: C++ has two stream objects that you can use instead of `cout`. The `clog` and
    `cerr` stream objects will write character data to the standard error stream (the
    C stream pointer `stderr`), which will usually show on the console as if you are
    using `cout` (which outputs to the standard output stream, the C stream pointer
    `stdout`), but you can redirect it elsewhere. The difference between `clog` and
    `cerr` is that `clog` uses buffered output, which is potentially better-performing
    than the unbuffered `cerr`. However, there is the danger that the data may be
    lost if the application stops unexpectedly without flushing the buffer.
  prefs: []
  type: TYPE_NORMAL
- en: Since the `clog` and `cerr` stream objects are available in release builds as
    well as debug builds, you should use them only for messages that you are happy
    that your end user will see. This makes them inappropriate for trace messages
    (which will be covered shortly). Instead, you should use them for diagnostic messages
    that the user will be in a position to address (perhaps a file cannot be found
    or the process does not have the security access to perform an action).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This code opens a file in two steps (rather than using the constructor) and
    the `open` method will return `false` if the file cannot be opened. The code checks
    to see if opening the file was successful, and if it fails, it will tell the user
    via the `clog` object and then return from whatever function contains the code,
    as the `file` object is now invalid and cannot be used. The `clog` object is buffered
    but in this case we want to inform the user immediately, and this is performed
    by the `endl` manipulator, which inserts a newline in the stream and then flushes
    the stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the `clog` and `cerr` stream objects will output to the standard
    error stream and this means that for a console application you can separate out
    the output stream and error stream by redirecting the streams. On the command-line,
    the standard streams can be redirected by using a value of 0 for `stdin`, 1 for
    `stdout,` and 2 for `stderr` and the redirection operator `>`. For example, an
    application `app.exe` could have this code in the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cerr` object is not buffered so whether you use `n` or `endl` for a newline
    is irrelevant. When you run this on the command line, you''ll see something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To redirect a stream to a file, redirect the stream handle (1 for `stdout`,
    2 for `stderr`) to the file; the console will open the file and write the stream
    to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As the last chapter showed, C++ stream objects are layered so that calls to
    insert data into a stream will write the data to the underlying stream object,
    depending on the type of stream, with or without buffering. This stream buffer
    object is obtained, and replaced, using the `rdbuf` method. If you want the `clog`
    object redirected to a file by the application, you can write code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this code the application code will be in the `run_code` function, and the
    rest of the code sets up the `clog` object to redirect to files.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the file is explicitly closed when the `run_code` function returns
    (the application has finished); this is not entirely necessarily because the `ofstream`
    destructor will close the file, and in this case this will happen when the `main`
    function returns. The last line is important. The standard stream objects are
    created before the `main` function is called, and they will be destroyed sometime
    after the `main` function returns, that is, well after the file objects have been
    destroyed. To prevent the `clog` object accessing the destroyed file object, the
    `rdbuf` method is called passing `nullptr` to indicate that there is no buffer.
  prefs: []
  type: TYPE_NORMAL
- en: Trace messages with the C runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often you will want to test your code by running the application in real time
    and output the *trace messages* to test that your algorithms work. Sometimes you
    will want to test the order that functions are called (for example, that correct
    branching occurs in a `switch` statement or in an `if` statement), and in other
    cases you'll want to test intermediate values to see that the input data is correct
    and the calculations on that data are correct.
  prefs: []
  type: TYPE_NORMAL
- en: Trace messages can produce a lot of data, so it is unwise to send these to the
    console. It is extremely important that trace messages are only produced in debug
    builds. If you leave trace messages in product code, it could seriously impact
    the performance of your application (as will be explained later). Further, trace
    messages are unlikely to be localized, nor will they be checked to see if they
    contain information that could be used to reverse-engineer your algorithms. One
    final issue with trace messages in release builds is that your client will think
    that you are providing them with code that has not been completely tested. It
    is important, then, that trace messages are only generated in debug builds, when
    the `_DEBUG` symbol is defined.
  prefs: []
  type: TYPE_NORMAL
- en: The C Runtime provides a series of macros with names starting with `_RPT` that
    can be used to trace messages when `_DEBUG` is defined. There are `char` and wide
    char versions of these macros, and there are versions that will report just the
    trace messages and others that will report the message and the location (source
    file and line number) of the message. Ultimately these macros will call a function
    called `_CrtDbgReport` that will generate the message with the settings that have
    been determined elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `_RPTn` macros (where `n` is `0`, `1`, `2`, `3`, `4`, or `5`) will take
    a format string and 0 to 5 parameters that will be put into the string before
    being reported. The first parameter of the macros indicates the type of message
    to report: `_CRT_WARN`, `_CRT_ERROR`, or `_CRT_ASSERT`. The last two of these
    categories are the same and refer to asserts, which will be covered in a later
    section. The second parameter of the report macros is a format string, which will
    then be followed by the required number of parameters. The `_RPTFn` macros are
    the same format but will report the source file and line number as well as the
    formatted message.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The default action is that `_CRT_WARN` messages will produce no output and
    the `_CRT_ERROR` and `_CRT_ASSERT` messages will generate a popup window to allow
    you to abort or debug the application. You can change the response to any of these
    message categories by calling the `_CrtSetReportMode` function and providing the
    category and a value indicating the action to take. If you use `_CRTDBG_MODE_DEBUG`
    then the message will be written to the debugger output window. If you use `_CRTDBG_MODE_FILE`
    then the message will be written to a file that you can open and pass the handle
    to the `_CrtSetReportFile` function. (You can also use `_CRTDBG_FILE_STDERR` or
    `_CRTDBG_FILE_STDOUT` as the file handle to send the message to the standard output
    or the error output.) If you use `_CRTDBG_MODE_WNDW` as the report mode then the
    message will be displayed using the Abort/Retry/Ignore dialog box. Since this
    will pause the current thread of execution, it should only be used for assert
    messages (the default action):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: If you do not provide the `n` in the messages then the next message will be
    appended to the end of your message, and in most cases this is not what you want
    (although you could justify this for a series of calls to the `_RPTn` macros,
    where the last one is terminated with `n`).
  prefs: []
  type: TYPE_NORMAL
- en: The Visual Studio output window is shown when you compile a project (to show
    it at debug time select the Output option in the View menu), and at the top is
    a combo box labelled Show output from, which will be usually set to Build. If
    you set this to Debug then you will see the debugging messages generated during
    a debugging session. These will include messages about loading debugging symbols
    and messages redirected from the `_RPTn` macros to the output window.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you prefer the messages to be directed to a file then you need to open the
    file with the Win32 `CreateFile` function and use the handle from that function
    in a call to the `_CrtSetReportFile` function. To do this, you will need to include
    the Windows header files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `WIN32_LEAN_AND_MEAN` macro will reduce the size of the Windows files included.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This code will direct the warning messages to the text file `log.txt` which
    will be created new every time the application is run.
  prefs: []
  type: TYPE_NORMAL
- en: Tracing messages with Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `OutputDebugString` function is used to send messages to a debugger. The
    function does this through a *shared memory section* called `DBWIN_BUFFER`. Shared
    memory means that any process can access this memory, and so Windows provides
    two *event objects* called `DBWIN_BUFFER_READY` and `DBWIN_DATA_READY` that control
    read and write access to this memory. These event objects are shared between processes
    and can be in a signalled or unsignalled state. A debugger will indicate that
    it is no longer using the shared memory by signalling the `DBWIN_BUFFER_READY`
    event, at which point the `OutputDebugString` function can write the data to the
    shared memory. The debugger will wait on the `DBWIN_DATA_READY` event, which will
    be signalled by the `OutputDebugString` function when it has finished writing
    to the memory and it is safe to read the buffer. The data written to the memory
    section will be the process ID of the process that called the `OutputDebugString`
    function, followed by a string of up to 4 KB of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is that when you call the `OutputDebugString` function it will
    wait on the `DBWIN_BUFFER_READY` event, which means that when you use this function
    you are coupling the performance of your application to the performance of another
    process, which is usually a debugger (but may not be). It is very easy to write
    a process to access the `DBWIN_BUFFER` shared memory section and get access to
    the associated event objects, so it may be possible that your production code
    will run on a machine where someone has such an application running. For this
    reason, it is vitally important that you use conditional compilation so that the
    `OutputDebugString` function is only used in debug builds--code that will never
    be released to your customers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You will need to include the `windows.h` header file to compile this code. As
    for the `_RPT` example, you will have to run this code under a debugger to see
    the output, or have an application like **DebugView** (available from Microsoft's
    Technet website) running.
  prefs: []
  type: TYPE_NORMAL
- en: Windows provides the `DBWinMutex` mutex object to act as an overall *key* to
    accessing this shared memory and event objects. As the name suggests, when you
    have a handle to a mutex you will have mutually exclusive access to the resource.
    The problem is that processes do not have to have a handle to this mutex to use
    these resources and consequently you have no guarantee that, if your application
    thinks it has exclusive access that it will really have exclusive access.
  prefs: []
  type: TYPE_NORMAL
- en: Using asserts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An assert checks that a condition is true. The assertion means just that: the
    program should not continue if the condition is not true. Clearly asserts should
    not be called in release code and hence conditional compilation must be used.
    Asserts should be used to check for conditions that should never happen: never
    events. Since the conditions do not happen there should be no need for asserts
    in release builds.'
  prefs: []
  type: TYPE_NORMAL
- en: The C Runtime provides the `assert` macro that is available through the `<cassert>`
    header file. The macro, and any functions called in the expression passed as its
    only parameter, will be called unless the `NDEBUG` symbol is defined. That is,
    you do not have to define the `_DEBUG` symbol to use asserts and you should have
    taken extra action to explicitly prevent `assert` from being called.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth re-iterating this. The `assert` macro is defined even if `_DEBUG`
    is not defined, so an assert could be called in release code. To prevent this
    from happening you must define the `NDEBUG` symbol in a release build. Conversely,
    you can define the `NDEBUG` symbol in a debug build so that you can use tracing
    but do not have to use asserting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, you will use asserts in debug builds to check that pre- and post-conditions
    are met in a function and that class invariant conditions are fulfilled. For example,
    you may have a binary buffer that has a special value at the tenth byte position
    and so have written a function to extract that byte:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, the calls to `assert` are used to check that the pointer is not `nullptr`
    and that the buffer is big enough. If these asserts are true, then it means that
    it is safe to access the tenth byte through the pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Although it is not strictly necessary in this code, the assertion expressions
    are given in parentheses. It is good to get into the habit of doing this because
    `assert` is a macro and so a comma in the expression will be treated as a macro
    parameter separator; the parentheses protected against this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the `assert` macro will be defined in release builds by default, you
    will have to disable them by defining `NDEBUG` on the compiler command line, in
    your make file, or you may want to use conditional compilation explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: If an assert is called and it fails, then an assert message is printed at the
    console along with source file and line number information and then the process
    is terminated with a call to `abort`. If the process is built with release build
    standard libraries then the process `abort` is straightforward, however, if the
    debug builds are used then the user will see the standard Abort/Retry/Ignore message
    box where the Abort and Ignore options abort the process. The Retry option will
    use **Just-in-Time** (**JIT**) debugging to attach the registered debugger to
    the process.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, the `_ASSERT` and `_ASSERTE` macros are only defined when `_DEBUG`
    is defined, so these macros will not be available in release builds. Both macros
    take an expression and generate an assert message when the expression is `false`.
    The message for the `_ASSERT` macro will include the source file and line number
    and a message stating that the assertion failed. The message for the `_ASSERTE`
    macro is similar but includes the expression that failed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This code sets the reporting mode so that the failed assert will be a message
    printed on the console (rather than the default, which is the Abort/Retry/Ignore
    dialog). Since the variable is clearly less than 100, the assert will fail and
    so the process will terminate and the following message will be printed on the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The Abort/Retry/Ignore dialog gives the person, testing the application, the
    option of attaching the debugger to the process. If you decide that the failure
    of the assertion is heinous you can force the debugger to attach to the process
    by calling `_CrtDbgBreak`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You do not need to use conditional compilation because in release builds the
    `_CrtDbgBreak` function is a no-operation. In a debug build, this code will trigger
    JIT debugging, which gives you the option to close the application or launch the
    debugger, and if you choose the latter, the registered JIT debugger will be started.
  prefs: []
  type: TYPE_NORMAL
- en: Application termination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `main` function is the entry point for your application. However, this isn't
    called directly by the operating system because C++ will perform initialization
    before `main` is called. This includes constructing the Standard Library global
    objects (`cin`, `cout`, `cerr`, `clog,` and the wide character versions) and there
    is a whole host of initialization that is performed for the C Runtime Library
    that underpins C++ libraries. Further, there are the global and static objects
    that your code creates. When the `main` function returns, the destructors of global
    and static objects will have to be called and a clean-up performed on the C runtime.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to stop a process deliberately. The simplest is to return
    from the `main` function, but this assumes that there is a simple route back to
    the `main` function from the point that your code wants to finish the process.
    Of course, process termination must be ordered and you should avoid writing code
    where it is normal to stop the process anywhere in the code. However, if you have
    a situation where data is corrupted and unrecoverable and any other action could
    damage more data, you may have no option other than to terminate the application.
  prefs: []
  type: TYPE_NORMAL
- en: The `<cstdlib>` header file provides access to the header files to the functions
    that allow you to terminate and to handle the termination of an application. When
    a C++ program closes down normally, the C++ infrastructure will call the destructors
    of the objects created in the `main` function (in the reverse order to their construction)
    and the destructors of `static` objects (which may have been created in functions
    other than the `main` function). The `atexit` function allows you to register
    functions (that have no parameters and no return value) that will be called after
    the `main` function completes and `static` object destructors have been called.
    You can register more than one function by calling this function several times,
    and at termination the functions will be called in reverse order to their registering.
    After the functions registered with the `atexit` function have been called, the
    destructors of any global objects will be called.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a Microsoft function called `_onexit` that also allows you to
    register functions to be called during normal termination.
  prefs: []
  type: TYPE_NORMAL
- en: The `exit` and `_exit` functions perform a normal exit of a process, that is,
    they clean up the C runtime and flush any open files before shutting down the
    process. The `exit` function does additional work by calling any registered termination
    functions; the `_exit` function does not call these termination functions and
    so is a quick exit. These functions will not call the destructors of temporary
    or automatic objects, so if you use stack objects to manage resources, you will
    have to explicitly call the destructor code before calling `exit`. However, the
    destructors of static and global objects will be called.
  prefs: []
  type: TYPE_NORMAL
- en: The `quick_exit` function causes normal shutdown, but it does not call any destructors
    nor flush any streams, so there is no resource clean up. The functions registered
    with `atexit` are not called, but you can register that termination functions
    are called by registering them with the `at_quick_exit` function. After calling
    these termination functions, the `quick_exit` function calls the `_Exit` function
    that shuts down the process.
  prefs: []
  type: TYPE_NORMAL
- en: You can also call the `terminate` function to close down a process with no clean
    up. This process will call a function that has been registered with the `set_terminate`
    function and then calls the `abort` function. If an exception occurs in the program
    and is not caught--and hence propagates to the `main` function - the C++ infrastructure
    will call the `terminate` function. The `abort` function is the most severe of
    mechanisms that terminate a process. This function will exit the process without
    calling the destructors of objects or performing any other clean up. The function
    raises the `SIGABORT` signal and so it is possible to register a function with
    the `signal` function, which will be called before the process terminates.
  prefs: []
  type: TYPE_NORMAL
- en: Error values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some functions are designed to perform an action and return a value based on
    that action, for example, `sqrt` will return the square root of a number. Other
    functions perform more complex operations and use the return value to indicate
    whether the function was successful. There is no common convention about such
    error values, so if a function returns a simple integer there is no guarantee
    that the values one library uses have the same meaning as values returned from
    functions in another library. This means that you have to examine carefully the
    documentation for any library code that you use.
  prefs: []
  type: TYPE_NORMAL
- en: Windows does provide common error values, which can be found in the `winerror.h`
    header file, and the functions in the Windows **Software Development Kit** (**SDK**)
    only return values in this file. If you write library code that will be used exclusively
    in Windows applications, consider using the error values in this file because
    you can use the Win32 `FormatMessage` function to obtain a description of the
    error, as explained in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The C Runtime Library provides a global variable called `errno` (in fact it
    is a macro that you can treat as a variable). C functions will return a value
    to indicate that they have failed and you access the `errno` value to determine
    what the error was. The `<errno.h>` header file defines the standard POSIX error
    values. The `errno` variable does not indicate success, it only indicates errors,
    so you should only access it when a function has indicated that there is an error.
    The `strerror` function will return a C string with a description of the error
    value that you pass as a parameter; these messages are localized according to
    the current C locale set through a call to the `setlocale` function.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining message descriptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To obtain the description at runtime for a Win32 error code you use the Win32
    `FormatMessage` function. This will get the description for a system message or
    for a custom message (described in the next section). If you want to use a custom
    message you have to load the executable (or DLL) that has the message resource
    bound to it and pass the `HMODULE` handle to the `FormatMessage` function. If
    you want to get the description of a system message you do not need to load a
    module because Windows will do this for you. For example, if you call the Win32
    `CreateFile` function to open a file and the file cannot be found, the function
    will return a value of `INVALID_HANDLE_VALUE,` indicating that there is an error.
    To get details of the error you call the `GetLastError` function (which returns
    a 32-bit unsigned value sometimes called `DWORD` or `HRESULT`). You can then pass
    the error value to `FormatMessage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This code tries to open a file that does not exist and obtains the error value
    associated with the failure (this will be a value of `ERROR_FILE_NOT_FOUND`).
    The code then calls the `FormatMessage` function to get the string describing
    the error. The first parameter of the function is a flag that indicates how the
    function should work; in this case, the `FORMAT_MESSAGE_FROM_SYSTEM` flag says
    that the error is a system error and the `FORMAT_MESSAGE_ALLOCATE_BUFFER` flag
    says that the function should allocate a buffer large enough to hold the string
    using the Win32 `LocalAlloc` function.
  prefs: []
  type: TYPE_NORMAL
- en: If the error is a custom value that you have defined then you should use the
    `FORMAT_MESSAGE_FROM_HMODULE` flag, open the file with `LoadLibrary` and use the
    resulting `HMODULE` as the parameter passed in through the second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third parameter is the error message number (from `GetLastError`) and the
    fourth is a `LANGID` that indicates the language ID to use (in this case `LANG_USER_DEFAULT`
    to get the language ID for the current logged on user). The `FormatMessage` function
    will generate a formatted for the error value, and this string may have replacement
    parameters. The formatted string is returned in a buffer and you have two options:
    you can allocate a character buffer and pass the pointer in as the fifth and the
    length as the sixth parameter, or you can request the function to allocate a buffer
    using the `LocalAlloc` function as in this example. To get access to a function
    allocated buffer you pass the *address* of a pointer variable via the fifth parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the fifth parameter is used to either take a pointer to a user allocated
    buffer, or returns the address of system allocated buffer, and this is why in
    this case the pointer to pointer has to be cast.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some format strings may have parameters, and if so, the values are passed in
    through an array in the seventh parameter (in this case, no array is passed).
    The result of the preceding code is the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Using the message compiler, resource files, and the `FormatMessage`, you can
    provide a mechanism to return error values from your functions and then convert
    these to localized strings according to the current locale.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Message Compiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous example showed that you can obtain localized strings for Win32
    errors, but that you can also create your own errors and provide localized strings
    that are bound as resources to your process or library. If you intend to report
    errors to the end user, you have to make sure that the descriptions are localized.
    Windows provides a tool called the Message Compiler (`mc.exe`) that will take
    a text file with entries for messages in various languages and compile them into
    binary resources that can be bound to a module.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This defines three localized strings for the same message. The messages here
    are simple strings, but you can define format messages with placeholders that
    can be provided at runtime. The *neutral* language is US English, and in addition
    we define strings for British English, and French. The names used for the languages
    are defined in the `LanguageNames` lines at the top of the file. These entries
    have the name that will be used later in the file, the code page for the language,
    and the name of the binary resource that will contain the message resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MessageId` is the identifier that will be used by the `FormatMessage`
    function, and the `SymbolicName` is a pre-processor symbol that will be defined
    in a header file, so that you can use this message in your C++ code rather than
    the number. This file is compiled by passing it to the command line utility `mc.exe`,
    which will create five files: a header file with the definition of the symbol,
    three binary sources (`MSG00001.bin`, which is created by default for the neutral
    language, and `MSG00409.bin` and `MSG0040C.bin,` which are created because of
    the `LanguageNames` lines), and a resource compiler file. For this example, the
    resource compiler file (with extension `.rc`) will contain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This is a standard resource file that can be compiled by the Windows SDK resource
    compiler (`rc.exe`), which will compile the message resources into a `.res` file
    that can be bound to an executable or DLL. A process or DLL that has a resource
    of type `11` bound to it can be used by the `FormatMessage` function as a source
    of descriptive error strings.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, you will not use a message ID of 1 because it is unlikely to be unique
    and you are likely to want to take advantage of the *facility code* and *severity
    code* (for details of facility code, look in the `winerror.h` header file). Further,
    to indicate that the message is not Windows you can set the customer bit of the
    error code using the `/c` switch when you run `mc.exe`. This will mean that your
    error code will not be a simple value like 1, but this should not matter because
    your code will use the symbol defined in the header file.
  prefs: []
  type: TYPE_NORMAL
- en: C++ exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, exceptions are for exceptional conditions. They are not
    normal conditions. They are not conditions that you want to occur but they are
    conditions that may happen. Any exceptional condition will often mean that your
    data will be in an inconsistent state, so using exceptions means that you need
    to think in transactional terms, that is, an operation either succeeds, or the
    state of an object should remain the same as it was before the operation was attempted.
    When an exception occurs in a code block, everything that happened in the code
    block will be invalid. If the code block is part of a wider code block (say, a
    function that is a series of function calls by another function) then the work
    in that other code block will be invalid. This means that the exception may propagate
    out to other code blocks further up the call stack, invalidating the objects that
    depend on the operation being successful. At some point, the exceptional condition
    will be recoverable, so you will want to prevent the exception going further.
  prefs: []
  type: TYPE_NORMAL
- en: Exception specifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exception specifications are deprecated in C++11 but you may see them in earlier
    code. A specification is through the `throw` expression applied to a function
    declaration giving the exceptions that can be thrown from the function. The `throw`
    specification can be an ellipsis, which means that the function can throw exceptions
    but the type is not specified. If the specification is empty then it means the
    function won't throw exceptions, and this is the same as using the `noexcept`
    specifier in C++11.
  prefs: []
  type: TYPE_NORMAL
- en: The `noexcept` specifier tells the compiler that exception handling is not required,
    so if an exception does occur in the function the exception will not be bubbled
    out of the function and the `terminate` function will be called immediately. In
    this situation, there is no guarantee that the destructors of the automatic objects
    are called.
  prefs: []
  type: TYPE_NORMAL
- en: C++ exception syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In C++, an exceptional situation is generated by throwing an exception object.
    That exception object can be anything you like: an object, a pointer, or a built-in
    type, but because exceptions may be handled by code written by other people it
    is best to standardize the objects that are used to represent exceptions. For
    this, the Standard Library provides the `exception` class, which can be used as
    a base class.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This code tests the parameter and if it is zero then it throws an exception.
    Four examples are given and all are valid C++, but only the last version is acceptable
    because it uses a Standard Library class (or one derived from the Standard Library
    classes) and it follows the convention that exceptions are thrown by value.
  prefs: []
  type: TYPE_NORMAL
- en: When an exception is thrown, the exception handling infrastructure takes over.
    Execution will stop in the current code block and the exception will be propagated
    up the call stack. As the exception propagates through a code block, all the automatic
    objects will be destroyed, but objects created on the heap in the code black will
    not be destroyed. This is a process called **stack unwinding,** whereby each stack
    frame is cleaned up as much as possible before the exception moves to the stack
    frame above it in the call stack. If the exception is not caught, it will propagate
    up to the `main` function, at which point the `terminate` function will be called
    to handle the exception (and hence it will terminate the process).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can protect code to handle propagated exceptions. Code is protected with
    a `try` block and it is caught with an associated `catch` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Unlike other code blocks in C++, braces are mandatory even if the `try` and
    `catch` blocks contain single lines of code. In the preceding code the second
    call to the `reciprocal` function will throw an exception. The exception will
    halt the execution of any more code in the block, so the third call to the `reciprocal`
    function will not occur. Instead, the exception propagates out of the code block.
    The `try` block is the scope of the objects defined between the braces, and this
    means that the destructors of these objects will be called (`s` and `v`). Control
    is then passed to the associated `catch` blocks, and in this case, there is just
    one handler. The `catch` block is a separate block to the `try` block, so you
    cannot access any variables defined in the `try` block. This makes sense because
    when an exception is generated the entire code block is *tainted* so you cannot
    trust any object created in that block. This code uses the accepted convention,
    that is, exceptions are caught by reference, so that the actual exception object,
    and not a copy, is caught.
  prefs: []
  type: TYPE_NORMAL
- en: 'The convention is: throw my value, catch-by-reference.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Standard Library provides a function called `uncaught_exception`, which
    returns `true` if an exception has been thrown but not yet handled. It may seem
    odd to be able to test for this since no code other than the exception infrastructure
    will be called when an exception has occurred (for example the `catch` handlers)
    and you should put exception code there. However, there *is* other code that is
    called when an exception is thrown: the destructors of automatic objects that
    are destroyed during the stack clear up. The `uncaught_exception` function should
    be used in a destructor to determine if the object is being destroyed due to an
    exception rather than normal object destruction due to an object going out of
    scope or being deleted. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This simple object indicates if it is being destroyed because of exception
    stack unwinding. It can be tested like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The `f` function will throw an exception only if it is called with a `true`
    value. The `main` function calls `f` twice, once with a value of `false` (so the
    exception is not thrown in `f`) and a second time with `true`. The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The first-time `f` is called, the `test` object is destroyed normally, so `uncaught_exception`
    will return `false`. The second-time `f` is called the `test` object in the function
    is being destroyed before the exception has been caught, so `uncaught_exception`
    will return `true`. Since an exception is thrown, the execution leaves the `try`
    block and so the `test` object in the `try` block is destroyed and `uncaught_exception`
    will return `true`. Finally, when the exception has been handled and control returns
    to code after the `catch` block, the `test` object created on the stack in the
    `main` function will be destroyed when the `main` function returns and so `uncaught_exception`
    will return `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Standard exception classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `exception` class is a simple container for a C string: the string is passed
    as a constructor parameter and is available through the `what` accessor. The Standard
    Library declares the exception class in the `<exception>` library, and you are
    encouraged to derive your own exception classes from this. The Standard Library
    provides the following derived classes; most are defined in `<stdexcept>`.'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Class** | **Thrown** |'
  prefs: []
  type: TYPE_TB
- en: '| `bad_alloc` | When the `new` operator has been unable to allocate memory
    (in `<new>`) |'
  prefs: []
  type: TYPE_TB
- en: '| `bad_array_new_length` | When the `new` operator has been asked to create
    an array with an invalid length (in `<new>`) |'
  prefs: []
  type: TYPE_TB
- en: '| `bad_cast` | When `dynamic_cast` to a reference type fails (in `<typeinfo>`)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `bad_exception` | An unexpected condition has occurred (in `<exception>`)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `bad_function_call` | Invoked an empty `function` object (in `<functional>`)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `bad_typeid` | When the argument of `typeid` is null (in `<typeinfo>`) |'
  prefs: []
  type: TYPE_TB
- en: '| `bad_weak_ptr` | When accessing a weak pointer, which refers to an already
    destroyed object (in `<memory>`) |'
  prefs: []
  type: TYPE_TB
- en: '| `domain_error` | When an attempt is made to perform an operation outside
    the domain on which the operation is defined |'
  prefs: []
  type: TYPE_TB
- en: '| `invalid_argument` | When an invalid value has been used for a parameter
    |'
  prefs: []
  type: TYPE_TB
- en: '| `length_error` | When an attempt has been made to exceed the length defined
    for an object |'
  prefs: []
  type: TYPE_TB
- en: '| `logic_error` | When there is a logic error, for example, class invariants
    or pre-conditions |'
  prefs: []
  type: TYPE_TB
- en: '| `out_of_range` | When an attempt has been made to access elements outside
    of the range defined for the object |'
  prefs: []
  type: TYPE_TB
- en: '| `overflow_error` | When a calculation results in a value bigger than the
    destination type |'
  prefs: []
  type: TYPE_TB
- en: '| `range_error` | When a calculation results in a value outside the range for
    the type |'
  prefs: []
  type: TYPE_TB
- en: '| `runtime_error` | When an error occurs outside the scope of the code |'
  prefs: []
  type: TYPE_TB
- en: '| `system_error` | Base class to wrap operating system errors (in `<system_error>`)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `underflow_error` | When a calculation results in an underflow |'
  prefs: []
  type: TYPE_TB
- en: All the classes, mentioned in the preceding table, have a constructor that takes
    a `const char*` or a `const string&` parameter, in contrast to the `exception`
    class that takes a C string (hence the base class is constructed using the `c_str`
    method if the description is passed through a `string` object). There are no wide
    character versions, so if you want to construct an exception description from
    a wide character string you have to convert it. Also, note that the standard exception
    classes only have one constructor parameter, and this is available through the
    inherited `what` accessor.
  prefs: []
  type: TYPE_NORMAL
- en: There is no absolute rule about the data that an exception can hold. You can
    derive a class from `exception` and construct it with whatever values you want
    to make available to the exception handler.
  prefs: []
  type: TYPE_NORMAL
- en: Catching exceptions by type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There can be more than one `catch` block with each `try` block, which means
    that you can tailor the exception handling according to the exception type. The
    types of the parameters in the `catch` clauses will be tested against the type
    of the exception in the order that they are declared. The exception will be handled
    by the first handler that matches the exception type, or is a base class. This
    highlights the convention to catch the exception object via a reference. If you
    catch as a base class object a copy will be made, slicing the derived class object.
    In many cases code, will throw objects of a type derived from the `exception`
    class so it means that a catch handler for `exception` will catch all exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since code can throw any object, it is possible that an exception will propagate
    out of the handler. C++ allows you to catch everything by using an ellipses in
    the `catch` clause. Clearly, you should order the `catch` handlers from the most
    derived to the least derived and (if you use it) with the ellipses handler at
    the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: If the guarded code does not throw an exception, then the `catch` blocks are
    not executed.
  prefs: []
  type: TYPE_NORMAL
- en: When your handler examines the exception, it may decide that it does not want
    to suppress the exception; this is called rethrowing the exception. To do this,
    you can use the `throw` statement without an operand (this is only allowed in
    a `catch` handler), which will rethrow the actual exception object that was caught,
    and not a copy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exceptions are thread-based and so it is difficult to propagate an exception
    to another thread. The `exception_ptr` class (in `<exception>`) provides shared
    ownership semantics for an exception object of any type. You can get a shared
    copy of an exception object by calling the `make_exception_ptr` object, or you
    can even get a shared copy of the exception being handled in a `catch` block using
    `current_exception`. Both functions return an `exception_ptr` object. An `exception_ptr`
    object can hold an exception of any kind, not just those derived from the `exception`
    class, so getting information from the wrapped exception is specific to the exception
    type. The `exception_ptr` object knows nothing about these details, so instead
    you can pass it to `rethrow_exception` in the context where you want to use the
    shared exception (another thread) and then catch the appropriate exception object.
    In the following code, there are two threads running. The `first_thread` function
    runs on one thread and the `second_thread` function on the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code looks like it is using `exception_ptr` as a pointer. In fact,
    `eptr` is created as a global object and the assignment to `nullptr` uses the
    copy constructor to create an empty object (where the wrapped exception is `nullptr`).
    Similarly, the comparison with `nullptr` actually tests the wrapped exception.
  prefs: []
  type: TYPE_NORMAL
- en: This book is not about C++ threading, so we won't go into the details of the
    signalling between two threads. This code shows that a shared copy of an exception,
    *any exception*, can be stored in one context and then rethrown and processed
    in another context.
  prefs: []
  type: TYPE_NORMAL
- en: Function try blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may decide that you want to protect an entire function with a `try` block,
    in which case you could write code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This uses the `reciprocal` function, as defined earlier, that will throw an
    `exception` if the parameter is zero. An alternative syntax for this is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This looks rather odd because the function prototype is followed immediately
    by the `try... catch` block and there is no outer set of braces. The function
    body is the code in the `try` block; when this code completes the function returns.
    If the function returns a value, it must do it in the `try` block. In most cases,
    you will find that this syntax makes your code less readable, but there is one
    situation where it may be useful--for initializer lists in constructors.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we wrap a `double` value that is simply the reciprocal of the
    parameter passed to the constructor. The data member is initialized by calling
    the `reciprocal` function in the initializer list. Since this is outside of the
    constructor body, an exception that occurs here will be passed straight to the
    code that calls the constructor. If you want to do some additional processing,
    then you could call the reciprocal function inside the constructor body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important to note that the exception will be automatically rethrown because
    any exception in a constructor means that the object is invalid. However, this
    does allow you to do some additional processing, if necessary. This solution will
    not work for exceptions thrown in a base object constructor because, although
    you can call a base constructor in the derived constructor body, the compiler
    will call the default constructor automatically. If you want the compiler to call
    a constructor other than the default constructor you have to call it in the initializer
    list. An alternative syntax to providing exception code in the `inverse` constructor
    is to use function `try` blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This looks a little cluttered, but the constructor body is still after the initializer
    list giving an initial value to the `recip` data member. Any exception from the
    call to `reciprocal` will be caught and automatically rethrown after processing.
    The initializer list can contain calls to the base class and any of the data members
    and all will be protected with the `try` block.
  prefs: []
  type: TYPE_NORMAL
- en: System errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `<system_error>` library defines a series of classes to encapsulate system
    errors. The `error_category` class provides a mechanism to convert numeric error
    values into localized descriptive strings. Two objects are available through the
    `generic_category` and `system_category` functions in `<system_error>`, and `<ios>`
    has a function called `isostream_category`; all of these functions return an `error_category`
    object. The `error_category` class has a method called `message` that returns
    a string description of the error number you pass as the parameter. The object
    returned from the `generic_category` function will return the descriptive string
    for a POSIX error, so you can use it to get a description for an `errno` value.
    The object returned from the `system_category` function will return an error description
    via the Win32 `FormatMessage` function using `FORMAT_MESSAGE_FROM_SYSTEM` for
    the flags parameter, and hence this can be used to get the descriptive message
    for a Windows error message in a `string` object.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `message` has no extra parameters to pass in values for a Win32 error
    message that takes parameters. Consequently, in those situations you will get
    back a message that has formatting placeholders.
  prefs: []
  type: TYPE_NORMAL
- en: In spite of the name, the `isostream_category` object essentially returns the
    same descriptions as the `generic_category` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `system_error` exception is a class that reports one of the values described
    by one of the `error_category` objects. For example, this is the example used
    earlier for `FormatMessage` but re-written using `system_error`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `system_error` constructor used here has the error value as the first parameter
    (a `ulong` returned from the Win32 function `GetLastError`) and a `system_category`
    object used to convert the error value to a descriptive string when the `system_error::what`
    method is called.
  prefs: []
  type: TYPE_NORMAL
- en: Nested exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `catch` block may rethrow the current exception by calling `throw` without
    any operand, and there will be stack unwinding until the next `try` block is reached
    in the call stack. You can also rethrow the current exception *nested inside*
    another exception. This is achieved by calling the `throw_with_nested` function
    (in `<exception>`) and passing the new exception. The function calls `current_exception`
    and wraps the exception object in a nested exception along with the parameter,
    which is then thrown. A `try` block further up the call stack can catch this exception,
    but it can only access the outer exception; it has no direct access to the inner
    exception. Instead, the inner exception can be thrown with a call to `rethrow_if_nested`.
    For example, here is another version of code to open a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The code opens a file, and if the file does not exist then a state bit is set
    (you can test the bits later with a call to the `rdstat` method). The next line
    indicates the values of the state bits that should be handled by the class throwing
    an exception, and in this case the `ios_base::failbit` is provided. If the constructor
    failed to open the file then this bit will be set, so the `exceptions` method
    will respond by throwing an exception. In this example, the exception is caught
    and wrapped into a nested exception. The outer exception is a `system_error` exception,
    which is initialized with an error value of `ENOENT` (which means that the file
    does not exist) and an `error_category` object to interpret it, passing the name
    of the file as additional information.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function can be called like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The exception caught here can be accessed, but it just gives information about
    the outer object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This message is constructed by the `system_error` object using the additional
    information passed to its constructor and the description from the category object.
    To get the inner object in a nested exception you have to tell the system to throw
    the inner exception with a call to `rethrow_if_nested`. So, instead of printing
    out the outer exception, you call a function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This prints the description for the outer exception and then calls `rethrow_if_nested,`
    which will only throw the exception if it is nested. If so, it throws the inner
    exception, which is then caught and recursively calls the `print_exception` function.
    The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The last line is the inner exception which was thrown when the `ifstream::exception`
    method was called.
  prefs: []
  type: TYPE_NORMAL
- en: Structured Exception Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Native exceptions in Windows are **Structured Exceptions Handling** (**SEH**)
    and Visual C++ has a language extension to allow you to catch these exceptions.
    It is important to understand that they are not the same as C++ exceptions, which
    are considered by the compiler to be *synchronous*, that is, the compiler knows
    if a method may (or specifically, will not) throw a C++ exception, and it uses
    this information when analysing code. C++ exceptions are also caught by type.
    SEH is not a C++ concept, so the compiler treats structured exceptions as being
    *asynchronous*, meaning it treats any code within an SEH protected block as potentially
    raising a structured exception, and hence the compiler cannot perform optimizations.
    SEH exceptions are also caught by exception code.
  prefs: []
  type: TYPE_NORMAL
- en: The language extensions for SEH are extensions to Microsoft C/C++, that is,
    they can be used in C as well as C++ so the handling infrastructure does not know
    about object destructors. Additionally, when you catch an SEH exception, no assumptions
    are made about the state of the stack or any other part of your process.
  prefs: []
  type: TYPE_NORMAL
- en: Although most Windows functions will catch the SEH exceptions generated by the
    kernel in an appropriate way, some purposely allow them to propagate (for example,
    the **Remote Procedure Calls** (**RPC**) functions, or those used for memory management).
    With some Windows functions you can explicitly request that errors are handled
    with SEH exceptions. For example, the `HeapCreate` set of functions will allow
    a Windows application to create a private heap, and you can pass the `HEAP_GENERATE_EXCEPTIONS`
    flag to indicate that errors in creating the heap, and allocating, or reallocating
    memory in a private heap, will generate an SEH exception. This is because the
    developer calling these functions may regard the failure to be so serious that
    it is not recoverable, and hence the process should terminate. Since an SEH is
    such a serious situation, you should review carefully whether it is appropriate
    (which is not entirely impossible) to do much more than report details of the
    exception and terminate the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'SEH exceptions are essentially low-level operating system exceptions, but it
    is important to be familiar with the syntax because it looks similar to C++ exceptions.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The SEH exception code is highlighted here. This code uses the Windows `VirtualAlloc`
    function to reserve a number of pages of memory. Reserving does not allocate the
    memory, that action has to be carried out in a separate operation called **committing
    the memory**. Windows will reserve (and commit) memory in blocks called **pages**
    and on most systems a page is 4096 bytes, as assumed here. The call to the `VirtualAlloc`
    function indicates that it should reserve ten pages of 4096 bytes, which will
    be committed (and used) later.
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter to `VirtualAlloc` indicates the location of the memory,
    but since we are reserving memory, this is unimportant so `nullptr` is passed.
    If the reserving succeeds, then a pointer is returned to the memory. The `for`
    loop simply writes data to the memory one byte at a time. The highlighted code
    protects this memory access with structured exception handling. The protected
    block starts with the `__try` keyword. When an SEH is raised, execution passes
    to the `__except` block. This is very different to the `catch` block in C++ exceptions.
    Firstly, `__except` exception handler receives one of three values to indicate
    how it should behave. Only if this is `EXCEPTION_EXECUTE_HANDLER` will the code
    in the handler block be run (in this code, to shut down the process abruptly).
    If the value is `EXCEPTION_CONTINUE_SEARCH` then the exception is not recognized
    and the search will continue up the stack, *but without C++ stack unwinding*.
    The surprising value is `EXCEPTION_CONTINUE_EXECUTION,` because this dismisses
    the exception and execution in the `__try` block will continue. *You cannot do
    this with C++ exceptions*. Typically, SEH code will use an exception filter function
    to determine what action is required of the `__except` handler. In this code,
    this filter is called `exception_filter,` which is passed the exception code obtained
    by calling the Windows function `GetExceptionCode`. This syntax is important because
    this function can only be called in the `__except` context.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first time the loop runs no memory will have been committed and so the
    code that writes to the memory will raise an exception: a page fault. Execution
    will pass to the exception handler and through to `exception_filter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: It is important in SEH code to only handle exceptions that you know about, and
    only consume the exception if you know that the condition has been completely
    addressed. If you access Windows memory that has not been committed, the operating
    system generates an exception called a page fault. In this code, the exception
    code is tested to see if it is a page fault, and if not, the filter returns telling
    the exception handler to run the code in the exception handler block that terminates
    the process. If the exception is a page fault then we can commit the next page.
    First, there is a test to see if the page number is within the range that we will
    use (if not, then close down the process). Then, the next page is committed with
    another call to `VirtualAlloc` to identify the page to commit and the number of
    bytes in that page. If the function succeeds, it will return a pointer to the
    committed page or a null value. Only if committing the page has succeeded will
    the filter return a value of `EXCEPTION_CONTINUE_EXECUTION`, indicating that the
    exception has been handled and execution can continue at the point the exception
    was raised. This code is a standard way to use `VirtualAlloc` because it means
    that memory pages are only committed when, and if, they are needed.
  prefs: []
  type: TYPE_NORMAL
- en: SEH also has the concept of termination handlers. When execution leaves the
    `__try` block of code through a call to `return`, or by completing all of the
    code in the block, or by calling the Microsoft extension `__leave` instruction,
    or has raised an SEH, then the termination handler block of code marked with `__finally`
    is called. Since the termination handler is always called, regardless of how the
    `__try` block is exited, it is possible to use this as a way to release resources.
    However, because SEH does not do C++ stack unwinding (nor call destructors), this
    means that you cannot use this code in a function that has C++ objects. In fact,
    the compiler will refuse to compile a function that has SEH and created C++ objects,
    either on the function stack or allocated on the heap. (You can, however, use
    global objects or objects allocated in calling functions and passed in as parameters.)
    The `__try`/`__finally` construct looks useful, but is constrained by the requirement
    that you cannot use it with code that creates C++ objects.
  prefs: []
  type: TYPE_NORMAL
- en: Compiler exception switches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, it is worth explaining why you have compiled your code with the
    `/EHsc` switch. The simple answer is, if you do not use this switch the compiler
    will issue a warning from the Standard Library code, and as the Standard Library
    uses exceptions you must use the `/EHsc` switch. The warning tells you to do this,
    so that is what you do.
  prefs: []
  type: TYPE_NORMAL
- en: The long answer is that the `/EH` switch has three arguments that you can use
    to influence how exceptions are handled. Using the `s` argument tells the compiler
    to provide the infrastructure for synchronous exceptions, that is, C++ exceptions
    that may be thrown in a `try` block and handled in a `catch` block, and that have
    stack unwinding that calls the destructors of automatic C++ objects. The `c` argument
    indicates that `extern C` functions (that is, all the Windows SDK functions) never
    throw C++ exceptions (and hence the compiler can do an additional level of optimization).
    Hence, you can compile Standard Library code with either `/EHs` or `/EHsc`, but
    the latter will generate more optimized code. There is an additional argument,
    where `/EHa` indicates that the code will catch *both* synchronous and asynchronous
    exceptions (SEH) with `try`/`catch` blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Mixing C++ and SEH exception handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `RaiseException` Windows function will throw an SEH exception. The first
    parameter is the exception code and the second indicates if the process can continue
    after this exception is handled (`0` means it can). The third and fourth parameters
    give additional information about the exception. The fourth parameter is a pointer
    to an array with these additional parameters and the number of parameters is given
    in the third parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `/EHa`, you can write code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem with this code is that it handles all SEH exceptions. This is quite
    dangerous because some SEH exceptions may indicate that the process state is corrupted,
    so it is dangerous for the process to continue. The C Runtime Library provides
    a function called `_set_se_translator` that provides a mechanism to indicate which
    SEH exceptions are handled by `try`. This function is passed a pointer by a function
    that you write with this prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter is the exception code (which will be returned from the
    `GetExceptionCode` function) and the second parameter is the return from the `GetExceptionInformation`
    function and has any additional parameters associated with the exception (for
    example, those passed through the third and fourth parameters in `RaiseException`).
    You can use these values to throw a C++ exception in place of the SEH. If you
    provide this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now register the function before handling an SEH exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, the `RaiseException` function is raising a custom SEH with a
    value of 1\. This translation is perhaps not the most useful, but it illustrates
    the point. The `winnt.h` header file defines the exception code for the standard
    SEH exceptions that can be raised in Windows code. A more useful translation function
    would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows you to call the reciprocal function as following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Writing exception-safe classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In general, when you write classes, you should ensure that you protect the users
    of your classes from exceptions. Exceptions are not an error propagation mechanism.
    If a method on your class fails but is recoverable (the object state is left consistent)
    then you should use the return value (most likely an error code) to indicate this.
    Exceptions are for exceptional situations, those that have invalidated data and
    where, at the point where the exception is raised, the situation is unrecoverable.
  prefs: []
  type: TYPE_NORMAL
- en: When an exception occurs in your code, you have three options. Firstly, you
    can allow the exception to propagate up the call stack and put the responsibility
    of handling the exception on the calling code. This means that you call code without
    guarding by `try` blocks, even though the code is documented as being able to
    throw exceptions. In this situation, you must be reassured that the exception
    makes sense to the calling code. For example, if your class is documented as a
    network class and uses a temporary file to buffer some data received from the
    network, if the file access code throws an exception, the exception object will
    not make sense to code that calls your code, because that client code thinks that
    your class is about accessing network data, not file data. If, however, the network
    code throws an error, it may make sense to allow those exceptions to propagate
    to calling code, especially if they refer to errors that require external action
    (say, a network cable is unplugged or there is a security issue).
  prefs: []
  type: TYPE_NORMAL
- en: In this case, you can apply your second option, which is to protect code that
    can throw exceptions with a `try` block, catch known exceptions, and throw a more
    appropriate exception, perhaps nesting the original exception so that the calling
    code can do more detailed analysis. If the exception is one that makes sense to
    your calling code, you may allow it to propagate out, but catching the original
    exception allows you to take additional action before you rethrow it.
  prefs: []
  type: TYPE_NORMAL
- en: Using the buffered network data example, you could decide that since there is
    an error in the file buffering, it means that you cannot read any more network
    data, so your exception handling code should shut down the network access in a
    graceful way. The error occurred in the file code, not the network code, so an
    abrupt shutdown of the network is not justified, and it makes more sense to allow
    the current network action to complete (but ignore the data), so that no errors
    are propagated back to the network code.
  prefs: []
  type: TYPE_NORMAL
- en: The final option is to protect all code with a `try` block, and catch and consume
    exceptions, so that calling code completes without throwing an exception. There
    are two main situations where this is appropriate. Firstly, the error may be recoverable,
    and so in the `catch` clause you can take steps to address the issue. In the buffered
    network data example, when opening a temporary file, if you get an error that
    a file with the requested name already exists, you can simply use another name
    and try again. The user of your code does not need to know that this problem occurred
    (although, it may make sense to trace this error so that you can investigate the
    issue in the testing phase of your code). If the error is not recoverable, it
    may make more sense to invalidate the state of your object and return an error
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Your code should utilize the behavior of the C++ exception infrastructure, which
    guarantees that automatic objects are destroyed. Therefore, when you use memory
    or other appropriate resources, you should wrap them in smart pointers whenever
    possible so that if an exception is thrown then the resource is released by the
    smart pointer destructor. Classes that use Resource Acquisition Is Initialization
    (RAII) are `vector`, `string`, `fstream,` and the `make_shared` function, so if
    the object construction (or the function call) is successful, it means that the
    resource has been acquired, and you can use the resource through these objects.
    These classes are also **Resource Release Destruction** (**RRD**), which means
    that the resource is released when the object is destroyed. The smart pointer
    classes, `unique_ptr` and `shared_ptr`, are not RAII because they simply wrap
    the resource and the allocation of resources is carried out separately by other
    code. However, these classes are RRD, so you can be assured that if an exception
    is thrown the resource is released.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling can offer three levels of exception safety. At the safest
    level of the scale is the *no-fail* method and function. This is the code that
    does not throw exceptions and does not allow exceptions to propagate. Such code
    will guarantee that class invariants are maintained and that the object state
    will be consistent. No-fail code is not achieved by simply catching all exceptions
    and consuming them, instead, you have to protect all code and catch, and handle,
    all exceptions to ensure that the object is left in a consistent state.
  prefs: []
  type: TYPE_NORMAL
- en: All built-in C++ types are no-fail. You also have a guarantee that all Standard
    Library types have no-fail destructors, but since containers will call the contained
    object destructors when instances are destroyed, this means that you have to ensure
    that the types you write to put in containers also have a no-fail destructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing no-fail types can involve quite detailed code, so another option is
    the *strong guarantee*. Such code will throw exceptions, but they ensure that
    no memory is leaked and that when an exception is thrown the object will be in
    the same state as when the method was called. This is essentially a transactional
    operation: either the object is modified or it is left unmodified, as if no attempt
    was made to perform the operation. In most cases methods, this will offer a *basic
    guarantee* of exception safety. In this case, there is a guarantee that whatever
    happens no memory is leaked, but when an exception is thrown, the object may be
    left in an inconsistent state, so the calling code should handle the exception
    by discarding the object.'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation is important. If the object methods are marked with `throw` or
    `noexcept` then you know it is no-fail. You should only assume the strong guarantee
    if the documentation says so. Otherwise, you can assume that objects will have
    the basic guarantee of exception safety, and if an exception is thrown the object
    is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you write your C++ code you should always have one eye looking towards
    the testing and debugging of your code. The ideal way to prevent the need to debug
    code is to write robust, well-designed code. Ideals are difficult to achieve,
    so it is better to write code that is easy for you to diagnose issues and easy
    to debug with. The C Runtime and the C++ Standard Library provides a wide range
    of facilities to enable you to trace and report issues, and through error code
    handling and exceptions you have a rich collection of tools to report and handle
    the failure of functions.
  prefs: []
  type: TYPE_NORMAL
- en: After reading this book you should be aware that the C++ language and Standard
    Library provide a rich, flexible, and powerful way to write code. What's more,
    once you know how to use the language and its libraries, C++ is a pleasure to
    use.
  prefs: []
  type: TYPE_NORMAL
