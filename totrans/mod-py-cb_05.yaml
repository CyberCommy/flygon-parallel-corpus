- en: Chapter 5. User Inputs and Outputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll look at the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using features of the print() function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using input() and getpass() for user input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging with "format".format_map(vars())
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using argparse to get command-line input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using cmd for creating command-line applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the OS environment settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The core value of software is to produce useful output. One simple type of output
    is a text display of some useful result. Python supports this with the `print()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: The `input()` function has a clear parallel with the `print()` function. The
    `input()` function reads text from a console, allowing us to provide distinct
    values to our programs.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of other common ways to provide input. Parsing the command-line
    is also helpful for many applications. We sometimes need to use configuration
    files to provide useful input. Data files and network connections are yet more
    ways to provide input. Each of these is distinct and needs to be looked at separately.
    In this chapter, we'll focus on the fundamentals of `input()` and `print()` .
  prefs: []
  type: TYPE_NORMAL
- en: Using features of the print() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In many cases, the `print()` function is the first function we learn. The first
    script is often a variation on the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We quickly learn that the `print()` function can display multiple values, including
    a helpful space between items.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We see that a space is included to separate the two values. Additionally, a
    line break, usually represented by the `\n` character, is printed after the values
    provided in the function.
  prefs: []
  type: TYPE_NORMAL
- en: Can we control this formatting? Can we change the extra characters that are
    supplied?
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that there are some more things we can do with `print()` .
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have a spreadsheet that is used to record fuel consumption on a large sailboat.
    It has rows that look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Date** | **10/25/13** | **10/26/13** | **10/28/13** |'
  prefs: []
  type: TYPE_TB
- en: '| **Engine on** | 08:24:00 | 09:12:00 | 13:21:00 |'
  prefs: []
  type: TYPE_TB
- en: '| **Fuel height on** | 29 | 27 | 22 |'
  prefs: []
  type: TYPE_TB
- en: '| **Engine off** | 13:15:00 | 18:25:00 | 06:25:00 |'
  prefs: []
  type: TYPE_TB
- en: '| **Fuel height off** | 27 | 22 | 14 |'
  prefs: []
  type: TYPE_TB
- en: For more information on this data, refer to the *Removing items from a set –
    remove(), pop(), and difference* and *Slicing and dicing a list* recipes in [Chapter
    4](text00048.html#page "Chapter 4. Built-in Data Structures – list, set, dict")
    , *Built-in Data Structures – list, set, dict* . There's no level gauge inside
    the tank. The depth of fuel has to be read through a sight glass on the side of
    the tank, which is why the volume of fuel is stated as a depth. The full depth
    of the tank is about 31 inches, and the volume is about 72 gallons; it's possible
    to convert depth to volume.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of using the CSV data. This function reads the file and
    returns a list of fields built from each row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We used a `pathlib.Path` object to define the location of the raw data. We defined
    a function, `get_fuel_use()` , that will open and read the file at a given path.
    This function creates a list of rows from the source spreadsheet. Each line of
    data is represented as an `OrderedDict` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function starts by creating a `csv.DictReader` object to parse the raw
    data. The reader normally returns a built-in `dict` object, which doesn''t force
    a particular ordering on the keys. To force a particular key order, this function
    uses a generator expression to create an `OrderedDict` object for each row. The
    `fieldnames` attribute of the reader, `rdr` , is used to force the columns into
    a specific order. The generator expression uses a nested pair of loops: one loop
    processes each field of a row and the outer loop processes each row of the data.'
  prefs: []
  type: TYPE_NORMAL
- en: The result is a list object that contains the `OrderedDict` objects. This is
    a consistent source of data that we can use for printing. Each row has five fields
    based on the column names in the first row.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have two ways to control the `print()` formatting:'
  prefs: []
  type: TYPE_NORMAL
- en: Set the inter-field separator character, `sep` , which has a space as its default
    value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the end-of-line character, `end` , which has the `\n` character as its default
    value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll show several examples of changing `sep` and `end` . Each is a kind of
    one-step recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default case looks like this. This example has no change to `sep` or `end`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When we look at the output, we can see where a space was inserted between each
    item. The `\n` character at the end of each collection of data items means that
    each `print()` function produces a separate line.
  prefs: []
  type: TYPE_NORMAL
- en: 'When preparing data, we might want to use a format that''s similar to comma-separated
    values, perhaps using a column separator that''s not a simple comma. Here''s an
    example using  `|` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we can see that each column has the given separator string. Since
    there were no changes to the `end` setting, each `print()` function produces a
    distinct line of output.
  prefs: []
  type: TYPE_NORMAL
- en: The most common case seems to be where we want to suppress the separators entirely.
    This gives us a fine degree of control over the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we might change the default punctuation to emphasize the field
    name and value. In this case, we''ve changed the `end` setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Since the end string was changed to `,` , each use of the `print()` function
    did not produce a separate line. We didn't get a proper end of line until the
    final `print()` function, which had the default value for `end` .
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, this technique can get quite complex for anything more sophisticated
    than these simple examples. For something simple, we can tweak the separator or
    ending. For anything more complex, we need to use the `format()` method of a string.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the general case, the `print()` function is a handy wrapper around `stdout.write()`
    . This relationship can be changed, as we'll see next.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can imagine that `print()` has a definition something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This provides a hint as to how the the separator string and end string are included
    in the output from the `print()` function. If no value is provided, the default
    values are space and new line. The function iterates through the argument values,
    treating the first value as special because it does not have a separator. This
    approach assures that the separator string, `sep` , appears between values.
  prefs: []
  type: TYPE_NORMAL
- en: The end of line string, `end` , appears after all of the values. It is always
    written. We can effectively turn it off by setting it to a zero-length string.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `sys` module defines the two standard output files that are always available:
    `sys.stdout` and `sys.stderr` .'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `file=` keyword argument to write to the standard error file
    in addition to the standard output file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We've imported the `sys` module so that we have access to the standard error
    file. We used this to write a message that would not be part of the standard output
    stream.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, we need to be cautious of opening too many output files in a single
    program. The OS limits are usually more than adequate to open many files. However,
    it can become confusing when a program creates a large number of files.
  prefs: []
  type: TYPE_NORMAL
- en: 'It often works out nicely to use OS file redirection techniques. A program''s
    primary output can be written to `sys.stdout` ; this is easily redirected at the
    OS level. A user might enter a command line like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will provide the `input.dat` file as the input on `sys.stdin` . When the
    Python program writes to `sys.stdout` , the output will be redirected by the OS
    to the `output.dat` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, we need to open additional files. In that case, we might see
    programming like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we've opened a specific path for output and assigned the open
    file to `target_file` using the `with` statement. We can then use this as the
    `file=` value in a `print()` function to write to this file. Because a file is
    a context manager, leaving the `with` statement means that the file will be closed
    properly and all of the OS resources will be released from the application. All
    file operations should be wrapped in a `with` statement context to ensure that
    the resources are properly released.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the *Debugging with "format".format_map(vars())* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on the input data in this example, refer to the *Removing
    items from a set – remove(), pop(), and difference* and *Slicing and dicing a
    list* recipes in [Chapter 4](text00048.html#page "Chapter 4. Built-in Data Structures
    – list, set, dict") , *Built-in Data Structures – list, set, dict*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on file operations in general, refer to [Chapter 9](text00099.html#page
    "Chapter 9. Input/Output, Physical Format, and Logical Layout") , *Input/Output,
    Physical Format, Logical Layout*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using input() and getpass() for user input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some Python scripts depend on gathering input from a user. There are several
    ways to do this. One popular technique is to use the console to prompt the user
    for input.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two relatively common situations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ordinary input** : We use the `input()` function for this. This will provide
    a helpful echo of the characters being entered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No echo input** : This is often used for passwords. The characters entered
    aren''t displayed, providing a degree of privacy. We use the `getpass()` function
    in the `getpass` module for this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `input()` and `getpass()` functions are just two implementation choices
    for reading from the console. It turns out that getting the string of characters
    is only the first step in processing. We actually have separate tiers of considerations:'
  prefs: []
  type: TYPE_NORMAL
- en: The initial interaction with the console. This is the basics of writing a prompt
    and reading input. This must correctly handle data as well as keyboard events,
    such as backspace for editing. This may also mean handling end-of-file appropriately.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Validating the input to see that it belongs in the expected domain of values.
    We might be looking for digits, yes/no values, or days of the week. In most cases,
    there are two parts to the validation tier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We check whether the input fits some general domain, for example, numbers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We check whether the input fits some more specific subdomain. For example, this
    might include a check to see if the number is greater than or equal to zero.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating the input in some larger context to ensure that it's consistent with
    other inputs. For example, we can check whether the user's birth date is prior
    to today.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Above and beyond these techniques, we'll look at some other approaches in the
    *Using argparse to get command-line input* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll look at a technique for reading a complex structure from a person. In
    this case, we'll use the year, month, and day as separate items to create a complete
    date.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a quick example that omits all of the validation issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This illustrates how easy it is to use the `input()` function. We often need
    to wrap this in additional processing to make it more useful. The calendar is
    complex, and we'd hate to accept February 32 without warning a user that this
    is not a proper date.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Check whether the input is a password or something equally subject to redaction.
    If so, then use the `getpass.getpass()` function. This means we need to import
    the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Otherwise, if the redacted input is not required, use the `input()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Determine which prompt will be used. This might be as simple as `>>>` or something
    more complex. In some cases, we might provide a great deal of contextual information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our example, we provided a field name and a hint about the type of data
    expected as a prompt string. The prompt string is the argument to the `input()`
    or `getpass()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Determine how to validate each item in isolation. The simplest case is a single
    value with a single rule that covers everything. In more complex cases—like this
    one—each individual element is a number with a range constraint. In a later step,
    we'll look at validating the composite item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We might want to restructure our input to look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This applies two validation rules to the input:'
  prefs: []
  type: TYPE_NORMAL
- en: It checks whether the month is a valid integer using the `int()` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It checks whether the integer is in the range [1, 12] using an `if` statement
    that raises a `ValueError` exception
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raising an exception for faulty input is generally the simplest approach. It
    allows us the most flexibility. There are other exception classes we might use,
    including defining a customized data validation exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we''ll use nearly identical loops for each field of a complex object,
    we need to restructure this input and validate the sequence into a separate function.
    We''ll call it `get_integer()` . We''ll look at the details here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Validate the composite object. In this case, it also means that our overall
    input needs to be restructured to allow for a retry in the event of bad input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This overall loop implements the higher level validation of the composite date
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Given a year and a month, we can actually determine a slightly more narrow range
    for the number of days. The complexity is that not only do months have different
    numbers of days, varying from 28 to 31, but February has a number of days that
    varies with the type of year.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than mimicing the rules, it''s easier to use the `datetime` module to
    compute the first days of two adjacent months, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This will properly compute the last day of any given month. The algorithm works
    by computing the first day of a given year and month. It then computes the first
    day of the next month. It properly changes the year so that January of `year+1`
    follows December of `year` .
  prefs: []
  type: TYPE_NORMAL
- en: The number of days between these dates is the number of days in the given month.
    We can use the expression `(day_end_date - day_1_date).days` to extract the number
    of days from the `timedelta` object.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to decompose the input problem into several separate, but closely related
    problems. At the bottom layer is the initial interaction with the user. We identified
    two of the common ways to handle this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`input()` : This prompts and reads simply'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getpass.getpass()` : This prompts and reads passwords without an echo'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We expect to be able to edit the current line of input using the *Backspace*
    character. In some environments, there is a more sophisticated editor available.
    It's embodied in the Python `readline` module. This module, if present, can add
    a great deal of editing while preparing a line of input. The principle feature
    of this module is an OS-level input history—we can use the up arrow key to recover
    any previous input.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve decomposed the input validation into several tiers to reflect the kind
    of programming required to confirm that the input is valid:'
  prefs: []
  type: TYPE_NORMAL
- en: A **general domain** validation should use the simple conversion functions such
    as `int()` or `float()` . These tend to raise exceptions for invalid data. It's
    far simpler to use these conversion functions and handle the exceptions than to
    attempt to write a regular expression that matches valid numeric values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our **subdomain** validation must use an `if` statement to determine whether
    values fit any additional constraints, such as ranges, that are imposed. For consistency,
    this should also raise an exception if the data is invalid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a lot of potential kinds of constraints that might be imposed on values.
    For example, we might want only valid OS process IDs, called PIDs. This requires
    checking the `/proc/<pid>` path on Nanny Linux systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'For BSD-based systems such as Mac OS X, the `/proc` file system doesn''t exist.
    Instead, something like the following needs to be done to determine if a PID is
    valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'For Windows, the command would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Either of these two functions would need to be part of input validation to ensure
    that the user is entering a proper PID value. This can only be applied if the
    primary domain of integers was assured.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, our overall input function should also raise an exception for invalid
    input. This can vary quite a bit in complexity. We created a simple date object
    in the example. In other cases, we might have to do considerably more processing
    to determine whether a complex input is valid.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have several alternatives for user input that involve slightly different
    approaches. We''ll look at these two topics in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Input string parsing: This will involve simple use of `input()` with clever
    parsing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Interaction via `cmd` module: This involves a more complex class, and somewhat
    simpler parsing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input string parsing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A simple date value requires three separate fields. A more complex date-time
    that includes a timezone offset from UTC will involve seven separate fields. The
    user experience might be improved by reading and parsing a string rather than
    individual fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a simple date input, we might use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We've used the `strptime()` function to parse a time string in a given format.
    We've emphasized the expected date format in the prompt that's provided in the
    `input()` function.
  prefs: []
  type: TYPE_NORMAL
- en: This style of input requires the user to enter a more complex string. Since
    it's a single string that includes all of the details for a date, many people
    find it as easier and more friendly.
  prefs: []
  type: TYPE_NORMAL
- en: Note that both techniques—gathering individual fields and processing a complex
    string—depend on the underlying `input()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Interaction via the cmd module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `cmd` module includes the `Cmd` class that can be used to build an interactive
    interface. This takes a dramatically different approach to the notion of user
    interaction. It does not rely on using `input()` explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at this closely in the *Using cmd for creating command-line applications*
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the reference material for the SunOS operating system, which is now owned
    by Oracle, there is a collection of commands that prompt for different kinds of
    user inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.oracle.com/cd/E19683-01/816-0210/6m6nb7m5d/index.html](https://docs.oracle.com/cd/E19683-01/816-0210/6m6nb7m5d/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, all of these commands that begin with `ck` are for gathering
    and validating user input. This could be used to define a module of input validation
    rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ckdate` : This prompts for and validates a date'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ckgid` : This prompts for and validates a group ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ckint` : This displays a prompt, verifies, and returns an integer value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ckitem` : This builds a menu, prompts for, and returns a menu item'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ckkeywd` : This prompts for and validates a keyword'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ckpath` : This displays a prompt, verifies, and returns a pathname'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ckrange` : This prompts for and validates an integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ckstr` : This displays a prompt, verifies, and returns a string answer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cktime` : This displays a prompt, verifies, and returns a time of day'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ckuid` : This prompts for and validates a user ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ckyorn` : This prompts for and validates yes/no'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging with "format".format_map(vars())
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important debugging and design tools available in Python is
    the `print()` function. There are some kinds of formatting options available;
    we looked at these in the *Using features of the print() function* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: What if we want more flexible output? We have more flexibility with the `"string".format_map()`
    method. This isn't all. We can couple this with the `vars()` function to create
    something that often leads to a wow!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at a multistep process that involves some moderately complex calculations.
    We''ll compute the mean and standard deviation of some sample data. Given these
    values, we''ll locate all items that are more than one standard deviation above
    the mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This calculation has several working variables. The `mean_size` , `std_size`
    , and `sig1` variables all show elements of the final list comprehension that
    filters the `size` list. If the result is confusing or even incorrect, it's helpful
    to know the intermediate steps in the calculation. In this case, because they're
    floating-point values, we often want to round the results so that they're more
    meaningful.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `vars()` function builds a dictionary structure from a variety of sources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If no arguments are given, then by default, the `vars()` function will expand
    all the local variables. This creates a mapping that can be used with the `format_map()`
    method of a template string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using a mapping allows us to inject variables using the variable''s name into
    the format template. It looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We can put any local variable into the format string. Using `format_map(vars())`
    , we don't need to have a more complex way to pick which variables are going to
    be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `vars()` function builds a dictionary structure from a variety of sources:'
  prefs: []
  type: TYPE_NORMAL
- en: The `vars()` expression will expand all local variables to create a mapping
    that can be used with the `format_map()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `vars(object)` expression will expand all of the items in an object's internal
    `__dict__` attribute. This allows us to expose attributes of class definitions
    and objects. When we look at objects in [Chapter 6](text00070.html#page "Chapter 6. Basics
    of Classes and Objects") , *Basics of Classes and Objects* , we'll see how we
    can leverage this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `format_map()` method expects a single argument, which is a mapping. The
    format string uses `{name}` to refer to keys in the mapping. We can use `{name:format}`
    to provide a format specification. We can also use `{name!conversion}` to provide
    a conversion function using the `repr()` , `str()` , or `ascii()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: For more background on the formatting options, refer to the *Building complex
    strings with "template".format()* recipe in [Chapter 1](text00014.html#page "Chapter 1. Numbers,
    Strings, and Tuples") , *Numbers, Strings, and Tuples* .
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `format_map(vars())` technique is a simple way to display the values of
    variables. An alternative is to use `format(**vars())` . This alternative can
    give us some additional flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can use this more flexible format to include additional calculations
    that aren''t simply local variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We've computed a new value, `sig2` , that appears only inside the formatted
    output.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the *Building complex strings with "template".format()* recipe in [Chapter
    1](text00014.html#page "Chapter 1. Numbers, Strings, and Tuples") , *Numbers,
    Strings, and Tuples* , for more of the things that can be done with the format()
    method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the *Using features of the print() function* recipe for other formatting
    options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using argparse to get command-line input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some cases, we want to get the user input from the OS command line without
    a lot of interaction. We'd prefer to parse the command-line argument values and
    either perform the processing or report an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, at the OS level, we might want to run a program like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The OS prompt is `slott$` . We entered a command of `python3 ch05_r04.py` .
    This command had an optional argument, `-r KM` , and two positional arguments
    of `36.12,-86.67` and `33.94,-118.40` .
  prefs: []
  type: TYPE_NORMAL
- en: The program parses the command-line arguments and writes the result back to
    the console. This allows for a very simple kind of user interaction. It keeps
    the program very simple. It allows the user to write a shell script to invoke
    the program or merge the program with other Python programs to create a higher
    level program.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the user enters something incorrect, the interaction might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: An invalid argument value of `-118asd` leads to an error message. The program
    stopped with an error status code. For the most part, the user can hit the up
    arrow key to get the previous command line back, make a change, and run the program
    again. The interaction is delegated to the OS command line.
  prefs: []
  type: TYPE_NORMAL
- en: The name of the program—`ch05_r04` —isn't too informative. We could perhaps
    do better. The positional arguments are two (latitude, longitude) pairs. The output
    shows the distance between the two in the given units.
  prefs: []
  type: TYPE_NORMAL
- en: How do we parse argument values from the command line?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we need to do is to refactor our code to create two separate
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: A function to get the arguments from the command line. Owing to the way in which
    the `argparse` module works, this function will almost always return an `argparse.Namespace`
    object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function which does the real work. This function should be designed so that
    it makes no reference to the command-line options in any way. This means it can
    be reused in a variety of contexts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s our *real work* function, `display()` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We've imported the core calculation, `haversine()` , from another module. We've
    provided argument values to this function and used `format()` to display the final
    result message.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve based this on the calculations shown in the examples in the *Picking
    an order for parameters based on partial functions* recipe in [Chapter 3](text00039.html#page
    "Chapter 3. Function Definitions") , *Function Definitions* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](Image00012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The essential calculation yields the central angle, *c* , between two points,
    given as ( *lat[1]* , *lon[1]* ) and ( *lat[2]* , *lon[2]* ). The angle is measured
    in radians. We convert it into distance by multiplying it by the Earth's mean
    radius in some units. If we multiply the angle *c* by a radius of 3,959 miles,
    we'll get the distance represented by the angle in miles.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we expect the distance conversion factor, *r* , to be provided as
    a string. This function will then map the string to an actual floating-point value.
  prefs: []
  type: TYPE_NORMAL
- en: For details on the `format()` method, note that we're using a variation on the
    *Debugging with "format".format_map(vars())* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how the function looks when it''s used inside Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This function has two important design features. The first feature is that it
    avoids references to features of the `argparse.Namespace` object that's created
    by argument parsing. Our goal is to have a function that we can reuse in a number
    of alternative contexts. We need to keep the input and output elements of the
    user interface separate.
  prefs: []
  type: TYPE_NORMAL
- en: The second design feature is that this function displays a value computed by
    another function. This is a helpful feature because it lets us decompose the problem.
    We've separated the user experience from the essential calculation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define the overall argument parsing function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `parser` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Add the various types of arguments to the `parser` object. Sometimes this is
    difficult because we're still refining the user experience. It's difficult to
    imagine all the ways in which people will use a program and all of the questions
    they might have.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For our example, we have two mandatory, positional arguments, and an optional
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: Point 1 latitude and longitude
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Point 2 latitude and longitude
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional distance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use Nautical Miles as a handy default so that sailors get the answers
    they need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve added two kinds of arguments. The first is the `-r` , argument, which
    starts with `-` to mark it as optional. Sometimes, a `--` is used with a longer
    name. In some cases, we''ll provide both alternatives, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The action is to store the value which follows the `-r` on the command-line.
    We've listed the three possible choices and provided a default. The parser will
    validate the input and write appropriate errors if the input isn't one of these
    three values.
  prefs: []
  type: TYPE_NORMAL
- en: The mandatory arguments are provided without a `-` prefix. We used an action
    of `store` ; this is the default action and doesn't really need to be stated.
    The function provided as the `type` argument is used to convert the source string
    to an appropriate Python object. This is also the ideal way to validate complex
    input values. We'll look at the `point_type()` validation function int this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Evaluate the `parse_args()` method of the parser object created in step 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: By default, this uses the values from `sys.argv` , which are the command-line
    argument values entered by the user. We can provide an explicit argument if we
    need to modify the user-supplied command-line in some way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the final function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This relies on the `point_type()` validation function. This is needed because
    the default input type is defined by the `str()` function. This assures that the
    values of arguments will be string objects. We've provided the `type` argument
    so that we can inject a type conversion. We might use `type = int` or `type =
    float` to convert to a number.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we used `point_type()` to convert a string to a ( *latitude*
    , *longitude* ) two-tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This function parses the input values. First, it separates the two values at
    the `,` character. It attempts a floating-point conversion on each part. If the
    `float()` functions both work, we have a valid latitude and longitude that we
    can return as a pair of floating-point values.
  prefs: []
  type: TYPE_NORMAL
- en: If anything goes wrong, an exception will be raised. From this exception, we'll
    raise an `ArgumentTypeError` exception. This is used by the `argparse` module
    to report the error to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the main script that combines the option parser and the output display
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This main script does a few things to connect the user inputs to the displayed
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: Parse the command-line options. These are all present in the options object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the `p1` and `p2` ( *latitude* , *longitude* ) two-tuples into four individual
    variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Evaluate the `display()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The argument parser works in three stages:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the overall context by creating a parser object as an instance of `ArgumentParser`
    . We can provide information such as the overall program description. We can also
    provide a formatter and other options here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add individual arguments with the `add_argument()` method. These can include
    optional arguments as well as required arguments. Each argument can have a number
    of features to provide different kinds of syntax. We'll look at a number of the
    alternatives in the *There's more...* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parse the actual command-line inputs. The parser's `parse()` method will use
    `sys.argv` automatically. We can provide an explicit value instead of the `sys.argv`
    values. The most common reason for providing an override value is to allow for
    more complete unit testing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some simple programs will have a few optional arguments. A more complex program
    may have many optional arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s common to have a filename as a positional argument. When a program reads
    one or more files, the filenames are provided on the command line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve used the Linux shell''s **globbing** feature—the `*.rst` string is expanded
    into a list of all files that match the naming rule. This list of files can be
    processed using an argument defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: All of the names on the command line that do not start with the `-` character
    will be collected into the `file` value in the object built by the parser.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This will process each file given on the command line.
  prefs: []
  type: TYPE_NORMAL
- en: For Windows programs, the shell doesn't glob, and the application must deal
    with filenames that have wild card patterns in them. The Python `glob` module
    can help with this. Also, the `pathlib` module can create `Path` objects, which
    include globbing features.
  prefs: []
  type: TYPE_NORMAL
- en: We may have to make even more complex argument parsing options. Very complex
    applications may have dozens of individual commands. As an example, look at the
    `git` version-control program; this application uses dozens of separate commands
    such as `git clone` , `git commit` , or `git push` . Each of these commands has
    unique argument parsing requirements. We can use `argparse` to create a complex
    hierarchy of these commands and their distinct sets of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What kinds of arguments can we process? There are a lot of argument styles
    in common use. All of these variations are defined using the `add_argument()`
    method of a parser:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple options** : The `-o` or `--option` arguments are often used to enable
    or disable features of a program. These are often implemented with `add_argument()`
    parameters of `action=''store_true'', default=False` . Sometimes the implementation
    is simpler if the application uses `action=''store_false'', default=True` . The
    choice of default value and stored value may simplify the programming, but it
    won''t change the user''s experience.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simple options with non-trivial objects** : The user sees this is as simple
    `-o` or `--option` arguments. We may want to implement this using a more complex
    object that''s not a simple Boolean constant. We can use `action=''store_const'',
    const=some_object, default=another_object` . As modules, classes, and functions
    are also objects, a great deal of sophistication is available here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Options with values** : We showed `-r unit` as an argument that accepted
    the string name for the units to use. We implemented this with an `action=''store''`
    assignment to store the supplied string value. We can also use the `type=function`
    option to provide a function that validates or converts the input into a useful
    form.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Options that increment a counter** : One common technique is to have a debugging
    log that has multiple levels of detail. We can use `action=''count'', default=0`
    to count the number of times a given argument is present. The user can provide
    `-v` for verbose output and `-vv` for very verbose output. The argument parser
    treats `-vv` as two instances of the `-v` argument, which means that the value
    will increase from the initial value of `0` to `2` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Options that accumulate a list** : We might have an option for which the
    user might want to provide more than one value. We could, for example, use a list
    of distance values. We could have an argument definition with `action=''append'',
    default=[]` . This would allow the user to say `-r NM -r KM` to get a display
    in both nautical miles and kilometers. This would require a significant change
    to the `display()` function, of course, to handle multiple units in a collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Show the help text** : If we do nothing, then `-h` and `--help` will display
    a help message and exit. This will provide the user with useful information. We
    can disable this or change the argument string, if we need to. This is a widely
    used convention, so it seems best to do nothing so that it''s a feature of our
    program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Show the version number** : It''s common to have `--Version` as an argument
    to display the version number and exit. We implement this with `add_argument("--Version",
    action="version", version="v 3.14")` . We provide an action of `version` and an
    additional keyword argument that sets the version to display.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This covers most of the common cases for command-line argument processing. Generally,
    we'll try to leverage these common styles of arguments when we write our own applications.
    If we strive to use simple, widely used argument styles, our users are somewhat
    more likely to understand how our application works.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few Linux commands, which have even more complex command-line syntax.
    Some Linux programs, such as `find` or `expr` , have arguments that can't easily
    be processed by `argparse` . For these edge cases, we would need to write our
    own parser using the values of `sys.argv` directly.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We looked at how to get interactive user input in the *Using input() and getpass()
    for user input* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll look at a way to add even more flexibility to this in the *Using the OS
    environment settings*  recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using cmd for creating command-line applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several ways of creating interactive applications. The *Using input()
    and getpass() for user input* recipe looked at functions such as `input()` and
    `getpass.getpass()` . The *Using* *argparse to get command-line input* recipe
    showed how to use `argparse` to create applications with which a user can interact
    from the OS command line.
  prefs: []
  type: TYPE_NORMAL
- en: We have a third way to create interactive applications using the `cmd` module.
    This module will prompt the user for input, and then invoke a specific method
    of the class we provide.
  prefs: []
  type: TYPE_NORMAL
- en: This is related to material in [Chapter 7](text00079.html#page "Chapter 7. More
    Advanced Class Design") , *More Advanced Class Design* . We'll add features to
    a class definition to create a unique subclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how the interaction will look, we''ve marked user input like this:
    "`help` ":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: There's an introductory message from the application. It shows the player's
    starting stake, that is, how much they have to bet. The application displays a
    prompt, `Roulette>` . The user can then enter any of the five available commands.
  prefs: []
  type: TYPE_NORMAL
- en: When we enter `help` as a command, we see a display of the available commands.
    Only two have any documentation. The other three have no further details available.
  prefs: []
  type: TYPE_NORMAL
- en: When we enter `help bet` , we see the detailed documentation for the `bet` command.
    The description tells us to provide a bet name from the available six choices
    and a bet amount.
  prefs: []
  type: TYPE_NORMAL
- en: We create two bets—one on black and one on even. We then enter the `spin` command
    to spin the wheel. This displays the outcome—the number `21` —which is red, high,
    and odd. Both of our bets are losses.
  prefs: []
  type: TYPE_NORMAL
- en: We've omitted a few more interactions that didn't win very much, either. When
    we entered the `done` command, the final stake was shown. If the simulation was
    more detailed, it might also show some aggregate statistics on spins, wins, and
    losses.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The core feature of the `cmd.Cmd` application is a **read-evaluate-print loop**
    ( **REPL** ). This kind of application works well when there are a large number
    of individual state changes and a large number of commands to make those state
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use a simple simulation of a subset of the bets in *Roulette* as an
    example. The idea is to allow the user to create one or more bets and then spin
    a simulated *Roulette* wheel. While proper casino *Roulette* has a dizzying array
    of possible bets, we''ll focus on just six:'
  prefs: []
  type: TYPE_NORMAL
- en: red, black
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: even, odd
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: high, low
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An *American Roulette* wheel has 38 bins. The numbers 1 to 36 are colored red
    and black. There are two other bins, zero and double zero, which are green. These
    two extra bins are defined as neither even nor odd and neither high nor low. There
    are only a few ways to bet on the zeroes, but numerous ways to bet on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: We'll represent the *Roulette* wheel using some helper functions that build
    a collection of bins. Each bin will have a string that shows the number and a
    set of bet names that are winners.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define a generic bin with some simple rules to determine which bets
    are in the winning set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `roulette_bin()` function returns a two-tuple with the string representation
    for the bin number and a set of three winning propositions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `0` and `00` , we''ll need something a little different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `zero_bin()` function returns a string bin number and an empty set. The
    `zerozero_bin()` function returns a special string to show that it's `00` , plus
    the empty set to show that none of the defined bets are winners.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can combine the results of these three functions to create a complete *Roulette*
    wheel. The whole wheel will be modeled as a list of bin tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve built a simple list that contains the complete set of bins: a zero,
    a double zero, and the numbers 1 through 36\. We can now use the `random.choice()`
    function to select a bin at random. This will tell us which bets win and which
    bets lose.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the cmd module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Define an extension to `cmd.Cmd` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Define any initialization required in the `preloop()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This `preloop()` method is evaluated just once when the processing starts. We've
    used this to initialize a dictionary for bets and the player's stake. We also
    created an instance of the wheel collection. The self argument is a requirement
    for methods within a class. For now, it's a simply required syntax. In [Chapter
    6](text00070.html#page "Chapter 6. Basics of Classes and Objects") , *Basics of
    Classes and Objects* , we'll look at this more closely.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this is indented within the `class` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Initialization can also be done in the `__init__()` method. This is a bit more
    complex, though, because we have to use `super()` to ensure that the `Cmd` class
    initialization is done first.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each command, create a `do_command()` method. The name of the method will
    be the command, prefixed by `do_` . The user''s input text after the command will
    be provided as an argument value to the method. Here are two examples for the
    `bet` command and the `spin` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Parse and validate the arguments to each command. The user's input after the
    command will be provided as the value of the first positional argument to the
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the arguments are invalid, the method should print a message and return.
    If the arguments are valid, the method can continue past the validation step.
  prefs: []
  type: TYPE_NORMAL
- en: For our example, the `spin` command doesn't require any input. We can ignore
    the argument string. To be more complete, we might want to display an error if
    the string is non-empty.
  prefs: []
  type: TYPE_NORMAL
- en: The `bet` command, however, does have a bet, which must be one of the six valid
    bet names. We might want to check for duplicate bets. We might also want to check
    for abbreviated bet names. Each of six bets has a unique first letter.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an extension, a bet can also have an amount. We looked at parsing strings
    in the *String parsing with regular expressions* recipe in [Chapter 1](text00014.html#page
    "Chapter 1. Numbers, Strings, and Tuples") , *Numbers, Strings, and Tuples* .
    For this example, we''ll simply handle the name of the bet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the happy path processing for each command. For our example, the `spin`
    command will resolve the bets. The `bet` command will accumulate another bet.
    Here''s the `do_bet()` happy path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We've added the user's bet to the `self.bets` mapping with the amount. For this
    example, we'll treat all bets as having the same minimal amount.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the `do_spin()` happy path that resolves all of the bets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: First, we spun the wheel to get a winning bet. Then, we examined each of the
    player's bets to see which of those match the set of winning bets. If the player's
    bet, `b` , is in the set of winning bets, we'll increase their stake. Otherwise,
    we'll reduce their stake.
  prefs: []
  type: TYPE_NORMAL
- en: All of the bets in this example pay 1:1\. If we want to extend the example to
    other kinds of bets, we have to provide proper odds for the various bets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the main script. This will create an instance of this class and execute
    the `cmdloop()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We've created an instance of our `Roulette` subclass of `Cmd` . When we execute
    the `cmdloop()` method, the class will write any introductory messages that have
    been provided, write the prompt, and read a command.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Cmd` module contains a large number of built-in features for displaying
    a prompt, reading input from a user, and then locating the proper method based
    on the user's input.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when we enter `bet black` , the built-in methods of the `Cmd` superclass
    will strip the first word from the input, `bet` , prefix this with `do_` , and
    then evaluate the method that implements the command.
  prefs: []
  type: TYPE_NORMAL
- en: If there's no `do_bet()` method, the command processor writes an error message.
    This is done automatically, we don't need to write any code at all.
  prefs: []
  type: TYPE_NORMAL
- en: Since we wrote a `do_bet()` method, this will be invoked. The text after the
    command, `black` in this case, will be provided as the positional argument value.
  prefs: []
  type: TYPE_NORMAL
- en: Some methods, such as `do_help()` , are already part of the application. These
    methods will summarize the other `do_*` methods. When one of our methods has a
    docstring, this can be displayed by the built-in help feature.
  prefs: []
  type: TYPE_NORMAL
- en: The `Cmd` class relies on Python's facilities for introspection. An instance
    of the class can examine the method names to locate all of the methods that start
    with `do_` . They're available in a class-level `__dict__` attribute. Introspection
    is an advanced topic, one that will be touched on in [Chapter 7](text00079.html#page
    "Chapter 7. More Advanced Class Design") , *More Advanced Class Design* .
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Cmd` class has a number of additional places where we can add interactive
    features:'
  prefs: []
  type: TYPE_NORMAL
- en: We can define `help_*()` methods that become part of the miscellaneous help
    topics.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When any of the `do_*` methods return a value, the loop will end. We might want
    to add a `do_quit()` method that has `return True` as it's body. This will end
    the command-processing loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We might provide a method named `emptyline()` to respond to blank lines. One
    choice is to do nothing quietly. Another common choice is to have a default action
    that's taken when the user doesn't enter a command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `default()` method is evaluated when the user's input does not match any
    of the `do_*` methods. This might be used for more advanced parsing of the input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `postloop()` method can be used to do some processing just after the loop
    finishes. This would be a good place to write a summary. This also requires a
    `do_*` method that returns a value—any non-`False` value—to end the command loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also, there are a number of attributes we can set. These are class-level variables
    that would be peers to the method definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `prompt` attribute is the prompt string to write. For our example, we can
    do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The `intro` attribute is the introductory message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can tailor the help output by setting `doc_header` , `undoc_header` , `misc_header`
    , and `ruler` attributes. These will all alter how the help output looks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The goal is to be able to create a tidy class that handles user interaction
    in a way that's simple and flexible. This class creates an application that has
    a lot of features in common with Python's REPL. It also has features in common
    with many command-line programs that prompt for user input.
  prefs: []
  type: TYPE_NORMAL
- en: One example of these interactive applications is the command-line FTP client
    in Linux. It has a prompt of `ftp>` , and it parses dozens of individual FTP commands.
    Entering `help` will show all of the various internal commands that are part of
    FTP interaction.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll look at class definitions in [Chapter 6](text00070.html#page "Chapter 6. Basics
    of Classes and Objects") , *Basics of Classes and Objects* , and [Chapter 7](text00079.html#page
    "Chapter 7. More Advanced Class Design") , *More Advanced Class Design*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the OS environment settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several ways to look at the span of time for user inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Interactive data: This is provided by the user in a kind of *right now* time
    span.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Command-line arguments provided when the program is started: These values often
    span one full execution of a program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Environment variables set at the OS level: These can be set at the command
    line, making them almost as interactive as the command that starts an application:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can be configured for a user in a `.bashrc` file or `.profile` file. This
    makes them more persistent and slightly less interactive than the command-line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Windows, there's the **Advanced Settings** option that allows someone to
    set a long-term configuration. These are often inputs to multiple executions of
    a program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Configuration file settings: These vary widely by application. The idea is
    to edit a file and make these options or arguments available for long periods
    of time. These might apply to multiple users or even to all users. Configuration
    files often have the longest time span.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the *Using input() and getpass() for user input* and *Using cmd for creating
    command-line applications* recipes, we looked at interaction with the user. In
    the *Using* *argparse to get command-line input* recipe, we looked at how to handle
    command-line arguments. We'll look at configuration files in [Chapter 13](text00137.html#page
    "Chapter 13. Application Integration") , *Application integration* .
  prefs: []
  type: TYPE_NORMAL
- en: The environment variables are available through the `os` module. How can we
    have an application's configuration based on these OS-level settings?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We may want to provide information of various types to a program via OS settings.
    There''s a profound limitation here: the OS settings can only be string values.
    This means that many kinds of settings will require some code to parse the value
    and create proper Python objects from the string.'
  prefs: []
  type: TYPE_NORMAL
- en: When we work with `argparse` to parse command-line arguments, this module can
    do some data conversions for us. When we use `os` to process environment variables;
    we'll have to implement the conversion ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Using argparse to get command-line input* recipe, we wrapped the `haversine()`
    function in a simple application that parsed command-line arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the OS level, we created a program that worked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: After using this for a while, we've found that we're often using nautical miles
    to compute distances from where our boat is anchored. We'd really like to have
    default values for one of the input points as well as the `-r` argument.
  prefs: []
  type: TYPE_NORMAL
- en: Since a boat can be anchored in a variety of places, we need to change the default
    without having to tweak the actual code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll set set an OS environment variable, `UNITS` , with the distance units.
    We can set another variable, `HOME_PORT` , with the home point. We want to be
    able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The units and the home point values are provided to the application via the
    OS environment. This can be set in a configuration file so that we can make easy
    changes. It can also be set manually, as shown in the example.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the `os` module. The OS environment is available through this module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Import any other classes or object needed for the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a function that will use the environment values as defaults for optional
    command-line arguments. The default set of arguments to parse come from `sys.argv`
    , so it''s important to also import the `sys` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Gather default values from the OS environment settings. This includes any validation
    required:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `sys.exit()` function handles the error processing nicely. It will print
    the message and exit with a non-zero status code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `parser` attribute. Provide any default values for the relevant
    arguments. This depends on the `argparse` module, which must also be imported:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Do any additional validation to ensure that arguments are set properly. In
    this example, it''s possible to have no value for `HOME_PORT` and no value provided
    for the second command-line argument. This requires an `if` statement and a call
    to `sys.exit()` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Return the `options` object with the set of valid arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This will allow the `-r` argument and the second point to be completely optional.
    The argument parser will use the configuration information to supply default values
    if these are omitted from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Use the *Using argparse to get command-line input* recipe for ways to process
    the options created by the `get_options()` function.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've used the OS environment variables to create default values that can be
    overridden by command-line arguments. If the environment variable is set, that
    string is provided as the default to the argument definition. If the environment
    variable is not set, then an application-level default value is used.
  prefs: []
  type: TYPE_NORMAL
- en: In the instance of the `UNITS` variable, the application uses kilometers as
    the default if not, then the OS environment variable is set.
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives us three tiers of interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: We can define a setting in a `.bashrc` file. Alternatively, we can use the Windows
    **Advanced Settings** option to make a change that is persistent. This value will
    be used each time we log in or create a new command window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can set the OS environment interactively at the command line. This will last
    as long as our session lasts. When we logout, or close the command window, this
    value will be lost.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can provide a unique value through the command-line arguments each time the
    program is run.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that there's no built-in or automatic validation of the values retrieved
    from environment variables. We'll need to validate these strings to ensure that
    they're meaningful.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that we've repeated the list of valid units in several places. This
    violates the **Don't Repeat Yourself** ( **DRY** ) principle. A global variable
    with this list is a good improvement to make.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using argparse to get command-line input* recipe shows a slightly different
    way to handle the default command-line arguments available from `sys.argv` . The
    first of the arguments is the name of the Python application being executed and
    is not often relevant to argument parsing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The value of `sys.argv` will be a list of strings as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to skip the initial value in `sys.argv[0]` at some point in the processing.
    We have two choices:'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we discard the extra item as late as possible in the parsing
    process. The first item is skipped when providing `sys.argv[1:]` to the parser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the previous example, we discarded the value earlier in the processing. The
    `main()` function used `options = get_options(sys.argv[1:])` to provide the shorter
    list to the parser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generally, the only relevant distinction between the two approaches depends
    on the number and complexity of the unit tests. This recipe will require a unit
    test that includes an initial argument string, which will be discarded during
    parsing.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll look at numerous ways to handle configuration files in [Chapter 13](text00137.html#page
    "Chapter 13. Application Integration") , *Application integration*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](image/614271.jpg)'
  prefs: []
  type: TYPE_IMG
