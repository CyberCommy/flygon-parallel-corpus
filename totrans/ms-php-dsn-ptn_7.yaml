- en: Chapter 7. Refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book I have largely focused on using design patterns to address
    new code that you write; this is critical, it is vital that developers don't write
    the new legacy, improving your own code is vital before critiquing the code of
    others. Developers must first seek to understand how to code before they themselves
    may refactor code effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter shall be heavily based on *Refactoring: Improving the Design of
    Existing Code* by *Martin Fowler* et al alongside *Refactoring To Patterns* by
    *Joshua Kerievsky*. I would highly recommend reading these books if you are interested
    in learning more about this subject.'
  prefs: []
  type: TYPE_NORMAL
- en: What is refactoring?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A key theme in refactoring code is addressing issues within the internal structure
    of code while not altering the external behavior of the program being refactored.
    In some cases, this can mean introducing internal structure where it previously
    wasn't intentional or thought about before.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring as a process improves the design of code after it is written. While
    design is a critical phase of the software engineering process, it is often disregarded
    (not least in PHP); in addition to this, maintaining the structure of code over
    the long-term requires a continued understanding of the design of software. If
    a developer takes up a project without understanding how it was originally designed,
    they may develop upon it in a very crude fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 'In **Extreme Programming** (**XP**), a phrase known as *Refactor Mercilessly*
    is used, it is self-explanatory. In XP, refactoring is proposed as a mechanism
    to keep software design as simple as possible and to avoid needless complexity.
    As is stated in the rules of XP: *Make sure everything is expressed once and only
    once. In the end it takes less time to produce a system that is well groomed*.'
  prefs: []
  type: TYPE_NORMAL
- en: A key tenet of refactoring is finding the software design as if it is something
    to be discovered instead of being created upfront. When developing a system, we
    can use development as a mechanism of finding a good design solution. By using
    refactoring, we are able to ensure that a system stays good as systems are developed,
    thus we are able to keep technical debt down.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring isn't always possible, you may occasionally encounter *black-box*
    systems which you cannot alter, indeed you may even need to encapsulate a system
    in order to rewrite it. There are, however, many cases in which we can simply
    refactor code to improve the design.
  prefs: []
  type: TYPE_NORMAL
- en: Test, test, and test again
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is no way around this, in order to refactor code, you need a solid set
    of tests. Refactoring code may well reduce the chances of introducing bugs, but
    changing the design of code introduces a significant amount of chances to introduce
    new bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Unintended side-effects will occur during refactoring, where classes are tightly
    coupled, you may well find making a minor change to one function leading to a
    negative side-effect in a completely separate class.
  prefs: []
  type: TYPE_NORMAL
- en: Good refactoring effects require good tests. There is simply no way around this.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this, from a more political standpoint, some companies which
    have encountered the bad effects of repetitively bad refactoring efforts may become
    reluctant to refactor code; ensuring there are good tests in place allows the
    company to ensure a refactoring effort won't break functionality.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter I will demonstrate refactoring efforts which should be accompanied
    with testing efforts using unit tests, in the next (and final) chapter of this
    book, I will discuss behavioral tests (for use in BDD). Unit tests are the best
    mechanism developers have for testing a given unit of code; unit tests complement
    code structure, prove methods do what they should, and test interaction between
    units of code; in this sense, they are the best form of testing at the disposal
    of a developer in a refactoring effort. Behavioral tests however are there to
    test the behavior of code, thus are useful in order to demonstrate an application
    can successfully complete a given form of behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Every seasoned developer will have memories of painful debugging tasks; sometimes
    long into the night. Let's think about how most developers work on a day-to-day
    basis. They don't code all the time, some of their time is spent around designing
    code while a considerable amount of time is spent debugging code they've already
    written. Having self-testing code can rapidly reduce this burden.
  prefs: []
  type: TYPE_NORMAL
- en: Test-Driven Development centers around a methodology of writing a test before
    writing functionality, indeed the code should match the test.
  prefs: []
  type: TYPE_NORMAL
- en: When testing classes, be sure to test the `public` interface of the class; indeed,
    PHPUnit will not allow you to test `private` or `protected` methods under ordinary
    usage.
  prefs: []
  type: TYPE_NORMAL
- en: Code smells
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Code smells** are essentially bits of bad practice that make your code needlessly
    harder to understand, bad code may be refactored away using the techniques expressed
    in this chapter. Code smells can usually violate somewhat fundamental software
    design principles and accordingly, can negatively impact design quality of the
    overall code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Martin Fowler defined code smell by stating the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"a code smell is a surface indication that usually corresponds to a deeper
    problem in the system".*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: At the start of this book we discussed the term *technical debt*, in this sense,
    code smells can contribute to *technical debt* as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: Code smell may not necessarily constitute a bug, it won't stop the execution
    of a program, but it can aid the process of introducing bugs later on and make
    it harder to refactor code to an appropriate design.
  prefs: []
  type: TYPE_NORMAL
- en: Let's cover some fundamental code smells that you may encounter when dealing
    with legacy PHP projects.
  prefs: []
  type: TYPE_NORMAL
- en: We will address some code smells and how to address them in quite simplistic
    ways, but now let us consider some slightly more significant, recurring patterns
    and how these can be addressed by applying design patterns in order to simplify
    the maintenance of code going forward.
  prefs: []
  type: TYPE_NORMAL
- en: Here we will specifically talk about refactoring *to* patterns, in some cases,
    you may benefit from refactoring *from* patterns when it simplifies the design
    of the code. The recurring theme in this chapter surrounds how the design of code
    lives throughout the development life cycle of the code, it isn't merely discarded
    after an arbitrary design phase.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns can be used to communicate intention, they can serve as the language
    between developers; this is why knowing and continuing to use a large body of
    patterns is vital throughout the career of a software engineer.
  prefs: []
  type: TYPE_NORMAL
- en: Many more of these approaches are available in the book *Refactoring To Patterns*,
    here I have handpicked the ones most appropriate to PHP developers.
  prefs: []
  type: TYPE_NORMAL
- en: Long methods and duplicated code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Duplicated code is a very common code smell. Developers will frequently copy
    and paste code instead of using an appropriate control structure for their application.
    If the same control structure is in more than one place, your code will benefit
    by merging the two structures into one.
  prefs: []
  type: TYPE_NORMAL
- en: If duplicated code is identical, you can use the extract method. So what is
    the extract method? In essence, the **extract method** is merely removing business
    logic that is vested in long functions into smaller functions.
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine a `dice` class, once the dice is rolled it will return a random
    number between 1 and 6 in Roman numerals.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Legacy` class can look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s extract the method to convert a random number into a Roman numeral and
    put it into a separate function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There are merely two changes we have made to the original code block, we have
    separated out that function which performs Roman numeral conversion and put it
    in a separate function. We have replaced that inline comment with a DocBlock for
    the function itself.
  prefs: []
  type: TYPE_NORMAL
- en: This approach can be used for duplication, if it exists in more than one place
    (and is identical), we simply call a single function instead of having the code
    duplicated across multiple places.
  prefs: []
  type: TYPE_NORMAL
- en: If the code is in unrelated classes, see where it logically fits (in either
    of the classes or a separate class) and extract it there.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier in this book, we have already discussed the need to keep functions small.
    This is absolutely vital for ensuring your code is readable in the long term.
  prefs: []
  type: TYPE_NORMAL
- en: I frequently see developers comment blocks of code within functions; instead,
    why not break out these methods into their own functions? Readable documentation
    may then be added through DocBlocks. Thus, the extract method we are using here
    to address duplicated code can have a much simpler use; breaking up long methods.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to various business problems are far easier shared when dealing with
    smaller methods.
  prefs: []
  type: TYPE_NORMAL
- en: Large class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Large classes often emerge as a violation of the Single Responsibility Principle.
    Does the class you are dealing with, at a given point in time, have only one reason
    to change? A class should only have responsibility over a single part of the functionality,
    furthermore, that class should entirely encapsulate that responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: Dividing up the class into multiple classes by extracting methods which don't
    narrowly align to single responsibility is an easy and effective way to help mitigate
    this code smell.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing complex logical statements and switch statements with polymorphism
    or the Strategy Pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Switch statements (or endlessly large if statements, for that matter) can largely
    be removed by using polymorphic behavior; I have described polymorphism in the
    early chapters of this book and it provides a far more elegant way of dealing
    with computational problems than using switch statements.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you were switching on a country code; US or GB, instead of switching
    in such a fashion, by using polymorphism you can run the same method.
  prefs: []
  type: TYPE_NORMAL
- en: Where polymorphic behavior is not possible (for example, where there isn't a
    common interface), in some cases you may even benefit by replacing type code with
    strategy; effectively you are able to consolidate the multiple switch statements
    into merely injecting a class into the constructor of a client which will handle
    the relation to the individual classes itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example; let''s suppose we have an Output interface, this interface is
    implemented by various other classes that contain a `load` method. This `load`
    method allows us to inject an array and we get back some data in the format we
    requested. These classes are incredibly crude implementations of that behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time fo writing, PHP still deems the `xmlrpc_encode` function to be experimental,
    for this reason, I would advise against its use in production. It's just here
    purely for demonstration purposes (in order to keep the code short).
  prefs: []
  type: TYPE_NORMAL
- en: 'An incredibly crude implementation with a `switch` statement could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'But clearly we can do a lot by, instead, implementing a client that will allow
    us to inject an `Output` class into a `Client` and accordingly allow us to receive
    the output. Such a class may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now utilize this client in a very simple fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Duplicating code following a single control structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I won't reiterate here how the Template design pattern works, but what I want
    to explain is that it can be used to help eliminate duplicate code.
  prefs: []
  type: TYPE_NORMAL
- en: The Template design pattern I demonstrated earlier in this book allowed us to
    effectively abstract away the structure of a program, we then just populated the
    methods specific to an implementation. This can help us reduce code duplication
    by avoiding repeating a single control structure over and over.
  prefs: []
  type: TYPE_NORMAL
- en: Long Parameter List and primitive obsession
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Primitive obsession is where developers over-use primitive data types instead
    of using objects.
  prefs: []
  type: TYPE_NORMAL
- en: PHP supports eight primitive types; this group can further be subdivided into
    scalar types, compound types, and special types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scalar types are the data types which hold a single value. You can recognize
    them if you ask yourself "can this value be on a scale?" A number can be on a
    scale from *X* to *Y* and a Boolean could be on a scale from false to true. Here
    are some examples of scalar types:'
  prefs: []
  type: TYPE_NORMAL
- en: Boolean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Float
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Compound types consist of a set of scalar values:'
  prefs: []
  type: TYPE_NORMAL
- en: Array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Special types are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Resource (references an external resource)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NULL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Suppose we have a simple `Salary` calculator class, it takes an employee''s
    base salary, commission rate, and pension rate; after this data is sent, the `calculate`
    method can be used to input the amount of sales they have made to calculate their
    total salary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note how long that constructor is. Yes, we could use the Builder pattern to
    create an object which we can then inject into the constructor, but in this case,
    we are able to specifically abstract away the complicated information. In this
    case, if we were to move the employee information to a separate class we could
    ensure better compliance with the Single Responsibility Principle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to separate out the responsibilities of the class so that
    we can separate the responsibilities of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'From this point, we can simplify the constructor of our `Salary` class so that
    it only needs to input the `Employee` object for us to be able to use the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Indecent exposure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s suppose we have a `Human` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We are able to set the values as we please, with no validation and no unified
    way of getting information. What's so wrong with this? Well, in object orientation,
    the principle of encapsulation is vital; we hide data. In other words, our data
    should never be made visible without the owning object knowing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we substitute all the `public` data variables with `private` ones.
    In addition to this we add appropriate methods to get and set the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Be sure to ensure that setters and getters are logical and are not there merely
    because a class property exists. After this is complete you will need to go through
    your application and substitute any direct access to variables so that they go
    through the appropriate methods first.
  prefs: []
  type: TYPE_NORMAL
- en: This has, however, now exposed another code smell; feature envy.
  prefs: []
  type: TYPE_NORMAL
- en: Feature envy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Loosely, **feature envy** is where we don't get an object to do calculation
    of its own properties and instead offset that to another class.
  prefs: []
  type: TYPE_NORMAL
- en: 'So in the previous example we had our own `Salary` calculator class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead let''s take a look at implementing this function into the `Employee`
    class itself, as a result we can also disregard the unnecessary getters and keep
    our properties rightfully internalized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Inappropriate intimacy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This may frequently occur with inheritance; Martin Fowler elegantly puts it
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Subclasses are always going to know more about their parents than their parents
    would like them to know."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: More generally; when a field is used more in another class than the class itself,
    we can use the move field method to create a field in a new class, then redirect
    users of that field to the new class.
  prefs: []
  type: TYPE_NORMAL
- en: We can combine this with the move method, whereby we place a function in the
    class that uses it most and remove it from the original class, if that isn't possible
    we can get away with simply referencing the function in the new class.
  prefs: []
  type: TYPE_NORMAL
- en: Deeply nested statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Nested if statements are messy and ugly. This causes spaghetti logic that is
    difficult to follow; instead use inline function calls.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from the inner-most code block, seek to extract that code into its
    own function where it can live happily. In [Chapter 1](ch01.html "Chapter 1. Why
    "Good PHP Developer" Isnt an Oxymoron"), *Why "Good PHP Developer" Isn't an Oxymoron*
    we discussed how this can be achieved with an example, but if you're refactoring
    frequently you might want to consider investing in a tool which can help you with
    this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a tip for the PHPStorm users among us: there is a lovely little option
    within the Refactor menu that can do this for you automatically. Simply highlight
    the code block you wish to extract, go to Refactor in the menu bar then click
    Extract>Method. A dialog will then pop up allowing you to configure how you want
    the refactoring to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deeply nested statements](graphics/image_07_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Remove assignments to parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Try to avoid setting a parameter in the body of a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be done correctly by setting an internal parameter instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: By doing such behavior we are able to easily identify and extract repetitive
    code going forward, in addition to this it allows easier code replacement when
    maintaining this code later.
  prefs: []
  type: TYPE_NORMAL
- en: This is a simple tweak which allows us to identify what particular parameters
    in our code are doing.
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Comments aren''t a code smell per-se, in many cases, comments are hugely beneficial.
    As Martin Fowler states:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"In our olfactory analogy, comments aren''t a bad smell; indeed they are a
    sweet smell."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: However, Fowler goes on to demonstrate how comments may be used as the deodorant
    to hide code smells. When you find yourself commenting code blocks within functions
    you can find a good opportunity to use the extract method.
  prefs: []
  type: TYPE_NORMAL
- en: If a comment is hiding a bad smell, refactor the smell away and you will soon
    find the original comment being superfluous. This isn't an excuse not to DocBlock
    your function or needlessly go on a hunt for code comments, but it is important
    to remember that specific comments may become useless when you refactor a design
    to be far more simplistic.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulating Composite with Builder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed earlier in this book, the Builder design pattern can work by us
    taking a long set of arguments and turning them into a single object which we
    can then throw into the constructor of another class.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we have a class called `APIBuilder`, this builder class can then
    itself be instantiated with the API key and secret of the API, but once it's instantiated
    as an object, we can simply pass the entire object into the constructor of another
    class.
  prefs: []
  type: TYPE_NORMAL
- en: So far, so good; but we can use this Builder pattern to encapsulate the Composite
    pattern. We effectively just create a Builder to create our items. By doing this
    we have greater control with a single class offering us an opportunity to navigate
    and alter the entire tree structure of the Composite family.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing hard-coded notifications with Observer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Hard-coded notifications are usually where two classes are tightly coupled
    together in order for one to be able to notify the other. Instead, by using the
    `SplObserver` and `SplSubject` interfaces, the Observer can update the subject
    using a far more pluggable. After implementing an `update` method in the Observer,
    the subject merely needs to implement the `Subject` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The resulting architecture is a far more pluggable notification system which
    is not tightly coupled.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing one/many distinctions with Composite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Where we have separate logic for handing individuals to groups, we can consolidate
    these using the Composite pattern. This is a pattern we have covered earlier this
    book; in order to consolidate to this pattern, a developer needs only alter their
    code so that one class can handle both forms of data.
  prefs: []
  type: TYPE_NORMAL
- en: In order to achieve this, we must first ensure both the distinctions implement
    the same interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'When I initially demonstrated this pattern, I wrote about how this pattern
    can be used to address treating a single song and a playlist as one. Suppose our
    `Music` interface is purely the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The critical task is just ensuring that this interface is abided by for both
    the one and the many distinctions. Both your `Song` class and your `Playlist`
    class must implement the `Music` interface. This is fundamentally what allows
    us to treat both with the behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Separate versions with Adapters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I won't dwell on Adapters for long due to how thoroughly I covered them earlier
    in this book, but I just want you to consider that they can be used for supporting
    different versions of APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure not to wrap code together in the same class for multiple API versions
    instead, you can abstract these differences from version-to-version to an Adapter.
    When using this approach, I would urge you to initially attempt to use an encapsulation
    approach rather than an inheritance-based approach as this will provide greater
    freedom going forward.
  prefs: []
  type: TYPE_NORMAL
- en: What do I tell my manager?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refactoring and then adding functionality can often be faster than simply adding
    the functionality while adding value to the existing code base. Many good managers,
    who properly understand software and how it is developed will understand this.
  prefs: []
  type: TYPE_NORMAL
- en: Of course there are managers who are clueless about what software actually is,
    they are often driven solely by deadlines and may be reluctant to learn more about
    their subject field. I am talking about the horror story developers I have mentioned
    earlier in this book. Sometimes, *Scrum Masters* are also guilty of this, due
    to the fact they may not be able to relate to the entire software development
    life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'As Martin Fowler himself put it:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Of course, many people say they are driven by quality but are more driven
    by schedule. In these cases I give my more controversial advice: Don''t tell!"*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Managers who don't properly understand technical processes may be intent on
    delivering on the basis of how rapidly software can be produced; refactoring can
    prove to be the most rapid way of helping produce software. It provides an efficient
    and thorough way to get up to speed with a project and allows us to smooth the
    process of injecting in new functionality.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss management and how projects can be effectively managed in the
    next chapter of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've discussed some methods of refactoring code to ensure
    the design is always of a good quality. By refactoring code, we can gain a greater
    understanding of our code base and future-proof it for the additional functionality
    that we add to the software.
  prefs: []
  type: TYPE_NORMAL
- en: Simplification and breaking down the problems you face are two of the best fundamental
    tools you can use when refactoring code.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using a CI environment, having PHP Mess Detector (PHPMD) running
    on that environment can also help you code better.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, I will discuss how we can use design patterns appropriately,
    starting off with a quick lesson on developing APIs in the context of a network.
  prefs: []
  type: TYPE_NORMAL
