- en: Control Flow Statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter describes one particular kind of Java statement, called control
    statements, which allow the building of a program flow according to the logic
    of the implemented algorithm, which includes selection statements, iteration statements,
    branching statements, and exception handling statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a control flow?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Selection statements: `if`, `if....else`, `switch...case`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Iteration statements: `for`, `while`, `do...while`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Branching statements: `break`, `continue`, `return`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exception handling statements: `try...catch...finally`, `throw`, `assert`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise – Infinite loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a control flow?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Java program is a sequence of statements that can be executed and produce
    some data or/and initiate some actions. To make the program more generic, some
    statements are executed conditionally, based on the result of an expression evaluation.  Such
    statements are called control flow statements because, in computer science, control
    flow (or flow of control) is the order in which individual statements are executed
    or evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: By convention, they are divided into four groups: selection statements, iteration
    statements, branching statements, and exception handling statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following sections, we will use the term block, which means a sequence
    of statements enclosed in braces. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: x = 42;
  prefs: []
  type: TYPE_NORMAL
- en: y = method(7, x);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("Example");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: A block can also include control statements – a doll inside a doll, inside a
    doll, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Selection statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The control flow statements of the selection statements group are based on
    an expression evaluation. For example, here is one possible format: `if(expression)
    do something`. Or, another possible format: `if(expression) {do something} else
    {do something else}`.'
  prefs: []
  type: TYPE_NORMAL
- en: The expression may return a `boolean` value (as in the previous examples) or
    a specific value that can be compared with a constant. In the latter case, the
    selection statement has the format of a `switch` statement, which executes the
    statement or block that is associated with a particular constant value.
  prefs: []
  type: TYPE_NORMAL
- en: Iteration statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Iteration statements execute a certain statement or block until a certain condition
    is reached. For example, it can be a `for` statement that executes a statement
    or a block for each value of a collection of values, or until a certain counter
    reaches the predefined threshold, or some other condition is reached. Each cycle
    of the execution is called an iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Branching statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Branching statements allow for breaking the current flow of the execution and
    continue executing from the first line after the current block, or from a certain
    (labeled) point in the control flow.
  prefs: []
  type: TYPE_NORMAL
- en: A `return` statement in a method is also an example of a branching statement.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exceptions are classes that represent events that happen during program execution
    and disrupt the normal execution flow. We have already seen examples of `NullPointerException`,
    `ClassCastException`, and `ArrayIndexOutOfBoundsException` generated under the
    corresponding conditions.
  prefs: []
  type: TYPE_NORMAL
- en: All the exception classes in Java have a common parent, the `java.lang.Exception`
    class, which in turn extends the `java.lang.Throwable` class. That's why all exception
    objects have common behaviors. They contain information about the cause of the
    exceptional condition and the location of its origination (line number of the
    class source code).
  prefs: []
  type: TYPE_NORMAL
- en: Each exception can be thrown either automatically (by JVM) or by the application
    code using the `throw` keyword. The method caller can catch the exception using
    the exception statements and perform some action based on the exception type and
    the message it (optionally) carries, or it can let the exception propagate further
    up the method call stack.
  prefs: []
  type: TYPE_NORMAL
- en: If none of the application methods in the stack catches the exception, it will
    eventually be caught by the JVM which will abort the application execution with
    an error.
  prefs: []
  type: TYPE_NORMAL
- en: So, the purpose of the exception handling statements is to generate (`throw`)
    and `catch` the exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Selection statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The selection statements have four variations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if` statement'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if...else` statement'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if...else if-...-else` statement'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`switch...case` statement'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The simple `if` statement allows executing a certain statement or block conditionally,
    only when the result of the expression evaluation is `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: if(booelan expression){
  prefs: []
  type: TYPE_NORMAL
- en: //do something
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: 'if(true) System.out.println("true");    //1: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'if(false) System.out.println("false");  //2:'
  prefs: []
  type: TYPE_NORMAL
- en: int x = 1, y = 5;
  prefs: []
  type: TYPE_NORMAL
- en: 'if(x > y) System.out.println("x > y");  //3:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if(x < y) System.out.println("x < y");  //4: x < y'
  prefs: []
  type: TYPE_NORMAL
- en: 'if((x + 5) > y) {                       //5: x + 5 > y'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("x + 5 > y");
  prefs: []
  type: TYPE_NORMAL
- en: x = y;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'if(x == y){                             //6: x == y'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("x == y");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Statement 1 prints `true`. Statements 2 and 3 print nothing. Statement 4 prints
    `x < y`. Statement 5 prints `x + 5 > y`. We used braces to create a block because
    we wanted the `x = y` statement to be executed only when the expression of this
    `if` statement evaluates to `true`. Statement 6 prints `x == y`. We could avoid
    using braces here because there is only one statement to execute. We did it for
    two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate that braces can be used with a single statement too, thus forming
    a block of one statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is a good practice, in general, to have braces after `if`; it reads better
    and helps to avoid this frustrating error: you add another statement after if,
    assuming it is going to be executed only when the expression returns `true`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: if(x > y) System.out.println("x > y");
  prefs: []
  type: TYPE_NORMAL
- en: x = y;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: But, the statement `x = y` in this code is executed unconditionally. If you
    think such an error doesn't happen very often, you will be surprised.
  prefs: []
  type: TYPE_NORMAL
- en: It is a good practice to always use braces `{}` with an `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have mentioned already, it is possible to include a selection statement
    inside the selection statement to create a more refined logic for the control
    flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: if(x > y){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("x > y");
  prefs: []
  type: TYPE_NORMAL
- en: if(x == 3){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("x == 3");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if(y == 3){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("y == 3");
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("x == " + x);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: It can go as deep (nested) as the logic requires.
  prefs: []
  type: TYPE_NORMAL
- en: if...else
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `if...else` construct allows executing a certain statement or block if
    the expression evaluates to `true`; otherwise, another statement or block is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: if(Boolean expression){
  prefs: []
  type: TYPE_NORMAL
- en: //do something
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: //do something else
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are two examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int x = 1, y = 1;
  prefs: []
  type: TYPE_NORMAL
- en: if(x == y){
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("x == y");  //prints: x == y'
  prefs: []
  type: TYPE_NORMAL
- en: x = y - 1;
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("x != y");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if(x == y){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("x == y");
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("x != y");  //prints: x != y'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: You can see how easy it is to read this code when the braces `{}` are used consistently.
    And, as in the previous case of a simple `if` statement, each block can have another
    nested block with another `if` statement, and so on – as many blocks and as deeply nested
    as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: if...else if-...-else
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use this form to avoid creating nested blocks and make the code easier
    to read and understand. For example, look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: if(n > 5){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("n > 5");
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: if (n == 5) {
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("n == 5");
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: if (n == 4) {
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("n == 4");
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("n < 4");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'These nested `if...else` statements can be replaced by `if...else...if` statements
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: if(n > 5){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("n > 5");
  prefs: []
  type: TYPE_NORMAL
- en: '} else if (n == 5) {'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("n == 5");
  prefs: []
  type: TYPE_NORMAL
- en: '} else if (n == 4) {'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("n == 4");
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("n < 4");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Such code is easier to read and understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t need to do anything when `n < 4`, you can leave out the last
    catch-all-the-rest-options `else` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: if(n > 5){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("n > 5");
  prefs: []
  type: TYPE_NORMAL
- en: '} else if (n == 5) {'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("n == 5");
  prefs: []
  type: TYPE_NORMAL
- en: '} else if (n == 4) {'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("n == 4");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to do something for each particular value, you can write, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: if(x == 5){
  prefs: []
  type: TYPE_NORMAL
- en: //do something
  prefs: []
  type: TYPE_NORMAL
- en: '} else if (x == 7) {'
  prefs: []
  type: TYPE_NORMAL
- en: //do something else
  prefs: []
  type: TYPE_NORMAL
- en: '} else if (x == 12) {'
  prefs: []
  type: TYPE_NORMAL
- en: //do something different
  prefs: []
  type: TYPE_NORMAL
- en: '} else if (x = 50) {'
  prefs: []
  type: TYPE_NORMAL
- en: //do something yet more different
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: //do something completely different
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: But there is a dedicated selection statement for such cases, called `switch...case`,
    which is easier to read and understand.
  prefs: []
  type: TYPE_NORMAL
- en: switch...case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The previous code example of the last section can be expressed as a `switch`
    statement, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: switch(x){
  prefs: []
  type: TYPE_NORMAL
- en: 'case 5:'
  prefs: []
  type: TYPE_NORMAL
- en: //do something
  prefs: []
  type: TYPE_NORMAL
- en: break;
  prefs: []
  type: TYPE_NORMAL
- en: 'case 7:'
  prefs: []
  type: TYPE_NORMAL
- en: //do something else
  prefs: []
  type: TYPE_NORMAL
- en: break;
  prefs: []
  type: TYPE_NORMAL
- en: 'case 12:'
  prefs: []
  type: TYPE_NORMAL
- en: //do something different
  prefs: []
  type: TYPE_NORMAL
- en: break;
  prefs: []
  type: TYPE_NORMAL
- en: 'case 50:'
  prefs: []
  type: TYPE_NORMAL
- en: //do something yet more different
  prefs: []
  type: TYPE_NORMAL
- en: break;
  prefs: []
  type: TYPE_NORMAL
- en: 'default:'
  prefs: []
  type: TYPE_NORMAL
- en: //do something completely different
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The type of the expression that returns the value of the `x` variable can be
    either `char`, `byte`, `short`, `int`, `Character`, `Byte`, `Short`, `Integer`,
    `String`, or an `enum` type. Notice the `break` keyword. It forces the exit from
    the `switch...case` statement. Without it, the following statement, `do something`,
    would be executed. We will talk about the `break` statement in the *Branching
    statements* section later.
  prefs: []
  type: TYPE_NORMAL
- en: The types that can be used in a `switch` statement are `char`, `byte`, `short`, `int`, `Character`, `Byte`, `Short`, `Integer`, `String`,
    and an `enum` type. The value set in a case clause has to be a constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a method that takes advantage of the `switch` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void switchDemo(int n){
  prefs: []
  type: TYPE_NORMAL
- en: switch(n + 1){
  prefs: []
  type: TYPE_NORMAL
- en: 'case 1:'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("case 1: " + n);'
  prefs: []
  type: TYPE_NORMAL
- en: break;
  prefs: []
  type: TYPE_NORMAL
- en: 'case 2:'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("case 2: " + n);'
  prefs: []
  type: TYPE_NORMAL
- en: break;
  prefs: []
  type: TYPE_NORMAL
- en: 'default:'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("default: " + n);'
  prefs: []
  type: TYPE_NORMAL
- en: break;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code demonstrates how the `switch` statement works:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: 'switchDemo(0);     //prints: case1: 0'
  prefs: []
  type: TYPE_NORMAL
- en: 'switchDemo(1);     //prints: case2: 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'switchDemo(2);     //prints: default: 2'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'And, similar to the `else` clause in an `if` statement, the default clause
    is not required in a `switch` statement if it is not needed for the program logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: switch(n + 1){
  prefs: []
  type: TYPE_NORMAL
- en: 'case 1:'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("case 1: " + n);'
  prefs: []
  type: TYPE_NORMAL
- en: break;
  prefs: []
  type: TYPE_NORMAL
- en: 'case 2:'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("case 2: " + n);'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Iteration statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Iteration statements are as fundamental for Java programming as selection statements.
    There is a good chance you will see and use them very often, too. Each iteration
    statement can be one of three forms: `while`, `do...while`, or `for`.
  prefs: []
  type: TYPE_NORMAL
- en: while
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `while` statement executes a Boolean expression and a statement or a block
    repeatedly until the value of the expression evaluates as `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: while (Boolean expression){
  prefs: []
  type: TYPE_NORMAL
- en: //do something
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two things to note:'
  prefs: []
  type: TYPE_NORMAL
- en: Braces `{}` are not necessary when only one statement has to be repeatedly executed,
    but are recommended for consistency and better code understanding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The statement may not be executed at all (when the very first expression evaluation
    returns `false`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at some examples. The following loop executes the printing statement
    five times:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int i = 0;
  prefs: []
  type: TYPE_NORMAL
- en: while(i++ < 5){
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.print(i + " ");   //prints: 1 2 3 4 5'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Notice a different method used for printing: `print()` instead of `println()`.
    The latter adds an escape sequence `\n` after the printed line (we have explained
    what an escape sequence is in [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml),
    *Java Language Elements and Types*), which moves the cursor to the next line.
  prefs: []
  type: TYPE_NORMAL
- en: 'And here is an example of calling a method that returns some value which is
    accumulated until the required threshold is reached:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: double result = 0d;
  prefs: []
  type: TYPE_NORMAL
- en: while (result < 1d){
  prefs: []
  type: TYPE_NORMAL
- en: result += tryAndGetValue();
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(result);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `tryAndGetValue()` method is very simple and unrealistic, written only
    for demo purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: double tryAndGetValue(){
  prefs: []
  type: TYPE_NORMAL
- en: return Math.random();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the last `while` statement, we will see something similar to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fab4ec67-c60b-4037-a459-37af35dbc04d.png)'
  prefs: []
  type: TYPE_IMG
- en: The exact values will vary from run to run because the `Math.random()` method
    generates pseudo-random `double` values greater than or equal to 0.0 and less
    than 1.0\. As soon as an accumulated value becomes equal to 1.0 or exceeds it,
    the loop exits.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is tempting to make this loop simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: double result = 0d;
  prefs: []
  type: TYPE_NORMAL
- en: while ((result += tryAndGetValue()) < 1d){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(result);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or even simpler yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: double result = 0d;
  prefs: []
  type: TYPE_NORMAL
- en: while ((result += Math.random()) < 1d){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(result);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'But if we run any of the last two `while` statement variations, we will get
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/08d31c48-80e3-42d0-89ce-c6634ee01f5d.png)'
  prefs: []
  type: TYPE_IMG
- en: The printed value will never be equal or exceed 1.0 because the expression with
    the newly accumulated value is evaluated before entering the execution block.
    That is something to keep an eye on when the calculations are included in the
    expression, not in the execution block.
  prefs: []
  type: TYPE_NORMAL
- en: do...while
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similarly to the `while` statement, the `do...while` statement executes the
    Boolean expression repeatedly and the statement or block until the value of the
    Boolean expression evaluates as `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: do {
  prefs: []
  type: TYPE_NORMAL
- en: //statement or block
  prefs: []
  type: TYPE_NORMAL
- en: '} while (Boolean expression)'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: But it executes the statement or the block first before the expression is evaluated,
    which means that the statement or block is executed at least once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some examples. The following code executes the printing statement
    six times (one more than the similar `while` statement):'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int i = 0;
  prefs: []
  type: TYPE_NORMAL
- en: do {
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.print(i + " ");   //prints: 0 1 2 3 4 5'
  prefs: []
  type: TYPE_NORMAL
- en: '} while(i++ < 5);'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'While the following code behaves the same way as a `while` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: double result = 0d;
  prefs: []
  type: TYPE_NORMAL
- en: do {
  prefs: []
  type: TYPE_NORMAL
- en: result += tryAndGetValue();
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(result);
  prefs: []
  type: TYPE_NORMAL
- en: '} while (result < 1d);'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run this code, we will see something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7957ae0e-88ff-4d36-a4b9-9df736c28d38.png)'
  prefs: []
  type: TYPE_IMG
- en: That is because the value is printed after it is accumulated, and then the expression
    is evaluated before entering the execution block again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplified `do...while` statement behaves differently. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: double result = 0d;
  prefs: []
  type: TYPE_NORMAL
- en: do {
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(result);
  prefs: []
  type: TYPE_NORMAL
- en: '} while ((result += tryAndGetValue()) < 1d);'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'And here is the same code, but without using the `tryAndGetValue()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: double result = 0d;
  prefs: []
  type: TYPE_NORMAL
- en: do {
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(result);
  prefs: []
  type: TYPE_NORMAL
- en: '} while ((result += Math.random()) < 1d);'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run any of the preceding two examples, we will get something like what''s
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da256ca8-5d1a-4fe6-8b10-20d1f22b757a.png)'
  prefs: []
  type: TYPE_IMG
- en: The initial value of the `result` variable is always printed first because the
    statement is executed at least once before the expression is evaluated the first
    time.
  prefs: []
  type: TYPE_NORMAL
- en: for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The format of the basic `for` statement looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: for(ListInit; Boolean Expression; ListUpdate) block or statement
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'But, we will start with the most popular, much simpler, version and get back
    to the full version in the *For with multiple initializers and expressions* section later.
    The simpler basic `for` statement format looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: for(DeclInitExpr; Boolean Expression; IncrDecrExpr) block or statement
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'This definition consists of the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DeclInitExpr` is a declaration and initialization expression, like `x = 1`,
    that is evaluated only once at the very beginning of the `for` statement''s execution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean Expression is a Boolean expression, like `x < 10`,  that is evaluated
    at the beginning of each iteration – every time before executing the block or
    statement; if the result is `false`,  the `for` statement terminates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IncrDecrExpr` is an increment or a decrement unary expression, like `++x`, `--x`, `x++`, `x-`,
    that is evaluated at the end of each iteration – after the block or statement
    is executed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Notice that we talk about expressions, not statements, although with added
    semicolons, they look like statements. The reason for that is that a semicolon
    serves as the separator between the expressions in the `for` statement. Let''s
    look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: for (int i=0; i < 3; i++){
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.print(i + " ");  //prints: 0 1 2'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int i=0` is the declaration and initialization expression, evaluated only
    once at the very beginning'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i < 3` is the Boolean expression, evaluated at the beginning of each iteration
    – before executing the block or statement; if the result is `false` ( `i >= 3`,
    in this case), the `for` statement execution terminates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i++` is the increment expression, evaluated after the block or statement is
    executed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And, as in the case of a `while` statement, the braces `{}` are not needed when
    only one statement has to be executed, but it is a good style to have them, so
    the code is consistent and easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'None of the expressions in a `for` statement are required:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int k = 0;
  prefs: []
  type: TYPE_NORMAL
- en: for (;;){
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.print(k++ + " ");     //prints: 0 1 2'
  prefs: []
  type: TYPE_NORMAL
- en: if(k > 2) break;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'But using expressions in the statement declaration is more convenient and conventional,
    thus easier to understand. And here are other examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: for (int i=0; i < 3;){
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.print(i++ + " "); //prints: 0 1 2'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: for (int i=2; i > 0; i--){
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.print(i + " "); //prints: 2 1'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Notice how in the last example, the decrement operator is used to walk down
    the initial `i` value.
  prefs: []
  type: TYPE_NORMAL
- en: While using a `for` statement, or any iteration statement for that matter, make
    sure the exit condition will be reached (unless you deliberately create an infinite
    loop). That is the main concern around which the iteration statement is built.
  prefs: []
  type: TYPE_NORMAL
- en: for enhanced
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have mentioned already, a `for` statement is a very convenient way to
    access array components (elements):'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int[] arr = {21, 34, 5};
  prefs: []
  type: TYPE_NORMAL
- en: for (int i=0; i < arr.length; i++){
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.print(arr[i] + " ");  //prints: 21 34 5'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice how we use the public property `length` of an array object to make sure
    we have reached all the array elements. But in such a case, when all the array
    has to be traversed, it is better (easier to write and to read) to use an enhanced
    `for` statement that has the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: <Type> arr = ...;              //an array or any Iterable
  prefs: []
  type: TYPE_NORMAL
- en: 'for (<Type> a: arr){'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.print(a + " ");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the comment, it is applicable to an array or a class that
    implements the interface `Iterable`. This interface has an `iterator()` method that
    returns an object of class `Iterator` which, in turn, has a method called `next()`
    that allows accessing the class members sequentially.  We will talk about such
    classes, called collections, in [Chapter 13](3d6ae5fa-f48e-44e2-ae03-62dae2f78401.xhtml),
    *Java Collections*. So, we can rewrite the last `for` statement example and use
    the enhanced `for` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int[] arr = {21, 34, 5};
  prefs: []
  type: TYPE_NORMAL
- en: 'for (int a: arr){'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.print(a + " ");  //prints: 21 34 5'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of a collection class that implements an interface `List` (and
    `List` extends `Iterable`), the sequential access to its members looks very similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list = List.of("Bob", "Joe", "Jill");
  prefs: []
  type: TYPE_NORMAL
- en: 'for (String s: list){'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.print(s + " ");  //prints: Bob Joe Jill'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: But when not all elements of an array or collection have to be accessed, some
    other form of an iteration statement is probably better suited.
  prefs: []
  type: TYPE_NORMAL
- en: Also, please notice that since Java 8, many data structures can produce streams
    that allow writing much more compact code and avoid the use of for statements
    whatsoever. We will show you how to do it in [Chapter 18](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml),
    *Streams and Pipelines*.
  prefs: []
  type: TYPE_NORMAL
- en: for with multiple initializers and expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's return to the basic `for` statement format once more. It allows much
    more variety in using it than many programmers even know about. And it is not
    because of a lack of interest or professional curiosity, but probably because
    this additional functionality usually is not needed. Yet, once in a while, when
    you read somebody's code or during a job interview, you may encounter the need
    to know the full picture. So, we decided to at least mention it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The full format of `for` statements is built around lists of expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: for(ListInit; Boolean Expression; ListUpdate) block or statement
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'This definition consists of the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ListInit`: May include a declaration list and/or an expression list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Expression`: Boolean expression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ListUpdate`: Expression list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The expression list members, separated by a comma, can be:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Assignment**: `x = 3`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pre/postfix increment/decrement expression**: `++x`  `--x`  `x++`  `x--`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Method invocation**: `method(42)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Object creation expression**: `new SomeClass(2, "Bob")`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following two `for` statements produce identical results:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: for (int i=0, j=0; i < 3 && j < 3; ++i, ++j){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(i + " " + j);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'for (int x=new A().getInitialValue(), i=x == -2 ? x + 2 : 0, j=0;'
  prefs: []
  type: TYPE_NORMAL
- en: i < 3 || j < 3 ; ++i, j = i) {
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(i + " " + j);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Where the `getInitialValue()` method has the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class A{
  prefs: []
  type: TYPE_NORMAL
- en: int getInitialValue(){ return -2; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, even such a simple functionality can look very complex and even
    be confusing when multiple initializers, assignments, and expressions are excessively
    used. If in doubt, keep your code simple and easy to understand. Sometimes it
    is not easy, but in our experience, it can always be done, and being easy to understand
    is one of the most important criteria of good code quality.
  prefs: []
  type: TYPE_NORMAL
- en: Branching statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have already seen the branching statements `break` and `return` in our examples. 
    We will define and discuss them and the third member of the group—the branching
    statement `continue` —in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Break and labeled break
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you have probably noticed, the `break` statement is essential for the `switch...case`
    selection statements to be able to work (see the s*witch...case* section for more
    information). If included in the execution block of an iteration statement, it causes
    the `for` or `while` statement to terminate immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is widely used in iteration statements while searching for a particular
    element in an array or collection. To demonstrate how it works, let''s assume,
    for example, that we need to find a certain person by age and name among the students
    and teachers of a community college. Let''s first create the classes `Person`,
    `Student`, and `Teacher`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class Person{
  prefs: []
  type: TYPE_NORMAL
- en: private int age;
  prefs: []
  type: TYPE_NORMAL
- en: private  String name;
  prefs: []
  type: TYPE_NORMAL
- en: public Person(int age, String name) {
  prefs: []
  type: TYPE_NORMAL
- en: this.age = age;
  prefs: []
  type: TYPE_NORMAL
- en: this.name = name;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public Boolean equals(Object o) {
  prefs: []
  type: TYPE_NORMAL
- en: if (this == o) return true;
  prefs: []
  type: TYPE_NORMAL
- en: Person person = (Person) o;
  prefs: []
  type: TYPE_NORMAL
- en: return age == person.age &&
  prefs: []
  type: TYPE_NORMAL
- en: Objects.equals(name, person.name);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public String toString() {
  prefs: []
  type: TYPE_NORMAL
- en: return "Person{age=" + age +
  prefs: []
  type: TYPE_NORMAL
- en: '", name=''" + name + "''}";'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: class Student extends Person {
  prefs: []
  type: TYPE_NORMAL
- en: private int year;
  prefs: []
  type: TYPE_NORMAL
- en: public Student(int age, String name, int year) {
  prefs: []
  type: TYPE_NORMAL
- en: super(age, name);
  prefs: []
  type: TYPE_NORMAL
- en: this.year = year;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public String toString() {
  prefs: []
  type: TYPE_NORMAL
- en: return "Student{year=" + year +
  prefs: []
  type: TYPE_NORMAL
- en: '", " + super.toString() + "}";'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: class Teacher extends Person {
  prefs: []
  type: TYPE_NORMAL
- en: private String subject;
  prefs: []
  type: TYPE_NORMAL
- en: public Teacher(int age, String name, String subject) {
  prefs: []
  type: TYPE_NORMAL
- en: super(age, name);
  prefs: []
  type: TYPE_NORMAL
- en: this.subject = subject;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public String toString() {
  prefs: []
  type: TYPE_NORMAL
- en: return "Student{subject=" + subject +
  prefs: []
  type: TYPE_NORMAL
- en: '", " + super.toString() + "}";'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the method `equals()` is implemented only in the base class `Person`.
    We identify a person by name and age only. Also, notice the use of the keyword
    `super` that allows us to access the constructor and `toString()` method of the
    parent class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that we are assigned to find a person (by name and age) in a
    community college database. So, we have created a collection of type `List` and
    we will iterate over it until we find a match:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<Person> list =
  prefs: []
  type: TYPE_NORMAL
- en: List.of(new Teacher(32, "Joe", "History"),
  prefs: []
  type: TYPE_NORMAL
- en: new Student(29,"Joe", 4),
  prefs: []
  type: TYPE_NORMAL
- en: new Student(28,"Jill", 3),
  prefs: []
  type: TYPE_NORMAL
- en: new Teacher(33, "ALice", "Maths"));
  prefs: []
  type: TYPE_NORMAL
- en: Person personOfInterest = new Person(29,"Joe");
  prefs: []
  type: TYPE_NORMAL
- en: Person person = null;
  prefs: []
  type: TYPE_NORMAL
- en: 'for (Person p: list){'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p);
  prefs: []
  type: TYPE_NORMAL
- en: if(p.equals(personOfInterest)){
  prefs: []
  type: TYPE_NORMAL
- en: person = p;
  prefs: []
  type: TYPE_NORMAL
- en: break;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if(person == null){
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("Not found: " + personOfInterest);'
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("Found: " + person);'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run this program, the result will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d1a86d0-d089-4e18-80b6-fb25ea409a53.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have found the person we were looking for. But if we change our search and
    look for another person (just one year at age difference):'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Person personOfInterest = new Person(30,"Joe");
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/61fb11ee-a3a3-4c3b-a0cc-c2228878a8f7.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the `break` statement allows exiting the loop as soon as the
    object of interest is found, thus not wasting time on iterating over all the collection,
    which may be quite large.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 18](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml), *Streams and Pipelines*,
    we will show you another (often more efficient) way to search a collection or
    an array. But iterating over the elements is still a viable way to do it in many
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `break` statement can be used for searching a particular element in a multidimensional
    data structure, too. Let''s assume we need to search a three-dimensional array
    and find the array of the lowest dimension that has the sum of its elements equal
    to or bigger than 4\. Here is an example of such an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int[][][] data = {
  prefs: []
  type: TYPE_NORMAL
- en: '{{1,0,2},{1,2,0},{2,1,0},{0,3,0}},'
  prefs: []
  type: TYPE_NORMAL
- en: '{{1,1,1},{1,3,0},{2,0,1},{1,0,1}}};'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The lowest dimension array we are looking for is `{1,3,0}`. If the first dimension
    is `x` and the second dimension is `y`, then the location of this array is `x=1`,
    `y=1`, or `[1][1]`. Let''s write a program that finds this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int[][][] data = {
  prefs: []
  type: TYPE_NORMAL
- en: '{{1,0,2},{1,2,0},{2,1,0},{0,3,0}},'
  prefs: []
  type: TYPE_NORMAL
- en: '{{1,1,1},{1,3,0},{2,0,1},{1,0,1}}};'
  prefs: []
  type: TYPE_NORMAL
- en: int threshold = 4;
  prefs: []
  type: TYPE_NORMAL
- en: int x = 0, y = 0;
  prefs: []
  type: TYPE_NORMAL
- en: Boolean isFound = false;
  prefs: []
  type: TYPE_NORMAL
- en: 'for(int[][] dd: data){'
  prefs: []
  type: TYPE_NORMAL
- en: y = 0;
  prefs: []
  type: TYPE_NORMAL
- en: 'for(int[] d: dd){'
  prefs: []
  type: TYPE_NORMAL
- en: int sum = 0;
  prefs: []
  type: TYPE_NORMAL
- en: 'for(int i: d){'
  prefs: []
  type: TYPE_NORMAL
- en: sum += i;
  prefs: []
  type: TYPE_NORMAL
- en: if(sum >= threshold){
  prefs: []
  type: TYPE_NORMAL
- en: isFound = true;
  prefs: []
  type: TYPE_NORMAL
- en: break;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if(isFound){
  prefs: []
  type: TYPE_NORMAL
- en: break;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: y++;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if(isFound){
  prefs: []
  type: TYPE_NORMAL
- en: break;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: x++;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("isFound=" + isFound + ", x=" + x + ", y=" + y);
  prefs: []
  type: TYPE_NORMAL
- en: '//prints: isFound=true, x=1, y=1'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we use a Boolean variable called `isFound` to facilitate exit
    from outer loops as soon as the desired result is found in the innermost loop.
    The boring need to check the value of the `isFound` variable made Java authors
    introduce a label – an identifier followed by a colon sign (`:`) that can be placed
    in front of a statement. The `break` statement can take advantage of it. Here
    is how the previous code can be changed using a label:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int[][][] data = {
  prefs: []
  type: TYPE_NORMAL
- en: '{{1,0,2},{1,2,0},{2,1,0},{0,3,0}},'
  prefs: []
  type: TYPE_NORMAL
- en: '{{1,1,1},{1,3,0},{2,0,1},{1,0,1}}};'
  prefs: []
  type: TYPE_NORMAL
- en: int threshold = 4;
  prefs: []
  type: TYPE_NORMAL
- en: int x = 0, y = 0;
  prefs: []
  type: TYPE_NORMAL
- en: Boolean isFound = false;
  prefs: []
  type: TYPE_NORMAL
- en: 'exit:'
  prefs: []
  type: TYPE_NORMAL
- en: 'for(int[][] dd: data){'
  prefs: []
  type: TYPE_NORMAL
- en: y = 0;
  prefs: []
  type: TYPE_NORMAL
- en: 'for(int[] d: dd){'
  prefs: []
  type: TYPE_NORMAL
- en: int sum = 0;
  prefs: []
  type: TYPE_NORMAL
- en: 'for(int i: d){'
  prefs: []
  type: TYPE_NORMAL
- en: sum += i;
  prefs: []
  type: TYPE_NORMAL
- en: if(sum >= threshold){
  prefs: []
  type: TYPE_NORMAL
- en: isFound = true;
  prefs: []
  type: TYPE_NORMAL
- en: break exit;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: y++;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: x++;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("isFound=" + isFound + ", x=" + x + ", y=" + y);
  prefs: []
  type: TYPE_NORMAL
- en: '//prints: isFound=true, x=1, y=1'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: We still use the variable `isFound` but only for reporting purposes. The `exit:` label
    allows the `break` statement to specify which statement has to stop executing.
    This way, we do not need to write boilerplate code checking the `isFound` variable's
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Continue and labeled continue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `continue` statement supports functionality similar to the one supported
    by the `break` statement. But instead of exiting the loop, it forces exiting the
    current iteration only, so the loop continues executing. To demonstrate how it
    works, let''s assume that, as in the case with the `break` statement in the previous
    section, we need to search a three-dimensional array and find the array of the
    lowest dimension that has the sum of its elements equal to or bigger than 4\.
    But this time, the sum should not include an element equal to 1\. Here is the
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int[][][] data = {
  prefs: []
  type: TYPE_NORMAL
- en: '{{1,1,2},{0,3,0},{2,4,1},{2,3,2}},'
  prefs: []
  type: TYPE_NORMAL
- en: '{{0,2,0},{1,3,4},{2,0,1},{2,2,2}}};'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our program should find the following arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '`data[0][2] = {2,4,1}`, `sum = 6` (because 1 has to be skipped)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data[0][3] = {2,3,2}`, `sum = 7`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data[1][1] = {1,3,4}`, `sum = 7` (because 1 has to be skipped)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data[1][3]={2,2,2}`, `sum = 6`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sum of other array elements does not reach 4 if 1 is skipped.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int[][][] data = {
  prefs: []
  type: TYPE_NORMAL
- en: '{{1,1,2},{0,3,0},{2,4,1},{2,3,2}},'
  prefs: []
  type: TYPE_NORMAL
- en: '{{0,2,0},{1,3,4},{2,0,1},{2,2,2}}};'
  prefs: []
  type: TYPE_NORMAL
- en: int threshold = 4;
  prefs: []
  type: TYPE_NORMAL
- en: int x = 0, y;
  prefs: []
  type: TYPE_NORMAL
- en: 'for(int[][] dd: data){'
  prefs: []
  type: TYPE_NORMAL
- en: y = 0;
  prefs: []
  type: TYPE_NORMAL
- en: 'for(int[] d: dd){'
  prefs: []
  type: TYPE_NORMAL
- en: int sum = 0;
  prefs: []
  type: TYPE_NORMAL
- en: 'for(int i: d){'
  prefs: []
  type: TYPE_NORMAL
- en: if(i == 1){
  prefs: []
  type: TYPE_NORMAL
- en: continue;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: sum += i;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if(sum >= threshold){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("sum=" + sum + ", x=" + x + ", y=" + y);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: y++;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: x++;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run it, the result will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/74f53e31-3c98-4c50-9dc5-ea22b18790dd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the results are exactly as we expected: all elements of 1 were
    skipped.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate how the labeled `continue` statement can be used, let''s change
    the requirements: not only the element 1 has to be skipped, but all the arrays
    that contain such an element have to be ignored too. In other words, we need to
    find arrays that do not contain 1 and have a sum of the elements equal to or bigger
    than 4.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our program should find only two arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '`data[0][3] = {2,3,2}`, `sum = 7`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data[1][3] = {2,2,2}`, `sum = 6`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the code that does it:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int[][][] data = {
  prefs: []
  type: TYPE_NORMAL
- en: '{{1,1,2},{0,3,0},{2,4,1},{2,3,2}},'
  prefs: []
  type: TYPE_NORMAL
- en: '{{0,2,0},{1,3,4},{2,0,1},{2,2,2}}};'
  prefs: []
  type: TYPE_NORMAL
- en: int threshold = 4;
  prefs: []
  type: TYPE_NORMAL
- en: int x = 0, y;
  prefs: []
  type: TYPE_NORMAL
- en: 'for(int[][] dd: data){'
  prefs: []
  type: TYPE_NORMAL
- en: y = 0;
  prefs: []
  type: TYPE_NORMAL
- en: 'cont: for(int[] d: dd){'
  prefs: []
  type: TYPE_NORMAL
- en: int sum = 0;
  prefs: []
  type: TYPE_NORMAL
- en: 'for(int i: d){'
  prefs: []
  type: TYPE_NORMAL
- en: if(i == 1){
  prefs: []
  type: TYPE_NORMAL
- en: y++;
  prefs: []
  type: TYPE_NORMAL
- en: continue cont;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: sum += i;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if(sum >= threshold){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("sum=" + sum + ", x=" + x + ", y=" + y);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: y++;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: x++;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we have added a label called `cont:` and refer it in the `continue`
    statement, so the current iteration of the innermost loop and the iteration of
    the next outer loop stops executing. The outer loop then continues executing the
    next iteration.  If we run the code, the results will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e701141-fa2f-411a-8827-6e7aa41bc93e.png)'
  prefs: []
  type: TYPE_IMG
- en: All the other arrays were skipped either because they contained 1 or the sum
    of their elements was less than 4.
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `return` statement can be placed only in a method or a constructor. Its
    function is to return control to the invoker with or without a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of a constructor, the `return` statement is not required. If placed
    in the constructor, it has to be the last statement that returns no value:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class ConstructorDemo{
  prefs: []
  type: TYPE_NORMAL
- en: private int field;
  prefs: []
  type: TYPE_NORMAL
- en: public ConstructorDemo(int i) {
  prefs: []
  type: TYPE_NORMAL
- en: this.field = i;
  prefs: []
  type: TYPE_NORMAL
- en: return;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: An attempt to place the `return` statement as not the last statement of a constructor
    or to make it return any value will result in a compilation error.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of a method, if the method was declared as returning some type:'
  prefs: []
  type: TYPE_NORMAL
- en: The `return` statement is required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `return` statement has to be effectively (see the following example) the
    last statement of the method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There may be several return statements, but one of them has to be effectively
    (see the following example) the last statement of the method, while the others
    have to be inside a selection statement; otherwise, a compilation error will be
    generated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `return` statement does not return anything, it causes a compilation
    error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `return` statement returns a type that is not the one declared in the
    method definition and not its subtype, it causes a compilation error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boxing, unboxing, and type widening are performed automatically, while type
    narrowing requires typecasting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example demonstrates the `return` statement being effectively
    the last statement of a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public String method(int n){
  prefs: []
  type: TYPE_NORMAL
- en: if(n == 1){
  prefs: []
  type: TYPE_NORMAL
- en: return "One";
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: return "Not one";
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The last statement of the method is a selection statement, but the `return`
    statement is the last one executed inside the selection statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of a method with many return statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public static String methodWithManyReturns(){
  prefs: []
  type: TYPE_NORMAL
- en: if(true){
  prefs: []
  type: TYPE_NORMAL
- en: return "The only one returned";
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if(true){
  prefs: []
  type: TYPE_NORMAL
- en: return "Is never reached";
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return "Is never reached";
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Although in the method, only the first `return` statement always returned, the
    compiler does not complain and the method is executed without a runtime error.
    It just always returns a `The only one returned` literal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following examples of methods with several return statements are more realistic:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public Boolean method01(int n){
  prefs: []
  type: TYPE_NORMAL
- en: if(n < 0) {
  prefs: []
  type: TYPE_NORMAL
- en: return true;
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: return false;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public Boolean sameAsMethod01(int n){
  prefs: []
  type: TYPE_NORMAL
- en: if(n < 0) {
  prefs: []
  type: TYPE_NORMAL
- en: return true;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return false;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public Boolean sameAsAbove(int n){
  prefs: []
  type: TYPE_NORMAL
- en: 'return n < 0 ? true : false;'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public int method02(int n){
  prefs: []
  type: TYPE_NORMAL
- en: if(n < 0) {
  prefs: []
  type: TYPE_NORMAL
- en: return 1;
  prefs: []
  type: TYPE_NORMAL
- en: '} else if(n == 0) {'
  prefs: []
  type: TYPE_NORMAL
- en: return 2;
  prefs: []
  type: TYPE_NORMAL
- en: '} else if (n == 1){'
  prefs: []
  type: TYPE_NORMAL
- en: return 3;
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: return 4;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public int methodSameAsMethod02(int n){
  prefs: []
  type: TYPE_NORMAL
- en: if(n < 0) {
  prefs: []
  type: TYPE_NORMAL
- en: return 1;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: switch(n) {
  prefs: []
  type: TYPE_NORMAL
- en: 'case 0:'
  prefs: []
  type: TYPE_NORMAL
- en: return 2;
  prefs: []
  type: TYPE_NORMAL
- en: 'case 1:'
  prefs: []
  type: TYPE_NORMAL
- en: return 3;
  prefs: []
  type: TYPE_NORMAL
- en: 'default:'
  prefs: []
  type: TYPE_NORMAL
- en: return 4;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are examples of boxing, unboxing, and type widening and narrowing:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public Integer methodBoxing(){
  prefs: []
  type: TYPE_NORMAL
- en: return 42;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public int methodUnboxing(){
  prefs: []
  type: TYPE_NORMAL
- en: return Integer.valueOf(42);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public int methodWidening(){
  prefs: []
  type: TYPE_NORMAL
- en: byte b = 42;
  prefs: []
  type: TYPE_NORMAL
- en: return b;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public byte methodNarrowing(){
  prefs: []
  type: TYPE_NORMAL
- en: int n = 42;
  prefs: []
  type: TYPE_NORMAL
- en: return (byte)n;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We also can revisit the program that looks for a particular person in the list
    of teachers and students:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<Person> list =
  prefs: []
  type: TYPE_NORMAL
- en: List.of(new Teacher(32, "Joe", "History"),
  prefs: []
  type: TYPE_NORMAL
- en: new Student(29,"Joe", 4),
  prefs: []
  type: TYPE_NORMAL
- en: new Student(28,"Jill", 3),
  prefs: []
  type: TYPE_NORMAL
- en: new Teacher(33, "ALice", "Maths"));
  prefs: []
  type: TYPE_NORMAL
- en: Person personOfInterest = new Person(29,"Joe");
  prefs: []
  type: TYPE_NORMAL
- en: Person person = null;
  prefs: []
  type: TYPE_NORMAL
- en: 'for (Person p: list){'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p);
  prefs: []
  type: TYPE_NORMAL
- en: if(p.equals(personOfInterest)){
  prefs: []
  type: TYPE_NORMAL
- en: person = p;
  prefs: []
  type: TYPE_NORMAL
- en: break;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if(person == null){
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("Not found: " + personOfInterest);'
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("Found: " + person);'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the return statements, we can now create the method `findPerson()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Person findPerson(List<Person> list, Person personOfInterest){
  prefs: []
  type: TYPE_NORMAL
- en: Person person = null;
  prefs: []
  type: TYPE_NORMAL
- en: 'for (Person p: list){'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p);
  prefs: []
  type: TYPE_NORMAL
- en: if(p.equals(personOfInterest)){
  prefs: []
  type: TYPE_NORMAL
- en: person = p;
  prefs: []
  type: TYPE_NORMAL
- en: break;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return person;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'This method can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<Person> list = List.of(new Teacher(32, "Joe", "History"),
  prefs: []
  type: TYPE_NORMAL
- en: new Student(29,"Joe", 4),
  prefs: []
  type: TYPE_NORMAL
- en: new Student(28,"Jill", 3),
  prefs: []
  type: TYPE_NORMAL
- en: new Teacher(33, "ALice", "Maths"));
  prefs: []
  type: TYPE_NORMAL
- en: Person personOfInterest = new Person(29,"Joe");
  prefs: []
  type: TYPE_NORMAL
- en: Person person = findPerson(list, personOfInterest);
  prefs: []
  type: TYPE_NORMAL
- en: if(person == null){
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("Not found: " + personOfInterest);'
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("Found: " + person);'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking advantage of the new code structure, we can change the `findPerson()`
    method further and demonstrate greater variety in `return` statement usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Person findPerson(List<Person> list, Person personOfInterest){
  prefs: []
  type: TYPE_NORMAL
- en: 'for (Person p: list){'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p);
  prefs: []
  type: TYPE_NORMAL
- en: if(p.equals(personOfInterest)){
  prefs: []
  type: TYPE_NORMAL
- en: return p;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return null;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we have replaced the `break` statement with the return statement.
    Is the code more readable now? Some programmers would say no, as they prefer to
    have one `return` statement to be the only source of the returned result. Otherwise,
    they argue, one has to study the code and see if there is another—the third—`return`
    statement that might return yet another value. If the code is not as simple, one
    is never sure that all possible returns have been identified. The programmers
    of the opposite camp would counter-argue that a method should be small, so finding
    all return statements is easy. But making a method small often forces the creation
    of deeply nested methods that are not so easy to understand. The argument may
    go on for a long time. That's why we leave it up to you to try and decide which
    style you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the return type of a method is defined as `void`:'
  prefs: []
  type: TYPE_NORMAL
- en: The `return` statement is not required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `return` statement is present, it does not return any value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `return` statement returns some value, it causes a compilation error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There may be several return statements, but one of them has to be effectively
    the last statement of the method, while the others have to be inside a selection
    statement; otherwise, a compilation error will be generated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To demonstrate the `return` statement without a value, we will use the `findPerson()`
    method again. If all we need to do is to print out the results, then the method
    can be changed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void findPerson2(List<Person> list, Person personOfInterest){
  prefs: []
  type: TYPE_NORMAL
- en: 'for (Person p: list){'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(p);
  prefs: []
  type: TYPE_NORMAL
- en: if(p.equals(personOfInterest)){
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("Found: " + p);'
  prefs: []
  type: TYPE_NORMAL
- en: return;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("Not found: " + personOfInterest);'
  prefs: []
  type: TYPE_NORMAL
- en: return;  //this statement is optional
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'And the client code will look much simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<Person> list = List.of(new Teacher(32, "Joe", "History"),
  prefs: []
  type: TYPE_NORMAL
- en: new Student(29,"Joe", 4),
  prefs: []
  type: TYPE_NORMAL
- en: new Student(28,"Jill", 3),
  prefs: []
  type: TYPE_NORMAL
- en: new Teacher(33, "ALice", "Maths"));
  prefs: []
  type: TYPE_NORMAL
- en: Person personOfInterest = new Person(29,"Joe");
  prefs: []
  type: TYPE_NORMAL
- en: findPerson(list, personOfInterest);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or it can be even more compact:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<Person> list = List.of(new Teacher(32, "Joe", "History"),
  prefs: []
  type: TYPE_NORMAL
- en: new Student(29,"Joe", 4),
  prefs: []
  type: TYPE_NORMAL
- en: new Student(28,"Jill", 3),
  prefs: []
  type: TYPE_NORMAL
- en: new Teacher(33, "ALice", "Maths"));
  prefs: []
  type: TYPE_NORMAL
- en: findPerson(list, new Person(29, "Joe");
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As in the previous discussion, there are different styles for passing the parameters
    into a method. Some people prefer the more compact style as in the code here.
    Others argue that each parameter has to have a variable because the name of the
    variable carries additional information that helps to communicate the intent (like
    the name `personOfInterest`).
  prefs: []
  type: TYPE_NORMAL
- en: Such discussions are inevitable because the same code has to be understood and
    maintained by different people, and each development team has to find the style
    that suits the needs and preferences of all the team members.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have explained in the introduction, an unexpected condition can cause
    JVM to create and throw an exception object, or the application code can do it.
    As soon as it happens, the control flow is transferred to the exception handling
    `try` statement (also called a `try-catch` or `try-catch-finally` statement) if
    the exception was thrown inside a `try` block. Here is an example of a caught
    exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void exceptionCaught(){
  prefs: []
  type: TYPE_NORMAL
- en: try {
  prefs: []
  type: TYPE_NORMAL
- en: method2();
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (Exception ex){'
  prefs: []
  type: TYPE_NORMAL
- en: ex.printStackTrace();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void method2(){
  prefs: []
  type: TYPE_NORMAL
- en: method1(null);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void method1(String s){
  prefs: []
  type: TYPE_NORMAL
- en: s.equals("whatever");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The method `exceptionCaught()` calls `method2()` which calls `method1()` and passes
    to it `null`. The line `s.equals("whatever")` throws `NullPointerException` which
    propagates through the method call stack until caught by the `try-catch` block
    of the method `exceptionCaught()` and its stack trace (which method called which
    method and in which line of the class) is printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/67e2282b-6d05-4627-ab9f-55ae0b280afa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the stack trace, you can see that all the involved methods belong to the
    same class, `ExceptionHandlingDemo`. Reading from the bottom up, you can see that:'
  prefs: []
  type: TYPE_NORMAL
- en: The method `main()` called the method `exceptionCaught()` in line 5 of `ExceptionHandlingDemo`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method `exceptionCaught()` called `method2()` in line 10 of the same class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `method2()` called `method1()` in line 17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `method1()` has thrown `java.lang.NullpointerException` from line 21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we don''t see the code, we don''t know if this exception was thrown deliberately.
    For example, `method1()` might look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void method1(String s){
  prefs: []
  type: TYPE_NORMAL
- en: if(s == null){
  prefs: []
  type: TYPE_NORMAL
- en: throw new NullPointerException();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'But usually, programmers add a message to indicate what the problem is:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void method1(String s){
  prefs: []
  type: TYPE_NORMAL
- en: if(s == null){
  prefs: []
  type: TYPE_NORMAL
- en: throw new NullPointerException("Parameter String is null");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If that were the case, the stack trace would show a message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/42776307-171b-476f-a280-ba2e3d606546.png)'
  prefs: []
  type: TYPE_IMG
- en: 'But the message is not a reliable indicator of the custom exception. Some standard
    exceptions carry their own message, too. The exception package is better evidence
    of a custom exception or if the exception is one of the base classes (`java.lang.Exception`
    or `java.langRuntimeException`) and has a message in it. The following code, for
    example, customizes `RuntimeException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void method1(String s){
  prefs: []
  type: TYPE_NORMAL
- en: if(s == null){
  prefs: []
  type: TYPE_NORMAL
- en: throw new RuntimeException("Parameter String is null");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'And here is what the stack trace looks like with such a customized exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13e41dba-0766-4f70-9448-6c0cc91cce5a.png)'
  prefs: []
  type: TYPE_IMG
- en: We will talk more about exception customization in the *Custom exceptions* section
    later.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the exception is thrown outside a `try...catch` block, the program execution
    is terminated by JVM. Here is an example of an exception not caught by the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void exceptionNotCaught(){
  prefs: []
  type: TYPE_NORMAL
- en: method2();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void method2(){
  prefs: []
  type: TYPE_NORMAL
- en: method1(null);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void method1(String s){
  prefs: []
  type: TYPE_NORMAL
- en: s.equals("whatever");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run this code, the result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f0cbbec-63b6-49a5-81a6-0db76a269dbc.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's talk about the exception handling statements and then come back to
    the discussion about the best way to handle the exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: throw
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `throw` statement consists of the keyword `throw` and either a variable
    or value of a reference type `java.lang.Throwable`, or the `null` reference. Since
    all the exceptions are children of `java.lang.Throwable`, any of the following
    throw statements is correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: throw new Exception("Something happened");
  prefs: []
  type: TYPE_NORMAL
- en: Exception ex = new Exception("Something happened");
  prefs: []
  type: TYPE_NORMAL
- en: throw ex;
  prefs: []
  type: TYPE_NORMAL
- en: Throwable thr = new Exception("Something happened");
  prefs: []
  type: TYPE_NORMAL
- en: throw thr;
  prefs: []
  type: TYPE_NORMAL
- en: throw null;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If `null` is thrown, as it is in the last statement, then JVM converts it to
    a `NullPointerException`, so these two statements are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: throw null;
  prefs: []
  type: TYPE_NORMAL
- en: throw new NullPointerException;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: And, just to remind you, the package `java.lang` does not need to be imported.
    You can refer to any of the package `java.lang` members—interface or class—by
    its name without using the fully qualified name (that includes package name too).
    That is why we are able to write `NullPointerException` without importing the
    class instead of using its fully qualified name, `java.lang.NullPointerException`.
    We will look into the content of the package `java.lang` in [Chapter 12](dc404209-4f4f-42f6-b63e-ea494ba593db.xhtml),
    *Java Standard and External Libraries*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also create your own exception by extending `Throwable` or any of its
    children and throw them instead of standard exceptions of the package `java.lang`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class MyNpe extends NullPointerException{
  prefs: []
  type: TYPE_NORMAL
- en: public MyNpe(String message){
  prefs: []
  type: TYPE_NORMAL
- en: super(message);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: //whatever code you need to have here
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: class MyRuntimeException extends RuntimeException{
  prefs: []
  type: TYPE_NORMAL
- en: public MyRuntimeException(String message){
  prefs: []
  type: TYPE_NORMAL
- en: super(message);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: //whatever code you need to have here
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: class MyThrowable extends Throwable{
  prefs: []
  type: TYPE_NORMAL
- en: public MyThrowable(String message){
  prefs: []
  type: TYPE_NORMAL
- en: super(message);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: //whatever code you need to have here
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: class MyException extends Exception{
  prefs: []
  type: TYPE_NORMAL
- en: public MyException(String message){
  prefs: []
  type: TYPE_NORMAL
- en: super(message);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: //whatever code you need to have here
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Why you would want to do that will become clear after reading the *Custom exceptions* section later.
  prefs: []
  type: TYPE_NORMAL
- en: try...catch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When an exception is thrown inside a `try` block, it redirects control flow
    to its first `catch` clause (the one that catches `NullPointerException` in the
    following example):'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void exceptionCaught(){
  prefs: []
  type: TYPE_NORMAL
- en: try {
  prefs: []
  type: TYPE_NORMAL
- en: method2();
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (NullPointerException ex){'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("NPE caught");
  prefs: []
  type: TYPE_NORMAL
- en: ex.printStackTrace();
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (RuntimeException ex){'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("RuntimeException caught");
  prefs: []
  type: TYPE_NORMAL
- en: ex.printStackTrace();
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (Exception ex){'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("Exception caught");
  prefs: []
  type: TYPE_NORMAL
- en: ex.printStackTrace();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: If there are more than one `catch` clauses, the compiler forces you to arrange
    them so that the child exception is listed before the parent exception. In our
    previous example, `NullPointerException` extends  `RuntimeException` extends `Exception`.
    If the thrown exception type matches the topmost `catch` clause, this `catch`
    block handles the exception (we will talk about what it means shortly). If the
    topmost clause does not match the exception type, the next `catch` clause gets
    the control flow and handles the exception if it matches the clause type. If not,
    the control flow is passed to the next clause until either the exception is handled
    or all the clauses are tried. If none of the clauses match, the exception is thrown
    further up until is it either handled by some try-catch block or it propagates
    all the way out of the program code. In such a case, JVM terminates the program
    execution (to be precise, it terminates the thread execution, but we will talk
    about threads in [Chapter 11](e8c37d86-291d-4500-84ea-719683172477.xhtml), *JVM
    Processes and Garbage Collection*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s demonstrate this by running the examples. If we use the three `catch`
    clauses in the method `exceptionCaught()` as shown previously, and throw `NullPointerException`
    in  `method1()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void method1(String s){
  prefs: []
  type: TYPE_NORMAL
- en: throw new NullPointerException("Parameter String is null");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result will be like that shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8721c37-ab6d-4418-9406-f8c0e2517e3c.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see that the topmost `catch` clause caught the exception as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we change `method1()` to throw a `RuntimeException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void method1(String s){
  prefs: []
  type: TYPE_NORMAL
- en: throw new RuntimeException("Parameter String is null");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'You probably will be not surprised to see that the second `catch` clause catches
    it. So, we are not going to demonstrate it. We better change `method1()` again
    and let it throw `ArrayIndexOutOfBoundsException`, which extends `RuntimeException`,
    but is not listed in any of the catch clauses:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void method1(String s){
  prefs: []
  type: TYPE_NORMAL
- en: throw new ArrayIndexOutOfBoundsException("Index ... is bigger " +
  prefs: []
  type: TYPE_NORMAL
- en: '"than the array length ...");'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the code again, the result will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4b8464ff-2568-4c63-a7bf-c8a8fb30d954.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the exception was caught by the first `catch` clause that matched
    its type. That is the reason the compiler forces you to list them so that a child
    is often listed before its parent, so the most specific type is listed first.
    This way, the first matched clause is always the best match.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you probably fully expect to see any non-`RuntimeException` to be caught
    by the last `catch` clause. That is a correct expectation. But before we can throw
    it, we have to address the difference between *checked* and *unchecked* (also
    called *runtime*) exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Checked and unchecked (runtime) exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To understand why this topic is important, let''s try to throw an exception
    of type `Exception` in `method1()`. For this test, we will use  `InstantiationException`,
    which extends `Exception`. Let''s assume there was a validation of input data
    (from some external source) and it turned out that they were not good enough for
    some object instantiation:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void method1(String s) {
  prefs: []
  type: TYPE_NORMAL
- en: //some input data validation
  prefs: []
  type: TYPE_NORMAL
- en: throw new InstantiationException("No value for the field" +
  prefs: []
  type: TYPE_NORMAL
- en: '" someField of SomeClass.");'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: We wrote this code and suddenly the compiler generated an error, `Unhandled
    exception java.lang.InstantiationException`, although we do have a `catch` clause
    up in the client code that will match this type of exception (the last `catch`
    clause in the method `exceptionCaught()`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason for the error is that all exception types that extend the `Exception`
    class but not its child `RuntimeException` are checked at compile time, hence
    the name. The compiler checks if such exceptions are handled in the method of
    their origination:'
  prefs: []
  type: TYPE_NORMAL
- en: If, in the method of the exception origination, there is a `try-catch` block
    that catches this exception and does not let it propagate outside the method,
    the compiler does not complain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Otherwise, it checks if there is a `throws` clause in the method declaration
    that lists this exception; here is an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void method1(String s) throws Exception{
  prefs: []
  type: TYPE_NORMAL
- en: //some input data validation
  prefs: []
  type: TYPE_NORMAL
- en: throw new InstantiationException("No value for the field" +
  prefs: []
  type: TYPE_NORMAL
- en: '" someField of SomeClass.");'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The `throws` clause must list all the checked exceptions that can propagate
    outside the method. By adding `throws Exception`, we made the compiler happy even
    if we decide to throw any other checked exception because they are all of the type
    `Exception` and thus are covered by the new `throws` clause.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, `Throws`, you will read some pros and cons of using a base
    exception class in a `throws` clause, and in the section *Some best practices
    of exception handling*, later, we discuss some other possible solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Meanwhile, let''s continue discussing checked exception usage. In our demo
    code, we have decided to add the clause `throws Exception` to the `method1()` declaration.
    This change has immediately triggered the same error `Unhandled exception java.lang.InstantiationException` in
    `method2()`, which calls `method1()` but does not handle `Exception`. So, we had
    to add a `throws` clause to `method2()`, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void method2() throws Exception{
  prefs: []
  type: TYPE_NORMAL
- en: method1(null);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Only the caller of `method2()`—the method `exceptionCaught()`—does not need
    to be changed because it handles the `Exception` type. The final version of the
    code is:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void exceptionCaught(){
  prefs: []
  type: TYPE_NORMAL
- en: try {
  prefs: []
  type: TYPE_NORMAL
- en: method2();
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (NullPointerException ex){'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("NPE caught");
  prefs: []
  type: TYPE_NORMAL
- en: ex.printStackTrace();
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (RuntimeException ex){'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("RuntimeException caught");
  prefs: []
  type: TYPE_NORMAL
- en: ex.printStackTrace();
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (Exception ex){'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("Exception caught");
  prefs: []
  type: TYPE_NORMAL
- en: ex.printStackTrace();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void method2() throws Exception{
  prefs: []
  type: TYPE_NORMAL
- en: method1(null);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void method1(String s) throws Exception{
  prefs: []
  type: TYPE_NORMAL
- en: throw new InstantiationException("No value for the field" +
  prefs: []
  type: TYPE_NORMAL
- en: '" someField of SomeClass.");'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we call the method `exceptionCaught()` now, the result will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8faf4c71-38d5-42b8-96bb-6b261faeae1d.png)'
  prefs: []
  type: TYPE_IMG
- en: That is exactly what we expected. The last `catch` clause for the `Exception` type
    matched the `InstantiationException` type.
  prefs: []
  type: TYPE_NORMAL
- en: The unchecked exceptions—the descendants of the class `RuntimeExceptions` —are
    not checked at compile time, thus the name, and are not required to be listed
    in the `throws` clause.
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, checked exceptions are (should be) used for recoverable
    conditions, while unchecked exceptions for unrecoverable conditions. We will talk
    more about it in the *What is exception handling?* and *Some best practices* *of
    exception handling* sections later.
  prefs: []
  type: TYPE_NORMAL
- en: throws
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `throws` clause must list all checked exception classes (descendants of the
    class `Exception` but not descendants of the class `RuntimeException`) that the
    method or constructor can throw. It is allowed but not required to list the unchecked
    exception classes (descendants of the class `RuntimeException`) in a `throws`
    clause, too. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void method1(String s)
  prefs: []
  type: TYPE_NORMAL
- en: throws InstantiationException, InterruptedException {
  prefs: []
  type: TYPE_NORMAL
- en: //some input data validation
  prefs: []
  type: TYPE_NORMAL
- en: if(some data missing){
  prefs: []
  type: TYPE_NORMAL
- en: throw new InstantiationException("No value for the field" +
  prefs: []
  type: TYPE_NORMAL
- en: '" someField of SomeClass.");'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: //some other code
  prefs: []
  type: TYPE_NORMAL
- en: if(some other reason){
  prefs: []
  type: TYPE_NORMAL
- en: throw new InterruptedException("Reason..."); //checked exception
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, instead of declaring throwing two different exceptions, one can list only
    the base class in the `throws` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void method1(String s) throws Exception {
  prefs: []
  type: TYPE_NORMAL
- en: //some input data validation
  prefs: []
  type: TYPE_NORMAL
- en: if(some data missing){
  prefs: []
  type: TYPE_NORMAL
- en: throw new InstantiationException("No value for the field" +
  prefs: []
  type: TYPE_NORMAL
- en: '" someField of SomeClass.");'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: //some other code
  prefs: []
  type: TYPE_NORMAL
- en: if(some other reason){
  prefs: []
  type: TYPE_NORMAL
- en: throw new InterruptedException("Reason..."); //checked exception
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it would mean that the variety and possible reasons for potential
    failures will be hidden from the client this way, so one must either:'
  prefs: []
  type: TYPE_NORMAL
- en: Handle the exceptions inside the method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assume that the client code will base its behavior on the content of the message
    (which is often not reliable and subject to change)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assume that the client will behave the same way no matter what the actual type
    exception can be
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assume that the method will never throw any other checked exception and, if
    it does, the behavior of the client should not change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are too many assumptions to feel comfortable declaring only a base class
    exception in the `throws` clause.  But there are some best practices that avoid
    such a dilemma. We will talk about them in the *Some best practices for exception
    handling* section later.
  prefs: []
  type: TYPE_NORMAL
- en: Custom exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we promised to discuss the motivation for custom exception
    creation. Here are two examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: //Unchecked custom exception
  prefs: []
  type: TYPE_NORMAL
- en: class MyRuntimeException extends RuntimeException{
  prefs: []
  type: TYPE_NORMAL
- en: public MyRuntimeException(String message){
  prefs: []
  type: TYPE_NORMAL
- en: super(message);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: //whatever code you need to have here
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: //Checked custom exception
  prefs: []
  type: TYPE_NORMAL
- en: class MyException extends Exception{
  prefs: []
  type: TYPE_NORMAL
- en: public MyException(String message){
  prefs: []
  type: TYPE_NORMAL
- en: super(message);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: //whatever code you need to have here
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: These examples don't look particularly useful until you realize that the comment
    `whatever code you need to have here` allows you put any data or functionality
    in your  custom class and utilize the exception handling mechanism to propagate
    such an object from any code depth all the way up to any level you need it.
  prefs: []
  type: TYPE_NORMAL
- en: Since this is only an introduction to Java programming, such cases are beyond
    the scope of this book. We just wanted to make sure you know that such a capability
    exists, so you may search the internet when you need it or build your own innovative
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is an ongoing discussion in the Java community on the topic of
    utilizing the exception handling mechanism for business purposes, which we will
    touch on in the *Some best practices of exception handling* section later.
  prefs: []
  type: TYPE_NORMAL
- en: What is exception handling?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have mentioned already, checked exceptions were originally thought to
    be used for the recoverable conditions when a caller code may do something automatically
    and take another branch of execution, based on the type of the caught exception
    and maybe the data it carried. And that is the primary purpose and function of
    exception handling.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, such utilization of exceptions proved to be not very productive
    because as soon as an exceptional condition is discovered, the code is enhanced
    and makes such a condition one of the possible processing options, albeit not
    very often executed.
  prefs: []
  type: TYPE_NORMAL
- en: The secondary function is to document the error condition and all the related
    information for later analysis and code enhancement.
  prefs: []
  type: TYPE_NORMAL
- en: The third and no less important function of exception handling is to protect
    the application from complete failure. The unexpected condition happened, but
    hopefully such conditions are rare and the mainstream processing is still available
    for the application to continue working as it was designed.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth function of exception handling is to provide a mechanism for information
    delivery in some special cases when other means are not as effective. This last
    function of exception handling remains controversial and not used very often.
    We will talk about it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Some best practices of exception handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Java exception handling mechanism was designed to address possible edge
    cases and unexpected program termination. The two categories of errors were expected
    to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Recoverable**: Those that can be remedied automatically based on the application
    logic'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unrecoverable**: Those that cannot be corrected automatically and which lead
    to program termination'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first category of errors was addressed by introducing checked exceptions
    (descendants of the `Exception` class), while the second became a realm of unchecked
    exceptions (descendants of the `RuntimeException` class).
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, such categorization turned out to be not in line with the programming
    practicalities, especially for the areas of programming unrelated to the development
    of libraries and frameworks designed to be used by different users and organizations
    in a variety of environments and execution contexts. Typical application development
    was always able to fix the problem in the code directly without writing a complicated
    mechanism for recovery. The distinction is important because as an author of a
    library, you never know where and how your methods are going to be used, while
    as an application developer, one knows exactly the environment and the execution
    context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even the Java authors indirectly confirmed this experience by adding, as it
    stands at the time of writing, 15 unchecked exceptions and only nine checked exceptions
    to the `java.lang` package. If the original expectations were confirmed by the
    practice, one would expect only a few unrecoverable (unchecked) exceptions and
    many more types of recoverable (checked) exceptions. Meanwhile, even some of the
    checked exceptions of the `java.lang` package do not look as recoverable either:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ClassNotFoundException`: Thrown when JVM is not able to find the referred
    class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CloneNotSupportedException`: Thrown to indicate that the clone method in the
    object''s class does not implement the `Cloneable` interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IllegalAccessException`: Thrown when the currently executing method does not
    have access to the definition of the specified class, field, method, or constructor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In fact, one would be hard-pressed to find a situation when automatic recovery
    code is worth writing instead of just adding another branch of logic to the mainstream
    processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that in mind, let''s enumerate a few best practices that proved to be
    useful and effective:'
  prefs: []
  type: TYPE_NORMAL
- en: Always catch all exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle each exception as close to the source as possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not use checked exceptions unless you have to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convert third-party checked exceptions into unchecked by re-throwing them as
    `RuntimeException` with the corresponding message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not create custom exceptions unless you have to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not drive business logic by using the exception handling mechanism, unless
    you have to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customize the generic `RuntimeException` by using the system of messages and,
    optionally, enum type instead of using exception type to communicate the cause
    of the error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: finally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `finally` block can be added to a `try` block with or without a `catch` clause.
    The format looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: try {
  prefs: []
  type: TYPE_NORMAL
- en: //code of the try block
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (...){'
  prefs: []
  type: TYPE_NORMAL
- en: //optional catch block code
  prefs: []
  type: TYPE_NORMAL
- en: '} finally {'
  prefs: []
  type: TYPE_NORMAL
- en: //code of the finally block
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: If present, the code in the `finally` block is always executed just before the
    method is exited. Whether the code in the `try` block has thrown an exception,
    and whether this exception was processed in one of the `catch` blocks or if the
    code in the `try` block did not throw an exception, the `finally` block is still
    executed every time just before the method returns the control flow to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: Originally, the `finally` block was used to close some resources used in the
    `try` block that needed to be closed. For example, if the code has opened a connection
    to the database or has established a reading or writing connection with a file
    on a disk, such a connection has to be closed after the operation is completed
    or when an exception has been thrown. Otherwise, a connection that is not closed
    on time keeps the resources (necessary to maintain the connection) locked without
    being used. We will talk about JVM processes in [Chapter 11](e8c37d86-291d-4500-84ea-719683172477.xhtml),
    *JVM Processes and Garbage Collection*.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, typical code looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Connection conn = null;
  prefs: []
  type: TYPE_NORMAL
- en: try {
  prefs: []
  type: TYPE_NORMAL
- en: conn = createConnection();
  prefs: []
  type: TYPE_NORMAL
- en: //code of the try block
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (...){'
  prefs: []
  type: TYPE_NORMAL
- en: //optional catch block code
  prefs: []
  type: TYPE_NORMAL
- en: '} finally {'
  prefs: []
  type: TYPE_NORMAL
- en: if(conn != null){
  prefs: []
  type: TYPE_NORMAL
- en: conn.close();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'It worked fine. But a new Java capability, called `try...with...resources`,
    allows closing the connection automatically if the connection class implements
    `AutoCloseable` (which most of the popular connection classes do). We will talk
    about the `try...with...resources` construct in  [Chapter 16](d77f1f16-0aa6-4d13-b9a8-f2b6e195f0f1.xhtml), *Database
    Programming*. This development decreased the `finally` block''s usefulness, and
    now it is used primarily for handling some code that cannot be executed using
    the `AutoCloseable` interface, yet has to be performed just before the method
    returns unconditionally. For example, we could refactor our `exceptionCaught()` method by
    taking advantage of the `finally` block as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void exceptionCaught(){
  prefs: []
  type: TYPE_NORMAL
- en: Exception exf = null;
  prefs: []
  type: TYPE_NORMAL
- en: try {
  prefs: []
  type: TYPE_NORMAL
- en: method2();
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (NullPointerException ex){'
  prefs: []
  type: TYPE_NORMAL
- en: exf = ex;
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("NPE caught");
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (RuntimeException ex){'
  prefs: []
  type: TYPE_NORMAL
- en: exf = ex;
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("RuntimeException caught");
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (Exception ex){'
  prefs: []
  type: TYPE_NORMAL
- en: exf = ex;
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("Exception caught");
  prefs: []
  type: TYPE_NORMAL
- en: '} finally {'
  prefs: []
  type: TYPE_NORMAL
- en: if(exf != null){
  prefs: []
  type: TYPE_NORMAL
- en: exf.printStackTrace();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: There are other cases of `finally` block use too, based on its guaranteed execution
    just before the control flow is returned to the method caller.
  prefs: []
  type: TYPE_NORMAL
- en: Assert requires JVM option -ea
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The branching `assert` statement can be used for validation of the data in application
    testing, especially for accessing rarely used execution paths or combinations
    of data. The unique aspect of this capability is that the code is not executed
    unless the JVM is run with the option `-ea`.
  prefs: []
  type: TYPE_NORMAL
- en: A full discussion of the `assert` statement's functionality and possible application
    is outside the scope of this book. We will just demonstrate its basic usage and
    how to turn it on using IntelliJ IDEA.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class AssertDemo {
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String... args) {
  prefs: []
  type: TYPE_NORMAL
- en: int x = 2;
  prefs: []
  type: TYPE_NORMAL
- en: 'assert x > 1 : "x <= 1";'
  prefs: []
  type: TYPE_NORMAL
- en: 'assert x == 1 : "x != 1";'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The first `assert` statement evaluates the expression `x > 1` and stops program
    execution (and reports `x <= 1`) if the expression `x > 1` evaluates to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: The second `assert` statement evaluates the expression `x == 1` and stops program
    execution (and reports `x != 1`) if the expression `x == 1` evaluates to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run this program now, none of the `assert` statements will be executed.
    To turn them on, click Run in the IntelliJ IDEA menu and select Edit Configurations,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4cfd5dda-e07c-45ec-b9bd-13c4e4b6ac33.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Run/Debug Configurations screen will open. Type `-ea` in the field VM options,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8019cb61-0d4f-4d29-8d28-d10aef60490e.png)'
  prefs: []
  type: TYPE_IMG
- en: Then, click the OK button at the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the `AssertDemo` program now, the result will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9666cbdf-3943-494e-a7b8-d8a9eebdd592.png)'
  prefs: []
  type: TYPE_IMG
- en: The `-ea` option should not be used in production, except maybe temporarily
    for testing purposes, because it creates overhead and affects the application's
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – Infinite loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write one or two examples of an infinite loop.
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is one possible infinite loop implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: while(true){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("try and stop me"); //prints indefinitely
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is another one:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: for (;;){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("try and stop me"); //prints indefinitely
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'And this one is an infinite loop, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: for (int x=2; x > 0; x--){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(x++ + " "); //prints 2 indefinitely
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In this code, the Boolean expression `x > 0` is always evaluated to `true` because
    `x` is initialized to `2` and then incremented and decremented by `1` in each
    iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter described Java statements that let you build a program flow according
    to the logic of the implemented algorithm, using conditional statements, iteration
    statements, branching statements, and exception handling. An extensive discussion
    of Java exception helped you to navigate this complex and very often correctly
    used area. Best practices were provided for the most effective and least confusing
    exception handling.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look under the hood of the JVM and discuss its
    processes and other aspects of its inner workings important that are for effective
    Java programming, including mechanism threads and garbage collection, which help
    an application to regain memory that is no longer in use.
  prefs: []
  type: TYPE_NORMAL
