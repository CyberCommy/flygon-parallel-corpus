- en: '*Chapter 4*: The Linux Firewall'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linux has almost always had an integrated firewall available for use by administrators.
    With the native firewall tools, you can craft a traditional perimeter firewall
    with address translation or a proxy server. These aren''t, however, typical use
    cases in a modern data center. The typical use cases for host firewalls in modern
    infrastructure are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Inbound access controls, to limit access to administrative interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inbound access controls, to restrict access to other installed services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging of accesses for any subsequent incident response, after a security exposure,
    breach, or another incident
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While egress filtering (outbound access controls) is certainly recommended,
    this is more often implemented at network perimeters – on firewalls and routers
    between VLANs or facing less-trusted networks such as the public internet.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll focus on implementing a set of rules that govern access
    to a host that implements a web service for general access, and an SSH service
    for administrative access.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring iptables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring nftables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the examples in this chapter, we'll continue to build on our existing
    Ubuntu host or virtual machine. We'll be focusing on the Linux firewall in this
    chapter, so a second host might be handy to test your firewall changes with.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we work through the various firewall configurations, we''ll only be using
    two main Linux commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Configuring iptables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the time of writing (2021), we're in flux on firewall architectures. iptables
    is still the default host firewall on many distributions, including our example
    Ubuntu distribution. However, the industry has started moving toward a newer architecture,
    nftables (Netfilter). Red Hat and CentOS v8 (on the Linux kernel 4.18), for instance,
    have nftables as their default firewall. Just for context, when iptables was introduced
    in kernel version 3.13 (around 2014), it in turn replaced the `ipchains` package
    (which was introduced in kernel version 2.2, in 1999). The main reasons for moving
    to the new commands are to move toward a more consistent command set, provide
    better support of IPv6, and deliver better programmatic support for configuration
    operations using APIs.
  prefs: []
  type: TYPE_NORMAL
- en: While there are definitely some advantages to the nftables architecture (which
    we'll cover in this chapter), there are decades of inertia in the current iptables
    approach. Entire automation frameworks and products are based on iptables. Once
    we get into the syntax, you'll see that this may look do-able, but keep in mind
    that often, Linux hosts will be deployed with lifetimes that stretch into decades
    – think cash registers, medical devices, elevator controls, or hosts that work
    with manufacturing equipment such as PLCs. In many cases, these long-lived hosts
    may not be configured to auto-update, so depending on the type of organization,
    at any time you can easily expect to work with hosts with complete OS versions
    from 5, 10, or 15 years ago. Also, because of what these devices are, even if
    they are connected to the network, they might not be inventoried as "computers."
    What this means is that while the migration of the default firewall from iptables
    to nftables may go quickly on the new versions of any particular distribution,
    there will be a long tail of legacy hosts that will run iptables for many years
    to come.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what iptables and nftables are, let's get on with configuring
    them, starting with iptables.
  prefs: []
  type: TYPE_NORMAL
- en: iptables from a high level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: itables is a Linux firewall application, installed by default in most modern
    distributions. If it's enabled, it governs all traffic in and out of the host.
    The firewall configuration is in a text file, as you would expect on Linux, which
    is organized into tables consisting of sets of rules called **chains**.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a packet matches a rule, the rule outcome will be a target. A target can
    be another chain, or it can be one of three main actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Accept**: The packet is passed through.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Drop**: The packet is dropped; it is not passed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Return**: Stops the packet from traversing this chain; tells it to go back
    to the previous chain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One of the default tables is called **filter**. This table has three default
    chains:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Input**: Controls packets inbound into the host'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Forward**: Processes incoming packets to be forwarded elsewhere'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Output**: Processes packets leaving the host'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other two default tables are **NAT** and **Mangle**.
  prefs: []
  type: TYPE_NORMAL
- en: As always with a new command, take a look at the iptables manual page, and also
    take a quick look at the iptables help text. To make it easier to read, you can
    run the help text through the `less` command, using `iptables -- help | less`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Out of the gate, by default iptables is not configured. We can see from `iptables
    –L -v` (for "list") that no rules are in any of the three default chains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the service is running, though the packets and bytes on the
    `INPUT` and `OUTPUT` chains are non-zero and increasing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to add a rule to a chain, we use the `-A` parameter. This command
    can take several arguments. Some commonly used parameters are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'So, for instance, these two rules would allow hosts from network `1.2.3.0/24`
    to port `tcp/22` on our host, and anything is allowed to connect to `tcp/443`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Port `tcp/22` is the SSH service and `tcp/443` is HTTPS, but there's nothing
    stopping you from running some other service on either port if you choose to.
    Of course, the rules come to nothing if you don't have anything running on those
    ports.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that executed, let''s look at our ruleset again. We''ll add line numbers
    with `- -line-numbers`, and skip any DNS resolution on addresses by using `–n`
    (for numeric):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The list of rules is processed sequentially from top to bottom, so if you wanted
    to, for instance, just deny access to our `https` server for one host but allow
    everything else, you would add a line number to the `INPUT` specifier. Note that
    we''ve changed up the `List` syntax in the second command of the following code
    block – we''re specifying just `INPUT` rules, and also specifying the `filter`
    table (the default if you don''t specify anything):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we used the `–I` parameter to insert a rule at a specific
    location in the chain. If, however, you have things planned out and are building
    your ruleset sequentially, you might find it easier to use the `–A` (append) parameter,
    which appends the rule to the bottom of the list.
  prefs: []
  type: TYPE_NORMAL
- en: In your source, you can define hosts rather than subnets, either just by IP
    address (with no mask) or by a range of addresses, for instance, `--src-range
    192.168.122.10-192.168.122.20`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This concept can be used to protect specific services running on a server.
    For instance, often you will want to restrict access to ports that allow administrative
    access (for instance, SSH) to only administrators of that host, but allow access
    more broadly to the main application on the host (for instance, HTTPS). The rules
    we''ve just defined are a start on exactly that, assuming the server''s administrators
    are on the `1.2.3.0/24` subnet. What we''ve missed, though, is the "deny" that
    stops people from connecting to SSH from other subnets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'These rules can become complex pretty quickly. It''s good to get into the habit
    of "grouping" protocol rules together. In our example, we''ve kept the SSH adjacent
    to each other and in a logical order, and the same for the HTTPS rules. You''ll
    want the default action for each protocol/port to be the last in each group, with
    the preceding exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Because the rules are processed sequentially, for performance reasons, you will
    want to put the rules most frequently "hit" toward the top of the list. So, in
    our example, we may have put our rules in backward. On many servers, you might
    rather have the application ports (in this case `tcp/443`) at the top of the list,
    with the admin permissions (which usually see lower volume traffic) toward the
    bottom of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'To delete a specific rule by number (for instance, `INPUT` rule 5 if we had
    one), use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Since a network administrator should maintain a focus on security in this book,
    keep in mind that restricting traffic using iptables is just the first half of
    the process. We can't look back on what happened in the past unless we have iptables
    logging enabled. To log a rule, add `-j LOG` to it. In addition to just logging,
    we can also add a logging level with the `- -log-level` parameter and some descriptive
    text with `- -log-prefix 'text goes here'`. What can you get from that?
  prefs: []
  type: TYPE_NORMAL
- en: Logging permitted SSH sessions allows us to track people that might be port-scanning
    the administrative services on our host.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging blocked SSH sessions tracks people trying to connect to administrative
    services from non-admin subnets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging successful and failed HTTPS connections allows us to correlate web server
    logs with local firewall logs when troubleshooting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To just log everything, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To just log traffic from one subnet, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To add both a logging level and some descriptive text, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Where do the logs go? In Ubuntu (our example OS), they are added to `/var/log/kern.log`.
    In Red Hat or Fedora, look for them in `/var/log/messages`.
  prefs: []
  type: TYPE_NORMAL
- en: What else should we consider doing? Like everything else in information technology,
    if you can build a thing and have it document itself, that often saves you from
    writing separate documentation (which is often outdated days after it's completed).
    To add a comment, simply add `–m comment - -comment "Comment Text Here"` to any
    rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for our small four-rule firewall table, we''ll add comments to each rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'A final note on iptables rules: there is a default rule that is the last entry
    in your chain, called `default policy`. The default value for this is `ACCEPT`,
    so that if a packet makes it all the way to the bottom of the list, it will be
    accepted. This is the commonly desired behavior if you plan to deny some traffic
    then permit the rest – for instance, if you are protecting a "mostly public" service,
    such as most web servers.'
  prefs: []
  type: TYPE_NORMAL
- en: If the desired behavior, however, is rather to permit some traffic then deny
    the rest, you may want to change that default policy to `DENY`. To make this change
    for the `INPUT` chain, use the `iptables –P INPUT DENY` command. `ACCEPT`.
  prefs: []
  type: TYPE_NORMAL
- en: You can always add a final rule, though, that permits all or denies all to override
    the default policy (whatever that is).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've got a basic ruleset in place, like so many things, you'll need
    to remember that this ruleset is not permanent – it's just running in memory so
    it won't survive a system restart. You can easily save your rules with the `iptables-save`
    command. If you've made an error in configuration and want to revert to the saved
    table without a reload, you can always use the `iptables-restore` command. While
    these commands are installed by default in the Ubuntu distribution, you may need
    to install a package to add them to other distributions. For example, in Debian-based
    distributions, check for or install the `iptables-persistent` package, or in Red
    Hat-based distributions, check for or install the `iptables-services` package.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a firm handle on the basic permit and deny rules, let's explore
    the **Network Address Translation** (**NAT**) table.
  prefs: []
  type: TYPE_NORMAL
- en: The NAT table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NAT is used to translate traffic that's coming from (or going to) one IP address
    or subnet and instead make it appear as another.
  prefs: []
  type: TYPE_NORMAL
- en: This is perhaps most commonly done in internet gateways or firewalls, where
    the "inside" addresses are in one or more of the RFC1918 ranges, and the "outside"
    interface connects to the entire internet. In this example, the internal subnets
    will be translated to routable internet addresses. In many cases, all internal
    addresses will map to a single "outside" address, the outside IP of the gateway
    host. In this example, this is done by mapping each "tuple" (source IP, source
    port, destination IP, destination port, and protocol) to a new tuple, where the
    source IP is now a routable outside IP, and the source port is just the next free
    source port (the destination and protocol values remain the same).
  prefs: []
  type: TYPE_NORMAL
- en: The firewall keeps this mapping from the inside tuple to the outside tuple in
    a "NAT table" in memory. When the return traffic arrives, it uses this table to
    map the traffic back to the real inside source IP and port. If a specific NAT
    table entry is for a TCP session, the TCP session teardown process removes the
    mapping for that entry. If a specific NAT table entry is for UDP traffic, that
    entry is usually removed after some period of inactivity.
  prefs: []
  type: TYPE_NORMAL
- en: 'How does this look for real? Let''s use an example of an internal network of
    `192.168.10.0/24`, and a NET configuration where all inside hosts have this "overload
    NAT" configuration, all using the outside interface of the gateway host:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Linux as a perimeter firewall'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_04_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – Linux as a perimeter firewall
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s be more specific. We''ll add a host, `192.168.10.10`, with that host
    making a DNS query to `8.8.8.8`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Perimeter firewall example, showing NAT and state (session tracking
    or mapping)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_04_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 – Perimeter firewall example, showing NAT and state (session tracking
    or mapping)
  prefs: []
  type: TYPE_NORMAL
- en: 'So, using this example, what does our configuration look like? It''s as simple
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This tells the gateway host to masquerade all traffic leaving interface `eth1`
    using the IP address of `eth1`. The `POSTROUTING` keyword tells it to use the
    `POSTROUTING` chain, meaning that this `MASQERADE` operation happens after the
    packet is routed.
  prefs: []
  type: TYPE_NORMAL
- en: Whether an operation happens pre- or post-routing starts to make a much bigger
    impact when we start to introduce encryption. For instance, if we encrypt traffic
    before or after a NAT operation, it may mean that traffic is encrypted in one
    instance but not the other. So, in this case, the outbound NAT would be the same
    pre- or post-routing. It's a good idea to start defining the order so that there's
    no confusion.
  prefs: []
  type: TYPE_NORMAL
- en: There are hundreds of variations on this, but the important thing at this point
    is that you have the basics of how NAT works (in particular the mapping process).
    Let's leave our NAT example and look at how the mangle table works.
  prefs: []
  type: TYPE_NORMAL
- en: The mangle table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The mangle table is used to manually adjust values in the IP packet as it transits
    our Linux host. Let's consider a brief example – using our firewall example from
    the previous section, what if the internet uplink on interface `eth1` is using
    a `1500` byte packet. DSL links, for instance, usually have some encapsulation
    overhead, and satellite links simply use smaller packets (so that any single-packet
    errors affect less traffic).
  prefs: []
  type: TYPE_NORMAL
- en: '"No problem," you say. "There''s a whole MTU "discovery" process that happens
    when sessions start up, where the two hosts that are communicating figure out
    what the largest packet possible is between the two parties." However, especially
    with older applications or specific Windows services, this process breaks. Another
    thing that might cause this is if the carrier network is blocking ICMP for some
    reason. This may seem like an extreme special case, but in practice, it comes
    up fairly frequently. Especially with legacy protocols, it''s common to see this
    MTU discovery process break. In situations like this, the mangle table is your
    friend!'
  prefs: []
  type: TYPE_NORMAL
- en: 'This example tells the mangle table "when you see a `SYN` packet, adjust the
    `1412` in this example):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are working out the configuration for real, how do you get this "smaller
    number"? If ICMP is being passed, you can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This tells `ping`, "Don't fragment the packet; send a `1400` byte size packet
    with a destination of `8.8.8.8`."
  prefs: []
  type: TYPE_NORMAL
- en: Often, it's a hunt-and-peck procedure to find the "real" size. Keep in mind
    that there are 28 bytes of packet header that's included in this size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Or if ICMP isn''t working, you can use `nping` (from our NMAP section). Here
    we''re telling `nping` to use TCP, port `53`, `mtu` value of `1400` for 1 second
    only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In both cases (`ping` and `nping`), you're looking for the largest number that
    works (in `nping`'s case, that would be the largest number where you are still
    seeing `RCVD` packets) to determine that help number for MSS.
  prefs: []
  type: TYPE_NORMAL
- en: You can see from this example that the mangle table gets used very infrequently.
    Often you are inserting or removing specific bits in the packet – for instance,
    you can, by traffic type, set the **Type of Service** (**TOS**) or **Differentiated
    Services field CodePoint** (**DSCP**) bits in the packet, to tell the upstream
    carrier what quality of service that specific traffic might need.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've covered some of the default tables in iptables, let's discuss
    why keeping the order of operations can be critical when building complex tables.
  prefs: []
  type: TYPE_NORMAL
- en: Order of operations in iptables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With some of the main iptables discussed, why is the order of operations important?
    We touched on one instance already – if you are encrypting traffic using IPSEC,
    there's normally a "match list" to define what traffic is being encrypted. Normally,
    you want this to match on traffic before it gets processed by the NAT table.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, you might be doing policy-based routing. For example, you might want
    to match traffic by source, destination, and protocol, and, for instance, forward
    your backup traffic over the link that has a lower per-packet cost and forward
    your regular traffic over the link that has better speed and latency characteristics.
    You'll usually want to make that decision prior to NAT as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several diagrams available to work out what iptables operations happen
    in which sequence. I normally refer to the one maintained by *Phil Hagen* at [https://stuffphilwrites.com/wp-content/uploads/2014/09/FW-IDS-iptables-Flowchart-v2019-04-30-1.png](https://stuffphilwrites.com/wp-content/uploads/2014/09/FW-IDS-iptables-Flowchart-v2019-04-30-1.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Order of operation in iptables'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_04_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3 – Order of operation in iptables
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, configuring, processing, and especially debugging iptables configurations
    can become extremely complex. In this chapter, we're focusing on the input table,
    specifically to restrict or permit access to services that are running on the
    host. As we proceed on to discuss various services running on Linux, you should
    be able to use this knowledge to see where input rules can be used to protect
    services in your environment.
  prefs: []
  type: TYPE_NORMAL
- en: Where can you go next with iptables? As always, review the man page again –
    with roughly 100 pages of syntax and examples, the iptables man pages are a great
    resource if you want to dive deeper into this feature. For instance, as we discussed,
    you can run a Linux host as a router or a NAT-based firewall just using iptables
    and some static routes. These aren't normal use cases in a regular data center,
    though. It's common to run features like this on Linux hosts, but in most cases,
    you would see these executed on a prepackaged Linux distribution such as the VyOS
    distribution or FRR/Zebra package for routers, or the pfSense or OPNsense firewall
    distributions.
  prefs: []
  type: TYPE_NORMAL
- en: With the basics of iptables mastered, let's tackle the configuration of the
    nftables firewall.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring nftables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed at the beginning of this chapter, iptables is being deprecated
    and eventually retired in Linux, in favor of nftables. With that in mind, what
    advantages does using nftables bring?
  prefs: []
  type: TYPE_NORMAL
- en: Deploying nftables rules is much quicker than in iptables – under the hood,
    iptables modifies the kernel as each rule is added. This doesn't happen in nftables.
    Related to that, nftables also has an API. This makes it much easier to configure
    using orchestration or "network as code" tools. These tools include apps such
    as Terraform, Ansible, Puppet, Chef, and Salt. What this allows system administrators
    to do is more easily automate the deployment of hosts, so that a new virtual machine
    can be deployed into a private or public cloud in minutes, rather than in hours.
    More importantly, applications that might involve several hosts can be deployed
    in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: nftables also operates much more efficiently in the Linux kernel, so for any
    given ruleset, you can count on nftables to take less CPU. This may not seem like
    a big deal for our ruleset of just four rules, but if you had 40, 400, or 4,000
    rules, or 40 rules on 400 virtual machines, this could add up in a hurry!
  prefs: []
  type: TYPE_NORMAL
- en: 'nftables uses a single command for all operations – `nft`. While you can use
    iptables syntax for compatibility, what you''ll find is that there are no predefined
    tables or chains, and more importantly, you can have multiple operations within
    a single rule. We haven''t talked much about IPv6 yet, but iptables just on its
    own doesn''t handle IPv6 (you''ll need to install a new package for that: ip6tables).'
  prefs: []
  type: TYPE_NORMAL
- en: With the basics covered, let's dive into the command line and the details of
    using the `nft` command to configure the nftables firewall.
  prefs: []
  type: TYPE_NORMAL
- en: nftables basic configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, it's likely wise to look at the man page for nftables. Also,
    take a look at the man page for the main nftables command – `nft`. This manual
    is even more lengthy and complex than iptables; it's upward of 600 pages long.
  prefs: []
  type: TYPE_NORMAL
- en: With that in mind, let's deploy the same example configuration that we did for
    iptables. A straight `INPUT` firewall to protect the host is by far the most often-seen
    style of Linux firewall in most data centers.
  prefs: []
  type: TYPE_NORMAL
- en: First, be sure to document any existing iptables and ip6tables rules that you
    have in place (`iptables –L` and `ip6tables –L`), then clear both (with the `–F`
    option). Just because you can run iptables and nftables simultaneously, doesn't
    mean that it's a good idea to do so. Think of the next person who administers
    this host; they'll see one or the other firewall and think that's all that's been
    deployed. It's always wise to configure things for the next person who will inherit
    the host you're working on!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have an existing iptables ruleset, especially if it''s a complex ruleset,
    then the `iptables-translate` command will turn hours of work into minutes of
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this syntax, our iptables rules turn into a very similar set of nftables
    rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we created a table and a chain first, before we could add rules.
    Now to list our ruleset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As in so many Linux network constructs, nftables rules are not persistent at
    this point; they'll only be there until the next system reload (or service restart).
    The default `nftools` ruleset is in `/etc/nftools.conf`. You can make our new
    rules persistent by adding them to this file.
  prefs: []
  type: TYPE_NORMAL
- en: Especially in a server configuration, updating the `nftools.conf` file can end
    up with a pretty complex construction. This can be simplified considerably by
    breaking the `nft` configuration into logical sections and breaking them out into
    `include` files.
  prefs: []
  type: TYPE_NORMAL
- en: Using include files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What else can you do? You can set up a "case" structure, segmenting your firewall
    rules to match your network segments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, the three chains defined have their own sets of inbound rules or outbound
    rules.
  prefs: []
  type: TYPE_NORMAL
- en: You can see that each rule is a `match` clause, which then jumps the matching
    traffic to a ruleset that governs the subnet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than making a single, monolithic nftables file, you can separate statements
    in a logical way by using `include` statements. This allows you to, for instance,
    maintain a single rules file for all web servers, SSH servers, or whatever other
    server or service class, so that you end up with a number of standard `include`
    files. These files can then be included as needed, in a logical order in the master
    file on each host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Or, you can make rules more and more complex – to the point where you have rules
    based on IP header fields such as **Differentiated Services Code Point** (**DSCP**),
    which are six bits in the packet that are used to determine or enforce **Quality
    of Service** (**QOS**), in particular for the voice of video packets. You might
    also decide to apply firewall rules pre- or post-routing (which really helps if
    you are doing IPSEC encryption).
  prefs: []
  type: TYPE_NORMAL
- en: Removing our Firewall Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can proceed to the next chapter, we should remove our example firewall
    configuration, with the following two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While many distributions still have iptables as their default firewall, over
    time we can expect to see that situation shift to the newer nftables architecture.
    It will take some years before this transition is complete, and even then the
    odd "surprise" will pop up, as you find hosts that you didn't have in your inventory,
    or devices that you didn't realize were Linux-based computers – **Internet of
    Things** (**IoT**) devices such as thermostats, clocks, or elevator controls come
    to mind. This chapter has gotten us started with both architectures.
  prefs: []
  type: TYPE_NORMAL
- en: With roughly 150 pages in the man pages for nftables and 20 for iptables, that
    documentation is essentially a standalone book all on its own. We've scratched
    the surface of the tool, but in a modern data center, defining an ingress filter
    on each host is the most common use you'll see for nftables. However, as you explore
    the security requirements in your data center, outbound and transit rules may
    certainly have a place in your strategy. I hope this discussion is a good start
    on your journey!
  prefs: []
  type: TYPE_NORMAL
- en: If you find any of the concepts that we've discussed in this chapter fuzzy at
    all, now is a great time to review them. In the next chapter, we'll be discussing
    an overall hardening approach to Linux servers and services – the Linux firewall,
    of course, is a key part of this discussion!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material. You will find the answers in the *Assessments*
    section of the *Appendix*:'
  prefs: []
  type: TYPE_NORMAL
- en: If you were starting a new firewall strategy, which method would you choose?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you implement central standards for firewalls?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Man pages for iptables: [https://linux.die.net/man/8/iptables](https://https://linux.die.net/man/8/iptables%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'iptables processing flowchart (Phil Hagen):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://stuffphilwrites.com/2014/09/iptables-processing-flowchart/](https://stuffphilwrites.com/2014/09/iptables-processing-flowchart/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://stuffphilwrites.com/wp-content/uploads/2014/09/FW-IDS-iptables-Flowchart-v2019-04-30-1.png](https://stuffphilwrites.com/wp-content/uploads/2014/09/FW-IDS-iptables-Flowchart-v2019-04-30-1.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Man pages for NFT: [https://www.netfilter.org/projects/nftables/manpage.html](https://https://www.netfilter.org/projects/nftables/manpage.html%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'nftables wiki: [https://wiki.nftables.org/wiki-nftables/index.php/Main_Page](https://https://wiki.nftables.org/wiki-nftables/index.php/Main_Page%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*nftables in 10 minutes*: [https://wiki.nftables.org/wiki-nftables/index.php/Quick_reference-nftables_in_10_minutes](https://https://wiki.nftables.org/wiki-nftables/index.php/Quick_reference-nftables_in_10_minutes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
