- en: Chapter 1. Getting Started with Regex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Regular expressions** are special kinds of tools used to represent patterns
    syntactically. When working with any type of textual input, you don''t always
    know what the value will be, but you can usually assume (or even demand) the format
    you are going to receive into your application. These types of situations arise
    when you create a regular expression to extract and manipulate this input.'
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, to match a specific pattern requires a very mechanical syntax,
    since a change in even a single character or two can vastly change the behavior
    of a regular expression and, as a result, the final outcome as well.
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions by themselves (or **Regex**, for short) are not specific
    to any single programming language and you can definitely use them in nearly all
    the modern languages straight out of the box. However, different languages have
    implemented Regex with different feature sets and options; in this book, we will
    be taking a look at Regex through **JavaScript**, and its specific implementation
    and functions.
  prefs: []
  type: TYPE_NORMAL
- en: It's all about patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regular expressions are strings that describe a pattern using a specialized
    syntax of characters, and throughout this book, we will be learning about these
    different characters and codes that are used to match and manipulate different
    pieces of data in a vague sort of manner. Now, before we can attempt to create
    a regular expression, we need to be able to spot and describe these patterns (in
    English). Let's take a look at a few different and common examples and later on
    in the book, when we have a stronger grasp on the syntax, we will see how to represent
    these patterns in code.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing a phone number
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s begin with something simple, and take a look at a single phone number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can describe this pattern as being three digits, a dash, then another three
    numbers, followed by a second dash, and finally four more numbers. It is pretty
    simple to do; we look at a string and describe how it is made up, and the preceding
    description will work perfectly if all your numbers follow the given pattern.
    Now, let''s say, we add the following three phone numbers to this set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'These are all valid phone numbers, and in your application, you probably want
    to be able to match all of them, giving the user the flexibility to write in whichever
    manner they feel most comfortable. So, let''s have another go at our pattern.
    Now, I would say we have three numbers, optionally inside brackets, then an optional
    dash, another three numbers, followed by another optional dash, and finally four
    more digits. In this example, the only parts that are mandatory are the ten digits:
    the placing of dashes and brackets would completely be up to the user.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice also that we haven''t put any constraints on the actual digits, and
    as a matter of fact, we don''t even know what they will be, but we do know that
    they have to be numbers (as opposed to letters, for instance), so we''ve only
    placed this constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Analyzing a phone number](img/2258OS_01_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Analyzing a simple log file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, we might have a more specific constraint than just a digit or a
    letter; in other cases, we may want a specific word or at least a word from a
    specific group. In these cases (and mostly with all patterns), the more specific
    you can be, the better. Let''s take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is an example of some sort of log, of course, and we can simply say that
    each line is a single log message. However, this doesn't help us if we want to
    manipulate or extract the data more specifically. Another option would be to say
    that we have some kind of word in brackets, which refers to the log level, and
    then a message after the dash, which will consist of any number of words. Again,
    this isn't too specific, and our application may only know how to handle the three
    preceding log levels, so, you may want to ignore everything else or raise an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'To best describe the preceding pattern, we would say that you have a word,
    which can either be info, a warning, or an error inside a pair of square brackets,
    followed by a dash and then some sort of sentence, which makes up the log message.
    This will allow us to capture the information from the log more accurately and
    make sure our system is ready to handle the data before we send it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Analyzing a simple log file](img/2258OS_01_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Analyzing an XML file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last example I want to discuss is when your pattern relies on itself; a
    perfect example of this is with something like **XML**. In XML you may have the
    following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We could just say that the pattern consists of a tag, some text, and a closing
    tag. This isn''t really specific enough for it to be a valid XML, since the closing
    tag has to match the opening one. So, if we define the pattern again, we would
    say that it contains some text wrapped by an opening tag on the left-hand side
    and a matching closing tag on the right-hand side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Analyzing an XML file](img/2258OS_01_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last three examples were just used to get us into the Regex train of thought;
    these are just a few of the common types of patterns and constraints, which you
    can use in your own applications.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what kind of patterns we can create, let's take a moment to
    discuss what we can do with them; this includes the actual features and functions
    JavaScript provides to allow us to use these patterns once they're made.
  prefs: []
  type: TYPE_NORMAL
- en: Regex in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In JavaScript, regular expressions are implemented as their own type of object
    (such as the `RegExp` object). These objects store patterns and options and can
    then be used to test and manipulate strings.
  prefs: []
  type: TYPE_NORMAL
- en: To start playing with regular expressions, the easiest thing to do is to enable
    a JavaScript console and play around with the values. The easiest way to get a
    console is to open up a browser, such as **Chrome**, and then open the JavaScript
    console on any page (press the *command* + *option* + *J* on a Mac or *Ctrl* +
    *Shift* + *J*).
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by creating a simple regular expression; we haven't yet gotten into
    the specifics of the different special characters involved, so for now, we will
    just create a regular expression that matches a word. For example, we will create
    a regular expression that matches `hello`.
  prefs: []
  type: TYPE_NORMAL
- en: The RegExp constructor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Regular expressions can be created in two different ways in JavaScript, similar
    to the ones used in strings. There is a more explicit definition, where you call
    the constructor function and pass it the pattern of your choice (and optionally
    any settings as well), and then, there is the literal definition, which is a shorthand
    for the same process. Here is an example of both (you can type this straight into
    the JavaScript console):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Both these variables are essentially the same, it''s pretty much a personal
    preference as to which you would use. The only real difference is that with the
    constructor method you use a string to create an expression: therefore, you have
    to make sure to escape any special characters beforehand, so it gets through to
    the regular expression.'
  prefs: []
  type: TYPE_NORMAL
- en: Besides a pattern, both forms of Regex constructors accept a second parameter,
    which is a string of flags. **Flags** are like settings or properties, which are
    applied on the entire expression and can therefore change the behavior of both
    the pattern and its methods.
  prefs: []
  type: TYPE_NORMAL
- en: Using pattern flags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first flag I would like to cover is the **ignore case** or **i** flag. Standard
    patterns are case sensitive, but if you have a pattern that can be in either case,
    this is a good option to set, allowing you to specify only one case and have the
    modifier adjust this for you, keeping the pattern short and flexible.
  prefs: []
  type: TYPE_NORMAL
- en: The next flag is the **multiline** or **m** flag, and this makes JavaScript
    treat each line in the string as essentially the start of a new string. So, for
    example, you could say that a string must start with the letter **a**. Usually,
    JavaScript would test to see if the entire string starts with the letter a, but
    with the m flag, it will test this constraint against each line individually,
    so any of the lines can pass this test by starting with a.
  prefs: []
  type: TYPE_NORMAL
- en: The last flag is the **global** or **g** flag. Without this flag, the `RegExp`
    object only checks whether there is a match in the string, returning on the first
    one that's found; however, in some situations, you don't just want to know if
    the string matches, you may want to know about all the matches specifically. This
    is where the global flag comes in, and when it's used, it will modify the behavior
    of the different `RegExp` methods to allow you to get to all the matches, as opposed
    to only the first.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, continuing from the preceding example, if we wanted to create the same
    pattern, but this time, with the case set as insensitive and using global flags,
    we would write something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Using the rgx.test method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have created our regular expression objects, let''s use its simplest
    function, the `test` function. The `test` method only returns `true` or `false`,
    based on whether a string matches a pattern or not. Here is an example of it in
    action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the first string matches and returns true, and the second string
    does not contain `hello`, so it returns `false`, and finally the last string *matches
    the pattern*. In the pattern, we did not specify that the string had to only contain
    `hello`, so it matches the last string and returns `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the rgx.exec method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next method on the `RegExp` object, is the `exec` function, which, instead
    of just checking whether the pattern matches the text or not, `exec` also returns
    some information about the match. For this example, let's create another regular
    expression, and get `index` for the start of the pattern;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see here, the result from the function contains the actual match
    as the first element (`rgx.exec("world !!")[0];`) and if you `console.dir` the
    results, you will see it also contains two properties: `index` and `input`, which
    store the starting `index` property and complete the `input` text, respectively.
    If there are no matches, the function will return `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the rgx.exec method](img/2258OS_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The string object and regular expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides these two methods on the `RegExp` object itself, there are a few methods
    on the string object that accept the `RegExp` object as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Using the String.replace method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most commonly used method is the `replace` method. As an example, let''s
    say we have the `foo foo` string and we want to change it to `qux qux`. Using
    `replace` with a string would only switch the first occurrence, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the String.replace method](img/2258OS_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to replace all the occurrences, we need to supply a `RegExp` object
    that has the `g` flag, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the String.replace method](img/2258OS_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using the String.search method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, if you just want to find the (zero-based) index of the first match in
    a string, you can use the `search` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Using the String.match method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last method I want to talk about right now is the `match` function. This
    function returns the same output as the `exec` function we saw earlier when there
    was no `g` flag (it includes the `index` and `input` properties), but returned
    a regular `Array` of all the matches when the `g` flag was set. Here is an example
    of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the String.match method](img/2258OS_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have taken a quick pass through the most common uses of regular expressions
    in JavaScript (code-wise), so we are now ready to build our `RegExp` testing page,
    which will help us explore the actual syntax of Regex without combining it with
    JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: Building our environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to test our Regex patterns, we will build an **HTML** form, which will
    process the supplied pattern and match it against a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'I am going to keep all the code in a single file, so let''s start with the
    head of the HTML document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: It is a fairly standard document head, and contains a title and some styles.
    Besides this, I am including the bootstrap **CSS** framework for design, and the
    jQuery library to help with the **DOM** manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s create the form and result area in the body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of this code is boilerplate HTML required by the Bootstrap library for
    styling; however, the gist of it is that we have two inputs: one for some text
    and the other for the pattern to match against it. We have a button to submit
    the form (the `Test!` button) and an extra `div` to display the results.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Opening this page in your browser should show you something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building our environment](img/2258OS_01_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Handling a submitted form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last thing we need to do is handle the form being submitted and run a regular
    expression. I broke the code into helper functions to help with the code flow
    when we go through it now. To begin with, let''s write the full-click handler
    for the submit (`Test!`) button (this should go where I''ve inserted the comment
    in the script tags):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first four lines select the corresponding DOM element from the page using
    jQuery, and store them for use throughout the application. This is a best practice
    when the DOM is static, instead of selecting the element each time you use it.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the code is the click handler for the submit (`Test!`) button. In
    the function that handles the `Test!` button, we start by clearing the results
    and errors from the previous run. Next, we pull in the values from the two text
    boxes and handle the cases where they are empty using a function called `err`,
    which we will take a look at in a moment. If the two values are fine, we attempt
    to create a new `RegExp` object and we get their results using two other functions
    I wrote called `createRegex` and `getMatches`, respectively. Finally, the last
    conditional block checks whether there were results and displays either a **No
    Matches Found** message or an element on the page that will show individual matches
    using `getMatchesCountString` to display how many matches were found and `getResultsString`
    to display the actual matches in `string`.
  prefs: []
  type: TYPE_NORMAL
- en: Resetting matches and errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at some of these helper functions, starting with `err`
    and `clearResultsAndErrors`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The first function clears the text from the results element and then hides the
    previous errors, and the second function un-hides the alert element and adds the
    error passed in as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a regular expression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next function I want to take a look at is in charge of creating the actual
    `RegExp` object from the value given in the textbox:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If you try and create a `RegExp` object with flags that don't exist or invalid
    parameters, it will throw an exception. Therefore, we need to wrap the `RegExp`
    creation in a `try`/`catch` block, so that we can catch the error and display
    an error for it.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `try` section, we will handle two different kinds of `RegExp` input,
    the first is when you use forward slashes in your expressions. In this situation,
    we split this expression by forward slashes, remove the first element, which will
    be an empty string (the text before it is the first forward slash), and then pop
    off the last element which is supposed to be in the form of flags.
  prefs: []
  type: TYPE_NORMAL
- en: We then recombine the remaining parts back into a string and pass it in along
    with the flags into the `RegExp` constructor. The other case we are dealing with
    is where you wrote a string, and then we are simply going to pass this pattern
    to the constructor with only the `g` flag, so as to get multiple results.
  prefs: []
  type: TYPE_NORMAL
- en: Executing RegExp and extracting its matches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next function we have is for actually cycling through the `regex` object
    and getting `results` from different matches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We have already seen the `exec` command earlier and how it returns a `results`
    object for each match, but the `exec` method actually works differently, depending
    on whether the global flag (`g`) is set or not. If it is not set, it will constantly
    just return the first match, no matter how many times you call it, but if it is
    set, the function will cycle through the results until the last match returns
    `null`. In the function, the global flag is set, I use a while loop to cycle through
    `results` and push each one into the `results` array, whereas if it is not set,
    I simply call `function` once and push only if the first match on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have a function that will create a string that displays how many matches
    we have (either one or more):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have `function`, which will cycle through the `results` array and
    create an HTML string to display on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Inside `function`, we cycle through a list of matches and for each one, we cut
    the string and wrap the actual match inside a label for styling purposes. We need
    to cycle through the list in reverse order as we are changing the actual text
    by adding labels and also so as to change the indexes. In order to keep in sync
    with the indexes from the `results` array, we modify `text` from the end, keeping
    `text` that occurs before it, the same.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If everything goes as planned, we should now be able to test the application.
    For example, let''s say we enter the `Hello World` string as the text and add
    the `l` pattern (which if you remember will be similar to entering `/l/g` into
    our application), you should get something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing our application](img/2258OS_01_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Whereas, if we specify the same pattern, though without the global flag, we
    would only get the first match:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing our application](img/2258OS_01_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Of course, if you leave out a field or specify an invalid pattern, our error
    handling will kick in and provide an appropriate message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing our application](img/2258OS_01_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With this all working as expected, we are now ready to start learning Regex
    by itself, without having to worry about the JavaScript code alongside it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a look at what a pattern actually is, and at the kind
    of data we are able to represent. Regular expressions are simply strings that
    express these patterns, and combined with functions provided by JavaScript, we
    are able to match and manipulate user data.
  prefs: []
  type: TYPE_NORMAL
- en: We also covered building a quick `RegExp` builder that allowed us to get a first-hand
    look at how to use regular expressions in a real-world setting. In the next chapter,
    we will continue to use this testing tool to start exploring the `RegExp` syntax.
  prefs: []
  type: TYPE_NORMAL
