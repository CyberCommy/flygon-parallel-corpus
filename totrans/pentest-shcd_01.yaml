- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the first chapter of *Penetration Testing with Shellcode*. The term
    **penetration testing** refers to attacking a system without causing any damage
    to the system. The motive behind the attack is to find the system's flaws or vulnerabilities
    before attackers also find ways to get inside the system. Hence, to measure how
    the system resists exposing sensitive data, we try collecting as much data as
    possible and to perform penetration testing using shellcode, we have to first
    understand overflow attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Buffer overflow is one of the oldest and the most destructive vulnerabilities
    that could cause critical damage to an operating system, remotely or locally.
    Basically, it's a serious problem because certain functions don't know whether
    the input data can fit inside the preallocated space or not. So, if we add more
    data than the allocated space can hold, then this will cause overflow. With shellcode
    in the picture, we can change the execution flow of the same application. The
    main core of that damage is the payload generated by shellcode. With the spread
    of all kinds of software, even with a strong support like Microsoft, it could
    leave you vulnerable to such attacks. Shellcode is exactly what we want to be
    executed after we control the flow of execution, which we will talk about later
    in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a stack?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a buffer?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is stack overflow?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a heap?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is heap corruption?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is shellcode?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to computer architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a system call?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: What is a stack?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **stack** is an allocated space in the memory for each running application,
    used to hold all the variables inside it. The operating system is responsible
    for creating a memory layout for each running application, and within each memory
    layout, there is a stack. A stack is also used to save the return address so that
    the code can go back to the calling function.
  prefs: []
  type: TYPE_NORMAL
- en: A stack uses **Last Input First Output **(**LIFO**) to store elements in it,
    and there is a stack pointer (we will talk about it later), which points to the
    top of the stack and also uses *push* to store an element at the top of stack
    and *pop* to extract the element from the top of the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following example to understand this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how the preceding code works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main` function will start first, the variable `x` will be pushed into
    the stack, and it will print out the sentence `This is the main function`, as
    shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00005.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `main` function will call `function1` and before moving forward to `function1`,
    the address of `printf("After calling function1\n")` will be saved into the stack
    in order to continue the execution flow. After finishing `function1` by pushing
    variable `y` in the stack, it will execute `printf("This is function1\n")`, as
    shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00006.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, go back to the `main` function again to execute `printf("After calling
    function1\n")`, and push the address of `printf("After calling function2")` in
    the stack, as shown:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00007.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now control will move forward to execute `function2` by pushing the variable
    `z` into the stack and then execute `printf("This is function2\n")`, as shown
    in the following diagram:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Then, go back to the `main` function to execute `printf("After calling function2")` and
    exit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a buffer?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **buffer** is a temporary section of the memory used to hold data, such as
    variables. A buffer is only accessible or readable inside its function until it
    is declared global; when a function ends, the buffer ends with it; and all programs
    have to deal with the buffer when there is data storing or retrieving.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'What does this section of C code mean? It tells the computer to allocate a
    temporary space (buffer) with the size of `char`, which can hold up to 1 byte.
    You can use the `sizeof` function to confirm the size of any data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you can use the same code to get the size of other data types such
    as the `int` data type.
  prefs: []
  type: TYPE_NORMAL
- en: What is stack overflow?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Stack overflow** occurs when you put more data into a buffer than it can
    hold, which causes the buffer to be filled up and overwrite neighboring places
    in memory with what''s left over of the input. This occurs when the function,
    which is responsible for copying data, doesn''t check if the input can fit inside
    the buffer or not, such as `strcpy`. We can use stack overflow to change the execution
    flow of a code to another code using shellcode.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The code works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `copytobuffer` function, it allocates a buffer with the size of `15`
    characters, but this buffer can only hold 14 characters and a null-terminated
    string `\0`, which indicates the end of the array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You don't have to end arrays with a null-terminated string; the compiler will
    do it for you.
  prefs: []
  type: TYPE_NORMAL
- en: Then, there is `strcpy`, which takes input from the user and copies it into
    the allocated buffer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `main` function, it calls `copytobuffer` and passes the `argv` argument
    to `copytobuffer`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What really happens when the `main` function calls the `copytobuffer` function?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the answers to this question:'
  prefs: []
  type: TYPE_NORMAL
- en: The **return address** of the `main` function will be pushed in memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **old base pointer** (explained in the next section) will be saved in memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A section of memory will be allocated as the buffer with a size of 15 bytes
    or *15*8 *bits:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00009.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we agreed that this buffer will take only 14 characters but the real problem
    is inside the `strcpy` function, because it doesn't check for the size of the
    input, it just copies the input into the allocated buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try now to compile and run this code with 14 characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a look at the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the program exited without error. Now, let''s try it again
    but with 15 characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'And now let''s take another look at the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is a stack overflow, and a segmentation fault is an indication that there
    is a violation in memory; what happened is the user's input overflowed the allocated
    buffer, thus filling the old base pointer and **return address**.
  prefs: []
  type: TYPE_NORMAL
- en: A **segmentation fault** means a violation in the user space memory, and **kernel
    panic** means a violation in kernel-space.
  prefs: []
  type: TYPE_NORMAL
- en: What is a heap?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **heap** is a portion of memory that is dynamically allocated by the application
    at runtime. A heap can be allocated using the `malloc` or `calloc` function in
    C. A heap is different from a stack as a heap remains until:'
  prefs: []
  type: TYPE_NORMAL
- en: The program exits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will be deleted using the `free` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A heap is different from a stack because in a heap, a very large space can be
    allocated, and there is no limit on the allocated spaces such as in a stack, where
    there is a limited space depending on the operating system. You can also resize
    a heap using the `realloc` function, but you can't resize the buffer. When using
    the heap, you must deallocate the heap after finishing by using the `free` function,
    but not in the stack; also, the stack is faster than the heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: What does this section of C code mean?
  prefs: []
  type: TYPE_NORMAL
- en: It tells the computer to allocate a section in heap memory with a size of `15`
    bytes and it should also hold 14 characters plus a null-terminated string `\0`.
  prefs: []
  type: TYPE_NORMAL
- en: What is heap corruption?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Heap corruption occurs when data copied or pushed into a heap is larger than
    the allocated space. Let''s look at a full heap example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the first line of code, it allocates a heap with a size of `15` bytes using
    the `malloc` function; in the second line of code, it copies the user's input
    into the heap using the `strcpy` function; in the third line of code, it sets
    the heap free using the `free` function, back to the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s compile and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s try to crash it using a larger input:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This crash is a heap corruption, which forced the program to terminate.
  prefs: []
  type: TYPE_NORMAL
- en: Memory layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the complete memory layout for a program that contains:'
  prefs: []
  type: TYPE_NORMAL
- en: The `.text` section which is used to hold the **program code**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `.data` section which is used to hold **initialized data**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `.BSS` section which is used to hold **uninitialized data**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **heap** section which is used to hold ****dynamically allocated variables****
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **stack** section which is used to hold non-dynamically allocated variables
    such as buffers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Look at how the **heap** and **stack** are growing; the **stack** grows from
    **high memory** to **low memory**, whereas the **heap** grows from **low memory**
    to **high memory**.
  prefs: []
  type: TYPE_NORMAL
- en: What is shellcode?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shellcode is like a payload that is used in overflow exploitation written in
    machine language. Hence, the shellcode is used to override the flow of execution
    after exploiting a vulnerable process, such as making the victim's machine connect
    back to you to spawn a shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example is a shellcode for Linux x86 SSH Remote port forwarding which
    executes the `ssh -R 9999:localhost:22 192.168.0.226` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is the assembly language of that shellcode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Computer architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s walk through some concepts in computer architecture (Intel x64). The
    major components of a computer are shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s dive a little more inside the CPU. There are three parts to the CPU:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arithmetic logic unit** (**ALU**): This part is responsible for performing
    arithmetic operations, such as addition and subtraction and logic operations,
    such as ADD and XOR'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Registers**: This is what we really care about in this book, they are a superfast
    memory for the CPU that we will discuss in the next section'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Control unit** (**CU**): This part is responsible for communications between
    the ALU and the registers, and between the CPU itself and other devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we said earlier, registers are like a superfast memory for the CPU to store
    or retrieve data in processing, and they are divided into the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: General purpose registers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are 16 general purpose registers in the Intel x64 processor:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The accumulator register (**RAX**) is used in arithmetic operations—**RAX**
    holds **64** bits, **EAX** holds **32** bits, **AX** holds **16** bits, **AH**
    holds **8** bits, and **AL** holds **8** bits:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The base register (**RBX**) is used as a pointer to data—**RBX** holds **64**
    bits, **EBX** holds **32** bits, **BX** holds **16** bits, **BH** holds **8**
    bits, and **BL** holds **8** bits:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00019.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The counter register (**RCX**) is used in loops and shift operations—**RCX**
    holds **64** bits, **ECX** holds **32** bits, **CX** holds **16** bits, **CH**
    holds **8** bits, and **CL** holds **8** bits:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The data register (**RDX**) is used as a data holder and in arithmetic operations—**RDX**
    holds **64** bits, **EDX** holds **32** bits, **DX** holds **16** bits, **DH**
    holds **8** bits, and **DL** holds **8** bits:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The source index register (**RSI**) is used as a pointer to a source—**RSI**
    holds **64** bits, **ESI** holds **32** bits, **DI** holds **16** bits, and **SIL**
    holds **8** bits:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The destination index register (**RDI**) is used as a pointer to a destination—**RDI**
    holds **64** bits, **EDI** holds **32** bits, **DI** holds **16** bits, and **DIL**
    hold **8** bits:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00023.jpeg)**RSI** and **RDI** are both used in stream operations and
    string manipulation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The stack pointer register (**R****SP**) is used as a pointer to the top of
    the stack—**RSP** holds **64** bits, **ESP** holds **32** bits, **SP** holds **16**
    bits, and **SPL** holds **8** bits:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00024.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The base pointer register (**RBP**) is used as a pointer to the base of the
    stack—**RBP** holds **64** bits, **EBP** holds **32** bits, **BP** holds **16**
    bits, and **BPL** holds **8** bits:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The registers R8, R9, R10, R11, R12, R13, R14, and R15 have no specific operations,
    but they do not have the same architecture as the previous registers, such as
    **high** (**H**) value or **low** (**L**) value. However, they can be used as
    **D** for **double-word**, **W** for **word**, or **B** for **byte**. Let''s look
    at **R8** for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here, **R8** holds **64** bits, **R8D** holds **32** bits, **R8W** holds **16**
    bits, and **R8B** holds **8** bits.
  prefs: []
  type: TYPE_NORMAL
- en: R8 through R15 only exist in Intel x64 but not in x84.
  prefs: []
  type: TYPE_NORMAL
- en: Instruction pointer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The instruction pointer register or RIP is used to hold the next instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following example first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing that will be executed is the `main` function, then it will
    call the `printsomething` function. But before it calls the `printsomething` function,
    the program needs to know exactly what the next operation is after executing the
    `printsomething` function. So before calling `printsomething`, the next instruction
    that is `printf("This is after print something function\n")` will have its location
    pushed into the **RIP** and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here, **RIP** holds **64** bits, **EIP** holds **32** bit, and **IP** holds
    **16** bits.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table sums up all the general-purpose registers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **64-bit register** | **32-bit register** | **16-bit register** | **8-bit
    register** |'
  prefs: []
  type: TYPE_TB
- en: '| RAX | EAX | AX | AH,AL |'
  prefs: []
  type: TYPE_TB
- en: '| RBX | EBX | BX | BH, BL |'
  prefs: []
  type: TYPE_TB
- en: '| RCX | ECX | CX | CH, CL |'
  prefs: []
  type: TYPE_TB
- en: '| RDX | EDX | DX | DH,DL |'
  prefs: []
  type: TYPE_TB
- en: '| RSI | ESI | SI | SIL |'
  prefs: []
  type: TYPE_TB
- en: '| RDI | EDI | DI | DIL |'
  prefs: []
  type: TYPE_TB
- en: '| RSP | ESP | SP | SPL |'
  prefs: []
  type: TYPE_TB
- en: '| RBP | EBP | BP | BPL |'
  prefs: []
  type: TYPE_TB
- en: '| R8 | R8D | R8W | R8B |'
  prefs: []
  type: TYPE_TB
- en: '| R9 | R9D | R9W | R9B |'
  prefs: []
  type: TYPE_TB
- en: '| R10 | R10D | R10W | R10B |'
  prefs: []
  type: TYPE_TB
- en: '| R11 | R11D | R11W | R11B |'
  prefs: []
  type: TYPE_TB
- en: '| R12 | R12D | R12W | R12B |'
  prefs: []
  type: TYPE_TB
- en: '| R13 | R13D | R13W | R13B |'
  prefs: []
  type: TYPE_TB
- en: '| R14 | R14D | R14W | R14B |'
  prefs: []
  type: TYPE_TB
- en: '| R15 | R15D | R15W | R15B |'
  prefs: []
  type: TYPE_TB
- en: Flags registers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are registers that the computer uses to control the execution flow. For
    example, the JMP operation in assembly will be executed based on the value of
    flag registers such as the **jump if zero** (**JZ**) operation, meaning that the
    execution flow will be changed to another flow if the zero flag contains 1\. We
    are going to talk about the most common flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The **c****arry flag** (**CF**) is set in arithmetic operations if there is
    a carry in addition or borrow in subtraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **parity flag** (**PF**) is set if the number of set bits is even
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **adjust flag** (**AF**) is set in arithmetic operations if there is a carry
    of binary code decimal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **zero flag** (**ZF**) is set if the result is zero
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **sign flag** (**SF**) is set if the most significant bit is one (the number
    is negative)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **overflow flag** (**OF**) is set in arithmetic operations if the result
    of the operation is too large to fit in a register
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Segment registers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are six segment registers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The **c****ode segment** (**CS**) points to the starting address of the **code
    segment** in the **stack**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **stack segment** (**SS**) points to the starting address of the **stack**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **data segment** (**DS**) points to the starting address of the **data segment**
    in the **stack**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **extra segment** (**ES**) points to **extra data**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **F segment** (**FS**) points to **extra data**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **G segment** (**GS**) points to **extra data**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The F in FS means F after E in ES; and, the G in GS means G after F.
  prefs: []
  type: TYPE_NORMAL
- en: Endianness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Endianness describes the sequence of allocating bytes in memory or registers,
    and there are the following two types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Big-endian** means allocating bytes from left to right. Let''s see how a
    word like *shell* (which in hex **73** **68** **65** **6c** **6c**) will be allocated
    in memory:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It pushed as you can read it from left to right.
  prefs: []
  type: TYPE_NORMAL
- en: '**Little-endian** means allocating bytes from right to left. Let''s look at
    the previous example with little-endian:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, it pushed backward *llehs*, and the most important thing is
    Intel processors are little-endian.
  prefs: []
  type: TYPE_NORMAL
- en: System calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two spaces under Linux in memory (RAM): **user space** and **kernel
    space**. Kernel space is responsible for running kernel codes and system processes
    with full access to memory, whereas user space is responsible for running user
    processes and applications with restricted access to memory, and this separation
    is to protect the kernel space.'
  prefs: []
  type: TYPE_NORMAL
- en: When a user wants to execute a code (in user space), then user space sends requests
    to the kernel space using **system calls**, also known as **syscalls** through
    libraries such as glibc, and then kernel space executes it on behalf of the user
    space using the **fork-exec** technique.
  prefs: []
  type: TYPE_NORMAL
- en: What are syscalls?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Syscalls are like requests that the user space uses to ask the kernel to execute
    on behalf of the user space. For example, if a code wants to open a file then
    **user space** sends the open syscall to the **kernel** to open the file on behalf
    of the **user space**, or when a C code contains the `printf` function, then the
    **user space** sends the write system call to the **kernel**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The fork-exec technique is how Linux runs processes or applications by forking
    (copy) parent's resources located in memory using fork syscall, then running the
    executable code using exec syscall.
  prefs: []
  type: TYPE_NORMAL
- en: Syscalls are like kernel API or how you are going to talk to the kernel itself
    to tell it to do something for you.
  prefs: []
  type: TYPE_NORMAL
- en: User space is an isolated environment or a sandbox to protect the kernel space
    and its resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'So how can we get the full list of x64 kernel syscalls ? Actually it''s easy,
    all syscalls are located inside this file: `/usr/include/x86_64-linux-gnu/asm/unistd_64.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output for the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is just a small portion of my kernel syscalls.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we talked about some definitions in computer science, such
    as stack, buffer, and heap, and also gave a quick hint about buffer overflow and
    heap corruption. Then, we moved on to some definitions in computer architecture
    such as register, which is very important in debugging and understanding how execution
    is done inside the processor. Finally, we talked briefly about syscalls, which
    is also important in assembly language on Linux (we will see that in the next
    part), and how the kernel executes codes on Linux. At this point, we are ready
    to move on to another level, which is building an environment to test overflow
    attacks, and also creating and injecting shellcodes.
  prefs: []
  type: TYPE_NORMAL
