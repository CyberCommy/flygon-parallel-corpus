- en: Building an Application with Angular Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have reached a point in our journey where we can successfully develop more
    complex applications by nesting components within other components, in a sort
    of component tree. However, bundling all our component logic in a unique file
    is definitely not the way to go. Our application might become unmaintainable very
    soon and, as we will see later in the chapter, we would be missing the advantages
    that Angular's dependency management mechanism can bring to the game.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will see how to build application architectures based on
    trees of components, and how the new Angular dependency injection mechanism will
    help us to declare and consume our dependencies across the application with minimum
    effort and optimal results.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover these topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for directory structures and naming conventions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different approaches to dependency injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Injecting dependencies into our custom types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overriding global dependencies throughout the component tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with the host component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overviewing the directive lifecycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overviewing the component lifecycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the component tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern web applications based on web component architectures often conform to
    a sort of tree hierarchy, wherein the top main component (usually dropped somewhere
    in the main HTML index file) acts as a global placeholder where child components
    turn into hosts for other nested child components, and so on and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: There are obvious advantages to this approach. On one hand, reusability does
    not get compromised and we can reuse components throughout the component tree
    with little effort. Secondly, the resulting granularity reduces the burden required
    for envisioning, designing, and maintaining bigger applications. We can simply
    focus on a single piece of UI and then wrap its functionality around new layers
    of abstraction until we wrap up a full-blown application from the ground up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can approach our web application the other way around, and
    start from a more generic functionality just to end up breaking down the app into
    smaller pieces of UI and functionality, which become our web components. The latter
    has become the most common approach when building component-based architectures.
    We will stick to it for the rest of the book, undertaking architectures as the
    one depicted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: For the sake of clarity, this chapter will just borrow the code we wrote in
    the previous chapters, and we will deconstruct it into a component hierarchy.
    We will also allocate some room in the resulting application for all the supporting
    classes and models required to give shape to our Pomodoro tool. This will turn
    into a perfect opportunity to learn the intricacies of the dependency injection
    machinery baked into Angular, as we will see later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Common conventions for scalable applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In all fairness, we have already tackled a good number of the common concerns
    that modern web developers confront when building applications, small and large
    alike, nowadays. Therefore, it makes sense to define an architecture that will
    separate the aforementioned concerns into separate domain folders, catering to
    media assets and shared code units.
  prefs: []
  type: TYPE_NORMAL
- en: Angular's approach to separating the code and assets into logical units is by
    organizing them into different folders, but also by introducing the concept of
    an Angular module. It is in these modules that the constructs are registered.
    By introducing modules, a lot of the noise have disappeared from our components
    and our components are free to use the other constructs of the same module and,
    in some cases, constructs from other modules, given that their containing module
    is imported first.
  prefs: []
  type: TYPE_NORMAL
- en: It's worth emphasizing that when we are talking about Angular modules, we mean
    the `@NgModule` decorator and when we otherwise talk about modules, we mean the
    ES2015 construct.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, two contexts may require sharing the same entities, and that is fine
    (as long as it does not become a common thing in our project, which would denote
    a serious design issue). Also worth emphasizing is that we use the word *context*
    to describe a logical boundary of constructs. A context is best kept within an
    Angular module. So, every time the word *context* is used, think that it will
    in code translate to an Angular module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example, applied to our previous work on Pomodoro components,
    depicts this scheme, essentially making out our entire application of contexts
    and different constructs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Task context:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Task module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Task model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tasks service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Task table component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Task pomodoros component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Task tooltip directive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Timer context:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timer module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timer feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timer component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Admin context:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Admin module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Login component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editor component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Shared context:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shared module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components shared across features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipes shared across features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directives shared across features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Global models and services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shared media assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we can see, the first step is to define the different features our application
    needs, keeping in mind that each one should make sense on its own in isolation
    from the others. Once we define the set of features required, we will create a
    module for each one. Each module will then be filled with the components, directives,
    pipes, models, and services that shape the feature it represents. Always remember
    the principles of encapsulation and reusability when defining your features set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, when starting your project, you should name your constructs after
    what they are, so say we have the `Admin` context, it should look something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'With a quick glance, you should be able to see what the construct contains,
    so use a naming standard that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not the only way to do it, of course. There is another perfectly acceptable
    way of doing it, namely to create subdirectories for each type, so your preceding `admin`
    directory could look like this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It is worth noting that you should keep the type in the filename for clarity
    in debugging. Otherwise, when looking for a specific file to set a breakpoint
    in your browser, let''s say the login service, it might be quite confusing if
    you start typing `login.ts` and you are presented with:'
  prefs: []
  type: TYPE_NORMAL
- en: '`components/login.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`services/login.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pipes/login.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is an official style guide in place for how you should organize your code
    and how to name your constructs. There are definitely benefits to following a
    guide; it's easy for newcomers, the code looks more consistent, and so on. You
    can read more here; [https://angular.io/guide/styleguide](https://angular.io/guide/styleguide).
    Remember that whether you choose to follow this style guide in its entirety or
    not, consistency is key as it will make it easier to maintain the code.
  prefs: []
  type: TYPE_NORMAL
- en: File and ES6 module naming conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each one of our feature folders will host a wide range of files, so we need
    a consistent naming convention to prevent filename collisions while we ensure
    that the different code units are easy to locate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list summarizes the current conventions enforced by the community:'
  prefs: []
  type: TYPE_NORMAL
- en: Each file should contain a single code unit. Simply put, each component, directive,
    service, pipe, and so on should live in its own file. This way, we contribute
    to a better organization of code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Files and directories are named in lower-kebab-case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Files representing components, directives, pipes, and services should append
    a type suffix to their name: `video-player.ts` will become `video-player.component.ts`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any component's external HTML template or CSS style sheet filename will match
    the component filename, including the suffix. Our `video-player.component.ts`
    might be accompanied by `video-player.component.css` and `video-player.component.html`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directive selectors and pipe names are camelCased, while component selectors
    are lower-kebab-cased. Plus, it is strongly advised to add a custom prefix of
    our choice to prevent name collisions with other component libraries. For example,
    following up our video player component, it may be represented as `<vp-video-player>`,
    where `vp-` (which stands for video-player) is our custom prefix.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules are named by following the rule of taking a PascalCased
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: self-descriptive name, plus the type it represents. For example, if we see a
    module named `VideoPlayerComponent`, we can easily tell it is a component. The
    custom prefix in use for selectors (`vp-`, in our example) should not be part
    of the module name.
  prefs: []
  type: TYPE_NORMAL
- en: Models and interfaces require special attention, though. Depending on your application
    architecture, model types will feature more or less relevance. Architectures such
    as MVC, MVVM, Flux, or Redux tackle models from different standpoints and grades
    of importance. Ultimately, it will be up to you and your architectural design
    pattern of choice to approach models and their naming convention in one way or
    another. This book will not be opinionated in that sense, although we do enforce
    interface models in our example application and will create modules for them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each component and shared context of business logic in our application is intended
    to integrate with the other pieces of the puzzle in a simple and straightforward
    way. Clients of each subdomain are not concerned about the internal structure
    of the subdomain itself. If our timer feature, for example, evolves to the point
    of having two dozen components and directives that need to be reorganized into
    different folder levels, external consumers of its functionalities should remain
    unaffected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From facades/barrels to NgModule
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There comes a need to group your constructs into logical groups as your application
    grows. As the application grows, you also realize that not all constructs should
    be able to talk to each other, so you also need to think about restricting this.
    Before `@NgModule` was added to the framework, the natural course of action was
    to think of facade modules, which essentially meant that we created a specific
    file with the sole purpose of deciding what would get exported to the outside
    world. This could look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything else not explicitly exported would be considered as private or internal
    to the feature. Using one of the exported constructs would be as easy as typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This was a valid way of dealing with grouping as well as restricting access.
    We keep these two features in mind as we delve deeper into `@NgModule` in the
    next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Using NgModule
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the arrival of `@NgModule`, we suddenly had a more logical way of grouping
    our constructs and also a natural way of deciding what got to be exported or not.
    The following piece of code corresponds to the preceding facade code, but it uses `@NgModule` 
     instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This would create the same effect and the construct is called a feature module.
    The `exports`keyword is what says what is publicly accessible or not. Getting
    access to what is publicly exposed looks a bit different though. Instead of typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We would need to import our feature module into our root module. This means
    our root module would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This would now give us access to the exported components in the template markup.
    So in your upcoming app building, think about what belongs in a root module, what
    is part of a feature, and what is more common and used everywhere in the app.
    This is how you need to break apart your app, first in modules and then in proper
    constructs like components, directives, pipes, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: How dependency injection works in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As our applications grow and evolves, each one of our code entities will internally
    require instances of other objects, which are better known as dependencies in
    the world of software engineering. The action of passing such dependencies to
    the dependent client is known as injection, and it also entails the participation
    of another code entity, named the injector. The injector will take responsibility
    for instantiating and bootstrapping the required dependencies so they are ready
    for use from the very moment they are successfully injected in the client. This
    is very important since the client knows nothing about how to instantiate its
    own dependencies and is only aware of the interface they implement in order to
    use them.
  prefs: []
  type: TYPE_NORMAL
- en: Angular features a top-notch dependency injection mechanism to ease the task
    of exposing required dependencies to any entity that might exist in an Angular
    application, regardless of whether it is a component, a directive, a pipe, or
    any other custom service or provider object. In fact, as we will see later in
    this chapter, any entity can take advantage of dependency injection (usually referred
    to as DI) in an Angular application. Before delving deeper into the subject, let's
    look at the problem that Angular's DI is trying to address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s figure out if we have a music player component that relies on a `playlist`
    object to broadcast music to its users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `Playlist`type could be a generic class that returns in its API a random
    list of songs or whatever. That is not relevant now, since the only thing that
    matters is that our `MusicPlayerComponent`entity does need it to deliver its functionality.
    Unfortunately, the previous implementation means that both types are tightly coupled,
    since the component instantiates the playlist within its own constructor. This
    prevents us from altering, overriding, or mocking up in a neat way the `Playlist`class
    if required. It also entails that a new `Playlist` object is created every time
    we instantiate a `MusicPlayerComponent`. This might be not desired in certain
    scenarios, especially if we expect a singleton to be used across the application
    and thus keep track of the playlist's state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dependency injection systems try to solve these issues by proposing several
    patterns, and the constructor injection pattern is the one enforced by Angular.
    The previous piece of code could be rethought like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, the `Playlist`is instantiated outside our component. On the other hand,
    the `MusicPlayerComponent`expects such an object to be already available before
    the component is instantiated so it can be injected through its constructor. This
    approach gives us the opportunity to override it or mock it up if we wish.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, this is how dependency injection, and more specifically the constructor
    injection pattern, works. However, what has this got to do with Angular? Does
    Angular's dependency injection machinery work by instantiating types by hand and
    injecting them through the constructor? Obviously not, mostly because we do not
    instantiate components by hand either (except when writing unit tests). Angular
    features its own dependency injection framework, which can be used as a standalone
    framework by other applications, by the way.
  prefs: []
  type: TYPE_NORMAL
- en: The framework offers an actual injector that can introspect the tokens used
    to annotate the parameters in the constructor and return a singleton instance
    of the type represented by each dependency, so we can use it straight away in
    the implementation of our class, as in the previous example. The injector ignores
    how to create an instance of each dependency, so it relies on the list of providers
    registered upon bootstrapping the application. Each one of those providers actually
    provides mappings over the types marked as application dependencies. Whenever
    an entity (let's say a component, a directive, or a service) defines a token in
    its constructor, the injector searches for a type matching that token in the pool
    of registered providers for that component. If no match is found, it will then
    delegate the search on the parent component's provider, and will keep conducting
    the provider's lookup upwards until a provider resolves with a matching type or
    the top component is reached. Should the provider lookup finish with no match,
    Angular will throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: The latter is not exactly true, since we can mark dependencies in the constructor
    with the `@Optional` parameter decorator, in which case Angular will not throw
    any exception and the dependency parameter will be injected as null if no provider
    is found.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a provider resolves with a type matching that token, it will return
    such type as a singleton, which will be therefore injected by the injector as
    a dependency. In fairness, the provider is not just a collection of key/value
    pairs coupling tokens with previously registered types, but a factory that instantiates
    these types and also instantiates each dependency's very own dependencies as well,
    in a sort of recursive dependency instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, instead of instantiating the `Playlist` object manually, we could do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `providers` property of the `@Component`decorator is the place where we
    can register dependencies on a component level. From that moment onwards, these
    types will be immediately available for injection at the constructor of that component
    and, as we will see next, at its own child components as well.
  prefs: []
  type: TYPE_NORMAL
- en: A note on providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before `@NgModule`was introduced, Angular applications and especially components
    were thought to be responsible for what they needed. Therefore, it was commonplace
    for a component to ask for what dependencies it needed in order to be instantiated
    correctly. In the example of the previous section, the `MusicPlayerComponent` asks
    for a `Playlist`dependency. While this is still technically possible to do, we
    should use our new `@NgModule`concept and provide constructs on a module level
    instead. This means that the previously mentioned example would instead register
    its dependencies in a module, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that `Playlist` and `SomeOtherService`would be available for
    injection, for all constructs declared in the declarations property. As you can
    see, the responsibility of where to provide a service has shifted somewhat. As
    mentioned before, this does not mean we can't provide constructs on a per component
    level, there exist use cases where this makes sense. We want to stress however
    that the normal case is to place your services or other constructs, which need
    injecting, in the `providers` property of the module rather than the component.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting dependencies across the component tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen that the provider lookup is performed upwards until a match is
    found. A more visual example might help, so let''s figure out that we have a music
    app component that hosts in its directives property (and hence its template) a
    music library component with a collection of all our downloaded tunes that also
    hosts, in its own directives property and template, a music player component so
    we can playback any of the tunes in our library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Our music player component requires an instance of the `Playlist` object we
    mentioned before, so we declare it as a constructor parameter, conveniently annotated
    with the `Playlist` token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `MusicPlayerComponent` entity is instantiated, the Angular DI mechanism
    will go through the parameters in the component constructor with special attention
    to their type annotations. Then, it will check if that type has been registered
    in the component''s provider property of the component decorator configuration.
    The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: But, what if we want to reuse the `Playlist`type in other components throughout
    the same component tree? Maybe the `Playlist` type contains functionalities in
    its API that are required by different components at once across the application.
    Do we have to declare the token in the provider's property for each one? Fortunately
    not, since Angular anticipates that necessity and brings transversal dependency
    injection through the component tree.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, we mentioned that components conduct a provider lookup
    upwards. This is because each component has its own built-in injector, which is
    specific to it. Nevertheless, that injector is in reality a child instance of
    the parent's component injector (and so on and so forth), so it is fair to say
    that an Angular application has not a single injector, but many instances of the
    same injector, so to say.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to extend the injection of the `Playlist`object to other components
    in the component tree in a quick and reusable fashion. Knowing beforehand that
    components perform a provider lookup starting from itself and then passing up
    the request to its parent component''s injectors, we can then address the issue
    by registering the provider in the parent component, or even the top parent component,
    so the dependency will be available for injection for each and every child component
    found underneath it. In this sense, we could register the `Playlist` object straight
    at `MusicAppComponent`, regardless to whether it might not need it for its own
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The immediate child component might not require the dependency for its own
    implementation either. Since it has been already registered in its parent `MusicAppComponent` component,
    there is no need to register it there again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We finally reach our music player component, but now it no longer features
    the `Playlist` type as a registered token in its `providers` property. In fact,
    our component does not feature a providers property at all. It no longer requires
    this, since the type has been already registered somewhere above the component''s
    hierarchy, being immediately available for all child components, no matter where
    they are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, we see how dependencies are injected down the component hierarchy and how
    the provider lookup is performed by components just by checking their own registered
    providers and bubbling up the request upwards in the component tree. However,
    what if we want to constrain such injection or lookup actions?
  prefs: []
  type: TYPE_NORMAL
- en: Restricting dependency injection down the component tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our previous example, we saw how the music app component registered the
    Playlist token in its providers collection, making it immediately available for
    all child components. Sometimes, we might need to constrain the injection of dependencies
    to reach only those directives (and components) that are immediately next to a
    specific component in the hierarchy. We can do that by registering the type token
    in the `viewProvider`s property of the component decorator, instead of using the
    providers property we''ve seen already. In our previous example, we can restrain
    the downwards injection of `Playlist` one level only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We are informing Angular that the `Playlist` provider should only be accessible
    by the injectors of the directives and components located in the `MusicAppComponent`view,
    but not for the children of such components. The use of this technique is exclusive
    of components, since only they feature views.
  prefs: []
  type: TYPE_NORMAL
- en: Restricting provider lookup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like we can restrict dependency injection, we can constrain dependency
    lookup to the immediate upper level only. To do so, we just need to apply the `@Host()` decorator
    to those dependency parameters whose provider lookup we want to restrict:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: According to the preceding example, the `MusicPlayerComponent` injector will
    look up a`Playlist` type at its parent component's providers collection (`MusicLibraryComponent`,
    in our example) and will stop there, throwing an exception because `Playlist` has
    not been returned by the parent's injector (unless we also decorate it with the `@Optional()` parameter
    decorator).
  prefs: []
  type: TYPE_NORMAL
- en: 'To clarify this functionality, let''s do another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we would get an error as the `Child`component only looks one level
    up, to try and find the service. As it is two levels up, it does not find it.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding providers in the injector hierarchy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've seen so far how Angular's DI framework uses the dependency token to introspect
    the type required and return it right from any of the provider sets available
    along the component hierarchy. However, we might need to override the class instance
    corresponding to that token in certain cases where a more specialized type is
    required to do the job. Angular provides special tools to override the providers
    or even implement factories that will return a class instance for a given token,
    not necessarily matching the original type.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will not cover all the use cases in detail here, but let''s look at a simple
    example. In our example, we assumed that the `Playlist` object was meant to be
    available across the component tree for use in different entities of the application.
    What if our `MusicAppComponent`directive hosts another component whose child directives
    require a more specialized version of the `Playlist` object? Let''s rethink our
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a bit of a contrived example, but it will definitely help us to understand
    the point of overriding dependencies. The `Playlist`instance object is available
    right from the top component downwards. The `MusicChartsComponent` directive is
    a specialized component that caters only for music featured in the top seller''s
    charts and hence its player must playback big hits only, regardless of the fact
    it uses the same component as `MusicLibraryComponent`. We need to ensure that
    each player component gets the proper playlist object, and this can be done at
    the `MusicChartsComponent` level by overriding the object instance corresponding
    to the `Playlist`token. The following example depicts this scenario, leveraging
    the use of the `provide` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `provide` keyword creates a provider mapped to the token specified in the
    first argument (`Playlist`, in this example) and the property `useClass` essentially
    overwrites the playlist with `TopHitsPlaylist` from this component and downstream.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could refactor the block of code to use `viewProviders` instead, so we ensure
    that (if required) the child entities still receive an instance of`Playlist` instead
    of `TopHitsPlaylist`. Alternatively, we can go the extra mile and use a factory
    to return the specific object instance we need, depending on other requirements.
    The following example will return a different object instance for the `Playlist`token,
    depending on the evaluation of a Boolean condition variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: So, you can see how powerful this is. We could, for example, make sure that
    our data service suddenly would be replaced by a mock data service when testing.
    The point is it is really easy to tell the DI mechanism to change its behavior
    based on a condition.
  prefs: []
  type: TYPE_NORMAL
- en: Extending injector support to custom entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Directives and components require dependencies to be introspected, resolved,
    and injected. Other entities such as service classes often require such functionality
    too. In our example, our `Playlist` class might rely on a dependency on a HTTP
    client to communicate with a third party to fetch the songs. The action of injecting
    such dependency should be as easy as declaring the annotated dependencies in the
    class constructor and have an injector ready to fetch the object instance by inspecting
    the class provider or any other provider available somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is only when we think hard about the latter that we realize there is a gap
    in this idea: custom classes and services do not belong to the component tree.
    Hence, they do not benefit from anything such as a built-in injector or a parent
    injector. We cannot even declare a providers property, since we do not decorate
    these types of class with a `@Component` or `@Directive` decorator. Let''s take
    a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We might try this in the hope of having Angular''s DI mechanism introspecting
    the `songsService`parameter of the `Playlist` class constructor when instantiating
    this class in order to inject it into `MusicPlayerComponent`. Unfortunately, the
    only thing we will eventually get is an exception like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This is kind of misleading, since all constructor parameters in `Playlist`
    have been properly annotated, right? As we said before, the Angular DI machinery
    resolves dependencies by introspecting the types of the constructor parameters.
    To do so, it needs some metadata to be created beforehand. Each and every Angular
    entity class decorated with a decorator features this metadata as a by-product
    of the way TypeScript compiles the decorator configuration details. However, dependencies
    that also require other dependencies have no decorator whatsoever and no metadata
    is then created for them. This can be easily fixed thanks to the `@Injectable()`
    decorator, which will give visibility to these service classes for the DI mechanism:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You will get used to introducing that decorator in your service classes, since
    they will quite often rely on other dependencies not related to the component
    tree in order to deliver the functionality.
  prefs: []
  type: TYPE_NORMAL
- en: It is actually a good practice to decorate all your service classes with the `@Injectable()`decorator,
    irrespective of whether its constructor functions have dependencies or not. This
    way, we prevent errors and exceptions because of skipping this requirement once
    the service class grows, and it requires more dependencies in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing applications with bootstrapModule()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have seen in this chapter, the dependency lookup bubbles up until the
    first component at the top. This is not exactly true, since there is an additional
    step that the DI mechanism will check on: the `bootstrapModule()` function.'
  prefs: []
  type: TYPE_NORMAL
- en: As far as we know, we use the `bootstrapModule()` function to kickstart our
    application by declaring in its first argument the root module, that in turn points
    out the root component, that initiates the application's component tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical bootstrap will look like the following in the file `main.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The takeaway from the preceding code is that Angular has changed how it bootstraps
    things. With the addition of `@NgModule`, we now bootstrap a root module rather
    than a root component. However, the root module still needs to point to an entry
    point where the application starts. Let''s have a look at the root module to see
    how this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note the existence of the `bootstrap`key, how we point out the root component
    `AppComponent`. Also, note how the `bootstrap`property is an array. This means
    we can have multiple root components. Each one of these root components will feature
    its own set of injectors and service singletons, with no relationship whatsoever
    among them. Next up, let's talk about the different modes we can alter in-between.
  prefs: []
  type: TYPE_NORMAL
- en: Switching between development and production modes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular applications are bootstrapped and initialized by default in development
    mode. In the development mode, the Angular runtime will throw warning messages
    and assertions to the browser console. While this is quite useful for debugging
    our application, we do not want those messages to be displayed when the application
    is in production. The good news is that the development mode can be disabled in
    favor of the more silent production mode. This action is usually performed before
    bootstrapping our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: What we can see here is that the call to `enableProdMode()` is what enables
    production mode.
  prefs: []
  type: TYPE_NORMAL
- en: Different modes in Angular CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is worth noting that it''s a good idea to keep different environment configurations
    in different files, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The environments directory consists of two different files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`environment.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`environment.prod.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With the first file looking like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'And the second looking like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Depending on how we call the `ng build` command, one of the two files will
    be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To find out which files map to which environment, you should have a look at
    the `angular-cli.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Introducing the app directory structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters and sections in this chapter, we have seen different
    approaches and good practices for laying out Angular applications. These guidelines
    encompassed from naming conventions to pointers about how to organize files and
    folders. From this point onwards, we are going to put all this knowledge to practice
    by refactoring all the different interfaces, components, directives, pipes, and
    services in an actual Angular architecture, conforming to the most commonly agreed
    community conventions.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, we will have a final application layout that wraps
    everything we have seen so far in the following site architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'It is easy to understand the whole rationale of the project. Now, we will put
    together an application that features two main contexts: a timer feature and tasks
    listing feature. Each feature can encompass a different range of components, pipes,
    directives, or services. The inner implementation of each feature is opaque to
    the other features or contexts. Each feature context exposes an Angular module
    that exports the pieces of functionality (that is, the component, one or many)
    that each context delivers to the upper-level context or application. All the
    other pieces of functionality (inner directives and components) are concealed
    from the rest of the application.'
  prefs: []
  type: TYPE_NORMAL
- en: It is fair to say that it is difficult to draw a line in the sand differentiating
    what belongs to a specific context or another. Sometimes, we build pieces of functionality,
    such as certain directives or pipes, which can be reused throughout the application.
    So, locking them down to a specific context does not make much sense. For those
    cases, we do have the shared context, where we store any code unit that is meant
    to be reusable at an application level, apart from media files such as style sheets
    or bitmap images that are component-agnostic.
  prefs: []
  type: TYPE_NORMAL
- en: The main `app.component.ts` file contains and exports the application root component,
    which declares and registers in its own injector the dependencies required by
    its child components. As you know already, all Angular applications must have
    at least one root module and one root component, initialized by the `bootstrapModule()`
    function. This operation is actually performed in the `main.ts` file, which is
    fired by the `index.html` file.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a component or a group of related components within a context like
    this improves reusability and encapsulation. The only component that is tightly
    coupled with the application is the top root component, whose functionality is
    usually pretty limited and entails basically rendering the other child components
    in its template view or acting as a router component, as we will see in further
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The last bit of the puzzle is the JSON files that contain the TypeScript compiler,
    typings, and `npm` configuration. Since versioning on the Angular framework keeps
    evolving, we will not look at the actual content of these files here. You are
    supposed to know their purpose, but some specifics such as the peer dependency
    versions change quite often, so you'd better refer to the book's GitHub repository
    for the latest up-to-date version of each one. The `package.json` file requires
    a special mention though. There are a few common industry conventions and popular
    seed projects, like the one provided by the Angular official site itself. We have
    provided several `npm` commands to ease the overall installation process and the
    development endeavor.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring our application the Angular way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will split the code we created in earlier chapters into
    code units, following the single responsibility principle. So, do not expect many
    changes in the code, apart from allocating each module in its own dedicated file.
    This is why we will focus more on how to split things rather than explaining each
    module, whose purpose you should know already. In any event, we will take a minute
    to discuss changes if required.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin by creating in your work folder the same directory structure we
    saw in the previous section. We will populate each folder with files on the go.
  prefs: []
  type: TYPE_NORMAL
- en: The shared context or store it all in a common module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The shared context is where we store any construct whose functionality is meant
    to be used by not one, but many contexts at once, as it is agnostic to those contexts
    as well. A good example is the Pomodoro bitmap we've been using to decorate our
    components, which should be stored in the `app/shared/assets/img` path (please
    do save it there, by the way).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another good example is the interfaces that model data, mostly when their schema
    can be reused across a different context of functionality. For instance, when
    we defined the `QueuedOnlyPipe` in [Chapter 4](41335dde-9066-4998-a0a9-3c42f97cdd9e.xhtml),
    *Implementing Properties and Events in Our Components*, we actioned only over
    the queued property of items in the recordset. We can then seriously consider
    implementing a Queued interface that we can use later on to provide type-checking
    for modules that feature that property. This will make our pipes more reusable
    and model-agnostic. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Pay attention to this workflow: first, we define the module corresponding to
    this code unit, and then we export it, flagging it as default so we can import
    it by name from elsewhere. Interfaces need to be exported this way, but for the
    rest of the book we will usually declare the module and export it in the same
    statement.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With this interface in place, we can now safely refactor the `QueuedOnlyPipe` to
    make it fully agnostic from the `Task` interface so that it is fully reusable
    in any context where a recordset, featuring items implementing the `Queueable`interface,
    needs to be filtered, regardless of what they represent. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, each code unit contains a single module. This code unit conforms
    to the naming conventions set for Angular filenames, clearly stating the module
    name in camel case, plus the type suffix (`.pipe`, in this case). The implementation
    does not change either, apart from the fact that we have annotated all queue-able
    items with the `Queuable`type, instead of the Task annotation we had earlier.
    Now, our pipe can be reused wherever a model implementing the `Queueable` interface
    is present.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is something that should draw your attention: we''re not importing
    the `Queuable`interface from its source location, but from a file named `shared.ts`
    located in the upper level. This is the facade file for the shared context, and
    we will expose all public shared modules from that file, not only to the clients
    consuming the shared context modules, but to those inside the shared context as
    well. There is a case for this: if any module within the shared context changes
    its location, we need to update the facade so that any other element referring
    to that module within the same context remains unaffected since it consumes it
    through the facade. This is actually a good moment to start introducing our shared
    module that before `@NgModule` would have been a facade file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The main difference from a facade file is that we can add all sorts of business
    logic to our `SharedModule`by adding methods and injecting services and so on
    to `SharedModule`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This far we have only exposed pipes, directives, and components through the
    exports property of our `SharedModule`, but what about other things such as classes
    and interfaces? Well, we can require them directly when we need them, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a working `Queuable` interface and a `SharedModule`, we can
    create the other interface we will require throughout the book, corresponding
    to the `Task` entity, along with the other pipe we required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We implement an interface onto another interface in TypeScript by using extends
    (instead of implements). Now, for the `FormattedTimePipe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to update our `SharedModule`to contain this `Pipe` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: To sum up what we did here, we created two interfaces, `Task` and `Queueable`.
    We also created two pipes, `QueuedOnlyPipe` and `FormattedTimePipe`. We added
    the latter to the declarations keyword for our `@NgModule`, and as for the interfaces,
    we will pull them into the application as we need them, using the `import` keyword.
    There is no need to expose them through a facade file anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Services in the shared context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s talk about what the impact of having services in a shared context and
    what the addition of `@NgModule`has brought to the table. There are two types
    of services we need to care about:'
  prefs: []
  type: TYPE_NORMAL
- en: A transient service; this service creates a new copy of itself and may or may
    not contain an inner state; for each copy created it has its own state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A singleton, there can only be one of this service and if it has a state, we
    need to ensure that there is only a copy of this service in our entire application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using dependency injection in Angular, placing services in the providers of
    the modules will ensure they end up on on the root injector and thereby there
    will be only one copy of them created if we have this situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we had a declaration of a `TaskModule` in which we provided the `TaskService`.
    Let''s look at defining another module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Providing we import both of these modules in the root module, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now created a situation where `ProductsService` and `TaskService` can
    be injected in the constructor of`ProductsComponent` or `TaskComponent`, thanks
    to `ProductsModule` and `TaskModule` both being imported into the `AppModule`.
    So far, we don''t have an issue. However, were we to start using lazy loading,
    we have an issue on our hands. In lazy loading, the user navigates to a certain
    route and our module, together with its constructs, which are loaded into the
    bundle. If the lazy loaded module, or one of its constructs, actually injects,
    let''s say `ProductsService`, it would not be the same `ProductsService` instance
    that `TaskModule` or `ProductsModule`is using and this might become a problem,
    especially if the state is shared. The way to solve this is to create a core module,
    a module that is imported by the `AppModule`; this would ensure that services
    is never subjected to the risk of being instantiated again, by mistake. So, if `ProductsService`is
    used in more than one module, especially in a lazy loaded module, it is advisable
    to move it to a core module. So essentially, we go from doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'To moving our `ProductService` to a core module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'And of course, we need to add the newly created `CoreModule` to our root module,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: One can argue that if our application is small enough, creating a core module
    early on might be seen as somewhat of an overkill. An argument against that is
    that the Angular framework has a mobile first approach and that you as a developer
    should lazy load most of your modules, unless there is a good reason not to. This
    means that when you deal with services which might be shared, you should move
    them to a core module.
  prefs: []
  type: TYPE_NORMAL
- en: 'We built a data service in the previous chapter to serve a tasks dataset to
    populate our data table with. As we will see later in this book, the data service
    will be consumed by other contexts of the application. So, we will allocate it
    in the shared context, exposing it through our shared module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Please pay attention to how we imported the `Injectable()` decorator and implemented
    it on our service. It does not require any dependency in its constructor, so other
    modules depending on this service will not have any issues anyway when declaring
    it in its constructors. The reason is simple: it is actually a good practice to
    apply the `@Injectable()` decorator in our services by default to ensure they
    keep being injected seamlessly as long as they begin depending on other providers,
    just in case we forget to decorate them.'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring application settings from a central service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapters, we hardcoded a lot of stuff in our components: labels,
    durations, plural mappings, and so on. Sometimes, our contexts are meant to have
    a high level of specificity and it''s fine to have that information there. At
    other times, we might require more flexibility and a more convenient way to update
    these settings application-wide.'
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we will make all the `l18n` pipes mappings and settings available
    from a central service located in the shared context and exposed, as usual, from
    the `shared.ts` facade.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code describes a `SettingsService` that will hold all the configuration
    for the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Please note how we expose context-agnostic mapping properties, which are actually
    namespaced, to better group the different mappings by context.
  prefs: []
  type: TYPE_NORMAL
- en: It would be perfectly fine to split this service into two specific services,
    one per context, and locate them inside their respective context folders, at least
    with regard to the `l18n` mappings. Keep in mind that data such as the time duration
    will be used across different contexts, though, as we will see later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together in our shared module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With all the latest changes, our `shared.module.ts` should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Our `SharedModule` exposes `FormattedTimePipe` and `QueuedOnlyPipe`from before,
    but there are some new additions; namely, we added things to the `provider` keyword.
    We added our services, `SettingsService` and `TaskService`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, an interesting thing happens when this module is consumed by another module;
    so, let''s take a look at such a scenario in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The effect of importing another module is partly known from before. We know
    that everything included in the `export` keyword from`SharedModule` is now readily
    available in the `AppModule`, but there is more. Anything mentioned in the `provider`
    keyword of`SharedModule` is ready to be injected. So, let''s say we have the following
    `app.component.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we can now freely inject services from other modules as long
    as they are:'
  prefs: []
  type: TYPE_NORMAL
- en: Mentioned in the `provider`s keyword for their module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The module they reside in gets imported by another module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To sum up, so far, we have learned how to add components as well as services
    to a shared module and we have also learned that we need to register components
    in declarations and `export` keywords, and for services, we need to place them
    in the `provider` keyword. Lastly, we need to `import` the module they reside
    in and all your shared constructs are ready for use in your application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With our shared context sorted out, the time has come to cater to our other
    two contexts: timer and tasks. Their names are self-descriptive enough of the
    scope of their functionalities. Each context folder will allocate the component,
    HTML view template, CSS, and directive files required to deliver their functionality,
    plus a facade file that exports the public components of this feature.'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to life cycle hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Life cycle hooks are your ability to spy on stages in the life cycle of a directive
    or component. The hooks themselves are completely optional to use, but might be
    of valuable help if you understand how to use them. Some hooks are considered
    best practice to use, while other hooks help with debugging and understanding
    what happens in your app. A hook comes with an interface that defines a method
    you need to implement. The Angular framework makes sure the hook is called, provided
    you have added the interface to the component or directive and fulfilled the contract
    by implementing the methods the interface specifies. As we are just starting to
    learn how to build your app, it might not make sense to use certain hooks yet.
    So, we will have a reason to return to this topic in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The hooks you can use are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnInit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnDestroy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnChanges`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DoCheck`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AfterContentInit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AfterContentChecked`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AfterViewInit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AfterViewChecked`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we will cover the top three ones in this chapter as the rest
    are touching on more complex topics. We will revisit the remaining five hooks
    in later chapters in the book.
  prefs: []
  type: TYPE_NORMAL
- en: OnInit - the beginning of it all
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using this hook is as easy as adding the `OnInit` interface and implementing
    the `ngOnInit()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Let's talk about why this hook exists though. Constructors should be relatively
    empty and devoid of logic other than setting initial variables. There should be
    no surprises when constructing an object because sometimes you construct an object
    meant for business use and sometimes it is created in unit testing scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of suitable things to carry out in the constructor
    of the class. Here, we are showing assignment of the class''s member variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example shows what NOT to do. In the code, we are subscribing
    to an Observable in the constructor. This can be acceptable in some scenarios,
    but it is usually a better idea to place this kind of code inside an `ngOnInit()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: It's better to set up subscription, as shown previously with the `ngOnInit()` method
    provided by the `OnInit` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is, of course, a recommendation and not a law. If you are not using this
    hook, then obviously you need to use the constructor or similar to perform the
    preceding HTTP call. Other than just saying that the constructor should be empty
    for aesthetic reasons and when dealing with testing, there is another aspect,
    namely that of binding of input values. An input variable won''t be set immediately,
    so relying on the input value to be there when in the constructor will lead to
    a runtime error. Let''s illustrate the mentioned scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: At this stage, you can make sure that all bindings have been properly set and
    you can safely use the value of prop. If you are familiar with jQuery, then `ngOnInit`
    acts much like a`$(document).ready()` like construct, the bottom line is that
    the ceremony that happens when a component is being set up has happened at this
    point.
  prefs: []
  type: TYPE_NORMAL
- en: OnDestroy - called when a component is removed from a DOM tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The typical use case for this is to do some custom clean up when the component
    is about to leave the DOM tree. It consists of the interface `OnDestroy`and the
    `ngOnDestroy()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate its use, let''s look at the following code snippet where we
    implement the `OnDestroy` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Our preceding snippet tries to highlight when an instance of `TodoComponent`gets
    removed from the DOM tree. The `TodosComponent` renders a list of `TodoComponents`and
    when the `remove()` method is invoked, the targeted `TodoComponent`is removed,
    thereby triggering the `ngOnDestroy()` method on the `TodoComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: OK, great, so we have a way to capture that exact moment in time when our component
    is being disposed... so what?
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where we do a clean up of resources; by clean up, we mean:'
  prefs: []
  type: TYPE_NORMAL
- en: Timeout, interval should be unsubscribed to here
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observable streams should be unsubscribed to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other clean up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Essentially, anything that causes a footprint should be cleaned up here.
  prefs: []
  type: TYPE_NORMAL
- en: OnChanges - a change has occurred
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This hook is used in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how our method takes an input parameter `changes`. This is an object with
    all properties that changed as keys on the `changes`object. Each key points to
    an object with the previous value and the current value, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code assumes we have a class with a `prop` field, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'So, what causes things to change? Well, it''s a change in the binding, that
    is, we have the `@Input` property set up, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'A little heads up worth noting here is that what we are tracking are reference
    changes, not property changes on an object. If, for example, we have the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'And the name property on the `todoItem` changed so that `todoItem.name` is
    `code` instead of `coding`, this would not lead to a change being reported. However,
    if the whole item is replaced, as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Then this would lead to a change event being emitted as the `todoItem`now points
    to a completely new reference. I hope this clears it up a bit.
  prefs: []
  type: TYPE_NORMAL
- en: The timer feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our first feature is the one belonging to the timer functionality, which happens
    to be the simpler one as well. It comprises of a unique component with the countdown
    timer we built in the previous chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the implementation is pretty much the same to what we saw already
    back in [Chapter 1](17474bca-f7f9-41ec-ab4c-5f7ac741c0c9.xhtml), *Creating Our
    Very First Component in Angular*, with the exception of initializing the component
    at the init lifecycle stage through the `OnInit` interface hook. We leverage the `l18nSelect` pipe
    to better handle the different labels required for each state of the timer, consuming
    the label information from the `SettingsService`, which is injected in the constructor.
    Later on in this chapter, we will see where to register that provider. The duration
    in minutes is also consumed from the service, once the latter is bound to a class
    field.
  prefs: []
  type: TYPE_NORMAL
- en: 'The component is exported publicly through the `TimerModule`file `timer.module.ts`
    by us adding it to the`declarations` keyword as well as the `exported` keyword,
    the latter to enable outside access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'And we also need to remember to import our newly created module to the root
    module in `app.module.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we have created a nice structure before we create more constructs
    for the timer feature.
  prefs: []
  type: TYPE_NORMAL
- en: The tasks feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The tasks feature encompasses some more logic since it entails two components
    and a directive. Let''s begin by creating the core unit required by `TaskTooltipDirective`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The directive keeps all the original functionality in place and just imports
    the Angular core types and task-typing it requires. Let''s look at the `TaskIconsComponent` now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'So far so good. Now, let''s jump to `TasksComponent`. This will consist of:'
  prefs: []
  type: TYPE_NORMAL
- en: The component file `tasks.component.ts`, where the logic is described in TypeScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The CSS file `tasks.component.css`, where the styles are defined
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The template file `tasks.component.html`, where the markup is defined
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Starting with the CSS file, it will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Continuing on with the HTML markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Please take a moment to check out the naming convention applied to the external
    component files, whose filename matches the component''s own to identify which
    file belongs to what in flat structures inside a context folder. Also, please
    note how we removed the main bitmap from the template and replaced the hardcoded
    time durations with a variable named `timerMinutes`in the binding expression that
    computes the time estimation to accomplish all queued tasks. We will see how that
    variable is populated in the following component class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Several aspects of the `TasksComponent`implementation are worth highlighting.
    Firstly, we can inject the `TaskService` and `SettingsService`in the component,
    leveraging Angular's DI system. The dependencies are injected with accessors right
    from the constructor, becoming private class members on the spot. The tasks dataset
    and the time duration are then populated from the bound services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now add all these constructs to the `TaskModule`, that is, the file
    `task.module.ts` and export everything that is either a directive or a component.
    It is worth noting, however, that we do this because we think all these constructs
    may need to be referred to somewhere else in the app. I urge you to strongly consider
    what to put in the `exports`keyword and what not to put there. Your default stance
    should be to put as little as possible for exporting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: We have now added the constructs to the `declarations`keyword so that the module
    is aware of them and also the `exports` keyword so that other modules importing
    our`TaskModule`are able to use them. The next task is to set up our `AppComponent`,
    or root component, as it is also known as.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the top root component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With all our feature contexts ready, the time has come to define the top root
    component, which will kickstart the whole application as a cluster of components
    laid out in a tree hierarchy. The root component usually has a minimum implementation.
    The main child components will eventually evolve into branches of child components.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of the template of the root component. This is
    the main visual component that your app is going to live in. Here, it makes sense
    to define application headers, menus, or viewports for routing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'It has been mentioned before, but it is worth repeating. Any constructs that
    we use in the `app.component.ts` file that do not belong to the `AppModule` need
    to be imported. Technically, it is the module these constructs belong to that
    is being imported. You also need to ensure that the constructs are properly exposed
    by being mentioned in said modules `exports`keyword. With the preceding root component,
    we can see that we use two different components in the template for `app.component.ts`,
    the `<timer-widget>`   and `<pomodoro-tasks>`.  These belong to different modules
    with the first component belonging to the `TimerModule` and the second belonging
    to the `TaskModule`. This means that the `AppModule`needs to import both of these
    modules for the preceding to compile. The `app.module.ts` should, therefore, look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has definitely set the foundation for all the great applications
    that you will be building on top of Angular from now on. The Angular dependency
    management implementation is in fact one of the gems of this framework and a time
    saver. Application architectures based on component trees are not rocket science
    anymore, and we have followed this pattern to some extent while building web software
    in other frameworks such as AngularJS and React.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter concludes our trip through the core of Angular and its application
    architecture, setting up the standards that we will follow from now on while building
    applications on top of this new and exciting framework.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapters, we will focus on very specific tools and modules
    that we can use to solve everyday problems when crafting our web projects. We
    will see how to develop better HTTP networking clients with Angular.
  prefs: []
  type: TYPE_NORMAL
