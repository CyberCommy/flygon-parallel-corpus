- en: Appendix A. A Node.js Kick start
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In web development, it is desirable to have a backend server of some sort. The
    list of servers and languages available is extensive. But one server that has
    generated an extraordinary level of excitement is Node.js, which lets you use
    the same JavaScript for frontend and backend development, and allows truly interesting
    possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this book is to introduce Facebook's frontend user interface
    framework, called ReactJS. The purpose of this appendix is to provide just enough
    of a backend to run an authenticated server, and while there are many good choices,
    Node.js works without an appendix asking you to deal with a new language. The
    basic work done in this appendix covers territory comparable to what you might
    approach with another server and backend language.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this appendix, we will be covering these topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How Node.js takes a cue from INTERCAL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Node.js, like JavaScript, has minefields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Porting the Pragmatometer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But let's first look at Node.js and INTERCAL.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js and INTERCAL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**INTERCAL**, properly named **The Compiler Language With No Pronounceable
    Acronym**, was first announced by Princeton students Don Woods and Jim Lyon in
    1972\. The archetypal example of a language designed to satirize various trends
    and fashions in programming languages, it is perhaps better known as the archetypal
    example of a language intended, not to be easy to work with, but to be deliberately
    and unnecessarily hard to use. Its *Hello, world!* code contains full, repetitive-stress-injury-inducing
    16 lines; its legendary ROT-13 encryptor/decryptor (a straightforward one-liner
    for Perl or Unix shell commands) has been described on `alt.folklore.computers`
    as "four pages of completely undecipherable code." INTERCAL was originally published
    on punch cards in EBCDIC, a character encoding that has been called an encryption
    standard.'
  prefs: []
  type: TYPE_NORMAL
- en: One trend that was satirized was Edgser Dikjstra's "Go to statement considered
    harmful," a work that was beyond being merely seminal, arguably being the single
    most important article in the history of computer science. Wags have said, for
    instance, that a programmer is someone who is offended on being told, "Go to hell!"
    not by the "hell" but by `Go to`. One INTERCAL variant (C-INTERCAL) took the premise
    that `Go to` statements are indeed rightly considered harmful, and they wanted
    to go as far away from `Go to` statements as possible—much farther than wimpy
    IF-THEN-ELSE statements and `while` loops. They offered a much more radical departure
    from the `Go to` statement than IF-THEN-ELSE and `while` loops—the `come from`
    statement. While the `Go to` statement says, "If the execution reaches this point
    of the code, go to that area of the code," the `come from` antonym says, "If the
    execution reaches that other area of the code, switch over and pick up things
    at this point of the code."
  prefs: []
  type: TYPE_NORMAL
- en: 'The suggestion that might be made is as follows: the genius of Node.js, for
    which we are providing a kick start in this chapter, is that it bends over backward
    to have flow control based on `come from` statements, or something very similar
    to them. Now, Node.js is also a server programmable in JavaScript, which is nothing
    to sneeze at, but it has completely eclipsed all other servers programmable in
    JavaScript. Its genius stems, not from JavaScript alone, but from a development
    environment that works best when you can solve problems in terms of `come from`
    as a primary tool for flow control. The usual preferred term is asynchronous callback
    function, rather than `come from`, but you will work best with Node.js when you
    realize that Node.js is interesting as a live example of `come from` programming
    being performant by default, and outperforming its competitors by an order of
    magnitude.'
  prefs: []
  type: TYPE_NORMAL
- en: Someone who has formative C experience and comes to Perl might well be told,
    "You're not really thinking of Perl unless you're thinking of hashes," or an old-line
    Java programmer might be told, "You're not really thinking of JavaScript unless
    you're thinking of closures." In like fashion, someone coming from any other mainstream
    web server at all might be told, "You're not really thinking of Node.js unless
    you're thinking of `come from`-style asynchronous callback functions."
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Anonymous functions have been glorious since they appeared in Lisp, and they're
    a great feature in JavaScript. But when dealing with Node.js callbacks, consider
    using non-nested named functions as an alternative to deeply nesting layers of
    anonymous inner functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Technically speaking, using asynchronous callback functions in Node.js is strictly
    optional. However, it may be strongly suggested that unless you are using a learning
    tool for Node.js—such as the excellent "Learn You the Node.js For Much Win!" (a
    title that clearly alludes to *Learn You a Haskell For Great Good* as an excellent
    predecessor), the Node.js learning tool being the one promoted at [http://nodeschool.io](http://nodeschool.io)—you
    should remember Knuth''s two rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule 1 (for all programmers)**: Don''t optimize'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule 2 (for advanced programmers only)**: Optimize later'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the context of Node.js, this becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule 1 (for all Node.js hackers)**: Don''t use synchronous methods where
    an asynchronous approach would work'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule 2 (for advanced Node.js hackers only)**: Add any synchronous functionality
    later'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For an example of code implemented synchronously, the way a non-Node.js person
    would likely see, we can read and print a file such as `/etc/passwd` (on Windows,
    a different full path would be appropriate; you can create and save one with Notepad
    or your favorite editor):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Implemented with the `come from` asynchronous callback functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The question of whether `console.log()` is blocking or not does not concern
    us here.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a slightly more sophisticated *Hello, world!* program for node, or
    perhaps a program just after *Hello, world!* which, in Node.js, is simply as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let's comment on the asynchronous example in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard way of importing a package is to call `require()`, and save the
    result in the variable you want to use to access the package. The `fs` package
    is one of the few packages that come automatically with Node.js, but Node.js comes
    packed with a whole universe of packages available through **Node Package Manager**
    (**npm**), a package manager that may appear familiar to people who use Linux
    package managers. With npm, you can search for, for example, Express.js, which
    will be covered briefly in this chapter. Express.js is popular among the Node.js
    community, works well with Node.js, and is a bit like Rails for Ruby or Django
    for Python. A search for Express.js can be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you''ve identified which package name you want (or you think you want),
    you can install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the `fs.readFile()` function call is what sets up the
    `come from` behavior. Like other asynchronous calls, it has two required arguments:
    a basic argument (possibly an array) that is given to `fs.readFile()`, and a callback
    function. What happens when this is called—instead of blocking for an expensive
    amount of time while the file is being read—is that the program registers a request
    to read a file with the specified parameters, and then the single Node.js leaves
    it where it is, and attends to other requests. This is very important. Instead
    of blocking and doing nothing while it waits, the program services other needs,
    and after the file operation comes back with the file result (having been busy
    in the meantime tucking in other requests), and then `come from` wherever it is
    and services the callback function provided. It is very hard to accidentally get
    properly used Node.js to block, except with something that burns the CPU, and
    with the current CPU speeds, it is rare for an innocuous request to block the
    CPU so much to be a problem (interested parties can use Node.js to mine bitcoins
    via tools such as those provided at [http://bitcoinjs.org/](http://bitcoinjs.org/),
    but presumably few people worried about their Node.js server being as performant
    as possible will have it mine bitcoin on the side). There is a cluster module
    intended to take advantage of multiple cores where Node.js, by default, runs in
    one single-threaded process on one core. But if you have any doubt about whether
    your use case is extreme enough to need something like cluster to perform Node''s
    performant-by-default structure, you probably don''t need cluster yet.'
  prefs: []
  type: TYPE_NORMAL
- en: The way Node works (without using cluster, at least) has the additional advantage
    of avoiding concurrency issues, because it is single-threaded and de facto not
    concurrent. This is a very good thing. Concurrency is a slippery, treacherous
    thing to deal with. There are highly proficient programmers who work well with
    concurrency, but overall, concurrency should be considered harmful—a sort of Pandora's
    Box that perennially confuses most normal programmers. There may be a reason to
    consider purely functional languages using immutable data to be a separate case
    as far as concurrency goes, but here we will stick to saying that it is good that
    Node.js can, by default, handle an enormous number of requests without requiring
    the developer to cope with slippery concurrency difficulties.
  prefs: []
  type: TYPE_NORMAL
- en: The second argument given to `fs.readFile()` is optional, and `fs.readFile()`
    allowing it is a little unusual. Normal asynchronous calls look like identifier(data,
    callback). In this case, the second, optional argument is worth a closer look.
  prefs: []
  type: TYPE_NORMAL
- en: The argument is what encoding to use to make a string from an array of bytes,
    and the argument given is the normal default encoding, `'utf-8'`, although there
    is a slight temptation here to fall back, in this case on `'ascii'`. This is particularly
    because Unix `/etc/passwd` files precede `UTF-[anything]` by decades. But we will
    be good netizens and use `'utf-8'`.
  prefs: []
  type: TYPE_NORMAL
- en: The behavior would probably be similar, in our case, between using UTF-8 and
    ASCII encoding. The output will, in fact, be identical if `/etc/passwd` is like
    many `/etc/passwd` files over the years in containing ASCII characters alone and
    possibly supporting ASCII characters alone. But either of them will be a different
    beast by not specifying some encoding. Without further changes, the callback will
    be given in bytes rather than any JavaScript string in the ordinary sense. And
    here, we have a hint of something big about Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: There has been an arms race for the fastest JavaScript engine among browsers,
    and Node.js took a release of Google Chrome's V8 engine (forks of Node.js may
    use something newer), and extended it in certain ways, so that it would be able
    to function as a general-purpose runtime environment, including being well-adapted
    to serving as a web server. This included adding several extensions that don't
    exist in client-side web browser JavaScript. The ability to handle sockets as
    a server was one example, and this, along with I/O, was brilliantly developed
    along an asynchronous model, as discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another gap has to do with binary data. The standard browser JavaScript, at
    the time of writing this book, doesn''t really provide a direct way to deal with
    binary data. While there may be obvious work of handling binary data behind the
    scenes in the following code, there is no clear way to say "I want 128 (octet)
    bytes of alternating 1s and 0s, starting with a 1":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Node.js extends V8's capabilities to handle proper binary data, and tried and
    true JSON is complemented with the new and binary-friendly BSON. The handling
    of binary data is low-level, possibly too low-level for its C-like character.
    For example, a productivity boost and decrease in frustration comes when a C programmer
    switches completely from using `malloc()` ("memory allocate") to using `calloc()`
    ("cleared memory allocate"). The `malloc()` function allocates a raw block of
    memory with whatever detritus was left over from the memory's previous occupant,
    leading to strange and wickedly magical effects if you fail to properly initialize
    any portion of the memory.
  prefs: []
  type: TYPE_NORMAL
- en: The `calloc()` function allocates a raw block of memory and clobbers any previous
    content with zeroes. Remember Pete Hunt's words, "I'd rather be predictable than
    right?" Stopping ever using `malloc()` directly again in favor of `calloc()` is
    a major way in which C programmers can opt to be predictable rather than right.
    However, out of misguided optimization concerns (it is a fraction of a second
    faster not to wipe the allocated byte memory), Node.js offers the equivalent of
    a C `malloc()` only, without any furnished `calloc()` equivalent, as far as I
    can tell. Fortunately, Node.js JavaScript (or C, for that matter) is so powerful
    that it is a straightforward exercise to port the `calloc()` functionality. Just
    make a wrapper that handles everything that the Node.js byte allocation handles,
    follows up by making all bits zeroes, and use this wrapper exclusively when you
    allocate bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to the immediately highlighted code, in Node.js thinking at least,
    reading from a file or from the network does not return a string. It returns binary
    bytes. Now those bytes may be easily convertible via a given encoding, and if
    you furnish the encoding you want, `fs.readFile()` will give you a proper string,
    not just bytes. But let''s look at some code similar to what we had earlier. Node.js,
    like many good environments, offers a **Read-Eval-Print-Loop** (**REPL**) to try
    things out (invoking the node executable without any following arguments will
    activate the REPL). From the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The various bytes in the file are represented in hexadecimal code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to our last code sample, the `function(err, data)` callback signature
    is the normal callback signature for the programming contract. The callback should
    be eventually called, and perhaps called very quickly. This should be done with
    either a "truthy" `err`, in which case the callback should optionally take steps
    to respond to any information contained in the error feedback, and non-optionally
    return without going further, or a null err, in which case the function''s precondition
    is met and the callback should take whatever action is appropriate to receive
    the data that was requested. The preceding code illustrates the pattern: check
    for null `err`, optionally act on it by logging diagnostics, and print the file
    contents if err is null.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning – Node.js and its ecosystem are hot, and hot enough to burn you badly!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When I was a teacher''s assistant, one of the nonobvious suggestions I was
    told was not to tell a student that something was "easy." The reason was somewhat
    obvious in retrospect: if you tell people that something is easy, someone who
    doesn''t see a solution may end up feeling (even more) stupid, because not only
    do they not get how to solve the problem, but also the problem that they are too
    stupid to understand is an easy one!'
  prefs: []
  type: TYPE_NORMAL
- en: There are gotchas that don't just annoy people coming from Python/Django, which
    immediately reloads the source if you change anything. With Node.js, the default
    behavior is that if you make one change, the old version continues to be active
    until the end of time or until you manually stop and restart the server. This
    inappropriate behavior doesn't just annoy Pythonistas; it also irritates native
    Node.js users who provide various workarounds. The StackOverflow question "Auto-reload
    of files in Node.js" has, at the time of this writing, over 200 upvotes and 19
    answers; an edit directs the user to a nanny script, node-supervisor, with homepage
    at [http://tinyurl.com/reactjs-node-supervisor](http://tinyurl.com/reactjs-node-supervisor).
    This problem affords new users with great opportunity to feel stupid because they
    thought they had fixed the problem, but the old, buggy behavior is completely
    unchanged. And it is easy to forget to bounce the server; I have done so multiple
    times. And the message I would like to give is, "No, you're not stupid because
    this behavior of Node.js bit your back; it's just that the designers of Node.js
    saw no reason to provide appropriate behavior here. Do try to cope with it, perhaps
    taking a little help from node-supervisor or another solution, but please don't
    walk away feeling that you're stupid. You're not the one with the problem; the
    problem is in Node.js's default behavior."
  prefs: []
  type: TYPE_NORMAL
- en: 'This section, after some debate, was left in, precisely because I don''t want
    to give an impression of "It''s easy." I cut my hands repeatedly while getting
    things to work, and I don''t want to smooth over difficulties and set you up to
    believe this: getting Node.js and its ecosystem to function well is a straightforward
    matter, and if it''s not straightforward for you too, you don''t know what you''re
    doing. If you don''t run into obnoxious difficulties while using Node.js, that''s
    wonderful. If you do, I would hope that you don''t walk away feeling, "I''m stupid.
    There must be something wrong with me." You''re not stupid if you experience nasty
    surprises dealing with Node.js. It''s not you! It''s Node.js and its ecosystem!'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will explore a sample project, a remote equivalent of the quick and
    dirty localStorage-based persistence, which was covered in [Chapter 11](ch11.html
    "Chapter 11. Demonstrating Functional Reactive Programming in JavaScript with
    a Live Example Part IV – Adding a Scratchpad and Putting It All Together"), *Demonstrative
    Functional Reactive Programming in JavaScript with a Live Example Part IV – Adding
    a Scratchpad and Putting It All Together*. That was a success, but it was way
    too hard with way too many trip-ups along the way. I have, at times, compared
    Python and JavaScript; but it may be worth a moment to look at why JavaScript's
    Node.js is really nasty compared to Python's Django.
  prefs: []
  type: TYPE_NORMAL
- en: 'My first experience with Django, after years of experience, was a feeling that
    it was a brilliant power tool that, for some strange reason, had accidentally
    not been enshrined in Python''s standard library. Now, in fact, there is excellent
    reason for this, and one that need criticize neither Python nor Django: as Python''s
    Benevolent Dictator for Life observed, you put something into the standard library
    when it is "dead," not when it is still growing. Django is still growing and it''s
    still getting better. Therefore, Django does not belong in the standard library
    for Python no matter how good it is.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is, for many contexts, a principle of least astonishment, and once you
    start to know Python well, it does not give you unpleasant surprises too often.
    Django does come with some surprises, such as its templating system, which at
    the time of ASP and JSP was a striking proposition. (Now it has had its 15 minutes
    of fame, and even Python/Django developers start off by replacing the templating
    system with something more powerful. It was entirely the right choice for ReactJS
    to essentially do the opposite.) But paradoxically, both Django and ReactJS offered
    templating that reflected a genius from Mars technique, as defined in The New
    Hacker''s Dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '*[TMRC] A visionary quality which enables one to ignore the standard approach
    and come up with a totally unexpected new algorithm. An attack on a problem from
    an offbeat angle that no one has ever thought of before, but in retrospect makes
    perfect sense. Compare grok, zen.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Working with Node.js doesn't feel anything like working with Python, or even
    like working with ReactJS. It is more frustrating, is more difficult, and has
    more things that don't make sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is one example: at the time of the initial research, I intended to use
    passport.js to offload the dirty work of authentication. I originally meant to
    use Facebook authentication, but the instructions involved creating something
    on the Facebook developer site, and taking down information from the Facebook
    application. And even after exploring the Facebook developer site and asking,
    "passport.js says to get XYZ information from my application on the Facebook developer
    site," I completely failed to obtain any timely answer.'
  prefs: []
  type: TYPE_NORMAL
- en: Scaling back my ambitions, I decided to use the most basic proper authentication
    from passport.js—username and password—until I learned that what was provided
    as username and password support was almost entirely useless.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason it is useless is that just as **Create, Read, Update, Destroy**
    (**CRUD**) offers an enumeration of basic responsibilities—bases that need to
    be covered in any serious and complete tool for handling data and records (whether
    it is an SQL database, any stripe of a NoSQL database, pickled data saved in a
    programming environment, an editor, or an e-mail client)—there is a basic set
    of bases that need to be covered in mainstream account management, whether username/password
    or any newer and gentler alternative to making users keep track of yet another
    login and password. While individual sites may opt out of certain functionality,
    repeated and basic functionality that provide the CRUD of account management includes
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Allowing users to create new accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing users to log in with an existing account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing a lost password without an unencrypted password being e-mailed to
    the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Possibly an extended set of features for a site's administrative members, such
    as account moderation (if desired), locking and unlocking accounts, and account
    deletion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only one of these bases covered by passport.js's functionality is logging
    in with an already existing account, created by some means that I have not been
    able to ascertain, and being successfully or unsuccessfully authenticated. Perhaps
    the only thing more pathologically incomplete in terms of a CRUD was offered in
    the April 1 issue of Byte magazine some decades ago, when someone advertised an
    exceptionally good deal on write-only memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we might note in passing that supporting 100 percent of CRUD is not, strictly
    speaking, the only possible approach. Years ago, **Write Once, Read Many** (**WORM**)
    disk drives spent some time in the limelight. While there is possibly no modern
    laptop that has shipped with a genuine WORM drive, ClojureScript includes an extraordinary
    amount of effort to offer WORM data. WORM, in this context, means that data is
    designed to exclude Updating (although you can make modified copies easily enough),
    and Deletion is reserved to garbage collection: out of full CRUD support, ClojureScript''s
    WORM data only allows unimpaired Creation and Reading of data. ClojureScript reflects
    a carefully thought-out decision to offer WORM data in a context where full CRUD
    support would have been considerably easier. This decision now deserves obvious
    respect.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, the lack of an equivalent of full CRUD support is not the end of the world
    for authentication, as at least one other group has approached "authentication
    CRUD" more appropriately. Stormpath advertises offerings for Node, Python, Java,
    and REST. One of their developers rewrote my code for authentication for me to
    use their system. While this may just be being nice to an author who might cover
    their product, Stormpath inclusion isn't even a proper integration challenge;
    it's really simple. Now it should be stated for the record that Stormpath is not
    open source, but a SaaS with freemium pricing. The full-featured, free, and "no
    credit card required" developer tier has a quota of 100,000 API calls per month,
    and they estimate user logins as using about three API calls. They definitely
    have a profit motive, but if you have enough traffic for you to need a paid tier
    of service, you shouldn't care about the trifle you have to pay them. The system
    gives an overall impression of being a bit young, with people working out the
    remaining kinks, but it has happened that someone told them politely about something
    that was immature, and the problem was resolved quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Another basic difficulty surrounds databases. There's a good case to be made
    that MongoDB is important, and together with the "access MongoDB from Node.js"
    package of mongoose, it is worth the learning curve. In preparation for this chapter,
    top-of-search tutorials proved to explain how to create a Schema and save something
    in it, but left guesswork as to how to usefully approach a database where all
    the necessary schemas already exist. Subsequent work turned up an existing Stack
    Overflow solution that appeared to cover database CRUD with a database with already
    existing schemas and databases. I may have come within an inch of pay dirt before
    giving up, but I intended to use mongoose/MongoDB for its database work almost
    from the beginning, and I have not yet attained proficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Another database that seemed like a perfect fit, and may yet be redeemable,
    is a server-side implementation of the HTML5 key-value store. This approach has
    the cardinal advantage of an API that most good frontend developers understand
    well enough. For that matter, it's also an API that most not-so-good frontend
    developers understand well enough. But with the `node-localstorage` package, while
    `dictionary-syntax` access is not offered (you would want to use `localStorage.setItem(key,
    value)` or `localStorage.getItem(key)`, but not `localStorage[key])`, the full
    localStorage semantics is implemented, including a default 5 MB quota. Why? Do
    server-side JavaScript developers need to be protected from themselves?
  prefs: []
  type: TYPE_NORMAL
- en: For client-side database capabilities, a 5 MB quota per website is really a
    generous and useful amount of breathing space to let developers work with it.
    You could set a much lower quota and still offer developers an immeasurable improvement
    over limping along with cookie management. A 5 MB limit doesn't lend itself very
    quickly to big data client-side processing, but there is a really generous allowance
    that resourceful developers can use to do a lot. On the other hand, 5 MB is not
    a particularly large portion of most disks purchased any time recently. This means
    that if you and a website disagree about what the reasonable use of disk space
    is, or if a site is simply hoggish, it does not really cost you much and you are
    in no danger of a swamped hard drive, unless your hard drive was already too full.
    We may be better off if the balance were a little less, or a little more, but
    overall it's a decent solution for addressing the intrinsic tension with respect
    to a client-side context.
  prefs: []
  type: TYPE_NORMAL
- en: However, it might gently be pointed out that when you are the one writing code
    for your server, you don't need any additional protection from making your database
    more than a tolerable 5 MB in size. Most developers will neither need nor want
    tools acting like nannies and protecting them from storing more than 5 MB of server-side
    data. Also, this 5 MB quota, which is a golden balancing act on the client side,
    is rather a bit silly on a Node.js server.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, for a database for multiple users—such as is covered in this appendix—it
    might be pointed out, slightly painfully, that it's not 5 MB per user account,
    unless you create a separate database for list on each account. It is 5 MB shared
    between all user accounts together. This could get painful if you go viral!
  prefs: []
  type: TYPE_NORMAL
- en: 'The documentation states that the quota is customizable, but an e-mail a week
    ago to the developer asking how to change the quota is unanswered, as was a Stack
    Overflow question asking the same thing. The only answer I have been able to find
    is in the GitHub CoffeeScript source, where it is listed as an optional second
    integer argument to a constructor. This is easy enough, and you can specify a
    quota equal to the disk or partition size. But besides porting a feature that
    does not make sense, the tool''s author has also completely failed to follow a
    very standard convention of interpreting 0 as "unlimited" for a variable or function
    wherein an integer is to specify the maximum limit for the concerned resource
    use. The best thing to do with this disfeature is probably to specify that the
    quota is infinity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A similar amateur roughness kept cropping up in elements that surfaced in my
    research. Express.js is of a higher level than Node.js, but in terms of ways of
    shooting yourself in the foot, Node.js is closer to offering C's way than any
    other technology I have used recently. C is for those who prefer to load their
    own rounds before shooting themselves in the foot.
  prefs: []
  type: TYPE_NORMAL
- en: A sample project – a server for our Pragmatometer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's work toward a simple project. We will create a generic server backend
    that can serve a modification of the Pragmatometer project covered in the last
    chapters of this book, which handled persistence by saving and restoring from
    a few JSON strings locally in HTML5 localStorage. We will work on a server that
    can provide static content, like what has already been developed, provide an API
    to save or restore a string and an identifying key, and handle basic authentication
    and account management. The client-side programming should be barely more interesting
    than it was before, essentially by swapping saving to localStorage to saving to
    our remote Node.js server.
  prefs: []
  type: TYPE_NORMAL
- en: We will work with several technologies. The most attention will be given to
    working within Express.js compared to, for instance, Stormpath. Stormpath appears
    not to have taken credit for inventing something fundamentally new, original,
    or stunning, or for a breakthrough in an authentication mechanism. They might
    perhaps take credit for solving a well-known problem in such a way that a large
    chunk of busy work will be taken off your plate. Adding Stormpath is small and
    unobtrusive. Most users will not use it as a platform to build some great work
    on top of. Consequently, we will give significant attention to Express.js (and
    getting our client to talk to Express.js), which is a platform to work with. On
    the framework's site, Express.js is promoted as a "fast, unopinionated web framework
    for Node.js." They pretty much deliver what they boast of.
  prefs: []
  type: TYPE_NORMAL
- en: We will need to build a server, but also alter the client side for the Pragmatometer
    project in chapter 8 to chapter 11 There are `save()` and `restore()` functions,
    and they will be altered and expanded.
  prefs: []
  type: TYPE_NORMAL
- en: Install Express.js via `npm install express`. Then create an express project
    using `express [the directory name for your project]`. You will have a framework
    fleshed out. You can add packages to the `package.json` file, and run `npm install`
    to populate your local copy. There will be a public or static directory that you
    can make available, and `routes/index.js` handles routing in a way that people
    who know other frameworks may feel like home.
  prefs: []
  type: TYPE_NORMAL
- en: Client-side preparations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everything that was under the `js/` directory in chapter 8 to chapter 11 is
    moved to `public/javascripts`. The full details of the changes will be posted
    on the website. Here, we adapt the `save()` and `restore()` functions from being
    (client-side) localStorage-specific to retaining localStorage for a slight perceived
    speed boost, but restore from and save to a remote server. In this case, the server
    is a Node.js server built with Express.js, but it could essentially be any server
    serving the same, simple, and implicit API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ordinarily, with ReactJS, an object''s state is set within a `setInitialState()`
    call. Theoretically, we can preserve the relevant semantics by loading with the
    synchronous equivalent of an Ajax call, but it''s also possible to populate a
    stub and then make available a callback that will really set things in motion.
    The function used to populate an object''s state upon successful return from an
    Ajax call is `populate_state()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `restore()` function is slightly complex, but that''s because it is written
    to build perceived layers of responsiveness. It makes an Ajax call, setting a
    state as initialized and marking `state.initialized` as `false`. It also restores
    from JSON (if anything has been saved). Its check of whether localStorage is available,
    and graceful degradation if it isn''t, is probably historical, as ReactJS is only
    claimed to work with browsers (IE8 and higher) that offer localStorage. Nonetheless,
    it provides an example of how we might go about graceful degradation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As a limitation of scope, neither the implementation of the `restore()` function
    in the preceding code, nor the `save()` function in the following code address
    resilience in the face of a failed Ajax call (or calls). One way of addressing
    this concern is to check for failure and keep retrying, with exponentially increasing
    delays between retries to be a good netizen and not add persistent heavy traffic
    to the network. This pattern is followed (roughly) at a high level by Gmail and
    at a low level baked into TCP/IP. For our implementation, anything that a failed
    Ajax call might not have conveyed should be available afresh in the key-value
    store, unless there has been a subsequent update, in which case both changes will
    usually be saved.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `save()` function is slightly simpler, but it represents the other side
    of a coin: make an Ajax call to save/restore, and save to and restore from localStorage
    as an approximation before it is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'While we are pulling stuff from localStorage, we try to prevent the user from
    being able to enter data. This is because under unpredictable race conditions,
    this data gets clobbered when data from Ajax calls comes back. In other words,
    the user is blocked from adding any input until data is restored from Ajax (even
    if a value has already been restored from localStorage). This means, in particular,
    that submit buttons are disabled, and for now, the only application for which
    the callback function is given to `restore()` is for enabling submit buttons that
    have been disabled. For the calendar, the `render()` method has a disabled **Submit**
    button (you can be more purist and disable all the input fields, but disabling
    the **Submit** button is enough to prevent user data from being clobbered by race
    conditions):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The Calendar''s `getInitialState` function only arranges for a bare stub of
    data to be synchronously put in place. The Ajax call, upon returning, gives it
    a more appropriate value and re-enables the disabled save button, as race conditions
    are no longer a concern here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few more details on the client side, but they are not particularly
    difficult. For instance, we add a Logout link (positioned with CSS to be at the
    top right), and the JavaScript behavior (without calling the usual `preventDefault()`
    method, because we do not want to prevent the default behavior) of erasing account
    data from the key-value store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The server side
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we need packages, we should add them to our `package.json` file. One way
    of doing this is backwards. Perform npm install XYZ and then add a line to the
    `package.json` file under "dependencies," specifying "XYZ": "~1.2.3" and recording
    the version number for the installation. The dependencies presently included are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We create an account at [https://stormpath.com/](https://stormpath.com/), probably
    a free developer account (unless you know you need more), and specify the various
    details in `app.js`. This setup uses HTML-like EJS over Markdown-like Jade for
    views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'All but one of the items marked `[Deleted]` are things that you get from your
    setup on Stormpath. Some people have advised trying to be clever in making your
    own secret key; Don''t! Under Mac, Unix, Linux, or Cygwin (Cygwin is freely available
    from [http://cygwin.org](http://cygwin.org) and runs under Windows), pull up Command
    Prompt and type the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This will get you a kilobyte of cryptographically strong and random data that
    is encoded to be copy and paste friendly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a note on hygiene: the recommended practice is to be very careful with
    your secret key and, in particular, not to include it in version control. Instead,
    put it into a dot-file directory under your home directory with permissions that
    don''t let anyone else do anything with it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Probably, the one file with the heaviest work in it is `routes/index.js`. We
    pull in several dependencies, including a body parser that will be able to get
    data out of Ajax saves that POST JSON in the body of the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We include localStorage , specifying Infinity as our quota, and then provide
    a sanitizer for characters in keys. This specific sanitizer leaves alphanumeric
    characters intact, which with the rest of the application is sufficient to ensure
    that it doesn''t make key collisions. It also ensures that the characters are
    on a whitelist that excludes colons. This allows us to create keys with names
    similar to `username:component-name`, perform a string split on colons, and always
    get the username in the zeroth slot and a component name in the first slot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The router works in a way that should seem familiar to users who''ve seen routers
    in almost any context before. Although route and non-route functions will be mixed,
    the router is created and connected to the first two routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The included `stormpath.loginRequired`, once Stormpath is included, is really
    all that you need to get a view to be login protected. We go ahead to define two
    non-view functions: the functions used to `save()` and `restore()` a key for a
    particular user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We add the routes that will service the POST Ajax requests. If we want to add
    support for GET or other verbs, we can call `router.get()` and the like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then there is a boilerplate line that we keep intact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We also use Express.js''s hierarchy for static data; the revised `index.ejs`
    pulls from a place different from our earlier js/:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: And that's it! We provide full details in the electronic resource packet. Now
    we have provided a server-side key-value store with account management.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When this appendix was being contemplated, one of the questions I considered
    was "JavaScript plus Node.js or Python plus Django?" The focus of this book is
    on a frontend with ReactJS, and the focus on the backend was just to have enough
    to support the frontend. I naturally thought that Python is so easy, even to newcomers,
    and Django also is so easy (again, even to newcomers) that even with the introduction
    of a new language, a basic key-value store with authentication should be an easy
    appendix to read and to write. However, the author thought then that I would go
    the high road of JavaScript plus Node.js, the combination everybody wants in on,
    and I have been paying for his decision not to provide a Python-plus-Django appendix
    ever since.
  prefs: []
  type: TYPE_NORMAL
- en: The code provided in a bundle is, of course, freely offered for any mileage
    you can pull from it that won't violate Packt Publishing's licensing. But the
    basic task of implementing a key-value store with account management is perhaps
    of the level of an undergraduate's homework assignment. It does not, in any sense,
    demonstrate the peaks of wonder offered by any server.
  prefs: []
  type: TYPE_NORMAL
- en: Now, Node.js really does offer peaks of wonder. These, however, were not explored
    here because the goal was to provide just enough "Node.js plus Express.js" to
    create a server-based adaptation of the Pragmatometer project covered in chapters
    8 to 11\. Moreover, given the degree of enthusiasm and the sheer work hours on
    all projects, it may be warranted in a year, 2 years, or 3 years to sharply temper
    any remarks about an immature ecosystem made at the time of writing this book.
    After 5 years, it may really make sense to say, "The 2015 Node.js ecosystem had
    several minefields. The 2020 Node.js ecosystem has multiple paradises."
  prefs: []
  type: TYPE_NORMAL
- en: But to publish, as passport.js did, to have a simple animation between `passport.authenticate('twitter')`,
    `passport.authenticate('google')`, `passport.authenticate('facebook')`, and so
    on slide by with a quite seductive apparent ease, and then have the user searching
    and asking at length for a passport.js way to handle username-password authentication
    that allowed users to create a new account, doesn't happen. This is extremely
    inappropriate, and it is inappropriate in a way that happened more than once in
    the Node.js ecosystem. The transition between finding a Node.js tool with a slick
    website that seems to offer exactly what you need, and activating "Hello, world!"
    levels of functionality meets perhaps 50 percent success. It represents a gulf
    bigger than I anything have seen in the entire history of the Web.
  prefs: []
  type: TYPE_NORMAL
- en: I can see people thinking, not exactly that I am brilliant because of how I
    made the to-do list with multiple statuses available for each item, but that I
    was practical, and overall the book significantly reduced the amount of legwork
    involved in the readers' getting up to speed with ReactJS. However, I would be
    mystified if people told me that I was brilliant, because I thought of making
    an authenticated key-value store, as covered in this appendix. The achievement
    is not at all because I managed to get some technology to work as an authenticated
    key-value store—which is a task on par with undergraduate homework—but because
    it was accomplished in an environment that exists in continuity with INTERCAL.
  prefs: []
  type: TYPE_NORMAL
- en: 'People have needlessly shot themselves in the foot by constantly using JavaScript
    as a whole, and crucial to JavaScript being made a respectable language was Douglas
    Crockford saying, in essence:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"JavaScript as a language has some really good parts and some really bad parts.
    Here are the good parts. Just forget that anything else is there."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Perhaps the hot Node.js ecosystem will grow its own "Douglas Crockford," who
    will say:'
  prefs: []
  type: TYPE_NORMAL
- en: The Node.js ecosystem is a coding Wild West, but there are some real gems to
    be found. Here's a road map. Here are the areas to avoid at almost any cost. And
    here are the areas with some of the richest pay dirt to be found in any language
    or environment.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps someone else can take these words as a challenge, follow Crockford's
    lead, and write *The Good Parts* and/or *The Better Parts* for Node.js and its
    ecosystem. I'd buy a copy!
  prefs: []
  type: TYPE_NORMAL
