- en: Chapter 2. Enumeration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Performing a ping sweep with Scapy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scanning with Scapy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking username validity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brute forcing usernames
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerating files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brute forcing passwords
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating e-mail addresses from names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding e-mail addresses from web pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding comments in source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you have identified the targets for testing, you'll want to perform some
    enumeration. This will help you to identify some potential paths for further reconnaissance
    or attacks. This is an important step. After all, if you were to try to steal
    something from a safe, you would first take a look to determine whether or not
    you'd need a pin, key, or combination, rather than simply attaching a stick of
    dynamite and potentially destroying the contents.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at some ways that you can use Python to perform
    active enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: Performing a ping sweep with Scapy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the first tasks to perform when you have identified a target network
    is to check which hosts are live. A simple way of achieving this is to ping an
    IP address and confirm whether or not a reply is received. However, doing this
    for more than a few hosts can quickly become a draining task. This recipe aims
    to show you how you can achieve this with Scapy.
  prefs: []
  type: TYPE_NORMAL
- en: Scapy is a powerful tool that can be used to manipulate network packets. While
    we will not be going into great depth of all that can be accomplished with Scapy,
    we will use it in this recipe to determine which hosts reply to an **Internet
    Control Message Protocol** (**ICMP**) packet. While you can probably create a
    simple bash script and tie it together with some grep filtering, this recipe aims
    to show you techniques that will be useful for tasks involving iterating through
    IP ranges, as well as an example of basic Scapy usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scapy can be installed on the majority of Linux systems with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following script shows how you can use Scapy to create an ICMP packet to
    send and process the response if it is received:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first section of the script will set up suppression of warning messages
    from Scapy when it runs. A common occurrence when importing Scapy on machines
    that do not have IPv6 configured is a warning message about not being able to
    route through IPv6.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The next section imports the necessary modules, validates the number of arguments
    received, and sets up a list for storing hosts found to be live:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We then compile a regular expression that will check that the IP addresses
    are valid. This not only checks the format of the string, but also that it exists
    within the IPv4 address space. This compiled regular expression is then used to
    match against the supplied arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the IP addresses have been validated, then further checks are carried
    out to ensure that the range supplied is a valid range and to assign the variables
    that will be used to set the parameters for the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The next part of the script is purely informational and can be omitted. It
    will print out the IP address range to be pinged or, in the case of both arguments
    supplied being equal, the IP address to be pinged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We then enter the loop and start by creating an ICMP packet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we use the `sr1` command to send the packet and receive one packet
    back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we check that a response was received and that the response code was
    `0`. The reason for this is because a response code of `0` represents an echo
    reply. Other codes may be reporting an inability to reach the destination. If
    a response passes these checks, then the IP address is appended to the `livehosts`
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If live hosts have been found, then the script will then print out the list.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning with Scapy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scapy is a powerful tool that can be used to manipulate network packets. While
    we will not be going into great depth of all that can be accomplished with Scapy,
    we will use it in this recipe to determine which TCP ports are open on a target.
    In identifying which ports are open on a target, you may be able to determine
    the types of services that are running and use these to then further your testing.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the script that will perform a port scan on a specific target in a
    given port range. It takes arguments for the target, the start of the port range
    and the end of the port range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing you notice about this recipe is the starting two lines of the
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'These lines serve to suppress a warning created by Scapy when IPv6 routing
    isn''t configured, which causes the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This isn't essential for the functionality of the script, but it does make the
    output tidier when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: The next few lines will validate the number of arguments and assign the arguments
    to variables for use in the script. The script also checks to see whether the
    start and end of the port range are the same and increments the end port in order
    for the loop to be able to work.
  prefs: []
  type: TYPE_NORMAL
- en: 'After all of the setting up, we''ll loop through the port range and the real
    meat of the script comes along. First, we create a rudimentary TCP packet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We then use the `sr1` command. This command is an abbreviation of `send/receive1`.
    This command will send the packet we have created and receive the first packet
    that is sent back. The additional parameters we have supplied include a timeout,
    so the script will not hang for closed or filtered ports, and the verbose parameter
    we have set will turn off the output that Scapy normally creates when sending
    packets.
  prefs: []
  type: TYPE_NORMAL
- en: The script then checks whether there is a response that contains TCP data. If
    it does contain TCP data, then the script will check for the SYN and ACK flags.
    The presence of these flags would indicate a SYN-ACK response, which is part of
    the TCP protocol handshake and shows that the port is open.
  prefs: []
  type: TYPE_NORMAL
- en: 'If it is determined that a port is open, an output is printed to this effect
    and the next line of code sends a reset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This line is necessary in order to close the connection and prevent a TCP SYN-flood
    attack from occurring if the port range and the number of open ports are large.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we showed you how Scapy can be used to perform a TCP port scan.
    The techniques used in this recipe can be adapted to perform a UDP port scan on
    a host or a ping scan on a range of hosts.
  prefs: []
  type: TYPE_NORMAL
- en: This just touches the surface of what Scapy is capable of. For more information,
    a good place to start is on the official Scapy website at [http://www.secdev.org/projects/scapy/](http://www.secdev.org/projects/scapy/).
  prefs: []
  type: TYPE_NORMAL
- en: Checking username validity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When performing your reconnaissance, you may come across parts of web applications
    that will allow you to determine whether or not certain usernames are valid. A
    prime example of this will be a page that allows you to request a password reset
    when you have forgotten your password. For instance, if the page asks that you
    enter your username in order to have a password reset, it may give different responses
    depending on whether or not a user with that username exists. So, if a username
    doesn't exist, the page may respond with `Username not found`, or something similar.
    However, if the username does exist, it may redirect you to the login page and
    inform you that `Password reset instructions have been sent to your registered
    email address`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each web application may be different. So, before you go ahead and create your
    username checking tool, you will want to perform a reconnaissance. Details you
    will need to find will include the page that is accessed to request a password
    reset, the parameters that you need to send to this page, and what happens in
    the event of a successful or failed outcome.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have the details of how the password reset request works on the target,
    you can assemble your script. The following is an example of what your tool will
    look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following shows an example of the output produced when using this script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After the number of arguments have been validated and the arguments have been
    assigned to variables, we use the `urllib` module in order to encode the data
    that we are submitting to the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We then look for the string that indicates that the request failed due to a
    username that does not exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The result of find (`str`) does not give a simple true or false. Instead, it
    will return the position in the string that the substring is found in. However,
    if it does not find the substring you are searching for, it will return `1`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe can be adapted to other situations. Password resets may request
    e-mail addresses instead of usernames. Or a successful response may reveal the
    e-mail address registered to a user. The important thing is to look out for situations
    where a web application may reveal more than it should.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For bigger jobs, you will want to consider using the *Brute forcing usernames*
    recipe instead.
  prefs: []
  type: TYPE_NORMAL
- en: Brute forcing usernames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For small but regular instances, a small tool that enables you to quickly check
    something will suffice. What about those bigger jobs? Maybe you've got a big haul
    from open source intelligence gathering and you want to see which of those users
    use an application you are targeting. This recipe will show you how to automate
    the process of checking for usernames that you have stored in a file.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you use this recipe, you will need to acquire a list of usernames to
    test. This can either be something you have created yourself, or you can use a
    word list found within Kali. If you need to create your own list, a good place
    to start would be to use common names that are likely to be found in a web application.
    These could include usernames such as `user`, `admin`, `administrator`, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This script will attempt to check usernames in a list provided to determine
    whether or not an account exists within the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of the output of this script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This script introduces a couple more concepts than basic username checking.
    The first of these is opening files in order to load our list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This opens the file containing our list of usernames and loads it into our
    `userlist` variable. We then loop through the list of users in the list. In this
    recipe, we also make use of the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This command strips out whitespace, including newline characters, which can
    sometimes change the result of the encoding before being submitted.
  prefs: []
  type: TYPE_NORMAL
- en: If a username exists, then it is appended to a list. When all usernames have
    been checked, the contents of the list are output.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For single usernames, you will want to make use of the *Basic username check*
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When enumerating a web application, you will want to determine what pages exist.
    A common practice that is normally used is called spidering. Spidering works by
    going to a website and then following every single link within that page and any
    subsequent pages within that website. However, for certain sites, such as wikis,
    this method may result in the deletion of data if a link performs an edit or delete
    function when accessed. This recipe will instead take a list of commonly found
    filenames of web pages and check whether they exist.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need to create a list of commonly found page names.
    Penetration testing distributions, such as Kali Linux will come with word lists
    for various brute forcing tools and these could be used instead of generating
    your own.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following script will take a list of possible filenames and test to see
    whether the pages exist within a website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output shows what could be returned when run against **Damn Vulnerable
    Web App** (**DVWA**) using a list of commonly found web pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After importing the necessary modules and validating the number of arguments,
    the list of filenames to check is opened in read-only mode, which is indicated
    by the `r` parameter in the file''s `open` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'When the script enters the loop for the list of filenames, any newline characters
    are stripped from the filename, as this will affect the creation of the URLs when
    checking for the existence of the filename. If a preceding `.` exists in the provided
    extension, then that also is stripped. This allows for the use of an extension
    that does or doesn''t have the preceding `.` included, for example, `.php` or
    `php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The main action of the script then checks whether or not a web page with the
    given filename exists by checking for a `HTTP 200` code and catches any errors
    given by a nonexistent page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Brute forcing passwords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Brute forcing may not be the most elegant of solutions, but it will automate
    what could be a potentially mundane task. Through the use of automation, you can
    get tasks completed much more quickly, or at least free yourself up to work on
    something else at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To be able to use this recipe, you will need a list of usernames that you wish
    to test and also a list of passwords. While this is not the true definition of
    brute forcing, it will lower the number of combinations that you will be testing.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you do not have a password list available, there are many available online,
    such as the top 10,000 most common passwords on GitHub here at [https://github.com/neo/discourse_heroku/blob/master/lib/common_passwords/10k-common-passwords.txt](https://github.com/neo/discourse_heroku/blob/master/lib/common_passwords/10k-common-passwords.txt).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code shows an example of how to implement this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following shows an example of the output produced when the script is run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After the initial importing of the necessary modules and checking the system
    arguments, we set up password checking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The filename arguments are stored in variables, which are then opened. The `r`
    variable means that we are opening these files as read-only.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also specify our target and initialize an array to store any valid credentials
    that we find:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `FailStr` variable in the preceding code is just to make our lives easier
    by having a short variable name to type instead of typing out the entire string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main course of this recipe lies within a nested loop in which our automated
    password checking is carried out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Within this loop, a request is sent including the username and password as parameters.
    If the response doesn't contain the string indicating that the username and password
    combination is invalid, then we know that we have a valid set of credentials.
    We then add these credentials to the array that we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once all the username and password combinations have been tried, we then check
    the array to see whether there are any credentials. If so, we print out the credentials.
    If not, we print out a sad message informing us that we have not found anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you're looking to find usernames, you may also want to make use of the *Checking
    username validity* and the *Brute forcing usernames* recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Generating e-mail addresses from names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some scenarios, you may have a list of employees for a target company and
    you want to generate a list of e-mail addresses. E-mail addresses can be potentially
    useful. You might want to use them to perform a phishing attack, or you might
    want to use them to try and log on to a company's application, such as an e-mail
    or a corporate portal containing sensitive internal documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you can use this recipe, you will want to have a list of names to work
    with. If you don't have a list of names, you might want to consider first performing
    an open source intelligence exercise on your target.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code will take a file containing a list of names and generate
    a list of e-mail addresses in varying formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main mechanism in this recipe is the use of string concatenation. By joining
    up the first name or first initial with the last name in different combinations
    with an e-mail suffix, you have a list of potential e-mail addresses that you
    can then use in a later test.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The recipe featured shows how a list of names can be used to generate a list
    of e-mail addresses. However, not all the e-mail addresses will be valid. You
    could further narrow this list by using enumeration techniques in a company's
    application that may reveal whether an e-mail address exists. You could also perform
    further open source intelligence investigations, which may allow you to determine
    the correct format for the target organization's e-mail addresses. If you manage
    to achieve this, you can then remove any unnecessary formats from the recipe to
    generate a more concise list of e-mail addresses that will provide greater value
    to you later on.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you've got your e-mail addresses, you may want to use them as part of the
    *Checking username validity* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Finding e-mail addresses from web pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of generating your own e-mail list, you may find that a target organisation
    will have some that exist on their web pages. This may prove to be of higher value
    than e-mail addresses you have generated yourself as the likelihood of e-mail
    addresses on a target organisation's website being valid will be much higher than
    ones you have tried to guess.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need a list of pages you want to parse for e-mail
    addresses. You may want to visit the target organization's website and search
    for a sitemap. A sitemap can then be parsed for links to pages that exist within
    the website.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code will parse through responses from a list of URLs for instances
    of text that match an e-mail address format and save them to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After importing the necessary modules, you will see the assignment of the `regex`
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This attempts to match an e-mail address format, for example `victim@target.com`,
    or victim at target dot com. The code then opens up a file containing the URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You might notice the use of the parameter `r` . This opens the file in read-only
    mode. The code then loops through the list of URLs. Within the loop, a file is
    opened to save e-mail addresses to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the `a` parameter is used. This indicates that any input to this
    file will be appended instead of overwriting the entire file. The script utilizes
    a sleep timer in order to avoid triggering any protective measures the target
    may have in place to prevent attacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This timer will pause the script for a random amount of time between `10` and
    `100` seconds.
  prefs: []
  type: TYPE_NORMAL
- en: The use of exception handling when using the `urlopen()` method is essential.
    If the response from `urlopen()` is `404 (HTTP not found error)`, then the script
    will error and exit.
  prefs: []
  type: TYPE_NORMAL
- en: 'If there is a valid response, the script will then store all instances of e-mail
    addresses in the `emails` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'It will then loop through the `emails` variable and write each item in the
    list to the `emails.txt` file and also output it to the console for confirmation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The regular expression matching used in this recipe matches two common types
    of format used to represent e-mail addresses on the Internet. During the course
    of your learning and investigations, you may come across other formats that you
    might like to include in your matching. For more information on regular expressions
    in Python, you may want read the documentation on the Python website for regular
    expressions at [https://docs.python.org/2/library/re.html](https://docs.python.org/2/library/re.html).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the recipe *Generating e-mail addresses from names* for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Finding comments in source code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common security issue is caused by good programming practices. During the
    development phase of web applications, developers will comment their code. This
    is very useful during this phase, as it helps with understanding the code and
    will serve as useful reminders for various reasons. However, when the web application
    is ready to be deployed in a production environment, it is best practice to remove
    all these comments as they may prove useful to an attacker.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will use a combination of `Requests` and `BeautifulSoup` in order
    to search a URL for comments, as well as searching for links on the page and searching
    those subsequent URLs for comments as well. The technique of following links from
    a page and analysing those URLs is known as spidering.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following script will scrape a URL for comments and links in the source
    code. It will then also perform limited spidering and search linked URLs for comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After the initial import of the necessary modules and setting up of variables,
    the script first gets the source code of the target URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that for `Beautifulsoup`, we have the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This is so that when we use `BeautifulSoup`, we just have to type `BeautifulSoup`
    instead of `bs4.BeautifulSoup`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It then searches for all instances of HTML comments and prints them out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The script will then use `Beautifulsoup` in order to scrape the source code
    for any instances of absolute (starting with `http`) and relative (starting with
    `/`) links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Once the script has collated a list of URLs linked to from the page, it will
    then search each page for HTML comments.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe shows a basic example of comment scraping and spidering. It is possible
    to add more intelligence to this recipe to suit your needs. For instance, you
    may want to account for relative links that use start with `.` or `..` to denote
    the current and parent directories.
  prefs: []
  type: TYPE_NORMAL
- en: You can also add more control to the spidering part. You could extract the domain
    from the supplied target URL and create a filter that does not scrape links for
    domains external to the target. This is especially useful for professional engagements
    where you need to adhere to a scope of targets.
  prefs: []
  type: TYPE_NORMAL
