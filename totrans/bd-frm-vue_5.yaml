- en: Input Validation with Vuelidate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In production-ready forms, validating user input is a must. Even though, on
    the server side, applications should double-check all the data that is passed
    to them, also pre-validating data on the frontend should be a mandatory practice
    for any experienced developer.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to look at a very well-known and powerful library
    for form validation, Vuelidate. You will learn how to use this library in your
    projects, and you will be able to successfully validate user input with it.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, in Vue, we have a few different options for third-party libraries,
    such as Vuelidate, VeeValidate, and even Vuetify has its own validation methods.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be covering Vuelidate. Ranging from its installation
    to the creation of rules and applying them to our form inputs, and using the error
    state to inform our users of a problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating validation rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving validation into our custom inputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the final touches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found in the following GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Building-Forms-with-Vue.js/tree/master/Chapter05](https://github.com/PacktPublishing/Building-Forms-with-Vue.js/tree/master/Chapter05).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2VJIL8E](http://bit.ly/2VJIL8E)'
  prefs: []
  type: TYPE_NORMAL
- en: Installing dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by installing Vuelidate in our project as a dependency, and then
    we are going to use it for validation. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the Terminal and execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Once the library has been installed, we have to import it into `main.js` and
    use it as a plugin, so that it is globally available to all our components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `main.js`, after the code that imports `Vue` and
    `App`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now that Vuelidate has been installed and is now part of our project dependencies,
    we are ready to make it do some of the heavy lifting. In the next section, we
    are going to create our validation rules.
  prefs: []
  type: TYPE_NORMAL
- en: Creating validation rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we added Vuelidate to our project through `Vue.use`, the library added
    a new reserved property that we can use on our components: `validations`.'
  prefs: []
  type: TYPE_NORMAL
- en: This property is added onto the configuration object for the component, alongside
    `data()`, `computed`, and so on. It will also be an object that holds a property
    of its own for each input that we want to validate.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create this property and set up a new input, without a custom component
    wrapper to test. Once we understand the basics, we can work on translating all
    of this into our `BaseInput` and `BaseSelect` components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps in order to create validation rules:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `<input>` form below the `telephone` object of `BaseInput` in
    `App.vue`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember to add this new property, `website`, to the `form` object of `data()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go and actually create a `validations` property; for now, we will
    only add the `form.website` validations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Place it on the top level of the `component` object, at the same level as your
    `data()` and computed properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For this particular field, we want to make sure that we validate that the input
    that the user provides, is a valid URL. In Vuelidate, we have several different
    built-in validators that we can use out of the box. A complete list can be found
    at [https://vuelidate.netlify.com/#sub-builtin-validators](https://vuelidate.netlify.com/#sub-builtin-validators).
  prefs: []
  type: TYPE_NORMAL
- en: In order to validate that the input is a valid URL, we have the URL validator.
    But, in order for us to add it to our website's `validators` object, we have to
    import it first. Vuelidate allows us to import only the validators that we are
    actually going to be using; that way, we can ensure that our deployed code stays
    smaller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following import statement to `App.vue`, near the other imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have imported the statement, we can finally add it to the `validations.website`
    object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: That's enough of setting up our rules. Remember the new `<input>` form that
    we created earlier to hold `v-model="form.website"`? We're going to need to make
    some adjustments to the way that `v-model` is set up, in order for Vuelidate to
    take charge of the validation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the `validations` property that we used earlier to set up our rules,
    Vuelidate gives us access to a new property inside the component instance: `$v`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`$v` is a special object that holds a copy of our validation structure. Among
    other things, a notable trait is that it has a `$model` property for each one
    of the elements that we added to `validations`. Vuelidate will become an *intermediary*
    model for us, and in turn, it will take care of actually binding to our `form.website`
    property within `data()`, automatically.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at this in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `<input>` website element to use the new `v-model` format that Vuelidate
    expects. Also, we are going to interpolate the `$v` object below it, so that you
    can see more clearly what''s happening behind the scenes, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Go back to your browser and take a look at the structure of the `$v` object,
    before you type anything in your new form field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first thing to pay special attention to is the `form.website` object. Inside
    this object, Vuelidate will keep the validation state of this input. The `$model`
    property will hold the user's input, just as we told `v-model` to do. The `$error`
    property is the one that will actually toggle a Boolean value, and will let us
    know if there was an error in the input.
  prefs: []
  type: TYPE_NORMAL
- en: Try typing some random gibberish in the field and observe the properties that
    get updated. The `$error` property will update to `true`, to indicate that there
    is an error. The `url` property, which is directly tied to the URL rule, will
    switch to `false`, to indicate that the URL validation condition is not being
    met.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add some CSS binding onto `<input>`, in order to visually display that
    something is not passing validation on our input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Try this in your browser before we go into a further explanation. Try typing
    a valid URL, such as [http://google.com](http://google.com), and notice how the
    input changes to reflect your changes.
  prefs: []
  type: TYPE_NORMAL
- en: The `:class` binding is a way to add classes conditionally to any HTML element
    in Vue. In the type of syntax that we are using here, an object, it allows us
    to set up a key-value pair, in which the key defines the class that we want to
    be toggled, for example, `is-valid`.
  prefs: []
  type: TYPE_NORMAL
- en: The value is a JavaScript condition that will be evaluated, in order to determine
    whether or not the class should be applied. These conditions are reactive, and
    will be re-executed every time the dependencies of the condition change.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, `is-valid` will be toggled *on*, whenever there is no `$error` and
    the input is `$dirty`. If you're wondering why we have to check against `$dirty`
    as well, try removing that part of the condition and then reload your browser.
    You'll notice right away that the green border and checkmark are present on the
    input, even if the element doesn't have any value in it. The way we determine
    whether `<input>` has been modified by the user at any point is through the `$dirty`
    property; in this case, it makes sense from a UX perspective to not show the valid
    visual queues until there's actually some input there.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of `is-invalid`, we are checking to see if there are any `$errors`
    present in the field, and setting the field up with a nice red border and an x
    icon.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have some basic rules in place, let's move on to the next section,
    where we will learn how to incorporate all of this into our custom components.
  prefs: []
  type: TYPE_NORMAL
- en: Moving validation into our custom inputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The amazing thing about having your own custom components is that you can craft
    them in any way you like. For this chapter, we're going to add support for both
    a valid and an invalid status to our components. The main validation logic will
    still be held by the parent, `App.vue`, as it is the containing component that
    holds our form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to add validations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s add new rules for each of our inputs. Add the following to the
    `validations` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t forget to update your import statement to bring in the new validators
    that we are now using, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go over the new validators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`alpha`: This will restrict the field to only alpha-numeric characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`required`: This field makes the field required; it is invalid if there is
    no value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`email`: This field ensures that the input holds a valid email format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the `telephone` field, we're going to do some custom validation, because
    this field is masked to have a specific format, `(###)###-####`, and we need to
    resort to writing our own validation function.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we're calling the validator, `validPhone`, and it is a function
    that returns a Boolean value. This Boolean is calculated by matching the phone
    against a regular expression and assuring that it is not null; that is, that it
    does, in fact, have a match.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have all our `validations` in place, we have to update our `App.vue`
    template. Our `BaseInput` components and the `BaseSelect` component need to have
    `v-model` updated, so that it points to the Vuelidate model instead of our local
    state. Also, we need to update our website input to a full `BaseInput` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make the following changes to your code; we are updating `v-model` and the
    input types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In order for our custom components to display the correct CSS classes, we are
    going to add a new prop to them called `validator`, and we will pass the reference
    to the Vuelidate object's prop that matches this particular element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `BaseInput.vue` and create the `validator` property, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the `validator` method for the property, we are going to check that the `validator` object
    that got passed in as a property has a `$model` property in it (that is, `validator.$model`),
    which is `true` for all of the field props of Vuelidate. That way, we can ensure
    that we have access to the properties that we need.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's bring over the `:class` binding that we had before on our `<input>`
    element, but we will make some slight adjustments, to account for this being a
    `component` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following to the `<input>` element inside `BaseInput.vue`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Since `validator` is not a required prop on our component, we have to double-check
    that the condition that is actually set before checking its `$error` and `$dirty`
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, go back to `App.vue` and add the `:validator` attribute to all of
    our `BasicInput` elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Go back to your browser and play around with the inputs, now that they are all
    being validated behind the scenes by Vuelidate!
  prefs: []
  type: TYPE_NORMAL
- en: Whew, that was quite a bit of information—grab yourself a break and some avocado
    toast; you deserve it! In the next section, we are going to make some final changes
    to our form, to `BaseSelect` , and to our `onSubmit` method, so that we can wrap
    things up.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the final touches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a couple more things that we need to do before we can close off this
    chapter. First of all, let's take care of `BaseSelect`; it still needs a `validator`
    property and some `:class` bindings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to find out how we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the `validator` prop in `BaseSelect.vue`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's add the `:class` binding; except here, we're not going to check against
    `$dirty`, because we don't have an initial empty value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `<select>` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the component is ready, go back to `App.vue` and update our `BaseSelect`
    element with its own `:validator` attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Go back to your browser and verify that the element is behaving as expected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another thing that we shouldn't forget to change is our `onSubmit` method on
    `App.vue`. Right now, we are using a `computed` property that is doing a very
    poor job of checking the validity of our form. Let's fix this by leveraging some
    more of Vuelidate's power to check whether our form is ready to submit. To do
    this, let's delete our `formIsValid` `computed` property first.
  prefs: []
  type: TYPE_NORMAL
- en: Vuelidate has an `$invalid` property on the root of the `$v` object, which we
    can check to see whether the form is ready for submission. We are going to use
    this in a minute for our `onSubmit` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Delete the `formIsValid` `computed` property completely:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: By default, all forms start out as having an `$invalid` state, because Vuelidate
    triggers its validations when the user `$touches` and modifies the input fields.
    We need to make some slight adjustments in order to accommodate this behavior
    with our Submit button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the button''s `:disabled` attribute first, in order to check against
    `$error`, instead of our old `computed` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s modify the `onSubmit` method to both force the `$touch` method
    of all the inputs (and to trigger the validations on all of them), and to check
    afterward whether the form is actually valid and ready for submitting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Go back to your browser and reload the window to clear the inputs. Without typing
    anything, click on the Submit button. You will see that the `$v.$touch()` method
    will trigger and the invalid inputs (such as those that are required, for example)
    will turn to red to indicate that there is a problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see how `validator` is working, and how
    it is visually confirming to the user, what is happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/11fd20c9-49ef-4626-893d-e6b33dfd20b7.png)'
  prefs: []
  type: TYPE_IMG
- en: That's it! Vuelidate is a fantastic tool when it comes to form validation—it
    is super flexible, and allows for hooking into external data sources such as Vuex,
    which we will see in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned how to add Vuelidate as a dependency to your
    Vue project, as well as acquiring the skills to set up and manage form validation
    on regular inputs and on custom components. In the next chapter, we are going
    to take things one step further and look at global state management with—*drum
    roll*—Vuex!
  prefs: []
  type: TYPE_NORMAL
