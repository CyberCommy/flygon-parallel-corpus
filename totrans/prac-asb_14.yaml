- en: Troubleshooting and Testing Strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a similar way to any other kind of code, Ansible code can contain issues
    and bugs. Ansible tries to make it as safe as possible by checking the task syntax
    before the task is executed. This check, however, only saves you from a small
    number of possible types of errors, such as incorrect task parameters, but it
    will not protect you from others.
  prefs: []
  type: TYPE_NORMAL
- en: It's also important to remember that, due to its nature, in Ansible code, we
    describe the desired state rather than stating a sequence of steps to obtain the
    desired state. This difference means that the system is less prone to logical
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, a bug in a Playbook could mean a potential misconfiguration on
    all of your machines. This should be taken very seriously. It is even more critical
    when critical parts of the system are changed, such as SSH daemon or `sudo` configuration,
    since the risk is you locking yourself out of the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a bunch of different ways to prevent or mitigate a bug in Ansible
    playbooks. In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Digging into playbook execution problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using host facts to diagnose failures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing with a playbook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using check mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving host connection issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing working variables via the CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limiting the host's execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flushing the code cache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking for bad syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter assumes that you have set up your control host with Ansible, as
    detailed in [Chapter 1](0efc8364-b8a4-4866-9ff4-1e2d09f6724b.xhtml), *Getting
    Started with Ansible*, and are using the most recent version available – the examples
    in this chapter were tested with Ansible 2.9\. Although we will give specific
    examples of hostnames in this chapter, you are free to substitute them with your
    own hostname and/or IP addresses. Details of how to do this will be provided at
    the appropriate places.
  prefs: []
  type: TYPE_NORMAL
- en: The examples in this chapter can be found in this book's GitHub repository at [https://github.com/PacktPublishing/Practical-Ansible-2/tree/master/Chapter%2011](https://github.com/PacktPublishing/Practical-Ansible-2/tree/master/Chapter%2011).
  prefs: []
  type: TYPE_NORMAL
- en: Digging into playbook execution problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are cases where an Ansible execution will interrupt. Many things can cause
    these situations.
  prefs: []
  type: TYPE_NORMAL
- en: The single most frequent cause of problems I've found while executing Ansible
    playbooks is the network. Since the machine that is issuing the commands and the
    one that is performing them are usually linked through the network, a problem
    in the network will immediately show itself as an Ansible execution problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, and this is particularly true for some modules, such as `shell`
    or `command`, the return code is non-zero, even though the execution was successful.
    In those cases, you can ignore the error by using the following line in your module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance, if you run the `/bin/false` command, it will always return `1`.
    To execute this in a playbook so that you can avoid it blocking there, you can
    write something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As we have seen, `/bin/false` will always return `1` as return code, but we
    still managed to go forward in the execution. Be aware that this is a particular
    case, and often, the best approach is to fix your application so that you're following
    UNIX standards and return `0` if the application runs appropriately, instead of
    putting a workaround in your Playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will talk more about the methods we can use to diagnose Ansible execution
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: Using host facts to diagnose failures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some execution failures derive from the state of the target machine. The most
    common problem of this kind is the case where Ansible expects a file or variable
    to be present, but it's not.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, it can be enough to print the machine facts to find the problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we need to create a simple playbook, called `print_facts.yaml`, which
    contains the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This technique will give you a lot of information about the state of the target
    machine during Ansible execution.
  prefs: []
  type: TYPE_NORMAL
- en: Testing with a playbook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most complex things in the IT field is not creating software and
    systems, but debugging them when they have problems. Ansible is not an exception.
    No matter how good you are at creating Ansible playbooks, sooner or later, you'll
    find yourself debugging a playbook that is not behaving as you thought it would.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way of performing basic tests is to print out the values of variables
    during execution. Let''s learn how to do this with Ansible, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need a playbook called `debug.yaml` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Run it with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You will receive an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the first task, we used the `command` module to execute the `uptime` command
    and saved its output in the `result` variable. Then, in the second task, we used
    the `debug` module to print the content of the `result` variable.
  prefs: []
  type: TYPE_NORMAL
- en: The `debug` module is the module that allows you to print the value of a variable
    (by using the `var` option) or a fixed string (by using the `msg` option) during
    Ansible's execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `debug` module also provides the `verbosity` option. Let''s say you change
    the playbook in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you try to execute it in the same way you did previously, you will
    notice that the debug step won''t be executed and that the following line will
    appear in the output instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is because we set the minimum required `verbosity` to `2`, and by default,
    Ansible runs with a `verbosity` of `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the result of using the debug module with this new playbook, we will
    need to run a slightly different command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: By putting two `-v` options in the command line, we will be running Ansible
    with `verbosity` of `2`. This will not only affect this specific module but all
    the modules (or Ansible itself) that are set to behave differently at different
    debug levels.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned how to test with a playbook, let's learn how to use check
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: Using check mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although you might be confident in the code you have written, it still pays
    to test it before running it for real in a production environment. In such cases,
    it is a good idea to be able to run your code, but with a safety net in place.
    This is what check mode is for. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need to create an easy playbook to test this feature. Let''s
    create a playbook called `check-mode.yaml` that contains the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can run the playbook in the check mode by specifying the `--check`
    option in the invocation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output everything as if it was really performing the operation, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: However, if you look in `/tmp`, you won't find `myfile`.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible check mode is usually called a dry run. The idea is that the run won't
    change the state of the machine and will only highlight the differences between
    the current status and the status declared in the playbook.
  prefs: []
  type: TYPE_NORMAL
- en: Not all modules support check mode, but all major modules do, and more and more
    modules are being added at every release. In particular, note that the `command`
    and `shell` modules do not support it because it is impossible for the module
    to tell what commands will result in a change, and what won't. Therefore, these
    modules will always return changed when they're run outside of check mode because
    they assume a change has been made.
  prefs: []
  type: TYPE_NORMAL
- en: 'A similar feature to check mode is the `--diff` flag. What this flag allows
    us to do is track what exactly changed during an Ansible execution. So, let''s
    say we run the same playbook with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the output says `changed`, which means that something was changed
    (more specifically, the file was created), and in the output, we can see a diff-like
    output that tells us that the state moved from `absent` to `touch`, which means
    the file was created. `mtime` and `atime` also changed, but this is probably due
    to how files are created and checked.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned how to use check mode, let's learn how to solve host
    connection issues.
  prefs: []
  type: TYPE_NORMAL
- en: Solving host connection issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible is often used to manage remote hosts or systems. To do this, Ansible
    will need to be able to connect to the remote host, and only after that will it
    be able to issue commands. Sometimes, the problem is that Ansible is unable to
    connect to the remote host. A typical example of this is when you try to manage
    a machine that hasn't booted yet. Being able to quickly recognize these kinds
    of problems and fix them promptly will help you save a lot of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a playbook called `remote.yaml` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can try to run the `remote.yaml` playbook against a non-existent FQDN, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the output will clearly inform us that the SSH service did not
    reply in time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also the possibility that we''ll receive a different error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the host did reply, but we don't have enough access to be able
    to SSH into it.
  prefs: []
  type: TYPE_NORMAL
- en: 'SSH connections usually fail for one of two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The SSH client is unable to establish a connection with the SSH server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SSH server refuses the credentials provided by the SSH client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Due to OpenSSH''s very high stability and backward compatibility, when the
    first issue occurs, it''s very probable that the IP address or the port is wrong,
    so the TCP connection isn''t feasible. Very rarely, this kind of error occurs
    in SSH-specific problems. Usually, double-checking the IP and the hostname (if
    it''s a DNS, check that it resolves to the right IP) solves the problem. To investigate
    this further, you can try performing an SSH connection from the same machine to
    check if there are problems. For instance, I would do this like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: I've taken the hostname from the error itself to ensure that I'm simulating
    exactly what Ansible is doing. I'm doing this to ensure that I can see all possible
    logging messages that SSH is able to give me to troubleshoot the problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second problem might be a little bit more complex to debug since it can
    happen for multiple reasons. One of those is that you are trying to connect to
    the wrong host and you don''t have the credentials for that machine. Another common
    case is that the username is wrong. To debug it, you can take the `user@host` address
    that is shown in the error (in my case, `fale@host.example.com`) and use the same
    command you used previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This should raise the same error that Ansible reported to you, but with much
    more details.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned how to solve host connection issues, let's learn how
    to pass working variables via the CLI.
  prefs: []
  type: TYPE_NORMAL
- en: Passing working variables via the CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One thing that can help during debugging, and definitely helps for code reusability,
    is passing variables to playbooks via the command line. Every time your application –
    either an Ansible playbook or any kind of application – receives an input from
    a third party (a human, in this case), it should ensure that the value is reasonable.
    An example of this would be to check that the variable has been set and therefore
    is not an empty string. This is a security golden rule, but should also be applied
    when the user is trusted since the user might mistype the variable name. The application
    should identify this and protect the whole system by protecting itself. Follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we want to have is a simple playbook that prints the content
    of a variable. Let''s create a playbook called `printvar.yaml` that contains the
    following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have an Ansible playbook that allows us to see if a variable has
    been set to what we were expecting, let''s run it with `variable` declared in
    the execution statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'By running this, we will receive an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Ansible allows variables to be set in various modes and with different priorities.
    More specifically, you can set them with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Command-line values (lowest priority)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Role defaults
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inventory files or script group `vars`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inventory `group_vars/all`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playbook `group_vars/all`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inventory `group_vars/*`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playbook `group_vars/*`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inventory files or script host vars
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inventory `host_vars/*`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playbook `host_vars/*`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Host facts/cached `set_facts`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Play `vars`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Play `vars_prompt`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Play `vars_files`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Role `vars` (defined in `role/vars/main.yml`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Block `vars` (only for tasks in block)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Task `vars` (only for the task)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`include_vars`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set_facts`/registered vars'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Role (and `include_role`) params
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`include` params'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extra vars (highest priority)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, the last option (and the highest priority of them all) is using
    `--extra-vars` in the execution command.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned how to pass working variables via CLI, let's learn how
    to limit the host's execution.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting the host's execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While testing a playbook, it might make sense to test on a restricted number
    of machines; for instance, just one. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the limitation of target hosts on Ansible, we will need a playbook.
    Create a playbook called `helloworld.yaml` that contains the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to create an inventory with at least two hosts. In my case, I
    created a file called `inventory` that contains the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the playbook in the usual way with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'By doing this, we will receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that the playbook was executed on all the machines in the inventory.
    If we just want to run it against `host3.example.com`, we will need to specify
    this on the command line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To prove that this works as expected, we can run it. By doing this, we will
    receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Before Ansible executes the playbook we mentioned in the command line, it analyzes
    the inventory to detect which targets are in scope and which are not. By using
    the `--limit` keyword, we can force Ansible to ignore all the hosts that are outside
    what is specified in the limit parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s possible to specify multiple hosts as a list or with patterns, so both
    of the following commands will execute the playbook against `host2.example.com`
    and `host3.example.com`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The limit will not override the inventory but will add restrictions to it.
    So, let''s say we limit to a host that is not part of the inventory, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we will receive the following error, and nothing will be done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have learned how to limit the host's execution, let's learn how
    to flush the code cache.
  prefs: []
  type: TYPE_NORMAL
- en: Flushing the code cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everywhere in IT, caches are used to speed up operations, and Ansible is not
    an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, caches are good, and for this reason, they are heavily used ubiquitously.
    However, they might create some problems if they cache a value they should not
    have cached or if they are not flushed, even if the value has changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flushing caches in Ansible is very straightforward, and it''s enough to run
    `ansible-playbook`, which we are already running, with the addition of the `--flush-cache`
    option, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Ansible uses Redis to save host variables, as well as execution variables. Sometimes,
    those variables might be left behind and influence the following executions. When
    Ansible finds a variable that should be set in the step it just started, Ansible
    might assume that the step has already been completed, and therefore pick up that
    old variable as if it has just been created. By using the `--flush-cache` option,
    we can avoid this since it will ensure that Ansible flushes the Redis cache during
    its execution.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned how to flush the code cache, let's learn how to check
    for bad syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for bad syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Defining whether a file has the right syntax or not is fairly easy for a machine,
    but might be more complex for humans. This does not mean that machines are able
    to fix the code for you, but they can quickly identify whether a problem is present
    or not. To use Ansible''s built-in syntax checker, we need a playbook with a syntax
    error. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `syntaxcheck.yaml` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use the `--syntax-check` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'By doing this, we will receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now proceed to fix the indentation problem on line 4:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'When we recheck the syntax, we will see that it now returns no errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: When the syntax check doesn't find any errors, the output will resemble the
    previous one, where it listed the files that were analyzed without listing any
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: Since Ansible knows all the supported options in all the supported modules,
    it can quickly read your code and validate whether the YAML you provided contains
    all the required fields and that it does not contain any unsupported fields.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the various options that Ansible provides
    so that you can look for problems in your Ansible code. More specifically, you
    learned how to use host facts to diagnose failures, how to include testing within
    a playbook, how to use check mode, how to solve host connection issues, how to
    pass variables from the CLI, how to limit the execution to a subset of hosts,
    how to flush the code cache, and how to check for bad syntax.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to get started with Ansible Tower.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'True or False: The debug module allows you to print the value of a variable
    or a fixed string during Ansible''s execution.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) True
  prefs: []
  type: TYPE_NORMAL
- en: B) False
  prefs: []
  type: TYPE_NORMAL
- en: Which keyword allows Ansible to force limit the host's execution?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) `--limit`
  prefs: []
  type: TYPE_NORMAL
- en: B) `--max`
  prefs: []
  type: TYPE_NORMAL
- en: C) `--restrict`
  prefs: []
  type: TYPE_NORMAL
- en: D) `--force`
  prefs: []
  type: TYPE_NORMAL
- en: E) `--except`
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible's official documentation about error handling can be found at [https://docs.ansible.com/ansible/latest/user_guide/playbooks_error_handling.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_error_handling.html).
  prefs: []
  type: TYPE_NORMAL
