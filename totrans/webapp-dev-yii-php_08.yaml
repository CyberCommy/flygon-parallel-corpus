- en: Chapter 8. Adding User Comments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the implementation of user management throughout the two previous chapters,
    our Trackstar application is really starting to take shape. The bulk of our primary
    application feature functionality is now behind us. We can now start to focus
    on some of the nice-to-have features. The first of these that we will tackle is
    the ability for users to leave comments on the project issues.
  prefs: []
  type: TYPE_NORMAL
- en: The ability for users to engage in dialog about project issues is an important
    part of what any issue tracking tool should provide. One way to achieve this is
    to allow users to leave comments directly on the issues. The comments will form
    a conversation about the issue and provide immediate as well as historical context
    to help track the full lifespan of any issue. We will also use comments to demonstrate
    the use of Yii widgets and how to establish a portlet model for delivering content
    to the user (for more on portlets, see [http://en.wikipedia.org/wiki/Portlet](http://en.wikipedia.org/wiki/Portlet)).
  prefs: []
  type: TYPE_NORMAL
- en: Feature planning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of this chapter is to implement feature functionality in the Trackstar
    application that allows users to leave and read comments on issues. When the user
    is viewing the detail of any project issue, they should be able to read all comments
    previously added as well as create a new comment on the issue. We also want to
    add a small fragment of content or portlet to the project listing page to display
    a list of recent comments left on all of the issues. This will be a nice way to
    provide a window into recent user activity and allow easy access to the latest
    issues that have active conversations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of high-level tasks we will need to complete in order
    to achieve these goals:'
  prefs: []
  type: TYPE_NORMAL
- en: Design and create a new database table to support comments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the Yii AR class associated with our new comments table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a form directly to the issue details page to allow users to submit comments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display a list of all comments associated with an issue directly on its details
    page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take advantage of Yii widgets to display a list of the most recent comments
    on the projects listing page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating the model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We first need to create a new table to house our comments. As you might expect,
    we will use a database migration to make this addition to our database structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `up()` and `down()` methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to implement this database change, we need to run the migration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now that our database table is in place, creating the associated AR class is
    a snap. We have seen this many times throughout the previous chapters. We know
    exactly how to do this. We simply use the Gii code creation tool's **Model Generator**
    command and create an AR class called `Comment`, based on our newly created table
    `tbl_comment`. If needed, refer back to [Chapter 4](ch04.html "Chapter 4. Project
    CRUD"), *Project CRUD* and [Chapter 5](ch05.html "Chapter 5. Managing Issues"),
    *Managing Issues*, for all the details on using this tool to create model classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'After using the Gii tool to create the model class for comments, you''ll notice
    that the code generated for us already has some relations defined. These are based
    on the foreign key relationships we defined on the `tbl_comments` table. The following
    is what was created for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We can see that we have a relationship that specifies a comment belongs to an
    issue. But we also need to define the one-to-many relationship between an issue
    and its comments. One issue can have many comments. This change needs to be made
    in the `Issue` model class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Had we created our comment model at the same time we created our Issue model,
    this relation would have been created for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to this, we will also add a relationship as a statistical query
    to easily retrieve the number of comments associated with a given issue. Here
    are the changes we make to the `Issue::relations()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This establishes the one-to-many relationship between an issue and comments.
    It also defines a statistical query to allow us to easily retrieve the total comment
    count for any given issue instance.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Statistical query**'
  prefs: []
  type: TYPE_NORMAL
- en: The `commentCount` relation defined previously is a new type of relation we
    have not seen before. In addition to relational queries, Yii also offers what
    is called a statistical or aggregational relationship. These are very useful in
    cases where there is a one-to-many (`HAS_MANY`) or many-to-many (`MANY_MANY`)
    relationship between objects. In such cases, we can define statistical relationships
    to allow us to easily get the total number of related objects. We have taken advantage
    of this in the previous relationship declarations to allow us to easily retrieve
    the total number of comments for any given issue instance. For more information
    on using statistical queries in Yii, refer to [http://www.yiiframework.com/doc/guide/1.1/en/database.arr#statistical-query](http://www.yiiframework.com/doc/guide/1.1/en/database.arr#statistical-query).
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to change our newly created `Comment` AR class to extend our custom
    `TrackStarActiveRecord` base class, so that it benefits from the logic we placed
    in the `beforeSave()` method. Simply alter the beginning of the class definition,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We'll make one last small change to the definitions in the `Comment::relations()`
    method. The relational attributes were named for us when the class was created.
    Let's change the one named `createUser`, to `author`, as this related user represents
    the author of the comment. This is just a semantic change, but it will help to
    make our code easier to read and understand. Change the definition from `'createUser'
    => array(self::BELONGS_TO, 'User', 'create_user_id'),` to `'author' => array(self::BELONGS_TO,
    'User', 'create_user_id')`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the comment CRUD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our AR model class in place, creating the CRUD scaffolding
    to manage the related entity is easy. Simply use the Gii code generation tool's
    **Crud Generator** command with the AR class name, `Comment`, as the argument.
    We have seen this many times in previous chapters, so we won't go through it in
    detail again here. If needed, refer back to [Chapter 4](ch04.html "Chapter 4. Project
    CRUD"), *Project CRUD* and [Chapter 5](ch05.html "Chapter 5. Managing Issues"),
    *Managing Issues*, for all the details on using the Gii tool to create CRUD scaffolding
    code. Although we will not immediately implement full CRUD operations for our
    comments, it is nice to have the scaffolding for the other operations in place.
  prefs: []
  type: TYPE_NORMAL
- en: 'After using Gii''s Crud Generator, and as long as we are logged in, we should
    now be able to view the autogenerated comment submission form via the following
    URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost/trackstar/index.php?r=comment/create`'
  prefs: []
  type: TYPE_NORMAL
- en: Altering the scaffolding to meet our requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have seen many times before, we often have to make adjustments to the
    autogenerated scaffolding code in order to meet the specific requirements of the
    application. For one, our autogenerated form for creating a new comment has an
    input field for every single column defined in the `tbl_comment` database table.
    We don''t actually want all of these fields to be part of the form. In fact, we
    want to greatly simplify this form to only have a single input field for the comment
    content. What''s more, we don''t want the user to access the form via the previously
    mentioned URL, but rather only by visiting an issue details page. The user will
    add comments on the same page where they are viewing the details of the issue.
    We want to build towards something like what is depicted in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Altering the scaffolding to meet our requirements](graphics/8727_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In order to achieve this, we are going to alter our `Issue` controller class
    to handle the post of the comment form as well as alter the issue details view
    to display the existing comments and new comment creation form. Also, since comments
    should only be created within the context of an issue, we'll add a new method
    to the issue model class to create new comments.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a comment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned, we are going to have the issue instance create its own comments.
    For this, we want to add a method to the `Issue` AR class. Here is that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This method ensures the proper setting of the comment issue ID before saving
    the new comment. That is, when an instance of `Issue` creates a new comment, it
    is understood that the comment belongs to that issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this method in place, we can now turn our focus to the issue controller
    class. Since we want the comment creation form to display from and post its data
    back to the `IssueController::actionView()` method, we will need to alter that
    method. We will also add a new protected method to handle the form post request.
    First, alter the `actionView()` method to be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the following protected method to create a new comment and handle
    the form post request for creating a new comment for this issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Our new protected method, `createComment()`, is responsible for handling the
    `POST` request submitted when a user is leaving a new comment on an issue. If
    the comment is successfully created, we set a flash message to display to the
    user and also do a page refresh so that our new comment will display. Of course,
    we still need to alter our view file to make all of this display to the user.
    The changes made to `IssueController::actionView()` are responsible for calling
    this new method and also for feeding the new comment instance to the view for
    display.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we need to alter our view. First we are going to create a new view file
    to render the display of our comments and the comment input form. We intend to
    display this view file within another view file. As such, we don't want to display
    all of the general page components, such as the header navigation and footer information,
    again. View files that are intended to be displayed within other view files, or
    without any extra decoration, are called **partial** views. You can then use the
    controller method `renderPartial()`, as opposed to the `render()` method. Using
    `renderPartial()` will only render the content contained within that view file
    and will not decorate the display with any other content. We will be discussing
    this in much more detail in [Chapter 10](ch10.html "Chapter 10. Making It Look
    Good"), *Making it Look Good*, when we discuss using layouts and decorating your
    view files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Yii uses a naming convention of a leading underscore (`_`) when creating partial
    view files. Since we''ll render this as a partial view, we''ll stick with the
    naming conventions and begin the filename with a leading underscore. Create a
    new file called `_comments.php` under the `protected/views/issue/` directory and
    add the following code to that file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This file accepts an array of comment instances as an input parameter and displays
    them one by one. We now need to alter the view file for the issue detail to use
    this new file. We do this by opening up `protected/views/issue/view.php` and adding
    the following to the end of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here we are taking advantage of the statistical query property, `commentCount`,
    which we added earlier to our `Issue` AR model class. This allows us to quickly
    determine if there are any comments available for the specific issue. If there
    are comments, it proceeds to render them using our `_comments.php` display view
    file. It then displays the input form that was created for us when we used the
    Gii Crud Generator functionality. It will also display the simple flash message
    set upon a successfully saved comment.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last change we need to make is to the comment input form itself. As we
    have seen many times in the past, the form created for us has an input field for
    every column defined in the underlying `tbl_comment` table. This is not what we
    want to display to the user. We want to make this a simple input form where the
    user only needs to submit the comment content. So, open up the view file that
    houses the input form, that is `protected/views/comment/_form.php`, and edit it
    to be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'With all of this in place, we can visit an issue listing page to see the comment
    form. For example, if we visit `http://localhost/trackstar/index.php?r=issue/view&id=111`,
    we see the following comment input form at the bottom of the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying the form](graphics/8727_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we attempt to submit the comment without specifying any content, we see
    the error as depicted in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying the form](graphics/8727_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And then, if we are logged in as `User One` and we submit the comment `My first
    test comment`, we are presented with the following display:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying the form](graphics/8727_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a recent comments widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the ability to leave comments on issues, we are going to turn
    our focus to the second goal of this chapter. We want to display a list of all
    of the recent comments that have been left on various issues across all of the
    projects. This will provide a nice snapshot of user communication activity within
    the application. We also want to build this small block of content in a manner
    that will allow it to be easily reused in various different locations throughout
    the site. This is very much in the style of myriad web portal applications across
    the internet. These small snippets of content are often referred to as **portlets**,
    and is why we referred to building portlet architecture at the beginning of this
    chapter. Again, you can refer to [http://en.wikipedia.org/wiki/Portlet](http://en.wikipedia.org/wiki/Portlet)
    for more information on this topic.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing CWidget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lucky for us, Yii is ready-made to help us achieve this architecture. Yii provides
    a component class called `CWidget`, which is perfect for achieving this type of
    architecture. A Yii **widget** is an instance of the `CWidget` class (or a child
    class thereof), and is a presentational component typically embedded in a view
    file to display self-contained, reusable user interface features. We are going
    to use a Yii widget to build a recent comments component and display it on the
    main project details page so we can see comment activity across all issues related
    to the project. To demonstrate the ease of re-use, we'll take it one step further
    and also display a list of recent comments across all projects on the projects
    listings page.
  prefs: []
  type: TYPE_NORMAL
- en: Named scopes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To begin creating our widget, we are going to first alter our `Comment` AR model
    class to return the most recently added comments. To do this, we are going to
    take advantage of another feature within Yii's AR model classes—named scopes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Named scopes** allow us to specify a named query, which provides an elegant
    way to define SQL `where` conditions when retrieving lists of AR objects. Named
    scopes are typically defined in the `CActiveRecord::scopes()` method as `name=>criteria`
    pairs. For example, if we want to define a named scope called `recent` that would
    return the five most recent comments; we could create the `Comment::scopes()`
    method as such:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can easily retrieve a list of recent comments, using the following
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also chain named scopes together. If we had defined another named scope,
    for example, `approved` (if our application were to have an approval process before
    comments would be displayed), we could get a list of the most recent approved
    comments, thus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can see that by chaining these together, we have a flexible and powerful
    way to retrieve our objects in specific contexts.
  prefs: []
  type: TYPE_NORMAL
- en: Named scopes must appear to the left of a `find` call (`find`, `findAll`, `findByPk`,
    and so on) and also can only be used in a class-level context. The named scope
    method call must be used along with `ClassName::model()`. See [http://www.yiiframework.com/doc/guide/1.1/en/database.ar#named-scopes](http://www.yiiframework.com/doc/guide/1.1/en/database.ar#named-scopes)
    for more information on named scopes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Named scopes can also be parameterized. In the earlier `recent` named scope
    for comments, we hardcoded the limit in the criteria to be `5`. However, we may
    want to be able to specify the limit number when we call the method. This is how
    we will set up our named scope for comments. To add parameters, we specify the
    named scope a bit differently. Rather than use the `scopes()` method to declare
    our scope, we define a new public method whose name is the same as the scope name.
    Add the following method to the `Comment` AR class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: One thing to note about this query condition is the use of `t` in the order
    value. This is to help in the event that this is used along with another related
    table that has the same column name. Obviously, when two tables that are being
    joined have columns with the same name, we have to make a distinction between
    the two in our query. For example, if we use this in the same query where we are
    retrieving `Issue` AR information, both `tbl_issue` and `tbl_comment` tables have
    the `create_time` column defined. We are trying to order by this column in the
    `tbl_comment` table and not the one defined in the issue table. In relational
    AR query in Yii, the alias name for the primary table is fixed as `t`, while the
    alias name for a relational table, by default, is the same as the corresponding
    relation name. So, in this case, we specify `t.create_time` to indicate that we
    want to use the primary table's column.
  prefs: []
  type: TYPE_NORMAL
- en: More on relational AR queries in Yii
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With this method in place, we could combine the named scope with an eager loading
    approach to also retrieve related `Issue` AR instances. For example, let''s say
    we want to get the last ten comments left on issues related to a project whose
    ID is `1`. We could use the following to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This query is new to us. We have not been using many of these options in our
    previous queries. Previously, we were using different approaches to execute relational
    queries:'
  prefs: []
  type: TYPE_NORMAL
- en: Load the AR instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access the relational properties defined in the `relations()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, if we wanted to query for all of the issues associated with, say,
    project ID #1, we would have been using something similar to the following two
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This familiar approach uses what is referred to as **lazy loading**. When we
    first create the project instance, the query does not return all of the associated
    issues. It only retrieves the associated issues upon a subsequent, explicit request
    for them, that is when `$project->issues` is executed. This is referred to as
    "lazy" because it waits to load the issues until they are requested at a later
    time.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is very convenient and can also be very efficient, especially
    in those cases where the associated issues are not required. However, in other
    circumstances, this approach can be somewhat inefficient. For example, if we wanted
    to retrieve the issue information across *N* projects, then using this lazy approach
    would involve executing *N* join queries. Depending on how large *N* is, this
    could be very inefficient. In these situations, we have another option. We can
    use what is called **eager loading**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The eager loading approach retrieves the related AR instances at the same time
    as the main AR instances are requested. This is accomplished by using the `with()`
    method in concert with either the `find()` or `findAll()` methods for AR query.
    Sticking with our project example, we could use eager loading to retrieve all
    issues for all projects by executing the following single line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, in this case, every project AR instance in the `$projects` array already
    has its associated `issues` property populated with an array of `Issue` AR instances.
    This result has been achieved by using just a single join query.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s look back at our example of retrieving the last ten comments for
    a specific project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using the eager loading approach to retrieve the issues along with the
    comments, but this one is slightly more complex. This query specifies a single
    join between the `tbl_comment` and `tbl_issue` tables. This relational AR query
    would basically execute something similar to the following SQL statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Armed with the knowledge about the benefits of lazy loading versus eager loading
    in Yii, we should make an adjustment to how the issue model is loaded within the
    `IssueController::actionView()` method. Since we have altered the issues' detail
    view to display our comments, including the author of the comment, we know it
    will be more efficient to use the eager loading approach to load our comments
    along with their respective authors when we make the call to `IssueController::loadModel()`.
    To do this, we can add an additional parameter as a simple input flag to indicate
    whether or not we want to load the comments as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alter the `IssueController::loadModel()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three places where the `loadModel()` method is called in the `IssueController`
    method: `actionView`, `actionUpdate`, and `actionDelete`. We only need the associated
    comments when we are viewing the issue details. So, we have made the default to
    not retrieve the associated comments. We just need to alter the `actionView()`
    method to add `true` to the `loadModel()` call.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, we will load the issue along with all of its associated
    comments, and for each comment, we'll load the associated author information,
    all with just one database call.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the widget
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are now ready to create our new widget to make use of all the previously
    mentioned changes to display our recent comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we previously mentioned, a widget in Yii is a class that extends from the
    framework class, `CWidget`, or one of its child classes. We''ll add our new widget
    to the `protected/components/` directory, as the contents of this directory are
    already specified in the main configuration file to be autoloaded within the application.
    This way, we won''t have to explicitly import the class every time we wish to
    use it. We''ll call our widget `RecentComments` and add a `.php` file of the same
    name to this directory. Add the following class definition to this newly created
    `RecentComments.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The primary work involved when creating a new widget is to override the `init()`
    and `run()` methods of the base class. The `init()` method initializes the widget
    and is called after its properties have been initialized. The `run()` method executes
    the widget. In this case, we simply initialize the widget by requesting recent
    comments based on the `$displayLimit` and `$projectId` properties, using the query
    we discussed previously. The execution of the widget itself simply renders its
    associated view file, which we have yet to create. View files for widgets, by
    convention, are placed in a `views/` directory within the same directory where
    the widget resides and are named the same as the widget, except starting with
    a lowercase letter. Sticking with this convention, create a new file whose fully
    qualified path is `protected/components/views/recentCommentsWidget.php`. Once
    created, add the following to that file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This calls the `RecentCommentsWidget::getData()` method, which returns an array
    of comments. It then iterates over each of them, displaying who added the comment
    and the associated issue on which the comment was left.
  prefs: []
  type: TYPE_NORMAL
- en: In order to see the results, we need to embed this widget into an existing controller
    view file. As previously mentioned, we want to use this widget on the projects
    listing page to display all recent comments across all projects, and also on a
    specific project details page to display the recent comments for just that specific
    project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the projects listing page. The view file responsible for
    displaying that content is `protected/views/project/index.php`. Open up that file
    and add the following at the bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If we view the projects listing page `http://localhost/trackstar/index.php?r=project`
    now, we see something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the widget](graphics/8727_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have now embedded our new recent comments data within the page, simply by
    calling the widget. This is nice, but we can take our little widget one step further
    to have it display in a consistent manner with all other potential *portlets*
    in the application. We can do this by taking advantage of another class provided
    to us by Yii, `CPortlet`.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing CPortlet
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`CPortlet` is part of Zii, the official extension class library that comes
    packaged with Yii. It provides a nice base class for all portlet-style widgets.
    It will allow us to render a nice title as well as a consistent HTML markup, so
    that all portlets across the application can be easily styled in a similar manner.
    Once we have a widget that renders content, such as our `RecentCommentsWidget`,
    we can simply use the rendered content of our widget as the content for `CPortlet`,
    which itself is a widget, as it also extends from `CWidget`. We can do this by
    placing our call to the `RecentComments` widget between a `beginWidget()` and
    an `endWiget()` call for `CPortlet`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `CPortlet` provides a title property, we set it to be something meaningful
    for our portlet. We then use the rendered content of the `RecentComments` widget
    to provide the content for the portlet widget. The end result of this is depicted
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing CPortlet](graphics/8727_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is not a huge change from what we had previously, but we have now placed
    our content into a consistent container that is already being used throughout
    the site. Note the similarity between the right-hand column menu content block
    and our newly created, recent comments content block. I am sure it will come as
    no surprise to you that this right-hand column menu block is also displayed within
    a `CPortlet` container. Taking a peek in `protected/views/layouts/column2.php`,
    which is a file that the `yiic webapp` command autogenerated for us when we initially
    created the application, reveals the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: So, it seems that the application has been taking advantage of portlets all
    along!
  prefs: []
  type: TYPE_NORMAL
- en: Adding our widget to another page
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let's also add our portlet to the project details page and restrict the comments
    to just those associated with the specific project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following at the end of the `protected/views/project/view.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This is basically the same thing we added to the projects listing page, except
    we are initializing the widget's `$projectId` property by adding an array of `name=>value`
    pairs to the call.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we visit a specific project details page now, we should see something similar
    to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding our widget to another page](graphics/8727_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This preceding screenshot shows the details page for **Project #1**, which
    has one associated issue with just one comment on that issue, as depicted in the
    screenshot. You may need to add a few issues and comments on those issues in order
    to generate a similar display. We now have a way to display recent comments with
    a few different configurable parameters anywhere throughout the site, in a consistent
    and easily maintainable manner.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this chapter, we have started to flush out our Trackstar application with
    the functionality that has come to be expected of most user-based web applications
    today. The ability for users to communicate with each other within the application
    is an essential part of a successful issue management system.
  prefs: []
  type: TYPE_NORMAL
- en: As we created this essential feature, we were able to look deeper into how to
    write relational AR queries. We were also introduced to content components called
    widgets and portlets. This introduced us to an approach to developing small content
    blocks and being able to use them anywhere throughout the application. This approach
    greatly increases re-use, consistency, and ease of maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll build upon the recent comments widget created here
    and expose the content generated by our widget as an RSS feed to allow users to
    track application or project activity without having to visit the application.
  prefs: []
  type: TYPE_NORMAL
