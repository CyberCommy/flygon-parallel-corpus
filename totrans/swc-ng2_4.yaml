- en: Chapter 4. Getting Started with Angular 2 Components and Directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By this point, you're already familiar with the core building blocks that Angular
    2 provides for the development of single-page applications and the relations between
    them. However, we've touched only the surface by introducing the general idea
    behind Angular's concepts and the basic syntax used for their definition. In this
    chapter, we'll take a deep dive into Angular 2's components and directives.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following sections, we will cover these topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Enforced separation of concerns of the building blocks that Angular 2 provides
    for developing applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The appropriate use of directives or components when interacting with the DOM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built-in directives and developing custom ones.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An in-depth look at components and their templates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content projection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View children versus content children.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The component's life cycle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using template references.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Angular's change detection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Hello world! application in Angular 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s build our first "Hello world!" app in Angular 2! In order to get
    everything up and running as easy and quickly as possible, for our first application,
    we will use the ECMAScript 5 syntax with the transpiled bundle of Angular 2\.
    First, create the `index.html` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding HTML file defines the basic structure of our page. Just before
    closing the `body` tag, we have references to four script files: the `polyfills`
    required by the framework (including ES2015 `shim`, `zone.js`, and others), `RxJS`,
    the ES5 bundle of Angular 2, and the file that contains the application we''re
    going to build.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`RxJS` is used by Angular''s core in order to allow us to empower the reactive
    programming paradigm in our applications. In the following content, we will take
    only a shallow look at how we can take advantage of observables. For further information,
    you can visit the `RxJS` GitHub repository at [https://github.com/Reactive-Extensions/RxJS](https://github.com/Reactive-Extensions/RxJS).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same directory where your `index.html` resides, create a file called
    `app.js` and enter the following content inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we define a component called `App` with an `app`
    selector. This selector will match all the app elements inside our templates that
    are in the scope of the application. The component has the following template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This syntax should already be familiar to you from AngularJS 1.x. When compiled
    in the context of the given component, the preceding snippet will interpolate
    the template with the result of the expression inside the curly brackets. In our
    case, the expression is simply the `target` variable.
  prefs: []
  type: TYPE_NORMAL
- en: To `Class`, we pass an object literal, which has a single method called `constructor`.
    This DSL provides an alternative way to define classes in ECMAScript 5\. In the
    body of the `constructor` function, we add a property called `target` with a value
    of the `"world"` string. In the last line of the snippet, we invoke the `bootstrap`
    method in order to initialize our application with `App` as a root component.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `bootstrap` is located under `ng.platform.browser`. This is due to
    the fact that the framework is built for different platforms in mind, such as
    a browser, NativeScript, and so on. By placing the `bootstrap` methods used by
    the different platforms under a separate namespace, Angular 2 can implement different
    logic to initialize the application and also include different sets of providers
    and directives that are platform specific.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you open `index.html` with your browser, you should see some errors,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Hello world! application in Angular 2](../images/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This happened because we missed something quite important. We didn''t use the
    root component anywhere inside `index.html`. In order to finish the application,
    add the following HTML element after the open tag of the body element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can refresh your browser to see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Hello world! application in Angular 2](../images/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Using TypeScript**'
  prefs: []
  type: TYPE_NORMAL
- en: Although we already have an Angular 2 application running, we can do much better!
    We didn't use any package manager or module loader. We spent all of [Chapter 3](part0027_split_000.html#PNV61-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 3. TypeScript Crash Course"), *TypeScript Crash Course*, talking about
    TypeScript; however, we didn't write a single line of it in the preceding application.
    Although it is not required that you use TypeScript with Angular 2, it's much
    convenient to take advantage of all the bonuses that static typing provides.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The core team of Angular developed a brand new CLI tool for Angular 2, which
    allows us to `bootstrap` our applications with a few commands. Although we are
    going to introduce it in the last chapter, by then, in order to boost our learning
    experience, we are going to use the code located at [https://github.com/mgechev/switching-to-angular2](https://github.com/mgechev/switching-to-angular2).
    It includes all the examples in this book and allows us to quickly `bootstrap`
    our Angular 2 application (you can know more on how to quickly start developing
    web applications with Angular 2 in [Chapter 5](part0056_split_000.html#1LCVG1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 5. Dependency Injection in Angular 2"), *Dependency Injection in Angular
    2.*). It has all the required dependencies declared in `package.json`, the definition
    of basic gulp tasks, such as the development server, the transpilation of your
    TypeScript code to ECMAScript 5, live-reload, and so on. Our upcoming examples
    are going to be based on it.
  prefs: []
  type: TYPE_NORMAL
- en: In order to set up the `switching-to-angular2` project, you'll need Git, Node.js
    v5.x.x, and npm up and running on your computer. If you have a different version
    of the Node.js installed, I recommend that you take a look at nvm (the Node.js
    version manager, which is available at [https://www.npmjs.com/package/nvm](https://www.npmjs.com/package/nvm))
    or n ([https://www.npmjs.com/package/n](https://www.npmjs.com/package/n)). Using
    these tools, you'll be able to have multiple versions of Node.js on your machine
    and switch between them with a single command via the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Installing our project repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by setting up the `switching-to-angular2` project. Open your terminal
    and enter the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first line will clone the `switching-to-angular2` project into a directory
    called `switching-to-angular2`.
  prefs: []
  type: TYPE_NORMAL
- en: The last step before being able to run the seed project is to install all the
    required dependencies using npm. This step may take a while depending on your
    Internet connection, so be patient and do not interrupt it. If you encounter any
    problems, do not hesitate to raise the issues at [https://github.com/mgechev/switching-to-angular2/issues](https://github.com/mgechev/switching-to-angular2/issues).
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step left is to start the development server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When the process of the transpilation is completed, your browser will automatically
    open with this URL: `http://localhost:5555/dist/dev`. You should now see a view
    similar to what is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing our project repository](../images/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Playing with Angular 2 and TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s play around with the files we already have! Navigate to the `app/ch4/ts/hello-world`
    directory inside `switching-to-angular2`. Then, open `app.ts` and replace its
    content with the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the code line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Initially, we import the `@Component` decorator from the `angular2/core` module
    and the `bootstrap` function from `angular2/platform/browser`. Later, we use `@Component`
    to decorate the `App` class. To the `@Component` decorator, we pass almost the
    same object literal that we used in the ECMAScript 5 version of the application,
    and this way, we define the CSS selector for the component.
  prefs: []
  type: TYPE_NORMAL
- en: As a next step, we define the view of the component. However, note that in this
    case, we use `templateUrl` instead of simply inlining the component's template.
  prefs: []
  type: TYPE_NORMAL
- en: Open `app.html` and replace the file's content with `<h1>Hello {{target}}!</h1>`.
    The content of `app.html` should be the same as the inlined template we used previously.
    Since we can use a template by both inlining it (with `template`) and setting
    its URL (`templateUrl`), the component's API is quite similar to the AngularJS
    1.x directives API.
  prefs: []
  type: TYPE_NORMAL
- en: In the last line of the snippet, we `bootstrap` the application by providing
    the root component.
  prefs: []
  type: TYPE_NORMAL
- en: Digging into the index
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at `index.html` in order to get a sense of what goes
    on when we start the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that inside the body of the page, we use the `app` element with the content
    of the text node, `"Loading…"`, inside. The `"Loading…"` label will be visible
    until the application gets bootstrapped and the main component gets rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are template placeholders `<%= INIT %> and <-- inject:js…` that inject
    content that is specific to individual demos. They are not Angular specific but
    instead aim to prevent code duplications in the code samples attached to the book
    because of the shared structure between them. In order to see how this specific
    HTML file has been transformed, open `/dist/dev/ch4/ts/hello-world/index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Using Angular 2 directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already built our simple "Hello world!" app. Now, let's start building something
    that is closer to a real-life application. By the end of this section, we'll have
    a simple application that lists a number of items we need to do and greets us
    at the header of the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by developing our `app` component. The two modifications from
    the previous example that we need to make are to rename the `target` property
    to `name` and add a list of `todos` to the component''s controller definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The only thing left is to change the template in order to consume the provided
    data. We're already familiar with the `ng-repeat` directive from AngularJS 1.x.
    It allows us to loop a list of items using a microsyntax, which is later interpreted
    by AngularJS 1.x. However, the directive doesn't carry enough semantics, so it
    is hard to build tools that perform static code analysis and help us improve our
    development experience. Since the `ng-repeat` directive is quite useful, Angular
    2 took the idea and improved it further in order to allow more sophisticated tooling
    by introducing further semantics on top of it. It allows better static code analysis
    to be performed by IDEs and text editors. Such support will prevent us from making
    typos in the code we write and allow us to have smoother development experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `app.html`, add the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `template` element is a place where we can hold markup and make sure that
    it won't be rendered by the browser. This is quite useful if we need to embed
    the templates of our application directly into the markup of the page and let
    the template engine we're using to process them later. In the current example,
    this means that if the Angular 2 DOM compiler doesn't process the DOM tree, all
    we're going to see on the screen are the `h1`, `p` elements and the `ul` element
    without any list items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, after you refresh your browser, you should see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Angular 2 directives](../images/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So far, so good! The only new things left in the preceding snippets are the
    attributes of the `template` element that we're not familiar with, such as `ngFor`,
    `var-todo`, and `[ngForOf]`. Let's take a look at them.
  prefs: []
  type: TYPE_NORMAL
- en: The ngFor directive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ngFor` directive is a directive that allows us to loop over a collection
    of items and does exactly what `ng-repeat` does in AngularJS 1.x, but it brings
    some extra semantics. Note that the `ngForOf` attribute is surrounded by brackets.
    At first, these brackets might seem like invalid HTML. However, according to the
    HTML specification, their use is permitted in attribute names. The only thing
    the W3C validator is going to complain about is the fact that the `template` element
    doesn't own such attributes; however, browsers won't have problems processing
    the markup.
  prefs: []
  type: TYPE_NORMAL
- en: The semantics behind these brackets is that the value of the attribute surrounded
    by them is an expression, which needs to be evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: Improved semantics of the directives syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 1](part0015_split_000.html#E9OE1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 1. Getting Started with Angular 2"), *Getting Started with Angular 2*,
    we mentioned the opportunity for improved tooling in Angular 2\. A big issue in
    AngularJS 1.x is the different ways in which we can use directives. This requires
    an understanding of the attribute values, which can be literals, expressions,
    callbacks, or a microsyntax. Angular 2 eliminates this problem by introducing
    a few simple conventions that are built into the framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '`propertyName="value"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[propertyName]="expression"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(eventName)="handler()"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first line, the `propertyName` attribute accepts a string literal as
    a value. Angular will not process the attribute's value any further; it will use
    it the way it is set in the template.
  prefs: []
  type: TYPE_NORMAL
- en: The second syntax, `[propertyName]="expression"`, gives a hint to Angular 2
    that the value of the attributes should be handled as an expression. When Angular
    2 finds an attribute surrounded by brackets, it will interpret the expression
    in the context of the component associated to the template. In short, if we want
    to set a non-string value or result of an expression as value of given property
    we need to use this syntax.
  prefs: []
  type: TYPE_NORMAL
- en: The last example shows how we can bind to events. The semantics behind `(eventName)="handler()"`
    is that we want to handle all events called `eventName` that are triggered by
    the given component with the `handler()` expression.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to discuss more examples later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Angular provides alternative canonical syntax, which allows us to define the
    bindings of the elements without using brackets. For instance, the property binding
    can be expressed using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'It can also be expressed using this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can express the event bindings with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'They can also be expressed using this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Declaring variables inside a template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last thing left from the preceding template is the `var-todo` attribute.
    What we are telling Angular using this syntax is that we want to declare a new
    variable called `todo` and bind it to the individual items from the collection
    we get from the evaluation of the expression set as a value of `[ngForOf]`.
  prefs: []
  type: TYPE_NORMAL
- en: Using syntax sugar in templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the template syntax is awesome and provides much more meaning of the
    code to the IDEs or text editors we use, it is quite verbose. Angular 2 provides
    an alternative syntax, which will be desugared to the one shown in the preceding.
    Instead of using `var-todo`, for example, we can use `#todo`, which has the same
    semantics.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few Angular 2 directives that require the usage of a template element,
    for example, `ngForOf`, `ngIf`, and `ngSwitch`. Since such directives are used
    often, there''s an alternative syntax for them. Instead of typing down the entire
    template element explicitly, we can simply prefix the directive with `*`. This
    will allow us to turn our `ngForOf` directive syntax usage into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Later, this template will be desugared by Angular 2 to the more verbose syntax
    described earlier. Since the less verbose syntax is easier to read and write,
    its use is considered as best practice.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `*` character allows you to remove the `template` element and put the directive
    directly on the root of the `template` element (in the preceding example, the
    list item, `li`).
  prefs: []
  type: TYPE_NORMAL
- en: Defining Angular 2 directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've built a simple Angular 2 component, let's continue our journey
    by understanding the Angular 2 directives.
  prefs: []
  type: TYPE_NORMAL
- en: Using Angular 2 directives, we can apply different behavioral or structural
    changes over the DOM. In this example, we're going to build a simple tooltip directive.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to components, directives do not have views and templates, respectively.
    Another core difference between these two concepts is that the given HTML element
    may have only a single component but multiple directives on it. In other words,
    directives augment the elements compared to components that are the actual elements
    in our views.
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular''s core team''s recommendation is to use directives as attributes,
    prefixed with a namespace. Keeping this in mind, we will use the tooltip directive
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we use the tooltip directive over the `div` element.
    As a namespace, its selector uses the `sa` string.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For simplicity, in the rest of the book we may not prefix all the selectors
    of our components and directives. However, for production applications following
    best practices is essential. You can find an Angular 2 style guide which points
    out such practices at [https://github.com/mgechev/angular2-style-guide](https://github.com/mgechev/angular2-style-guide).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before implementing our tooltip, we need to import a couple of things from
    `angular2/core`. Open a new TypeScript file called `app.ts` and enter the following
    content; we''ll fill the placeholders later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding line, we import the following definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ElementRef`: This allows us to inject the element reference (we''re not limited
    to the DOM only) to the host element. In the sample usage of the preceding tooltip,
    we get an Angular wrapper of the `div` element, which holds the tooltip attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Directive`: This decorator allows us to add the metadata required for the
    new directives we define.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HostListener(eventname)`: This is a method decorator that accepts an event
    name as an argument. During initialization of the directive, Angular 2 will add
    the decorated method as an event handler for the `eventname` event of the host
    element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at our implementation; this is what the directive''s definition
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Setting the directive's inputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding example, we declare a directive with the `saTooltip` selector.
    Note that Angular''s HTML compiler is case sensitive, which means that it will
    distinguish the `[satooltip]` and `[saTooltip]` selectors. Later, we will declare
    the input of the directive using the `@Input` decorator over the `saTooltip` property.
    The semantics behind this code is: declare a property called `saTooltip` and bind
    it to the value of the result that we got from the evaluation of the expression
    passed to the `saTooltip` attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: The `@Input` decorator accepts a single argument—the name of the attribute we
    want to bind to. In case we don't pass an argument, Angular will create a binding
    between the attribute with the same name as the property itself. We will explain
    the concept of input and output in detail later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the directive's constructor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The constructor declares two private properties: `el` of the `ElementRef` type
    and `overlay` of the `Overlay` type. The `Overlay` class implements logic to manage
    the tooltips'' overlays and is going to be injected using the DI mechanism of
    Angular. In order to declare it as available for injection, we need to declare
    the top-level component in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We're going to take a look at the dependency injection mechanism of Angular
    2 in the next chapter, where we will explain the way in which we can declare the
    dependencies of our services, directives, and components.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the `Overlay` class is not important for the purpose
    of this chapter. However, if you''re interested in it, you can find the implementation
    in: `ch4/ts/tooltip/app.ts`.'
  prefs: []
  type: TYPE_NORMAL
- en: Better encapsulation of directives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to make the tooltip directive available to the Angular''s compiler,
    we need to explicitly declare where we intend to use it. For instance, take a
    look at the `App` class at `ch4/ts/tooltip/app.ts`; there, you can notice the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: To the `@Component` decorator, we pass an object literal that has the `directives`
    property. This property contains a list of all the directives that should be available
    in the entire component subtree with the root of the given component.
  prefs: []
  type: TYPE_NORMAL
- en: At first, it might seem annoying that you should explicitly declare all the
    directives that your component uses; however, this enforces better encapsulation.
    In AngularJS 1.x, all directives are in a global namespace. This means that all
    the directives defined in the application are accessible in all the templates.
    This brings in some problems, for example, name collision. In order to deal with
    this issue, we've introduced naming conventions, for instance, the "`ng-`" prefix
    of all the directives defined by AngularJS 1.x and "`ui-`" for all directives
    coming with the Angular UI.
  prefs: []
  type: TYPE_NORMAL
- en: This way, by explicitly declaring all the directives, the given component uses
    in Angular 2, we create a namespace specific to the individual components' subtrees
    (that is, the directives will be visible to the given root component and all of
    its successor components). Preventing name collisions is not the only benefit
    we get; it also helps us with better semantics of the code that we produce, since
    we're always aware of the directives accessible by the given component. We can
    find all the accessible directives of the given component by following the path
    from the component to the top of the component tree and taking the union of all
    the values of `directives` arrays set in the `@Component` decorators. Given that
    components are extended from directives, we need to explicitly declare all the
    used components as well.
  prefs: []
  type: TYPE_NORMAL
- en: Since Angular 2 defines a set of built-in directives, the `bootstrap` method
    passes them in a similar way in order to make them available in the entire application
    in order to prevent us from code duplications. This list of predefined directives
    includes `NgClass`, `NgFor`, `NgIf`, `NgStyle`, `NgSwitch`, `NgSwitchWhen`, and
    `NgSwitchDefault`. Their names are quite self-explanatory; we'll take a look at
    how we can use some of them later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Using Angular 2's built-in directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's build a simple to-do application in order to demonstrate the syntax
    to define components further!
  prefs: []
  type: TYPE_NORMAL
- en: 'Our to-do items will have the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start by importing everything we are going to need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s declare the component and the metadata associated with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, we specify that the selector of the `Todo` component will be the `todo-app`
    element. Later, we add the template URL, which points to the `app.html` file.
    After that, we use the `styles` property; this is the first time we encounter
    it. As we can guess from its name, it is used to set the styles of the component.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the component's view encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we know, Angular 2 is inspired from Web Components, whose core feature is
    the shadow DOM. The shadow DOM allows us to encapsulate the styles of our Web
    Components without allowing them to leak outside the component's scope. Angular
    2 provides this feature. If we want Angular's renderer to use the shadow DOM,
    we can use `ViewEncapsulation.Native`. However, the shadow DOM is not supported
    by all browsers; if we want to have the same level of encapsulation without using
    the shadow DOM, we can use `ViewEncapsulation.Emulated`. If we don't want to have
    any encapsulation at all, we can use `ViewEncapsulation.None`. By default, the
    renderer uses encapsulation of the type `Emulated`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the component's controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s continue with the implementation of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here is part of the implementation of the controller associated with the template
    of the `Todo` application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the class declaration, we initialized the `todos` property to an array
    with two `todo` items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s update the template and render these items! Here''s how this is
    done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding template, we looped all the `todo` items inside the `todos`
    property of the controller. For each `todo` item, we created a checkbox that can
    `toggle` the item''s completion status; we also rendered the `todo` item''s label
    with the interpolation directive. Here, we can notice the syntax that was explained
    earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: We bind to the change event of the checkbox using `(change)="statement"`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We bind to the property of the `todo` item using `[checked]="expr"`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to have a line across the completed `todo` items, we bind to the `class.completed`
    property of the element. Since we want to apply the `completed` class to all the
    completed to-do items, we use `[class.completed]="todo.completed"`. This way,
    we declare that we want to apply the `completed` class depending on the value
    of the `todo.completed` expression. Here is how our application looks now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the component''s controllers](../images/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Similar to the class binding syntax, Angular allows us to bind to the element''s
    styles and attributes. For instance, we can bind to the `td` element''s `colspan`
    attribute using the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same way, we can bind to any `style` property using this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Handling user actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, so good! Now, let''s implement the `toggleCompletion` method. This
    method accepts the index of the to-do item as a single argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In `toggleCompletion`, we simply toggle the `completed` Boolean value associated
    with the current to-do item, which is specified by the index passed as an argument
    to the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add a text input to add the new to-do items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The input here defines a new identifier called `newtodo`. We can reference the
    input using the `newtodo` identifier inside the template. Once the user clicks
    on the button, the `addTodo` method defined in the controller will be invoked
    with the value of the `newtodo` input as an argument. Inside the statement that
    is passed to the `(click)` attribute, we also reset the value of the `newtodo`
    input by setting it to the empty string.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that directly manipulating DOM elements is not considered as best practice
    since it will prevent our component from running properly outside the browser
    environment. We will explain how we can migrate this application to Web Workers
    in [Chapter 8](part0075_split_000.html#27GQ62-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 8. Development Experience and Server-Side Rendering"), *Development Experience
    and Server-Side Rendering*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s define the `addTodo` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Inside it, we create a new to-do item using the object literal syntax.
  prefs: []
  type: TYPE_NORMAL
- en: The only thing left out of our application is to implement removal of existing
    to-do items. Since it is quite similar to the functionality used to toggle the
    completion of the to-do items, I'll leave its implementation as a simple exercise
    for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: Using a directives' inputs and outputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By refactoring our `todo` application, we are going to demonstrate how we can
    take advantage of the directives'' inputs and outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using a directives'' inputs and outputs](../images/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can think of the inputs as properties (or even arguments) that the given
    directive accepts. The outputs could be considered as events that it triggers.
    When we use a directive provided by a third-party library, mostly we care about
    is its inputs and outputs because they define its API.
  prefs: []
  type: TYPE_NORMAL
- en: Inputs refers to values that parameterize the directive's behavior and/or view.
    On the other hand, outputs refers to events that the directive fires when something
    special happens.
  prefs: []
  type: TYPE_NORMAL
- en: Finding out directives' inputs and outputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s divide our monolithic to-do application into separate components
    that communicate with each other. In the following screenshot, you can see the
    individual components that when composed together implement the functionality
    of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Finding out directives'' inputs and outputs](../images/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The outer rectangle represents the entire `Todo` application. The first nested
    rectangle contains the component that is responsible for entering labels of the
    new to-do items, and the one below it lists the individual items that are stored
    in the root component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having said this, we can define these three components as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TodoApp`: Responsible for maintaining the list of to-do items (adding new
    items and toggling the completion status).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InputBox`: Responsible for entering the label of the new to-do item. It has
    the following inputs and outputs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Input`: A placeholder for the textbox and a label for the submit button.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Output`: It should emit the content of the input once the submit button is
    clicked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TodoList`: This is responsible for rendering the individual to-do items. It
    has the following inputs and outputs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Input`: The list of to-do items.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Output`: Once the completion status of any of the to-do items changes, the
    component should emit the change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's begin with the implementation!
  prefs: []
  type: TYPE_NORMAL
- en: Defining the component's inputs and outputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s use a bottom-up approach and start with the `InputBox` component. Before
    that, we need a couple of imports from Angular''s `angular2/core` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we imported the `@Component`, `@Input`, and `@Output`
    decorators and the `EventEmitter` class. As their names state, `@Input` and `@Output`
    are used for declaring the directive's inputs and outputs. `EventEmitter` is a
    generic class (that is, accepting type parameter) which combined with the `@Output`
    decorator helps us emit outputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the next step, let''s take a look at the `InputBox` component''s declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that in the template, we declare a text input called `todoInput` and set
    its placeholder property to the value that we got from the evaluation of the `inputPlaceholder`
    expression. The value of the expression is the value of the `inputPlaceholder`
    property defined in the component''s controller. This is the first input that
    we need to define:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we declare the other input of the `buttonLabel` component, which
    we use as a value of the label of the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding template, we bind the click event of the button to this expression:
    `emitText(todoInput.value); todoInput.value = '''';`. The `emitText` method is
    supposed to be defined in the component''s controller; once it is invoked, it
    should emit the value of the text input. Here is how we can implement this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Initially, we declare an output called `inputText`. As its value, we set a new
    instance of the type `EventEmitter<string>` that we create.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that all the outputs of all the components need to be instances of `EventEmitter`.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `emitText` method, we invoke the emit method of the `inputText` instance
    with the argument of the value of the text input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s define the `TodoList` component in the same fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Since the value of the object literal passed to the `@Component` decorator is
    not essential for the purpose of this section, we've omitted it. The complete
    implementation of this example could be found at `ch4/ts/inputs-outputs/app.ts`.
    Let's take a look at the body of the `TodoList` class. Similarly, for the `InputBox`
    component, we define the `todos` input. We also define the `toggle` output by
    declaring the `toggle` property, setting its value to a new instance of the type
    `EventEmitter<Todo>` and decorating it with the `@Output` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: Passing inputs and consuming the outputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's combine the components we defined in the preceding section and implement
    our complete application!
  prefs: []
  type: TYPE_NORMAL
- en: 'The last component we need to take a look at is `TodoApp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Initially, we define the `TodoApp` class and decorate it with the `@Component`
    decorator. Note that in the list of the directives used by the component, we include
    `InputBox` and `TodoList`. The magic of how these components collaborate together
    happens in the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we use the `InputBox` component and pass values to the inputs: `inputPlaceholder`
    and `buttonLabel`. Note that just like we saw earlier, if we want to pass an expression
    as a value to any of these inputs, we need to surround them with brackets (that
    is, `[inputPlaceholder]="expression"`). In this case, the expression will be evaluated
    in the context of the component that owns the template, and it will be passed
    as an input to the component that owns the given property.'
  prefs: []
  type: TYPE_NORMAL
- en: Right after we pass the value for the `buttonLabel` input, we consume the `inputText`
    output by setting the value of the `(inputText)` attribute to the `addTodo($event)`
    expression. The value of `$event` will equal the value we passed to the `emit`
    method of the `inputText` object inside the `emitText` method of `InputBox` (in
    case we bind to a native event, the value of the event object will be the native
    event object itself).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same way, we pass the input of the `TodoList` component and handle its
    toggle output. Now, let''s define the logic behind the `TodoApp` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the `addTodo` method, we simply push a new to-do item to the `todos` array.
    The implementation of `toggleCompletion` is even simpler—we toggle the value of
    the completed flag that is passed as an argument to the to-do item. Now, we are
    familiar with the basics of the components' inputs and outputs!
  prefs: []
  type: TYPE_NORMAL
- en: Event bubbling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Angular, we have the same bubbling behavior we have in the DOM. For instance,
    if we have the following template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The declaration of `input-box` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Once the user clicks on the button defined within the template of the `input-box`
    component, the `handleClick($event)` expression will be evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: Further, the `target` property of the first argument of `handleClick` will be
    the button itself, but the `currentTarget` property will be the `input-box` element.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that unlike native events, ones triggered by `EventEmitter` will not bubble.
  prefs: []
  type: TYPE_NORMAL
- en: Renaming the inputs and outputs of a directive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we will explore how we can rename the directives'' inputs and outputs!
    Let''s suppose that we have the following definition of the `TodoList` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the component is called `toggle`; the method that handles changes
    in the checkboxes responsible for toggling completion of the individual to-do
    items is called `toggle` as well. This code will not be compiled as in the `TodoList`
    controller, we have two identifiers named in the same way. We have two options
    here: we can either rename the method or the property. If we rename the property,
    this will change the name of the component''s output as well. So, the following
    line of code will no longer work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'What we can do instead is rename the `toggle` property and explicitly set the
    name of the output using the `@Output` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This way, we will be able to trigger the `toggle` output using the `toggleEvent`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that such renames could be confusing and are not considered as best practices.
    For a complete set of best practices visit [https://github.com/mgechev/angular2-style-guide](https://github.com/mgechev/angular2-style-guide).
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can rename component''s inputs using the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, no matter that we renamed the input and output properties of `TodoList`,
    it still has the same public interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: An alternative syntax to define inputs and outputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `@Input` and `@Output` decorators are syntax sugar for easier declaration
    of the directive''s inputs and outputs. The original syntax for this purpose is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `@Input` and `@Output`, the preceding syntax is equivalent to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Although both have the same semantics, according to the best practices, we should
    use the latter one because it is easier to read and understand.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining Angular 2's content projection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Content projection is an important concept when developing user interfaces.
    It allows us to project pieces of content into different places of the user interface
    of our application. Web Components solve this problem with the `content` element.
    In AngularJS 1.x, it is implemented with the infamous transclusion.
  prefs: []
  type: TYPE_NORMAL
- en: Angular 2 is inspired by modern web standards, especially Web Components, which
    led to the adoption of some of the methods of content projection used there. In
    this section, we'll look at them in the context of Angular 2 using the `ng-content`
    directive.
  prefs: []
  type: TYPE_NORMAL
- en: Basic content projection in Angular 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s suppose we''re building a component called `fancy-button`. This component
    will use the standard HTML button element and add some extra behavior to it. Here
    is the definition of the `fancy-button` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside of the `@Component` decorator, we set the inline template of the component
    together with its selector. Now, we can use the component with the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: On the screen, we are going to see a standard HTML button that has a label with
    the content **Click me**. This is not a very flexible way to define reusable UI
    components. Most likely, the users of the fancy button will need to change the
    content of the label to something, depending on their application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In AngularJS 1.x, we were able to achieve this result with `ng-transclude`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In Angular 2, we have the `ng-content` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can pass custom content to the fancy button by executing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: As a result, the content between the opening and the closing `fancy-button`
    tags will be placed where the `ng-content` directive resides.
  prefs: []
  type: TYPE_NORMAL
- en: Projecting multiple content chunks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another typical use case of content projection is when we pass content to a
    custom Angular 2 component or AngularJS 1.x directive and we want different parts
    of this content to be projected to different locations in the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let''s suppose we have a `panel` component that has a title and
    a body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'And we have the following template of our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'In AngularJS 1.5, we are able to do this using multi-slot transclusion, which
    was implemented in order to allow us to have a smoother transition to Angular
    2\. Let''s take a look at how we can proceed in Angular 2 in order to define such
    a `panel` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We have already described the `selector` and `styles` properties, so let''s
    take a look at the component''s template. We have a `div` element with the `panel`
    class, which wraps the two nested `div` elements, respectively: one for the title
    of `panel` and one for the content of `panel`. In order to grab the content from
    the `panel-title` element and project it where the title of the `panel` is supposed
    to be in the rendered panel, we need to use the `ng-content` element with the
    `selector` attribute, which has the `panel-title` value. The value of the `selector`
    attribute is a CSS selector, which in this case is going to match all the `panel-title`
    elements that reside inside the target `panel` element. After this, `ng-content`
    will grab their content and set them as its own content.'
  prefs: []
  type: TYPE_NORMAL
- en: Nesting components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve already built a few simple applications as a composition of components
    and directives. We saw that components are basically directives with views, so
    we can implement them by nesting/composing other directives and components. The
    following figure illustrates this with a structural diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Nesting components](../images/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The composition could be achieved by nesting directives and components within
    the components'' templates, taking advantage of the nested nature of the used
    markup. For instance, let''s say we have a component with the `sample-component`
    selector, which has the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The template of the `sample-component` selector has a single child element with
    the tag name `view-child`.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, we can use the `sample-component` selector inside the template
    of another component, and since it can be used as an element, we can nest other
    components or directives inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This way, the `sample-component` component has two different types of successors:'
  prefs: []
  type: TYPE_NORMAL
- en: The successor defined within its template.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The successor that is passed as nested elements between its opening and closing
    tags.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the context of Angular 2, the direct children elements defined within the
    component's template are called **view children** and the ones nested between
    its opening and closing tags are called **content children**.
  prefs: []
  type: TYPE_NORMAL
- en: Using ViewChildren and ContentChildren
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at the implementation of the `Tabs` component, which uses
    the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding structure is composed of three components:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Tab` component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `TabTitle` component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `TabContent` component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at the implementation of the `TabTitle` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: There's nothing new in this implementation. We define a `TabTitle` component,
    which has a single property called `tabSelected`. It is of the type `EventEmitter`
    and will be triggered once the user clicks on the tab title.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the `TabContent` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This has an even simpler implementation—all we do is project the DOM passed
    to the `tab-content` element inside `ng-content` and hide it once the value of
    the `isActive` property becomes `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interesting part of the implementation is the `Tabs` component itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: In this implementation, we have a decorator that we haven't used yet—the `@ContentChildren`
    decorator. The `@ContentChildren` property decorator fetches the content children
    of the given component. This means that we can get references to all `TabTitle`
    and `TabContent` instances from within the instance of the `Tabs` component and
    get them in the order in which they are declared in the markup. There's an alternative
    decorator called `@ViewChildren`, which fetches all the view children of the given
    element. Let's take a look at the difference between them before we explain the
    implementation further.
  prefs: []
  type: TYPE_NORMAL
- en: ViewChild versus ContentChild
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although both concepts sound similar, they have quite different semantics.
    In order to understand them better, let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''ve defined two components: `UserBadge` and `UserRating`. Let''s define
    a parent component, which comprises both the components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the template of the view of `UserPanel` contains only the `UserBadge`
    component''s selector. Now, let''s use the `UserPanel` component in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The template of our main `App` component uses the `UserPanel` component and
    nests the `UserRating` component inside it. Now, let''s suppose we want to get
    a reference to the instance of the `UserRating` component that is used inside
    the `user-panel` element in the `App` component and a reference to the `UserBadge`
    component, which is used inside the `UserPanel` template. In order to do this,
    we can add two more properties to the `UserPanel` controller and add the `@ContentChild`
    and `@ViewChild` decorators to them with the appropriate arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The semantics of the `badge` property declaration is this: "get the instance
    of the first child component of the type `UserBadge`, which is used inside the
    `UserPanel` template". Accordingly, the semantics of the `rating` property''s
    declaration is this: "get the instance of the first child component of the type
    `UserRating`, which is nested inside the `UserPanel` host element".'
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you run this code, you'll note that the values of the `badge` and `rating`
    properties are still equal to the `undefined` value inside the controller's constructor.
    This is because they are still not initialized in this phase of the component's
    life cycle. The life cycle hooks that we can use in order to get a reference to
    these child components are `ngAfterViewInit` and `ngAfterContentInit`. We can
    use these hooks simply by adding definitions of the `ngAfterViewInit` and `ngAfterContentInit`
    methods to the component's controller. We will make a complete overview of the
    life cycle hooks that Angular 2 provides shortly.
  prefs: []
  type: TYPE_NORMAL
- en: To recap, we can say that the content children of the given components are the
    child elements that are nested within the component's host element. In contrast,
    the view children directives of the given component are the elements used within
    its template.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to get platform independent reference to a DOM element, again, we
    can use `@ContentChildren` and `@ViewChildren`. For instance, if we have the following
    template: `<input #todo>` we can get a reference to the `input` by using: `@ViewChild(''todo'')`.'
  prefs: []
  type: TYPE_NORMAL
- en: Since we are already familiar with the core differences between view children
    and content children now, we can continue with our tabs implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the tabs component, instead of using the `@ContentChild` decorator, we use
    `@ContentChildren`. We do this because we have multiple content children and we
    want to get them all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Another main difference we can notice is that the types of the `tabTitles` and
    `tabContents` properties are `QueryList` with the respective type parameter and
    not the component's type itself. We can think of the `QueryList` data structure
    as a JavaScript array—we can apply the same high-order functions (`map`, `filter`,
    `reduce`, and so on) over it and loop over its elements; however, `QueryList`
    is also observable, that is, we can observe it for changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the final step of our `Tabs` definition, let''s take a peek at the implementation
    of the `ngAfterContentInit` and select methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: In the first line of the method's implementation, we loop all `tabTitles` and
    take the observable's references. These objects have a method called `subscribe`,
    which accepts a callback as an argument. Once the `.emit()` method of the `EventEmitter`
    instance (that is, the `tabSelected` property of any tab) is called, the callback
    passed to the `subscribe` method will be invoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the `select` method''s implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: In the first line, we get an array representation of `tabContents`, which is
    of the type `QueryList<TabContent>`. After that, we set the `isActive` flag of
    the current active tab to `false` and select the next active one. In the last
    line in the `select` method's implementation, we trigger the selected event of
    the `Tabs` component by invoking `this.tabChanged.emit` with the index of the
    currently selected tab.
  prefs: []
  type: TYPE_NORMAL
- en: Hooking into the component's life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Components in Angular 2 have a well-defined life cycle, which allows us to hook
    into different phases of it and have further control over our application. We
    can do this by implementing specific methods in the component's controller. In
    order to be more explicit, thanks to the expressiveness of TypeScript, we can
    implement different interfaces associated with the life cycle's phases. Each of
    these interfaces has a single method, which is associated with the phase itself.
  prefs: []
  type: TYPE_NORMAL
- en: Although code written with explicit interface implementation will have better
    semantics, since Angular 2 supports ES5 as well within the component, we can simply
    define methods with the same names as the life cycle hooks (but this time, prefixed
    with `ng`) and take advantage of duck typing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows all the phases we can hook into:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hooking into the component''s life cycle](../images/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a look at the different life cycle hooks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnChanges`: This hook will be invoked once a change in the input properties
    of a given component has been detected. For instance, let''s take a look at the
    following component:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the value of the expression associated with the `[title]` attribute has
    been changed, the `ngOnChanges` hook will be invoked. We can implement it using
    this code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding snippet will display all the changed bindings and their old values.
    In order to be more explicit in the implementation of the hook, we can use interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: All the interfaces representing the individual life cycle hooks define a single
    method with the name of the interface itself prefixed with `ng`. In the upcoming
    list, we'll use the term life cycle hook, both for interface and/or the method,
    except if we won't imply anything specifically for only one of them.
  prefs: []
  type: TYPE_NORMAL
- en: '`OnInit`: This hook will be invoked once the given component has been initialized.
    We can implement it using the `OnInit` interface with its `ngOnInit` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DoCheck`: This will be invoked when the change detector of the given component
    is invoked. It allows us to implement our own change detection algorithm for the
    given component. Note that `DoCheck` and `OnChanges` should not be implemented
    together on the same directive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnDestroy`: If we implement the `OnDestroy` interface with its single `ngOnDestroy`
    method, we can hook into the destroy life cycle phase of a component. This method
    will be invoked once the component is detached from the component tree.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the life cycle hooks associated with the component''s
    content and view children:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AfterContentInit`: If we implement the `ngAfterContentInit` life cycle hook,
    we will be notified when the component''s content has been fully initialized.
    This is the phase when the properties decorated with `ContentChild` or `ContentChildren`
    will be initialized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AfterContentChecked`: By implementing this hook, we''ll get notified each
    time the content of the given component has been checked by the change detection
    mechanism of Angular 2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AfterViewInit`: If we implement the `ngAfterViewInit` life cycle hook, we
    will be notified when the component''s view has been fully initialized. This is
    the phase when the properties decorated with `ViewChild` or `ViewChildren` will
    be initialized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AfterViewChecked`: This is similar to `AfterContentChecked`. The `AfterViewChecked`
    hook will be invoked once the view of your component has been checked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The order of execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to trace the order of execution of the callbacks associated with each
    hook, let''s take a peek at the `ch4/ts/life-cycle/app.ts` example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The `Panel` component implements all the hooks without explicitly implementing
    the interfaces associated with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the component in the following template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have a panel and a button. Upon each click on the
    button, the panel will be either removed or appended to the view by the `ngIf`
    directive.
  prefs: []
  type: TYPE_NORMAL
- en: During the application initialization, if the result of the `"counter % 2 ==
    0"` expression is evaluated to `true`, the `ngOnChanges` method will be invoked.
    This happens because the values of the title and caption properties are going
    to be set for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: Right after this, the `ngOnInit` method will be called, since the component
    has been initialized. Once the component's initialization is completed, the change
    detection will be triggered, which will lead to the invocation of the `ngDoCheck`
    method that allows us to hook custom logic for detecting changes in the state.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that you are not supposed to implement both `ngDoCheck` and `ngOnChanges`
    methods for the same component, since they are mutually exclusive. The example
    here does this for learning purposes only.
  prefs: []
  type: TYPE_NORMAL
- en: After the `ngDoCheck` method, the component's content will be followed by performing
    a check on it (`ngAfterContentInit` and `ngAfterContentChecked` will be invoked
    in this order). Right after this, the same will happen for the component's view
    (`ngAfterViewInit` followed by `ngAfterViewChecked`).
  prefs: []
  type: TYPE_NORMAL
- en: Once the expression of the `ngIf` directive is evaluated to `false`, the entire
    component will be detached from the view, which will lead to the invocation of
    the `ngOnDestroy` hook.
  prefs: []
  type: TYPE_NORMAL
- en: On the next button click, if the value of the expression of `ngIf` is equal
    to `true`, the same sequence of calls of the life cycle hooks as the one during
    the initialization phase will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Defining generic views with TemplateRef
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are already familiar with the concepts of inputs, content, and view children,
    and we also know when we can get a reference to them in the component''s life
    cycle. Now, we will combine them and introduce a new concept: `TemplateRef`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a step back and take a look at the last to-do application we developed
    earlier in this chapter. In the following screenshot, you can see what its UI
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining generic views with TemplateRef](../images/00019.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If we take a look at its implementation in `ch4/ts/inputs-outputs/app.ts`, we'll
    see that the template used to render the individual to-do items is defined inside
    the template of the entire to-do application.
  prefs: []
  type: TYPE_NORMAL
- en: What if we want to use a different layout to render the to-do items? We can
    do this by creating another component called `Todo`, which encapsulates the responsibility
    of rendering them. Then, we can define separate `Todo` components for the different
    layouts we want to support. This way, we need to have *n* different components
    for *n* different layouts, even though we use only their templates.
  prefs: []
  type: TYPE_NORMAL
- en: Angular 2 comes with a more elegant solution. Earlier in this chapter, we already
    discussed the template element. We said that it allows us to define a chunk of
    HTML that will not be processed by the browser. Angular 2 allows us to reference
    such template elements and use them by passing them as content children!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how we can pass the custom layout to our refactored `todo-app` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: In the template, we declare a variable called `todo`. Later in the template,
    we can use it to specify the way in which we want to visualize the content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see how we can get a reference to this template in the controller
    of the `TodoApp` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: All we do here is define a property called `itemsTemplate` and decorate it with
    the `@ContentChild` decorator. During the component's life cycle (more accurately,
    in `ngAfterContentInit`), the value of `itemsTemplate` will be set as a reference
    of the template that we passed as the content of the `todo-app` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more problem though—we need the template in the `TodoList` component,
    since that''s the place where we render the individual to-do items. What we can
    do is define another input of the `TodoList` component and pass the template directly
    from `TodoApp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to pass it as an input from the template of `TodoApp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The only thing left is to use this template reference in the template of the
    `TodoList` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'We explained the extended syntax of the `ngForOf` directive in the previous
    sections of this chapter. This snippet shows one more property of this directive
    that we can set: the `ngForTemplate` property. By default, the template of the
    `ngForOf` directive is the element it is used on. By specifying a template reference
    to the `ngForTemplate` property, we can use the passed `TemplateRef` instead.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and enhancing the change detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already briefly described the change detection mechanism of the framework.
    We said that compared to AngularJS 1.x, where it runs in the context of the scope,
    in Angular 2, it runs in the context of the individual components. Another concept
    we mentioned is the zones, which basically intercept all the asynchronous calls
    that we can make using the browser APIs and provide execution context for the
    change detection mechanism of the framework. Zones fix the annoying problem we
    have in AngularJS 1.x, where when we use APIs outside of Angular, we need to explicitly
    invoke the `digest` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapters 1](part0015_split_000.html#E9OE1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 1. Getting Started with Angular 2"), *Getting Started with Angular 2*
    and [Chapter 2](part0019_split_000.html#I3QM1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 2. The Building Blocks of an Angular 2 Application"), *The Building Blocks
    of an Angular 2 Application*, we discussed that there are two main implementations
    of the change detector: `DynamicChangeDetector` and `JitChangeDetector`. The first
    one works great for environments with strict **CSP** (**Content-Security-Policy**)
    because of the disabled dynamic evaluation of JavaScript. The second one takes
    great benefits from the inline-caching mechanism of the JavaScript virtual machine
    and therefore brings great performance!'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll explore another property of the `@Component` decorator's
    configuration object, which provides us further control over the change detection
    mechanism of the framework by changing its strategy. By explicitly setting the
    strategy, we are able to prevent the change detection mechanism from running over
    a component's subtrees, which in some cases can bring great performance benefits.
  prefs: []
  type: TYPE_NORMAL
- en: The order of execution of the change detectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's briefly describe the order in which the change detectors are invoked
    in a given component tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this purpose, we will use the last implementation of the to-do application
    we have, but this time, we''ll extract the logic to render the individual to-do
    items into a separate component called `TodoItem`. In the following figure, we
    can see the application''s structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The order of execution of the change detectors](../images/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'At the top level is the `TodoApp` component, which has two children: `InputBox`
    and `TodoList`. The `TodoList` component renders the individual to-do items in
    `TodoItem` components. The implementation details are not important for our purpose,
    so we are going to ignore them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to realize that there is an implicit dependency between the state
    of the parent component and its children. For instance, the state of the `TodoList`
    component depends completely on the to-do items that are located at its parent:
    the `TodoApp` component. There''s a similar dependency between `TodoItem` and
    `TodoList`, since the `TodoList` component passes the individual to-do items to
    a separate instance of the `TodoItem` component.'
  prefs: []
  type: TYPE_NORMAL
- en: '![The order of execution of the change detectors](../images/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Because of our last observation, the order of execution of the change detectors
    attached to the individual components is like the one shown on the preceding figure.
    Once the change detection mechanism run, initially it will perform a check over
    the `TodoApp` component. Right after this, the `InputBox` component will be checked
    for changes, followed by the `TodoList` component. In the end, Angular will invoke
    the change detector of the `TodoItem` component.
  prefs: []
  type: TYPE_NORMAL
- en: You can trace the order of execution in the `ch4/ts/change_detection_strategy_order/app.ts`
    example, where each individual component logs a message once its `ngDoCheck` method
    is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that only the components have an instance of a change detector attached
    to them; directives use the change detector of their parent component.
  prefs: []
  type: TYPE_NORMAL
- en: Change detection strategies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The change detection strategies that Angular 2 provides are: `CheckOnce`, `Checked`,
    `CheckAlways`, `Detached`, `Default`, and `OnPush`. We will describe how we can
    take advantage of `OnPush` in detail, since it is very powerful when working with
    immutable data. Before taking a deep dive into `OnPush`, let''s briefly describe
    the other strategies.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s import the TypeScript `enum`, which can be used to configure the
    strategy used for the individual components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can configure the `TodoList` component to use the `Checked` strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: This way, the change detection will be skipped until its mode (strategy) changes
    to `CheckOnce`. But what does it mean to prevent the change detection from running?
    You can go to `http://localhost:5555/dist/dev/ch4/ts/change_detection_strategy_broken/`
    and see the inconsistent behavior of the `TodoList` component. When you add a
    new to-do item in the input and you click on the button, it won't immediately
    appear in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's try `CheckOnce`! Inside `ch4/ts/change_detection_strategy_broken/app.ts`,
    change the change detection strategy of the `TodoList` component to `ChangeDetectionStrategy.CheckOnce`.
    After refreshing the browser, try to add a new to-do item. The change should not
    be immediately reflected because `CheckOnce` will instruct the change detector
    to perform the check only once (in this case, during initialization), and after
    that, nothing will happen.
  prefs: []
  type: TYPE_NORMAL
- en: By default, it is used in the `CheckAlways` mode, which as its name states,
    doesn't prevent the change detector from running.
  prefs: []
  type: TYPE_NORMAL
- en: If we declare the strategy of a given component to `Detached`, the change detector
    subtree will not be considered as a part of the main tree and will be skipped.
  prefs: []
  type: TYPE_NORMAL
- en: Performance boosting with immutable data and OnPush
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last change detection strategy that we are going to describe is `OnPush`.
    It is extremely useful when the result that the given component produces depends
    only on its inputs. In such cases, we can pass immutable data to the inputs in
    order to make sure that it will not be mutated by any other component. This way,
    by having a component that depends only on its immutable inputs, we can make sure
    that it produces different user interfaces only once it receives different inputs
    (that is, different reference).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to apply the `OnPush` strategy on the `TodoList`
    component. Since it depends only on its inputs (the `todos` input), we want to
    make sure that its change detection will be performed only once it receives a
    new reference of the `todos` collection.
  prefs: []
  type: TYPE_NORMAL
- en: The essence of immutable data is that it cannot change. This means that once
    we add a new to-do item to the `todos` collection, we cannot change it; instead,
    the `add` (or in our case, `push`) method will return a new collection—a copy
    of the initial collection with the new item included.
  prefs: []
  type: TYPE_NORMAL
- en: 'This may seem like a huge overhead—to copy the entire collection on each change.
    In big applications, this may have a big performance impact. However, we don''t
    need to copy the entire collection. There are libraries that implement immutable
    data structure using smarter algorithms: persistent data structures. Persistent
    data structures are out of the scope of the current content. Further information
    about them can be found in most computer science textbooks for advanced data structures.
    The good thing is that we don''t have to understand their implementation in depth
    in order to use them! There is a library called `Immutable.js` that implements
    a few commonly used immutable data structures. In our case, we are going to use
    the immutable list. Generally, the immutable list behaves just like a normal list,
    but on each operation that is supposed to mutate it, it returns a new list.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that if we have a list called `foo`, which is immutable, and we
    append a new item to the list, we are going to get a new reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: In order to take advantage of immutability, we need to install `Immutable.js`
    using npm.
  prefs: []
  type: TYPE_NORMAL
- en: We've already done this in `ch4/ts/change_detection_strategy/app.ts`. `Immutable.js`
    is already part of `package.json`, which is located at the root directory of the
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to refactor our to-do application and make it use immutable data!
  prefs: []
  type: TYPE_NORMAL
- en: Using immutable data structures in Angular
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at how we currently keep the to-do items in the `TodoApp`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'We use an array of `Todo` items. The JavaScript array is mutable, which means
    that if we pass it to a component that uses the `OnPush` strategy, it is not safe
    to skip the change detection in case we get the same input reference. For instance,
    we may have two components that use the same list of to-do items. Both components
    can modify the list since it is mutable. This will lead to an inconsistent state
    to any of the components in case their change detection is not performed. That''s
    why we need to make sure that the list that holds the items is immutable. All
    we need to do in the `TodoApp` component in order to make sure that it holds its
    data in an immutable data structure is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'In this way, we construct the `todos` property as an immutable list. Since
    the mutation operations of the immutable list return a new list, we need to make
    a slight modification in `addTodo` and `toggleTodoCompletion`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The `addTodo` function looks exactly the same as before except that we set the
    result of the `push` method as a value to the `todos` property.
  prefs: []
  type: TYPE_NORMAL
- en: In `toggleTodoCompletion`, we use the `update` method of the immutable list.
    As the first argument, we pass the index of the to-do item we want to modify,
    and the second argument is a callback that does the actual modification. Note
    that since we are using immutable data in this case, we copy the modified to-do
    item. This is required because it tells the `update` method that the item with
    the given index has been changed (since it is immutable, it is considered as changed
    only when it has a new reference), which means that the entire list has been changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'That was the complex part! Now let''s take a look at the `TodoList` component''s
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `@Component` decorator, we set the `changeDetection` property to
    the value of the `OnPush` strategy. This means that the component will run its
    change detector only when any of its inputs gets a new reference. The template
    of the component stays exactly the same since `ngForOf` internally uses ES2015
    iterators to loop the items in the provided collection. They are supported by
    `Immutable.js`, so the changes in the template are not required.
  prefs: []
  type: TYPE_NORMAL
- en: Since we need the index of the changed item (the one we use in the `update`
    method of the `todos` collection in `TodoApp`), we change the type of the output
    of the component to `EventEmitter<number>`. In `toggleCompletion`, we emit the
    index of the changed to-do item.
  prefs: []
  type: TYPE_NORMAL
- en: This is how we optimized our simple to-do application by preventing the change
    detection mechanism from running in the entire right subtree in case the parent
    component hasn't pushed an input with a new reference.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we went through the core building blocks of an Angular 2 application:
    directives and components. We built a couple of sample components, which show
    us the syntax to be used for the definition of these fundamental concepts. We
    also described the life cycle of each directive and the core set of features the
    given directive and component have. As the next step, we saw how we can enhance
    the performance of our application by using the `OnPush` change detection strategy
    with immutable data.'
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is completely dedicated to the Angular 2 services and the dependency
    injection mechanism of the framework. We are going to look at how we can define
    and instantiate custom injectors and how we can take advantage of the dependency
    injection mechanism in our directives and components.
  prefs: []
  type: TYPE_NORMAL
