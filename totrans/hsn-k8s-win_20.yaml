- en: Production Considerations for Running Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have arrived at the last chapter of this book— well done! In this short
    chapter, we will provide you with various best practices and recommendations for
    running Kubernetes in production. There are always two worlds for every software
    engineering approach or tool—how you use it for development and how you use it
    in production. For Kubernetes, running in production requires more operations
    overheads as you want to run your workloads with high availability and reliability, often at
    a large scale. You have to consider how you are performing upgrades to the cluster
    itself and how you patch the underlying operating system, ensuring the continuity
    of your business. If you are running Kubernetes in an isolated network in your
    enterprise data center, you may need to wire in network proxy configuration in
    all components of Docker and Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, it is important to ensure that your clusters are provisioned reproducibly
    using *infrastructure as code* and *immutable infrastructure* approaches. But
    this is not everything—you definitely want to manage your cluster workloads declaratively
    (similar to your infrastructure) and for that, you can employ the GitOps approach.
    All of the concepts that we describe in this chapter can be applied to Linux-only
    clusters and hybrid Windows/Linux clusters as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'This last chapter of this book will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning clusters reproducibly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubeadm limitations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upgrading clusters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OS patching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring a network proxy for the Docker daemon and Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Windows 10 Pro, Enterprise, or Education (version 1903 or later, 64-bit) installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Azure account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helm installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Windows/Linux Kubernetes cluster deployed using AKS Engine or an on-premises
    cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To follow along, you will need your own Azure account to create Azure resources
    for the Kubernetes cluster. If you haven't already created the account for the
    previous chapters, you can read more about how to obtain a limited free account
    for personal use here: [https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/).
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a Kubernetes cluster using AKS Engine has been covered in [Chapter
    8](ab695a0d-05dc-48f8-8c41-bbd167cfbfa6.xhtml), *Deploying Hybrid Azure Kubernetes
    Service Engine Cluster*.
  prefs: []
  type: TYPE_NORMAL
- en: You can download the latest code samples for this chapter from the official
    GitHub repository: [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter16](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter16).
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning clusters reproducibly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let's take a look at how you can approach provisioning your clusters
    and the underlying infrastructure and how to declaratively manage your application
    workloads as part of your **Continuous Integration** or **Continuous Deployment**
    (**CI/CD**) pipelines. In all cases, setting up any *infrastructure as code* approach
    is a bit harder and more complex than just using the infrastructure but it pays
    off greatly in the end game. You gain configuration consistency, simplicity when
    introducing complex changes, testable/analyzable infrastructure changes, and reproducible
    environments for any stage of the development workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure as code for clusters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Infrastructure as Code** (**IaC**) is, in short, the concept of managing
    your whole IT infrastructure using declarative configuration files only. What
    it means is that you aim to havie the state of your infrastructure captured in
    configuration files and apply changes to the environment using dedicated tools
    rather than performing physical hardware configuration using scripts or interactive
    tooling. For Azure, you can use **Azure Resource Manager** (**ARM**) templates ([https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-group-authoring-templates](https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-group-authoring-templates))
    to describe your infrastructure or use a generic IaC tool such as Terraform ([https://www.terraform.io/](https://www.terraform.io/)).
    In fact, you have already used ARM templates indirectly when deploying the AKS
    Engine cluster—you can think of AKS Engine tools as another layer of abstraction
    for creating complex ARM templates.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can take the IaC approach even further: **Immutable Infrastructure** (**IM**).
    In the case of IM, you never modify any configuration on the machines after they
    are deployed. If you need to perform a fix, you have to build a new machine from
    a base image with a fix and deprovision the old machines. This may sound extreme
    but it can be easily achieved both in the virtual machines world as well as bare-metal
    environments.'
  prefs: []
  type: TYPE_NORMAL
- en: Packer ([https://www.packer.io/](https://www.packer.io/)) is one of the best
    tools to help you to introduce this paradigm for virtual and bare-metal machines.
    But if you think about it carefully, we have already been using IaC and IM in
    this book a lot but at a different, higher level.
  prefs: []
  type: TYPE_NORMAL
- en: Docker itself is a manifestation of *immutable infrastructure*, where you ship
    your software as immutable operating system container images, just as if they
    were VM images.Kubernetes can be seen as a platform for managing your immutable
    container infrastructure for your application workloads—whenever you create a
    new Docker image and roll out a new version of a Deployment, you are just creating
    new containers and throwing away the old ones. If you use a declarative approach
    to manage your Kubernetes objects (at least using `kubectl apply -f`), you end
    up with neat *infrastructure as code*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This long introduction shows us a few things that can be treated as recommendations
    for provisioning infrastructure for Kubernetes and deploying your clusters, from
    the lowest to the highest level:'
  prefs: []
  type: TYPE_NORMAL
- en: Always provision your underlying infrastructure for clusters using the *infrastructure
    as code* or *immutable infrastructure* approach, using the right tools for the
    job. Terraform or ARM templates suit this task very well in both cases. AKS Engine ([https://github.com/Azure/aks-engine](https://github.com/Azure/aks-engine))
    is a perfect example of *immutable infrastructure* tooling built on top of ARM
    templating. If you want to roll out a new version of a VM image for your cluster
    nodes, you need to create a new node pool with a new image and decommission the
    old node pool. Avoid using tools that were not originally meant to do that, such
    as Ansible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To create the Kubernetes cluster itself on your infrastructure, use the *infrastructure
    as code* concept. Tools such as Ansible ([https://www.ansible.com/](https://www.ansible.com/)),
    Powershell Desired State Configuration ([https://docs.microsoft.com/en-us/powershell/scripting/dsc/overview/overview?view=powershell-6](https://docs.microsoft.com/en-us/powershell/scripting/dsc/overview/overview?view=powershell-6)),
    or dedicated kubespray ([https://github.com/kubernetes-sigs/kubespray](https://github.com/kubernetes-sigs/kubespray))
    are perfect for this task. AKS Engine excellently combines both infrastructure
    provisioning and cluster Deployment into one tool. If you need a managed Kubernetes
    service, then again use Terraform or ARM templates. But do not use them for self-managed
    clusters to provision software—even if they are capable of doing that, they were
    not meant to do so in the first place.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Docker and Kubernetes clusters as an *immutable infrastructure* platform
    for your application workloads. Manage this platform using dedicated, declarative
    tools such as Kustomize ([https://kustomize.io/](https://kustomize.io/)) or Helm ([https://helm.sh/](https://helm.sh/)).
    Take Helm chart management to an even higher, also declarative, level—use Helmfile
    ([https://github.com/roboll/helmfile](https://github.com/roboll/helmfile)) or
    Flux ([https://github.com/fluxcd/flux](https://github.com/fluxcd/flux)). You will
    not have to worry about running the `helm upgrade` command again! But again, do
    not use tools that were not meant for this, such as Ansible or Terraform, even
    though they have modules or providers that are advertised as being capable of
    managing Kubernetes Objects or Helm Charts. You risk tying to a custom API that
    does not have all of Kubernetes features and quickly gets outdated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to manage multiple Kubernetes clusters declaratively, definitely
    keep an eye on the Kubernetes Cluster API ([https://cluster-api.sigs.k8s.io/introduction.html](https://cluster-api.sigs.k8s.io/introduction.html)),
    which is currently in alpha state. This Kubernetes project will allow you to create
    a special Kubernetes management cluster where you can operate on clusters or machines
    as Kubernetes custom resources.
  prefs: []
  type: TYPE_NORMAL
- en: So, in short, always use the right tool for the job! This is why we will now
    take a look at Flux and the GitOps approach.
  prefs: []
  type: TYPE_NORMAL
- en: GitOps for application workloads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Flux ([https://github.com/fluxcd/flux](https://github.com/fluxcd/flux)) is a
    tool that automatically ensures that the state of a Kubernetes cluster matches
    the configuration (manifests and Helm charts) in Git. This approach complies with
    GitOps, which is a way of managing Kubernetes clusters and your applications,
    proposed by Weaveworks ([https://www.weave.works/technologies/gitops/](https://www.weave.works/technologies/gitops/)),
    where the Git repository is the single source of truth for the declarative infrastructure
    and your application workloads. This approach fully complies with the *infrastructure
    as code* paradigm. Moreover, you have a good separation of concerns: the developers
    introduce the changes to the cluster state or application configuration, which
    are stored in a Git repository (through a full CI pipeline) and a dedicated GitOps
    component is responsible for applying the configuration to the Kubernetes cluster.
    You get this clear boundary and you can always be sure that what is in the repository
    reflects the actual cluster state.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at how you can use Flux to manage a cluster that runs the
    Voting Application that we have implemented throughout this book. You will need
    an AKS Engine cluster for that purpose that has Linux nodes capable of handling
    more than 4 volume mounts per node—you can use the following cluster ApiModel: [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter16/01_aks-engine-flux/kubernetes-windows-template.json](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter16/01_aks-engine-flux/kubernetes-windows-template.json).
  prefs: []
  type: TYPE_NORMAL
- en: Support for Helm 3 in Flux is currently in the development state. You can track
    progress here: [https://github.com/fluxcd/helm-operator/issues/8](https://github.com/fluxcd/helm-operator/issues/8).
    For this reason, we need to use custom images for Flux components, but by the
    time you read this, the support may already be in a stable state.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create our repository with the source of truth for the Kubernetes
    cluster. Please follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new GitHub repository. We will be using [https://github.com/hands-on-kubernetes-on-windows/voting-application-flux](https://github.com/hands-on-kubernetes-on-windows/voting-application-flux)
    for demonstration purposes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `charts/voting-application` directory, place the Voting Application
    Helm chart. You can find the latest one here (with a small workaround for the `post-install`
    hook and waiting not working correctly in this version of Flux): [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter16/02_voting-application-flux/charts/voting-application](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter16/02_voting-application-flux/charts/voting-application).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `namespaces` directory, create the `demo.yaml` file with the namespace
    definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `storageclasses` directory, create the `azure-disk.yaml` file with the
    `StorageClass` definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `releases` directory, create the `voting-application.yaml` file with the
    `HelmRelease` custom resource for our Voting Application. This custom resource
    is handled by the Flux Helm Operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Push the changes to your GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Flux does not follow any directory convention—it is up to you how you define
    the structure. All it does is search for YAML files in the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have defined our repository with a source of truth. Now, let''s deploy Flux
    to our cluster, which is capable of handling Helm 3 charts. Execute the following
    steps (or you can use the PowerShell script: ([https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter16/03_DeployFlux.ps1](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter16/03_DeployFlux.ps1)):'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new PowerShell window as Administrator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install `fluxctl` using Chocolatey:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a dedicated `fluxcd` namespace for your Flux components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the Flux Helm repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the Flux Helm chart. You need to ensure that all components have `nodeSelector`
    set to run on Linux nodes. Set the `git.url` value to your GitHub repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the official manifest for HelmRelease custom resource definition (here
    we use the development manifest from the `helm-v3-dev` branch):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the Helm chart for the Flux Helm operator. This is a version of the
    operator that comes from the development branch with support for Helm 3\. Remember
    to ensure the Linux `nodeSelector`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `fluxctl` to retrieve the public SSH key that has to be added as a deploy
    key to your GitHub repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Copy the key and open your GitHub repository in a web browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to Settings and Deploy Keys.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add your key with write access.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, you can wait for a short while until the repository is automatically synchronized
    by Flux or force synchronization using this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Observe the creation of components using `kubectl get all -n demo`. You can
    also use the `kubectl logs` command to follow Helm operator logs, especially in
    the event of any problems with the process of installing the Helm release:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding steps, we used imperative commands, as in the official guides
    from Flux. You can, of course, use declarative manifests and YAML files with values
    for the Helm releases.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the whole procedure is completely automatic. You define the
    state in the Git repository and Flux automatically takes care of applying the
    changes to the cluster. Now, let''s test how rolling out a change in the cluster
    state works. As an example, we will change the tag for the image that we use in
    the Voting Application, as if we were rolling out a new version of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: In your repository with the cluster state, start editing `charts/voting-application/Chart.yaml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change `version` to `0.4.1` to indicate that the chart version itself has changed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change `appVersion` to a different Voting Application image tag. We can use,
    for example, `1.5.0`, one of the previous versions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the changes, commit to the repository, and push to GitHub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for the changes to be synced automatically or force the sync using the `fluxctl
    sync --k8s-fwd-ns fluxcd` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Execute the `kubectl get pods -n demo` command to see that the resources are
    indeed recreating:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Describe one of the new pods to verify that it was created with the desired
    Docker image tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! You have successfully set up a GitOps pipeline using Flux.
    In production, you can easily extend the pipeline by adding CI/CD components integrated
    with your Git repository, which will perform, for example,the validation of each
    pull request before it is merged to the cluster state repository. You can learn
    more about more complex pipelines in the following article: [https://www.weave.works/blog/what-is-gitops-really](https://www.weave.works/blog/what-is-gitops-really).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will take a look at kubeadm limitations for production
    use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Kubeadm limitations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubeadm ([https://github.com/kubernetes/kubeadm](https://github.com/kubernetes/kubeadm))
    is a command-line tool for provisioning Kubernetes clusters focused on performing
    actions necessary to get a minimum viable secure cluster up and running in a user-friendly
    way—we introduced this tool in [Chapter 4](118e3c89-786e-4718-ba67-6c38928e2a42.xhtml), *Kubernetes
    Concepts and Windows Support*, and later used it in [Chapter 7](165c2fcc-4ce8-4dbc-a19c-c7fd427b3379.xhtml), *Deploying
    Hybrid On-Premises Kubernetes Cluster*. This tool is scoped only to a given machine
    and Kubernetes API communication, so in general, it is intended to be a building
    block for other automation tools that manage the cluster as a whole. You will
    find that other complex automation tools such as kubespray are built on top of
    kubeadm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with Kubernetes 1.13, kubeadm is considered stable and ready for production
    use. But even though its current core feature set is in a stable state, you should
    take into account several limitations that may not make kubeadm the right tool
    for your production Kubernetes Deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: kubeadm has only initial support for Windows nodes and the API regarding this
    support is likely to change. This makes production Deployments of hybrid clusters
    a hard task—the only alternative at this point is manually configuring Kubernetes
    components on Windows nodes and joining them to an existing Linux cluster. Of
    course, if you are running on Azure you can use AKS or AKS Engine to run Windows
    container workloads in production.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A highly available Kubernetes cluster setup (with stacked and internal etcd
    topology) is now possible with kubeadm but is still relatively complex. You can
    read more in the official documentation: [https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/high-availability/](https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/high-availability/).
    Additionally, there is no easy way to manage the etcd cluster afterward using
    kubeadm, which means that solutions such as kubespray give more flexibility. But
    of course, this comes at the cost of no support for Windows at this point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: kubeadm cannot be used for joining new nodes to existing clusters that have
    been bootstrapped without kubeadm.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, for hybrid Windows/Linux Kubernetes clusters there is no perfect
    way for provisioning production-ready clusters if you cannot use AKS or AKS Engine.
    Using kubeadm is still the only semi-automated way to set up such clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a look at how you can upgrade your Kubernetes cluster to a newer
    version.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading clusters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Running a Kubernetes cluster in production will definitely require upgrading
    the Kubernetes components to newer versions at some point. How you perform the
    upgrade itself depends on the tools that you use to bootstrap and manage the cluster.
    But in general, the high-level procedure looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Upgrade the components running on the primary master node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upgrade the components running on the additional master nodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upgrade the worker nodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There is an important rule that you have to follow to ensure safe upgrades:
    you can only upgrade the cluster  by one minor version at once. It means that,
    for example, a cluster that has version 1.16 can be only upgraded to 1.17—you
    cannot make a jump straight to 1.18\. The reason for this is the version skew
    policy for Kubernetes master components, which allows running one minor version
    difference at most only. The expected cadence for releases of minor versions of
    Kubernetes is three months, which means that you may need to run the upgrade procedure
    quite often, especially considering that each minor version will be maintained
    for approximately nine months. You can read about the policies for all components
    in the official documentation: [https://kubernetes.io/docs/setup/release/version-skew-policy/](https://kubernetes.io/docs/setup/release/version-skew-policy/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on how you bootstrapped the cluster, the exact upgrade steps will
    be different. For example, for kubeadm clusters, the upgrade will be performed in
    place, on the same machines. But if you use AKS or AKS Engine, the procedure will
    be compliant with *immutable infrastructure* paradigm: master and worker VMs will
    be sequentially replaced with VMs running a newer version of Kubernetes components.
    In more detail, for master nodes, the automated upgrade procedure looks as follows
    under the hood:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Cordon` (mark the node as unschedulable) one of the master nodes and drain
    the existing pods.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the physical VM. Now, the size of the control plane is `N-1` nodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new VM with the new version of Kubernetes components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the new VM to the cluster and apply any existing labels, annotations, or
    taints for the node. Now, the size of the data plane is again `N`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For worker nodes, the procedure is similar and has the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new VM with the new version of Kubernetes components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the new VM to the cluster. Now, the size of the data plane is `M+1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If any pods have already been scheduled to the new node, evict them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply any existing labels, annotations, or taints to the new node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Cordon` the old node and drain the existing pods.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the old VM. Now, the size of the data plane is again `M`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The reason why worker nodes are upgraded by adding an extra node (instead of
    removing the existing node first) is to ensure that the cluster capacity for data
    plane workloads does not shrink. This ensures that the upgrade is entirely transparent
    for the users. You can read more about upgrade procedures for AKS at: [https://docs.microsoft.com/en-us/azure/aks/upgrade-cluster](https://docs.microsoft.com/en-us/azure/aks/upgrade-cluster)
    and for AKS Engine at: [https://github.com/Azure/aks-engine/blob/master/docs/topics/upgrade.md](https://github.com/Azure/aks-engine/blob/master/docs/topics/upgrade.md).'
  prefs: []
  type: TYPE_NORMAL
- en: You can use the *immutable infrastructure* approach for upgrades used in AKS
    and AKS Engine to perform manual upgrades of clusters bootstrapped using different
    tools, as long as the toolset allows adding new master and worker nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now perform an upgrade of a Kubernetes cluster (with Windows nodes)
    that has been created using AKS Engine. For this demonstration, we are running
    a cluster with version 1.16.1, which we have created in the previous sections.
    You will need the cluster ApiModel, which you used for the initial Deployment.
    To perform the upgrade, please follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a PowerShell window. Determine what the available Kubernetes versions
    are that you can use for upgrading your AKS Engine cluster with Windows nodes.
    Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s upgrade the cluster to the latest version, `1.17.0-beta.1`. If you do
    not have your AKS Engine Service Principal, you have to generate a new one because
    it is not possible to retrieve the password of an existing one. To do that, use
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Take note of `appId` and `password` to use it during the upgrade command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following command to perform the upgrade. You have to specify the generated
    cluster ApiModel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The upgrade can take around 50 minutes (10 minutes per node), depending on
    the size of your cluster. If you are using a single-node control plane in your
    cluster, you won''t be able to access the Kubernetes API during the upgrade for
    some time. When the upgrade is finished, run the following command to verify that
    the nodes are running the desired version of Kubernetes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In production clusters, especially if you are running a customized cluster with
    extensions or dedicated VM images, it is recommended to test the upgrade in a
    separate staging cluster that was created using exactly the same specification.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations, you have successfully upgraded your AKS Engine cluster to version
    `1.17.0-beta.1`. In the next section, you will learn how to approach operating
    system patching in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: OS patching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To ensure the best security of your cluster and the underlying infrastructure,
    you must ensure that you are running an operating system with the latest patches
    on your nodes. Fortunately, Kubernetes is flexible when it comes to the maintenance
    of nodes. The general approach for any maintenance, including applying OS patches
    that require reboot, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Cordon` (mark the node as unschedulable) the node and drain the existing pods.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the required updates and reboot the machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Uncordon` the node to make it schedulable again.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Alternatively, if you use an *immutable infrastructure* approach, the preceding
    steps have to be extended by the creation of a new patched machine and the deletion
    of the old machine. For example, in AKS Engine, this scenario could look as follows,
    providing that you use Virtual Machine Scale Sets (VMSS) with a custom VM image
    for your node pools:'
  prefs: []
  type: TYPE_NORMAL
- en: Build a new version of the VM image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the VM image for your VMSS ([https://docs.microsoft.com/en-us/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-upgrade-scale-set#update-the-os-image-for-your-scale-set](https://docs.microsoft.com/en-us/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-upgrade-scale-set#update-the-os-image-for-your-scale-set)),
    possibly directly in the ARM template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For each VM in the VMSS, sequentially perform the following: `cordon` and drain
    the node, set the VM image to the latest version for the VMSS instance, and `uncordon`
    the node.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are interested in creating your own custom VM images for AKS Engine Windows
    nodes, you can read the following description of the build process, which uses
    Packer and Azure DevOps: [https://github.com/Azure/aks-engine/blob/master/docs/topics/windows-vhd.md](https://github.com/Azure/aks-engine/blob/master/docs/topics/windows-vhd.md).
  prefs: []
  type: TYPE_NORMAL
- en: 'To exercise the manual procedure of maintenance for Windows nodes, please perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume that we would like to patch the `1754k8s010` Windows node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the name to get the private IP address of the `1754k8s010` node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Use one of the private IPs to create an SSH tunnel from your local `5500` port
    via the master node to port `3389` (RDP) on the Windows node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In a different PowerShell window, start the RDP session via the tunnel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Provide your Windows node credentials (as in ApiModel) and connect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for the console to initialize.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, you are ready to perform the maintenance, but first, we need to drain
    the node (which also `cordons` the node first). In a new PowerShell window on
    your local machine, execute this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'When the node is drained, you can start your maintenance procedure. For example,
    you can use the `sconfig.cmd` utility in the console to apply the updates manually:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/f7f45280-f41d-4029-92d1-c21dc0d7e75d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select option `6` and choose which updates you want to install:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/85db4f35-ad84-4c6b-a407-d5d69e79f922.png)'
  prefs: []
  type: TYPE_IMG
- en: Wait for the installation to end and reboot the machine if needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When the node is fully rebooted, you can `uncordon` the node to make it schedulable
    again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Your node will be now fully functional in the cluster again.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you may consider using Azure Update Management to manage operating
    system updates and patching in your cluster. You can read more in the official
    documentation: [https://docs.microsoft.com/en-us/azure/automation/automation-update-management](https://docs.microsoft.com/en-us/azure/automation/automation-update-management).
  prefs: []
  type: TYPE_NORMAL
- en: In the last section, we will show which components in Kubernetes require additional
    configuration if you are running your production cluster behind an HTTP(S) network
    proxy.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a network proxy for the Docker daemon and Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In enterprise environments, it is a common practice to use HTTP(S) network proxies
    for connections to external networks and especially the internet. This comes at
    an additional configuration cost of all components that are running behind a proxy—we
    are going to give a brief overview of what components in Kubernetes you need to
    make the proxy aware to use Docker images from external registries and propagate
    the proxy settings to the containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that our proxy addresses are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://proxy.example.com:8080/` for HTTP proxy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://proxy.example.com:9090/` for HTTPS proxy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Configuration for other standard proxies, such as SFTP, can be done similarly.
    You may also need appropriate no-proxy variables to exclude the Kubernetes nodes
    and local network, otherwise, you will be not able to communicate between the
    nodes or the traffic to nodes, will be additionally routed through the proxy!
    Now, for Linux nodes and masters (assuming a Debian-based distribution, such as
    Ubuntu), you will need to ensure that the following settings are configured:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define proxy settings for the default environment, `/etc/environment`. This
    will make tools such as APT honor the proxy settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Proxies are set for the Docker daemon environment. This will ensure that the
    containers receive the proxy variables as well. You can define the `/etc/systemd/system/docker.service.d/http-proxy.conf`
    file with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'For building Docker images on machines behind a proxy, consider passing the
    proxy settings as arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'For your Windows worker nodes, you can take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define global environment variables from PowerShell as an Administrator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, ensure that any traffic that uses a web browser engine also respects
    the proxy settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: These configuration steps should let you pull Docker images, bootstrap the cluster,
    and later make pod containers aware of these settings when connecting to an external
    network.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we focused on common operational best practices for Kubernetes
    clusters running in production. First, we covered the approaches for provisioning
    infrastructure for Kubernetes and deploying the clusters reproducibly—we introduced
    the concepts of *infrastructure as code* and *immutable infrastructure* and have
    showed how they fit into the Kubernetes landscape. Additionally, we provided a
    recommendation on the best tools for provisioning infrastructure and cluster Deployments.
    Next, you learned what GitOps is and how to apply this philosophy using Flux and
    Git repositories. We focused on the operational aspects of upgrades and the patching
    of both the underlying cluster infrastructure and Kubernetes itself. And lastly,
    you learned how to ensure that your Kubernetes cluster can run behind HTTP(S)
    network proxies in enterprise environments.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! This has been a long journey into the (almost) *uncharted territory*
    of Kubernetes on Windows—good luck with your further Kubernetes journey and thanks
    for reading.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between *infrastructure as code* and *immutable infrastructure*?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is Kubernetes considered to be a platform that uses the *infrastructure
    as code* approach?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is GitOps?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits of using Flux in your Kubernetes clusters?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the steps during the upgrade of a Kubernetes cluster version?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the procedure for performing maintenance on a Kubernetes node?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can find answers to these questions in *Assessments* of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information about Kubernetes features and running the cluster in production,
    please refer to the following Packt books:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Complete Kubernetes Guide* ([https://www.packtpub.com/virtualization-and-cloud/complete-kubernetes-guide](https://www.packtpub.com/virtualization-and-cloud/complete-kubernetes-guide))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Getting Started with Kubernetes - Third Edition* ([https://www.packtpub.com/virtualization-and-cloud/getting-started-kubernetes-third-edition](https://www.packtpub.com/virtualization-and-cloud/getting-started-kubernetes-third-edition))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you are interested in exploring *infrastructure as code* concepts, you can
    check out the following Packt book:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Infrastructure as Code (IaC) Cookbook* ([https://www.packtpub.com/virtualization-and-cloud/infrastructure-code-iac-cookbook](https://www.packtpub.com/virtualization-and-cloud/infrastructure-code-iac-cookbook))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Kubernetes documentation offers some more best practices for running clusters: [https://kubernetes.io/docs/setup/best-practices/](https://kubernetes.io/docs/setup/best-practices/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
