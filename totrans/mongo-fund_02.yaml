- en: 2\. Documents and Data Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2. 文档和数据类型
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter introduces you to MongoDB documents, their structure, and data
    types. For those who are new to the JSON model, this chapter will also serve as
    a short introduction to JSON. You will identify the basic concepts and data types
    of JSON documents and compare the document-based storage of MongoDB with the tabular
    storage of relational databases. You will learn how to represent complex data
    structures in MongoDB using embedded objects and arrays. By the end of this chapter,
    you will understand the need for precautionary limits and restrictions on MongoDB documents.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了MongoDB文档、它们的结构和数据类型。对于那些对JSON模型不熟悉的人来说，本章也将作为JSON的简要介绍。您将识别JSON文档的基本概念和数据类型，并将MongoDB的基于文档的存储与关系数据库的表格存储进行比较。您将学习如何在MongoDB中使用嵌入对象和数组表示复杂的数据结构。通过本章的学习，您将了解对MongoDB文档的预防性限制和限制的需求。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we learned how MongoDB, as a NoSQL database, differs
    from traditional relational databases. We covered the basic features of MongoDB,
    including its architecture, its different versions, and MongoDB Atlas.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解了作为NoSQL数据库的MongoDB与传统关系数据库的不同之处。我们涵盖了MongoDB的基本特性，包括其架构、不同版本和MongoDB
    Atlas。
- en: MongoDB is designed for modern-world applications. We live in a world where
    requirements change rapidly. We want to build lightweight and flexible applications
    that can quickly adapt to these new requirements and ship them to production as
    quickly as possible. We want our databases to become agile so that they can adapt
    to the ever-changing needs of our applications, reduce downtime, scale out easily,
    and perform efficiently. MongoDB is a perfect fit for all such needs.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB是为现代应用程序设计的。我们生活在一个需求迅速变化的世界。我们希望构建轻量灵活的应用程序，能够快速适应这些新需求，并尽快将其部署到生产环境中。我们希望我们的数据库变得敏捷，以便能够适应应用程序不断变化的需求，减少停机时间，轻松扩展，并且性能高效。MongoDB完全符合所有这些需求。
- en: One of the major factors that make MongoDB an agile database is its document-based
    data model. Documents are widely accepted as a flexible way of transporting information.
    You might have come across many applications that exchange data in the form of
    **JavaScript Object Notation** (**JSON**) documents. MongoDB stores data in Binary
    JSON (BSON) format and represents it in human readable JSON. This means that when
    we use MongoDB, we see the data in JSON format. This chapter begins with an overview
    of the JSON and BSON formats, followed by details of MongoDB documents and data
    types.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 使MongoDB成为一种敏捷数据库的主要因素之一是其基于文档的数据模型。文档被广泛接受为传输信息的灵活方式。您可能已经遇到许多以JSON文档形式交换数据的应用程序。MongoDB以二进制JSON（BSON）格式存储数据，并以人类可读的JSON表示数据。这意味着当我们使用MongoDB时，我们看到的数据是以JSON格式呈现的。本章以JSON和BSON格式的概述开始，然后介绍MongoDB文档和数据类型的详细信息。
- en: Introduction to JSON
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON介绍
- en: JSON is a full-text, lightweight format for data representation and transportation.
    JavaScript's simple representation of objects gave birth to JSON. Douglas Crockford,
    who was one of the developers of the JavaScript language, came up with the proposal
    for the JSON specification that defines the grammar and data types for the JSON syntax.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: JSON是一种用于数据表示和传输的全文本、轻量级格式。JavaScript对对象的简单表示形式催生了JSON。道格拉斯·克罗克福德（Douglas Crockford）是JavaScript语言的开发人员之一，他提出了JSON规范的建议，定义了JSON语法的语法和数据类型。
- en: The JSON specification became a standard in 2013\. If you have been developing
    applications for a while, you might have seen the transition of applications from
    XML to JSON. JSON offers a human-readable, plain-text way of representing data.
    In comparison to XML, where information is wrapped inside tags, and lots of tags
    make it look bulky, JSON offers a compact and natural format where you can easily
    focus on the information.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: JSON规范于2013年成为标准。如果您已经开发了一段时间的应用程序，您可能已经看到应用程序从XML转换为JSON的过渡。JSON提供了一种人类可读的纯文本表示数据的方式。与XML相比，其中信息被包裹在标签内，而且大量标签使其看起来笨重，JSON提供了一种紧凑和自然的格式，您可以轻松地专注于信息。
- en: To read or write information in JSON or XML format, the programming languages
    use their respective parsers. As XML documents are bound by schema definitions
    and tag library definitions, parsers need to do a lot of work to read and validate
    **XML Schema Definition** (**XSD**) and **Tag Library Descriptors** (**TLDs**).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以JSON或XML格式读取或写入信息，编程语言使用它们各自的解析器。由于XML文档受模式定义和标签库定义的约束，解析器需要做大量工作来读取和验证XML模式定义（XSD）和标签库描述符（TLD）。
- en: On the other hand, JSON does not have any schema definition, and JSON parsers
    only need to deal with opening and closing brackets and colons. Different programming
    languages have different ways of representing language constructs, such as objects,
    lists, arrays, variables, and more. When two systems, written in two different
    programming languages, want to exchange data, they need to have a mutually agreed
    standard for representing information. JSON provides that standard with its lightweight
    format. The objects, collections, and variables of any programming language can
    naturally fit into the JSON structure. Most programming languages have parsers
    that can translate their own objects to and from JSON documents.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，JSON没有任何模式定义，JSON解析器只需要处理开放和关闭括号以及冒号。不同的编程语言有不同的表示语言构造的方式，例如对象、列表、数组、变量等。当两个用不同编程语言编写的系统想要交换数据时，它们需要有一个共同约定的标准来表示信息。JSON以其轻量级格式提供了这样的标准。任何编程语言的对象、集合和变量都可以自然地适应JSON结构。大多数编程语言都有解析器，可以将它们自己的对象转换为JSON文档，反之亦然。
- en: Note
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: JSON does not impose JavaScript language internals on other languages. JSON
    is the syntax for language-independent data representation. The grammar that defines
    the JSON format was derived from JavaScript's syntax. However, to use JSON, programmers
    do not need to know JavaScript internals
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: JSON Syntax
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JSON documents or objects are a plain-text set of zero or more key-value pairs.
    The key-value pairs form an object, and if the value is a collection of zero or
    more values, they form an array. JSON has a very simple structure where, by only
    using a set of curly braces (`{}`), square brackets (`[]`), colons (`:`), and
    commas(`,`), you can represent any complex piece of information in a compact form.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'In a JSON object, key-value pairs are enclosed within curly braces: `{}`. Within
    an object, the key is always a string. However, the value can be any of JSON''s
    specified types. The JSON grammar specification does not define any order for
    JSON fields and can be represented as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding document represents a valid JSON object that has a single key-value
    pair. Moving on to JSON arrays, an array is a set of zero or more values that
    are enclosed within square brackets, `[]`, and separated by commas. While most
    programming languages have support for ordered arrays, JSON''s specification does
    not specify the order for array elements. Let''s take a look at an example array
    that has three fields separated by commas:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now that we have looked at JSON syntax, let''s consider a sample JSON document
    that contains the basic information of a company. The example demonstrates how
    naturally a piece of information can be presented in document format, making it
    easily readable:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'From the preceding document, we can see the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Company name and address, both being string fields
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Foundation year, number of employees, and revenue as numeric fields
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The company's Twitter username as null or no information
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON Data Types
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike many programming languages, JSON supports a limited and basic set of
    data types, as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '**String**: Refers to plain text'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Number**: Consists of all numeric fields'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`True` or `False`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Object**: Other embedded JSON objects'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Array**: Collection of fields'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Null**: Special value to denote fields without any value'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the major reasons for the wide acceptance of JSON is its language-independent
    format. Different languages have different data types. Some languages support
    **statically typed variables**, while some support **dynamically typed variables**.
    If JSON had many data types, it would be more in line with a number of languages—though,
    not all.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: JSON is a data exchange format. When an application transmits a piece of information
    over the wire, the information gets serialized into plain strings. The receiving
    application then deserializes the information into its objects so that it becomes
    available to use. The presence of basic data types provided by JSON reduces complexity
    during this process.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Thus, JSON keeps it simple and minimal in terms of data types. JSON parsers
    specific to programming languages can easily relate basic data types to the most
    specific types the language provides.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: JSON and Numbers
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As per the JSON specification, a number is just a sequence of digits. It does
    not differentiate between numbers such as `integer`, `float`, or `long`. Additionally,
    it restricts the range limits of numbers. This leads to greater flexibility when
    data is transferred or represented.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: However, there are some challenges involved. Most programming languages represent
    numbers in the form of `integer`, `float`, or `long`. When a piece of information
    is presented in JSON, the parsers cannot anticipate the exact format or range
    of a numeric field in the entire document. To avoid number format corruption or
    the loss of precision of numeric fields, the two parties exchanging data should
    agree and follow a certain contract in advance.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, say you are reading a movie record set in the form of JSON documents.
    When you look at the first record, you find the `audience_rating` field is an
    `integer`. However, when you reach the next record, you realize it is a `float`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您正在阅读以JSON文档形式呈现的电影记录集。当您查看第一条记录时，您发现`audience_rating`字段是一个`整数`。然而，当您到达下一条记录时，您意识到它是一个`浮点数`：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We will look at how this issue can be overcome in an upcoming section, *BSON*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在即将到来的*BSON*部分中看看如何克服这个问题。
- en: JSON and Dates
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON和日期
- en: 'As you may have noticed, JSON documents do not support the `Date` data type,
    and all dates are represented as plain strings. Let''s look at an example of a
    few JSON documents, each of which has a valid date representation:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，JSON文档不支持`Date`数据类型，所有日期都表示为普通字符串。让我们看一个例子，其中有几个JSON文档，每个文档都有一个有效的日期表示：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Although all the documents represent the same date, they are written in a different
    format. Different systems, based on their local standards, use different formats
    to write the same date and time instances.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管所有文档表示相同的日期，但它们以不同的格式编写。根据其本地标准，不同的系统使用不同的格式来编写相同的日期和时间实例。
- en: Like the examples of JSON numbers, the parties exchanging the information need
    to standardize the `Date` format during the transfers.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与JSON数字的示例一样，交换信息的各方需要在传输过程中标准化`Date`格式。
- en: Note
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that the JSON specification defines syntax and grammar for data representation.
    However, how you read the data depends on the interpreters of the languages and
    their data exchange contracts.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，JSON规范定义了数据表示的语法和语法。然而，您如何读取数据取决于语言的解释器和它们的数据交换协议。
- en: 'Exercise 2.01: Creating Your Own JSON Document'
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.01：创建您自己的JSON文档
- en: Now that you have learned the basics of JSON syntax, it is time to put this
    knowledge into practice. Suppose your organization wants to build a dataset of
    movies and series, and they want to use MongoDB to store the records. As a proof
    of concept, they ask you to choose a random movie and represent it in JSON format.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了JSON语法的基础知识，是时候将这些知识付诸实践了。假设您的组织想要构建一个电影和系列节目的数据集，并且他们想要使用MongoDB来存储记录。作为概念验证，他们要求您选择一部随机电影，并以JSON格式表示它。
- en: 'In this exercise, you will write your first basic JSON document from scratch
    and verify whether it is a grammatically valid document. For this exercise, you
    will consider a sample movie, `Beauty and the Beast`, and refer to the `Movie
    ID`, `Movie Title`, `Release Year`, `Language`, `IMDb Rating` `Genre`, `Director`,
    and `Runtime` fields, which contain the following information:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将从头开始编写您的第一个基本JSON文档，并验证它是否是一个语法上有效的文档。对于这个练习，您将考虑一部样本电影，`美女与野兽`，并参考`电影ID`、`电影标题`、`发行年份`、`语言`、`IMDb评分`、`类型`、`导演`和`时长`字段，其中包含以下信息：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To successfully create a JSON document for the preceding listed fields, first
    differentiate each field into key-value pairs. Execute the following steps to
    achieve the desired result:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功地为上述列出的字段创建一个JSON文档，首先将每个字段区分为键值对。执行以下步骤以实现所需的结果：
- en: Open a JSON validator—for example, [https://jsonlint.com/](https://jsonlint.com/).
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个JSON验证器，例如[https://jsonlint.com/](https://jsonlint.com/)。
- en: 'Type the preceding information in JSON format, which looks as follows:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将上述信息以JSON格式输入，如下所示：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Remember, a JSON document always starts with `{` and ends with `}`. Each element
    is separated by a colon (`:`) and the key-value pairs are separated by a comma
    (`,`).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，JSON文档总是以`{`开头，以`}`结尾。每个元素由冒号(`:`)分隔，键值对由逗号(`,`)分隔。
- en: 'Click on `Validate JSON` to validate the code. The following screenshot displays
    the expected output and validity of the JSON document:![Figure 2.1: The JSON document
    and its validity check'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击`验证JSON`以验证代码。以下屏幕截图显示了JSON文档的预期输出和有效性：![图2.1：JSON文档及其有效性检查
- en: '](img/B15507_02_01.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_02_01.jpg)'
- en: 'Figure 2.1: The JSON document and its validity check'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：JSON文档及其有效性检查
- en: In this exercise, you modeled a movie record into a document format and created
    a grammatically valid JSON object. To practice it more, you can consider any general
    item, such as a product you recently bought or a book you read, and model it as
    a valid JSON document. In the next section, we will look at a brief overview of
    MongoDB's BSON.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将把一部电影记录建模成文档格式，并创建一个语法上有效的JSON对象。要更多地练习它，您可以考虑任何一般项目，比如您最近购买的产品或您阅读的一本书，并将其建模为一个有效的JSON文档。在下一节中，我们将简要概述MongoDB的BSON。
- en: BSON
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BSON
- en: When you work with MongoDB using database clients such as mongo shell, MongoDB
    Compass, or the Collections Browser in Mongo Atlas, you always see the documents
    in human readable JSON format. However, internally, MongoDB documents are stored
    in a binary format called BSON. BSON documents are not human-readable, and you
    will never have to deal with them directly. Before we explore MongoDB documents
    in detail, let's have a quick overview of the BSON features that benefit the MongoDB
    document structure.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用数据库客户端（如mongo shell、MongoDB Compass或Mongo Atlas中的Collections Browser）与MongoDB一起工作时，您总是以人类可读的JSON格式看到文档。然而，在内部，MongoDB文档以一种称为BSON的二进制格式存储。BSON文档不是人类可读的，您永远不需要直接处理它们。在我们详细探讨MongoDB文档之前，让我们快速概述一下BSON的特性，这些特性有益于MongoDB文档结构。
- en: Like JSON, BSON was introduced in 2009 by MongoDB. Although it was invented
    by MongoDB, many other systems also use it as a format for data storage or transportation.
    BSON specifications are primarily based on JSON as they inherit all the good features
    of JSON, such as the syntax and flexibility. It also provides a few additional
    features, which are specifically designed for improving storage efficiency, ease
    of traversal, and a few data type enhancements to avoid the type conflicts that
    we saw in the *Introduction to JSON* section.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与JSON一样，BSON是由MongoDB在2009年引入的。尽管它是由MongoDB发明的，但许多其他系统也将其用作数据存储或传输的格式。BSON规范主要基于JSON，因为它继承了JSON的所有优点，如语法和灵活性。它还提供了一些额外的功能，专门设计用于提高存储效率，便于遍历，并避免类型冲突的一些数据类型增强，这些冲突是我们在*JSON简介*部分中看到的。
- en: 'As we have already covered the JSON features in detail, let''s focus on the
    enhancements that BSON provides:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经详细介绍了JSON的特性，让我们专注于BSON提供的增强功能：
- en: BSON documents are designed to be more efficient than JSON as they occupy less
    space and provide faster traversal.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BSON文档的设计旨在比JSON更高效，因为它们占用更少的空间并提供更快的遍历速度。
- en: With each document, BSON stores some **meta-information**, such as the length
    of the fields or the length of the sub-documents. The meta-information makes the
    document parsing, as well as traversing, faster.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个文档，BSON存储一些**元信息**，例如字段的长度或子文档的长度。元信息使文档解析和遍历更快。
- en: BSON documents have **ordered arrays**. Each element in an array is prefixed
    by its index position and can be accessed using its index number.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BSON文档具有**有序数组**。数组中的每个元素都以其索引位置为前缀，并可以使用其索引号进行访问。
- en: BSON provides many **additional data types**, such as dates, integers, doubles,
    byte arrays, and more. We will cover BSON data types later, in the next section.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BSON提供了许多**额外的数据类型**，如日期、整数、双精度、字节数组等。我们将在下一节中详细介绍BSON数据类型。
- en: Note
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Because of the binary format, BSON documents are compact in nature. However,
    some smaller documents end up occupying more space compared to JSON documents
    with the same information. This is because of the meta-information added to each
    document. However, for large documents, BSON is more space efficient.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于二进制格式，BSON文档在性质上是紧凑的。但是，一些较小的文档最终占用的空间比具有相同信息的JSON文档更多。这是因为每个文档都添加了元信息。但是，对于大型文档，BSON更节省空间。
- en: Now that we have completed a detailed introduction to JSON and BSON enhancements,
    let's now learn about MongoDB documents.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了对JSON和BSON增强功能的详细介绍，让我们现在学习一下MongoDB文档。
- en: MongoDB Documents
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB文档
- en: A MongoDB database is composed of collections and documents. A database can
    have one or more collections, and each collection can store one or more related
    BSON documents. In comparison to RDBMS, collections are analogous to tables and
    documents are analogous to rows within a table. However, documents are much more
    flexible compared with the rows in a table.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB数据库由集合和文档组成。一个数据库可以有一个或多个集合，每个集合可以存储一个或多个相关的BSON文档。与关系型数据库相比，集合类似于表，文档类似于表中的行。但是，与表中的行相比，文档更加灵活。
- en: RDBMSes consist of a tabular data model that comprises rows and columns. However,
    your applications may need to support more complex data structures, such as a
    nested object or a collection of objects. Tabular databases restrict the storage
    of such complex data structures. In such cases, you will have to split your data
    into multiple tables and change the application's object structures accordingly.
    On the other hand, the document-based data model of MongoDB allows your application
    to store and retrieve more complex object structures due to the flexible JSON-like
    format of the documents.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库由行和列组成的表格数据模型。但是，您的应用程序可能需要支持更复杂的数据结构，例如嵌套对象或对象集合。表格数据库限制了这种复杂数据结构的存储。在这种情况下，您将不得不将数据拆分成多个表，并相应地更改应用程序的对象结构。另一方面，MongoDB的基于文档的数据模型允许您的应用程序存储和检索更复杂的对象结构，因为文档具有灵活的类似JSON的格式。
- en: 'The following list details some of the major features of MongoDB''s document-based
    data model:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表详细介绍了MongoDB基于文档的数据模型的一些主要特性：
- en: The documents provide a flexible and natural way of representing data. The data
    can be stored as is, without having to transform it into a database structure.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文档提供了一种灵活和自然的表示数据的方式。数据可以按原样存储，而无需将其转换为数据库结构。
- en: The objects, nested objects, and arrays that are within a document are easily
    relatable to your programming language's object structure.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文档中的对象、嵌套对象和数组与您编程语言的对象结构容易相关联。
- en: With the ability of a flexible schema, the documents are agile in practice.
    They continuously integrate with application changes and new features without
    any major schema changes or downtimes.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 具有灵活模式的能力使文档在实践中更加灵活。它们可以持续集成应用程序的变化和新功能，而无需进行任何重大的模式更改或停机。
- en: Documents are self-contained pieces of data. They avoid the need to read multiple
    relational tables and table-joins to understand a complete unit of information.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文档是自包含的数据片段。它们避免了阅读多个关系表和表连接以理解完整信息单元的需要。
- en: The documents are extensible. You can use documents to store the entire object
    structure, use it as a map or a dictionary, as a key-value pair for quick lookup,
    or have a flat structure that resembles a relational table.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文档是可扩展的。您可以使用文档来存储整个对象结构，将其用作映射或字典，作为快速查找的键值对，或者具有类似关系表的扁平结构。
- en: Documents and Flexibility
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档和灵活性
- en: 'As stated earlier, MongoDB documents are a flexible way of storing data. Consider
    the following example. Imagine you are developing a movie service where you need
    to create a movie database. A movie record in a simple MongoDB document will look
    like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面所述，MongoDB文档是一种灵活的存储数据的方式。考虑以下示例。想象一下，您正在开发一个电影服务，需要创建一个电影数据库。一个简单的MongoDB文档中的电影记录将如下所示：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'However, storing only the title is not enough. You need more fields. Now, let''s
    consider a few more basic fields. With a list of movies in the MongoDB database,
    the documents will look like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅存储标题是不够的。您需要更多的字段。现在，让我们考虑一些更基本的字段。在MongoDB数据库中有一系列电影，文档将如下所示：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Say you are using an RDBMS table instead. On an RDBMS platform, you need to
    define your schema at the beginning, and to do that, first, you must think about
    the columns and data types. You might then come up with a `CREATE TABLE` query
    as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在使用RDBMS表。在RDBMS平台上，您需要在开始时定义您的模式，为此，首先您必须考虑列和数据类型。然后，您可能会提出一个`CREATE TABLE`查询，如下所示：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This query is a clear indication that relational tables are bound by a definition
    called the `id` field and `user_ratings` can never be a string.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询清楚地表明，关系表受到一个叫做`id`字段的定义的限制，而`user_ratings`永远不能是一个字符串。
- en: 'With a few records inserted, the table will appear as in *Figure 2.2*. This
    table is as good as a MongoDB document:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 插入了一些记录后，表将显示为*图2.2*。这个表和一个MongoDB文档一样好：
- en: '![Figure 2.2: The movies table'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.2：电影表'
- en: '](img/B15507_02_02.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_02_02.jpg)'
- en: 'Figure 2.2: The movies table'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：电影表
- en: 'Now, say you want to include the IMDb ratings for each of the movies listed
    in the table, and going forward, all the movies will have `imdb_ratings` included
    in the table. For an existing list of movies, `imdb_ratings` can be set to `null`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设您想要在表中列出的每部电影中包括IMDb评分，并且今后，所有电影都将在表中包括`imdb_ratings`。对于现有的电影列表，`imdb_ratings`可以设置为`null`：
- en: 'To meet this requirement, you will include an `ALTER TABLE` query in your syntax:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足这个要求，您将在您的语法中包含一个`ALTER TABLE`查询：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The query is correct, but there can be instances where table alterations may
    block the table for some time, especially for large datasets. When a table is
    blocked, other read and write operations will have to wait until the table is
    altered, which may lead to downtime. Now, let's see how we can tackle the same
    situation in MongoDB.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 查询是正确的，但是在某些情况下，表的更改可能会阻塞表一段时间，特别是对于大型数据集。当表被阻塞时，其他读写操作将不得不等待表被更改，这可能导致停机。现在，让我们看看如何在MongoDB中解决同样的情况。
- en: MongoDB supports a flexible schema, and there is no specific schema definition.
    Without altering anything on the database or the collection, you can simply insert
    a new movie with the additional field. The collection will behave exactly like
    the modified table of the movies, where the latest insertions will have `imdb_ratings`
    and the previous ones will return a `null` value. In MongoDB documents, a non-existent
    field is always considered `null`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB支持灵活的模式，并且没有特定的模式定义。在不改变数据库或集合上的任何内容的情况下，您可以简单地插入一个带有额外字段的新电影。集合的行为将与修改后的电影表完全相同，最新插入的将具有`imdb_ratings`，而之前的将返回`null`值。在MongoDB文档中，不存在的字段始终被视为`null`。
- en: 'Now, the whole collection will look similar to the following screenshot. You
    will notice that the last movie has a new field, `imdb_ratings`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，整个集合将看起来类似于以下的屏幕截图。您会注意到最后一个电影有一个新字段，`imdb_ratings`：
- en: '![Figure 2.3: Result for imdb_ratings for the movies collection'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.3：电影集合的imdb_ratings结果'
- en: '](img/B15507_02_03.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_02_03.jpg)'
- en: 'Figure 2.3: Result for imdb_ratings for the movies collection'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：电影集合的imdb_ratings结果
- en: The preceding examples clearly indicate that documents are extremely flexible
    in comparison to tabular databases. Documents can incorporate changes on the go
    without any downtime.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子清楚地表明，与表格数据库相比，文档非常灵活。文档可以在不停机的情况下进行更改。
- en: MongoDB Data Types
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB数据类型
- en: You have learned how MongoDB stores JSON-like documents. You have also seen
    various documents and read the information stored within them and seen how flexible
    these documents are to store different types of data structures, irrespective
    of the complexity of your data.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经学会了MongoDB如何存储类似JSON的文档。您还看到了各种文档，并读取了其中存储的信息，并看到了这些文档在存储不同类型的数据结构时有多灵活，无论您的数据有多复杂。
- en: In this section, you will learn about the various data types supported by MongoDB's
    BSON documents. Using the right data types in your documents is very important
    as correct data types help you use the database features more effectively, avoid
    data corruption, and improve data usability. MongoDB supports all the data types
    from JSON and BSON. Let's look at each in detail, with examples.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将了解MongoDB的BSON文档支持的各种数据类型。在文档中使用正确的数据类型非常重要，因为正确的数据类型可以帮助您更有效地使用数据库功能，避免数据损坏，并提高数据的可用性。MongoDB支持JSON和BSON中的所有数据类型。让我们详细看看每种类型，以及示例。
- en: Strings
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: A string is a basic data type used to represent text-based fields in a document.
    It is a plain sequence of characters. In MongoDB, the string fields are UTF-8
    encoded, and thus they support most international characters. The MongoDB drivers
    for various programming languages convert the string fields to UTF-8 while reading
    or writing data from a collection.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是用来表示文本字段的基本数据类型。它是一系列普通字符。在MongoDB中，字符串字段是UTF-8编码的，因此它们支持大多数国际字符。各种编程语言的MongoDB驱动程序在从集合中读取或写入数据时将字符串字段转换为UTF-8。
- en: 'A string with plain-text characters appears as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包含纯文本字符的字符串如下所示：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A string with random characters and whitespaces will appear as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包含随机字符和空格的字符串将显示如下：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In JSON, a value that is wrapped in double quotes is considered a string. Consider
    the following example in which a valid number and date are wrapped in double quotes,
    both forming a string:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSON中，用双引号括起来的值被视为字符串。考虑以下示例，其中一个有效的数字和日期被双引号括起来，都形成一个字符串：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: An interesting fact about MongoDB string fields is that they support search
    capabilities with regular expressions. This means you can search for documents
    by providing the full value of a text field or by providing only part of the string
    value using regular expressions.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有关MongoDB字符串字段的一个有趣事实是，它们支持使用正则表达式进行搜索。这意味着您可以通过提供文本字段的完整值或仅提供部分字符串值来使用正则表达式搜索文档。
- en: Numbers
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字
- en: 'A number is JSON''s basic data type. A JSON document does not specify whether
    a number is an integer, a float, or *long*:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 数字是JSON的基本数据类型。 JSON文档不指定数字是整数，浮点数还是*长*：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'However, MongoDB supports the following types of numbers:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，MongoDB支持以下类型的数字：
- en: '`double`: 64-bit floating point'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double`：64位浮点'
- en: '`int`: 32-bit signed integer'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`：32位有符号整数'
- en: '`long`: 64-bit unsigned integer'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long`：64位无符号整数'
- en: '`decimal`: 128-bit floating point – which is IEE 754-compliant'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decimal`：128位浮点 - 符合IEE 754标准'
- en: When you are working with a programming language, you don't have to worry about
    these data types. You can simply program using the language's native data types.
    The MongoDB drivers for respective languages take care of encoding the language-specific
    numbers to one of the previously listed data types.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用编程语言时，您不必担心这些数据类型。您可以简单地使用语言的本机数据类型进行编程。各种语言的MongoDB驱动程序负责将语言特定的数字编码为先前列出的数据类型之一。
- en: 'If you are working on the mongo shell, you get three wrappers to handle: `integer`,
    `long`, and `decimal`. The Mongo shell is based on JavaScript, and thus all the
    documents are represented in JSON format. By default, it treats any number as
    a 64-bit floating point. However, if you want to explicitly use the other types,
    you can use the following wrappers.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在mongo shell上工作，您将获得三个包装器来处理：`integer`，`long`和`decimal`。 Mongo shell基于JavaScript，因此所有文档都以JSON格式表示。默认情况下，它将任何数字视为64位浮点数。但是，如果要明确使用其他类型，可以使用以下包装器。
- en: '`NumberInt`: The `NumberInt` constructor can be used if you want the number
    to be saved as a 32-bit integer and not as a 64-bit float:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`NumberInt`：如果要将数字保存为32位整数而不是64位浮点数，则可以使用`NumberInt`构造函数：'
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding snippet, the first number, `plainNum`, is initialized with
    a sequence of digits without mentioning any explicit data type. Therefore, by
    default, it will be treated as a *64-bit floating-point number* (also known as
    a **double**).
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在上面的片段中，第一个数字`plainNum`是使用未提及任何显式数据类型的数字序列初始化的。因此，默认情况下，它将被视为*64位浮点数*（也称为**double**）。
- en: '`explicitInt`, however, is initialized with an integer-type constructor and
    a string representation of a number, and so MongoDB reads the number in an argument
    as a *32-bit integer*.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但是，`explicitInt`是使用整数类型构造函数和数字的字符串表示初始化的，因此MongoDB将参数中的数字读取为*32位整数*。
- en: However, in the `explicitInt_double` initialization, the number provided in
    the constructor argument doesn't have double quotes. Therefore, it will be treated
    as a *64-bit float*—that is, a **double**—and used to form a *32-bit integer*.
    But as the provided number fits in the integer range, no change is seen.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但是，在`explicitInt_double`初始化中，构造函数参数中提供的数字没有双引号。因此，它将被视为*64位浮点数* - 也就是**double**
    - 并用于形成*32位整数*。但是，由于提供的数字适合整数范围，因此不会看到任何更改。
- en: 'When you print the preceding numbers, they look as follows:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您打印上述数字时，它们看起来如下：
- en: '![Figure 2.4: Output for the plainNum, explicitInt, and explicitInt_double'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：plainNum，explicitInt和explicitInt_double的输出
- en: '](img/B15507_02_04.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_02_04.jpg)'
- en: 'Figure 2.4: Output for the plainNum, explicitInt, and explicitInt_double'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：plainNum，explicitInt和explicitInt_double的输出
- en: '`NumberLong`: `NumberLong` wrappers are similar to `NumberInt`. The only difference
    is that they are stored as 64-bit integers. Let''s try it on the shell:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`NumberLong`：`NumberLong`包装器类似于`NumberInt`。唯一的区别是它们存储为64位整数。让我们在shell上尝试一下：'
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s print the documents in the shell:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在shell中打印文档：
- en: '![Figure 2.5: MongoDB shell output'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.5：MongoDB shell输出'
- en: '](img/B15507_02_05.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_02_05.jpg)'
- en: 'Figure 2.5: MongoDB shell output'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5：MongoDB shell输出
- en: '`NumberDecimal`: This wrapper stores the given number as a 128-bit IEEE 754
    decimal format. The `NumberDecimal` constructor accepts both a string and a double
    representation of the number:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`NumberDecimal`：此包装器将给定数字存储为128位IEEE 754十进制格式。`NumberDecimal`构造函数接受数字的字符串和双精度表示：'
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We are passing a string representation of a decimal number to `explicitDecimal`.
    However, `explicitDecimal_double` is created using a `double`. When we print the
    results, they appear slightly differently:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个十进制数的字符串表示传递给`explicitDecimal`。但是，`explicitDecimal_double`是使用`double`创建的。当我们打印结果时，它们看起来略有不同：
- en: '![Figure 2.6: Output for explicitDecimal and explicitDecimal_double'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.6：explicitDecimal和explicitDecimal_double的输出'
- en: '](img/B15507_02_06.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_02_06.jpg)'
- en: 'Figure 2.6: Output for explicitDecimal and explicitDecimal_double'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6：explicitDecimal和explicitDecimal_double的输出
- en: The second number has been appended with trailing zeros. This is because of
    the internal parsing of the numbers. When we pass a double value to `NumberDecimal`,
    the argument is parsed to BSON's double, which is then converted to a 128-bit
    decimal with a precision of 15 digits.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个数字已附加尾随零。这是由于数字的内部解析。当我们将双精度值传递给`NumberDecimal`时，参数被解析为BSON的双精度，然后转换为具有15位数字精度的128位小数。
- en: 'During this conversion, the decimal numbers are rounded off and may lose precision.
    Let''s look at the following example:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在此转换过程中，十进制数将四舍五入并可能失去精度。让我们看下面的例子：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s print the numbers and inspect the output:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打印数字并检查输出：
- en: '![Figure 2.7: Output for dec and decDbl'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7：dec和decDbl的输出
- en: '](img/B15507_02_07.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_02_07.jpg)'
- en: 'Figure 2.7: Output for dec and decDbl'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7：dec和decDbl的输出
- en: It is evident that when a double is passed to `NumberDecimal`, there is a chance
    of a loss of precision. Therefore, it is important to always use string-based
    constructors when using `NumberDecimal`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，当双精度值传递给`NumberDecimal`时，存在失去精度的可能。因此，在使用`NumberDecimal`时始终使用基于字符串的构造函数非常重要。
- en: Booleans
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔值
- en: 'The Boolean data type is used to represent whether something is true or false.
    Therefore, the value of a valid Boolean field is either `true` or `false`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔数据类型用于表示某事是真还是假。因此，有效布尔字段的值要么是`true`，要么是`false`：
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The values do not have double quotes. If you wrap them in double quotes, they
    will be treated as strings.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 值没有双引号。如果您用双引号括起来，它们将被视为字符串。
- en: Objects
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象
- en: The object fields are used to represent nested or embedded documents—that is,
    a field whose value is another valid JSON document.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对象字段用于表示嵌套或嵌入文档，即其值是另一个有效的JSON文档。
- en: 'Let''s take a look at the following example from the airbnb dataset:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下来自airbnb数据集的以下示例：
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The value of the host field is another valid JSON. MongoDB uses a dot notation
    (`.`) to access the embedded objects. To access an embedded document, we will
    create a variable of the listing on the mongo shell:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 主机字段的值是另一个有效的JSON。MongoDB使用点表示法（`.`）来访问嵌入对象。要访问嵌入文档，我们将在mongo shell上创建一个列表的变量：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To print only the host details, use the dot notation (`.`) to get the embedded
    object, as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要仅打印主机详细信息，请使用点表示法（`.`）获取嵌入对象，如下所示：
- en: '![Figure 2.8: Output for the embedded object'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.8：嵌入对象的输出'
- en: '](img/B15507_02_08.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_02_08.jpg)'
- en: 'Figure 2.8: Output for the embedded object'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8：嵌入对象的输出
- en: 'Using a similar notation, you can also access a specific field of the embedded
    document as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类似的表示法，您还可以访问嵌入文档的特定字段，如下所示：
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Embedded documents can have further documents within them. Having embedded documents
    makes a MongoDB document a piece of self-contained information. To record the
    same information in an RDBMS database, you will have to create the listing and
    the host as two separate tables with a foreign key reference in between, and join
    the data from both tables to get a piece of information.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入文档可以包含其中的更多文档。具有嵌入文档使MongoDB文档成为一个自包含的信息片段。要在RDBMS数据库中记录相同的信息，您将不得不创建列表和主机作为两个单独的表，并在两者之间创建一个外键引用，并从两个表中获取信息。
- en: Along with embedded documents, MongoDB also supports links between the documents
    of two different collections, which resembles having foreign key references.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 除了嵌入文档之外，MongoDB还支持两个不同集合的文档之间的链接，这类似于具有外键引用。
- en: 'Exercise 2.02: Creating Nested Objects'
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.02：创建嵌套对象
- en: Your organization is happy with the movie representation so far. Now they have
    come up with a requirement to include the IMDb ratings and the number of votes
    that derived the rating. They also want to incorporate Tomatometer ratings, which
    include the user ratings and critics ratings along with fresh and rotten scores.
    Your task is to modify the document to update the `imdb` field to include the
    number of votes and add a new field called `tomatoes`, which contains the Rotten
    Tomato ratings.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您的组织对电影表示感到满意。现在他们提出了一个要求，要包括IMDb评分和导致评分的投票数。他们还希望包含番茄表评分，其中包括用户评分和评论家评分以及新鲜和烂的分数。您的任务是修改文档，更新`imdb`字段以包括投票数，并添加一个名为`tomatoes`的新字段，其中包含烂番茄评分。
- en: 'Recall the JSON document of a sample movie record that you created in *Exercise
    2.01*, *Creating Your Own JSON Document*:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下您在*练习2.01*中创建的样本电影记录的JSON文档，*创建您自己的JSON文档*：
- en: '[PRE23]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following steps will help modify the IMDb ratings:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助修改IMDb评分：
- en: 'The existing `imdb_rating` field indicates the IMDb rating score, so add an
    additional field to represent the vote count. However, both fields are closely
    related to each other and will always be used together. Therefore, group them
    together in a single document:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现有的`imdb_rating`字段表示IMDb评分，因此添加一个额外的字段来表示投票数。然而，这两个字段彼此密切相关，并且将始终一起使用。因此，将它们组合在一个单独的文档中：
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding document with two fields represents the complete IMDb rating.
    Replace the current `imdb_rating` field with the one you just created:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的文档具有两个字段，表示完整的IMDb评分。用您刚创建的字段替换当前的`imdb_rating`字段：
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This `imdb` field with its value of an embedded object represents the IMDb ratings.
    Now, add the Tomatometer ratings.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个带有嵌入对象值的`imdb`字段表示IMDb评分。现在，添加番茄表评分。
- en: 'As stated previously, the Tomatometer rating includes viewer ratings and critics
    ratings, along with the fresh score and the rotten score. Like the IMDb ratings,
    both `Viewer Ratings` and `Critics Ratings` will have a `rating` field and a `votes`
    field. Write these two documents separately:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，番茄表评分包括观众评分和评论家评分，以及新鲜分数和烂分数。与IMDb评分一样，`观众评分`和`评论家评分`都将有一个`评分`字段和一个`投票`字段。分别编写这两个文档：
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As both ratings are related, group them together in a single document:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于两个评分相关，将它们组合在一个单独的文档中：
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add the `fresh` and `rotten` scores as per the description:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据描述添加`fresh`和`rotten`分数：
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following output represents the Tomatometer ratings with the new `tomatoes`
    field in our movie record:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出表示了我们电影记录中新的`tomatoes`字段的番茄表评分：
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, validate your document with any online JSON validator (in our case,
    [https://jsonlint.com/](https://jsonlint.com/)). Click on `Validate JSON` to validate
    the code:![Figure 2.9: Validation of the JSON document'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用任何在线JSON验证器（在我们的案例中，[https://jsonlint.com/](https://jsonlint.com/)）验证您的文档。单击“验证JSON”以验证代码：![图2.9：验证JSON文档
- en: '](img/B15507_02_09.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_02_09.jpg)'
- en: 'Figure 2.9: Validation of the JSON document'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9：验证JSON文档
- en: Your movie record is now updated with detailed IMBb ratings and the new `tomatoes`
    rating. In this exercise, you practiced creating two nested documents to represent
    IMDb ratings and Tomatometer ratings. Now that we have covered nested or embedded
    objects, let's learn about arrays.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 您的电影记录现在已更新为详细的IMBb评分和新的`tomatoes`评分。在这个练习中，您练习了创建两个嵌套文档来表示IMDb评分和番茄表评分。现在我们已经涵盖了嵌套或嵌入对象，让我们了解一下数组。
- en: Arrays
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: 'A field with an **array** type has a collection of zero or more values. In
    MongoDB, there is no limit to how many elements an array can contain or how many
    arrays a document can have. However, the overall document size should not exceed
    16 MB. Consider the following example array containing four numbers:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Each element in an array can be accessed using its index position. While accessing
    an element on a specific index position, the index number is enclosed in square
    brackets. Let''s print the third element in the array:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Indexes are always zero-based. The index position `3` denotes the fourth element
    in the array.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the index position, you can also add new elements to an existing array,
    as in the following example:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Upon printing the array, you will see that the fifth element has been added
    correctly, which contains the index position, `4`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Just like objects having embedded objects, arrays can also have embedded arrays.
    The following syntax adds an embedded array into the sixth element:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you print the array, you will see the embedded array as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, you can use the square notation, `[]`, to access the elements of a specific
    index in the embedded array, as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The array can contain any MongoDB valid data type fields. This can be seen
    in the following snippet:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Exercise 2.03: Using Array Fields'
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to add comment details for each movie, your organization wants you
    to include full text of the comment along with user details such as name, email,
    and date. Your task is to prepare two dummy comments and add them to the existing
    movie record. In *Exercise 2.02*, *Creating Nested Objects*, you developed a movie
    record in a document format, which looks as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Build upon this document to add additional information by executing the following steps:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'Create two comments and list the details:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Split the two comments into separate documents as follows:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: There are two comments in two separate documents, and you can easily fit them
    in the movie record as `comment_1` and `comment_2`. However, as the number of
    comments will increase, it will be difficult to count their number. To overcome
    this, we will use an array, which implicitly assigns an index position to each element.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Add both comments to an array as follows:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'An array gives you the opportunity to add as many comments as you want. Also,
    because of the implicit indexes, you are free to access any comment via its dedicated
    index position. Once you add this array in the movie record, the output will appear
    as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, validate the JSON document with an online validator (for example, [https://jsonlint.com/](https://jsonlint.com/)).
    Click `Validate JSON` to validate the code:![Figure 2.10: Validation of the JSON
    document'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15507_02_10.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.10: Validation of the JSON document'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: We can see that our movie record now has user comments. In this exercise, we
    have modified our movie record to practice creating array fields. Now it is time
    to move on to the next data type, `null`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'Null'
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Null is a special data type in a document and denotes a field that does not
    contain a value. The `null` field can have only `null` as the value. You will
    print the object in the following example, which will result in the `null` value:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Build upon the array we created in the *Arrays* section:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, create a new variable and initialize it to `null` by inserting the variable
    in the next index position:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, print this array to see the `null` field:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ObjectId
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every document in a collection must have an `_id` that contains a unique value.
    This field acts as a *primary key* to these documents. The primary keys are used
    to uniquely identify the documents, and they are always indexed. The value of
    the `_id` field must be unique in a collection. When you work with any dataset,
    each dataset represents a different context, and based on the context, you can
    identify whether your data has a primary key. For example, if you are dealing
    with the users' data, the users' email addresses will always be unique and can
    be considered the most appropriate `_id` field. However, for some datasets that
    do not have a unique key, you can simply omit the `_id` field.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: If you insert a document without an `_id` field, the MongoDB driver will autogenerate
    a unique ID and add it to the document. So, when you retrieve the inserted document,
    you will find `_id` is generated with a unique value of random text. When the
    `_id` field is automatically added by the driver, the value is generated using `ObjectId`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ObjectId` value is designed to generate lightweight code that is unique
    across different machines. It generates a unique value of 12 bytes, where the
    first 4 bytes represent the timestamp, bytes 5 to 9 represent a random value,
    and the last 3 bytes are an incremental counter. Create and print an `ObjectId`
    value as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Print `uniqueID` on the next line:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: MongoDB supports a technique called sharding, where a dataset is distributed
    and stored on different machines. When a collection is sharded, its documents
    are physically located on different machines. Even so, `ObjectId` can ensure that
    the values will be unique in the collection across different machines. If the
    collection is sorted using the `ObjectId` field, the order will be based on the
    document creation time. However, the timestamp in `ObjectId` is based on the number
    of seconds to epoch time. Hence, documents inserted within the same second may
    appear in a random order. The `getTimestamp()` method on `ObjectId` tells us the
    document insertion time.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Dates
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The JSON specifications do not support date types. All the dates in JSON documents
    are represented as plain strings. The string representations of dates are difficult
    to parse, compare, and manipulate. MongoDB's BSON format, however, supports **Date**
    types explicitly.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: The MongoDB dates are stored in the form of milliseconds since the Unix epoch,
    which is January 1, 1970\. To store the millisecond's representation of a date,
    MongoDB uses a 64-bit integer (`long`). Because of this, the date fields have
    a range of around +/-290 million years since the Unix epoch. One thing to note
    is that all dates are stored in *UTC*, and there is no *time zone* associated
    with them.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'While working on the mongo shell, you can create `Date` instances using `Date()`,
    `new Date()`, or `new ISODate()`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Dates created with a new `Date()` constructor or a new `ISODate()` constructor
    are always in UTC, and ones created with `Date()` will be in the local time zone.
    An example of this is given next.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: When a `Date()` type is used to construct a date, it uses JavaScript's date
    representation, which is in the form of plain strings. These dates represent the
    date and time based on your current time zone. However, being in string formats,
    they are not useful for comparison or manipulation.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'If you add the `new` keyword to the `Date` constructor, you get the BSON date
    that is wrapped in `ISODate()` as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You can also use the `ISODate()` constructor directly to create `date` objects
    as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: These dates can be manipulated, compared, and searched.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: As per the MongoDB documentation, not all drivers support 64-bit date encodings.
    However, all the drivers support encoding dates having the year ranging from 0
    to 9999.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Timestamps
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The timestamp is a 64-bit representation of date and time. Out of the 64 bits,
    the first 32 bits store the number of seconds since the Unix epoch time, which
    is January 1, 1970\. The other 32 bits indicate an incrementing counter. The timestamp
    type is exclusively used by MongoDB for internal operations.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Binary Data
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Binary data, also called `BinData`, is a BSON data type for storing data that
    exists in a binary format. This data type gives you the ability to store almost
    anything in the database, including files such as text, videos, music, and more.
    `BinData` can be mapped with a binary array in your programming language as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11: Binary array'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_02_11.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.11: Binary array'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'The first argument to `BinData` is a binary subtype to indicate the type of
    information stored. The zero value stands for plain binary data and can be used
    with text or media files. The second argument to `BinData` is a *base64*-encoded
    text file. You can use the binary data field in a document as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We will cover MongoDB's document size limit in the upcoming section.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Limits and Restrictions on Documents
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have discussed the importance and benefits of using documents. Documents
    play a major role in building efficient applications, and they improve overall
    data usability. We know how documents offer a flexible way to represent data in
    its most natural form. They are often self-contained and can hold a complete unit
    of information. The self-containment comes from nested objects and arrays.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'To use any database effectively, it is important to have the correct data structure.
    The incorrect data structures you build today may result in lots of pain in the
    future. In the long term, as your application''s usage grows, the amount of data
    also grows, and the problems that seemed very small initially become more evident.
    Then comes the obvious question: how do you know whether your data structure is
    correct?'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Your application will tell you the answer. If, to access a certain piece of
    information, your application must execute multiple queries to the database and
    combine all the results to get the final information, then it will slow down the
    overall throughput. Contrastingly, if a single query on the database returns too
    much information in a single result, your application will have to scan through
    the entire result set and grab the intended piece of information. This will cause
    higher memory consumption, stale objects, and finally, slower performance.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Thus, MongoDB has put some limits and restrictions on documents. One thing to
    note is that the restrictions are not because of database limitations or shortcomings.
    The restrictions are added so that the overall database platform can perform efficiently.
    We have already covered the flexibility that MongoDB documents offer; now it is
    important to know the restrictions.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Document Size Limit
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A document with too much information is bad in many ways. For this reason, MongoDB
    puts a limit of 16 MB on the size of every document in the collection. The limit
    of 16 MB is enough to store the right information. A collection can have as many
    documents as you want. There is no limitation on the size of a collection. Even
    if a collection exceeds the space of the underlying system, you can use vertical
    or horizontal scaling to increase the capacity of the collection.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: The flexibility and self-containment of documents may tempt developers to put
    in too much information and create bulky documents. Oversized documents are usually
    an indication of bad design. Most of the time, your applications do not need all
    the information. A good database design considers the needs of the application.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Imagine your application is an interface providing sales information from various
    stores, where users can search and find sold items by the item type or by the
    store location. Most of the time, it is your application that will be hitting
    the database and that too with a similar set of queries. Therefore, your application's
    needs play a major role in database design, especially when the user base grows,
    and your application starts getting thousands and millions of requests in a short
    period of time. All you want is faster queries, less processing, and less resource
    consumption.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'Oversized documents are also expensive in terms of resource usage. When the
    documents are read from the system, they are held in memory and then transferred
    over the wire. Wire transfers are always slower. Then, your driver will map the
    received information to your programming language''s objects. Larger documents
    will result in too many bulky objects. Consider a sample document from a dummy
    sales record, as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Although this document is just fine, there are some constraints. The `items`
    field is an array of the `items` object. If an order has too many `items`, the
    size of the array will increase, which will result in an increase in the size
    of the overall document. If your application allows multiple items per order and
    you have thousands of unique items in store, this document will easily become
    oversized. The best way to deal with such complex documents is to split the collection
    into two and have document links embedded within.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Nesting Depth Limit
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A MongoDB BSON document supports nesting up to 100 levels, which is more than
    enough. Nested documents are a great way to provide readable data. They provide
    complete information in one go and avoid multiple queries to gather a piece of information.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: However, as the nesting level increases, performance and memory consumption
    issues arise. For example, consider a driver that is parsing the document to an
    object structure. During the scan, whenever a new sub-document is found, the scanner
    recursively enters the nested objects while maintaining a stack of already read
    information. This causes high memory utilization and slow performance.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: By setting the nesting limit of 100 levels, MongoDB avoids such issues. However,
    if you can't avoid such deep nesting, you can consider splitting the collections
    into two, or more, and have document references.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Field Name Rules
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MongoDB has a few rules about document field names, which are listed as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: The field name cannot contain a **null** character.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Only the fields in an array or an embedded document can have a name starting
    with the dollar sign (`$`). For the top-level fields, the name cannot start with
    a dollar (`$`) sign.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Documents with duplicate field names are not supported. According to the MongoDB
    documentation, when a document with duplicate field names is inserted, no error
    will be thrown, but the document won't be inserted. Even the drivers will drop
    the documents silently. On the mongo shell, however, if such a document is inserted,
    it gets inserted correctly. However, the resulting document will have only the
    second field. That means the second occurrence of the field overwrites the value
    of the first.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB (as of version 4.2.8) does not recommend field names starting with a
    dollar (`$`) sign or a dot (`.`). The MongoDB query language may not work correctly
    with such fields. Additionally, the drivers do not support them.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2.04: Loading Data into an Atlas Cluster'
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you have learned about documents and their structures, you can implement
    your learning on a business use case and observe MongoDB documents. In *Chapter
    1*, *Introduction to MongoDB*, you created a MongoDB Atlas account and initiated
    a cluster on the cloud. You will load sample datasets into this cluster. MongoDB
    Atlas provides sample datasets that can be loaded into the cluster by executing
    a few simple steps. These sample databases are large, real-life datasets that
    are made available for practice. The sample dataset in MongoDB Atlas has the following
    databases, where each database has multiple collections:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '`sample_mflix`'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sample_airbnb`'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sample_geospatial`'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sample_supplies`'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sample_training`'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sample_weatherdata`'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of all these datasets, it will be the `sample_mflix` dataset that you deal with
    throughout this book. This is a huge database with over 23,000 movies and series
    records along with their ratings, comments, and other details. Before you learn
    about the database, import the database into our cluster and familiarize ourselves
    with its structure and components.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the steps to be executed in order to achieve the desired
    result:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'Visit [https://cloud.mongodb.com/](https://cloud.mongodb.com/) and click to
    log in to your account:![Figure 2.12: Atlas login page'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15507_02_12.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.12: Atlas login page'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'Since you already have a cluster created on the cloud, upon login, the following
    screen displaying the cluster details will appear:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13: Cluster view'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_02_13.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.13: Cluster view'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the (`…`) option available next to `COLLECTIONS`. A drop-down list
    displaying the following options will appear. Click `Load Sample Dataset`:![Figure
    2.14: The Load Sample Dataset option'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15507_02_14.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.14: The Load Sample Dataset option'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 'This opens a confirmation dialog that shows the total size of a sample dataset
    that will be loaded into your cluster:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.15: Load Sample Dataset confirmation'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_02_15.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.15: Load Sample Dataset confirmation'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'Click `Load Sample Dataset`. You will see a message saying `Loading your sample
    dataset...` on the screen:![Figure 2.16: Loading your sample dataset… window'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15507_02_16.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.16: Loading your sample dataset… window'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: It may take a few minutes to load the data and redeploy the cluster instances.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the dataset has successfully loaded, you will see a success message saying
    `Sample dataset successfully loaded`:![Figure 2.17: Sample dataset successfully
    loaded'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15507_02_17.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.17: Sample dataset successfully loaded'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: As the dataset is loaded, you can also see charts showing information about
    the number of read and write operations performed on the dataset, the total connections,
    and the total size of the dataset.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, click `COLLECTIONS`. On the next screen, you will see the following list
    of available databases:![Figure 2.18: List of sample databases'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15507_02_18.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.18: List of sample databases'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Click the down arrow next to `sample_mflix`.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `movies` collection.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your result for the first 20 documents will be displayed as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.19: Movies collection on the cluster'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_02_19.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.19: Movies collection on the cluster'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we were able to load the `sample_mflix` database into our
    cluster. Let's now perform a simple activity that will help us put our understanding
    of everything we've learned in this chapter to practice.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 2.01: Modeling a Tweet into a JSON Document'
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you understand JSON documents, the data types supported by MongoDB,
    and the document-based storage model, it's time to practice modeling a real-life
    entity into a valid JSON document format.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'Your task is to prepare a valid JSON document to represent the data of a tweet.
    For this, use the dummy tweet shown in *Figure 2.20* From this tweet, identify
    all the various pieces of information that you can find, decide the field names
    and data types they can be represented with, prepare a JSON document with all
    the fields, and validate your document:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.20: Sample tweet'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_02_20.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.20: Sample tweet'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you achieve the desired result:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: List all the objects that you see in the tweet, such as user ID, name, profile
    picture, tweet text, tags, and mentions.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify the set of closely related fields that can be grouped together. These
    groups of fields can be placed as embedded objects or arrays.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have created the JSON document, validate it using any JSON validator
    available online (for example, [https://jsonlint.com/](https://jsonlint.com/)).
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code represents the final JSON document with only a few fields revealed:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found via [this link](B15507_Solution_Final_SZ_ePub.xhtml#_idTextAnchor463).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered a detailed structure of MongoDB documents and
    document-based models, which is important before we dive into more advanced concepts
    in the upcoming chapters. We began our discussion with the transportation and
    storage of information in the form of JSON-like documents that provide a flexible
    and language-independent format. We studied an overview of JSON documents, the
    document structure, and basic data types, followed by BSON document specifications
    and differentiating between BSON and JSON on various parameters.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: We then covered MongoDB documents, considering their flexibility, self-containment,
    relatability, and agility, as well as various data types provided by BSON. Finally,
    we made a note of MongoDB's limitations and restrictions for documents and learned
    why the limitations are imposed and why they are important.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will use the mongo shell and Mongo Compass to connect
    to an actual MongoDB server and manage user authentication and authorization.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
