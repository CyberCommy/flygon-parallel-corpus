- en: 2\. Documents and Data Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces you to MongoDB documents, their structure, and data
    types. For those who are new to the JSON model, this chapter will also serve as
    a short introduction to JSON. You will identify the basic concepts and data types
    of JSON documents and compare the document-based storage of MongoDB with the tabular
    storage of relational databases. You will learn how to represent complex data
    structures in MongoDB using embedded objects and arrays. By the end of this chapter,
    you will understand the need for precautionary limits and restrictions on MongoDB documents.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how MongoDB, as a NoSQL database, differs
    from traditional relational databases. We covered the basic features of MongoDB,
    including its architecture, its different versions, and MongoDB Atlas.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB is designed for modern-world applications. We live in a world where
    requirements change rapidly. We want to build lightweight and flexible applications
    that can quickly adapt to these new requirements and ship them to production as
    quickly as possible. We want our databases to become agile so that they can adapt
    to the ever-changing needs of our applications, reduce downtime, scale out easily,
    and perform efficiently. MongoDB is a perfect fit for all such needs.
  prefs: []
  type: TYPE_NORMAL
- en: One of the major factors that make MongoDB an agile database is its document-based
    data model. Documents are widely accepted as a flexible way of transporting information.
    You might have come across many applications that exchange data in the form of
    **JavaScript Object Notation** (**JSON**) documents. MongoDB stores data in Binary
    JSON (BSON) format and represents it in human readable JSON. This means that when
    we use MongoDB, we see the data in JSON format. This chapter begins with an overview
    of the JSON and BSON formats, followed by details of MongoDB documents and data
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSON is a full-text, lightweight format for data representation and transportation.
    JavaScript's simple representation of objects gave birth to JSON. Douglas Crockford,
    who was one of the developers of the JavaScript language, came up with the proposal
    for the JSON specification that defines the grammar and data types for the JSON syntax.
  prefs: []
  type: TYPE_NORMAL
- en: The JSON specification became a standard in 2013\. If you have been developing
    applications for a while, you might have seen the transition of applications from
    XML to JSON. JSON offers a human-readable, plain-text way of representing data.
    In comparison to XML, where information is wrapped inside tags, and lots of tags
    make it look bulky, JSON offers a compact and natural format where you can easily
    focus on the information.
  prefs: []
  type: TYPE_NORMAL
- en: To read or write information in JSON or XML format, the programming languages
    use their respective parsers. As XML documents are bound by schema definitions
    and tag library definitions, parsers need to do a lot of work to read and validate
    **XML Schema Definition** (**XSD**) and **Tag Library Descriptors** (**TLDs**).
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, JSON does not have any schema definition, and JSON parsers
    only need to deal with opening and closing brackets and colons. Different programming
    languages have different ways of representing language constructs, such as objects,
    lists, arrays, variables, and more. When two systems, written in two different
    programming languages, want to exchange data, they need to have a mutually agreed
    standard for representing information. JSON provides that standard with its lightweight
    format. The objects, collections, and variables of any programming language can
    naturally fit into the JSON structure. Most programming languages have parsers
    that can translate their own objects to and from JSON documents.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: JSON does not impose JavaScript language internals on other languages. JSON
    is the syntax for language-independent data representation. The grammar that defines
    the JSON format was derived from JavaScript's syntax. However, to use JSON, programmers
    do not need to know JavaScript internals
  prefs: []
  type: TYPE_NORMAL
- en: JSON Syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JSON documents or objects are a plain-text set of zero or more key-value pairs.
    The key-value pairs form an object, and if the value is a collection of zero or
    more values, they form an array. JSON has a very simple structure where, by only
    using a set of curly braces (`{}`), square brackets (`[]`), colons (`:`), and
    commas(`,`), you can represent any complex piece of information in a compact form.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a JSON object, key-value pairs are enclosed within curly braces: `{}`. Within
    an object, the key is always a string. However, the value can be any of JSON''s
    specified types. The JSON grammar specification does not define any order for
    JSON fields and can be represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding document represents a valid JSON object that has a single key-value
    pair. Moving on to JSON arrays, an array is a set of zero or more values that
    are enclosed within square brackets, `[]`, and separated by commas. While most
    programming languages have support for ordered arrays, JSON''s specification does
    not specify the order for array elements. Let''s take a look at an example array
    that has three fields separated by commas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have looked at JSON syntax, let''s consider a sample JSON document
    that contains the basic information of a company. The example demonstrates how
    naturally a piece of information can be presented in document format, making it
    easily readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding document, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Company name and address, both being string fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Foundation year, number of employees, and revenue as numeric fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The company's Twitter username as null or no information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON Data Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike many programming languages, JSON supports a limited and basic set of
    data types, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**String**: Refers to plain text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Number**: Consists of all numeric fields'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`True` or `False`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Object**: Other embedded JSON objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Array**: Collection of fields'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Null**: Special value to denote fields without any value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the major reasons for the wide acceptance of JSON is its language-independent
    format. Different languages have different data types. Some languages support
    **statically typed variables**, while some support **dynamically typed variables**.
    If JSON had many data types, it would be more in line with a number of languages—though,
    not all.
  prefs: []
  type: TYPE_NORMAL
- en: JSON is a data exchange format. When an application transmits a piece of information
    over the wire, the information gets serialized into plain strings. The receiving
    application then deserializes the information into its objects so that it becomes
    available to use. The presence of basic data types provided by JSON reduces complexity
    during this process.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, JSON keeps it simple and minimal in terms of data types. JSON parsers
    specific to programming languages can easily relate basic data types to the most
    specific types the language provides.
  prefs: []
  type: TYPE_NORMAL
- en: JSON and Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As per the JSON specification, a number is just a sequence of digits. It does
    not differentiate between numbers such as `integer`, `float`, or `long`. Additionally,
    it restricts the range limits of numbers. This leads to greater flexibility when
    data is transferred or represented.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are some challenges involved. Most programming languages represent
    numbers in the form of `integer`, `float`, or `long`. When a piece of information
    is presented in JSON, the parsers cannot anticipate the exact format or range
    of a numeric field in the entire document. To avoid number format corruption or
    the loss of precision of numeric fields, the two parties exchanging data should
    agree and follow a certain contract in advance.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, say you are reading a movie record set in the form of JSON documents.
    When you look at the first record, you find the `audience_rating` field is an
    `integer`. However, when you reach the next record, you realize it is a `float`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We will look at how this issue can be overcome in an upcoming section, *BSON*.
  prefs: []
  type: TYPE_NORMAL
- en: JSON and Dates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you may have noticed, JSON documents do not support the `Date` data type,
    and all dates are represented as plain strings. Let''s look at an example of a
    few JSON documents, each of which has a valid date representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Although all the documents represent the same date, they are written in a different
    format. Different systems, based on their local standards, use different formats
    to write the same date and time instances.
  prefs: []
  type: TYPE_NORMAL
- en: Like the examples of JSON numbers, the parties exchanging the information need
    to standardize the `Date` format during the transfers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the JSON specification defines syntax and grammar for data representation.
    However, how you read the data depends on the interpreters of the languages and
    their data exchange contracts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2.01: Creating Your Own JSON Document'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you have learned the basics of JSON syntax, it is time to put this
    knowledge into practice. Suppose your organization wants to build a dataset of
    movies and series, and they want to use MongoDB to store the records. As a proof
    of concept, they ask you to choose a random movie and represent it in JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, you will write your first basic JSON document from scratch
    and verify whether it is a grammatically valid document. For this exercise, you
    will consider a sample movie, `Beauty and the Beast`, and refer to the `Movie
    ID`, `Movie Title`, `Release Year`, `Language`, `IMDb Rating` `Genre`, `Director`,
    and `Runtime` fields, which contain the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To successfully create a JSON document for the preceding listed fields, first
    differentiate each field into key-value pairs. Execute the following steps to
    achieve the desired result:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a JSON validator—for example, [https://jsonlint.com/](https://jsonlint.com/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type the preceding information in JSON format, which looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Remember, a JSON document always starts with `{` and ends with `}`. Each element
    is separated by a colon (`:`) and the key-value pairs are separated by a comma
    (`,`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on `Validate JSON` to validate the code. The following screenshot displays
    the expected output and validity of the JSON document:![Figure 2.1: The JSON document
    and its validity check'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15507_02_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.1: The JSON document and its validity check'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you modeled a movie record into a document format and created
    a grammatically valid JSON object. To practice it more, you can consider any general
    item, such as a product you recently bought or a book you read, and model it as
    a valid JSON document. In the next section, we will look at a brief overview of
    MongoDB's BSON.
  prefs: []
  type: TYPE_NORMAL
- en: BSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you work with MongoDB using database clients such as mongo shell, MongoDB
    Compass, or the Collections Browser in Mongo Atlas, you always see the documents
    in human readable JSON format. However, internally, MongoDB documents are stored
    in a binary format called BSON. BSON documents are not human-readable, and you
    will never have to deal with them directly. Before we explore MongoDB documents
    in detail, let's have a quick overview of the BSON features that benefit the MongoDB
    document structure.
  prefs: []
  type: TYPE_NORMAL
- en: Like JSON, BSON was introduced in 2009 by MongoDB. Although it was invented
    by MongoDB, many other systems also use it as a format for data storage or transportation.
    BSON specifications are primarily based on JSON as they inherit all the good features
    of JSON, such as the syntax and flexibility. It also provides a few additional
    features, which are specifically designed for improving storage efficiency, ease
    of traversal, and a few data type enhancements to avoid the type conflicts that
    we saw in the *Introduction to JSON* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have already covered the JSON features in detail, let''s focus on the
    enhancements that BSON provides:'
  prefs: []
  type: TYPE_NORMAL
- en: BSON documents are designed to be more efficient than JSON as they occupy less
    space and provide faster traversal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With each document, BSON stores some **meta-information**, such as the length
    of the fields or the length of the sub-documents. The meta-information makes the
    document parsing, as well as traversing, faster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BSON documents have **ordered arrays**. Each element in an array is prefixed
    by its index position and can be accessed using its index number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BSON provides many **additional data types**, such as dates, integers, doubles,
    byte arrays, and more. We will cover BSON data types later, in the next section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Because of the binary format, BSON documents are compact in nature. However,
    some smaller documents end up occupying more space compared to JSON documents
    with the same information. This is because of the meta-information added to each
    document. However, for large documents, BSON is more space efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have completed a detailed introduction to JSON and BSON enhancements,
    let's now learn about MongoDB documents.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB Documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A MongoDB database is composed of collections and documents. A database can
    have one or more collections, and each collection can store one or more related
    BSON documents. In comparison to RDBMS, collections are analogous to tables and
    documents are analogous to rows within a table. However, documents are much more
    flexible compared with the rows in a table.
  prefs: []
  type: TYPE_NORMAL
- en: RDBMSes consist of a tabular data model that comprises rows and columns. However,
    your applications may need to support more complex data structures, such as a
    nested object or a collection of objects. Tabular databases restrict the storage
    of such complex data structures. In such cases, you will have to split your data
    into multiple tables and change the application's object structures accordingly.
    On the other hand, the document-based data model of MongoDB allows your application
    to store and retrieve more complex object structures due to the flexible JSON-like
    format of the documents.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list details some of the major features of MongoDB''s document-based
    data model:'
  prefs: []
  type: TYPE_NORMAL
- en: The documents provide a flexible and natural way of representing data. The data
    can be stored as is, without having to transform it into a database structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The objects, nested objects, and arrays that are within a document are easily
    relatable to your programming language's object structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the ability of a flexible schema, the documents are agile in practice.
    They continuously integrate with application changes and new features without
    any major schema changes or downtimes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Documents are self-contained pieces of data. They avoid the need to read multiple
    relational tables and table-joins to understand a complete unit of information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The documents are extensible. You can use documents to store the entire object
    structure, use it as a map or a dictionary, as a key-value pair for quick lookup,
    or have a flat structure that resembles a relational table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Documents and Flexibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As stated earlier, MongoDB documents are a flexible way of storing data. Consider
    the following example. Imagine you are developing a movie service where you need
    to create a movie database. A movie record in a simple MongoDB document will look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'However, storing only the title is not enough. You need more fields. Now, let''s
    consider a few more basic fields. With a list of movies in the MongoDB database,
    the documents will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Say you are using an RDBMS table instead. On an RDBMS platform, you need to
    define your schema at the beginning, and to do that, first, you must think about
    the columns and data types. You might then come up with a `CREATE TABLE` query
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This query is a clear indication that relational tables are bound by a definition
    called the `id` field and `user_ratings` can never be a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a few records inserted, the table will appear as in *Figure 2.2*. This
    table is as good as a MongoDB document:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2: The movies table'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_02_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.2: The movies table'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, say you want to include the IMDb ratings for each of the movies listed
    in the table, and going forward, all the movies will have `imdb_ratings` included
    in the table. For an existing list of movies, `imdb_ratings` can be set to `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To meet this requirement, you will include an `ALTER TABLE` query in your syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The query is correct, but there can be instances where table alterations may
    block the table for some time, especially for large datasets. When a table is
    blocked, other read and write operations will have to wait until the table is
    altered, which may lead to downtime. Now, let's see how we can tackle the same
    situation in MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB supports a flexible schema, and there is no specific schema definition.
    Without altering anything on the database or the collection, you can simply insert
    a new movie with the additional field. The collection will behave exactly like
    the modified table of the movies, where the latest insertions will have `imdb_ratings`
    and the previous ones will return a `null` value. In MongoDB documents, a non-existent
    field is always considered `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the whole collection will look similar to the following screenshot. You
    will notice that the last movie has a new field, `imdb_ratings`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3: Result for imdb_ratings for the movies collection'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_02_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.3: Result for imdb_ratings for the movies collection'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding examples clearly indicate that documents are extremely flexible
    in comparison to tabular databases. Documents can incorporate changes on the go
    without any downtime.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB Data Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have learned how MongoDB stores JSON-like documents. You have also seen
    various documents and read the information stored within them and seen how flexible
    these documents are to store different types of data structures, irrespective
    of the complexity of your data.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will learn about the various data types supported by MongoDB's
    BSON documents. Using the right data types in your documents is very important
    as correct data types help you use the database features more effectively, avoid
    data corruption, and improve data usability. MongoDB supports all the data types
    from JSON and BSON. Let's look at each in detail, with examples.
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A string is a basic data type used to represent text-based fields in a document.
    It is a plain sequence of characters. In MongoDB, the string fields are UTF-8
    encoded, and thus they support most international characters. The MongoDB drivers
    for various programming languages convert the string fields to UTF-8 while reading
    or writing data from a collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'A string with plain-text characters appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'A string with random characters and whitespaces will appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In JSON, a value that is wrapped in double quotes is considered a string. Consider
    the following example in which a valid number and date are wrapped in double quotes,
    both forming a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: An interesting fact about MongoDB string fields is that they support search
    capabilities with regular expressions. This means you can search for documents
    by providing the full value of a text field or by providing only part of the string
    value using regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A number is JSON''s basic data type. A JSON document does not specify whether
    a number is an integer, a float, or *long*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'However, MongoDB supports the following types of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`double`: 64-bit floating point'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int`: 32-bit signed integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long`: 64-bit unsigned integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decimal`: 128-bit floating point – which is IEE 754-compliant'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you are working with a programming language, you don't have to worry about
    these data types. You can simply program using the language's native data types.
    The MongoDB drivers for respective languages take care of encoding the language-specific
    numbers to one of the previously listed data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are working on the mongo shell, you get three wrappers to handle: `integer`,
    `long`, and `decimal`. The Mongo shell is based on JavaScript, and thus all the
    documents are represented in JSON format. By default, it treats any number as
    a 64-bit floating point. However, if you want to explicitly use the other types,
    you can use the following wrappers.'
  prefs: []
  type: TYPE_NORMAL
- en: '`NumberInt`: The `NumberInt` constructor can be used if you want the number
    to be saved as a 32-bit integer and not as a 64-bit float:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, the first number, `plainNum`, is initialized with
    a sequence of digits without mentioning any explicit data type. Therefore, by
    default, it will be treated as a *64-bit floating-point number* (also known as
    a **double**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`explicitInt`, however, is initialized with an integer-type constructor and
    a string representation of a number, and so MongoDB reads the number in an argument
    as a *32-bit integer*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, in the `explicitInt_double` initialization, the number provided in
    the constructor argument doesn't have double quotes. Therefore, it will be treated
    as a *64-bit float*—that is, a **double**—and used to form a *32-bit integer*.
    But as the provided number fits in the integer range, no change is seen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you print the preceding numbers, they look as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 2.4: Output for the plainNum, explicitInt, and explicitInt_double'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_02_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.4: Output for the plainNum, explicitInt, and explicitInt_double'
  prefs: []
  type: TYPE_NORMAL
- en: '`NumberLong`: `NumberLong` wrappers are similar to `NumberInt`. The only difference
    is that they are stored as 64-bit integers. Let''s try it on the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s print the documents in the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5: MongoDB shell output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_02_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.5: MongoDB shell output'
  prefs: []
  type: TYPE_NORMAL
- en: '`NumberDecimal`: This wrapper stores the given number as a 128-bit IEEE 754
    decimal format. The `NumberDecimal` constructor accepts both a string and a double
    representation of the number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We are passing a string representation of a decimal number to `explicitDecimal`.
    However, `explicitDecimal_double` is created using a `double`. When we print the
    results, they appear slightly differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6: Output for explicitDecimal and explicitDecimal_double'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_02_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.6: Output for explicitDecimal and explicitDecimal_double'
  prefs: []
  type: TYPE_NORMAL
- en: The second number has been appended with trailing zeros. This is because of
    the internal parsing of the numbers. When we pass a double value to `NumberDecimal`,
    the argument is parsed to BSON's double, which is then converted to a 128-bit
    decimal with a precision of 15 digits.
  prefs: []
  type: TYPE_NORMAL
- en: 'During this conversion, the decimal numbers are rounded off and may lose precision.
    Let''s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s print the numbers and inspect the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7: Output for dec and decDbl'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_02_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.7: Output for dec and decDbl'
  prefs: []
  type: TYPE_NORMAL
- en: It is evident that when a double is passed to `NumberDecimal`, there is a chance
    of a loss of precision. Therefore, it is important to always use string-based
    constructors when using `NumberDecimal`.
  prefs: []
  type: TYPE_NORMAL
- en: Booleans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Boolean data type is used to represent whether something is true or false.
    Therefore, the value of a valid Boolean field is either `true` or `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The values do not have double quotes. If you wrap them in double quotes, they
    will be treated as strings.
  prefs: []
  type: TYPE_NORMAL
- en: Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The object fields are used to represent nested or embedded documents—that is,
    a field whose value is another valid JSON document.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following example from the airbnb dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of the host field is another valid JSON. MongoDB uses a dot notation
    (`.`) to access the embedded objects. To access an embedded document, we will
    create a variable of the listing on the mongo shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To print only the host details, use the dot notation (`.`) to get the embedded
    object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8: Output for the embedded object'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_02_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.8: Output for the embedded object'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a similar notation, you can also access a specific field of the embedded
    document as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Embedded documents can have further documents within them. Having embedded documents
    makes a MongoDB document a piece of self-contained information. To record the
    same information in an RDBMS database, you will have to create the listing and
    the host as two separate tables with a foreign key reference in between, and join
    the data from both tables to get a piece of information.
  prefs: []
  type: TYPE_NORMAL
- en: Along with embedded documents, MongoDB also supports links between the documents
    of two different collections, which resembles having foreign key references.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2.02: Creating Nested Objects'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your organization is happy with the movie representation so far. Now they have
    come up with a requirement to include the IMDb ratings and the number of votes
    that derived the rating. They also want to incorporate Tomatometer ratings, which
    include the user ratings and critics ratings along with fresh and rotten scores.
    Your task is to modify the document to update the `imdb` field to include the
    number of votes and add a new field called `tomatoes`, which contains the Rotten
    Tomato ratings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall the JSON document of a sample movie record that you created in *Exercise
    2.01*, *Creating Your Own JSON Document*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following steps will help modify the IMDb ratings:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The existing `imdb_rating` field indicates the IMDb rating score, so add an
    additional field to represent the vote count. However, both fields are closely
    related to each other and will always be used together. Therefore, group them
    together in a single document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding document with two fields represents the complete IMDb rating.
    Replace the current `imdb_rating` field with the one you just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This `imdb` field with its value of an embedded object represents the IMDb ratings.
    Now, add the Tomatometer ratings.
  prefs: []
  type: TYPE_NORMAL
- en: 'As stated previously, the Tomatometer rating includes viewer ratings and critics
    ratings, along with the fresh score and the rotten score. Like the IMDb ratings,
    both `Viewer Ratings` and `Critics Ratings` will have a `rating` field and a `votes`
    field. Write these two documents separately:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As both ratings are related, group them together in a single document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `fresh` and `rotten` scores as per the description:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output represents the Tomatometer ratings with the new `tomatoes`
    field in our movie record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, validate your document with any online JSON validator (in our case,
    [https://jsonlint.com/](https://jsonlint.com/)). Click on `Validate JSON` to validate
    the code:![Figure 2.9: Validation of the JSON document'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15507_02_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.9: Validation of the JSON document'
  prefs: []
  type: TYPE_NORMAL
- en: Your movie record is now updated with detailed IMBb ratings and the new `tomatoes`
    rating. In this exercise, you practiced creating two nested documents to represent
    IMDb ratings and Tomatometer ratings. Now that we have covered nested or embedded
    objects, let's learn about arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A field with an **array** type has a collection of zero or more values. In
    MongoDB, there is no limit to how many elements an array can contain or how many
    arrays a document can have. However, the overall document size should not exceed
    16 MB. Consider the following example array containing four numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Each element in an array can be accessed using its index position. While accessing
    an element on a specific index position, the index number is enclosed in square
    brackets. Let''s print the third element in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Indexes are always zero-based. The index position `3` denotes the fourth element
    in the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the index position, you can also add new elements to an existing array,
    as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon printing the array, you will see that the fifth element has been added
    correctly, which contains the index position, `4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like objects having embedded objects, arrays can also have embedded arrays.
    The following syntax adds an embedded array into the sixth element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If you print the array, you will see the embedded array as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can use the square notation, `[]`, to access the elements of a specific
    index in the embedded array, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The array can contain any MongoDB valid data type fields. This can be seen
    in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 2.03: Using Array Fields'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to add comment details for each movie, your organization wants you
    to include full text of the comment along with user details such as name, email,
    and date. Your task is to prepare two dummy comments and add them to the existing
    movie record. In *Exercise 2.02*, *Creating Nested Objects*, you developed a movie
    record in a document format, which looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Build upon this document to add additional information by executing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create two comments and list the details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Split the two comments into separate documents as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: There are two comments in two separate documents, and you can easily fit them
    in the movie record as `comment_1` and `comment_2`. However, as the number of
    comments will increase, it will be difficult to count their number. To overcome
    this, we will use an array, which implicitly assigns an index position to each element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add both comments to an array as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'An array gives you the opportunity to add as many comments as you want. Also,
    because of the implicit indexes, you are free to access any comment via its dedicated
    index position. Once you add this array in the movie record, the output will appear
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, validate the JSON document with an online validator (for example, [https://jsonlint.com/](https://jsonlint.com/)).
    Click `Validate JSON` to validate the code:![Figure 2.10: Validation of the JSON
    document'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15507_02_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.10: Validation of the JSON document'
  prefs: []
  type: TYPE_NORMAL
- en: We can see that our movie record now has user comments. In this exercise, we
    have modified our movie record to practice creating array fields. Now it is time
    to move on to the next data type, `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Null'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Null is a special data type in a document and denotes a field that does not
    contain a value. The `null` field can have only `null` as the value. You will
    print the object in the following example, which will result in the `null` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Build upon the array we created in the *Arrays* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a new variable and initialize it to `null` by inserting the variable
    in the next index position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, print this array to see the `null` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: ObjectId
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every document in a collection must have an `_id` that contains a unique value.
    This field acts as a *primary key* to these documents. The primary keys are used
    to uniquely identify the documents, and they are always indexed. The value of
    the `_id` field must be unique in a collection. When you work with any dataset,
    each dataset represents a different context, and based on the context, you can
    identify whether your data has a primary key. For example, if you are dealing
    with the users' data, the users' email addresses will always be unique and can
    be considered the most appropriate `_id` field. However, for some datasets that
    do not have a unique key, you can simply omit the `_id` field.
  prefs: []
  type: TYPE_NORMAL
- en: If you insert a document without an `_id` field, the MongoDB driver will autogenerate
    a unique ID and add it to the document. So, when you retrieve the inserted document,
    you will find `_id` is generated with a unique value of random text. When the
    `_id` field is automatically added by the driver, the value is generated using `ObjectId`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ObjectId` value is designed to generate lightweight code that is unique
    across different machines. It generates a unique value of 12 bytes, where the
    first 4 bytes represent the timestamp, bytes 5 to 9 represent a random value,
    and the last 3 bytes are an incremental counter. Create and print an `ObjectId`
    value as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Print `uniqueID` on the next line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: MongoDB supports a technique called sharding, where a dataset is distributed
    and stored on different machines. When a collection is sharded, its documents
    are physically located on different machines. Even so, `ObjectId` can ensure that
    the values will be unique in the collection across different machines. If the
    collection is sorted using the `ObjectId` field, the order will be based on the
    document creation time. However, the timestamp in `ObjectId` is based on the number
    of seconds to epoch time. Hence, documents inserted within the same second may
    appear in a random order. The `getTimestamp()` method on `ObjectId` tells us the
    document insertion time.
  prefs: []
  type: TYPE_NORMAL
- en: Dates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The JSON specifications do not support date types. All the dates in JSON documents
    are represented as plain strings. The string representations of dates are difficult
    to parse, compare, and manipulate. MongoDB's BSON format, however, supports **Date**
    types explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: The MongoDB dates are stored in the form of milliseconds since the Unix epoch,
    which is January 1, 1970\. To store the millisecond's representation of a date,
    MongoDB uses a 64-bit integer (`long`). Because of this, the date fields have
    a range of around +/-290 million years since the Unix epoch. One thing to note
    is that all dates are stored in *UTC*, and there is no *time zone* associated
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'While working on the mongo shell, you can create `Date` instances using `Date()`,
    `new Date()`, or `new ISODate()`:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Dates created with a new `Date()` constructor or a new `ISODate()` constructor
    are always in UTC, and ones created with `Date()` will be in the local time zone.
    An example of this is given next.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: When a `Date()` type is used to construct a date, it uses JavaScript's date
    representation, which is in the form of plain strings. These dates represent the
    date and time based on your current time zone. However, being in string formats,
    they are not useful for comparison or manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you add the `new` keyword to the `Date` constructor, you get the BSON date
    that is wrapped in `ISODate()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the `ISODate()` constructor directly to create `date` objects
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: These dates can be manipulated, compared, and searched.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As per the MongoDB documentation, not all drivers support 64-bit date encodings.
    However, all the drivers support encoding dates having the year ranging from 0
    to 9999.
  prefs: []
  type: TYPE_NORMAL
- en: Timestamps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The timestamp is a 64-bit representation of date and time. Out of the 64 bits,
    the first 32 bits store the number of seconds since the Unix epoch time, which
    is January 1, 1970\. The other 32 bits indicate an incrementing counter. The timestamp
    type is exclusively used by MongoDB for internal operations.
  prefs: []
  type: TYPE_NORMAL
- en: Binary Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Binary data, also called `BinData`, is a BSON data type for storing data that
    exists in a binary format. This data type gives you the ability to store almost
    anything in the database, including files such as text, videos, music, and more.
    `BinData` can be mapped with a binary array in your programming language as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11: Binary array'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_02_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.11: Binary array'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first argument to `BinData` is a binary subtype to indicate the type of
    information stored. The zero value stands for plain binary data and can be used
    with text or media files. The second argument to `BinData` is a *base64*-encoded
    text file. You can use the binary data field in a document as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We will cover MongoDB's document size limit in the upcoming section.
  prefs: []
  type: TYPE_NORMAL
- en: Limits and Restrictions on Documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have discussed the importance and benefits of using documents. Documents
    play a major role in building efficient applications, and they improve overall
    data usability. We know how documents offer a flexible way to represent data in
    its most natural form. They are often self-contained and can hold a complete unit
    of information. The self-containment comes from nested objects and arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use any database effectively, it is important to have the correct data structure.
    The incorrect data structures you build today may result in lots of pain in the
    future. In the long term, as your application''s usage grows, the amount of data
    also grows, and the problems that seemed very small initially become more evident.
    Then comes the obvious question: how do you know whether your data structure is
    correct?'
  prefs: []
  type: TYPE_NORMAL
- en: Your application will tell you the answer. If, to access a certain piece of
    information, your application must execute multiple queries to the database and
    combine all the results to get the final information, then it will slow down the
    overall throughput. Contrastingly, if a single query on the database returns too
    much information in a single result, your application will have to scan through
    the entire result set and grab the intended piece of information. This will cause
    higher memory consumption, stale objects, and finally, slower performance.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, MongoDB has put some limits and restrictions on documents. One thing to
    note is that the restrictions are not because of database limitations or shortcomings.
    The restrictions are added so that the overall database platform can perform efficiently.
    We have already covered the flexibility that MongoDB documents offer; now it is
    important to know the restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: Document Size Limit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A document with too much information is bad in many ways. For this reason, MongoDB
    puts a limit of 16 MB on the size of every document in the collection. The limit
    of 16 MB is enough to store the right information. A collection can have as many
    documents as you want. There is no limitation on the size of a collection. Even
    if a collection exceeds the space of the underlying system, you can use vertical
    or horizontal scaling to increase the capacity of the collection.
  prefs: []
  type: TYPE_NORMAL
- en: The flexibility and self-containment of documents may tempt developers to put
    in too much information and create bulky documents. Oversized documents are usually
    an indication of bad design. Most of the time, your applications do not need all
    the information. A good database design considers the needs of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine your application is an interface providing sales information from various
    stores, where users can search and find sold items by the item type or by the
    store location. Most of the time, it is your application that will be hitting
    the database and that too with a similar set of queries. Therefore, your application's
    needs play a major role in database design, especially when the user base grows,
    and your application starts getting thousands and millions of requests in a short
    period of time. All you want is faster queries, less processing, and less resource
    consumption.
  prefs: []
  type: TYPE_NORMAL
- en: 'Oversized documents are also expensive in terms of resource usage. When the
    documents are read from the system, they are held in memory and then transferred
    over the wire. Wire transfers are always slower. Then, your driver will map the
    received information to your programming language''s objects. Larger documents
    will result in too many bulky objects. Consider a sample document from a dummy
    sales record, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Although this document is just fine, there are some constraints. The `items`
    field is an array of the `items` object. If an order has too many `items`, the
    size of the array will increase, which will result in an increase in the size
    of the overall document. If your application allows multiple items per order and
    you have thousands of unique items in store, this document will easily become
    oversized. The best way to deal with such complex documents is to split the collection
    into two and have document links embedded within.
  prefs: []
  type: TYPE_NORMAL
- en: Nesting Depth Limit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A MongoDB BSON document supports nesting up to 100 levels, which is more than
    enough. Nested documents are a great way to provide readable data. They provide
    complete information in one go and avoid multiple queries to gather a piece of information.
  prefs: []
  type: TYPE_NORMAL
- en: However, as the nesting level increases, performance and memory consumption
    issues arise. For example, consider a driver that is parsing the document to an
    object structure. During the scan, whenever a new sub-document is found, the scanner
    recursively enters the nested objects while maintaining a stack of already read
    information. This causes high memory utilization and slow performance.
  prefs: []
  type: TYPE_NORMAL
- en: By setting the nesting limit of 100 levels, MongoDB avoids such issues. However,
    if you can't avoid such deep nesting, you can consider splitting the collections
    into two, or more, and have document references.
  prefs: []
  type: TYPE_NORMAL
- en: Field Name Rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MongoDB has a few rules about document field names, which are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The field name cannot contain a **null** character.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Only the fields in an array or an embedded document can have a name starting
    with the dollar sign (`$`). For the top-level fields, the name cannot start with
    a dollar (`$`) sign.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Documents with duplicate field names are not supported. According to the MongoDB
    documentation, when a document with duplicate field names is inserted, no error
    will be thrown, but the document won't be inserted. Even the drivers will drop
    the documents silently. On the mongo shell, however, if such a document is inserted,
    it gets inserted correctly. However, the resulting document will have only the
    second field. That means the second occurrence of the field overwrites the value
    of the first.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB (as of version 4.2.8) does not recommend field names starting with a
    dollar (`$`) sign or a dot (`.`). The MongoDB query language may not work correctly
    with such fields. Additionally, the drivers do not support them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2.04: Loading Data into an Atlas Cluster'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you have learned about documents and their structures, you can implement
    your learning on a business use case and observe MongoDB documents. In *Chapter
    1*, *Introduction to MongoDB*, you created a MongoDB Atlas account and initiated
    a cluster on the cloud. You will load sample datasets into this cluster. MongoDB
    Atlas provides sample datasets that can be loaded into the cluster by executing
    a few simple steps. These sample databases are large, real-life datasets that
    are made available for practice. The sample dataset in MongoDB Atlas has the following
    databases, where each database has multiple collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sample_mflix`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sample_airbnb`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sample_geospatial`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sample_supplies`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sample_training`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sample_weatherdata`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of all these datasets, it will be the `sample_mflix` dataset that you deal with
    throughout this book. This is a huge database with over 23,000 movies and series
    records along with their ratings, comments, and other details. Before you learn
    about the database, import the database into our cluster and familiarize ourselves
    with its structure and components.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the steps to be executed in order to achieve the desired
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Visit [https://cloud.mongodb.com/](https://cloud.mongodb.com/) and click to
    log in to your account:![Figure 2.12: Atlas login page'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15507_02_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.12: Atlas login page'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since you already have a cluster created on the cloud, upon login, the following
    screen displaying the cluster details will appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13: Cluster view'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_02_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.13: Cluster view'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the (`…`) option available next to `COLLECTIONS`. A drop-down list
    displaying the following options will appear. Click `Load Sample Dataset`:![Figure
    2.14: The Load Sample Dataset option'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15507_02_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.14: The Load Sample Dataset option'
  prefs: []
  type: TYPE_NORMAL
- en: 'This opens a confirmation dialog that shows the total size of a sample dataset
    that will be loaded into your cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.15: Load Sample Dataset confirmation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_02_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.15: Load Sample Dataset confirmation'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click `Load Sample Dataset`. You will see a message saying `Loading your sample
    dataset...` on the screen:![Figure 2.16: Loading your sample dataset… window'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15507_02_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.16: Loading your sample dataset… window'
  prefs: []
  type: TYPE_NORMAL
- en: It may take a few minutes to load the data and redeploy the cluster instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the dataset has successfully loaded, you will see a success message saying
    `Sample dataset successfully loaded`:![Figure 2.17: Sample dataset successfully
    loaded'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15507_02_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.17: Sample dataset successfully loaded'
  prefs: []
  type: TYPE_NORMAL
- en: As the dataset is loaded, you can also see charts showing information about
    the number of read and write operations performed on the dataset, the total connections,
    and the total size of the dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, click `COLLECTIONS`. On the next screen, you will see the following list
    of available databases:![Figure 2.18: List of sample databases'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15507_02_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.18: List of sample databases'
  prefs: []
  type: TYPE_NORMAL
- en: Click the down arrow next to `sample_mflix`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `movies` collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your result for the first 20 documents will be displayed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.19: Movies collection on the cluster'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_02_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.19: Movies collection on the cluster'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we were able to load the `sample_mflix` database into our
    cluster. Let's now perform a simple activity that will help us put our understanding
    of everything we've learned in this chapter to practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 2.01: Modeling a Tweet into a JSON Document'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you understand JSON documents, the data types supported by MongoDB,
    and the document-based storage model, it's time to practice modeling a real-life
    entity into a valid JSON document format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your task is to prepare a valid JSON document to represent the data of a tweet.
    For this, use the dummy tweet shown in *Figure 2.20* From this tweet, identify
    all the various pieces of information that you can find, decide the field names
    and data types they can be represented with, prepare a JSON document with all
    the fields, and validate your document:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.20: Sample tweet'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_02_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.20: Sample tweet'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you achieve the desired result:'
  prefs: []
  type: TYPE_NORMAL
- en: List all the objects that you see in the tweet, such as user ID, name, profile
    picture, tweet text, tags, and mentions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify the set of closely related fields that can be grouped together. These
    groups of fields can be placed as embedded objects or arrays.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have created the JSON document, validate it using any JSON validator
    available online (for example, [https://jsonlint.com/](https://jsonlint.com/)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code represents the final JSON document with only a few fields revealed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found via [this link](B15507_Solution_Final_SZ_ePub.xhtml#_idTextAnchor463).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered a detailed structure of MongoDB documents and
    document-based models, which is important before we dive into more advanced concepts
    in the upcoming chapters. We began our discussion with the transportation and
    storage of information in the form of JSON-like documents that provide a flexible
    and language-independent format. We studied an overview of JSON documents, the
    document structure, and basic data types, followed by BSON document specifications
    and differentiating between BSON and JSON on various parameters.
  prefs: []
  type: TYPE_NORMAL
- en: We then covered MongoDB documents, considering their flexibility, self-containment,
    relatability, and agility, as well as various data types provided by BSON. Finally,
    we made a note of MongoDB's limitations and restrictions for documents and learned
    why the limitations are imposed and why they are important.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will use the mongo shell and Mongo Compass to connect
    to an actual MongoDB server and manage user authentication and authorization.
  prefs: []
  type: TYPE_NORMAL
