- en: File Input and Output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we talked about manipulating files and directories
    as entities without looking at their contents. However, in this chapter, we will
    take a different approach and look into the contents of files: you might consider
    this chapter one of the most important chapters in this book because **file input**
    and **file output** are primary tasks of any operating system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The main purpose of this chapter is to teach how the Go standard library permits
    us to open files, read their contents, process them if we like, create new files,
    and put the desired data into them. There are two main ways to read and write
    files: using the `io` package and using the functions of the `bufio` package.
    However, both packages work in a comparative way.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will tell you about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Opening files for writing and reading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `io` package for file input and output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `io.Writer` and `io.Reader` interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `bufio` package for buffered input and output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying files in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a version of the `wc(1)` utility in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a version of the `dd(1)` command in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating sparse files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The importance of byte slices in file input and output: byte slices were first
    mentioned in [Chapter 2](69bfa048-8113-4a6d-929a-b5addf9b6505.xhtml), *Writing
    Programs in Go*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing structured data in files and reading them afterwards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting tabs into space characters and vice versa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This chapter will not talk about appending data to an existing file: you will
    have to wait until [Chapter 7](a013a7ab-3736-4ea0-a8e7-ec72eb01b0c5.xhtml), *Working
    with System Files*, to learn more about putting data at the end of a file without
    destroying its existing data.'
  prefs: []
  type: TYPE_NORMAL
- en: About file input and output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: File input and output includes everything that has to do with reading the data
    of a file and writing the desired data to a file. There is not a single operating
    system that does not offer support for files and therefore for file input and
    output.
  prefs: []
  type: TYPE_NORMAL
- en: As this chapter is pretty big, I will stop talking and start showing you practical
    Go code that will make things clearer. So, the first thing that you will learn
    in this chapter is byte slices, which are very important in applications that
    are concerned with file input and output.
  prefs: []
  type: TYPE_NORMAL
- en: Byte slices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Byte slices** are a kind of slices used for file reading and writing. Putting
    it simply, they are slices of bytes used as a buffer during file reading and writing
    operations. This section will present a small Go example where a byte slice is
    used for writing to a file and reading from a file. As you will see byte slices
    all over this chapter, make sure that you understand the presented example. The
    related Go code is saved as `byteSlice.go` and will be presented in three parts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part of `byteSlice.go` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you use the `aByteSlice` byte slice to save some text into a file that
    is identified by the `filename` variable. The last part of `byteSlice.go` is the
    following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you define another byte slice named `anotherByteSlice` with `100` places
    that will be used for reading from the file you created previously. Note that
    `%s` used in `fmt.Printf()` forces `anotherByteSlice` to be printed as a string:
    using `Println()` would have produced a totally different output.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that as the file is smaller, the `f.Read()` call will put less data into
    `anotherByteSlice`.
  prefs: []
  type: TYPE_NORMAL
- en: The size of `anotherByteSlice` denotes the maximum amount of data that can be
    stored into it after a single call to `Read()` or after any other similar operation
    that reads data from a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `byteSlice.go` will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Checking the size of the `usingByteSlices` file will verify that the right
    amount of data was written to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: About binary files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is no difference between reading and writing binary and plain text files
    in Go. So, when processing a file, Go makes no assumptions about its format. However,
    Go offers a package named binary that allows you to make translations between
    different encodings such as **little endian** and **big endian**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `readBinary.go` file briefly illustrates how to convert an integer number
    to a little endian number and to a big endian number, which might be useful when
    the files you want to process contain certain kinds of data; this mainly happens
    when we are dealing with raw devices and raw packet manipulation: remember everything
    is a file! The source code of `readBinary.go` will be presented in two parts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'There is nothing special in this part of the program. The second part is the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part contains all the important Go code: the conversions happen
    with the help of the `binary.Write()` method and the proper write parameter (`binary.LittleEndian`
    or `binary.BigEndian`). The `bytes.Buffer` variable is used for the `io.Reader`
    and `io.Writer` interfaces of the program. Lastly, the `buf.Reset()` statement
    resets the buffer in order to be used afterwards for storing the big endian.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `readBinary.go` will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can find more information about the binary package by visiting its documentation
    page at [https://golang.org/pkg/encoding/binary/](https://golang.org/pkg/encoding/binary/).
  prefs: []
  type: TYPE_NORMAL
- en: Useful I/O packages in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `io` package is for performing primitive file I/O operations, whereas the
    `bufio` package is for executing buffered I/O.
  prefs: []
  type: TYPE_NORMAL
- en: In buffered I/O, the operating system uses an intermediate buffer during file
    read and write operations in order to reduce the number of filesystem calls. As
    a result, buffered input and output is faster and more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, you can use some of the functions of the `fmt` package to write
    text to a file. Note that the `flag` package will be also used in this chapter
    as well as in all the forthcoming ones where the developed utilities need to support
    command-line flags.
  prefs: []
  type: TYPE_NORMAL
- en: The io package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `io` package offers functions that allow you to write to or read from files.
    Its use will be illustrated in the `usingIO.go` file, which will be presented
    in three parts. What the program does is read `8` bytes from a file and write
    them in a standard output.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part is the preamble of the Go program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part is the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The program also uses the handy `defer` command that defers the execution of
    a function until the surrounding function returns. As a result, `defer` is used
    very frequently in file I/O operations because it saves you from having to remember
    to execute the `Close()` call after you are done working with a file or when you
    leave a function in any number of locations using a `return` statement or `os.Exit()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `io.ReadFull()` function here reads from the reader of an open file and
    puts the data into a byte slice that has 8 places. You can also see here the use
    of the `io.WriteString()` function for printing data to a standard output (`os.Stdout`)
    that is also a file. However, this is not a very common practice as you can simply
    use `fmt.Println()` instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `usingIO.go` generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The bufio package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The functions of the `bufio` package allow you to perform buffered file operations,
    which means that although its operations look similar to the ones found in `io`,
    they work in a slightly different way.
  prefs: []
  type: TYPE_NORMAL
- en: What `bufio` actually does is to wrap an `io.Reader` or `io.Writer` object into
    a new value that implements the required interface while providing buffering to
    the new value. One of the handy features of the `bufio` package is that it allows
    you to read a text file line by line, word by word, and character by character
    without too much effort.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, an example will try to clarify things: the name of the Go file
    that showcases the use of `bufio` is `bufIO.go` and will be presented in four
    parts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part is the expected preamble:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, you just try to get the name of the file that you are going to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of `bufIO.go` has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The default behavior of `bufio.NewScanner` is to read its input line by line,
    which means that each time you call the `Scan()` method that reads the next token,
    a new line will be returned. The last part is where you actually call the `Scan()`
    method in order to read the full contents of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `Text()` method returns the latest token from the `Scan()` method as a string,
    which in this case will be a line. However, if you ever get strange results while
    trying to read a file line by line, it will most likely be the way your file ends
    a line, which is usually the case with text files coming from Windows machines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `bufIO.go` and feeding `wc(1)` with its output can help you verify
    that `bufIO.go` works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: File I/O operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know the basics of the `io` and `bufio` packages, it is time to
    learn more detailed information about their usage and how they can help you work
    with files. But first, we will talk about the `fmt.Fprintf()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Writing to files using fmt.Fprintf()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The use of the `fmt.Fprintf()` function allows you to write formatted text to
    files in a way that is similar to the way the `fmt.Printf()` function works. Note
    that `fmt.Fprintf()` can write to any `io.Writer` interface and that our files
    will satisfy the `io.Writer` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Go code that illustrates the use of `fmt.Fprintf()` can be found in `fmtF.go`,
    which will be presented in three parts. The first part is the expected preamble:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `os.Create()` function will truncate the file if it already exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, you write the desired text data to the file that is identified by the
    destination variable using `fmt.Fprintf()` as if you were using the `fmt.Printf()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `fmtF.go` will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In other words, you can create plain text files using `fmt.Fprintf()`.
  prefs: []
  type: TYPE_NORMAL
- en: About io.Writer and io.Reader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Both `io.Writer` and `io.Reader` are interfaces that embed the `io.Write()`
    and `io.Read()` methods, respectively. The use of `io.Writer` and `io.Reader`
    will be illustrated in `readerWriter.go`, which will be presented in four parts.
    The program computes the characters of its input file and writes the number of
    characters to another file: if you are dealing with Unicode characters that take
    more than one byte per character, you might consider that the program is reading
    bytes. The output filename has the name of the original file plus the `.Count`
    extension.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, a byte slice is used during reading. The `break` statement allows
    you to exit the `for` loop. The third part is the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see how you can write a number to a file using `fmt.Fprintf()`:
    I did not manage to do the same using a byte slice! Additionally, note that the
    presented code writes text to a file using an `io.Writer` variable (`w`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `readerWriter.go` has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The execution of `readerWriter.go` generates no output; so, it is up to you
    to check its correctness, which in this case happens with the help of `wc(1)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Finding out the third column of a line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know how to read a file, it is time to present a modified version
    of the `readColumn.go` program you saw in [Chapter 3](96c36f62-d505-408c-add5-af84cf25454a.xhtml),
    *Advanced Go Features*. The new version is also named `readColumn.go`, but has
    two major improvements. The first is that you can provide the desired column as
    a command-line argument and the second is that it can read multiple files if it
    gets multiple command-line arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `readColumn.go` file will be presented in three parts. The first part of
    `readColumn.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The next part of `readColumn.go` contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As you will understand from the definition of the `minusCOL` variable, if the
    user does not use this flag, the program will print the contents of the first
    column of each file it reads.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `readColumn.go` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code does not do anything that you have not seen before. The `for`
    loop is used for processing all command-line arguments. However, if a file fails
    to open for some reason, the program will not stop its execution, but it will
    continue processing the rest of the files if they exist. However, the program
    expects that its input files end in a newline and you might see strange results
    if an input file ends differently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `readColumn.go` generates the following output, which is abbreviated
    in order to save some book space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this case, there is no file named `isThereAFile` and the `pF.data` file does
    not have a third column. However, the program did its best and printed what it
    could!
  prefs: []
  type: TYPE_NORMAL
- en: Copying files in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every operating system allows you to copy files because this is a very important
    and necessary operation. This section will show you how to copy files in Go now
    that you know how to read files!
  prefs: []
  type: TYPE_NORMAL
- en: There is more than one way to copy a file!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most programming languages offer more than one way to create a copy of a file
    and Go is no exception. It is up to the developer to decide which approach to
    implement.
  prefs: []
  type: TYPE_NORMAL
- en: The t*here is more than one way to do it* rule applies to almost everything
    implemented in this book, but file copying is the most characteristic example
    of this rule because you can copy a file by reading it line by line, byte by byte,
    or all at once! However, this rule does not apply to the way Go likes to format
    its code!
  prefs: []
  type: TYPE_NORMAL
- en: Copying text files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is no point in treating the copying of text files in a special way unless
    you want to inspect or modify their contents. As a result, the three techniques
    presented here will not differentiate between plain text and binary file copying.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 7](a013a7ab-3736-4ea0-a8e7-ec72eb01b0c5.xhtml)*, Working with System
    Files*, will talk about file permissions because there are times that you want
    to create new files with the file permissions you choose.'
  prefs: []
  type: TYPE_NORMAL
- en: Using io.Copy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This subsection will present a technique for copying files that uses the `io.Copy()`
    function. What is special about the `io.Copy()` function is the fact that is does
    not give you any flexibility in the process. The name of the program will be `notGoodCP.go`
    and will be presented in three parts. Note that a more appropriate filename for
    `notGoodCP.go` would have been `copyEntireFileAtOnce.go` or `copyByReadingInputFileAllAtOnce.go`!
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of the Go code of `notGoodCP.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here we define our own function that uses `io.Copy()` to make a copy of a file.
    The `Copy()` function checks whether the source file is a regular file before
    trying to copy it, which makes perfect sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part is the implementation of the `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The best tool for testing whether a file is an exact copy of another file is
    the `diff(1)` utility, which also works with binary files. You can learn more
    about `diff(1)` by reading its main page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `notGoodCP.go` will generate the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Reading a file all at once!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The technique in this section will use the `ioutil.WriteFile()` and `ioutil.ReadFile()`
    functions. Note that `ioutil.ReadFile()` does not implement the `io.Reader` interface
    and therefore is a little restrictive.
  prefs: []
  type: TYPE_NORMAL
- en: The Go code for this section is named `readAll.go` and will be presented in
    three parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The last part is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `ioutil.ReadFile()` function reads the entire file, which might
    not be efficient when you want to copy huge files. Similarly, the `ioutil.WriteFile()`
    function writes all the given data to a file that is identified by its first argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'The execution of `readAll.go` generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: An even better file copy program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will present a program that uses a more traditional approach, where
    a buffer is used for reading and copying to the new file.
  prefs: []
  type: TYPE_NORMAL
- en: Although traditional Unix command-line utilities are silent when there are no
    errors, it is not bad to print some kind of information, such as the number of
    bytes read, in your own tools. However, the right thing to do is to follow the
    Unix way.
  prefs: []
  type: TYPE_NORMAL
- en: There exist two main reasons that make `cp.go` better than `notGoodCP.go`. The
    first is that the developer has more control over the process in exchange for
    having to write more Go code and the second is that `cp.go` allows you to define
    the size of the buffer, which is the most important parameter in the copy operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code of `cp.go` will be presented in five parts. The first part is the
    expected preamble along with a global variable that holds the size of the read
    buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As you can see here, the size of the buffer is given to the `Copy()` function
    as an argument. The other two command-line arguments are the input filename and
    the output filename.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part has the remaining Go code of the `Copy()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'There is nothing special here: you just keep calling source, `Read()` until
    you reach the end of the input file. Each time you read something, you call destination.
    `Write()` to save it to the output file. The `buf[:n]` notation allows you to
    read the first `n` characters from the `buf` slice.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth part contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `filepath.Base()` is used for getting the name of the executable file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing `cp.go` will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: If there is a problem with the `copy` operation, you will get a descriptive
    error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if the program cannot find the input file, it will print the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'If the program cannot read the input file, you will get the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If the program cannot create the output file, it will print the following error
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If the destination file already exists, you will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Benchmarking file copying operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The size of the buffer you use in file operations is really important and affects
    the performance of your system tools, especially when you are dealing with very
    big files.
  prefs: []
  type: TYPE_NORMAL
- en: Although developing reliable software should be your main concern, you should
    not forget to make your systems software fast and efficient!
  prefs: []
  type: TYPE_NORMAL
- en: So, this section will try to see how the size of the buffer affects the file
    copying operations by executing `cp.go` with various buffer sizes and comparing
    its performance with `readAll.go`, `notGoodCP.go` as well as `cp(1)`.
  prefs: []
  type: TYPE_NORMAL
- en: In the old Unix days when the amount of RAM on Unix machines was too small,
    using a large buffer was not recommended. However, nowadays, using a buffer with
    a size of `100 MB` is not considered bad practice, especially when you know in
    advance that you are going to copy lots of big files such as the data files of
    a database server.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use three files with different sizes in our testing: these three files
    will be generated using the `dd(1)` utility, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The first file is `100 MB`, the second is `1 GB`, and the third is `5 GB` in
    size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it is time for the actual testing using the `time(1)` utility. First,
    we will test the performance of `notGoodCP.go` and `readAll.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you will see the results from the `cp.go` program using four different
    buffer sizes, `16`, `1024`, `1048576`, and `1073741824`. First, let''s copy the
    `100 MB` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will copy the `1 GB` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will copy the `5 GB` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s present the results from the `cp(1)` utility that comes with
    macOS Sierra:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure shows a graph with the values of the real fields from
    the output of the `time(1)` utility for all the aforementioned results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a8e66124-879d-4896-b67f-28ae698552a5.png)'
  prefs: []
  type: TYPE_IMG
- en: Benchmarking results for the various copy utilities
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the results, the `cp(1)` utility does a pretty good job.
    However, `cp.go` is more versatile because it allows you to define the size of
    the buffer. On the other hand, if you use `cp.go` with a small buffer size (16
    bytes), then the entire process will be totally ruined! Additionally, it is interesting
    that `readAll.go` does a pretty decent job with relatively small files and it
    is slow only when copying the `5 GB` file, which is not bad for such a small program:
    you can consider `readAll.go` as a quick and dirty solution!'
  prefs: []
  type: TYPE_NORMAL
- en: Developing wc(1) in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The principal idea behind the code of the `wc.go` program is that you can read
    a text file line by line until there is nothing left to read. For each line you
    read, you find out the number of characters and the number of words it has. As
    you need to read your input line by line, the use of `bufio` is preferred instead
    of the plain `io` because it simplifies the code. However, trying to implement
    `wc.go` on your own using `io` would be a very educational exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'But first, you will see that the `wc(1)` utility generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: So, if `wc(1)` has to process more than one file, it automatically generates
    summary information.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](e9f68321-ac26-49e4-bdae-44b38149afc2.xhtml), *Goroutines - Basic
    Features*, you will learn how to create a version of `wc.go` using Go routines.
    However, the core functionality of both versions will be exactly the same!
  prefs: []
  type: TYPE_NORMAL
- en: Counting words
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The trickiest part of the code implementation is word counting, which is implemented
    using regular expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Here, the provided regular expression separates the words of a line based on
    whitespace characters in order to count them afterwards!
  prefs: []
  type: TYPE_NORMAL
- en: The wc.go code!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After this little introduction, it is time to see the Go code of `wc.go`, which
    will be presented in five parts. The first part is the expected preamble:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part is the implementation of the `countLines()` function, which
    includes the core functionality of the program. Note that the name `countLines()`
    may have been a poor choice as `countLines()` also counts the words and the characters
    of a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Lots of interesting things exist here. First of all, you can see the Go code
    presented in the previous section for counting the words of each line. Counting
    lines is easy because each time the `bufio` reader reads a new line, the value
    of the `numberOfLines` variable is increased by one. The `ReadString()` function
    tells the program to read until the first occurrence of `''\n''` in the input:
    multiple calls to `ReadString()` mean that you are reading a file line by line.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can see that the `countLines()` function returns three integer values.
    Lastly, counting characters is implemented with the help of the `len()` function
    that returns the number of characters in a given string, which in this case is
    the line that was read. The `for` loop terminates when you get the `io.EOF` error
    message, which signifies that there is nothing left to read from the input file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of `wc.go` starts with the beginning of the implementation of
    the `main()` function, which also includes the configuration of the `flag` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The last `for` statement is for processing all the input files given to the
    program. The `wc.go` program supports three flags: the `-c` flag is for printing
    the character count, the `-w` flag is for printing the word count, and the `-l`
    flag is for printing the line count.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This part deals with printing the information on a per file basis depending
    on the command-line flags. As you can see, most of the Go code here is for handling
    the output according to the command-line flags.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This is where you print the total number of lines, words, and characters read
    according to the flags of the program. Once again, most of the Go code here is
    for modifying the output according to the command-line flags.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `wc.go` will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a subtle point here: using Go source files as command-line arguments
    to the `go run wc.go` command will fail. This will happen because the compiler
    will try to compile the Go source files instead of treating them as command-line
    arguments to the `go run wc.go` command. The following output proves this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, trying to execute `wc.go` on a Linux system with Go version 1.3.3
    will fail with the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Comparing the performance of wc.go and wc(1)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this subsection, we will compare the performance of our version of `wc(1)`
    with the `wc(1)` version that comes with macOS Sierra 10.12.6\. First, we will
    execute `wc.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will execute the macOS version of `wc(1)` to process the same files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Let's look at the good news here first; the two utilities generated exactly
    the same output, which means that our Go version of `wc(1)` works great and can
    process big text files!
  prefs: []
  type: TYPE_NORMAL
- en: Now, the bad news; `wc.go` is slow! It took `wc(1)` less than a second to process
    all five files, whereas it took `wc.go` nearly 18 seconds to perform the same
    task!
  prefs: []
  type: TYPE_NORMAL
- en: The general idea when developing software of any kind, on any platform, using
    any programming language, is that you should try to have a working version of
    it, which does not contain any bugs before trying to optimize it and not the other
    way round!
  prefs: []
  type: TYPE_NORMAL
- en: Reading a text file character by character
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although reading a text file character by character is not needed for the development
    of the `wc(1)` utility, it would be good to know how to implement it in Go. The
    name of the file will be `charByChar.go` and will be presented in four parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part is the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Although `charByChar.go` does not have many lines of Go code, it needs lots
    of Go standard packages, which is a naive indication that the task it implements
    is not trivial. The second part is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The third part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The last part has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Here, `ScanRunes` is a split function that returns each character (rune) as
    a token. Then, the call to `Scan()` allows us to process each character one by
    one. There also exist `ScanWords` and `ScanLines` for getting words and lines,
    respectively. If you use `fmt.Println(s.Text())` as the last statement in the
    program instead of `fmt.Print(s.Text())`, then each character will be printed
    on its own line and the task of the program will be more obvious.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `charByChar.go` generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The `wc(1)` command can verify the correctness of the Go code of `charByChar.go`
    by comparing the input file with the output generated by `charByChar.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Doing some file editing!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will present a Go program that converts tab characters to space
    characters in files and vice versa! This is the job that is usually done by a
    text editor, but it is good to know how to perform it on your own.
  prefs: []
  type: TYPE_NORMAL
- en: The code will be saved in `tabSpace.go` and will be presented in four parts.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `tabSpace.go` reads text files line by line, but you can also develop
    a version that reads text file character by character.
  prefs: []
  type: TYPE_NORMAL
- en: In the current implementation, all the work is done with the help of regular
    expressions, pattern matching, and search and replace operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part is the expected preamble:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The third part contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The last part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: This part is where the magic happens using the appropriate `strings.Replace()`
    call. In its current implementation, each tab is replaced by four space characters
    and vice versa, but you can change that by modifying the Go code.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, a big part of `tabSpace.go` relates to error handling because many
    strange things can happen when you try to open a file for reading!
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the Unix philosophy, the output of `tabSpace.go` will be printed
    on the screen and will not be saved in a new text file. Using `tabSpace.go` with
    `wc(1)` can prove its correctness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Interprocess communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Interprocess communication** (**IPC**), putting it simply, is allowing Unix
    processes to talk to each other. Various techniques exist that allow processes
    and programs to talk to each other. The single most popular technique used in
    Unix systems is the pipe, which exists since the early Unix days. [Chapter *8*](defd267a-724b-4983-a51f-7cda6bba93aa.xhtml),
    *Processes and Signals*, will talk more about implementing Unix pipes in Go. Another
    form of IPC is Unix domain sockets, which will also be discussed in [Chapter *8*](defd267a-724b-4983-a51f-7cda6bba93aa.xhtml),
    *Processes and Signals*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter *12*](fe18fc6b-5b18-4a49-ad25-78909d80232f.xhtml), *Network Programming*,
    will talk about another form of Interprocess communication, which is network sockets.
    Shared memory also exists, but Go is against the use of shared memory as a means
    of communication. [Chapter *9*](e9f68321-ac26-49e4-bdae-44b38149afc2.xhtml), *Goroutines
    - Basic Features*, and [Chapter 10](7926b940-94d5-4525-a6be-19e7acc64c05.xhtml),
    *Goroutines - Advanced Features*, will show various techniques that allow goroutines
    to communicate with others and share and exchange data.'
  prefs: []
  type: TYPE_NORMAL
- en: Sparse files in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Large files that are created with the `os.Seek()` function may have holes in
    them and occupy fewer disk blocks than files with the same size, but without holes
    in them; such files are called sparse files. This section will develop a program
    that creates sparse files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Go code of `sparse.go` will be presented in three parts. The first part
    is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part of `sparse.go` has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The `strconv.ParseInt()` function is used for converting the command-line argument
    that defines the size of the sparse file from its string value to its integer
    value. Additionally, the `os.Stat()` call makes sure that you will not accidentally
    overwrite an existing file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part is where the action takes place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: First, you try to create the desired sparse file using `os.Create()`. Then,
    you call `fd.Seek()` in order to make the file bigger without adding actual data.
    Lastly, you write a byte to it using `fd.Write()`. As you do not have anything
    more to do with the file, you call `fd.Close()` and you are done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `sparse.go` generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'How can you tell whether a file is a sparse file or not? You will learn this
    in a while, but first, let''s create some files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that some Unix variants will not create sparse files: the first such Unix
    variant that comes to mind is macOS that uses the HFS filesystem. Therefore, for
    better results, you can execute all these commands on a Linux machine.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how can you tell if any of these three files is a sparse file or not? The
    `-s` flag of the `ls(1)` utility shows the number of filesystem blocks actually
    used by a file. So, the output of the `ls -ls` command allows you to detect if
    you are dealing with a sparse file or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Now look at the first column of the output. The `noSparseDD` file, which was
    generated using the `dd(1)` utility, is not a sparse file. The `sparseDD` file
    is a sparse file generated using the `dd(1)` utility. Lastly, the `testSparse`
    is also a sparse file that was created using `sparse.go`.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing data records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section will teach you how to deal with writing and reading data records.
    What differentiates a record from other kinds of text data is that a record has
    a given structure with a specific number of fields: think of it as a row from
    a table in a relational database. Actually, records can be very useful for storing
    data in tables in case you want to develop your own database server in Go!'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Go code of `records.go` will save data in the CSV format and will be presented
    in four parts. The first part contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'So, this is where you have to declare that you are going to read or write data
    in the CSV format. The second part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The third part of the program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: You should be familiar with the operations in this part; the biggest difference
    from what you have seen so far in this chapter is that the writer is from the
    `csv` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `records.go` has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The `reader` reads the entire file at once to make the whole operation faster.
    However, if you are dealing with huge data files, you might need to read smaller
    parts of the file each time until you have read the complete file. The used `reader`
    is from the `csv` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `records.go` will create the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The CSV file, which is named `recordsDataFile`, contains the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: File locking in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are times that you do not want any other child of the same process to
    change a file or even access it because you are changing its data and you do not
    want the other processes to read incomplete or inconsistent data. Although you
    will learn more about file locking and go routines in [Chapter 9](e9f68321-ac26-49e4-bdae-44b38149afc2.xhtml),
    *Goroutines - Basic Features* and [Chapter 10](7926b940-94d5-4525-a6be-19e7acc64c05.xhtml),
    *Goroutines - Advanced Features*, this chapter will present a small Go example
    without a detailed explanation in order to give you an idea about how things work:
    you should wait until [Chapter 9](e9f68321-ac26-49e4-bdae-44b38149afc2.xhtml),
    *Goroutines - Basic Features* and [Chapter 10](7926b940-94d5-4525-a6be-19e7acc64c05.xhtml),
    *Goroutines - Advanced Features*, to learn more.'
  prefs: []
  type: TYPE_NORMAL
- en: The presented technique will use `Mutex`, which is a general synchronization
    mechanism. The `Mutex` lock will allow us to lock a file from within the same
    Go process. As a result, this technique has nothing to do with the use of the
    `flock(2)` system call.
  prefs: []
  type: TYPE_NORMAL
- en: Various techniques exist for file locking. One of them is by creating an additional
    file that signifies that another program or process is using a given resource.
    The presented technique is more suitable for programs that use multiple go routines.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file locking technique for writing will be illustrated in `fileLocking.go`,
    which will be presented in four parts. The first part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The locking of the file is done using the `mu.Lock()` statement and the unlocking
    of the file with the `mu.Unlock()` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The last part is the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing `fileLocking.go` will create the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The correct version of `fileLocking.go` has a call to `mu.Unlock()` at the
    end of the `writeDataToFile()` function, which allows all goroutines to use the
    file. If you remove that call to `mu.Unlock()` from the `writeDataToFile()` function,
    and execute `fileLocking.go`, you will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The reason for getting this output is that apart from the first goroutine that
    will be able to execute the `mu.Lock()` statement, the rest of them cannot get
    `Mutex`. Therefore, they cannot write to the file, which means that they will
    never finish their jobs and wait forever, which is the reason that Go is generating
    the aforementioned error messages.
  prefs: []
  type: TYPE_NORMAL
- en: If you do not completely understand this example, you should wait until [Chapter
    9](e9f68321-ac26-49e4-bdae-44b38149afc2.xhtml), *Goroutines - Basic Features*
    and [Chapter 10](7926b940-94d5-4525-a6be-19e7acc64c05.xhtml), *Goroutines - Advanced
    Features*.
  prefs: []
  type: TYPE_NORMAL
- en: A simplified Go version of the dd utility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `dd(1)` tool can do many things, but this section will implement a small
    part of its functionality. Our version of `dd(1)` will include support for two
    command-line flags: one for specifying the block size in bytes (`-bs`) and the
    other for specifying the total number of blocks that will be written (`-count`).
    Multiplying these two values will give you the size of the generated file in bytes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Go code is saved as `ddGo.go` and will be presented to you in four parts.
    The first part is the expected preamble:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part contains the Go code of two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: The first function is for getting random numbers and the second one is for creating
    a byte slice with the desired size filled with random numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of `ddGo.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Here, you mainly deal with the command-line arguments of the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: The reason for emptying the `buf` byte slice each time you want to call `createBytes()`
    is that you do not want the `buf` byte slice to get bigger and bigger each time
    you call the `createBytes()` function. This happens because the `append()` function
    adds data at the end of a slice without touching the existing data.
  prefs: []
  type: TYPE_NORMAL
- en: In the first version of `ddGo.go` that I wrote, I forgot to empty the `buf`
    byte slice before each call to `createBytes()`. Consequently, the generated files
    were bigger than expected! It took me a while and a couple of `fmt.Println(buf)`
    statements to find out the reason for this unforeseen behavior!
  prefs: []
  type: TYPE_NORMAL
- en: 'The execution of `ddGo.go` will generate the files you want quite fast:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, the use of random numbers makes the generated files of the same
    size different from each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visit the documentation page of the `bufio` package that can be found at [https://golang.org/pkg/bufio/](https://golang.org/pkg/bufio/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visit the documentation of the `io` package at [https://golang.org/pkg/io/](https://golang.org/pkg/io/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to make `wc.go` faster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the functionality of `tabSpace.go`, but try to read your input text
    files character by character instead of line by line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the code of `tabSpace.go` in order to be able to get the number of spaces
    that will replace a tab as a command-line argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Learn more information about the little endian and the big endian representations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we talked about file input and output in Go. Among other things,
    we developed Go versions of the `wc(1)`, `dd(1)`, and `cp(1)` Unix command-line
    utilities while learning more about the `io` and `bufio` packages of the Go standard
    library, which allow you to read from and write to files.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about another important subject, which is
    the Go way of working with the system files of a Unix machine. Additionally, you
    will learn how to read and change the Unix file permissions as well as how to
    find the owner and the group of a file. Also, we will talk about log files and
    how you can use pattern matching to acquire the information you want from log
    files.
  prefs: []
  type: TYPE_NORMAL
