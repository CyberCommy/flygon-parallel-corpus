- en: Real-World Challenges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many challenges a JavaScript programmer faces may not be with the language itself
    but with the ecosystems that their code must exist within and interface with.
    JavaScript is usually used in the context of the web, on either a browser or server,
    and so the problem domains encountered are usually characterized by topics such
    as HTTP and the DOM. We often have to wrestle with frameworks, APIs, and mechanisms
    that can sometimes seem awkward, unintuitive, and complicated. In this chapter,
    we're going to familiarize ourselves with some of the most common challenges and
    the approaches and abstractions we can use to surmount them.
  prefs: []
  type: TYPE_NORMAL
- en: We will begin by exploring the DOM and the challenges inherent in building ambitious
    **Single-Page Applications** (**SPAs**) in JavaScript. We'll then explore the
    topics of **dependency management** and **security** as these are both increasingly
    vital competencies in today's landscape. This chapter is not intended as an exhaustive
    coverage of topics, but rather a quick whirlwind of deep-dives that you may find
    relevant to the weighty task of crafting clean JavaScript on today's web platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The DOM and single-page applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security (XSS, CSRF, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The DOM and single-page applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Document Object Model** (**DOM**) API is provided within browsers to allow
    developers to read from and dynamically mutate web documents. Upon its initial
    introduction in 1997, it was very limited in scope but has expanded greatly in
    the last two decades, allowing us to now have programmatic access to a wide variety
    of browser functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The DOM itself presents us with a hierarchy of elements that are derived from
    the parsed HTML of a given page. This hierarchy is made accessible to JavaScript
    via an API. This API allows us to select elements, traverse trees of elements,
    and inspect element properties and characteristics. Here is an example of a DOM
    tree with the corresponding JavaScript used to access it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e30de7af-6916-41c0-b2ab-0059d0644e66.png)'
  prefs: []
  type: TYPE_IMG
- en: The way we access specific DOM nodes has changed over the years but its fundamental
    tree-like structure has remained the same. Via access to this structure, we can
    read from the elements, mutate them, or indeed add to the tree of elements ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Alongside the DOM API is a collection of other natively provided browser APIs
    that make it possible to do things such as reading cookies, mutating local storage,
    setting up background tasks (*workers*), and operating on the **CSS Object Model**
    (**CSSOM**).
  prefs: []
  type: TYPE_NORMAL
- en: As recently as the year 2012, it was quite typical for web developers to only
    use JavaScript to enhance experiences already manifested in the markup of a page.
    For example, they might've simply added a rollover state to a button or validation
    to a form field. Such additions were considered a type of *progressive enhancement*,
    where the user could experience the website without JavaScript if they wanted
    but having JavaScript enabled would enhance their experience in some small way.
  prefs: []
  type: TYPE_NORMAL
- en: '**Progressive enhancement** is a principle that espouses the importance of
    functionality that is resilient to environmental constraints. It tells us that
    we should try to provide all users with as much functionality as their environment
    allows. It is often conceptually paired with **graceful** **d****egradation**,
    which is the ability for a piece of software to maintain limited functionality
    even when its dependencies are unmet or only partially met (for example, a client-side
    validated `<form>` that is submittable even on browsers without JavaScript support
    is said to *gracefully degrade*).'
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, however, it is far more common to have the frontend portion of a web
    application built almost entirely with JavaScript and expressed within a single
    *page*. These are often termed SPAs. Instead of having the user naturally navigate
    around a website, loading up new pages within the browser upon each action, the
    SPA will instead rewrite the current page's content and the current browser address.
    SPAs are therefore dependent upon the user's browser supporting JavaScript and
    potentially other APIs too. SPAs typically do not gracefully degrade, although
    it is best practice (and good sense!) to provide a series of fallbacks so that
    the entire audience can receive functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The proliferation of the SPA can be attributed to both developer experience
    and user experience boosts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Architecture (DX)**: There is a nicer *separation of concerns* between the
    frontend client and the backend API layer. This can lead to a cleaner architecture
    that helpfully delineates *business logic* from UI. Having one code base that
    governs both the rendering and dynamic enhancement can vastly simplify things
    as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State persistence (UX)**: Users can navigate and execute actions within a
    web application without having to lose in-page state, such as populated input
    fields or scroll-position. Additionally, the UX can include multiple different
    panes, modals, or sections that populate independently and can be persisted regardless
    of other actions taken.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance (UX)**: The bulk of HTTP resources can be loaded just once within
    the user''s browser, increasing the performance of any further actions or navigations
    within the application. That is, after the initial load of the application, any
    further requests can be optimized to be simple JSON REST responses with no unnecessary
    boilerplate markup so the browser spends less time re-parsing or re-rendering
    boilerplate HTML, CSS, and JavaScript.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The growing demands on web applications and the proliferation of the SPA have
    meant that programmers have come to rely much more on browser APIs, especially
    the DOM, to create rich and dynamic experiences. The painful truth, however, is
    that the DOM was never intended to cater to the creation of rich desktop-like
    experiences. Because of this, there have been many growing pains in bringing the
    DOM up to scratch with current demands. Additionally, there has been a slow and
    iterative process of creating frameworks that enable the development of rich experiences
    atop a platform that was not originally designed for them.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most obvious ways in which the DOM (and browser APIs generally) does
    not meet the current demands of SPAs is experienced when trying to *bind the DOM
    to data*. We will now explore this topic in more depth.
  prefs: []
  type: TYPE_NORMAL
- en: DOM binding and reconciliation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One specific challenge that multiple frameworks have attempted to solve over
    the years is the *binding* of the DOM to data. We briefly discussed data-binding
    in the last chapter's section on MVVM. Any GUI needs to have a way of having its
    displayed pixels reflect its underlying data.
  prefs: []
  type: TYPE_NORMAL
- en: Via the DOM, we can dynamically create specific elements and place them as we
    wish. The user can then impose their intent on the application by interfacing
    with these elements, usually via input fields and buttons. These user actions,
    which we bind to via DOM events, may then affect a change in underlying data.
    This change needs to be reflected in the DOM. This *back-and-forth* is usually
    termed *two-way-binding.* Historically, to achieve this, we would manually create
    a DOM tree, set up event listeners on elements, and then manually mutate those
    DOM elements when any underlying data (or *state*) changed.
  prefs: []
  type: TYPE_NORMAL
- en: '**A reminder**: *State* is the current *situation* of a program: everything
    the user sees and everything that underlies what they see. The *state* of a given
    application may be represented in more than one place, and these representations
    may become out-of-sync. We can imagine a scenario in which the same data is displayed
    in two places but is not consistent.'
  prefs: []
  type: TYPE_NORMAL
- en: The challenge in manually fiddling with the DOM ourselves is that it doesn't
    scale very well without some kind of abstraction. It is easy enough to take a
    piece of data and derive a DOM tree from that data, but having the DOM tree tied
    to changes within the data and having the data tied to user-derived changes in
    the DOM (for example, clicking on buttons) are quite burdensome things to implement.
  prefs: []
  type: TYPE_NORMAL
- en: DOM reconciliation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To illustrate this challenge, consider a simple shopping list in the form of
    an array composed of individual items as strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Deriving a DOM tree from this data is quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This code would produce the following DOM tree (and append it to `<body>`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'But what happens if our data changes? And what would happen if there were `<input>`
    via which users could add new items? To accommodate these things, we would have
    to implement an abstraction to hold our data and raise events (or invoke callbacks)
    whenever the data changes. Additionally, we''d need some way of tying each individual
    data item to a DOM node. If the first item, `"Bananas"` were to be changed to
    `"Melons"`, then we should only make the minimum mutations necessary to the DOM
    to reflect that change. In this case, we would want to replace the first `<li>`
    element''s inner text node''s `data` property (in other words, the actual text
    contained within the text node):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This type of change, in abstract terms, is known as *DOM reconciliation* and
    involves reflecting any changes made to data within the DOM. There are broadly
    three types of reconciliation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Update**: If an existing data item is updated, then the corresponding DOM
    node should be updated to reflect the change'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deletion**: If an existing data item is removed, then the corresponding DOM
    node should also be removed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Creation**: If a new data item is added, then a new DOM node should be created,
    appended to the correct place in the live DOM tree, and then linked as the corresponding
    DOM node for that data item'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DOM reconciliation is a relatively simple process. We could easily create `ShoppingListComponent`
    ourselves with the ability to update/add/remove items, but it would be very highly
    coupled to the structure of the data and the DOM. The logic pertaining just to
    a singular update may involve, as we've seen, the specific mutation of a text
    node's content. If we want to change our DOM tree slightly or the structure of
    our data, then we have to significantly refactor our `ShoppingListComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: React's approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many modern libraries and frameworks have sought to make this a less burdensome
    process by abstracting the DOM reconciliation process away behind a declarative
    interface. A good example of this is React, which allows you to declare your DOM
    tree declaratively using its JSX syntax within your JavaScript. JSX looks like
    regular HTML with the addition of interpolation delimiters (`{...}`) where regular
    JavaScript can be written to express data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we are creating a component that produces a simple `<h1>` greeting populated
    with an uppercase `name`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `LoudGreeting` component could be rendered to `<body>` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And that would result in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We might implement a `ShoppingList` component in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And then we could render it in the following way, passing our specific shopping
    list items in our invocation of the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple example but gives us an idea of how React works. The true magic
    of React is in its ability to selectively re-render the DOM in reaction to changes
    in data. We can explore this in our example by changing data in reaction to a
    user action.
  prefs: []
  type: TYPE_NORMAL
- en: 'React and most other frameworks give us a straightforward mechanism of event-listening
    so that we can listen for user events in the same manner as we would conventionally.
    Via React''s JSX, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case of the shopping list problem domain, we want to create `<input
    />`, which can receive new items from users. To accomplish this, we can create
    a separate component called `ShoppingListAdder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using a React Hook (called `useRef`) to give us a persistent reference
    that we can re-use between component renders to reference our `<input />`.
  prefs: []
  type: TYPE_NORMAL
- en: '**React Hooks** (typically named `use[Something]`) are a relatively recent
    addition to React. They''ve simplified the process of keeping persistent state
    across component renders. A re-render occurs whenever our `ShoppingListAdder`
    function is invoked. But `useRef()` will return the same reference on every single
    call within `ShoppingListAdder`. A singular React Hook can be thought of as the
    *Model* in MVC.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To our `ShoppingListAdder` component, we are passing an `onAdd` callback, which
    we can see is called whenever the user has added a new item (in other words, when
    the `<form>` submits). To make use of a new component, we want to place it within
    `ShoppingList` and then respond when `onAdd` is invoked by adding a new item to
    our list of food:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we are using another type of React Hook called `useState` to
    persist the storage of our items. `initialItems` can be passed into our component
    (as an argument) but we then derive a set of persistent items from these that
    we can mutate freely across re-renders of our component. And that''s what our
    `onAdd` callback is doing: it is adding a new item (entered by the user) to the
    current list of items:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/34c61e29-1f0f-445c-9c15-1f7fcbcf5027.png)'
  prefs: []
  type: TYPE_IMG
- en: Calling `setItems` will, behind the scenes, invoke a re-render of our component,
    causing `<li>Coffee</li>` to be appended to the live DOM. Creations, updates,
    and deletions are all handled similarly. The beauty of abstractions like React
    is that you don't need to think of these mutations as distinct pieces of DOM logic.
    All we need to do is derive a component/DOM tree from our set of data and React
    will figure out the precise changes needed to reconcile the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure we understand what''s going on, when a piece of data (*state*) is
    changed via a Hook (for example, `setItems(...)`), React does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: React re-invokes the component (re-renders)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: React compares the tree returned from the re-render with the previous tree
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: React makes the essential granular mutations to the live DOM for all of the
    changes to be reflected
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Other modern frameworks borrow from this approach as well. One nice side-effect
    of DOM reconciliation mechanisms built into these abstractions is that, via their
    declarative syntax, we can derive a deterministic tree of components from any
    given data. This is in stark contrast to the imperative approach, within which
    we must manually select and mutate specific DOM nodes ourselves. The declarative
    approach gives us a functional purity that enables us to produce outputs that
    are deterministic and idempotent.
  prefs: []
  type: TYPE_NORMAL
- en: As you may recall from [Chapter 4](98ac69ed-3848-4359-b9fb-1a9f8b8daed4.xhtml), *SOLID
    and Other Principles*, **functional purity** and **idempotence** give us standalone
    testable units of predictable input and output. They allow us to say *X input
    will always result in Y output*. This transparency aids tremendously in both the
    reliability and the comprehensibility of our code.
  prefs: []
  type: TYPE_NORMAL
- en: Building large web applications, even with the reconciliation puzzle out of
    the way, is still a challenge. Every component or view within a given page needs
    to be populated with its correct data and needs to propagate changes. We'll be
    exploring this challenge next.
  prefs: []
  type: TYPE_NORMAL
- en: Messaging and data propagation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building a web application, you'll quickly run into the challenge of getting
    different *parts* or *components* within your page to talk to each other. At any
    single time, your application should be representing the exact same set of data.
    If something changes, either via user action or some other mechanism, that change
    needs to be reflected in all of the appropriate places.
  prefs: []
  type: TYPE_NORMAL
- en: 'This problem occurs at different scales. You may have a *chat* application
    where an entered message needs to be propagated to all participants as fast as
    possible. Or you may have a piece of data that needs to be represented several
    times within the same application view and hence all of these representations
    need to be kept in sync. For example, if a user changes their forename in a *profile
    settings* pane, then this should reasonably update other places in the visible
    application where their forename appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/45bf7759-0c3f-42e9-aa07-22663cda0a84.png)'
  prefs: []
  type: TYPE_IMG
- en: In a conventional non-SPA, the Save personal info button would simply submit
    a `<form>` and the page would then fully reload and a brand new chunk of markup
    with the updated state would be sent down from the server. Within an SPA, it is
    slightly more complicated. We would need to both submit the data to the server
    and then somehow update only the relevant portions of the page with the new data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, we have to think carefully about the flow of data or
    *state* within our application. The challenge is reflecting the *source of truth* for
    the relevant data as soon as possible in all of the places it needs to be represented.
    To achieve this, we need a way for different parts of our code base to talk to
    each other. There are a couple of paradigms we can use here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Event-oriented**: This means having specific global events that can be emitted
    and listened to (for example, `userProfileNameChange`). Any component or view
    within a page can then bind to this event and react accordingly by updating its
    content. The *state*, therefore, exists at the same time in many different areas
    (amongst various components or views).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State-oriented**: This means having a global state object that contains the
    single *source of truth* for the user''s forename. This state object, or parts
    of it, can be recursively passed down through a component tree, meaning that,
    upon any change, the entire component tree is *fed* with the new state. The *state* is
    therefore centralized yet propagated whenever a change occurs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we consider a user changing their forename via `<input />`, we can envisage
    the following distinct paths of data flow to all components that depend upon the
    forename data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/29c6b943-7c84-425e-99b5-13e87aa6fb50.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fundamentally, these approaches achieve the same thing: they render data to
    the DOM. The crucial thing that differs is how the change, in this case, a mutation
    of the forename, is communicated throughout the application and where the data
    resides at any one time:'
  prefs: []
  type: TYPE_NORMAL
- en: The **event-oriented** paradigm has data living in several places at once. So,
    if, for whatever reason, one of those places fails to bind to the mutation of
    that event, then you can end up with out-of-sync data representations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **state-oriented** paradigm only has one canonical representation of the
    data and effectively *pipes* it to the relevant views or components, so that they
    are always hydrated with the latest version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The state-oriented paradigm is the increasingly more prevalent approach as
    it enables us to think in a clearer way about our data and its representations.
    We can say that we have a single representation of the data and that we derive
    components (or UI) from that data. It''s a functionally pure approach since a
    component is really just a deterministic *mapping* of data to a given UI. Since
    any given component only cares about its input data, it doesn''t need to make
    too many assumptions about the context it lives within. For example, we may have
    a `UserInfo` component, with an expected input of four values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Since this component does not rely on any global events or other contextual
    assumptions, it can be easily isolated. This aids not only in comprehension and
    maintainability but also enables us to write simpler tests. The `UserInfo` component
    can be extracted and tested by itself, with no inter-dependencies with the application
    in which it will eventually reside.
  prefs: []
  type: TYPE_NORMAL
- en: 'React is a popular framework for expressing this state-oriented paradigm, but
    many other frameworks are following suit. In React, combined with JSX, we may
    express our `UserInfo` component like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that this component''s output is merely a mapping of its input.
    Such a simple case of I/O can easily be tested and reasoned about. The beauty
    of this harks back to the **Law of Demeter** (**LoD**), which we covered in [Chapter
    4](https://cdp.packtpub.com/clean_code_in_javascript/wp-admin/post.php?post=356&action=edit#post_139), *SOLID
    and Other Principles*, which tells us that the `UserInfo` component has no business
    knowing where its data comes from or where it is used; it only needs to fulfill
    its singular responsibility: from its four inputs, it simply needs to provide
    us with a DOM hierarchy—clean and beautiful.'
  prefs: []
  type: TYPE_NORMAL
- en: There is, naturally, a lot more complexity in real-life web applications that
    we have not been able to draw out with our forename example. However, if we remember
    the basics of separating concerns, and building views or components that are well
    isolated and functionally pure, then there are few challenges we won't be able
    to solve cleanly.
  prefs: []
  type: TYPE_NORMAL
- en: Frontend routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building web applications, we will likely need to mutate the address the
    user sees within the browser to reflect the current resource being accessed. This
    is a core tenet of how browsers and HTTP work. An HTTP address should represent
    a resource. And so, when the user wishes to change the resource they are viewing,
    the address should correspondingly change.
  prefs: []
  type: TYPE_NORMAL
- en: Historically, the only way of mutating the current URL within the browser would
    be for the user to navigate to a different page via an `<a href>` or similar.
    When SPAs started to become popular, however, JavaScript programmers needed to
    get creative. In the early days, a popular *hack* would be to mutate the hash
    component of a URL (`example.org/path/#hash`), which would give the user the experience
    of traversing a traditional website where each navigation or action would result
    in a new address and a new entry in the browser's history, hence enabling the
    use of the back-and-forward buttons in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: The approach of mutating the `#hash` of a URL was famously used in Google's
    Gmail application when it launched in 2004 so that the address bar in the browser
    would accurately express what email or view you were currently looking at. Many
    other SPAs followed suit.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few years later, thankfully, the History API found its way into browsers
    and is now the standard for mutating the address in response to navigations or
    actions within an SPA. Specifically, this API allows us to manipulate the browser
    session history by pushing new *states* or replacing current ones. For example,
    when a user expresses a wish to change to the `About Us` view within a fictional
    SPA, we can express this as a new state pushed to their history, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This would immediately change the address in the browser to `''/about''`*.*
    Typically, the calling code would also instigate the rendering of the associated
    view. Routing is the name given to these combined processes of rendering the new
    DOM and mutating the browser''s history. Specifically, a router takes responsibility
    for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Rendering the view, component, or page that corresponds to the current address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exposing an interface to other code so that navigation can be instigated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listening for changes to the address made by the user (the `popstate` event)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To illustrate these responsibilities, we can create a simple router for an
    application that very simply displays `Hello {color}!` atop a background of that
    very color for any color represented in the path of the URL. Hence, `/red` will
    render a red background with the text, `Hello red!`. And `/magenta` will render
    a magenta background with the text, `Hello magenta!`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a9fc8405-78c4-41c6-94f5-9281586c763e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And here is our implementation of `colorRouter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we're using the C*lass Singleton pattern* here (as introduced in
    the last chapter). Our `colorRouter` abstraction is well-suited to this pattern
    as we need specific construction logic and we want to present a singular interface.
    We could have also used the **Revealing Module** pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this router, we can then call `colorRouter.go()` with our color and it''ll
    change the address and be rendered as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'There is, even in this simple scenario, some complexity in our router. When
    the user originally lands on the page via conventional browsing, for example, perhaps
    by typing `example.org/red` into the address bar, the state of the history object
    will be empty, as we have not yet informed that browser session that `/red` is
    tied to the piece of state, `{ color: "red" }`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To populate this initial state, we need to grab the current `location.pathname`
    (`/red`) and then extract the color from it by removing the initial forward-slash.
    You can see this logic in the `colorRouter` constructor function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: For more complex paths, this logic can start to get quite complex. In a typical
    router, many different patterns of paths will need to be accommodated for. As
    such, usually, a URL parsing library will be used to properly extract each part
    of the URL and allow the router to route that address correctly.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to use a properly constructed URL parsing library for use in
    production routers. Such libraries tend to accommodate all of the edge-cases implicit
    in URLs, and should ideally be compliant with the URI specification (*RFC 3986*).
    An example of this would be `URI.js` (available on npm as `uri-js`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Various routing libraries and routing abstractions within larger frameworks
    have emerged over the years. They are all slightly different in the interface
    they present to the programmer. React Router, for example, allows you to declare
    your independent routes as a series of React components via JSX syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Vue.js, a different framework, provides a unique routing abstraction of its
    own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You may notice that, in both examples, there is a URL path specified as `/about/:employee`.
    The colon followed by a given token or word is a common way to designate that
    a specific portion of the path is dynamic. It''s typical to need to dynamically
    respond to a URL that contains a piece of identifying information concerning a
    specific resource. It''s reasonable that all of the following pages should produce
    different content:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/about/john`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/about/mary`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/about/nika`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It would be incredibly burdensome to specify these all as individual routes
    (and near impossible with large datasets), so routers will always have some way
    of expressing these dynamic portions. The hierarchical nature of URLs is usually
    also mirrored in the declarative APIs provided by routers and will typically allow
    us to specify a hierarchy of components or views to render in response to such
    hierarchical URLs. Here''s an example of a `routes` designation that could be
    passed to the Router service of Angular (another popular framework!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that `AboutEmployeeComponent` is attached to the path of `about/:employee` and
    has sub-components that are each attached to the sub-paths of `hobbies` and `hobbies/:hobby`.
    An address such as `/about/john/hobbies/kayaking` would intuitively render `AboutEmployeeComponent`
    and within that would render `EmployeeHobbyComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: You can probably observe here how intertwined a router is with rendering. It
    is indeed possible to have standalone routing libraries, but it's far more typical
    for frameworks to provide a routing abstraction themselves. This allows us to
    specify our routes alongside a view or component or widget, or whatever abstraction
    our framework provides for rendering things to the DOM. Fundamentally, although
    different on the surface, all of these frontend routing abstractions will achieve
    the same result.
  prefs: []
  type: TYPE_NORMAL
- en: Another real-world challenge that many JavaScript programmers will expose themselves
    to, whether they're predominately working on the client side or server side, is
    that of dependency management. We'll begin exploring this next.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Loading JavaScript within the context of a single web page used to be simple.
    We could simply place a couple of `<script>` tags somewhere within the document's
    source and call it a day.
  prefs: []
  type: TYPE_NORMAL
- en: Over the years, however, the complexity of our JavaScript has grown tremendously,
    alongside the demands of our users. Alongside this, our code bases have grown
    as well. It was, for a period, natural to just keep adding more and more `<script>`
    tags. At a certain point, though, this approach falters. Apart from the burden
    of multiple HTTP requests being made on every page load, this approach also made
    it hard for programmers to juggle their dependencies. JavaScript was typical,
    in those days, to spend time carefully ordering `<script>` placements so that,
    for any particular script, its dependencies were in place before it itself loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'It was not uncommon to see HTML markup like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This approach was expensive from a performance perspective as the browser had
    to fetch every resource before continuing to parse and render the remaining document.
    Large collections of inline scripts in the `<head>` of an HTML document were hence
    considered an anti-pattern as they would block the user from being able to use
    the website for a significant amount of time. Even moving scripts to the bottom
    of `<body>` wasn't ideal as browsers would still have to load and execute them
    serially.
  prefs: []
  type: TYPE_NORMAL
- en: Predictably, our increasingly complex applications started to outgrow this approach.
    Developers needed more performance and a finer level of control over script loading.
    Thankfully, over the years, various improvements have been made in how we manage
    dependencies, how we bundle them, and how we then serve our code bases to the
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll explore the improvements that have occurred over the
    years and will seek to understand what the current best practices are, as well.
  prefs: []
  type: TYPE_NORMAL
- en: Module definition – then and now
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before 2010 (*approximately*), there were very few agreed upon methods of loading
    large and complex JavaScript code bases within the browser. Soon, however, developers
    created the **Asynchronous Module Definition** (**AMD**) format. This was the
    first popular attempt at a standard that prescribed the definition of modules
    within JavaScript. It included both the ability to declare dependencies on each
    module and an asynchronous loading mechanism. This was a vast improvement upon
    the slow and blocking nature of multiple inline `<script>` tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'RequireJS was a popular library that supported this format. To use it, you
    only needed to place a single entry point `<script>` in your document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `data-main` attribute here would specify the entry point of our code base,
    which itself would then load the initial set of dependencies and initialize the
    application, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Each dependency would then `define` itself and its own dependencies, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This is similar in spirit to modules as now specified in the ECMAScript specification,
    except AMD is not related to any particular language syntax. It was entirely a
    community-driven effort to bring something like modules to JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that AMD prescribed that each module was defined within a callback,
    to which dependencies could be passed, meant that loading utilities such as RequireJS
    could load all dependencies asynchronously and then invoke the callback when it
    was done. This was a significant boost to frontend JavaScript at the time because
    it meant we could quite easily load massive dependency graphs in a way that eased
    the process of writing the code (less dependency juggling) and enabled the code
    to be loaded into the browser in a non-blocking and more performant fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 'At a similar time to AMD, a new standards-driven effort started to emerge called
    **CommonJS**. This sought to make the `require(...)` syntax a standard in various
    non-browser environments, with the hopeful, eventual intention of such syntax
    being supported on the frontend as well. Here''s an example of a CommonJS module
    (this may appear familiar if you''re accustomed to programming in Node.js):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This became the standard in various non-browser environments such as Node.js,
    SproutCore, and CouchDB. It was also possible to compile your CommonJS modules
    into browser-consumable scripts similar to AMD using the CommonJS Compiler. Sometime
    after this, around 2017, **ES Modules** emerged. This gave us language support
    for `import` and `export` statements, effectively solving the historical challenge
    of *how to define modules* in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In Node.js, such modules must have filename suffixes of `.mjs` instead of `.js`
    so the engine knows to expect `import` and `export` and not the conventional CommonJS
    module definition syntax. In the browser, such modules can be loaded by using `<script
    type="module">`. However, even with ES Modules supported in browsers, it''s still
    arguably preferable to build and bundle your JavaScript into conventional non-modular
    script tags. This is due to factors of performance and compatibility across browsers.
    Not to worry though: we can still use ES Modules when writing our code! Tools
    such as Babel can be used to compile and bundle the latest JavaScript syntax into
    JavaScript that is compatible across many environments. It''s typical to set up
    a tool such as Babel as part of your build and development process.'
  prefs: []
  type: TYPE_NORMAL
- en: npm and package.json
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the past, there was no package manager available for the JavaScript community.
    Instead, individuals and organizations would typically release code themselves,
    enabling developers to manually download the latest releases. With the introduction
    of Node.js and npm, this all changed. Finally, there was a central repository
    of packages available to pull into our projects with ease. This wasn't only useful
    for server-side Node.js projects but also entirely frontend projects as well.
    The emergence of npm is likely one of the most significant events that precipitated
    the maturation of the JavaScript ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nowadays, every project that heavily involves JavaScript will set out its manifest
    in a top-level `package.json` file, usually specifying, at the very least, a name,
    a description, a version, and a list of versioned dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a variety of available fields you can use in `package.json` so it''s
    worth exploring the npm documentation to understand all of them. Here''s a rundown
    of the most common ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: The name of the package is perhaps the most important thing. If you
    plan to publish the package to npm, then this name will need to be unique.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description`: This is a brief description of your module, to help developers
    understand its purpose. More detailed information is typically placed in a `README`
    or `README.md` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`version`: This is a **Semantic Versioning** (**SemVer**) compatible version
    (of the form, `[Major].[Minor].[Patch]`, for example, `5.11.23`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dependencies`: This is an object that maps every dependency package name to
    a version range. The version range is a string that has one or more space-separated
    descriptors. Dependencies can also be specified as a tarball/Git URL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`devDependencies`: This is identical in function to `dependencies` except for
    the fact that it is intended only for dependencies that are required during development,
    such as code quality analyzers and testing libraries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main`: This can refer to the module ID that is the primary entry point to
    your program. For example, if your package were named `super-utils`, and someone
    installed it and then did `require("super-utils")`, then your `main` module''s
    export object would be returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: npm assumes that your package and any packages you rely on follow the rules
    of SemVer, which uses a pattern of `[Major].[Minor].[Patch]` (for example, `1.0.2`).
    SemVer prescribes that any breaking changes must result in the *major* portion
    incrementing, whereas backward-compatible feature additions should result in only
    the *\minor* portion incrementing, and backward-compatible bug fixes should result
    in the *patch* portion incrementing. Full details can be found at [https://semver.org/](https://semver.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Running `npm install` in the directory where `package.json` resides will cause
    npm to download the versions of dependencies that you have specified. When declaring
    dependencies, by default, npm will do so with a caret (`^`) attached, meaning
    that npm will pick the latest available version that complies with the major version
    specified. So, if you specify `^1.2.3`, then anything up to `1.99.99` (and so
    on) may validly be installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several fuzzy *version ranges* that you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`version`: Must match `version` exactly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>version`: Must be greater than `version`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>=version`: Must be greater than or equal to `version`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<version`: Must be less than `version`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<=version`: Must be less than or equal to `version`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`~version`: Approximately equivalent to `version` (increment patch portion
    only)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`^version`: Compatible with `version` (increment minor/patch portions only)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1.2.x`: `1.2.0`, `1.2.1`, and so on, but not `1.3.0` (`x` means anything here)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arguably, the greatest issue with npm is that the unchecked introduction of
    new packages and their granularity in terms of functionality has led to projects
    with incredibly large and unwieldy dependency graphs. It's not unheard of for
    there to be individual packages that only export a singular narrow utility function.
    For example, in addition to a generic *string utility* package, you may also find
    a specific string function as a package of its own, such as *uppercase*. These
    packages are not inherently problematic—many of them serve useful purposes—but
    having an unwieldy dependency graph can lead to problems of its own. Any popular
    package that either is compromised or has not followed SemVer religiously can
    result in a propagation of issues across the JavaScript ecosystem, eventually
    affecting your project.
  prefs: []
  type: TYPE_NORMAL
- en: To help to prevent bugs and security issues, it is highly recommended to specify
    your dependencies with fixed versions and update dependencies manually only when
    you have checked their respective changelogs. Nowadays, some tools can help you
    to keep dependencies up to date without sacrificing security (for example, *dependabot*,
    owned by GitHub).
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s recommended to use a dependency management system that ensures the integrity
    of downloaded packages with cryptographic hashes (a checksum that would highlight
    malicious changes), to ensure that the package you end up executing is definitely
    the one you intended to install and has not been compromised or damaged during
    transmission. Yarn is an example of such a system (see [https://yarnpkg.com](https://yarnpkg.com)).
    It is effectively a more secure and efficient abstraction atop npm. In addition
    to being more secure, Yarn has the added benefit of avoiding inconsistent package
    resolution, which is when two installs of a given code base''s dependencies will
    result in a potentially different set of downloaded dependencies (due to the potentially
    fuzzy nature of npm''s version declarations). Such inconsistencies can result
    in the same code base behaving differently across two instances (a massive headache
    and harbinger of bugs!). Yarn stores the current *locked* dependency graph and
    corresponding versions and checksums in a `yarn.lock` file, which would look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, we see just one dependency but there'd usually be hundreds if not thousands
    as it would have to include not only your direct dependencies but also dependencies
    of those dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency management is a topic that has had much written about it, so if you
    look online, there is no shortage of opinions and solutions. Fundamentally, as
    our concern is clean code, we should go back to our principles. Foremost, what
    we should seek in both our dependency systems and the dependencies themselves
    is reliability, efficiency, maintainability, and usability. In the context of
    dependencies, when it comes to maintainability, we are interested in both our
    ability to maintain code that consumes and depends upon the dependency and the
    ability for the dependency's maintainers to keep the dependency up to date and
    bug-free.
  prefs: []
  type: TYPE_NORMAL
- en: Bundling and serving
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the land of JavaScript, around the same time as AMD and CommonJS started
    to emerge, the rise of command-line bundlers and build tools was also on the rise.
    This gave us the ability to bundle large dependency graphs into singular files
    that could be loaded with a single `<script>`. The proliferation of build tools
    such as GruntJS and gulp.js meant that, slowly, the JavaScript we wrote as programmers
    could be oriented to cleanliness and comprehension and not the loading idiosyncrasies
    of browsers. We could also begin to take advantage of spin-off languages and subsets
    such as CoffeeScript, TypeScript, and JSX. Such JavaScript adaptations could easily
    be compiled and then bundled into fully operable JavaScript sent down to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: The world that we have now is one in which build and bundling tools are incredibly
    common. There are several specific build tools, such as Grunt, gulp.js, webpack,
    and Browserify. Additionally, developers can easily use the npm `scripts` directive
    to create shortcuts to common command-line instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, building involves any preparations that need to occur on development
    code bases to make them production-ready. This can include anything from linting
    your CSS to bundling your JavaScript. Bundling, specifically, is concerned with the
    compilation and collation of large dependency graphs (of JavaScript files) into
    single JavaScript files. This is necessary so that we can serve our JavaScript
    code bases to the browser in the most performant and compatible way. Bundling
    utilities will usually output a file with a hash of the file''s content as part
    of the filename, for example, `main-f522dccf1ff37b.js`. This filename can then
    be dynamically or statically inserted into a `<script>` tag within your HTML to
    be served to the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Having a hash of the file's contents in the filename ensures that browsers always
    load the updated file and do not rely on a previously cached version of it. These
    files are usually *minified* as well. *Minification* involves parsing your JavaScript
    and producing a functionally identical but much smaller representation of it where
    all possible measures have been taken to take up less space, such as shortening
    variable names and removing whitespace and newlines. This is used in combination
    with HTTP compression techniques (such as `.gzip`) to ensure that the transmission
    over HTTP from a server to a client is as small and quick as possible. Usually,
    you will have distinct *development* and *production* builds since some build
    steps, such as minification, would make development (and debugging!) harder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Serving bundled JavaScript to the browser is usually done with a singular `<script>`
    tag referencing the bundled JavaScript filename, placed at somewhere within the
    HTML that you serve to the browser. There are several important performance considerations
    when selecting an approach. The most important metric is how quickly, from the
    time of the initial request, a user can start using the application. When loading
    up superWebApp.example.com, we can imagine the following possible latencies experienced
    by the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fetching resources**: Each resource fetch may involve a DNS lookup, an SSL
    handshake, and the completion of an HTTP request and response cycle. Responses
    are usually streamed, meaning that the browser may begin parsing a response before
    it is completed. Browsers typically make a moderate amount of requests concurrently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parsing HTML**: This involves the browser parsing every tag name and iteratively
    building up a DOM representation of the HTML. Some encountered tags will cause
    a new fetchable resource to be enqueued, such as `<img src>`, `<script src>`,
    or `<link type="stylesheet" href>`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parsing CSS**: This involves the browser parsing every ruleset within any
    fetched CSS. Referenced resources such as background images will only be fetched
    later if the corresponding element is found to exist on the page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parsing / compiling JavaScript**: Following the fetching of each JavaScript
    resource, its contents will be parsed and compiled, ready to execute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rendering HTML with CSS applied**: This will ideally occur only once, when
    all CSS has been loaded. If there are asynchronously loaded CSS or other aesthetic
    resources (such as typefaces or images), then there may be several repaints/re-renders
    before the page can be considered fully rendered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Executing JavaScript**: Depending on the location of the corresponding `<script>`,
    a piece of JavaScript will execute and may then mutate the DOM or perform its
    own fetches. This can potentially block any other fetching/parsing/rendering from
    occurring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's usually preferable to have the execution of your JavaScript occur last,
    when the browser has done everything else. However, this is not always ideal.
    Some JavaScript may be necessary to load vital resources, and so it should be
    executed as early as possible so those HTTP fetches can occur concurrently with
    the rest of the browser's preparatory work.
  prefs: []
  type: TYPE_NORMAL
- en: Placement of your primary bundled `<script>` (your `main` code base) is vital
    in determining when your JavaScript will be fetched, when it will execute, and
    what the state of the DOM will be when it executes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a rundown of the most popular `<script>` placements and their respective
    advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`<script src>` within `<head>`**: This script will be fetched as soon as `<script>`
    is encountered during parsing. Fetching and execution will occur in serial order
    and will block other parsing from occurring. This is considered a bad practice
    as it needlessly blocks the continued parsing of the rest of the document (and
    hence increases the latency of the page load, from the user''s perspective).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`<script src>` at the end of `<body>`**: This script will be fetched as soon
    as `<script>` is encountered during parsing. Fetching and execution will occur
    in serial and will block other parsing from occurring. Usually, parsing can be
    considered mostly complete as `<script>` is the very last thing in `<body>`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`<script src defer>` within `<head>`**: This script will be enqueued for
    fetching as soon as `<script>` is encountered during parsing, and this fetch will
    occur concurrently with the parsing of the HTML at a time that is convenient for
    the browser. The script will only execute once the entire document is parsed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`<script src async>` within `<head>`**: This script will be enqueued for
    fetching as soon as `<script>` is encountered during parsing, and this fetch will
    occur concurrently with the parsing of the HTML at a time that is convenient for
    the browser. The execution of the script will occur immediately following its
    fetch and will block continued parsing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having `<script defer>` in `<head>` is usually preferable as it can be fetched
    as soon as possible, it won't block parsing, and it'll only be executed once parsing
    has completed. This tends to give the user the fastest experience if you're serving
    up one singular bundled script and gives your JavaScript a completely parsed DOM
    that it can manipulate and render within immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Serving JavaScript to the browser is a simple thing, in truth. It is only complicated
    by the need for us to have our web applications perform quickly for the benefit
    of users. Increasingly complex JavaScript code bases produce increasingly large
    bundles, and so loading these bundles takes time. Hence, the loading performance
    of your JavaScript is something you'll likely need to take seriously and spend
    time investigating. Performance is something easily forgotten but incredibly important.
  prefs: []
  type: TYPE_NORMAL
- en: Another similarly easily forgotten topic in the JavaScript ecosystem is security,
    and that's what we'll now be exploring.
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security is a vital part of a reliable code base. From the user, there is an
    implicit assumption that any given piece of software will act according to its
    functional expectations and will not lead to the compromise of their data or devices.
    *Clean code* considers security as it does other functional expectations—as a
    vital requirement that should be carefully fulfilled and thoroughly tested.
  prefs: []
  type: TYPE_NORMAL
- en: Since JavaScript is predominantly used in a networked situation—either on the
    server side or client side, it is forever fraught with the possibility of security
    vulnerabilities. And the fact that browsers are, effectively, sandboxed vehicles
    of *remote code execution* means that our end users are susceptible to just as
    much risk as we are. To protect ourselves and our users, we need to have a diverse
    understanding of the types of vulnerabilities that exist and how to counteract
    them. There are reams and reams of intimidating information about security vulnerabilities
    in the wild. We cannot hope to cover all of them in this book, but hopefully,
    if we explore a couple of the common vulnerabilities, then we'll be more generally
    cautious and aware and can begin to understand the types of measures we should
    put in place.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Site Scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Cross-Site Scripting** (**XSS**) is a vulnerability that enables attackers
    to inject their own executable code (usually JavaScript) into the frontend of
    a web application so that browsers will execute as if it were trusted. There are
    many ways XSS can manifest but these can all be boiled down to two core types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stored XSS**: This involves an attacker somehow saving executable code within
    seemingly innocuous data to a web application that is persisted and then rendered
    back to other users of the web application. A primitive example of this is a social
    media website that allows me to specify my name as HTML (for example, `<em>James!</em>`)
    but without preventing the inclusion of potentially dangerous executable HTML,
    allowing me to specify a name such as `<script>alert(''XSS!'')...`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reflected XSS**: This involves an attacker sending a victim to a URL whilst
    sending their executable payload along with the request, either in the URL, an
    HTTP header, or the request body. This executable payload is then executed when
    the user lands on the page. An example of this would be a search page that reflects a
    query back to the user (a common feature of any search page) but does so in a
    way that fails to escape HTML, meaning that the attacker need only send their
    victim to `/search?q=<script>alert(''XSS!'')...`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The way that either stored or reflected payloads are rendered within a page
    is crucial here. Traditionally, XSS vectors were limited to the server-side rendering
    of unescaped user-entered HTML. So, if Bob sets his social media account name
    to `<script>alert("Bob's XSS")...`, then when Bob's page is requested from the
    server, the markup returned will include that `<script>` ready to be parsed and
    executed by the browser. Nowadays, however, SPAs and websites that involve client-side
    rendering are far more common, meaning that instead of the server being at fault
    for allowing unescaped HTML into the document's markup, it is the client (the
    JavaScript code base) that is at fault for rendering dangerous content directly
    into the DOM. XSS attacks that rely on client-side rendering are hence often called
    **DOM-based XSS**.
  prefs: []
  type: TYPE_NORMAL
- en: XSS payloads can come in a variety of forms. It's very rarely as simple as a
    `<script>` tag. Attackers use a variety of complex encodings, archaic HTML, and
    even CSS to embed their nefarious JavaScript. Cleansing XSS from strings is therefore
    not trivial and it is instead recommended to place **no trust whatsoever** in
    user-entered content.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can imagine a scenario in which our JavaScript code base has a `UserProfile`
    component that renders the name and profile information of any user. Upon initialization,
    this component requests its data from a REST endpoint that looks like `/profile/{id}.json`,
    returning the following JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This component then renders the received name to the DOM via `innerHTML`, without
    escaping or cleansing its contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: All users who render the `UserProfile` component are liable to execute arbitrary
    (potentially damaging) HTML. This would be an issue whether the arbitrary HTML
    comes from a reflected or a stored source.
  prefs: []
  type: TYPE_NORMAL
- en: 'The prevalence of common JavaScript frameworks that abstract DOM rendering
    means that an attacker need only find a vulnerability within a library or framework
    to attack thousands of different websites. Most frameworks, thankfully, by default,
    have interpolation mechanisms that force inserted data to be rendered as text,
    not HTML. React, for example, will always produce text nodes for any data inserted
    via JSX''s interpolation delimiters (curly braces). We can see this in effect
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the data containing `<script>` to be literally rendered as
    text, so that the resulting `innerHTML` of the `<body>` element is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the potentially dangerous HTML was rendered as text, no execution can
    occur and the XSS attack is prevented. This isn''t the only way that an XSS attack
    can occur though. It''s common for client-side frameworks to have templating solutions
    that rely on inline `<script>` tags, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a convenient way of declaring templates to be used in the later rendering
    of specific components, but such templates are often used in combination with
    server-side rendering and interpolation, and such a combination is liable to XSS
    if an attacker can force a dangerous string to be interpolated by the server into
    the template, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: If `user.data.name` contains nefarious HTML, then there is nothing that our
    JavaScript can do on the client side to prevent the attack. By the time we render
    our code, it may even be too late.
  prefs: []
  type: TYPE_NORMAL
- en: 'In modern web applications, we have to be wary of XSS, either stored or reflected,
    rendered on both the server and the client. It''s a mind-bending combination of
    possible vectors, so it''s crucial to ensure that you''re employing a combination
    of countermeasures:'
  prefs: []
  type: TYPE_NORMAL
- en: Never trust user-entered data. Ideally, do not allow users to enter any HTML.
    If they can, then use an HTML parsing library and whitelist specific tags and
    attributes that you trust.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Never place untrusted data in an HTML comment, a `<script>` element, a `<style>`
    element, or where an HTML tag or attribute name should appear (for example, `<HERE
    ...>` or `<div HERE=...>`). If you must, place it within an HTML element and ensure
    it is fully escaped (for example, `&` → `&amp;` and `"` → `&quot;`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If inserting untrusted data into regular (non-JavaScript) HTML attributes,
    escape all ASCII values less than `256` with the `&#xHH;` format. If inserting
    into a regular HTML element''s contents, then escaping the following characters
    is sufficient: `&`, `<`, `>`, `"`, `''`, and `/`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid inserting untrusted data into areas where JavaScript is executed, such
    as `<script>x = 'HERE'</script>` or `<img onmouseover="x='HERE'">`, but if you
    absolutely must, ensure that the data is escaped so that it cannot break out of
    its quotes or its containing HTML.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of embedding JavaScript-readable data in a `<script>`, use JSON to transmit
    data to the client, either via a request or by embedding it in a no-op element
    such as `<div>` (ensuring it's fully HTML-escaped!) and then extracting and deserializing
    it yourself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use an appropriately restrictive **Content Security Policy** (**CSP**) (we will
    explain this in the next section).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These countermeasures are not exhaustive, so it's advisable to also have a thorough
    readthrough of the **Open Web Application Security Project's** (**OWASP**) Cross-Site
    Scripting Prevention Cheatsheet: [https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).
  prefs: []
  type: TYPE_NORMAL
- en: Content Security Policy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As an added security measure, it's important to also configure an appropriate
    CSP.
  prefs: []
  type: TYPE_NORMAL
- en: CSP is a relatively new HTTP header that is available on all modern browsers.
    It is *not* universally supported or respected, so it should not be depended upon
    as our sole defense against XSS. Nonetheless, if correctly configured, it can
    prevent the majority of XSS vulnerabilities. Browsers that don't support CSP will
    fall back to their default behavior of the same-origin policy, which itself provides
    a level of crucial security.
  prefs: []
  type: TYPE_NORMAL
- en: The same-origin policy is a vital security mechanism employed by all browsers
    that restricts the ability of documents or scripts when accessing some resources
    from other origins (origins match when they share the same protocol, port, and
    host). This policy means that, for example, JavaScript within `leah.example.org`
    cannot fetch `alice.example.org/data.json`. With the advent of CSP, it is, however,
    possible for `alice.example.org` to express a level of trust and provide such
    access by disabling the same-origin policy just for `leah.example.org`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Content-Security-Policy` header allows you to specify where different types
    of resources are allowed to be loaded from. It is essentially an origin whitelist
    that the browser will validate all outgoing requests against.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be specified as a regular HTTP header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Or it can be specified as a `meta` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The format of the value is one or more policy directives, separated by semicolons,
    where each policy directive starts with the `fetch` directive. These designate
    the type of resource (for example, `img-src`, `media-src`, and `font-src`), or
    the default (`default-src`) that all directives will fall back on if they're not
    separately specified. The fetch directive is followed by one or more space-separated
    sources, where each source specifies where resources can be loaded from for that
    resource type. Possible sources include URLs, protocols, `'self'` (to refer to
    the document's own origin), and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of CSP values with explanations for each one:'
  prefs: []
  type: TYPE_NORMAL
- en: '`default-src ''self''`: This is the maximally restrictive directive that declares
    that only resources from the same origin as the document itself can be loaded
    within the document (whether from `<img>`, `<script>`, XHR, or anything else).
    No other origins are allowed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default-src ''self''; img-src cdn.example.com`: This directive declares that
    only resources from the same origin as the document itself can be loaded, except
    in the case of images (for example, `<img src>` and CSS-declared images), which
    can be loaded from the origin, `cdn.example.com`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default-src ''self'' *.trusted.example.com`: This declares that only resources
    from the same origin *or* resources from `*.trusted.example.com` are valid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default-src https://bank.example.com`: This declares that only resources from
    the SSL-secured origin, `https://bank.example.com`, can be loaded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default-src *; script-src https:`: This declares that resources can be loaded
    from any valid URL except in the case of `<script src>`, which must load its resources
    from an HTTPS URL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What an appropriately restrictive CSP is will depend entirely upon your specific
    web application, what kind of user-generated content you may be dealing with,
    and the sensitivity of the data you deal with. Having an appropriate CSP not only
    protects you from creating potential vectors of XSS (by loading from potentially
    compromised origins) but can help to counteract executing XSS vulnerabilities
    as well. CSP defends against XSS in the following specific ways:'
  prefs: []
  type: TYPE_NORMAL
- en: CSP disables `eval()` and other similar techniques from working. These are common
    vectors for XSS, especially in legacy browsers where such methods have been used
    to parse JSON. You can explicitly enable `eval` via the `'unsafe-eval'` source
    if you so desire.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSP disables inline `<script>` and `<style>` tags, the JavaScript protocol,
    and inline event handles (for example, `<img onload="..." />`). These are all
    common XSS vectors. You can explicitly enable these by specifying `unsafe-inline`
    as a source for the relevant fetch directives, but it's recommended to instead
    load your scripts and styles from external sources so the origins can be validated
    against your CSP whitelist by the browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a last-ditch effort, CSP, if well configured, can prevent currently executing
    XSS from loading its own malicious resources or calling home with compromised
    data, limiting its ability to do damage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subresource Integrity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Subresource Integrity** (**SRI**) is a security feature within browsers that
    allows us to verify that the resources they fetch are delivered without any unexpected
    manipulation or compromise. Such manipulation could potentially occur where the
    asset is served from (for example, your CDN is hacked) or during network transmission
    (for example, a middleman attack).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify your script, you must provide an integrity attribute that contains
    the name of a hashing algorithm (such as `sha256`, `sha384`, or `sha512`) and
    then the hash itself. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'To generate that hash, you can use OpenSSL''s CLI as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to using the integrity attribute on `<script>`, you can use it
    on `<link>` for the verification of CSS style sheets. To enforce SRI, you can
    use the helpful CSP header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Doing this will ensure that any scripts or style sheets that exist without an
    integrity hash will fail to load. Once fetched, if the provided integrity hash
    does not match the hash of the received file, then it will be ignored (as if it
    wasn't fetched). Using SRI together with CSP gives you a considerable defense
    against XSS.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Site Request Forgery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Cross-Site Request Forgery** (**CSRF**) is when commands, usually in the
    form of HTTP GET or POST requests, are transmitted from a user without their intent,
    by malicious code. A primitive example would be if a banking website at `bank.example.com`
    had an API endpoint that allowed logged-in users to transfer a given amount to
    a specified account number. The endpoint might be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Even if users were authenticated via a session cookie on the `bank.example.com`
    domain, a malicious website could easily embed and submit `<form>` directing the
    transfer to their own account, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Regardless of what HTTP method is used by the endpoint or what kind of request
    body or parameters it accepts, it is liable to a CSRF attack unless it ensures
    that the request comes from its own website. This problem is partially solved
    by the same-origin policy inherent to browsers, which prevents some types of requests
    from taking place (such as a JSON POST request via XHR or PUT/DELETE requests),
    but there is nothing inherent in the browser to prevent a user innocently clicking
    a link to a website or submitting a form that forges a malicious POST request.
    These actions are, after all, the entire purpose of the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since there is no inherent mechanism of the web that prevents CSRF, developers
    have come up with their own defenses. One common mechanism to prevent CSRF is
    with a CSRF token (which should really be called an **Anti-CSRF Token**). This
    is a generated key (random, long, and impossible to guess) that is sent down to
    the client with each regular request while also being stored on the server as
    part of the user''s session data. The server will then require the browser to
    send that key along with any subsequent HTTP requests to verify the source of
    each request. So, instead of just two parameters, our `/transfer` endpoint will
    now have a third, the token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The server can then verify that the provided token exists on that user''s session
    data. There are many libraries and frameworks that simplify this. There are also
    a variety of adaptations and configurations of this basic token mechanism. Some
    of them will only generate a token for a given amount of time, or a given request
    cycle, whereas others will provide a singular token for that user''s entire session.
    There are also a variety of ways for the token to be sent downstream to the client.
    The most common is within the response payload as part of the document markup,
    usually in the form of a `<meta>` element in `<head>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This can then be grabbed by JavaScript and sent with any subsequent GET or
    POST requests made dynamically by the JavaScript. Or in the case of a conventional
    website without client-side rendering, the CSRF token can be sent downstream directly
    embedded in the `<form>` markup as a hidden `<input>`, which naturally forms part
    of the form''s eventual submission to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If your web application is susceptible to XSS, then it is also inherently susceptible
    to CSRF, as the attacker will usually have access to the CSRF token and hence
    be able to masquerade any requests they make as legitimate, and the server won''t
    be able to tell the difference. So, strong anti-CSRF measures are not sufficient
    on their own: you must have countermeasures for other potential vulnerabilities
    as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Whatever anti-CSRF measure you use, the crucial need is for every request that
    mutates a user's data or carries out a command to be verified as coming from a
    legitimate page within the web application itself and not some maliciously crafted
    external source. To get a more thorough understanding of CSRF and the available
    countermeasures, I recommend reading and fully digesting **OWASP's CSRF Prevention
    Cheatsheet**:[https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html).
  prefs: []
  type: TYPE_NORMAL
- en: Other security vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: XSS and CSRF only touch the surface of the types of attacks that we should be
    prepared for. Defending against all possible vulnerabilities is incredibly challenging
    and usually unrealistic, but we'd be foolish to not write code that is resilient
    against the most prevalent ones. A good general understanding of the types of
    vulnerabilities that exist can help us to be generally cautious in the code we
    write.
  prefs: []
  type: TYPE_NORMAL
- en: XSS, as explored, is a very diverse vulnerability with many possible vectors
    of attack. But we can defend against it in a general way by consistently and correctly
    discerning between trusted and untrusted data. We can limit the possibility of
    untrusted data wreaking havoc by placing it in only very specific places, correctly
    escaping it, and ensuring that we have an appropriately restrictive CSP. Likewise,
    with CSRF, there are countless ways for an attacker to perform it, but having
    a solid Anti-CSRF Token mechanism will save you from most of them. All we can
    hope for in the realm of security, given our limited resources, is that we can
    have coverage against the majority of popular attacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a rundown of some other popular vulnerabilities that are worth being
    aware of:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SQL or NoSQL injections**: Any user-submitted data that is expressed via
    a SQL or NoSQL query can, if not correctly escaped, provide an attacker with access
    to your data and the ability to read from, mutate, or destroy it. It''s similar
    to XSS in that both are forms of *injection attacks*, and so our defense against
    it, again, comes down to identifying untrusted data and then correctly escaping
    it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authentication/password attacks**: An attacker can gain unauthorized access
    to a user''s account by guessing their password, brute-forcing combinations, or
    using a rainbow table (a database of common password hashes). Generally, it is
    advisable to not create your own authentication mechanisms, but instead to rely
    on trusted libraries and frameworks. You should always ensure that you''re using
    a secure hashing algorithm (such as *bcrypt*). A good resource is OWASP''s **Password
    Storage Cheat Sheet** ([https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency hijacking**: An attacker can gain access over your server-side
    or frontend code base by hijacking one of your dependencies. They may gain access
    to an npm package that exists in your dependency graph (search online for the
    *left-pad incident*) or compromise a CMS or CDN that you use to store JavaScript
    assets. To counteract these types of vulnerabilities, ensure that you use a secure
    package management system such as Yarn, try to use fixed version patterns in your
    `package.json`, always check changelogs, and on the frontend, have an appropriately
    restrictive CSP to prevent any malicious code from calling home.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is always the possibility of an attack, and so we need to build that risk
    into our system designs. We cannot expect to be immune to these vulnerabilities,
    but when they do occur, we can ensure that we can fix them quickly, communicate
    transparently with affected users, and ensure that we carefully consider how we
    can prevent such vulnerabilities from occurring again.
  prefs: []
  type: TYPE_NORMAL
- en: Whether we're creating a framework for developers or a UI for non-technical
    users, the consumers of our code will always expect it to behave securely. This
    expectation is increasingly being encoded into law (for example, in EU law, the **General
    Data Protection Regulation** (**GDPR**)), so it's crucial to take it seriously
    and spend a good amount of time on learning and prevention. The practice of security
    is yet another example of how clean code is not only about our syntax and design
    patterns but about the very significant ways that our code affects our users and
    their everyday lives.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have explored a variety of real-world challenges—topics
    that any JavaScript programmer may find themselves exposed to both within the
    browser and on the server. Writing clean code in JavaScript is not only about
    the language itself but about the web ecosystem that it exists within and the
    demands that this brings. Through our explorations of the DOM, routing, dependency
    management, and security, we have hopefully gained an insight into the technicalities
    of the problem domains that JavaScript often deals with, and an appreciation for
    the many frameworks, libraries, and standards-driven APIs that exist to help us
    to deal with these problems.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll delve into the art of writing clean tests, a vitally
    important task, not only because it gives us confidence in our own code, but because
    it ensures the kind of reliability that users rightfully expect from our software.
  prefs: []
  type: TYPE_NORMAL
