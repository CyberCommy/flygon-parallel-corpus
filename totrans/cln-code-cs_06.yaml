- en: Unit Testing
  prefs: []
  type: TYPE_NORMAL
- en: Previously, we looked at exception handling, how to implement it properly, and
    how this can be useful to the customer and the programmer when issues occur. In
    this chapter, we will look at how programmers can implement their own **quality
    assurance** (**QA**) to provide quality code that is robust and less likely to
    generate exceptions in production.
  prefs: []
  type: TYPE_NORMAL
- en: We start by looking at why we should test our own code, and what makes a good
    test. We then look at several testing tools that are available to C# programmers.
    Then, we move on to the three pillars of unit testing that are *Fail, Pass, and
    Refactor*. Finally, we look at redundant unit tests and why they should be removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the reasons for a good test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the testing tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TDD methodology practice – fail, pass, and refactor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing redundant tests, comments, and dead code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will have gained the following skills:'
  prefs: []
  type: TYPE_NORMAL
- en: Be able to describe the benefits of good code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be able to describe potential negatives that can arise from not unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be able to install and use MSTest to write and run unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be able to install and use NUnit to write and run unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be able to install and use Moq to write fake (mock) objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be able to install and use SpecFlow to write software that adheres to customer
    specifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be able to write tests that fail, then make them pass, and then perform any
    necessary refactoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To access the code files of this chapter, you can visit this link: [https://github.com/PacktPublishing/Clean-Code-in-C-/tree/master/CH06](https://github.com/PacktPublishing/Clean-Code-in-C-/tree/master/CH06).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the reasons for a good test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a programmer, it is nice to work on a new development project that you find
    interesting, especially if you are highly motivated to do so. But it can be extremely
    frustrating if you get called away to work on a bug instead. It can be worse if
    it is not your code, and you don't have the full understanding behind the code.
    It is even worse still if it is your own code and you have that *"What was I thinking?"*
    moment! The more you get called away from new development to perform maintenance
    on existing code, the more you begin to appreciate the need for unit testing.
    As this appreciation grows, you begin to see the real benefits of learning testing
    methodologies and techniques such as **Test-Driven Development (TDD)** and **Behavioral-Driven
    Development (BDD)**.
  prefs: []
  type: TYPE_NORMAL
- en: When you've spent a period of time working as a maintenance programmer on other
    people's code, you get to see the good, the bad, and the ugly. Such code can be
    a positive education that opens your eyes to a better way of programming by understanding
    what not to do and why not to do it. The bad code can make you shout *No. Just
    no!* and the ugly code can cause your eyes to bleed and your mind to go numb.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing directly with customers, providing them with technical support, you
    see just how crucial a good customer experience is to the success of the business.
    Conversely, you also get to see how a bad customer experience can lead to some
    very frustrated, angry, and extremely foul-mouthed customers; and how quickly
    sales can be lost due to customer refunds and loss of customers because of very
    harmful customer rants on social media and review sites.
  prefs: []
  type: TYPE_NORMAL
- en: As a tech lead, it is your responsibility to perform technical code reviews
    to ensure that staff adhere to the company's coding guidelines and policies, triage
    bugs, and assist the project manager in managing the people you are responsible
    for leading. It is important as a tech lead to be good at high-level project management,
    requirements gathering and analysis, architectural design, and clean programming.
    You also need to have good people skills.
  prefs: []
  type: TYPE_NORMAL
- en: Your project manager is only interested in delivering a project on time and
    to budget according to the needs of the business. They really don't care about
    how you code the software, only that you get it done on time and to the agreed
    budget. Most importantly, they care that the released software exactly matches
    what the business asks for – no more and no less – and that the software is to
    a very high and professional standard, as the quality of the code can equally
    boost or destroy a company brand. When a project manager is harsh with you, you
    know the business is putting them under increased pressure. And so that pressure
    trickles down to you.
  prefs: []
  type: TYPE_NORMAL
- en: As a tech lead, you are sandwiched between the project manager and the team
    working on the project. In your everyday work, you will be running scrum meetings
    and dealing with problems. Those problems may be the coders needing resources
    from the analysts, testers waiting for bugs to be fixed by the developers, and
    so on. But the most difficult job will be to perform peer code reviews and provide
    constructive feedback that gets the desired results without offending people.
    That is why you should take clean coding very seriously, because if you criticize
    a person's code, you open yourself up for a backlash if your own code is not up
    to scratch. But also, you will be the one to get it in the neck from the project
    manager if the software fails testing or goes out with loads of bugs.
  prefs: []
  type: TYPE_NORMAL
- en: That is why, as a tech lead, it is a good idea for you to encourage TDD. The
    best way to do that is by *leading by example*. Now I know that even degree-educated
    and experienced programmers can be very stand-offish to TDD. One of the most common
    reasons is that it can be hard to learn and put into practice, and appear to be
    more time consuming, especially when code becomes more complex. I have experienced
    these kinds of objections from my colleagues who prefer not to unit test.
  prefs: []
  type: TYPE_NORMAL
- en: But as a programmer, if you want to be truly confident (such that once you've
    written a piece of code, you can be confident in its quality and that it will
    not be returned to you to fix your own bugs), then TDD is a fantastic way to up
    your game as a programmer. When you learn to test first before you start programming,
    it soon becomes *habitual*. Such a habit, as a programmer, is very useful and
    beneficial to you, especially when there comes a time to find a new position,
    as many employment opportunities advertise for people with TDD or BDD experience.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to consider while writing code is that bugs in a simple, non-critical
    note-taking app are not the end of the world. But what if you work in the defense
    or health sectors? Consider a weapon of mass destruction that has been programmed
    to go in a specific direction to hit a specific target in enemy territory, but
    something goes wrong, and the missile aims for civilian populations that belong
    to your allies. Or, consider what would happen if you had a loved one that was
    on critical life support that died because of a bug in the software of the medical
    equipment that was your own fault. Then, what about some safety software going
    wrong on a passenger jet flying over a populated area that causes the plane to
    crash into the ground, killing people on the plane and on the ground?
  prefs: []
  type: TYPE_NORMAL
- en: The more critical the software, the more the use of unit testing techniques
    (such as TDD and BDD) needs to be taken seriously. We will be discussing BDD and
    TDD tools later in this chapter. When writing software, think about how you would
    be affected if you were the customer and something went wrong with the code you
    are writing. How would it affect your family, friends, and colleagues? Also, think
    of the moral and legal implications if you were responsible for a critical failure.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand why, as a programmer, you should learn to test
    your own code. It is true what they say that *"programmers should never test their
    own code"*. But it is only true in the context where the code is finished and
    ready for testing before it goes into production. So while the code is still being
    programmed, programmers should always be testing their own code. Yet some businesses
    are so time-constrained that proper QA is often sacrificed so that the business
    can be the first to market.
  prefs: []
  type: TYPE_NORMAL
- en: It may be very important for a business to be the first to market, but first
    impressions count. If a business is first to market, and the product has some
    serious flaws that become globally broadcast, this can have a long-lasting negative
    impact on a business. So you must think very carefully as a programmer and do
    your best to ensure that if the software has flaws, you are not the one responsible.
    When things go wrong in a business, heads will roll. And in Teflon Management,
    the managers will pass the guilt for driving ridiculous deadlines from themselves
    all the way down to the programmers that had to meet the deadline and make sacrifices
    to do so.
  prefs: []
  type: TYPE_NORMAL
- en: So you see, it is very important as a programmer that you test your code and
    test it often, especially prior to releasing it to the testing team. That is why
    you are actively encouraged to transition into the mindset and habitual behavior
    of writing your tests first, based upon the specification that you currently implementing.
    Your tests should fail to start with. You then write only enough code to get the
    tests to pass, and then you refactor your code as you need to.
  prefs: []
  type: TYPE_NORMAL
- en: It is hard to get started with TDD or BDD. But once you get the hang of it,
    TDD and BDD become second nature. And you will probably find that in the long
    term, you are left with cleaner code that is easy to read and maintain. You may
    also find that your confidence in your ability to modify the code without breaking
    it may also be greatly improved. Obviously, there is more code in the sense that
    you have the production method and the test method(s). But you may actually end
    up writing less code overall, as you will not be adding extra code that you think
    may be needed!
  prefs: []
  type: TYPE_NORMAL
- en: Picture yourself at your computer with a software specification that you have
    to translate into working software. A bad habit that many programmers have, and
    that I've been guilty of in the past, is that they jump straight into coding without
    doing any real design work. In my experience, this actually prolongs the time
    it takes to develop a piece of code and can often lead to more bugs and code that
    is hard to maintain and extend. In fact, although it appears to be counter-intuitive
    to some programmers, proper planning and design actually speed up coding, especially
    when you factor in maintenance and extensions.
  prefs: []
  type: TYPE_NORMAL
- en: This is where the test team comes in. Before we go any further, let's describe
    use cases, test designs, test cases, and test suites, and how they relate to one
    another.
  prefs: []
  type: TYPE_NORMAL
- en: A use case explains the process flow for a single operation, such as adding
    a customer record. A test design will comprise one or more test cases that test
    for different scenarios that could take place for the single use case. The test
    cases may be carried out manually, or they may be automated tests that are executed
    by a test suite. A test suite is a piece of software used to discover and run
    tests and to report their outcomes to an end user. The writing of use cases will
    be the role of the business analyst. As for the test design, test cases, and test
    suite, these will be the responsibility of the dedicated test team. Developers
    need not be concerned with putting together the use cases, test designs of test
    cases, and their execution in the test suite. Developers must focus on writing
    and using their unit tests to write code that fails, then runs, and is then refactored
    as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Software testers collaborate with programmers. This collaboration normally starts
    at project inception, and continues right through to the end. Both the development
    team and testing team will collaborate by sharing test cases for each product
    backlog item. This process normally consists of writing test cases. For the tests
    to pass, they will have to meet test criteria. These test cases will normally
    be run using a combination of manual testing and some test suite automation.
  prefs: []
  type: TYPE_NORMAL
- en: During the development phases, the testers write their QA tests and the developers
    write their unit tests. When developers submit their code to the test team, the
    test team will run through their battery of tests. The outcome of those tests
    will be fed back to the developers and the project stakeholders. If problems are
    encountered, this is known as technical debt. The development team will have to
    factor in time to address the issues raised by the test team. When the test team
    confirms that the software has been completed to the required level of quality,
    then the code is passed on to infrastructure to release into production.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming we are starting a brand new project (also known as a greenfield project),
    we would select the appropriate project type and tick the option to include a
    test project. This would create a solution that consists of our main project and
    the test project.
  prefs: []
  type: TYPE_NORMAL
- en: The type of project that we create and any features of projects to be implemented
    will be dependent upon use cases. Use cases are used during system analysis to
    identify, confirm, and organize software requirements. From use cases, test cases
    can be assigned to the acceptance criteria. As a programmer, you can take these
    use cases and their test cases to build up your own unit tests for each test case.
    Your tests are then run as part of a test suite. In Visual Studio 2019, you can
    access the Test Explorer from the View | Test Explorer menu. When you build your
    project, tests will be discovered. When tests are discovered, they are viewed
    in the Test Explorer. You can then run and/or debug your tests in the Test Explorer.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting at this stage that it will be the responsibility of the testers
    and not the developers to design tests and come up with a suitable number of test
    cases. They are also responsible for QA once the software leaves the hands of
    the developers. But it is still the responsibility of the developer to unit test
    their code, and this is where test cases can be a real help and motivation for
    writing unit tests in your code.
  prefs: []
  type: TYPE_NORMAL
- en: When the solution is created, the first thing you do is open the provided test
    class. In that test class, you write the pseudocode for what you must accomplish.
    You then go step by step through the pseudocode and add your test methods that
    test each step that must be accomplished in order to reach your goal of a completed
    software project. Each test method that you write is written to fail. You then
    write just enough code to pass the test. Then, once the test passes, you refactor
    your code before progressing to the next test. So, you can see that unit testing
    is not rocket science. But what does it take to write a good unit test?
  prefs: []
  type: TYPE_NORMAL
- en: Any code that is under test will be expected to provide a specific function.
    A function takes in input and produces output.
  prefs: []
  type: TYPE_NORMAL
- en: In a normally functioning computer program, a method (or function) will have
    an *acceptable* range of inputs and outputs, and an *unacceptable* range of inputs
    and outputs. And so the perfect unit test will test the lowest acceptable value,
    the highest acceptable value, and will provide test cases that are outside of
    the acceptable range of values both high and low.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests must be atomic, which means that they should only test one thing.
    Since methods can be chained together in the same class and even across multiple
    classes in multiple assemblies, it is often useful to provide fake or mock objects
    for the classes under test to keep them atomic. The output must determine whether
    it passes or fails. Good unit tests must never be inconclusive.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of a test should be repeatable, in that it either always passes
    or always fails in given conditions. That is, the same test run over and over
    again should not have different outcomes each time it is run. If it does, then
    it is not repeatable. Unit tests should not have to rely on other tests being
    run before them, and they should be isolated from other methods and classes. You
    should also aim for unit tests that run in milliseconds. Any test that takes one
    second or more to run is taking too long. If code takes longer than a second,
    then you should consider refactoring or implementing a mock object for testing.
    And since we are busy programmers, unit tests should be easy to set up and not
    require a lot of coding or configuration. The following diagram shows the unit
    testing life cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3012452a-e653-4059-99a1-54f3a4c3ade9.png)'
  prefs: []
  type: TYPE_IMG
- en: We'll be writing unit tests and mock objects during this chapter. But before
    we do, we'll need to look at some of the tools that are available to us as C#
    programmers.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the testing tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The testing tools we'll be looking at within Visual Studio are **MSTest**, **NUnit**,
    **Moq**, and **SpecFlow**. Each testing tool creates a console application and
    the relevant test project. NUnit and MSTest are unit testing frameworks. NUnit
    is much older than MSTest, and so has a more mature and full-featured API compared
    to MSTest. I personally prefer NUnit over MSTest.
  prefs: []
  type: TYPE_NORMAL
- en: Moq is different from MSTest and NUnit as it is not a testing framework but
    a mocking framework. A mocking framework replaces the real classes in your project
    with mock (fake) implementations that are used for testing purposes. You can use
    Moq together with MSTest or NUnit. And finally, SpecFlow is a BDD framework. You
    start by writing a feature in a feature file using business language that the
    user and the techy alike will understand. Then a step file is generated for that
    feature. The step file contains the methods as steps necessary to implement that
    feature.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand what each tool does and will
    be able to use them in your own projects. So, let's get started by looking at
    MSTest.
  prefs: []
  type: TYPE_NORMAL
- en: MSTest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will install and configure the MSTest Framework. We will
    write a test class with test methods and initialize it. We will perform assembly
    setup and cleanup, class cleanup, and method cleanup, and perform assertions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the MSTest Framework from the command line in Visual Studio, you
    will need to open the Package Manager Console via Tools | NuGet Package Manager
    | Package Manager Console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5b236774-e309-4dfa-b302-588fcceab5f9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, run the following three commands to install the MSTest Framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can add a new project and select Unit Test Project (.NET
    Framework) from the Context | Add menu in the Solution Explorer. See the screenshot
    that follows. When naming test projects, the accepted standard is in the form
    of `<ProjectName>.Tests`. This helps to associate them with the tests and distinguish
    them from the project that is under test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b5325f3-0e39-414a-abbb-65c908b7a64f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following code is the default unit test code that is generated when you
    add an MSTest project to your solution. As you can see, the class imports the `Microsoft.VisualStudio.TestTools.UnitTesting` namespace.
    The `[TestClass]` attribute identifies to the MS Test Framework that this class
    is a test class. The `[TestMethod]` attribute marks the method as a test method.
    All classes that have the `[TestMethod]` attribute will appear in the test player.
    The `[TestClass]` and `[TestMethod]` attributes are mandatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There are other methods and attributes that can optionally be combined to produce
    a complete test execution workflow. These include `[AssemblyInitialize]`, `[AssemblyCleanup]`,
    `[ClassInitialize]`, `[ClassCleanup]`, `[TestInitialize]`, and `[TestCleanup]`.
    As their names imply, the initialization attributes are used to perform any initialization
    at the assembly, class, and method level prior to tests being run. Likewise, the
    cleanup attributes run at the method, class, and assembly level after tests have
    been run to perform any necessary cleanup operations. We will look at each in
    turn and add them to your project as we will see its order of execution when we
    run the final code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `WriteSeparatorLine()` method is a helper method for the purpose of separating
    our testing method outputs. This will help us to more easily follow what''s going
    on with our test class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Optionally, assign the `[AssemblyInitialize]` attribute to execute code before
    the tests are executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can optionally assign the `[ClassInitialize]` attribute to execute
    code once before the tests are executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run the setup code before each unit test by assigning the `[TestInitialize]` attribute
    to a setup method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When you have finished your test run, you can optionally assign the `[AssemblyCleanup]` attribute
    to perform any necessary cleanup operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The optional method marked as `[ClassCleanup]` runs once after all tests in
    the class have been executed. You cannot guarantee when this method will run,
    as it may not run immediately after the execution of all tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To perform clean up operations after each test has been run, apply the `[TestCleanup]` attribute
    to the test cleanup method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that our code is in place, build it. Then, from the Test menu, select Test
    Explorer. You should see the following test in the Test Explorer. As you can from
    the following screenshot, the test has not yet been run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ddfa336a-8927-49a7-a440-fe06d8cc87ef.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So, let''s run our only test. Oh no! Our test has failed, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f5daca3-94d6-43f7-86c2-5ee95570875b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Update the `TestMethod1()` code as shown in the following snippet, and then
    run the test again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You see that the test has passed in the Test Explorer, as shown in the screenshot
    that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/16ff87f8-3e94-4b04-9129-30ed1b316b5f.png)'
  prefs: []
  type: TYPE_IMG
- en: So, from the previous screenshots, you can see that tests that have not been
    executed are *blue*, tests that fail are *red*, and tests that pass are *green*.
    From Tools | Options | Debugging | General, select Redirect all Output Window
    text to the Immediate Window. Then, select Run | Debug All Tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you run through the tests and the output is printed to Immediate Window,
    it will become apparent in what order the attributes are being executed. The following
    screenshot shows the output from our test methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca7e3c1b-fac4-4c63-a123-24020262e564.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you have seen already, we have used two `Assert` methods—these being `Assert.Fail()`
    and `Assert.IsTrue(true)`. The `Assert` class is very useful and so it pays to
    be aware of the methods available in the class for unit testing. These available
    methods are listed and described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Methods** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.AreEqual()` | Tests whether the specified values are equal and throws
    an exception if the two values are not equal. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.AreNotEqual()` | Tests whether the specified values are unequal and
    throws an exception if the two values are equal. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.ArtNotSame()` | Tests whether the specified objects refer to different
    objects and throws an exception if the two inputs refer to the same object. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.AreSame()` | Tests whether the specified objects both refer to the
    same object and throws an exception if the two inputs do not refer to the same
    object. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.Equals()` | This object will always throw with `Assert.Fail`. Hence,
    we can use `Assert.AreEqual` instead. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.Fail()` | Throws an `AssertFailedException` exception. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.Inconclusive()` | Throws an `AssertInconclusiveException` exception.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.IsFalse()` | Tests whether the specified condition is false and throws
    an exception if the condition is true. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.IsInstanceOfType()` | Tests whether the specified object is an instance
    of the expected type and throws an exception if the expected type is not in the
    inheritance hierarchy of the object. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.IsNotInstanceOfType()` | Tests whether the specified object is an
    instance of the wrong type and throws an exception if the specified type is in
    the inheritance hierarchy of the object. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.IsNotNull()` | Tests whether the specified object is non-null and
    throws an exception if it is null. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.IsNull()` | Tests whether the specified object is null and throws
    an exception if it is not null. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.IsTrue()` | Tests whether the specified condition is true and throws
    an exception if the condition is false. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.ReferenceEquals()` | Determines whether the specified object instances
    are the same instance. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.ReplaceNullChars()` | Replaces null characters (`''\0''`) with "`\\0`".
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.That()` | Gets the singleton instance of the `Assert` functionality.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.ThrowsException()` | Tests whether the code specified by delegate
    action throws given an exception of type `T` (and not a derived type) and throws
    `AssertFailedException` if the code does not throw an exception, or throws an
    exception of a type other than `T`. In simple words, this takes a delegate and
    asserts that it throws the expected exception with the expected message. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.ThrowsExceptionAsync()` | Tests whether the code specified by delegate
    action throws given the exception of type `T` (and not a derived type) and throws
    `AssertFailedException` if the code does not throw an exception, or throws an
    exception of a type other than `T`. |'
  prefs: []
  type: TYPE_TB
- en: Now that we have had a look at MSTest, it is time to look at NUnit.
  prefs: []
  type: TYPE_NORMAL
- en: NUnit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If NUnit is not installed for Visual Studio, then download and install it via
    Extensions | Manage Extensions. After that, create a new NUnit Test Project (.NET
    Core). The following code contains the default class created by NUnit, called `Tests`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the `Test1` method, the test methods also use an `Assert`
    class, as does MSTest for testing assertions in code. The NUnit Assert class makes
    the following methods available to us (note that methods marked as [NUnit] in
    the following table are specific to NUnit; all others are also present in MSTest):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Methods** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.AreEqual()` | Verifies that two items are equal. If they are not
    equal, then an exception is thrown. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.AreNotEqual()` | Verifies that two items are not equal. If they are
    equal, then an exception is thrown. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.AreNotSame()` | Verifies that two objects do not refer to the same
    object. If they do, then an exception is thrown. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.AreSame()` | Verifies that two objects refer to the same object.
    If they don''t, then an exception is thrown. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.ByVal()` | [NUnit] Applies a constraint to an actual value, succeeding
    if the constraint is satisfied and throwing an assertion exception on failure.
    Used as a synonym for `That` in rare cases where a private setter causes a Visual
    Basic compilation error. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.Catch()` | [NUnit] Verifies that a delegate throws an exception when
    called and returns it. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.Contains()` | [NUnit] Verifies whether a value is contained in a
    collection. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.DoesNotThrow()` | [NUnit] Verifies that a method does not throw an
    exception. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.Equal()` | [NUnit] Do not use. Use `Assert.AreEqual()` instead. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.Fail()` | Throws an `AssertionException`. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.False()` | [NUnit] Verifies a condition is false. Throws an exception
    if the condition is true. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.Greater()` | [NUnit] Verifies that the first value is greater than
    the second value. Throws an exception if it is not. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.GreaterOrEqual()` | [NUnit] Verifies that the first value is greater
    than or equal to the second value. Throws an exception if it is not. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.Ignore()` | [NUnit] Throws `IgnoreException` with the message and
    arguments that are passed in. This causes the test to be reported as ignored.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.Inconclusive()` | Throws `InconclusiveException` with the message
    and arguments that are passed in. This causes the test to be reported as inconclusive.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.IsAssignableFrom()` | [NUnit] Verifies that an object may be assigned
    a value of a given type. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.IsEmpty()` | [NUnit] Verifies whether a value such as a string or
    collection is empty. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.IsFalse()` | Verifies whether a condition is false. Throws an exception
    if it is true. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.IsInstanceOf()` | [NUnit] Verifies that an object is an instance
    of a given type. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.NAN()` | [NUnit] Verifies that the value is not a number. If it is,
    then an exception is thrown. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.IsNotAssignableFrom()` | [NUnit] Verifies that an object is not assignable
    from a given type. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.IsNotEmpty()` | [NUnit] Verifies that a string or collection is not
    empty. |'
  prefs: []
  type: TYPE_TB
- en: '| `Asserts.IsNotInstanceOf()` | [NUnit] Verifies that the object is not an
    instance of a given type. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.InNotNull()` | Verifies that an object is not null. If it is, then
    an exception is thrown. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.IsNull()` | Verifies that an object is null. If it is not, then an
    exception is thrown. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.IsTrue()` | Verifies that a condition is true. If it is false, then
    an exception is thrown. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.Less()` | [NUnit] Verifies that the first value is less than the
    second value. If not, then an exception is thrown. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.LessOrEqual()` | [NUnit] Verifies that the first value is less than
    or equal to the second value. If not, then an exception is thrown. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.Multiple()` | [NUnit] Wraps code containing a series of assertions,
    which should all be executed, even if they fail. Failed results are saved and
    reported at the end of the code block. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.Negative()` | [NUnit] Verifies that a number is negative. If not,
    then an exception is thrown. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.NotNull()` | [NUnit] Verifies that an object is not null. If it is
    null, then an exception is thrown. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.NotZero()` | [NUnit] Verifies that a number is not zero. If it is
    zero, then an exception is thrown. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.Null()` | [NUnit] Verifies that an object is null. If not, then an
    exception is thrown. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.Pass()` | [NUnit] Throws `SuccessException` with the message and
    arguments that are passed in. This allows a test to be cut short, with a result
    of success returned to NUnit. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.Positive()` | [NUnit] Verifies that a number is positive. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.ReferenceEquals()` | [NUnit] Do not use. Throws `InvalidOperationException`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.That()` | Verifies that a condition is true. If not, then an exception
    is thrown. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.Throws()` | Verifies that a delegate throws a particular exception
    when it is called. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.True()` | [NUnit] Verifies that a condition is true. If not, then
    an exception is called. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.Warn()` | [NUnit] Issues a warning using the message and arguments
    provided. |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.Zero()` | [NUnit] Verifies that a number is zero. |'
  prefs: []
  type: TYPE_TB
- en: 'The NUnit life cycle begins with the `TestFixtureSetup` that is executed once
    before the first test `SetUp`. Then, `SetUp` is executed before each test. After
    each test has executed, `TearDown` is executed. And finally, `TestFixtureTearDown`
    is executed once after the last test `TearDown`. We are now going to update the
    `Tests` class so that we can debug and see the NUnit life cycle in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We have added the `[TestFixture]` to the class and implemented the `IDisposable`
    interface. The `[TextFixture]` attribute is optional for non-parameterized and
    non-generic fixtures. A class will be treated as a `[TextFixture]` as long as
    at least one method is marked with the `[Test]`, `[TestCase]`, or `[TestCaseSource]`
    attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `WriteSeparatorLine()` method acts as a separator for our debug output.
    This method will be called at the top of all our methods in the `Tests` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The method marked with the `[OneTimeSetUp]` attribute will only run once before
    any tests in that class are run. Any initialization that is required for all the
    different tests would be carried out here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The method marked with `[OneTimeTearDown]` is run once after all the tests
    have been run, and before the class is disposed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The method marked with the `[Setup]` attribute runs once before every test
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The method marked with the `[TearDown]` attribute is run once after every test
    method has completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Test2()` method is a test method as denoted by the `[Test]` attribute
    and will be the second test method to run as determined by the `[Order(1)]` attribute.
    This method throws `InconclusiveException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Test1()` method is a test method as denoted by the `[Test]` attribute
    and will be the first test method to be run as determined by the `[0rder(0)]` attribute.
    The method passes `SuccessException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Test3()` method is a test method as denoted by the `[Test]` attribute
    and will be the third test method to run as determined by the `[Order(2)]` attribute.
    The method throws `AssertionException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When you debug all the tests, your immediate window should look like the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1d3fee70-f43a-4edb-8cdc-c7d7525fa9e1.png)'
  prefs: []
  type: TYPE_IMG
- en: You have now been exposed to MSTest and NUnit, and have seen the testing life
    cycle for each framework in action. It's now time to have a look at Moq.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the table of NUnit methods compared to the table of MSTest
    methods, NUnit enables more fine-grained unit testing over MSTest and executes
    with better performance, which is why it is more widely used than MSTest.
  prefs: []
  type: TYPE_NORMAL
- en: Moq
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A unit test should only test the method under test. See the following diagram. If
    a method under test calls other methods that are either in the current class or
    in different classes, then not only test methods but other methods are also tested:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1d62c94e-84a0-415b-b6e2-31dd12e48f47.png)'
  prefs: []
  type: TYPE_IMG
- en: One way to overcome this is to use mock (fake) objects. The mock object will
    only test the method you want to test, and you can make the mock object work any
    way that you want to. If you were to write your own mock objects, you would soon
    come to appreciate that there is a lot of hard work involved. This may be unacceptable
    in time-sensitive projects, and the more complex your code becomes, the more complex
    your mock objects become.
  prefs: []
  type: TYPE_NORMAL
- en: You will inevitably give it up as a bad job, or you will look for a mocking
    framework that suits your needs. Rhino Mocks and Moq are two mocking frameworks
    for the .NET Framework. For the purposes of this chapter, we will only be looking
    at Moq, which is easier to learn and use compared to Rhino Mocks. For more information
    on Rhino Mocks, visit [http://hibernatingrhinos.com/oss/rhino-mocks](http://hibernatingrhinos.com/oss/rhino-mocks).
  prefs: []
  type: TYPE_NORMAL
- en: When testing using Moq, we start by adding the mock object and then configure
    the mock object to do something. We then assert that the configuration is working
    and that the mock was invoked. These steps enable us to determine that the mock
    is correctly set up. Moq only produces test doubles. It does not test the code.
    You still need a test framework such as NUnit to test your code.
  prefs: []
  type: TYPE_NORMAL
- en: We'll now look at an example of using Moq and NUnit together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new console application and call it `CH06_Moq`. Add the following
    interface and classes—`IFoo`, `Bar`, `Baz`, and `UnitTests`. Then, via the Nuget
    package manager, install Moq, NUnit, and NUnit3TestAdapter. Update the `Bar` class
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Bar` class has a virtual property of type `Baz` and a virtual method called
    `Submit()` that returns a Boolean value of false. Now update the `Baz` class as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Baz` class has a single virtual property of type string called `Name`.
    Modify the `IFoo` file to contain the following source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IFoo` interface has a number of properties and methods. As you can see,
    the interface has a reference to the `Bar` class, and we know that the `Bar` class contains
    a reference to the `Baz` class. We will now start updating our `UnitTests` class
    to test our newly-created interface and classes using NUnit and Moq. Modify the
    `UnitTests` class file so that it looks like the code that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add the `AssertThrows` method that asserts whether a designated exception
    has been thrown or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AssertThrows` method is a generic method that will return `true` if your
    method throws the designated exception, and `false` if it does not. We will be
    using this method when we test exceptions further in this chapter. Now, add the
    `DoSomethingReturnsTrue()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DoSomethingReturnsTrue()` method creates a new mock implementation of
    the `IFoo` interface. Then it sets up the `DoSomething()` method to accept a string
    containing the word `"ping"`, and then returns `true`. Finally, the method asserts
    that when the `DoSomething()` method is called with the text `"ping"`, the method
    returns a value of `true`. We''ll now implement a similar test method that returns
    `false` if the value is `"tracert"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DoSomethingReturnsFalse()` method follows the same procedure as the `DoSomethingReturnsFalse()`
    method. We create a mock object of the `IFoo` interface, set it up to return `false`
    if the parameter value is `"tracert"`, and then assert that `false` is returned
    for a parameter value of `"tracert"`. Next, we''ll test our arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OutArguments()` method creates an implementation of the `IFoo` interface.
    A string that will be used as an out parameter is then declared and assigned the
    value `"ack"`. Next, the `TryParse()` method of the `IFoo` mock object is set
    up to return `true` for an input value of `"ping"` and to output the string value
    of `"ack"`. We then assert that the `outString` is equal to the value `"ack"`.
    The final check asserts that `TryParse()` returns `true` for the input value of
    `"ping"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `RefArguments()` method creates an instance of the `Bar` class. Then, a
    mock implementation of the `IFoo` interface is created. The `Submit()` method
    is then set up to return `true` if the reference type passed in is of type `Bar`.
    We then assert that the argument that is passed in is `true` of type `Bar`. In
    our `AccessInvocationArguments()` test method, we create a new implementation
    of the `IFoo` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we set up the `DoSomethingStringy()` method to convert the input to lowercase
    and return it. Finally, we assert that the string returned is the string passed
    in that has been converted to lowercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In our final test method called `ThrowingWhenInvokedWithSpecificParameters()`,
    we create a mock implementation of the `IFoo` interface. We then configure the
    `DoSomething()` method to throw `InvalidOperationException` when the passed-in
    value is `"reset"`.
  prefs: []
  type: TYPE_NORMAL
- en: An `ArgumentException` exception of `"command"` is thrown when an empty string
    is passed in. We then assert that `InvalidOperationException` is thrown when the
    input value is `"reset"`. When the input value is an empty string, we assert that
    `ArgumentException` is thrown, with the assertion that the message of `ArgumentException`
    is `"command"`.
  prefs: []
  type: TYPE_NORMAL
- en: You've now seen how to use a mocking framework called Moq to create mock objects
    to test your code using NUnit. The last tool we will now look at is called **SpecFlow**.
    SpecFlow is a BDD tool.
  prefs: []
  type: TYPE_NORMAL
- en: SpecFlow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: User-focused behavioral tests that are written ahead of the code are the primary
    function behind BDD. BDD is a software development methodology that evolved from
    TDD. You start BDD with a list of features. Features are specifications written
    in a formal business language. This language is understandable by all stakeholders
    on a project. Once the features have been agreed and generated, it is up to the
    developers to then develop step definitions for the feature statements. Once the
    step definitions have been created, the next step is to create the external project
    to implement the feature and add a reference to it. The step definitions are then
    extended to implement the application code for the feature.
  prefs: []
  type: TYPE_NORMAL
- en: One benefit of this approach is that you, as a programmer, are guaranteed to
    deliver on what the business has asked for, rather than give them what you think
    they asked for. This can save the business a lot of money and hours. Past history
    has shown that many projects failed because of the lack of clarity on what needed
    to be delivered between the business teams and the programming teams. BDD helps
    to alleviate this potential hazard when developing new features.
  prefs: []
  type: TYPE_NORMAL
- en: In this section of the chapter, we will develop a very simple calculator example
    using the BDD software development methodology by using SpecFlow.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by writing a feature file that will act as our specification with
    acceptance criteria. Then we will generate our step definitions from our feature
    file that will generate our required methods. Once our step definitions have generated
    the required methods, we will then write the code for them so that our feature
    is complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class library and add the following packages—NUnit, NUnit3TestAdapter,
    SpecFlow, SpecRun.SpecFlow and SpecFlow.NUnit. Add a new SpecFlow Feature file
    called `Calculator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The preceding text is the text automatically added to the `Calculator.feature`
    file upon creation. So we'll use this as our starting point for learning BDD using
    SpecFlow. As of the time of writing, it worth noting that SpecFlow and SpecMap
    have been acquired by **Tricentis**. Tricentis has stated that SpecFlow, SpecFlow+,
    and SpecMap will all remain free, so now is a good time to learn and use SpecFlow
    and SpecMap if you haven't already done so.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our feature file, we need to create step definitions that
    will bind our feature request to our code. Right-click in the code editor and
    a context menu will pop up. Select Generate step definitions. You should see the
    following dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/61f9cd3d-8061-46b9-ae24-40da636c3445.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Enter the name `CalculatorSteps` for the class name. Click on the Generate
    button to generate the step definition and save the file. Open the `CalculatorSteps.cs`
    file and you should see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'A comparison of the contents of the steps file with the feature file is shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/386ea8ad-8b99-4cc7-861e-30d2c32b3b4b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The code that implements the feature must be in a separate file. Create a new
    class library and call it `CH06_SpecFlow.Implementation`. Then, add a file called
    `Calculator.cs`. Add a reference to the newly created library in the SpecFlow
    project, and the following line to the top of the `CalculatorSteps.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now in a position to extend our step definitions so that they implement
    the application code. In the `CalculatorSteps.cs` file, replace all the `p0` parameters
    with a number. This makes the parameter requirement more *explicit*. At the top
    of the `Calculate` class, add two public properties called `FirstNumber` and `SecondNumber`,
    as shown in the code that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `CalculatorSteps` class, update the `GivenIHaveEnteredIntoTheCalculator()`
    method as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add the second method, `GivenIHaveAlsoEnteredIntoTheCalculator()`, if
    it does not already exist, and assign the `number` parameter to the calculator''s
    second number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Add `private int result;` to the top of the `CalculatorSteps` class and before
    any steps. Add the `Add()` method to the `Calculator` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, update the `WhenIPressAdd()` method in the `CalculatorSteps` class and
    update the `result` variable with the result of calling the `Add()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, modify the `ThenTheResultShouldBeOnTheScreen()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Build your project and run your tests. You should see that the tests pass. Only
    the code required by the feature to pass has been written and your code has passed
    the test.
  prefs: []
  type: TYPE_NORMAL
- en: You can find out more about SpecFlow at [https://specflow.org/docs/](https://specflow.org/docs/).
    We've covered some of the tools available for you to develop and test your code.
    Now it is time to see a really simple example of how we go about coding using
    TDD. We'll start by writing code that fails. Then, we'll write just enough code
    for the test to compile. And finally, we will refactor the code.
  prefs: []
  type: TYPE_NORMAL
- en: TDD methodology practice – fail, pass, and refactor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn to write tests that fail. Then you will learn
    to write just enough code to make the test pass, and then if necessary, you will
    perform any refactoring that needs to take place.
  prefs: []
  type: TYPE_NORMAL
- en: Before we delve into a practical example of TDD, let's consider why we need
    TDD. In the previous section, you saw how we can create feature files and generate
    step files from them to write code that meets a business need. Another way to
    ensure that your code meets the business requirements is with TDD. With TDD, you
    start with a test that fails. Then, you write just enough code to make the test
    pass, and as the need arises, you perform refactoring of your new code. This process
    is repeated until such time as all the features have been coded.
  prefs: []
  type: TYPE_NORMAL
- en: But *why* do we need TDD?
  prefs: []
  type: TYPE_NORMAL
- en: Business software specifications are put together by business analysts who work
    with project stakeholders to design new software, or extensions and modifications
    to existing software. Some software is critical and cannot afford to be buggy.
    Such software includes financial systems that handle private and business investments;
    medical equipment, including critical life support and scanning equipment, that
    requires functional software for it to work; transport signaling software for
    traffic management and navigation systems; space flight systems; and weapon systems.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, but where does TDD fit in?
  prefs: []
  type: TYPE_NORMAL
- en: Well, you've been given a specification to write a piece of software. The first
    thing you need to do is create your project. Then, you write the pseudocode for
    the functionality that you are going to implement. You then progress to writing
    the tests for each piece of pseudocode. The test fails. You then write the required
    code that causes the test to pass, and then you refactor your code as needed.
    What you are doing here is writing code that is well tested and robust. You are
    able to guarantee that your code will execute as expected in isolation. If your
    code is a component of a larger system, then it will be the responsibility of
    the test team to test the integration of your code, not you. You, as a developer,
    have earned the confidence in your code to release it to the test team. If the
    test team identify use cases that have previously been overlooked, they will share
    them with you. You will then write further tests and make them pass before releasing
    the updated code to them. Such a way of working ensures that code is of the highest
    standard and can be trusted to work as expected by given the expected outputs
    for the given inputs. And finally, TDD makes software progress measurable, which
    is good news for managers.
  prefs: []
  type: TYPE_NORMAL
- en: It's time for our little demonstration of TDD. In this example, we will use
    TDD to develop a simple logging application that can handle inner exceptions,
    and logs exceptions to a timestamped text file. We will write the program and
    get the tests to pass. Once we have written our program and got all the tests
    to pass, then we will refactor our code to make it reusable and easier to read,
    and of course, we will make sure that our tests still pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new console application and call it `CH06_FailPassRefactor`. Add a
    class called `UnitTests` with the following pseudocode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll write our first unit test to satisfy the condition `[1]`. In our unit
    test, we will test create the `Logger` variable, call the `Log()` method, and
    pass the test. So, let''s write the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This test will not run as the project will not build. That is because the `Logger`
    class does not exist. So add an internal class called `Logger` to the project.
    Then run your test. The build will still *fail*, and the test won't be run because
    we are now missing the `Log()` method. So let's add the `Log()` method to our
    `Logger` class. Then, we'll try and run our test again. This time, the test should
    succeed.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, we will perform any necessary refactoring. But since we have
    just started, there is no refactoring to do, so we can move on to our next test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our code to generate the log message and save it to disk will feature private
    members. With NUnit, you don''t test private members. The school of thought is
    that if you have to test private members, then there must be something wrong with
    your code. So, we''ll move on to our next unit test, which will determine whether
    the log file exists. Before we write our unit test, we will write a method that
    returns an exception with an inner exception that has an inner exception. We will
    pass the returned exception into the `Log()` method in our unit test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have our `GetException()` method in place where we can write our unit
    test to check whether the log file exists:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If we build our code and run the `CheckFileExists()` test, it will fail, so
    we need to write the code for it to succeed. In the `Logger` class, add `private
    StringBuilder _stringBuilder;` to the top of the `Logger` class. Then, modify
    the `Log()` method and add the following method to the `Logger` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We have called the `Log()` method and a log file is generated. Now, all we
    need is the text to be logged to the file. According to our pseudocode, we need
    to log the main exception and all inner exceptions. Let''s write a test that checks
    whether the log file contains the message `"Exception: Inner Exception Inner Exception"`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we know that the test will fail because the string builder is *empty*, so
    we will add the method to the `Logger` class that will take an exception, log
    the message, and check whether the exception has an inner exception. If it has,
    then it will call itself with the parameter `isInnerException`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, update the `Log()` method of the `Logger` class to call our `BuildExceptionMessage()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: All our tests now pass and we have a fully functioning program that does what's
    expected of it, but there is an opportunity here for some refactoring. The method
    called `BuildExceptionMessage()` is a candidate for reuse as it is very useful
    for debugging purposes, especially when you have an exception with an inner exception,
    so we are going to move that method into its own method. Notice that the `Log()`
    method is also building the opening and closing portions of the text to be logged.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can and will move this into the `BuildExceptionMessage()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class and call it `Text`. Add a private `StringBuilder` member
    variable and instantiate it in the constructor. Then, update the class by adding
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve now got a useful `Text` class that returns a useful exception message
    from an exception with inner exceptions, but we can also refactor the code in
    the `SaveLog()` method. We can extract the code that generates a unique hashed
    filename into its own method. So, let''s add the following method to the `Text`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The `GetHashedTextFileName()` method accepts a name for the file specified by
    the user and a special folder. It then adds a hyphen and the current UTC date's
    hash code to the end of the filename. It then adds the `.txt` file extension and
    assigns the text to the `fileName` variable. The absolute path of the special
    folder requested by the caller is then assigned to the `dir` variable and the
    path and filename are then returned to the user. This method is guaranteed to
    return unique filenames.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the body of the `Logger` class with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The class is still doing the same thing, but it is cleaner and smaller as the
    message and filename generation has been moved to a separate class. If you run
    the code, it behaves in the same way. If you run the tests, they will all pass.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have written unit tests that failed, and then modified them
    so that they passed. Then, we refactored the code to make it cleaner, which resulted
    in us writing code that can be reused in the same project or other projects. Let's
    now take a very brief look at redundant tests.
  prefs: []
  type: TYPE_NORMAL
- en: Removing redundant tests, comments, and dead code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the book states, we are interested in writing clean code. As our programs
    and tests grow and we start to refactor, some code will become redundant. Any
    code that is redundant and does not get called is known as **dead code**. Dead
    code should always be removed as soon as it is identified. Dead code will not
    be executed in compiled code, but it is still part of the code base that needs
    to be maintained. Code files with dead code are longer than they need to be. Apart
    from the unnecessary fact that it makes your files bigger, it can also make reading
    source code harder, as it may cut through the natural flow of the code and add
    confusion and delay to the programmer reading it. Not only that, but the last
    thing any programmer new to the project needs is to waste valuable time trying
    to understand dead code that will never be used. So it is best to get rid of it.
  prefs: []
  type: TYPE_NORMAL
- en: As for comments, they can be really useful if done right, and API commenting
    is particularly beneficial for API documentation generation. But some comments
    just add noise to the code file, and a surprising number of programmers can become
    really irritated by them. There is one group of programmers that will comment
    on everything. Another group won't comment on anything as they believe the code
    should read like a book. And then there are those who take a balanced approach,
    and only comment on code when it is deemed necessary for people to understand
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: When you see comments like this—*"This generates a random bug every so often.
    Don't know why. But you're welcome to fix it!"*—alarm bells should start ringing.
    First of all, the programmer who wrote the comment should have stuck with the
    code and not moved on until the conditions that generate the bug were identified,
    and then the bug should have been fixed. If you know who the programmer is who
    wrote the comment, then return the code to them to fix and remove the comment.
    I have seen code like that on more than one occasion, and I've seen comments on
    the web expressing these strong sentiments about such comments. I suppose it is
    a way to deal with lazy programmers. Should they not be lazy, but rather simply
    inexperienced, then it is a good learning task in the art of problem diagnosis
    and resolution.
  prefs: []
  type: TYPE_NORMAL
- en: If code has been checked in and approved, and you come across blocks of code
    that have been commented out, then delete them. The code will still exist in the
    version control history and you will be able to retrieve it from there if you
    have to.
  prefs: []
  type: TYPE_NORMAL
- en: Code should be read like a book, and so you should not aim to make your code
    cryptic just to look good and impress your colleagues, because I guarantee that
    when you come back to your own code in a few weeks' time, you will scratch your
    head wondering what your own code does and why. I've seen many juniors make this
    mistake.
  prefs: []
  type: TYPE_NORMAL
- en: Redundant tests should also be removed. You only need to run the tests that
    are necessary. Tests for redundant code have no value and can waste considerable
    time. Also, if your company has CI/CD pipelines that also run tests in the cloud,
    then the redundant tests and dead code add business costs to the build, test,
    and deploy pipelines. This means that the fewer lines of code you upload, build,
    test, and deploy, the less your company has to fork out on running costs. Remember,
    running processes in the cloud costs money and the aim of a business is to spend
    as little money as possible, but rake in plenty of money.
  prefs: []
  type: TYPE_NORMAL
- en: So now that we've finished the chapter, let's summarize what we've learned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started by looking at why it is important for developers to write unit tests
    to develop quality-assured code. Theoretical problems were identified that could
    arise from bugs in the software. These include loss of life and expensive lawsuits.
    Unit testing and what makes a good unit test was then discussed. We identified
    that a good unit test must be atomic, deterministic, repeatable, and fast.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we went on to look at the tools available to developers that assist with
    TDD and BDD. MSTest and NUnit were discussed with examples that showed how to
    implement TDD. Then, we looked at using a mocking framework called Moq in conjunction
    with NUnit for testing mock objects. Our look at tools then concluded with SpecFlow—a
    BDD tool that allows us to write features in a business language that both techies
    and non-techies can understand—to make sure that what the business wants is what
    the business gets.
  prefs: []
  type: TYPE_NORMAL
- en: NUnit was then put to work as we worked through a very simple TDD example using
    the *fail, pass, and refactor* methodology, before finally looking at why we should
    remove unnecessary comments, redundant tests, and dead code.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, you will find further resources on testing software
    programs. In the next chapter, we are going to look at end-to-end testing. But
    before that, you might as well have a go at the following questions and see how
    much knowledge on unit testing you have retained.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What makes a good unit test?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What should a good unit test not be?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does TDD stand for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does BDD stand for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a unit test?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a mock object?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a fake object?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name some unit testing frameworks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name some mocking frameworks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name a BDD framework.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What should be removed from source code files?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A brief overview of unit testing, with links to further information on different
    types of unit testing including integration testing, acceptance testing, and tester
    job descriptions, can be found at [http://softwaretestingfundamentals.com/unit-testing](http://softwaretestingfundamentals.com/unit-testing/)[.](http://softwaretestingfundamentals.com/unit-testing/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Rhino Mocks homepage can be found at [http://hibernatingrhinos.com/oss/rhino-mocks](http://hibernatingrhinos.com/oss/rhino-mocks).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
