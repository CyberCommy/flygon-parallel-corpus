- en: 6\. Collision Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will continue working on the collision-based game we introduced
    in the previous chapter by adding further mechanics and objects to our game. Initially,
    we will follow on from the previous chapter by introducing object collision. You
    will learn how to use collision boxes, collision triggers, overlap events, hit
    events, and physics simulation. You will also learn how to use timers, the Projectile
    Movement Component, and Physical Materials.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we came across some of the basic concepts of collision,
    namely Line Traces and Sweep Traces. We learned how to execute different types
    of Line Traces, how to create our own custom Trace Channels, and how to change
    how an object responds to a specific channel. Many of the things you learned in
    the previous chapter will be used in this chapter, where we'll learn about object
    collision.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we will continue to build upon our top-down `Dodgeball`
    game by adding game mechanics that revolve around object collision. We will create
    the **Dodgeball actor**, which will act as a dodgeball that bounces off of the
    floor and walls; a **Wall actor**, which will block all objects; a **Ghost Wall
    actor**, which will only block the player, not the enemies' lines of sight or
    the dodgeball; and a **Victory Box actor**, which will end the game when the player
    enters the Victory Box, representing the end of the level.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start creating our `Dodgeball` class, we will go over the basic concepts
    of object collision in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Object Collision in UE4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every game development tool must have a physics engine that simulates collision
    between multiple objects, as explained in the previous chapter. Collision is the
    backbone of most games released nowadays, whether 2D or 3D. In many games, it's
    the main way in which the player acts upon the environment, be it running, jumping,
    or shooting, and the environment acts accordingly by making the player land, get
    hit, and so on. It is no understatement to say that, without simulated collision,
    it wouldn't be possible to make many games at all.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's understand how object collision works in UE4 and the ways in which
    we can use it, starting with collision components.
  prefs: []
  type: TYPE_NORMAL
- en: Collision Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In UE4, there are two types of components that can affect and be affected by
    collision; they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Meshes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shape objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Meshes** can be as simple as a cube, or as complex as a high-resolution character
    with tens of thousands of vertices. A mesh''s collision can be specified with
    a custom file imported alongside the mesh into UE4 (which is outside the scope
    of this book), or it can be calculated automatically by UE4 and customized by
    you.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is generally a good practice to keep the collision mesh as simple (few triangles)
    as possible so that the physics engine can efficiently calculate collision at
    runtime. The types of meshes that can have collision are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Static Meshes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skeletal Meshes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Procedural Meshes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shape objects**, which are simple meshes represented in wireframe mode that
    are used to behave as collision objects by causing and receiving collision events.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Wireframe mode is a commonly used visualization mode in game development, usually
    for debugging purposes, which allows you to see meshes without any faces or textures
    â€“ they can only be seen through their edges, which are connected by their vertices.
    You will see what wireframe mode is when we add a Shape component to an actor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please note that Shape objects are essentially invisible meshes and that their
    three types are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Box Collision (Box Component in C++)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sphere Collision (Sphere Component in C++)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capsule Collider (Capsule Component in C++)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There's a class that all the components that provide geometry and collision
    inherit from, which is the `Primitive` Component. This component is the basis
    for all components that contain any sort of geometry, which is the case for mesh
    components and shape components.
  prefs: []
  type: TYPE_NORMAL
- en: So, how can these components collide, and what happens when they do so? We shall
    have a look at this in the next section, collision events.
  prefs: []
  type: TYPE_NORMAL
- en: Collision Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say that there are two objects colliding into one another. Two things
    can happen:'
  prefs: []
  type: TYPE_NORMAL
- en: They overlap each other, as if the other object weren't there, in which case
    the `Overlap` event is called.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They collide and prevent each other from continuing their course, in which case
    the `Block` event is called.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to change an object's response to a
    specific `Trace` channel. During this process, we learned that an object's response
    can be either `Block`, `Overlap`, or `Ignore`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see what happens in each of these responses during a collision.
  prefs: []
  type: TYPE_NORMAL
- en: '`Block`:'
  prefs: []
  type: TYPE_NORMAL
- en: Both objects will have their `OnHit` events called. This event is called whenever
    two objects block each other's path at the moment they collide. If one of the
    objects is simulating physics, that object must have its `SimulationGeneratesHitEvents`
    property set to `true`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both objects will physically stop each other from continuing with their course.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Have a look at the following figure, which shows an example of when two objects
    are thrown and bounce off each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1: Object A and Object B blocking each other'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_06_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.1: Object A and Object B blocking each other'
  prefs: []
  type: TYPE_NORMAL
- en: '**Overlap**: Two objects will overlap each other if they don''t block each
    other and neither of them is ignoring the other:'
  prefs: []
  type: TYPE_NORMAL
- en: If both objects have the `GenerateOverlapEvents` property set to `true`, they
    will have their `OnBeginOverlap` and `OnEndOverlap` events called. These overlap
    events are called when an object starts and stops overlapping another object,
    respectively. If at least one of them doesn't have this property set to `true`,
    neither of them will call these events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The objects act as if the other object doesn't exist and will overlap each other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As an example, suppose the player's character walks into a trigger box that
    marks the end of the level, which only reacts to the player's character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following figure, which shows an example of two objects
    overlapping each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2: Object A and Object B overlapping each other'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_06_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.2: Object A and Object B overlapping each other'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ignore**: Two objects will ignore each other if at least one of them is ignoring
    the other:'
  prefs: []
  type: TYPE_NORMAL
- en: There will be no events called on either object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar to the `Overlap` response, the objects will act as if the other object
    doesn't exist and will overlap each other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An example of two objects ignoring each other would be when an object other
    than the player's character goes into a trigger box that marks the end of the
    level, which only reacts to the player's character.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can look at the previous figure, where two objects overlap each other, to
    understand **Ignore**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a table to help you understand the necessary responses that two objects
    must have in order to trigger the previously described situations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3: Resulting responses on objects based on Block, Overlap, and Ignore'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_06_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.3: Resulting responses on objects based on Block, Overlap, and Ignore'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following this table, consider that you have two objects â€“ Object A and Object
    B:'
  prefs: []
  type: TYPE_NORMAL
- en: If Object A has set its response to Object B to `Block` and Object B has set
    its response to Object A to `Block`, they will `Block` each other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If Object A has set its response to Object B to `Block` and Object B has set
    its response to Object A to `Overlap`, they will `Overlap` each other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If Object A has set its response to Object B to `Ignore` and Object B has set
    its response to Object A to `Overlap`, they will `Ignore` each other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find a full reference to UE4''s collision interactions here: [https://docs.unrealengine.com/en-US/Engine/Physics/Collision/Overview](https://docs.unrealengine.com/en-US/Engine/Physics/Collision/Overview).'
  prefs: []
  type: TYPE_NORMAL
- en: 'A collision between objects has two aspects to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Physics**: All collisions related to physics simulation, such as a ball being
    affected by gravity and bouncing off the floors and walls.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The physically simulated response of the collision within the game, which can
    beÂ either:'
  prefs: []
  type: TYPE_NORMAL
- en: Both objects continuing their trajectories as if the other object wasn't there
    (no physical collision).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both objects colliding and changing their trajectories, usually with at least
    one of them continuing its movement, that is, blocking each other's paths.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Query**: Query can be divided into two aspects of collision, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The events related to the collision of the objects that are called by the game
    and that you can use to create additional logic. These events are the same ones
    we mentioned previously:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `OnHit` event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `OnBeginOverlap` event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `OnEndOverlap` event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The physical response of the collision within the game, which can be either:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both objects continuing their movement as if the other object wasn't there (no
    physical collision)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both objects colliding and blocking each other's path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The physical response from the Physics aspect might sound similar to the physical
    response from the Query aspect; however, although those are both physical responses,
    they will cause objects to behave differently.
  prefs: []
  type: TYPE_NORMAL
- en: The physical response from the Physics aspect (physics simulation) only applies
    when an object is simulating physics (for example, being affected by gravity,
    bouncing off the walls and ground, and so on). Such an object, when hitting a
    wall, for instance, will bounce back and continue moving in another direction.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the physical response from the Query aspect applies to all
    objects that don't simulate physics. An object can move without simulating physics
    when being controlled by code (for example, by using the `SetActorLocation` function
    or by using the Character Movement Component). In this case, depending on which
    method you use to move the object and its properties, when an object hits a wall,
    it will simply stop moving instead of bouncing back. This is because you're simply
    telling the object to move in a certain direction and something is blocking its
    path, so the physics engine doesn't allow that object to continue moving.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will be looking at Collision Channels.
  prefs: []
  type: TYPE_NORMAL
- en: Collision Channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we took a look at the existing Trace Channels (*Visibility*
    and *Camera*) and learned how to make our own custom channel. Now that you know
    about Trace Channels, it's time to talk about Object Channels, also known as ObjectÂ Types.
  prefs: []
  type: TYPE_NORMAL
- en: While Trace Channels are only used for Line Traces, Object Channels are used
    for object collision. You can specify a "purpose" for each `Object` Channel, much
    like with Trace Channels, such as Pawn, Static Object, Physics Object, Projectile,
    and so on. You can then specify how you want each Object Type to respond to all
    the other Object Types by blocking, overlapping, or ignoring objects of that type.
  prefs: []
  type: TYPE_NORMAL
- en: Collision Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've taken a look at how collision works, let's go back to the collision
    settings of the cube we selected in the previous chapter, where we changed its
    response to the Visibility Channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'The cube can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4: Cube blocking the SightSource of the enemy'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_06_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.4: Cube blocking the SightSource of the enemy'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the level open in the editor, select the cube and go to the `Collision`
    section of its Details Panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5: The changes in the level editor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_06_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.5: The changes in the level editor'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see some options that are important to us:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SimulationGeneratesHitEvents`, which allows the `OnHit` events to be called
    when an object is simulating physics (we''ll talk about this later in thisÂ chapter).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GenerateOverlapEvents`, which allows the `OnBeginOverlap` and `OnEndOverlap`
    events to be called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CanCharacterStepUpOn`, which allows a character to easily step up onto thisÂ object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CollisionPresets`, which allows us to specify how this object responds to
    each Collision Channel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s change the `CollisionPresets` value from `Default` to `Custom` and take
    a look at the new options that show up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6: Changes in Collision Presets'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_06_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.6: Changes in Collision Presets'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first of these options is the `CollisionEnabled` property. It allows you
    to specify which aspects of collision you want this object to be considered for:
    Query, Physics, Both, or None. Again, Physics Collision is related to physics
    simulation (whether this object will be considered by other objects that simulate
    physics), while Query Collision is related to collision events and whether objects
    will block each other''s movement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7: Collision Enabled for Query and Physics'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_06_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.7: Collision Enabled for Query and Physics'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is the `ObjectType` property. This is very similar to the
    Trace Channel concept but is specifically for object collision and, most importantly,
    dictates what type of collision object this is. The Object Type values that come
    with UE4 are asÂ follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WorldStatic`: An object that doesn''t move (structures, buildings, and so
    on)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WorldDynamic`: An object that may move (objects whose movement is triggered
    by code, objects the player can pick up and move, and so on)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pawn`: Used for Pawns that can be controlled and moved around the level'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PhysicsBody`: Used for objects that simulate physics'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Vehicle`: Used for Vehicle objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Destructible`: Used for destructible meshes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As mentioned previously, you can create your own custom object types (which
    will be mentioned later in this chapter) as well, similar to how you can create
    your own Trace Channels (*which was covered in the previous chapter*).
  prefs: []
  type: TYPE_NORMAL
- en: The last option we have is related to `Collision Responses`. Given that this
    `Cube` object has the default collision options, all the responses are set to
    `Block`, which means that this object will block all the Line Traces and all objects
    that block `WorldStatic` objects, given that that is this object's type.
  prefs: []
  type: TYPE_NORMAL
- en: Because there are so many different combinations of collision properties, UE4
    allows you to group collision property values in the form of Collision Presets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to the `CollisionPresets` property, which is currently set to
    `Custom`, and *click it* so that we can see all the possible options. Some of
    the existing `Collision Presets` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**No Collision**: Used for objects that aren''t affected by collision whatsoever:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Collision Enabled`: `NoCollision`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object Type`: `WorldStatic`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Responses: Irrelevant'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example: Objects that are purely visual and distant, such as an object that
    the player will never reach'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Block All**: Used for objects that are static and block all other objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Collision Enabled`: `Query` and `Physics`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object Type`: `WorldStatic`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Responses: `Block` all channels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example: Objects that are close to the player character and block their movement,
    such as the floor and walls, which will always be stationary'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Overlap All**: Used for objects that are static and overlap all other objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Collision Enabled`: `Query` only'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object Type`: `WorldStatic`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Responses: `Overlap` all channels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example: Trigger boxes placed in the level, which will always be stationary'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Block All` preset, but for dynamic objects that may change their transform
    during gameplay (`Object Type`: `WorldDynamic`)'
  prefs: []
  type: TYPE_NORMAL
- en: '`Overlap All` preset, but for dynamic objects that may change their transform
    during gameplay (`Object Type`: `WorldDynamic`)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pawn**: Used for pawns and characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Collision Enabled`: `Query` and `Physics`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object Type`: `Pawn`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Responses: `Block` all channels, `Ignore` Visibility Channel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example: Player character and non-playable characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Physics Actor**: Used for objects that simulate physics:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Collision Enabled`: `Query` and `Physics`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object Type`: `PhysicsBody`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Responses: `Block` all channels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example: Objects that are affected by physics, such as a ball that bounces
    off the floor and walls'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just like the other collision properties, you can also create your own Collision
    Presets.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find a full reference to UE4''s collision responses here: [https://docs.unrealengine.com/en-US/Engine/Physics/Collision/Reference](https://docs.unrealengine.com/en-US/Engine/Physics/Collision/Reference).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know about the basic concepts of collision, let's go ahead and start
    creating the `Dodgeball` class. The next exercise will guide you toward doing
    justÂ that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.01: Creating the Dodgeball Class'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we'll be creating our `Dodgeball` class, which will be thrown
    by our enemies and bounce off the floor and walls, just like an actual dodgeball.
  prefs: []
  type: TYPE_NORMAL
- en: Before we actually start creating the `Dodgeball` C++ class and its logic, we
    should set up all the necessary collision settings for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Open our `Project Settings` and go to the `Collision` subsection within the
    `Engine` section. Currently, there are no Object Channels, so you need to create
    a new one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the `New Object Channel` button, name it `Dodgeball`, and set its `Default
    Response` to `Block`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After you've done this, expand the `Preset` section. Here, you'll find all the
    default presets available in UE4\. If you select one of them and press the `Edit`
    option, you can change that `Preset` collision's settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create your own `Preset` by pressing the `New` option. We want our `Dodgeball`
    `Preset` settings to be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Name`: `Dodgeball`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CollisionEnabled`: `Collision Enabled (Query and Physics)` (we want this to
    be considered for physics simulation as well as collision events)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object Type`: `Dodgeball`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collision Responses`: Select *Block* for most of the options, but *Ignore*
    the Camera and `EnemySight` (we don''t want the dodgeball to block the camera
    or the enemy''s line of sight)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you've selected the correct options, press `Accept`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that the `Dodgeball` class's collision settings have been set up, let's
    create the `Dodgeball` C++ class.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `Content Browser`, *right-click* and select `New C++ Class`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose `Actor` as the parent class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose `DodgeballProjectile` as the name of the class (our project is already
    named `Dodgeball`, so we can't name this new class that too).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `DodgeballProjectile` class files in Visual Studio. The first thing
    we''ll want to do is add the collision component of the Dodgeball, so we''ll add
    a `SphereComponent` to our class header (*actor component properties are usuallyÂ private*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, include the `SphereComponent` class at the top of our source file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that all header file includes must be before the .generated.hÂ include.
  prefs: []
  type: TYPE_NORMAL
- en: Now, head to the `DodgeballProjectile` class's constructor, within its source
    file, and perform the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `SphereComponent` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Set its `radius` to `35` units:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Set its `Collision Preset` to the `Dodgeball` preset we created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We want the `Dodgeball` to simulate physics, so notify the component of this,
    as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We want the `Dodgeball` to call the `OnHit` event while simulating physics,
    so call the `SetNotifyRigidBodyCollision` function in order to set that to `true`
    (this is the same as the `SimulationGeneratesHitEvents` property that we saw in
    the `Collision` section of an object''s properties):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We will also want to listen to the `OnHit` event of `SphereComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a declaration for the function that will be called when the `OnHit`
    event is triggered, in the `DodgeballProjectile` class''s header file. This function
    should be called `OnHit`. It should be `public`, return nothing (`void`), have
    the `UFUNCTION` macro, and receive some parameters, in this order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`UPrimitiveComponent* HitComp`: The component that was hit and belongs to this
    actor. A Primitive Component is an actor component that has a `Transform` property
    and some sort of geometry (for example, a `Mesh` or `Shape` Component).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AActor* OtherActor`: The other actor involved in the collision.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UPrimitiveComponent* OtherComp`: The component that was hit and belongs to
    the other actor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FVector NormalImpulse`: The direction in which the object will be moving after
    it has been hit, and with how much force (by checking the size of the vector).
    This parameter will only be non-zero for objects that are simulatingÂ physics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FHitResult& Hit`: The data of the `Hit` resulting from the collision between
    this object and the other object. As we saw in the previous chapter, it contains
    properties such as the location of the `Hit`, its normal, which component and
    actor it hit, and so on. Most of the relevant information is already available
    to us through the other parameters, but if you need more detailed information,
    you can access this parameter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Add the `OnHit` function's implementation to the class's source file and within
    that function, at least for now, destroy the dodgeball when it hits the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cast the `OtherActor` parameter to our `DodgeballCharacter` class and check
    if the value is not a `nullptr`. If it''s not, which means that the other actor
    we hit is a `DodgeballCharacter`, we''ll destroy this `DodgeballProjectile` actor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Given that we''re referencing the `DodgebalCharacter` class, we''ll need to
    include it at the top of this class''s source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll change this function so that we have the dodgeball
    damage the player before destroying itself. We'll do this when we talk about Actor
    Components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Head back to the `DodgeballProjectile` class''s constructor and add the following
    line at the end in order to listen to the `OnHit` event of `SphereComponent`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This will bind the `OnHit` function we created to this `SphereComponent` `OnHit`
    event (because this is an actor component, this event is called `OnComponentHit`),
    which means our function will be called alongside thatÂ event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, make `SphereComponent` this actor''s `RootComponent`, as shown in the
    following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In order for a moving actor to behave correctly on collision, whether it's simulating
    physics or not, it is usually necessary for the main collision component of the
    actor to be its `RootComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `RootComponent` of the `Character` class is a Capsule Collider
    component, because that actor will be moving around and that component is the
    main way the character collides with the environment.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've added the `DodgeballProjectile` C++ class's logic, let's go ahead
    and create our Blueprint class.
  prefs: []
  type: TYPE_NORMAL
- en: Compile your changes and open the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the `Content` > `ThirdPersonCPP` > `Blueprints` directory in the Content
    Browser, right-click, and create a new Blueprint class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the `All Classes` section and search for the `DodgeballProjectile` class,
    then set it as the parent class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new Blueprint class `BP_DodgeballProjectile`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open this new Blueprint class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Notice the wireframe representation of the `SphereCollision` component in the
    actor''s Viewport window (this is hidden by default during the game, but you can
    change that property in this component''s `Rendering` section by changing its
    `HiddenInGame` property):![Figure 6.8: Visual wireframe representation of the
    SphereCollision component'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_06_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.8: Visual wireframe representation of the SphereCollision component'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add a new `Sphere` mesh as a child of the existing `Sphere Collision`Â component:![Figure
    6.9: Adding a Sphere mesh'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_06_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.9: Adding a Sphere mesh'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change its scale to `0.65`, as shown in the following screenshot:![Figure 6.10:
    Updating the scale'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_06_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.10: Updating the scale'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set its `Collision Presets` to `NoCollision`:![Figure 6.11: Updating Collision
    Presets to NoCollision'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_06_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.11: Updating Collision Presets to NoCollision'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, open our level and place an instance of the `BP_DodgeballProjectile`
    class near the player (this one was placed at a height of 600 units):![Figure
    6.12: Dodgeball bouncing on the ground'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_06_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.12: Dodgeball bouncing on the ground'
  prefs: []
  type: TYPE_NORMAL
- en: After you've done this, play the level. You'll notice that the Dodgeball will
    be affected by gravity and bounce off the ground a couple of times before coming
    to a standstill.
  prefs: []
  type: TYPE_NORMAL
- en: By completing this exercise, you've created an object that behaves like a physicsÂ object.
  prefs: []
  type: TYPE_NORMAL
- en: You now know how to create your own collision object types, use the `OnHit`
    event, and change an object's collision properties.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapter, we briefly mentioned `LineTraceSingleByObjectType`.
    Now that we know how object collision works, we can briefly mention its use: when
    executing a Line Trace that checks for a Trace Channel, you should use the `LineTraceSingleByChannel`
    function; when executing a Line Trace that checks for an `Object` Channel (Object
    Type), you should use the `LineTraceSingleByObjectType` function. It should be
    made clear that this function, unlike the `LineTraceSingleByChannel` function,
    will not check for objects that block a specific Object Type, but those that are
    of a specific Object Type. Both those functions have the exact same parameters
    and both the Trace Channels and Object Channels are available through the `ECollisionChannel`
    enum.'
  prefs: []
  type: TYPE_NORMAL
- en: But what if you wanted the ball to bounce off the floor more times? What if
    you wanted to make it bouncier? Well, that's where Physical Materials come in.
  prefs: []
  type: TYPE_NORMAL
- en: Physical Materials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In UE4, the way you can customize how an object behaves while simulating physics
    is through Physical Materials. In order to get into this new type of asset, let''s
    create ourÂ own:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder inside the `Content` folder called `Physics`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Right-click* on the `Content Browser` while inside that folder and, under
    the `Create Advanced Asset` section, go to the `Physics` subsection and select
    `Physical Material`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name this new Physical Material `PM_Dodgeball`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the asset and take a look at the available options.![Figure 6.13: Asset
    options'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_06_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.13: Asset options'
  prefs: []
  type: TYPE_NORMAL
- en: 'The main options we should note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Friction`: This property goes from `0` to `1` and specifies how much friction
    will affect this object (`0` means this object will slide as if it was on ice,
    while `1` means this object will stick like a piece of gum).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Restitution` (also known as *Bounciness*): This property goes from `0` to
    `1` and specifies how much velocity will be kept after colliding with another
    object (`0` means this object will never bounce off of the ground, while `1` means
    this object will bounce for a long time).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Density`: This property specifies how dense this object is (that is, how heavy
    it is relative to its mesh). Two objects can be of the same size, but if one is
    twice as dense as the other, that means it will be twice as heavy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To have our `DodgeballProjectile` object behave closer to an actual Dodgeball,
    it'll have to suffer quite a bit of friction (the default value is `0.7`, which
    is high enough) and be quite bouncy. Let's increase the `Restitution` property
    of this Physical Material to `0.95`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you''ve done this, open the `BP_DodgeballProjectile` Blueprint class
    and change the Sphere Collision component''s Physical Material, inside its `Collision`
    section, to the one we just created, `PM_Dodgeball`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14: Updating the BP_DodgeballProjectile Blueprint class'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_06_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.14: Updating the BP_DodgeballProjectile Blueprint class'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the instance of the Dodgeball actor you added to your level also has
    this physical material.
  prefs: []
  type: TYPE_NORMAL
- en: If you play the level that we created in *Exercise 6.01*, *Creating the Dodgeball
    Class* again, you'll notice that our `BP_DodgeballProjectile` will now bounce
    off the ground several times before coming to a standstill, behaving much more
    like an actualÂ dodgeball.
  prefs: []
  type: TYPE_NORMAL
- en: With all that done, we're just missing one thing to make our `Dodgeball` actor
    behave like an actual dodgeball. Right now, there is no way for us to be able
    to throw it. So, let's address that by creating a Projectile Movement Component,
    which is what we'll be doing in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapters, when we replicated the Third Person template project,
    we learned that the `Character` class that comes with UE4 has a `CharacterMovementComponent`.
    This actor component is what allows an actor to move around in the level in various
    ways, and has many properties that allow you to customize that to your preference.
    However, there is another movement component that is also frequently used: `ProjectileMovementComponent`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `ProjectileMovementComponent` actor component is used to attribute the behavior
    of a projectile to an actor. It allows you to set an initial speed, gravity force,
    and even some physics simulation parameters such as `Bounciness` and `Friction`.
    However, given that our `Dodgeball Projectile` is already simulating physics,
    the only property that we'll be using is `InitialSpeed`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.02: Adding a Projectile Movement Component to DodgeballProjectile'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will be adding a `ProjectileMovementComponent` to our `DodgeballProjectile`
    so that it has an initial horizontal speed. We're doing this so that it can be
    thrown by our enemies and doesn't just fall vertically.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `ProjectileMovementComponent` property to the `DodgeballProjectile` class''s
    header file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Include the `ProjectileMovementComponent` class at the top of the class''s
    source file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of the class''s constructor, create the `ProjectileMovementComponent`
    object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, set its `InitialSpeed` to `1500` units:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'After you''ve done this, compile your project and open the editor. To demonstrate
    the Dodgeball''s initial speed, lower its position on the *Z* axis and place it
    behind the player (*this one was placed at a height of 200 units*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15: Dodgeball moving along the X axis'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_06_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.15: Dodgeball moving along the X axis'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you play the level, you''ll notice that the Dodgeball starts moving towards
    its *X* axis (*red arrow*):'
  prefs: []
  type: TYPE_NORMAL
- en: And with that, we can conclude our exercise. Our `DodgeballProjectile` now behaves
    like an actual dodgeball. It falls, it bounces, and gets thrown.
  prefs: []
  type: TYPE_NORMAL
- en: The next step in our project is going to be adding logic to our `EnemyCharacter`
    so that it throws these dodgeballs at the player, but before we address that,
    we must address the concept of timers.
  prefs: []
  type: TYPE_NORMAL
- en: Timers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given the nature of video games and the fact that they're strongly event-based,
    every game development tool must have a way for you to cause a delay, or a wait
    time, before something happens. For instance, when you're playing an online death
    match game, where your character can die and then respawn, usually, the respawn
    event doesn't happen the instant your character dies but a few seconds later.
    There is a multitude of scenarios where you want something to happen, but only
    after a certain amount of time. This will be the case for our `EnemyCharacter`,
    which will be throwing dodge balls every few seconds. This delay, or wait time,
    can be achieved through timers.
  prefs: []
  type: TYPE_NORMAL
- en: A **timer** allows you to call a function after a certain amount of time. You
    can choose to loop that function call with an interval and also set a delay before
    the loop starts. If you want the Timer to stop, you can also do that.
  prefs: []
  type: TYPE_NORMAL
- en: We will be using timers so that our enemy throws a dodge ball every `X` amount
    of time, indefinitely, as long as it can see the player character, and then stop
    that timer when the enemy can no longer see its target.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start adding logic to our `EnemyCharacter` class that will make it
    throw dodge balls at the player, we should take a look at another topic, which
    is how to spawn actors.
  prefs: []
  type: TYPE_NORMAL
- en: Spawning Actors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 1*, *Unreal Engine Introduction*, you learned how to place an actor
    that you created in the level through the editor, but what if you wanted to place
    that actor in the level as the game is being played? That's what we're going to
    be taking a look atÂ now.
  prefs: []
  type: TYPE_NORMAL
- en: 'UE4, much like most other game development tools, allows you to place an actor
    in the game while the game itself is running. This process is called `SpawnActor`
    function, available from the `World` object (which we can access using the `GetWorld`
    function, as mentioned previously). However, the `SpawnActor` function has a few
    parameters that need to be passed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A `UClass*` property, which lets the function know the class of the object that
    will be spawned. This property can be a C++ class, available through the `NameOfC++Class::StaticClass()`
    function, or a Blueprint class, available through the `TSubclassOf` property.
    It is generally a good practice not to spawn actors from a C++ class directly,
    but to create a Blueprint class and spawn an instance of that instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `TSubclassOf` property is a way for you to reference a Blueprint class in
    C++. It's used for referencing a class in C++ code, which might be a Blueprint
    class. You declare a `TSubclassOf` property with a template parameter, which is
    the C++ class that class must inherit from. We will be taking a look at how to
    use this property in practice in the next exercise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Either an `FTransform` property or the `FVector` and `FRotator` properties,
    which will indicate the location, rotation, and scale of the object we want toÂ spawn.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional `FActorSpawnParameters` property, which allows you to specify more
    properties specific to the spawning process, such as who caused the actor to spawn
    (that is, the `Instigator`), how to handle the object spawning if the location
    that it spawns at is being occupied by other objects, which may cause an overlap
    or a block event, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `SpawnActor` function will return an instance to the actor that was spawned
    from this function. Given that it is also a template function, you can call it
    in such a way that you receive a reference to the type of actor you spawned directly
    using a template parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `SpawnActor` function is being called, where we're spawning
    an instance of the `NameOfC++Class` class. Here, we provide a reference to the
    class with the `ClassReference` property and the location and rotation of the
    actor to be spawned using the `SpawnLocation` and `SpawnRotation` properties,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: You will learn how to apply these properties in *Exercise 6.03*, *Adding Projectile-Throwing
    Logic to the EnemyCharacter*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we continue to the exercise, though, I''d like to briefly mention a
    variation of the `SpawnActor` function that may also come in handy: the `SpawnActorDeferred`
    function. While the `SpawnActor` function will create an instance of the object
    you specify and then place it in the world, this new `SpawnActorDeferred` function
    will create an instance of the object you want, and only place it in the world
    when you call the actor''s `FinishSpawning` function.'
  prefs: []
  type: TYPE_NORMAL
- en: For instance, let's say we want to change the `InitialSpeed` of our Dodgeball
    at the moment we spawn it. If we used the `SpawnActor` function, there's a chance
    that the Dodgeball will start moving before we set its `InitialSpeed` property.
    However, by using the `SpawnActorDeferred` function, we can create an instance
    of the dodge ball, then set its `InitialSpeed` to whatever we want, and only then
    place it in the world by calling the newly created dodgeball's `FinishSpawning`
    function, whose instance is returned to us by the `SpawnActorDeferred` function.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to spawn an actor in the world, and also about the concept
    of timers, we can add the logic that's responsible for throwing dodge balls to
    our `EnemyCharacter` class, which is what we'll be doing in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.03: Adding Projectile-Throwing Logic to the EnemyCharacter'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will be adding the logic that's responsible for throwing
    the Dodgeball actor that we just created to our `EnemyCharacter` class.
  prefs: []
  type: TYPE_NORMAL
- en: Open the class's files in Visual Studio in order to get started. We will begin
    by modifying our `LookAtActor` function so that we can save the value that tells
    us whether we can see the player and use it to manage our timer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `EnemyCharacter` class''s header file, change the `LookAtActor` function''s
    return type from `void` to `bool`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Do the same in the function''s implementation, inside the class''s source file,
    while also returning `true` at the end of the `if` statement where we call the
    `CanSeeActor` function. Also, return `false` in the first `if` statement where
    we check if `TargetActor` is a `nullptr` and also at the end of the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add two `bool` properties, `bCanSeePlayer` and `bPreviousCanSeePlayer`,
    set to `protected` in your class''s header file, which will represent whether
    the player can be seen in this frame from the enemy character''s perspective and
    whether the player could be seen in the last frame, respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, go to your class''s `Tick` function implementation and set the value
    of `bCanSeePlayer` to the return value of the `LookAtActor` function. This will
    replace the previous call to the `LookAtActor` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, set the value of `bPreviousCanSeePlayer` to the value of `bCanSeePlayer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In-between the previous two lines, add an `if` statement that checks whether
    the values of `bCanSeePlayer` and `bPreviousCanSeePlayer` are different. This
    will mean that either we couldn''t see the player last frame and now we can, or
    that we could see the player last frame and now we can''t:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside this `if` statement, we want to start a timer if we can see the player
    and stop that timer if we can no longer see the player:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to start a timer, we''ll need to add the following properties to our
    class''s header file, which can all be `protected`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An `FTimerHandle` property, which is responsible for identifying which timer
    we want to start. It basically works as the identifier of a specific timer:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'A `float` property, which represents the amount of time to wait between throwing
    dodgeballs (the interval) so that we can loop the timer. We give this a default
    value of `2` seconds:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Another `float` property, which represents the initial delay before the timer
    starts looping. Let''s give it a default value of `0.5` seconds:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'A function to be called every time the timer ends, which we will create and
    call `ThrowDodgeball`. This function doesn''t return anything and doesn''t receive
    any parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Before we can call the appropriate function to start the timer, we will need
    to add an `#include` to the object responsible for that, `FTimerManager`, in our
    source file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each `World` has one Timer Manager, which can start and stop timers and access
    relevant functions related to them, such as whether they''re still active, how
    long they''re running for, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, access the current World''s Timer Manager by using the `GetWorldTimerManager`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, call the `SetTimer` function of the Timer Manager, if we can see the
    player character, in order to start the timer responsible for throwing dodge balls.
    The `SetTimer` function receives the following parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `FTimerHandle` representing the desired timer: `ThrowTimerHandle`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The object that the function to be called belongs to: `this`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function to be called, which must be specified by prefixing its name with
    `&ClassName::`, resulting in `&AEnemyCharacter::ThrowDodgeball`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The timer''s rate, or interval: `ThrowingInterval`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Whether this timer will loop: `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The delay before this timer starts looping: `ThrowingDelay`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code snippet comprises these parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If we can no longer see the player and we want to stop the timer, we can do
    so using the `ClearTimer` function. This function only needs to receive an `FTimerHandle`
    property as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The only thing left is to implement the `ThrowDodgeball` function. This function
    will be responsible for spawning a new `DodgeballProjectile` actor. In order to
    do this, we'll need a reference to the class we want to spawn, which must inherit
    from `DodgeballProjectile`, so the next thing we need to do is create the appropriate
    property using the `TSubclassOf` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `TSubclassOf` property in the `EnemyCharacter` header file, which
    can be `public`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we''ll be using the `DodgeballProjectile` class, we also need to include
    it in the `EnemyCharacter` source file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, within the `ThrowDodgeball` function''s implementation in the source
    file, start by checking if this property is a `nullptr`. If it is, we `return`
    immediately:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will be spawning a new actor from that class. Its location will be
    `40` units in front of the enemy and its rotation will be the same as the enemy.
    In order to spawn the Dodgeball in front of the enemy character, we''ll need to
    access the enemy''s `ForwardVector` property, which is a unitary `FVector` (*meaning
    that its length is 1*) that indicates the direction an actor is facing, and multiply
    it by the distance at which we want to spawn our dodgeball, which is `40`Â units:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This concludes the modifications we need to make to the `EnemyCharacter` class.
    Before we finish setting up the Blueprint of this logic, let's make a quick modification
    to our `DodgeballProjectile` class.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `DodgeballProjectile` class's source file in Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Within its `BeginPlay` event, set its `LifeSpan` to `5` seconds. This property,
    which belongs to all actors, dictates how much longer they will remain in the
    game before being destroyed. By setting our dodgeball''s `LifeSpan` to `5`Â seconds
    on its `BeginPlay` event, we are telling UE4 to destroy that object 5Â seconds
    after it''s spawned (*or, if it''s already been placed in the level, 5 seconds
    after the game starts*). We will do this so that the floor isn''t filled with
    dodge balls after a certain amount of time, which would make the game unintentionally
    difficult for the player:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve finished our C++ logic related to the `EnemyCharacter` class''s
    Dodgeball throwing logic, let''s compile our changes, open the editor, and then
    open our `BP_EnemyCharacter` Blueprint. There, head to the `Class Defaults` panel
    and change the `DodgeballClass` property''s value to `BP_DodgeballProjectile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16: Updating the Dodgeball Class'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_06_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.16: Updating the Dodgeball Class'
  prefs: []
  type: TYPE_NORMAL
- en: After you've done this, you can remove the existing instance of the `BP_DodgeballProjectile`
    class we had placed in our level, if it's still there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can play our level. You''ll notice that the enemy will almost immediately
    start throwing dodge balls at the player and will continue to do so as long as
    the player character is in view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.17: Enemy character throwing dodgeballs if the player is in sight'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_06_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.17: Enemy character throwing dodgeballs if the player is in sight'
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have concluded our dodge ball-throwing logic for the `EnemyCharacter`.
    You now know how to use timers, an essential tool for any gameÂ programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Walls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step in our project is going to be creating the `Wall` classes. We
    will have two types of walls:'
  prefs: []
  type: TYPE_NORMAL
- en: A normal wall, which will block the enemy's line of sight, the player character,
    and the dodge ball.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A ghost wall, which will only block the player character, and ignore the enemy's
    line of sight and the dodge ball. You might find this type of collision setup
    in specific types of puzzle games.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll create both these Wall classes in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.04: Creating Wall Classes'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will be creating the `Wall` classes that represent both
    a normal `Wall` and a `GhostWall`, which will only block the player character's
    movement, but not the enemies' lines of sight or the dodge balls they throw.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the normal `Wall` class. This C++ class will basically be empty
    because the only thing that it'll need is a mesh in order to reflect the projectiles
    and block the enemies' lines of sight, which will be added through its Blueprint
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the top-left corner of the Content Browser, press the green `Add New` button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the first option at the top; `Add Feature or Content Pack`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A new window will show up. Select the `Content Packs` tab, then select the `Starter
    Content` pack and then press the `Add To Project` button. This will add some basic
    assets to the project, which we'll use in this chapter and some of the following
    chapters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ class, called `Wall`, with the `Actor` class as its parent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, open the class''s files in Visual Studio and add a `SceneComponent` as
    our Wall''s `RootComponent`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `Header` file will be as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Source` file will be as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Compile your code and open the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, go to the `Content` > `ThirdPersonCPP` >:`Blueprints` directory inside
    the Content Browser, create a new Blueprint class that inherits from the `Wall`
    class, name it `BP_Wall`, and open that asset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Static Mesh Component and set its `StaticMesh` property to `Wall_400x300`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its `Material` property to `M_Metal_Steel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the Static Mesh Component''s location on the *X* axis to `â€“200` units (*so
    that the mesh is centered relative to our actor''s origin*):![Figure 6.18: Updating
    the Static Mesh Component''s location'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_06_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.18: Updating the Static Mesh Component''s location'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what your Blueprint class''s Viewport should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.19: Blueprint class''s Viewport Wall'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_06_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.19: Blueprint class''s Viewport Wall'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is generally good practice to add a `SceneComponent` as an object's `RootComponent`,
    when a collision component isn't necessary, in order to allow for more flexibility
    with its child components.
  prefs: []
  type: TYPE_NORMAL
- en: An actor's `RootComponent` cannot have its location or rotation modified, which
    is why, in our case, if we had created a Static Mesh Component in the Wall C++
    class and set that as its Root Component, instead of using a Scene Component,
    we'd have a hard time offsetting it.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've set up the regular `Wall` class, let's create our `GhostWall`
    class. Because these classes don't have any logic set up, we're just going to
    create the `GhostWall` class as a child of the `BP_Wall` Blueprint class and not
    our C++ class.
  prefs: []
  type: TYPE_NORMAL
- en: '*Right-click* the `BP_Wall` asset and select `Create Child BlueprintÂ Class`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new Blueprint `BP_GhostWall`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the Static Mesh Component''s Collision properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its `CollisionPreset` to `Custom`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change its response to both the `EnemySight` and `Dodgeball` channels toÂ `Overlap`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the Static Mesh Component's `Material` property to `M_Metal_Copper`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your `BP_GhostWall`''s Viewport should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.20: Creating the Ghost Wall'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_06_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.20: Creating the Ghost Wall'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you''ve created both these Wall actors, place each in the level to
    test them. Set their transforms to the following transform values:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Wall: `Location`: `(-710, 120, 130)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ghost Wall: `Location`: `(-910, -100, 130)`; `Rotation`: `(0, 0, 90)`:![Figure
    6.21: Updating the Ghost Wall''s locations and rotation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '](img/B16183_06_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.21: Updating the Ghost Wall''s locations and rotation'
  prefs: []
  type: TYPE_NORMAL
- en: 'The final outcome should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.22: Final outcome with the Ghost Wall and the Wall'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_06_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.22: Final outcome with the Ghost Wall and the Wall'
  prefs: []
  type: TYPE_NORMAL
- en: You'll notice that when you hide your character behind the normal `Wall` (the
    one on the right), the enemy won't throw dodgeballs at the player; however, when
    you try to hide your character behind the `GhostWall` (the one on the left), even
    though the enemy can't go through it, the enemy will throw dodgeballs at the character
    and they will pass through the Wall as if it wasn't there!
  prefs: []
  type: TYPE_NORMAL
- en: And that concludes our exercise. We have made our `Wall` actors, which will
    either behave normally or ignore the enemies' lines of sight and dodgeballs!
  prefs: []
  type: TYPE_NORMAL
- en: Victory Box
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step in our project is going to be creating the `VictoryBox` actor.
    This actor will be responsible for ending the game when the player character enters
    it, given that the player has beaten the level. In order to do this, we'll be
    using the `Overlap` event. The following exercise will help us understand Victory
    Box.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.05: Creating the VictoryBox class'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will be creating the `VictoryBox` class, which, when entered
    by the player character, will end the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new C++ class that inherits from the actor and call it `VictoryBox`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open that class's files in Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new `SceneComponent` property, which will be used as a `RootComponent`,
    just like we did with our `Wall` C++ class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Header` file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`Source` file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a `BoxComponent` in the header file that will check for overlap events
    with the player character, which should also be `private`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Include the `BoxComponent` file in the class''s source file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating the `RootScene` Component, create the `BoxComponent`, which
    should also be `private`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Attach it to the `RootComponent` using the `SetupAttachment` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Set its `BoxExtent` property to `60` units on all axes. This will cause the
    `BoxComponent` to be double that size `(120 x 120 x 120)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Offset its relative position on the *Z* axis by `120` units using the `SetRelativeLocation`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you will require a function that will listen to the `BoxComponent`''s
    `OnBeginOverlap` event. This event will be called whenever an object enters the
    `BoxComponent`. This function must be preceded by the `UFUNCTION` macro, be `public`,
    return nothing, and have the following parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameters are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UPrimitiveComponent* OverlappedComp`: The component that was overlapped and
    belongs to this actor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AActor* OtherActor`: The other actor involved in the overlap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UPrimitiveComponent* OtherComp`: The component that was overlapped and belongs
    to the other actor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int32 OtherBodyIndex`: The index of the item in the primitive that was hit
    (usually useful for Instanced Static Mesh components).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool bFromSweep`: Whether the overlap originated from a Sweep Trace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FHitResult& SweepResult`: The data of the Sweep Trace resulting from the collision
    between this object and the other object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we won''t be using the `OnEndOverlap` event in this project, you will
    most likely need to use it sooner or later, so here''s the required function signature
    for that event, which looks very similar to the one we just learnedÂ about:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UFUNCTION()`'
  prefs: []
  type: TYPE_NORMAL
- en: '`void OnEndOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor,
    UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to bind this function to the `BoxComponent`''s `OnComponentBeginOverlap`
    event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Within our `OnBeginOverlap` function implementation, we''re going to check
    whether the actor we overlapped is a `DodgeballCharacter`. Because we''ll be referencing
    this class, we also need to include it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: If the actor we overlapped is a `DodgeballCharacter`, we want to quit theÂ game.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use `KismetSystemLibrary` for this purpose. The `KismetSystemLibrary`
    class contains useful functions for general use in your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to quit the game, we will call `KismetSystemLibrary`''s `QuitGame`
    function. This function receives the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The important parameters from the preceding code snippet are explained asÂ follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A `World` object, which we can access with the `GetWorld` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `PlayerController` object, which we will set to `nullptr`. We're doing this
    because this function will automatically find one this way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `EQuitPreference` object, which means the way in which we want to end the
    game, by either quitting or just putting it as a background process. We will want
    to actually quit the game, and not just put it as a background process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `bool`, which indicates whether we want to ignore the platform's restrictions
    when it comes to quitting the game, which we will set to `true`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we're going to create our Blueprint class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile your changes, open the editor, go to the `Content` â†’ `ThirdPersonCPP`
    â†’ `Blueprint` directory inside the `Content Browser`, create a new Blueprint class
    that inherits from `VictoryBox`, and name it `BP_VictoryBox`. Open that asset
    and make the following modifications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new Static Mesh Component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set its `StaticMesh` property to `Floor_400x400`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set its `Material` property to `M_Metal_Gold`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set its scale to `0.75` units on all three axes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set its location to `(-150, -150, 20)`, on the *X*, *Y*, and *Z* axes, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After you''ve made those changes, your Blueprint''s Viewport tab should look
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.23: Victory box placed in the Blueprint''s Viewport tab'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_06_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.23: Victory box placed in the Blueprint''s Viewport tab'
  prefs: []
  type: TYPE_NORMAL
- en: 'Place that Blueprint in your level to test its functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.24: Victory Box blueprint in the level for testing'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_06_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.24: Victory Box blueprint in the level for testing'
  prefs: []
  type: TYPE_NORMAL
- en: If you play the level and step onto the golden plate (and overlap the collision
    box), you'll notice that the game abruptly ends, as intended.
  prefs: []
  type: TYPE_NORMAL
- en: And with that, we conclude our `VictoryBox` class! You now know how to use the
    overlap events in your own projects. There's a multitude of game mechanics that
    you can create using these events, so congratulations on completing this exercise.
  prefs: []
  type: TYPE_NORMAL
- en: We are now very close to reaching the end of this chapter, where we'll be completing
    a new activity, but first, we'll need to make some modifications to our `DodgeballProjectile`
    class, namely adding a getter function to its `ProjectileMovementComponent`, which
    we'll be doing in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: A getter function is a function that only returns a specific property and does
    nothing else. These functions are usually marked as inline, which means that,
    when the code compiles, a call to that function will simply be replaced with its
    content. They are also usually marked as `const`, given that they don't modify
    any of the class's properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.06: Adding the ProjectileMovementComponent Getter Function in DodgeballProjectile'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will be adding a getter function to the `DodgeballProjectile`
    class's `ProjectileMovement` property so that other classes can access it and
    modify its properties. We will be doing the same in this chapter's activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, you''ll need to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `DodgeballProjectile` class's header file in Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new `public` function called `GetProjectileMovementComponent`. This function
    will be an inline function, which in UE4''s version of C++ is replaced with the
    `FORCEINLINE` macro. The function should also return a `UProjectileMovementComponent*`
    and be a `const` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When using the `FORCEINLINE` macro for a specific function, you can't add the
    declaration of that function to the header file and its implementation to the
    source file. Both must be done simultaneously in the header file, as shown previously.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we conclude this quick exercise. Here, we have added a simple `getter`
    function to our `DodgeballProjectile` class, which we will be using in this chapter's
    activity, where we'll replace the `SpawnActor` function within the `EnemyCharacter`
    class with the `SpawnActorDeferred` function. This will allow us to safely edit
    our `DodgeballProjectile` class's properties before we spawn an instance of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 6.01: Replacing the SpawnActor Function with SpawnActorDeferred in
    EnemyCharacter'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, you will be changing the EnemyCharacter's `ThrowDodgeball`
    function in order to use the `SpawnActorDeferred` function instead of the `SpawnActor`
    function so that we can change the `DodgeballProjectile`'s `InitialSpeed` before
    spawning it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `EnemyCharacter` class's source file in Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the `ThrowDodgeball` function's implementation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because the `SpawnActorDeferred` function can't just receive a spawn location
    and rotation properties, and must instead receive an `FTransform` property, we'll
    need to create one of those before we call that function. Let's call it `SpawnTransform`
    and send the spawn rotation and location, in that order, as inputs for its constructor,
    which will be this enemy's rotation and the `SpawnLocation` property, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, update the `SpawnActor` function call into the `SpawnActorDeferred` function
    call. Instead of sending the spawn location and spawn rotation as its second and
    third parameters, replace those with the `SpawnTransform` properties we just created,
    as the second parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure you save the return value of this function call inside a `ADodgeballProjectile*`
    property called `Projectile`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After you've done this, you will have successfully created a new `DodgeballProjectile`
    object. However, we still need to change its `InitialSpeed` property and actually
    spawn it
  prefs: []
  type: TYPE_NORMAL
- en: After you've called the `SpawnActorDeferred` function, call the `Projectile`
    property's `GetProjectileMovementComponent` function, which returns its Projectile
    Movement Component, and change its `InitialSpeed` property to `2200` units.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because we'll be accessing properties belonging to the Projectile Movement Component
    inside the `EnemyCharacter` class, we'll need to include that component, just
    like we did in *Exercise 6.02*, *Adding a Projectile Movement Component to DodgeballProjectile*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After you've changed the value of the `InitialSpeed` property, the only thing
    left to do is call the `Projectile` property's `FinishSpawning` function, which
    will receive the `SpawnTransform` property we created as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After you've done this, compile your changes and open the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.25: Dodgeball thrown at the player'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_06_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.25: Dodgeball thrown at the player'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  prefs: []
  type: TYPE_NORMAL
- en: By completing this activity, you've consolidated the use of the `SpawnActorDeferred`
    function and know how to use it in your future projects.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you've learned how to affect an object with physics simulations,
    create your own Object Types and Collision Presets, use the `OnHit`, `OnBeginOverlap`,
    and `OnEndOverlap` events, update an object's Physical Material, and use timers.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you've learned these fundamental concepts of collision topics, you'll
    be able to come up with new and creative ways to use them when creating your own
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll be taking a look at Actor Components, Interfaces,
    and Blueprint Function Libraries, which are very useful for keeping your project's
    complexity manageable and highly modular, thereby allowing you to easily take
    parts of one project and add them to another.
  prefs: []
  type: TYPE_NORMAL
