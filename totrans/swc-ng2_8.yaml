- en: Chapter 8. Development Experience and Server-Side Rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are already familiar with all the core concepts of Angular 2\. We know how
    to develop a component-based user interface, taking advantage of all the building
    blocks that the framework provides—directives, components, dependency injections,
    pipes, forms, and the brand new component-based router.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the next step, we''ll look at where to begin when we want to build a **single-page
    application** (**SPA**) from scratch. This chapter describes how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use Web Workers for performance-sensitive applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build SEO-friendly applications with server-side rendering.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bootstrap a project as quickly as possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhance our experience as developers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's begin!
  prefs: []
  type: TYPE_NORMAL
- en: Running applications in Web Workers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When talking about performance in the context of frontend web development, we
    can either mean network, computational, or rendering performance. In this section,
    we'll concentrate on rendering and computational performance.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's make a parallel between a web application and a video, and between
    a browser and a video player. The biggest difference between the web application
    running in the browser and the video file playing in the video player is that
    the web page needs to be generated dynamically, in contrast to the video which
    has been recorded, encoded, and distributed. However, in both the cases, the user
    of the application sees a sequence of frames; the core difference is how these
    frames are being generated. In the world of video processing, when we play a video,
    we have it already recorded; it is the responsibility of the video decoder to
    extract the individual frames based on the compression algorithm. In contrast
    to this, on the Web, JavaScript, and CSS are in charge of producing frames, rendered
    by the browser's rendering engine.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of the browser, we can think of each frame as a snapshot of the
    web page at a given moment. The different frames are rendered fast one after another,
    so in theory, the end user of the application should see them smoothly incorporated
    together, just like a video played in a video player.
  prefs: []
  type: TYPE_NORMAL
- en: On the Web, we are trying to reach 60 fps (frames per second), which means that
    each frame has about 16 ms to be computed and rendered on the screen. This duration
    includes the time required by the browser to make all the necessary calculations
    for the layout and the rendering of the page, and also the time that our JavaScript
    needs to execute.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, we have less than 16 ms (because of the browser rendering functionality
    that takes time depending on the calculations it needs to perform) for our JavaScript
    to finish execution. If it doesn't fit in this duration, the frame rate will drop
    by half. Since JavaScript is a single-threaded language, all the calculations
    need to happen in the main UI thread that, in the case of computationally-intensive
    applications (such as image or video processing, marshaling and unmarshaling big
    JSON strings, and so on), can lead to very poor user experience because of the
    frames being dropped.
  prefs: []
  type: TYPE_NORMAL
- en: HTML5 introduced an API called **Web Workers**, which allows the execution of
    client-side code in the browser environment into multiple threads. For simplicity,
    the standard doesn't allow shared memory between individual threads, but instead
    allows communication with message passing. The messages exchanged between Web
    Workers and the main UI thread must be strings, which often requires the serialization
    and deserialization of JSON strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lack of shared memory between the individual workers, and the workers and
    the main UI thread brings a couple of limitations, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Disabled access to the DOM by the worker threads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Global variables cannot be shared among the individual computational units (that
    is, worker threads and main UI threads and vice versa).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web Workers and Angular 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because of the platform agnostic design of Angular 2, the core team decided
    to take advantage of this API, and during the summer of 2015, Google embedded
    Web Workers support into the framework. This feature allows most of the Angular
    2 applications to be run on a separate thread, making the main UI thread responsible
    only for rendering. This helps us achieve the goal of 60 fps much easily than
    running the entire application in a single thread.
  prefs: []
  type: TYPE_NORMAL
- en: The Web Workers support is not enabled by default. When enabling it, we need
    to keep something in mind—in a Web Workers-ready application, the components are
    not going to be run in the main UI thread, which does not allow us to directly
    manipulate the DOM. In this case, we need to use bindings, such as inputs, outputs,
    and a combination of both with `NgModel`.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping an application running in Web Worker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's make the to-do application that we developed in [Chapter 4](part0040_split_000.html#164MG1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 4. Getting Started with Angular 2 Components and Directives"), *Getting
    Started with Angular 2 Components and Directives* work in Web Workers. You can
    find the example that we'll explore at `ch8/ts/todo_webworkers/`.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, let's discuss the changes that we need to make. Take a look at
    `ch4/ts/inputs-outputs/app.ts`. Notice that inside of `app.ts`, we included the
    `bootstrap` function from the `angular2/platform/browser` module. This is the
    first thing we need to modify! The `bootstrap` process of an application running
    in a background process is different.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before refactoring our code, let''s take a look at a diagram that illustrates
    the `bootstrap` process of a typical Angular 2 application running in Web Workers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bootstrapping an application running in Web Worker](../images/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '*Jason Teplitz*, who implemented the Web Worker support in Angular 2, presented
    this diagram during his talk on *AngularConnect 2015*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The diagram has two parts: **UI** and **Web Worker**. UI shows the actions
    performed during initialization in the main UI thread; the **Web Worker** part
    of the diagram shows how the application gets bootstrapped in the background thread.
    Now, let''s explain the `bootstrap` process step by step.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the user opens the `index.html` page, which triggers the download of
    the following two files:'
  prefs: []
  type: TYPE_NORMAL
- en: The UI bundle of Angular 2 used for applications running in Web Worker.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `system.js` bundle (we talked about the global object System in [Chapter
    3](part0027_split_000.html#PNV61-a118c4c18dd64e8ab73e171b466b6582 "Chapter 3. TypeScript
    Crash Course"), *TypeScript Crash Course*. We can think of the `system.js` bundle
    as a polyfill for the module loader).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `system.js`, we download the script used for the initialization of the
    part of the application running in the main UI thread. This script starts `loader.js`
    in Web Worker. This is the first script that is running in a background thread.
    Once the worker is started, `loader.js` will download `system.js` and the bundle
    of Angular 2, which is meant to be run in the background thread. The first request
    will usually hit the cache because `system.js` is already requested by the main
    thread. Using the module loader, we download the script that is responsible for
    bootstrapping the background app `background_bootstrap.js`, which will finally
    start the functionality of our application in the background.
  prefs: []
  type: TYPE_NORMAL
- en: From now on, the entire application that we built will be run in Web Worker
    and will exchange messages with the main UI thread for responding to user events
    and rendering instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are aware of the basic flow of events during initialization when
    using workers, let's refactor our to-do application to take advantage of them.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating an application to Web Worker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inside of `index.html`, we need to add the following scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we've included references to `system.js`, `angular2-polyfills`
    that includes `zone.js` and the others used by Angular libraries, and `ui.dev.js`
    which is the bundle that needs to be run in the main UI thread.
  prefs: []
  type: TYPE_NORMAL
- en: Right after this, we will configure `system.js` by setting the `baseURL` property
    of the module loader. For the next step, we will explicitly import the `bootstrap.js`
    file, which contains the logic used for starting the `loader.js` script in Web
    Worker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore `bootstrap.js`, which is the original of the transpiled `bootstrap.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this file, we set the platform to the type `WORKER_RENDER_PLATFORM` and the
    application type to `WORKER_RENDER_APPLICATION`. We configured the provider used
    for injecting the `WORKER_SCRIPT` token to use the value `'loader.js'`. As we
    said, `loader.js` is going to run in a background thread. The script is located
    in the application's root.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can move to the right of the diagram given in the *Bootstrapping an
    application running in a Web Worker* section. The logic in `loader.js` is quite
    simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As the first step, we import `system.js`, the Web Workers bundle of Angular
    2 (`worker.dev.js`), and all the required `polyfills`. Then, we configure the
    background instance of the module loader and import the `background_app` file,
    which contains the logic of our application as well as the Web Workers bootstrap
    call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s explore how we bootstrap the application inside Web Worker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Just like in the bootstrap in the main UI thread, we specify the type of the
    platform and the type of the application that we want to bootstrap. In the final
    step, we set the root component just like we did in the standard bootstrap process.
    The `TodoApp` component is defined between the imports and the initialization
    calls in the `background_app` file.
  prefs: []
  type: TYPE_NORMAL
- en: Making an application compatible with Web Workers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we said, the code that runs in the context of Web Worker does not have access
    to the DOM. Let's see what changes we need to make in order to address this limitation.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the original implementation of the `InputBox` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that inside the template, we named the input element `todoInput` and
    used its reference within the expression set as the handler of the click event.
    This code will not be able to run in Web Worker, since we directly access a DOM
    element inside the template. In order to take care of this, we need to refactor
    the snippet, so it uses Angular 2 bindings instead of directly touching any elements.
    We can either use inputs when a single direction binding makes sense or `NgModel`
    for achieving two-way data-binding, which is more computationally-intensive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use `NgModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this version of the `InputBox` component, we will create a two-way data-binding
    between the input element and the input property of the `InputBox` component.
    Once the user clicks on the button, the `emitText` method will be invoked, which
    will trigger a new event emitted by `inputText EventEmitter`. In order to reset
    the value of the input element, we take advantage of the two-way data-binding
    that we declared and set the value of the input property to the empty string.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Moving the entire logic from the templates of the components to their controllers
    brings a lot of benefits, such as improved testability, maintainability, code
    reuse, and clarity.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code is compatible with the Web Workers environment, since the
    `NgModel` directive is based on an abstraction that does not manipulate the DOM
    directly, but instead, under the hood, exchanges messages asynchronously with
    the main UI thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'To recap, we can say that while running applications in the context of Web
    Workers, we need to keep the following two things in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to use a different bootstrap process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should not access the DOM directly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Typical scenarios that violate the second point are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Changing the DOM of the page by selecting an element and manipulating it directly
    with the browser's native APIs or a third-party library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing native elements injected by using `ElementRef`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a reference to an element in the template and passing it as an argument
    to methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directly manipulating an element referenced within the template.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In all these scenarios, we need to use the APIs provided by Angular. If we build
    our applications according to this practice, we will benefit not only from being
    able to run them in Web Workers, but also from increasing the code reuse in case
    we want to use them across different platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping this in mind will allow us to take advantage of server-side rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Initial load of a single-page application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore what server-side rendering is, why we need
    it in our applications, and how we can use it with Angular 2.
  prefs: []
  type: TYPE_NORMAL
- en: For our purposes, we'll explain the typical flow of events when a user opens
    a SPA implemented in Angular 2\. First, we'll trace the events with the server-side
    rendering disabled, and after that, we'll see how we can benefit from this feature
    by enabling it. Our example will be illustrated in the context of HTTP 1.1.
  prefs: []
  type: TYPE_NORMAL
- en: '![Initial load of a single-page application](../images/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This image shows the first request by the browser and the corresponding server's
    response when loading a typical SPA. The result that the client will see initially
    is the initial content of the HTML page without any rendered components.
  prefs: []
  type: TYPE_NORMAL
- en: Let's suppose that we deploy the to-do application we built in [Chapter 4](part0040_split_000.html#164MG1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 4. Getting Started with Angular 2 Components and Directives"), *Getting
    Started with Angular 2 Components and Directives* to a web server that has the
    `https://example.com` domain associated with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the user navigates to `https://example.com/`, the browser will open a
    new HTTP `GET` request, fetching the root resource (`/`). When the server receives
    the request, it will respond with an HTML file that, in our case, will look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The browser will receive this content as the body of the response. When the
    markup is rendered onto the screen, all that the user will see is the label: **Loading…**.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, the browser will find all the references in the HTML file's
    external resources, such as styles and scripts, and start downloading them. In
    our case, some of them are `bootstrap.css`, `es6-shim.min.js`, `Reflect.js`, `system.src.js`,
    and `angular2-polyfills.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Once all the referenced resources are available, there still won't be any significant
    visual progress for the user (except if the styles from the downloaded `CSS` file
    are applied to the page). This won't change until the JavaScript virtual machine
    processes all the referenced scripts related to the application's implementation.
    At this point, Angular will know which component needs to be rendered based on
    the current URL and bootstrap's configuration.
  prefs: []
  type: TYPE_NORMAL
- en: If the component associated with the page is defined in a separate file outside
    of our main application bundle, the framework will need to download it together
    with its entire dependency graph. In case the template and the styles of the component
    are externalized, Angular will need to download them as well before it is able
    to render the requested page.
  prefs: []
  type: TYPE_NORMAL
- en: Right after this, the framework will be able to compile the template associated
    with the target component and render the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous scenario, there are the following two main pitfalls:'
  prefs: []
  type: TYPE_NORMAL
- en: Search engines are not that good at indexing dynamic content generated by JavaScript.
    This means that the **SEO** (**Search Engine Optimization**) of our SPA will suffer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In case of large applications and/or poor Internet connection, the user experience
    will be poor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the past, we solved the SEO issue in the applications built with AngularJS
    1.x with different workarounds, such as using headless browser for rendering the
    requested page, caching it onto the disk, and later providing it to search engines.
    However, there's a more elegant solution.
  prefs: []
  type: TYPE_NORMAL
- en: Initial load of a SPA with server-side rendering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A couple of years ago, libraries such as `Rendr`, `Derby`, `Meteor`, and the
    others introduced the concept of isomorphic JavaScript applications, which were
    later renamed to universal. In essence, universal applications could be run on
    the client as well as on the server. Such portability is only possible in the
    case of low coupling between the SPA and the browser's APIs. The greatest benefit
    of this paradigm is that the application can be rerendered on the server and later
    sent to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Universal applications are not framework-specific; we can take advantage of
    them in any framework that can be run outside of the environment of the browser.
    Conceptually, the practice of server-side rendering is very similar across platforms
    and libraries; only its implementation details may differ. For instance, the Angular
    2 Universal module, which implements server-side rendering, has support for node.js
    as well as ASP.NET that, at the moment of this writing, is still work in progress.
  prefs: []
  type: TYPE_NORMAL
- en: '![Initial load of a SPA with server-side rendering](../images/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding image shows the response by the server to the initial browser
    `GET` request. This time, in contrast to the typical scenario of loading a SPA,
    the browser will get the rendered content of the HTML page.
  prefs: []
  type: TYPE_NORMAL
- en: Let's trace the flow of the events in the same application with the server-side
    rendering feature enabled. In this case, once the server receives the HTTP `GET`
    request by the browser, it will run the SPA on the server in the node.js environment.
    All the DOM calls are going to be redirected to a server-side DOM implementation
    and be executed in the context of the used platform. Similarly, all the AJAX calls
    with the `http` module will be handled by the server-side implementation of the
    module. This way, the application will not make any difference, whether it is
    running in the context of the browser or the server.
  prefs: []
  type: TYPE_NORMAL
- en: Once the rendered version of the SPA is available, it can be serialized to HTML
    and sent to the browser. This time, during the application's initialization, instead
    of the **Loading…** label, the user will see the page they requested right away.
  prefs: []
  type: TYPE_NORMAL
- en: Note that at this point, the client will have the rendered version of the application,
    but all the referenced external resources, such as scripts and styles, still need
    to be available. This means that, initially, none of the CSS styles declared in
    the external files will be applied and the application will not be responsive
    to any user-related interactions, such as the mouse and keyboard events.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that in case the scripts are inlined into the server-side rendered page,
    the application will be responsive to user events. However, inlining big chunks
    of JavaScript is generally considered as a bad practice, since it will increase
    the page's size dramatically and prevent the scripts from caching. Both will influence
    the network performance.
  prefs: []
  type: TYPE_NORMAL
- en: When the JavaScript virtual machine processes the JavaScript associated with
    the page, our SPA will be ready to use.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side rendering with Angular 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the first half of 2015, Patrick Stapleton and Jeff Whelpley announced that
    they started the development of the module, **Universal**. Universal is a library
    that allows us to build universal (also called **isomorphic**) JavaScript applications
    with Angular 2; in other words, it provides server-side rendering support.
  prefs: []
  type: TYPE_NORMAL
- en: Applications built with Angular 2 and Universal will not be responsive until
    all the JavaScript belonging to the requested page is processed. This is a drawback
    that we already mentioned, which is valid for all the server-side rendered applications.
    However, Patrick and Jeff introduced **preboot.js**, which is a lightweight library
    that will be inlined on the page rendered by the server and available after the
    initial client request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Preboot.js has several strategies for the management of the received client
    events before the application has been completely initialized. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Record and play back events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Respond immediately to events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintain focus when a page is rerendered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buffer client-side re-rendering for smoother transition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Freeze page until the bootstrap is complete if a user clicks on a button.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the moment of this writing, the Universal module is still being actively
    developed. However, you can give it a try using the Angular 2 universal starter
    at [https://github.com/angular/universal-starter](https://github.com/angular/universal-starter).
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing our development experience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our experience as developers can be enhanced in terms of productivity or by
    allowing us to have more fun while working on our projects. This can be achieved
    with all the tools, IDEs, text editors, and more that we use on a daily basis.
    In this section, we'll briefly take a look at popular IDEs and text editors that
    we can use for taking advantage of the static code analysis features that Angular
    2 provides.
  prefs: []
  type: TYPE_NORMAL
- en: In the second part of this section, we'll see what hot reloading is and how
    we can take advantage of it during the development of Angular 2 applications.
  prefs: []
  type: TYPE_NORMAL
- en: Text editors and IDEs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we already mentioned at the beginning of the book, the core team put great
    effort into enhancing the tooling support in Angular 2\. First of all, the framework
    is built with TypeScript, which naturally allows us to use static typing during
    our development process. Some of the text editors and IDEs that have great TypeScript
    support are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**IntelliJ Idea**: A general-purpose IDE by JetBrains.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WebStorm**: An IDE specialized for web development by JetBrains.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VSCode**: A cross-platform text editor written in TypeScript and developed
    by Microsoft.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sublime Text**: A cross-platform text editor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Atom**: A cross-platform text editor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recently, JetBrains announced advanced Angular 2 support in IntelliJ Idea and
    WebStorm, which supports autocompletion for components and bindings.
  prefs: []
  type: TYPE_NORMAL
- en: Although not all the mentioned IDEs and text editors have Angular 2-specific
    support at the moment of this writing, Angular 2 comes with a great design. It
    allows us to perform advanced static code analysis on the application's codebase
    for the development of sophisticated refactoring and productivity tools in the
    near future. Until then, Angular 2 at least provides tooling support as good any
    other JavaScript framework in the market.
  prefs: []
  type: TYPE_NORMAL
- en: Hot reloading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hot reloading (or hot loading) is a practice that got popular in the world of
    purely functional user interfaces in libraries such as Om (used with ClojureScript)
    and React.
  prefs: []
  type: TYPE_NORMAL
- en: 'When developing a SPA, it is quite annoying to refresh your browser after each
    small change of a style, view, or even a component. That''s why a couple of years
    ago, a tool was developed called **livereload**. Livereload watches the files
    of our application, and when it detects a change in any of them, it sends a message
    to the browser to refresh the page. Usually, the connection established between
    the livereload server and the client is through WebSockets, since the server needs
    to send push notifications. Although this tool works great in some cases, it has
    one big disadvantage: once the page is refreshed, all of the state collected during
    the developer''s interaction will be lost.'
  prefs: []
  type: TYPE_NORMAL
- en: For instance, imagine a scenario where you're working on an application with
    a complex view. You navigate through a few pages, fill in forms, and set the values
    to input fields, and then, unexpectedly, you find an issue. You go to your text
    editor or IDE and fix the issue; the livereload server detects a change in your
    project's root and sends a notification to the browser in order to refresh the
    page. Now, you're back to the initial state of the application and you need to
    go through all these steps in order to reach the same point before the refresh.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to livereloading, in most cases, hot reloading can eliminate the
    state lost. Let's take a brief look at how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical implementation of a hot reloader has two main modules: a client and
    a server. In contrast to the server in livereloading, the hot reloader server
    not only watches the file system for changes, but also takes the content of the
    changed file and sends it to the browser. Once the browser receives the message
    sent by the server, it can swap the previous implementation of the changed unit
    with the new one. After this, the view affected by the change can be rerendered
    in order to visually reflect the change. Since the application doesn''t lose its
    state, we can continue from the point we''ve reached with the new version of the
    changed code unit.'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, it is not always possible to dynamically swap the implementations
    of all your components using this strategy. If you update a piece of code that
    holds that holds application state, you may need to refresh the page manually.
  prefs: []
  type: TYPE_NORMAL
- en: Hot reloading in Angular 2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of writing, there is a working prototype of Angular 2 hot reloader
    that can be tested with the angular2-seed described in the *Angular 2 quick starters*
    section. The project is in active development, so there are a lot of improvements
    on the roadmap. But it already provides its core functionality, which can ease
    the development experience significantly.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping a project with angular-cli
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During AngularConnect 2015, Brad Green and Igor Minar, part of the Angular team,
    announced `angular-cli`—a CLI (command-line interface) tool to ease starting and
    managing Angular 2 applications. For those who have used Ruby on Rails, the idea
    behind the CLI tool might be familiar. The basic purpose of the tool is to allow
    the quick bootstrapping of new projects and scaffolding of new directives, components,
    pipes, and services.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, the tool is still in the early stage of development,
    so we'll demonstrate only its basic usage.
  prefs: []
  type: TYPE_NORMAL
- en: Using angular-cli
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to install the CLI tool, run the following command in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Right after this, the global `ng` command will appear in your `$PATH`. For
    creating a new Angular 2 project, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding commands will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Angular 2 project and install all of its node.js dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enter your project's directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start a development web server that will let you open the application you just
    created in your web browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For further reading, take a look at the project's repository located at [https://github.com/angular/angular-cli](https://github.com/angular/angular-cli).
  prefs: []
  type: TYPE_NORMAL
- en: Angular 2 quick starters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although Angular 2 CLI is going to be amazing, at the moment of this writing,
    it is still at a very early stage of development. It's build-tool agnostic, which
    means that it doesn't provide any build system. Luckily, there are a lot of starter
    projects developed by the community that can provide a great starting point for
    our next Angular 2 project.
  prefs: []
  type: TYPE_NORMAL
- en: Angular 2 seed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In case you enjoy Gulp and static typing, you can give a try to the angular2-seed
    project. It is hosted on GitHub at the following URL: [https://github.com/mgechev/angular2-seed](https://github.com/mgechev/angular2-seed).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Angular 2 seed provides the following key features:'
  prefs: []
  type: TYPE_NORMAL
- en: Advanced, ready-to-go, easy-to-extend, modular, and statically typed build system
    using Gulp.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Production and development builds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sample unit tests with Jasmine and Karma.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: End-to-end tests with Protractor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A development server with Livereload.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experimental hot reloading support.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following the best practices for your applications' and files' organization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manager for the TypeScript-related type definitions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code distributed with the book is based on this seed project.
  prefs: []
  type: TYPE_NORMAL
- en: 'For angular2-seed, you need to have node.js, npm, and Git installed, and you
    need to run the following list of commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: After you run these commands, your browser will be automatically opened with
    the home page of the seed. On the change of any of the TypeScript files, the code
    will be automatically transpiled to JavaScript and your browser will be refreshed.
  prefs: []
  type: TYPE_NORMAL
- en: The production build is configurable, but by default, it produces a single bundle
    that contains a minified version of the application and all the referenced libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Angular 2 Webpack starter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you prefer declarative and minimalistic builds with Webpack, you can use
    *angular2-webpack-starter*. It is a starter project developed by *AngularClass*
    and hosted on GitHub. You can find it at the following URL: [https://github.com/AngularClass/angular2-webpack-starter](https://github.com/AngularClass/angular2-webpack-starter).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This starter provides the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: The best practices in file and application organization for Angular 2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ready-to-go build system using Webpack for working with TypeScript.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing Angular 2 code with Jasmine and Karma.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coverage with Istanbul and Karma.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: End-to-end Angular 2 code using Protractor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type manager with Typings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to give it a try, you need to have node.js, npm, and git installed,
    and you need to run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this book by introducing the reasons behind the development of Angular
    2, which was followed by a conceptual overview that gave us a general idea about
    the building blocks that the framework provides for application development. In
    the next step, we did a TypeScript crash course that prepared us for [Chapter
    4](part0040_split_000.html#164MG1-a118c4c18dd64e8ab73e171b466b6582 "Chapter 4. Getting
    Started with Angular 2 Components and Directives"), *Getting Started with Angular
    2 Components and Directives* where we went deep into Angular's directives, components,
    and change detection.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](part0056_split_000.html#1LCVG1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 5. Dependency Injection in Angular 2"), *Dependency Injection in Angular
    2* we explained the dependency injection mechanism and saw how we can manage the
    relations between the different components by using it. The next chapters explained
    to us how we can build forms and pipes, and take advantage of Angular 2's component-based
    router.
  prefs: []
  type: TYPE_NORMAL
- en: By completing the current chapter, we finished our journey into the framework.
    At the moment of this writing, the design decisions and the ideas behind Angular
    2's core are solid and finalized. Although the framework is still brand new, in
    the past couple of months its ecosystem reached a level that we can develop production-ready,
    high-performance, SEO-friendly applications, and on top of this, have a great
    development experience exploiting static typing and hot reloading.
  prefs: []
  type: TYPE_NORMAL
