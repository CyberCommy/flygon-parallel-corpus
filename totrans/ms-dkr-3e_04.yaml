- en: Managing Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been concentrating on how to build, store, and distribute our
    Docker images. Now we are going to look at how we can launch containers, and also
    how we can use the Docker command-line client to manage and interact with them.
  prefs: []
  type: TYPE_NORMAL
- en: We will be revisiting the commands we used in the first chapter by going into
    a lot more detail, before delving deeper into the commands that are available.
    Once we are familiar with the container commands, we will look at Docker networks
    and Docker volumes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker container commands:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with your containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logs and process information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource limits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container states and miscellaneous commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker networking and volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will continue to use our local Docker installation. As before,
    the screenshots in this chapter will be from my preferred operating system, macOS, but the Docker
    commands we will be running will work on all three of the operating systems on
    which we have installed Docker so far; however, some of the supporting commands,
    which will be few and far between, may be applicable only to macOS and Linux-based
    operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2yupP3n](http://bit.ly/2yupP3n)'
  prefs: []
  type: TYPE_NORMAL
- en: Docker container commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive into the more complex Docker commands, let's review and go into
    a little more detail on the commands we have used in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 1](db23d482-1df4-41c2-af33-d38a98fc5a1c.xhtml), *Docker Overview*,
    we launched the most basic container of all, the `hello-world` container, using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As you may recall, this command pulls a 1.84 KB image from the Docker Hub.
    You can find the Docker Store page for the image at [https://store.docker.com/images/hello-world/](https://store.docker.com/images/hello-world/),
    and as per the following Dockerfile, it runs an executable called `hello`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `hello` executable prints the `Hello from Docker!` text to the Terminal,
    and then the process exits. As you can see from the full message text in the following
    Terminal output, the `hello` binary also lets you know exactly what steps have
    just occurred:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/60c57d8f-1e69-4387-ae4f-61328267a54a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As the process exits, our container also stops; this can be seen by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the command is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/00190aaa-8351-4217-a20a-9a5f46206da2.png)'
  prefs: []
  type: TYPE_IMG
- en: You may notice in the Terminal output that I first ran `docker container ls`
    with and without the `-a` flag—this is shorthand for `--all`, as running it without
    the flag does not show any exited containers.
  prefs: []
  type: TYPE_NORMAL
- en: We didn't have to name our container as it wasn't around long enough for us
    to care what it was called. Docker automatically assigns names for containers,
    though, and in my case, you can see that it was called `pensive_hermann`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice, throughout your use of Docker, that it comes up with some
    really interesting names for your containers if you choose to let it generate
    them for you. Although this is slightly off-topic, the code to generate the names
    can be found in `names-generator.go`. Right at the end of the source code, it
    has the following `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This means there will never be a container called `boring_wozniak` (and quite
    rightly, too).
  prefs: []
  type: TYPE_NORMAL
- en: Steve Wozniak is an inventor, electronics engineer, programmer, and entrepreneur
    who co-founded Apple Inc. with Steve Jobs. He is known as a pioneer of the personal
    computer revolution of the 70s and 80s, and is definitely not boring!
  prefs: []
  type: TYPE_NORMAL
- en: 'We can remove the container with a status of `exited` by running the following
    command, making sure that you replace the name of the container with your own
    container name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, at the end of [Chapter 1](db23d482-1df4-41c2-af33-d38a98fc5a1c.xhtml),
    *Docker Overview*, we launched a container using the official nginx image, using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you may remember, this downloads the image and runs it, mapping port `8080`
    on our host machine to port `80` on the container, and calls it `nginx-test`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/796a8134-aa46-4c0a-b133-d47ebca3ad68.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, running `docker image ls` shows us that we now have two images
    downloaded and also running. The following command shows us that we have a running
    container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following Terminal output shows that mine had been up for 5 minutes when
    I ran the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f002c3b3-9feb-4993-8137-95b09982b12c.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from our `docker container run` command, we introduced three
    flags. One of them was `-d`, which is shorthand for `--detach`. If we hadn't added
    this flag, then our container would have executed in the foreground, which means
    that our Terminal would have been frozen until we passed the process an escape
    command by pressing *Ctrl* + *C*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see this in action by running the following command to launch a second
    `nginx` container to run alongside the container we have already launched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Once launched, open a browser and go to `http://localhost:9090/`. As you load
    the page, you will notice that your page visit is printed to the screen; hitting
    refresh in your browser will display more hits, until you press *Ctrl* + *C* back
    in the Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/5f74deb2-6202-486b-b99e-542262ab4569.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Running `docker container ls -a` shows that you have two containers, one of
    which has exited:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/595d8d02-f115-4928-9bc6-689caa8046a2.png)'
  prefs: []
  type: TYPE_IMG
- en: So what happened? When we removed the detach flag, Docker connected us to the
    nginx process directly within the container, meaning that we had visibility of
    `stdin`, `stdout`, and `stderr` for that process. When we used *Ctrl* + *C*, we
    actually sent an instruction to the nginx process to terminate it. As that was
    the process that was keeping our container running, the container exited immediately
    once there was no longer a running process.
  prefs: []
  type: TYPE_NORMAL
- en: Standard input (`stdin`) is the handle that our process reads to get information
    from the end user. Standard output (`stdout`) is where the process writes normal
    information to. Standard error (`stderr`) is where the process writes error messages
    to.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing you may have noticed when we launched the `nginx-foreground` container
    is that we gave it a different name using the `--name` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is because you cannot have two containers with the same name, since Docker
    gives you the option of interacting with your containers using both the `CONTAINER
    ID` or `NAME` values. This is the reason the name generator function exists: to
    assign a random name to containers you do not wish to name yourself—and also to
    ensure that we never call Steve Wozniak boring.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The final thing to mention is that when we launched `nginx-foreground`, we
    asked Docker to map port `9090` to port `80` on the container. This was because
    we cannot assign more than one process to a port on a host machine, so if we attempted
    to launch our second container with the same port as the first, we would have
    received an error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, since we are running the container in the foreground, you may receive
    an error from the nginx process, as it failed to start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: However, you may also notice that we are mapping to port 80 on the container—why
    no error there?
  prefs: []
  type: TYPE_NORMAL
- en: Well, as explained in [Chapter 1](db23d482-1df4-41c2-af33-d38a98fc5a1c.xhtml),
    *Docker Overview*, the containers themselves are isolated resources, which means
    that we can launch as many containers as we like with port 80 remapped, and they
    will never clash with other containers; we only run into problems when we want
    to route to the exposed container port from our Docker host.
  prefs: []
  type: TYPE_NORMAL
- en: Let's keep our nginx container running for the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with your containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, our containers have been running a single process. Docker provides you
    with a few tools that enable you to both fork additional processes and interact
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: attach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first way of interacting with your running container is to `attach` to
    the running process. We still have our `nginx-test` container running, so let''s
    connect to that by running this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Opening your browser and going to `http://localhost:8080/` will print the nginx
    access logs to screen, just as when we launched the `nginx-foreground` container.
    Pressing *Ctrl* + *C* will terminate the process and return your Terminal to normal;
    however, as before, we would have terminated the process that was keeping the
    container running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/1bb4e06d-3b7a-4ff5-a240-277270cfc9f2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can start our container back up by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This will start the container back up in the detached state, meaning that it
    is running in the background again, as this was the state that the container was
    originally launched in. Going to `http://localhost:8080/` will show you the nginx
    welcome page again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s reattach to our process, but this time with an additional option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Hitting the container''s URL a few times and then pressing *Ctrl* + *C* will
    detach us from the nginx process, but this time, rather than terminating the nginx
    process, it will just return us to our Terminal, leaving the container in a detached
    state that can be seen by running `docker container ls`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a4b9322c-7f40-4ca1-8a24-86b30d727a2b.png)'
  prefs: []
  type: TYPE_IMG
- en: exec
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `attach` command is useful if you need to connect to the process your container
    is running, but what if you need something a little more interactive?
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `exec` command; this spawns a second process within the container
    that you can interact with. For example, to see the contents of the `/etc/debian_version` file, we
    can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This will spawn a second process, the cat command in this case, which prints
    the contents of `/etc/debian_version` to `stdout`. The second process will then
    terminate, leaving our container as it was before the exec command was executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/26de55e0-7fde-47c8-8d5b-304a3fe6da7e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can take this one step further by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This time, we are forking a bash process and using the `-i` and `-t` flags to
    keep open console access to our container. The `-i` flag is shorthand for `--interactive`,
    which instructs Docker to keep `stdin` open so that we can send commands to the
    process. The `-t` flag is short for `--tty` and allocates a pseudo-TTY to the
    session.
  prefs: []
  type: TYPE_NORMAL
- en: Early user terminals connected to computers were called teletypewriters. While
    these devices are no longer used today, the acronym TTY has continued to be used
    to described text-only consoles in modern computing.
  prefs: []
  type: TYPE_NORMAL
- en: 'What this means is that you will be able to interact with the container as
    if you had a remote Terminal session, like SSH:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/adc82b1e-ce80-447f-ba61-df6187947c28.png)'
  prefs: []
  type: TYPE_IMG
- en: While this is extremely useful, as you can interact with the container as if
    it were a virtual machine, I do not recommend making any changes to your containers
    as they are running using the pseudo-TTY. It is more than likely that those changes
    will not persist and will be lost when your container is removed. We will go into
    the thinking behind this in more detail in [Chapter 12](2a59899d-85fa-4a6f-960f-15f77654396d.xhtml),
    *Docker Workflows*.
  prefs: []
  type: TYPE_NORMAL
- en: Logs and process information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been attaching to either the process in our container, or the
    container itself, to view information. Docker provides a few commands to allow
    you to view information about your containers without having to use either the
    `attach` or `exec` commands.
  prefs: []
  type: TYPE_NORMAL
- en: logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `logs` command is pretty self-explanatory; it allows you to interact with
    the `stdout` stream of your containers, which Docker is keeping track of in the
    background. For example, to view the last entries written to `stdout` for our
    `nginx-test` container, you just need to use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the command is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f4d55587-638d-40a9-b254-6ea3b7dfd5ca.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To view the logs in real time, I simply need to run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-f` flag is shorthand for `--follow`. I can also, say, view everything
    that has been logged since a certain time by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the command is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/81472a8d-7d42-47f3-8992-3ef68d28d1f2.png)'
  prefs: []
  type: TYPE_IMG
- en: You might notice that, in the preceding output, the timestamp in the access
    log is 17:12, which is before 18:00\. Why is that?
  prefs: []
  type: TYPE_NORMAL
- en: 'The `logs` command shows the timestamps of `stdout` as recorded by Docker,
    and not the time within the container. You can see this when I run the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ad0e1a71-4115-41f3-9cf9-ce4611e9c86e.png)'
  prefs: []
  type: TYPE_IMG
- en: There is an hour's time difference between my host machine and the container
    due to **British Summer Time** (**BST**) being in effect on my host.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, to save confusion—or add to it, depending on how you look at it—you
    can add `-t` to your `logs` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-t` flag is short for `--timestamp`; this option prepends the time the
    output was captured by Docker:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/5adad768-d3f4-48cf-861f-2c2928badd3b.png)'
  prefs: []
  type: TYPE_IMG
- en: top
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `top` command is quite a simple one; it lists the processes running within
    the container you specify, and is used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the command is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/4a4ecf85-0897-4c4f-ae0a-0d837d554327.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the following Terminal output, we have two processes running,
    both of which are nginx, which is to be expected.
  prefs: []
  type: TYPE_NORMAL
- en: stats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `stats` command provides real-time information on either the specified
    container or, if you don''t pass a `NAME` or `ID` container, on all running containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the following Terminal output, we are given information
    on the `CPU`, `RAM`, `NETWORK`, `DISK IO`, and `PIDS` for the specified container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b65c9bb2-62b3-4d50-bfd7-6fc5586a4ad9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also pass the `-a` flag; this is short for `--all` and displays all
    containers, running or not. For example, try running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You should receive something like the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/290518ab-d015-4073-99f4-96ba471a7fd3.png)'
  prefs: []
  type: TYPE_IMG
- en: However, as you can see from the preceding output, if the container isn't running,
    there aren't any resources being utilized, so it doesn't really add any value,
    other than giving you a visual representation of how many containers you have
    running and where the resources are being used.
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth pointing out that the information displayed by the `stats`
    command is real time only; Docker does not record the resource utilization and
    make it available in the same way that the `logs` command does. We will be looking
    at more long-term storage for resource utilization in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Resource limits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last command we ran showed us the resource utilization of our containers;
    by default, when launched, a container will be allowed to consume all the available
    resources on the host machine if it requires it. We can put caps on the resources
    our containers can consume; let's start by updating the resource allowances of
    our `nginx-test` container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, we would have set the limits when we launched our container using
    the `run` command; for example, to halve the CPU priority and set a memory limit
    of `128M`, we would have used the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we didn''t launch our `nginx-test` container with any resource limits,
    meaning that we need to update our already running container; to do this, we can
    use the `update` command. Now, you may have thought that this should just entail
    running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'But actually, running the preceding command will produce an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'So what is the `memoryswap` limit currently set to? To find this out, we can
    use the `inspect` command to display all of the configuration data for our running
    container; just run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see by running the preceding command, there is a lot of configuration
    data. When I ran the command, a 199-line JSON array was returned. Let''s use the
    `grep` command to filter out just the lines that contain the word `memory`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns the following configuration data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Everything is set to `0`, so how can `128M` be smaller than `0`?
  prefs: []
  type: TYPE_NORMAL
- en: 'In the context of the configuration of the resources, `0` is actually the default
    value and means that there are no limits—notice the lack of `M` after each numerical
    value. This means that our update command should actually read the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Paging is a memory management scheme in which the kernel stores and retrieves,
    or swaps, data from secondary storage for use in the main memory. This allows
    processes to exceed the size of physical memory available.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, when you set `--memory` as part of the run command, Docker will
    set the `-- memory-swap` size to be twice that of `--memory`. If you run `docker
    container stats nginx-test` now, you should see our limits in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/77a31bee-f5aa-47fa-bc45-c87ce4e5d593.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, re-running `docker container inspect nginx-test | grep -i memory` will
    show the changes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The values when running `docker container inspect` are all shown in bytes rather
    megabytes (MB).
  prefs: []
  type: TYPE_NORMAL
- en: Container states and miscellaneous commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the final part of this section, we are going to look at the various states
    your containers could be in, along with the few remaining commands we have yet
    to cover as part of the `docker container` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `docker container ls -a` should show something similar to the following
    Terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/5772ae4a-e0c4-4b08-9eaa-6736196039a3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, we have two containers; one has the status of `Up` and the
    other has `Exited`. Before we continue, let''s launch five more containers. To
    do this quickly, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'When running `docker container ls -a`, you should see your five new containers,
    named `nginx1` through to `nginx5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/93f06e05-03cc-4a87-afa7-405edc4fc671.png)'
  prefs: []
  type: TYPE_IMG
- en: Pause and unpause
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at pausing `nginx1`. To do this, simply run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `docker container ls` will show that the container has a status of
    `Up`, but it also says `Paused`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/1d9542b7-02c5-4c7d-9c9d-2231f3be2885.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that we didn't have to use the `-a` flag to see information about the container
    as the process has not been terminated; instead, it has been suspended using the
    `cgroups` freezer. With the `cgroups` freezer, the process is unaware it has been
    suspended, meaning that it can be resumed.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you will have probably already guessed, you can resume a paused container
    using the `unpause` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This command is useful if you need to freeze the state of a container; for example,
    maybe one of your containers is going haywire and you need to do some investigation
    later, but don't want it to have a negative impact on your other running containers.
  prefs: []
  type: TYPE_NORMAL
- en: Stop, start, restart, and kill
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next up, we have the `stop`, `start`, `restart`, and `kill` commands. We have
    already used the `start` command to resume a container with a status of `Exited`.
    The `stop` command works in exactly the same way as when we used *Ctrl* + *C*
    to detach from your container running in the foreground. Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: With this, a request is sent to the process for it to terminate, called a `SIGTERM`.
    If the process has not terminated itself within a grace period, then a kill signal,
    called a `SIGKILL`, is sent. This will immediately terminate the process, not
    giving it any time to finish whatever is causing the delay; for example, committing
    the results of a database query to disk.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because this could be bad, Docker gives you the option of overriding the default
    grace period, which is `10` seconds, by using the `-t` flag; this is short for
    `--time`. For example, running the following command will wait up to `60` seconds
    before sending a `SIGKILL`, in the event that it needs to be sent to kill the
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `start` command, as we have already seen, will start the process back up;
    however, unlike the `pause` and `unpause` commands, the process, in this case,
    starts from scratch using the flags that  originally launched it, rather than
    starting from where it left off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `restart` command is a combination of the following two commands; it stops
    and then starts the `ID` or `NAME` container you pass it. Also, as with `stop`,
    you can pass the `-t` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you also have the option of sending a `SIGKILL` command immediately
    to the container by running the `kill` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Removing containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s check the containers we have running using the `docker container ls
    -a` command. When I run the command, I can see that I have two containers with
    an `Exited` status and all of the others are running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/4bcbe8c0-ef73-4ee3-892f-736df9b751ed.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To remove the two exited containers, I can simply run the `prune` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'When doing so, a warning pops up asking you to confirm whether you are really
    sure, as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/6bf28535-d586-446d-90c9-652a5be114b0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can choose which container you want to remove using the `rm` command, an
    example of which is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Another alternative would be to string the `stop` and `rm` commands together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: However, given that you can use the `prune` command now, this is probably way
    too much effort, especially as you are trying to remove the containers and probably
    don't care too much how gracefully the process is terminated.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to remove the remainder of your containers using whichever method
    you like.
  prefs: []
  type: TYPE_NORMAL
- en: Miscellaneous commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the final part of this section, we are going to look at a few commands that
    you probably won't use too much during your day-to-day use of Docker. The first
    of these is `create`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `create` command is pretty similar to the `run` command, except that it
    does not start the container, but instead prepares and configures one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check the status of your created container by running `docker container
    ls -a`, and then starting the container with `docker container start nginx-test`,
    before checking the status again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/0ce749fe-7c8c-4322-8f83-59b00098ab61.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next command we are going to quickly look at is the `port` command; this
    displays the port along with any port mappings for the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'It should return the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We already know this, as it is what we configured. Also, the ports are listed
    in the `docker container ls` output.
  prefs: []
  type: TYPE_NORMAL
- en: The final command we are going to look at quickly is the `diff` command. This
    command prints a list of all of the files that have been added (`A`) or changed
    (`C`) since the container was started—so basically, a list of the differences
    on the filesystem between the original image we used to launch the container and
    what files are present now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we run the command, let''s create a blank file within the `nginx-test`
    container using the `exec` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a file called `testing` in `/tmp`, we can view the differences
    between the original image and the running container using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return a list of files; as you can see from the following list, our
    testing file is there, along with the files that were created when nginx started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: It is worth pointing out that once we stop and remove the container, these files
    will be lost. In the next section of this chapter, we will look at Docker volumes
    and learn how we can persist data.
  prefs: []
  type: TYPE_NORMAL
- en: Again, if you are following along, you should remove any running containers
    launched during this section using the command of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: Docker networking and volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we finish off this chapter, we are going to take a look at the basics
    of Docker networking and Docker volumes using the default drivers. Let's take
    a look at networking first.
  prefs: []
  type: TYPE_NORMAL
- en: Docker networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been launching our containers on a single flat shared network.
    Although we have not talked about it yet, this means the containers we have been
    launching would have been able to communicate with each other without having to
    use any of the host
  prefs: []
  type: TYPE_NORMAL
- en: networking.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than going into detail now, let's work through an example. We are going
    to be running a two-container application; the first container will be running
    Redis, and the second, our application, which uses the Redis container to store
    a system state.
  prefs: []
  type: TYPE_NORMAL
- en: '**Redis** is an in-memory data structure store that can be used as a database,
    cache, or message broker. It supports different levels of on-disk persistence.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we launch our application, let''s download the container images we will
    be using, and also create the network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something similar to the following Terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/437d8315-2fb0-4b30-919e-de523c2a9d8f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have our images pulled and our network created, we can launch our
    containers, starting with the Redis one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we used the `--network` flag to define the network that our
    container was launched in. Now that the Redis container is launched, we can launch
    the application container by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we launched the container into the `moby-counter` network; this time,
    we mapped port `8080` to port `80` on the container. Note that we did not need
    to worry about exposing any ports of the Redis container. That is because the
    Redis image comes with some defaults that expose the default port, which is `6379`
    for us. This can be seen by running `docker container ls`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/1b81c8f6-2b54-40c8-bccd-b2ba1cd835e8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'All that remains now is to access the application; to do this, open your browser
    and go to `http://localhost:8080/`. You should be greeted by a mostly blank page,
    with the message **Click to add logos**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/d2e7aade-e54d-49a5-8867-cd7fec245ee5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking anywhere on the page will add Docker logos, so click away:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/d32f4117-a87d-48e6-a1ac-06550232f498.png)'
  prefs: []
  type: TYPE_IMG
- en: So what is happening? The application that is being served from the moby-counter
    container is making a connection to the `redis` container, and using the service
    to store the on-screen coordinates of each of the logos that you place on the
    screen by clicking.
  prefs: []
  type: TYPE_NORMAL
- en: 'How is the moby-counter application connecting to the `redis` container? Well,
    in the `server.js` file, the following default values are being set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that the `moby-counter` application is looking to connect to a host
    called `redis` on port `6379`. Let''s try using the exec command to ping the `redis`
    container from the `moby-counter` application and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something similar to the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/4b88fe00-2244-44b4-88fe-1bd7efe6ef10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the `moby-counter` container resolves `redis` to the IP address
    of the `redis` container, which is `172.18.0.2`. You may be thinking that the
    application''s host file contains an entry for the `redis` container; let''s take
    a look using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns the contents of `/etc/hosts`, which, in my case, looks like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Other than the entry at the end, which is actually the IP address resolving
    to the hostname of the local container, `4e7931312ed2` is the ID of the container;
    there is no sign of an entry for `redis`. Next, let''s check `/etc/resolv.conf`
    by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns what we are looking for; as you can see, we are using a local
    `nameserver`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s perform a DNS lookup on `redis` against `127.0.0.11` using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns the IP address of the `redis` container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a second network and launch another application container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the second application container up and running, let''s try
    pinging the `redis` container from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In my case, I get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/fe272858-2c80-4c3d-a694-619b4c7b0046.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s check the `resolv.conf` file to see if the same nameserver is being
    used already, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the following output, the nameserver is indeed in use already:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have launched the `moby-counter2` container in a different network to
    that where the container named `redis` is running, we cannot resolve the hostname
    of the container, so it returns a bad address error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Let's look at launching a second Redis server in our second network; as we have
    already discussed, we cannot have two containers with the same name, so let's
    creatively name it `redis2`.
  prefs: []
  type: TYPE_NORMAL
- en: As our application is configured to connect to a container that resolves to
    `redis`, does this mean we will have to make changes to our application container?
    No, but Docker has you covered.
  prefs: []
  type: TYPE_NORMAL
- en: 'While you cannot have two containers with the same names, as we have already
    discovered, our second network is running completely isolated from our first network,
    meaning that we can still use the DNS name of `redis`. To do this, we need to
    add the `-- network-alias` flag as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have named the container `redis2`, but set the `--network-alias`
    to be `redis`; this means that when we perform the lookup, we see the correct
    IP address returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `redis` is actually an alias for `redis2.moby-counter2`, which
    then resolves to `172.19.0.3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we should have two applications running side by side in their own isolated
    networks on your local Docker host, accessible at `http://localhost:8080/` and
    `http://localhost:9090/`. Running `docker network ls` will display all of the
    networks configured on your Docker host, including the default networks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/028c4da4-f1c6-4714-9720-ac7eeed8307d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can find out more information about the configuration of the networks by
    running the following `inspect` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding command returns the following JSON array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it contains information on the network addressing being used
    in the IPAM section, along with details on each of the two containers running
    in the network.
  prefs: []
  type: TYPE_NORMAL
- en: '**IP address management (IPAM)** is a means of planning, tracking, and managing
    IP addresses within the network. IPAM has both DNS and DHCP services, so each
    service is notified of changes in the other. For example, DHCP assigns an address
    to `container2`. The DNS service is then updated to return the IP address assigned
    by DHCP whenever a lookup is made against `container2`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we progress to the next section, we should remove one of the applications
    and associated networks. To do this, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'This will remove the containers and network, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f90ab3a9-4e23-474b-bb23-6ca5f25a95e3.png)'
  prefs: []
  type: TYPE_IMG
- en: As mentioned at the start of this section, this is only the default network
    driver, meaning that we are restricted to our networks being available only on
    a single Docker host. In later chapters, we will look at how we can expand our
    Docker network across multiple hosts and even providers.
  prefs: []
  type: TYPE_NORMAL
- en: Docker volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have been following along with the network example from the previous
    section, you should have two containers running, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/d8736f3a-5221-4505-8f87-be8f4880a91f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When you go to the application in a browser (at `http://localhost:8080/`),
    you will probably see that there already are Docker logos on screen. Let''s stop
    and then remove the Redis container and see what happens. To do this, run the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have your browser open, you may notice that the Docker icons have faded
    into the background and there is an animated loader in the center of the screen.
    This is basically to show that the application is waiting for the connection to
    the Redis container to be re-established:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/877b5f80-6b36-4d49-be89-2f09a51aea48.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Relaunch the Redis container using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'This restores connectivity; however, when you start to interact with the application,
    your previous icons disappear and you are left with a clean slate. Quickly add
    some more logos to the screen, this time placed in a different pattern, as I have
    done here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ae34105f-21e6-4e8e-ad8d-98e7ebebdb46.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have a pattern, let''s remove the Redis container again, by running
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: As we discussed earlier in the chapter, losing the data in the container is
    to be expected. However, as we used the official Redis image, we haven't in fact
    lost any of our data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Dockerfile for the official Redis image that we used looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: If you notice, toward the end of the file, there are the `VOLUME` and `WORKDIR`
    directives declared; this means that when our container was launched, Docker actually
    created a volume and then ran `redis-server` from within the volume.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see this by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'This should show at least two volumes, as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a53d746d-cbc9-4f6d-8a9c-89758fcc9bb8.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the volume name is not very friendly at all; in fact, it is
    the unique ID of the volume. So how can we use the volume when we launch our Redis
    container?
  prefs: []
  type: TYPE_NORMAL
- en: We know from the Dockerfile that the volume was mounted at `/data` within the
    container, so all we have to do is tell Docker which volume to use and where it
    should be mounted at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, run the following command, making sure you replace the volume ID
    with that of your own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: If your application page looks like it is still trying to reconnect to the Redis
    container once you have launched your Redis container, then you may need to refresh
    your browser; failing that, restarting the application container by running `docker
    container restart moby-counter` and then refreshing your browser again should
    work.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can view the contents of the volume by running the following command to
    attach the container and list the files in `/data`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return something that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: You can also remove your running container and relaunch it, but this time using
    the ID of the second volume. As you can see from the application in your browser,
    the two different patterns you originally created are intact.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you can override the volume with your own. To create a volume, we
    need to use the `volume` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Once created, we will be able to use the `redis_data` volume to store our Redis
    by running the following command after removing the Redis container, which is
    probably already running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then reuse the volume as needed, the screen below shows the volume being
    created, attached to a container which is then removed and finally reattached
    to a new container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/587c6e86-e8de-4dca-bf50-f3e35dfe9776.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Like the `network` command, we can view more information on the volume using
    the `inspect` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will produce something like the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: You can see that there is not much to a volume when using the local driver;
    one interesting thing to note is that the path to where the data is stored on
    the Docker host machine is `/var/lib/docker/volumes/redis_data/_data`. If you
    are using Docker for Mac or Docker for Windows, then this path will be your Docker
    host virtual machine, and not your local machine, meaning that you do not have
    direct access to the data inside the volume.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t worry though; we will be looking at Docker volumes and how you can interact
    with data in later chapters. For now, we should tidy up. First of all, remove
    the two containers and network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can remove the volumes by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something similar to the following Terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/8a083f82-ac74-40d9-ad79-af59bc811b43.png)'
  prefs: []
  type: TYPE_IMG
- en: We are now back to having a clean slate, so we can progress to the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we looked at how you can use the Docker command-line client
    to both manage individual containers and launch multi-container applications in
    their own isolated Docker networks. We also discussed how we can persist data
    on the filesystem using Docker volumes. So far, in this and previous chapters,
    we have covered in detail the majority of the available commands that we will
    use in the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have covered the four main areas of using Docker locally, we can
    start to look at how to create more complex applications using Docker Compose.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a look at another core Docker tool, called
    Docker Compose.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which flag do you have to append to `docker container ls` to view all the containers,
    both running and stopped?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: the `-p 8080:80` flag will map port 80 on the container to port
    8080 on the host.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain the difference between what happens when you use *Ctrl* + *C* to exit
    a container you have attached, compared to using the attach command with `--sig-proxy=false`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: The `exec` command attaches you to the running process.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which flag would you use to add an alias to a container so that it responds
    to DNS requests, when you already have a container running with the same DNS name
    in another network?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which command would you use to find out details on a Docker volume?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find out more about some of the topics we have discussed in this chapter
    at the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: The Names Generator Code: [https://github.com/moby/moby/blob/master/pkg/namesgenerator/names-generator.go](https://github.com/moby/moby/blob/master/pkg/namesgenerator/names-generator.go)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cgroups freezer function: [https://www.kernel.org/doc/Documentation/cgroup-v1/freezer-subsystem.txt](https://www.kernel.org/doc/Documentation/cgroup-v1/freezer-subsystem.txt)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redis: [https://redis.io/](https://redis.io/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
