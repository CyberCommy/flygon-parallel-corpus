- en: Container and Cloud Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible is a very flexible automation tool and can be easily used to automate
    any aspect of your infrastructure. In the last few years, container-based workloads
    and cloud workloads have become more and more popular, and for this reason, we
    are going to look at how you can automate tasks related to those kinds of workloads
    with Ansible. In this chapter, we will start by designing and building containers
    with Ansible. We will then look at how to run those containers, and finally, we
    will look at ways to manage various cloud platforms with Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we will be covering the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing and building containers with playbooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing multiple container platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating Docker with Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring container-focused modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating against Amazon Web Services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complementing Google Cloud Platform with automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seamless automation integration to Azure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expanding your environment with Rackspace Cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Ansible to orchestrate OpenStack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter assumes that you have set up your control host with Ansible, as
    detailed in [Chapter 1](0efc8364-b8a4-4866-9ff4-1e2d09f6724b.xhtml), *Getting
    Started with Ansible*, and are using the most recent version available – the examples
    in this chapter were tested with Ansible 2.9\. Although we will give specific
    examples of hostnames in this chapter, you are free to substitute them with your
    own hostname and/or IP addresses. Details of how to do this will be provided in
    the appropriate places. This chapter also assumes you have access to a Docker
    host, and although it's possible to install Docker on the majority – if not all – operating
    systems, all the commands provided in this chapter are for GNU/Linux and have
    been tested solely on this platform.
  prefs: []
  type: TYPE_NORMAL
- en: All the examples in this chapter can be found in this book's GitHub repository
    at [https://github.com/PacktPublishing/Practical-Ansible-2/tree/master/Chapter%2010](https://github.com/PacktPublishing/Practical-Ansible-2/tree/master/Chapter%2010).
  prefs: []
  type: TYPE_NORMAL
- en: Designing and building containers with playbooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building containers with Dockerfiles is probably the most common way of doing
    this, but this does not mean that this is the best way.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, even if you are in a very good place in your automation path and
    you have a lot of Ansible roles written for your infrastructure, you can't leverage
    them in Dockerfiles, so you would end up replicating your work to create containers.
    Aside from the time required to do this and the fact that you need to learn a
    new language to do so, it is very rare that a company is able to drop all their
    infrastructure and switch to containers overnight. This means that you need to
    keep two copies of the same automation section active and up-to-date, thus putting
    yourself in the position to make mistakes and have inconsistent behaviors between
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: If this is not enough of a problem, this situation quickly deteriorates when
    you start considering cloud environments. All cloud environments have their own
    control planes and native automation languages, so in a very short time, you would
    find yourself rewriting the automation for the same operation over and over, thus
    wasting time and deteriorating the consistency of your environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible provides `ansible-container` so that you can create containers using
    the same components you would use for creating machines. The first thing you should
    do is ensure that you have `ansible-container` installed. There are a few ways
    to install it, but the most straightforward is using `pip`. To do so, you can
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ansible-container` tool comes with three supported engines at the time
    of writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker`: This is needed if you want to use it with Docker Engine (that is,
    on your local machine).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`k8s`: This is needed if you want to use it with a Kubernetes cluster, both
    local (that is, MiniKube) or remote (that is, a production cluster).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`openshift`: This is needed if you want to use it with an OpenShift cluster,
    both local (that is, MiniShift) or remote (that is, a production cluster).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Follow these steps to build the container using playbooks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Issuing the `ansible-container init` command will give us the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this command will also create the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ansible.cfg`: An empty file to be (eventually) used to override Ansible system
    configurations'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible-requirements.txt`: An empty file to (eventually) list the Python requirements
    for the building process of your containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`container.yml`: A file that contains the Ansible code for the build'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`meta.yml`: A file that contains the metadata for Ansible Galaxy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`requirements.yml`: An empty file to (eventually) list the Ansible roles that
    are required for your build'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s try building our own container using this tool – replace the contents
    of `container.yml` with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We can now run `ansible-container build` to initiate the build.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the building process, we will have a container built with the
    `geerlingguy.apache` role applied to it. The `ansible-container` tool performs
    a multi-stage build capability, spinning up an Ansible container that is then
    used to build the real container.
  prefs: []
  type: TYPE_NORMAL
- en: If we specified more than one role to be applied, the output would be an image
    with more layers, since Ansible will create a layer for every specified role.
    In this way, containers can easily be built using your existing Ansible roles
    rather than Dockerfiles.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned how to design and building containers with playbooks,
    you'll learn how to manage multiple container platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Managing multiple container platforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In today's world, simply being able to run an image is not considered a production-ready
    setup.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to call a deployment "production-ready," you need to be able to demonstrate
    that the service your application is delivering will run reasonably, even in the
    case of a single application crash, as well as hardware failure. Often, you'll
    have even more reliability constraints from your customer.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, your software is not the only data that has those requirements, so
    orchestration solutions have been developed for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Today, the most successful one is Kubernetes due to its various distributions/versions,
    so we are going to focus on it primarily.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of Kubernetes is that you inform the Kubernetes Control Plane that
    you want X number of instances of your Y application, and Kubernetes will count
    how many instances of the Y application are running on the Kubernetes Nodes to
    ensure that the number of instances are X. If there are too few instances, Kubernetes
    will take care to start more instances, while if there are too many instances,
    the exceeding instances will be stopped.
  prefs: []
  type: TYPE_NORMAL
- en: Since Kubernetes constantly checks that the requested amount of instances are
    running, in the case of an application failure or a node failure, Kubernetes will
    restart the lost instances.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the complexity of installing and managing Kubernetes, multiple companies
    have started to sell distributions of Kubernetes that simplify their operations
    and that they are willing to support.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most widely used distribution by far, at the moment, is OpenShift: the
    Red Hat Kubernetes distribution.'
  prefs: []
  type: TYPE_NORMAL
- en: To simplify the life of the developers and operation teams, Ansible provides
    `ansible-container`, which, as we saw in the previous section, is a tool that's
    used to create containers, as well as to support the whole life cycle of the container
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to Kubernetes with ansible-container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's learn how to run the image we just built with `ansible-container`.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we need the image itself, and you should have it since this is
    the output of the previous section!
  prefs: []
  type: TYPE_NORMAL
- en: 'We will assume that you have access to either a Kubernetes or OpenShift cluster
    for testing. Setting these up is out the scope of this book, so you might want
    to look at a distribution such as Minikube or Minishift, both of which are designed
    to be quick and easy to set up so that you can start learning these technologies
    rapidly. We also need to have the `kubectl` client or the `oc` client, based on
    the fact that we have deployed Kubernetes or OpenShift, properly configured. Let''s
    get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To deploy your application to your cluster, you need to change the `container.yml`
    file so that you can add some additional information. More specifically, we will
    need to add a section called `settings` and a section called `k8s_namespace` to
    declare our deployment settings. This section will look something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have added the necessary information about the Kubernetes deployment,
    we can proceed with the deployment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As soon as Ansible has completed its execution, you will be able to find the
    `http-server` deployment on your Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: What happens behind the scenes is that Ansible has a set of modules (whose name
    usually starts with `k8s`) that are used to drive a Kubernetes cluster, and it
    uses them to deploy the application automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Based on the image that we built in the previous section and the additional
    information we added at the beginning of this section, Ansible is able to populate
    a deployment template and then deploy it using the `k8s` module.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned how to deploy your container on a Kubernetes cluster,
    you'll learn how to interact with the Kubernetes cluster with Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Kubernetes objects with Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have deployed your first application with `ansible-container`,
    it would be useful to interact with this application. It can come in handy to
    obtain information around the state of your Kubernetes objects or to deploy an
    application to it, and more generally, to interact with the Kubernetes APIs without
    `ansible-containers`.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Ansible Kubernetes dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First of all, you need to install the Python `openshift` package (you can install
    it either via pip or via your OS packaging system).
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready for our first Kubernetes playbook!
  prefs: []
  type: TYPE_NORMAL
- en: Listing Kubernetes namespaces with Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Kubernetes cluster has multiple namespaces internally, and you can usually
    find the ones a cluster has with `kubectl get namespaces`. You can do the same
    with Ansible by creating a file called `k8s-ns-show.yaml` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now execute this, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You will now see information regarding the namespaces in the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that in the seventh line of the code (`kind: Namespace`), we are specifying
    the type of resources we are interested in. You can specify other Kubernetes object
    types to see them (for example, you can try this with Deployments, Services, and
    Pods).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Kubernetes namespace with Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have learned how to show existing namespaces, but usually, Ansible
    is used in a declarative way to achieve a desired state. So, let''s create a new
    playbook called `k8s-ns.yaml` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Before running it, we can execute `kubectl get ns` so that we can ensure `myns`
    is not present. In my case, the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now run the playbook with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should resemble the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, Ansible reports that it changed the namespace state. If I execute
    `kubectl get ns` again, is clear that Ansible created the namespace we were expecting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's create a Service.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Kubernetes Service with Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have seen how to create namespaces from Ansible, so now, let''s
    put a Service in the namespace we just created. Let''s create a new playbook called
    `k8s-svc.yaml` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Before running it, we can execute `kubectl get svc` to ensure that the namespace
    has no Services. Make sure you''re in the right namespace before running it! In
    my case, the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now run it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should resemble the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, Ansible reports that it changed the Service state. If I execute
    `kubectl get svc` again, is clear that Ansible created the Service we were expecting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we followed the same procedure that we used in the namespace
    case, but we specified a different Kubernetes object type and specified the various
    parameters that are needed for the Service type. You can do the same for all other
    Kubernetes object types.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned how to deal with Kubernetes clusters, you'll learn
    how to automate Docker with Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Automating Docker with Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker is now a very common and ubiquitous tool. In production, it is often
    managed by an orchestrator (or at least it should be, in the majority of cases),
    but in development, environments are often used directly.
  prefs: []
  type: TYPE_NORMAL
- en: With Ansible, you can easily manage your Docker instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are going to manage a Docker instance, we need to make sure we have
    one at hand and that the `docker` command on our machine is configured properly.
    We need to do this to ensure this is enough to run `docker images` on the Terminal.
    Let''s say you get a result similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This means that everything is working properly. More lines may be provided as
    output if you have already-cloned images.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, let''s say it returns something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This means that we don't have a Docker daemon running or that our Docker console
    has been configured incorrectly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, it''s important to ensure that you have the `docker` Python module since
    Ansible will try to use it to communicate with the Docker daemon. Let''s take
    a look:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need to create a playbook called `start-docker-container.yaml`
    that will contain the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the Ansible playbook, we just need to execute it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As you may expect, it will give you an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now check that our command executed properly, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This will show the container that was run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This proves that a container was executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check that the `echo` command was executed, we can run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we executed the `docker_container` module. This is not the
    only module Ansible has to control the Docker daemon, but it is probably one of
    the most widely used since it's used to control containers running on Docker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other modules include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker_config`: Used to change the configurations of the Docker daemon'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker_container_info`: Used to gather information from (inspect) a container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker_network`: Used to manage Docker networking configuration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also many modules that start with `docker_` but are actually used
    to manage Docker Swarm clusters, and not Docker instances. Some examples are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker_node`: Used to manage a node in a Docker Swarm cluster'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker_node_info`: Used to retrieve information about a specific node in a
    Docker Swarm cluster'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker_swarm_info`: Used to retrieve information about a Docker Swarm cluster'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we will see in the next section, there many more modules that can be used
    to manage containers that are orchestrated in various ways.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned how to automate Docker with Ansible, you will explore
    container-focused modules.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring container-focused modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, when organizations grow, they start to use multiple technologies in different
    parts of the organization. Another thing that usually happens is that after a
    department has found that a vendor worked well for them, they will be more inclined
    to try new technologies offered by this vendor. A mix of those two factors and
    time (usually, fewer technologies cycles) will end up creating multiple solutions
    for the same problem within the same organization.
  prefs: []
  type: TYPE_NORMAL
- en: If your organization is in this situation with containers, Ansible can come
    to rescue, thanks to its ability to interoperate with the majority of, if not
    all, container platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Many times, the biggest problem to do something with Ansible is finding the
    name of the modules you need to use to achieve what you want to achieve. In this
    section, we will try to help in this effort, mainly in terms of the containerization
    space, but this might help you in the quest to find different kinds of modules.
  prefs: []
  type: TYPE_NORMAL
- en: The starting point for all Ansible module research should be the Module index
    ([https://docs.ansible.com/ansible/latest/modules/modules_by_category.html](https://docs.ansible.com/ansible/latest/modules/modules_by_category.html)).
    Very often, you can find a category that is clearly a match for what you are looking
    for, but this is not always the case.
  prefs: []
  type: TYPE_NORMAL
- en: Containers are one of those exceptions (at least at the time of writing), and
    therefore there is no "containers" category. The solution is to go to All modules.
    From here, you can search by using your browser's built-in feature (usually, this
    can be reached by using *Ctrl*+*F*) to find the strings that might match the package
    name or short description.
  prefs: []
  type: TYPE_NORMAL
- en: Every module in Ansible is classified in one category, but very often, modules
    fit more than one category, so it's not always easy to find them.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, many Ansible modules relative to container Services are in the
    Cloud modules category (ECS, Docker, LXC, LXD, and Podman), while others are in
    the Clustering modules category (Kubernetes, OpenShift, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: To help you further, let's take a look at some of the main container platforms
    and the main modules Ansible provides.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon Web Services, back in 2014, launched **Elastic Container Service** (**ECS**),
    which is a way to deploy and orchestrate Docker containers within their infrastructure.
    In the following year, **Amazon Web Services** (**AWS**) also launched **Elastic
    Container Registry** (**ECR**), a managed Docker Registry service. The service
    did not become as ubiquitous as AWS hoped, so in 2018, AWS launched **Elastic
    Kubernetes Service** (**EKS**) to allow people that wanted to run Kubernetes on
    AWS to have a managed service. If you are using or plan to use EKS, this is just
    a standard managed Kubernetes cluster, so you can use the Kubernetes-specific
    modules that we are going to cover shortly. If you decide to use ECS, there are
    several modules that can help you. The most important ones are `ecs_cluster`,
    which allows you to create or terminate ECS clusters; `ecs_ecr`, which allows
    you to manage ECR; `ecs_service`, which allows you to create, terminate, start,
    or stop a service in ECS; and `ecs_task`, which allows you to run, start, or stop
    a task in ECS. In addition to those, there are `ecs_service_facts` that allow
    Ansible to list or describe services in ECS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Microsoft Azure, in 2018, announced **Azure Container Service** (**ACS**),
    and then announced **Azure Kubernetes Service** (**AKS**). These services are
    managed by Kubernetes solutions, so they can both be managed with the Kubernetes
    modules. In addition to those, Ansible provided two specific modules: the `azure_rm_acs`
    module allows us to create, update, and delete Azure Container Service instances,
    while the `azure_rm_aks` module allows us to create, update, and delete Azure
    Kubernetes Service instances.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Google Cloud launched **Google Kubernetes Engine** (**GKE**) in 2015\. GKE
    is the Google Cloud Platform version of managed Kubernetes, and therefore compatible
    with Ansible Kubernetes modules. In addition to those, there are various GKE-specific
    modules, some of which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`gcp_container_cluster`: Allows you to create a GCP Cluster'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gcp_container_cluster_facts`: Allows you to gather facts for a GCP Cluster'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gcp_container_node_pool`: Allows you to create a GCP NodePool'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gcp_container_node_pool_facts`: Allows you to gather facts for a GCP NodePool'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Red Hat started OpenShift in 2011, and at the time, it was based on its own
    container runtime. In version 3, which was released in 2015, it was completely
    rebased on Kubernetes, so all Ansible Kubernetes modules work. In addition to
    those, there is the `oc` module, which is currently still present but in a deprecated
    state, giving preference to the Kubernetes modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'In 2015, Google released Kubernetes and quickly, a huge community started to
    build around it. Ansible allows you to manage your Kubernetes clusters with some
    modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`k8s`: Allows you to manage any kind of Kubernetes object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`k8s_auth`: Allows you to authenticate to Kubernetes clusters that require
    an explicit login step'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`k8s_facts`: Allows you to inspect Kubernetes objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`k8s_scale`: Allows you to set a new size for a Deployment, ReplicaSet, Replication
    Controller, or Job'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`k8s_service`: Allows you to manage Services on Kubernetes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'LXC and LXD are also systems that can be used to run containers in Linux. These
    systems are also supported by Ansible, thanks to the following modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lxc_container`: Allows you to manage LXC containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lxd_container`: Allows you to manage LXD containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lxd_profile`: Allows you to manage LXD profiles'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you have learned how to explore container-focused modules, you'll learn
    how to automate against Amazon Web Services.
  prefs: []
  type: TYPE_NORMAL
- en: Automating against Amazon Web Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many organizations, cloud providers are being used widely, while in others,
    they are just being introduced. However, in one way or the other, you will probably
    have to deal with some cloud provider doing your job. AWS is the biggest and the
    oldest, and is perhaps something you will have to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to use Ansible to automate your Amazon Web Service estate, you''ll
    need to install the `boto` library. To do so, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have all the necessary software installed, you can set up authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `boto` library looks up the necessary credentials in the `~/.aws/credentials`
    file. There are two different ways to ensure that the credentials file is configured
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to use the AWS CLI tool. Alternatively, this can be done with
    a text editor of your choice by creating a file with the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now that you've created the file with the necessary credentials, `boto` will
    be able to work against your AWS environment. Since Ansible uses `boto` for every
    single communication with AWS systems, this means that Ansible will be appropriately
    configured, even without you have to change any Ansible-specific configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that Ansible is able to connect to your AWS environment, you can proceed
    with the actual playbook by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `aws.yaml` Playbook with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Run it using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will return something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: If you check AWS Console, you will see that you now have one machine up and
    running!
  prefs: []
  type: TYPE_NORMAL
- en: 'To launch a virtual machine in AWS, we need a few things to be in place, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: An SSH key pair
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A subnetwork
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A security group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, a network and a subnetwork are already available in your accounts,
    but you need to retrieve their IDs.
  prefs: []
  type: TYPE_NORMAL
- en: That's why we started by uploading the public part of an SSH keypair to AWS,
    then queried for information about the network and the subnetwork, then ensured
    that the Security Group we wanted to use was present, and lastly triggered the
    machine build.
  prefs: []
  type: TYPE_NORMAL
- en: Now you have learned how to automate against Amazon Web Services, you'll learn
    how to complement Google Cloud Platform with automation.
  prefs: []
  type: TYPE_NORMAL
- en: Complementing Google Cloud Platform with automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another global cloud provider is Google, with its Google Cloud Platform. Google's
    approach to the cloud is relatively different from other providers' since Google
    does not try to simulate the data center in a virtual environment. This is because
    Google wishes to rethink the concept of cloud provision in order to simplify it.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need to ensure that you have the proper components installed before you
    can start using Google Cloud Platform with Ansible. More specifically, you will
    require the Python `requests` and `google-auth` modules. To install these modules,
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have all the dependencies present, you can start the authentication
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two different approaches to obtain a working set of credentials in
    Google Cloud Platform:'
  prefs: []
  type: TYPE_NORMAL
- en: The Service Account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Machine Account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first approach is the suggested one in the majority of cases since the second
    applies only to circumstances where Ansible is run directly within the Google
    Cloud Platform environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have created the Service Account, you should set the following environmental
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GCP_AUTH_KIND`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GCP_SERVICE_ACCOUNT_EMAIL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GCP_SERVICE_ACCOUNT_FILE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GCP_SCOPES`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, Ansible can use the proper Service Account.
  prefs: []
  type: TYPE_NORMAL
- en: The second approach is by far the easiest since Ansible will be able to auto-detect
    the Machine Account if you are running it in a Google Cloud instance.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that Ansible is able to connect to your GCP environment, you can proceed
    with the actual Playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `gce.yaml` Playbook with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create an output like the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As for the AWS example, running a machine in the cloud is very easy with Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of GCE, you don't need to set up the networks beforehand since the
    GCE defaults will kick in and provide a functional machine either way.
  prefs: []
  type: TYPE_NORMAL
- en: As for AWS, the list of modules you can use is huge. You can find the full list
    at [https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#google](https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#google).
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned how to complement Google Cloud Platform with automation,
    you will learn how to seamlessly perform automation integration to Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Seamless automation integration to Azure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another global cloud that Ansible can manage is Microsoft Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Azure integration, like the AWS one, requires quite a few steps to be performed
    in Playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you will need to do is set up the authentication so that Ansible
    is allowed to control your Azure account.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To let Ansible manage the Azure cloud, you need to install the Azure SDK for
    Python. Do this by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have all the dependencies present, you can start the authentication
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are different ways to ensure that Ansible is able to manage Azure for
    you, based on the way your Azure account is set up, but they can all be configured
    in the `~/.azure/credentials` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want Ansible to use the principal credentials for the Azure account,
    you will need to create a file that resembles the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If you prefer to use Active Directories with a username and password, you can
    do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, you can opt for an Active Directory login with ADFS. In this case,
    you''ll need to set some additional parameters. You''ll end up with something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The same parameters can be passed as parameters or as environmental variables
    if it makes more sense.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that Ansible is able to connect to your Azure environment, you can proceed
    with the actual Playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `azure.yaml` Playbook with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run it with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You now have your machine running in the Azure cloud!
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, in Azure, you will need all the resources to be ready before
    you can issue the machine creation command. This is the reason you create the
    Storage Account, the Virtual Network, the Subnet, the Public IP, the security
    Group, and the NIC first, and only at that point, the machine itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Outside the three major players in the market, there are many additional cloud
    options. One very interesting option is RackSpace, due to its history: Rackspace
    Cloud.'
  prefs: []
  type: TYPE_NORMAL
- en: Expanding your environment with Rackspace Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rackspace was one of the first companies in the public cloud business. Also,
    in a joint effort with NASA, Rackspace created OpenStack in 2010\. In the last
    10 years, Rackspace has been a very influential provider for the world of cloud
    infrastructure, OpenStack, and, more generally, the hosting scene.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to manage Rackspace from Ansible, you will need to install `pyrax`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to install it is by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: You can also install it via your system package manager if it's available.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since `pyrax` does not have a default location for the credentials file, you
    will need to create a file and then set an environmental variable by instructing
    `pyrax` to do this at the file's location.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a file in `~/.rackspace_credentials` with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now proceed by setting the `RAX_CREDS_FILE` variable to the right location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Let's go ahead and create a machine using Rackspace Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating a machine in Rackspace Cloud is very simple since it''s a single-step
    operation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `rax.yaml` Playbook with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can execute it with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This should result in something like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, creating machines in Rackspace Cloud is very straightforward,
    and the default Ansible module has some interesting concepts already integrated
    into it, such as group and count. Those options allow you to create and manage
    groups of instances in the same way you would do with a single instance.
  prefs: []
  type: TYPE_NORMAL
- en: Using Ansible to orchestrate OpenStack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As opposed to the various cloud services we just discussed, all of which are
    public clouds, OpenStack allows you to create your own (private) cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Private clouds have the disadvantage that they expose more complexity to the
    administrator and to the user, but this is the reason why they can be customized
    to suit an organization perfectly.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step to being able to control an OpenStack cluster with Ansible is
    to ensure that `openstacksdk` is installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install `openstacksdk`, you need to execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have installed `openstacksdk`, you can start the authentication
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Ansible will use `openstacksdk` as its backend, you will need to ensure
    that `openstacksdk` is able to connect to the OpenStack cluster.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, you can change the `~/.config/openstack/clouds.yaml` file, ensuring
    that there is a configuration for the cloud you want to use it for.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of what a correct OpenStack credentials set could look like is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: It's also possible to set a different config file location if you are willing
    to export the `OS_CLIENT_CONFIG_FILE` variable as an environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have set up the required security so that Ansible can manage your
    cluster, you can create your first Playbook.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since OpenStack is very flexible, many of its components can have many different
    implementations, which means they may differ slightly in terms of their behavior.
    To be able to accommodate all the various cases, the Ansible modules that manage
    OpenStack tend to have a lower level of abstraction compared to the ones for many
    public clouds.
  prefs: []
  type: TYPE_NORMAL
- en: So, to create a machine, you will need to ensure that the public SSH key is
    known to OpenStack and ensure that the OS image is present as well. After doing
    this, you can set up networks, subnetworks, and routers to ensure that the machine
    we are going to create can communicate via the network. Then, you can create the
    security group and its rules so that the machine can receive connections (pings
    and SSH traffic, in this case). Finally, you can create a machine instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete all the steps we''ve just described, you need to create a file
    called `openstack.yaml` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can run it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this process was longer than the public cloud ones we covered.
    However, you did get to upload the image that you wanted to run, which is something
    many clouds do not allow (or allow with very complex processes).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to automate tasks, from designing and building
    containers with playbooks to managing the deployment on Kubernetes, as well as
    managing Kubernetes objects and automating Docker with Ansible. You also explored
    the modules that can help you automate cloud environments, such as AWS, Google
    Cloud Platform, Azure, Rackspace, and OpenShift. You also learned about the different
    approaches various cloud providers use, including their defaults and the parameters
    that you will always need to add.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an understanding of how Ansible interacts with the clouds,
    you can immediately start to automate your cloud workflows. Also, remember to
    check the documentation in the *Further reading* section to take a look at all
    the cloud modules that Ansible supports and their options.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to troubleshoot and create testing strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which of the following is NOT a GKE Ansible module?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) `gcp_container_cluster`
  prefs: []
  type: TYPE_NORMAL
- en: B) `gcp_container_node_pool`
  prefs: []
  type: TYPE_NORMAL
- en: C) `gcp_container_node_pool_facts`
  prefs: []
  type: TYPE_NORMAL
- en: D) `gcp_container_node_pool_count`
  prefs: []
  type: TYPE_NORMAL
- en: E) `gcp_container_cluster_facts`
  prefs: []
  type: TYPE_NORMAL
- en: 'True or False: In order to manage containers in Kubernetes, you need to add
    `k8s_namespace` in the settings section.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) True
  prefs: []
  type: TYPE_NORMAL
- en: B) False
  prefs: []
  type: TYPE_NORMAL
- en: 'True or False: When working with Azure, you don''t need to create a **Network
    Interface Controller** (**NIC**) before creating an instance.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) True
  prefs: []
  type: TYPE_NORMAL
- en: B) False
  prefs: []
  type: TYPE_NORMAL
- en: 'True or False: `Ansible-Container` is the only way to interact with Kubernetes
    and Doc.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) True
  prefs: []
  type: TYPE_NORMAL
- en: B) False
  prefs: []
  type: TYPE_NORMAL
- en: 'True or False: When working with AWS, it''s necessary to create a Security
    Group before creating an EC2 instance.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) True
  prefs: []
  type: TYPE_NORMAL
- en: B) False
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More AWS modules: [https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#amazon](https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#amazon)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More Azure modules: [https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#azure](https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#azure)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More Docker modules: [https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#docker](https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#docker)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More GCP modules: [https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#google](https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#google)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More OpenStack modules: [https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#openstack](https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#openstack)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More Rackspace modules: [https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#rackspace](https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#rackspace)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
