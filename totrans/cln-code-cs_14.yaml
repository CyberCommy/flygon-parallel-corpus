- en: Refactoring C# Code – Implementing Design Patterns
  prefs: []
  type: TYPE_NORMAL
- en: Half the battle in programming clean code is in the correct implementation and
    usage of design patterns. Design patterns themselves can become code smells. A
    design pattern becomes a code smell when it is used to over-engineer something
    that is rather simple to implement.
  prefs: []
  type: TYPE_NORMAL
- en: You have already seen the use of design patterns in writing clean code and refactoring
    code smells in the previous chapters of this book. Specifically, we have implemented
    the adapter pattern, the decorator pattern, and the proxy pattern. These patterns
    were implemented in the right way to accomplish the task at hand. They were kept
    simple and they most certainly did not complicate the code. So, when used for
    their proper purpose, design patterns are really useful in removing code smells,
    thus leaving your code nice, clean, and fresh.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will address the **Gang of Four (GoF)** creational, structural,
    and behavioral design patterns. Design patterns are not set in stone and you don't
    have to be strict in their implementation. But having code samples can help you
    transition from just having head knowledge to having the practical skills needed
    to correctly implement and use design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing creational design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing structural design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of behavioral design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will have the following skills:'
  prefs: []
  type: TYPE_NORMAL
- en: The ability to understand, describe, and program different creational design
    patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to understand, describe, and program different structural design
    patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An understanding of an overview of behavioral design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will begin our overview of GoF design patterns by addressing creational design
    patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual Studio 2019
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Visual Studio 2019 .NET Framework console application as your working project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The complete source code for this chapter: [https://github.com/PacktPublishing/Clean-Code-in-C-/tree/master/CH14/CH14_DesignPatterns](https://github.com/PacktPublishing/Clean-Code-in-C-/tree/master/CH14/CH14_DesignPatterns)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing creational design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From a programmer''s perspective, we use creational design patterns when we
    perform object creation. Patterns are selected based on the task at hand. There
    are five creational design patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Singleton**: The singleton pattern ensures that only one instance of an object
    will exist at the application level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Factory method**: A factory pattern is used to create objects without using
    the class to be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Abstract factory**: Without the specification of their concrete classes,
    groups of related or dependent objects are instantiated by the abstract factory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prototype**: Specifies the type of prototype to create, and then creates
    copies of the prototype.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Builder**: Separates object construction from its representation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will now begin implementing each of these patterns, starting with the singleton
    design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the singleton pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The singleton design pattern only allows one instance of a class with global
    access to it. Use the singleton pattern when all operations within a system must
    be coordinated by exactly one object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94e2597c-471b-48e0-ae30-ec3f69fa8d9c.png)'
  prefs: []
  type: TYPE_IMG
- en: The participant in this pattern is **s****ingleton**—a class that is responsible
    for managing its own instance and ensures that there is only one instance of itself
    running in the entire system.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now going to implement the singleton design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a folder called `Singleton` to the `CreationalDesignPatterns` folder. Then,
    add a class called `Singleton`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Singleton` class stores a static copy of an instance of itself. You cannot
    instantiate the class because the constructor is marked as protected. The `Instance()`
    method is static. It checks to see whether an instance of the `Singleton` class
    exists. If it does, then it is returned. If it does not exist, then the instance
    is created and returned. Now, we''ll add the code to call it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We declare two instances of the `Singleton` class, and then compare them to
    see whether they are the same instance. You can see the output in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/691d45a9-3c14-4bd6-8f99-46e4e9f5c5e3.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we have a working class that implements the singleton design
    pattern. Next up, we'll tackle the factory method design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the factory method pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The factory method design pattern creates objects that let their subclasses
    implement their own object creation logic. Use this design pattern when you want
    to keep object instantiation in a single place and need to generate a specific
    group of related objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/93b0c1b5-6908-4e09-b537-4d396424bf78.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The participants in this project are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Product`**:** The abstract product created by the factory method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcreteProduct`: Inherits the abstract product'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Creator`: An abstract class with an abstract factory method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Concrete Creator`**:** Inherits the abstract creator and overrides the factory
    method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will now implement the factory method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a folder to the `CreationalDesignPatterns` folder called `FactoryMethod`.
    Then, add the `Product` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Product` class defines the objects that are created by the factory method.
    Add the `ConcreteProduct` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ConcreteProduct` class inherits the `Product` class. Add the `Creator` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Creator` class will be inherited by the `ConcreteFactory` class, which
    will implement `FactoryMethod()`. Add the `ConcreteCreator` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ConcreteCreator` class inherits the `Creator` class and overrides the `FactoryMethod()`.
    A new `ConcreteProduct` class is returned by the method. The following code demonstrates
    the factory method in use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We have created a new instance of the `ConcreteCreator` class. Then, we called
    the `FactoryMethod()` to create a new product. The name of the product created
    by the factory method is then output to the console window, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/daa493a5-07aa-4d8f-8e20-a97708956825.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we know how to implement the factory method design pattern, we will
    move on to implementing the abstract factory design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the abstract factory pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Without the specification of their concrete classes, groups of related or dependent objects, referred
    to as families, are instantiated using the abstract factory design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d57e611f-4941-4627-abfb-f991728fed2f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The participants in this pattern are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AbstractFactory`: The abstract factory, which is implemented by concrete factories'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcreteFactory`: Creates concrete products'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AbstractProduct`: The abstract product that concrete products will inherit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Product`: Inherits `AbstractProduct` and is created by the concrete factory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will now start implementing the pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a folder to the project called `CreationalDesignPatterns`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a folder to the `CreationalDesignPatterns` folder called `AbstractFactory`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `AbstractFactory` folder, add the `AbstractFactory` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`AbstractFactory` contains two abstract methods for creating abstract products.
    Add the `AbstractProductA` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AbstractProductA` class has a single abstract method, which performs an
    operation on `AbstractProductB`. Now, add the `AbstractProductB` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AbstractProductB` class has a single abstract method, which performs an
    operation on `AbstractProductA`. Add the `ProductA` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`ProductA` inherits `AbstractProductA` and overrides the `Operation()` method,
    which interacts with `AbstractProductB`. The `Operation()` method in this example
    prints out a console message. Do the same for the `ProductB` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`ProductB` inherits `AbstractProductB` and overrides the `Operation()` method,
    which interacts with `AbstractProductA`. The `Operation()` method in this example
    prints out a console message. Add the `ConcreteFactory` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`ConcreteFactory` inherits the `AbstractFactory` class and overrides the two
    product creation methods. Each method returns a concrete class. Add the `Client` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Client` class declares two abstract products. Its constructor takes an `AbstractFactory` class.
    Inside the constructor, both declared abstract products are assigned their respective
    concrete products by the factory. The `Run()` method executes `Operation()` on
    both products. The following code executes our abstract factory example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code and you will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bb3f9ac2-15db-4b09-92ce-fa278c42e5c6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A good reference implementation of the abstract factory is the ADO.NET 2.0
    `DbProviderFactory` abstract class. An article called *Abstract Factory Design
    Pattern in ADO.NET 2.0* by Moses Soliman on C# Corner is a nice write-up on `DbProviderFactory`
    about the implementation of the abstract factory design pattern. Here is the link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.c-sharpcorner.com/article/abstract-factory-design-pattern-in-ado-net-2-0/](https://www.c-sharpcorner.com/article/abstract-factory-design-pattern-in-ado-net-2-0/).'
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully implemented the abstract factory design pattern. Now, we
    will implement the prototype pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the prototype pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The prototype design pattern is used to create an instance of a prototype,
    and then to create new objects by cloning the prototype. Use this pattern when
    the cost of creating objects directly is expensive. With this pattern, you can
    cache the object and return a clone when needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a9b4467-fc5b-4ff3-9143-0f951db7651a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The participants in the prototype design pattern are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Prototype`: An abstract class that provides a method for cloning itself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcretePrototype`: Inherits the prototype and overrides the `Clone()` method
    to return a memberwise clone of the prototype'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Client`: Requests new clones of the prototype'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will now implement the prototype design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a folder called `Prototype` to the `CreationalDesignPatterns` folder, and
    then add the `Prototype` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `Prototype` class must be inherited. Its constructor requires an identifying
    string to be passed in that is stored at the class level. A `Clone()` method is
    provided, which the subclass will override. Now, add the `ConcretePrototype` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ConcretePrototype` class inherits from the `Prototype` class. Its constructor
    takes an identifying string and passes that string into the constructor of the
    base class. It then overrides the clone method to provide a shallow copy of the
    current object by calling the `MemberwiseClone()` method and returning the clone
    that is cast to the type of `Prototype`. Now for the code that demonstrates the
    prototype design pattern in use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Our code creates a new instance of the `ConcretePrototype` class with an identifier
    of `"Clone 1"`. We then clone the prototype and cast it to the `ConcretePrototype`
    type. Then, we print the clone''s identifier to the console window, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dfb6a75d-50e6-40db-b4e9-8d379bb5a8cc.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the clone has the same identifier as the prototype that it was
    cloned from.
  prefs: []
  type: TYPE_NORMAL
- en: For a very detailed article of a real-world example, refer to an excellent article
    called *Prototype Design Pattern with Real-World Scenario*, by Akshay Patel, on
    C# Corner. Here is the link: [https://www.c-sharpcorner.com/UploadFile/db2972/prototype-design-pattern-with-real-world-scenario624/](https://www.c-sharpcorner.com/UploadFile/db2972/prototype-design-pattern-with-real-world-scenario624/).
  prefs: []
  type: TYPE_NORMAL
- en: We will now implement our final creational design pattern called the builder
    design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the builder pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The builder design pattern separates the object''s construction from its representation.
    As a result, you can use the same construction method to create different representations
    of the object. Use the builder design pattern when you have a complex object that
    needs to be built up and connected in stages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/721f8a0f-4d08-4857-a7b3-68407de21f3e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The participants in the builder design pattern are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Director`: A class that receives a builder via its constructor, and then calls
    each of the build methods on the builder object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`Builder`**: An abstract class that provides abstract build methods and an
    abstract method for returning the built object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcreteBuilder`: A concrete class that inherits the `Builder` class, overrides
    the builder methods to actually build the object, and overrides the result method
    to return the fully built object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start implementing our final creational design pattern—the builder design
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding a folder called `Builder` to the `CreationalDesignPatterns`
    folder. Then, add the `Product` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In our example, the `Product` class keeps a list of parts. These parts are
    strings. The list is initialized in the constructor. Parts are added by the `Add()`
    method, and when our object is fully constructed, we can call the `PrintPartsList()`
    method to print the list of parts that make up the object to the console window.
    Now, add the `Builder` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `Builder` class will be inherited by concrete classes that will override
    its abstract methods to build the object and return it. We''ll now add the `ConcreteBuilder`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `ConcreteBuilder` class inherits the `Builder` class. The class stores
    the instance of the object to be constructed. The build methods are overridden
    and parts are added to the product via the product''s `Add()` method. The product
    is returned to the client via the `GetProduct()` method call. Add the `Director`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Director` class is a concrete class that takes a `Builder` object via
    its `Build()` method and calls the build methods on the `Builder` object to build
    the object. All we need now is the code to demonstrate the builder design pattern
    in action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a director and builder. Then, the director builds the product. The
    product is then assigned, and its parts list is printed out to the console window,
    as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/97d6673e-dcdf-4ede-8c17-06af4f20b39c.png)'
  prefs: []
  type: TYPE_IMG
- en: Everything is working as it should be.
  prefs: []
  type: TYPE_NORMAL
- en: 'In .NET Framework, the `System.Text.StringBuilder` class is an example of the
    builder design pattern in the real world. Using string concatenation with the
    plus (`+`) operator is slower than using the `StringBuilder` class when concatenating
    five or more lines. String concatenation with the `+` operator is faster than
    `StringBuilder` when you have less than five concatenation lines, but slower when
    you have more than five lines to concatenate. The reason for this is that each
    time you create a string with the `+` operator, you are recreating the string
    since strings are immutable on the heap. But `StringBuilder` allocates buffer
    space on the heap. Then, characters are written to the buffer space. For only
    a small number of lines, the `+` operator is faster because of the overhead of
    creating the buffer when using the string builder. But when there are more than
    five lines, there is a noticeable difference when using `StringBuilder`. In big
    data projects where there may be hundreds of thousands or even millions of string
    concatenations taking place, the string concatenation strategy that you decide
    to employ will either perform fast or sluggishly. Let''s create a simple demonstration.
    Create a new class called `StringConcatenation`, and then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `_startTime` variable holds the current start time of the method execution.
    The `_durationPlus` variable holds the duration of the method execution as the
    number of ticks when using the `+` operator to concatenate, and `_durationSb`
    holds the duration of the operation as the number of ticks for the `StringBuilder`
    concatenation. Add the `UsingThePlusOperator()` method to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UsingThePlusOperator()` method demonstrates the time taken when concatenating
    10,000 strings using the `+` operator. The time taken to process the string concatenation
    is stored as the number of ticks fired. There are 10,000 ticks per millisecond.
    Now, add the `UsingTheStringBuilder()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is the same as the previous one, except we perform string concatenation
    using the `StringBuilder` class. We''ll now add the code to print out the time
    difference, called `PrintTimeDifference()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PrintTimeDifference()` method calculates the time difference by subtracting
    the `StringBuilder` ticks from the `+` ticks. The difference in ticks is then
    printed to the console, followed by a line that translates the ticks into seconds.
    Here is the code to test our methods so that we can see the time difference in
    the two concatenation methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the code, you will see the times and time difference in the console
    window, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b2cac85-45bb-4abf-a951-4d54785decff.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the screenshot, `StringBuilder` is much faster. With small
    amounts of data, you don't really see a difference with the naked eye. But the
    difference is noticeable to the naked eye when the data lines being processed
    greatly increase in number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example that comes to mind for using the builder pattern is report
    construction. If you consider banded reports, the bands are essentially sections
    that need to be built up from various sources. So, you could have the main part,
    and then each subreport as a different part. The final report would be the amalgamation
    of these various parts. So, you could have code like the following to build a
    report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are creating a new report. We start by adding the header. Then, we
    add last year's sales figures, combined for all regions, followed by last year's
    sales figures, broken down by region. We then add a footer to the report and complete
    the process by generating the report output.
  prefs: []
  type: TYPE_NORMAL
- en: So, you've seen the default implementation of the builder pattern from the UML
    diagram. Then, you implemented string concatenation using the `StringBuilder`
    class, which helps you build strings in a performant manner. Finally, you learned
    how the builder pattern can be useful in building up the sections of a report
    and generating its output.
  prefs: []
  type: TYPE_NORMAL
- en: Well, that concludes our implementations of the creational design patterns.
    We will now move on to implementing some structural design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing structural design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As programmers, we use structural patterns to improve the overall structure
    of our code. So, when code is encountered that lacks structure and is not at its
    cleanest, we can use the patterns mentioned in this section to restructure the
    code and make it clean. There are seven structural design patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adapter**:Use this pattern to enable classes with incompatible interfaces
    to work cleanly together.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bridge**: Use this pattern to loosely couple code by decoupling an abstraction
    from its implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composite**: Use this pattern to aggregate objects and provide a uniform
    way of working with individual and object compositions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decorator**: Use this pattern to keep the interface the same while dynamically
    adding new functionality to the object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Façade**: Use this pattern to simplify larger and more complex interfaces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flyweight**:Use this pattern to conserve memory and pass shared data between
    objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Proxy**:Use this pattern between a client and an API to intercept calls between
    the client and the API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have already touched on the adapter, decorator, and proxy patterns in previous
    chapters, so they won't be covered again in this chapter. Now, we'll start implementing
    our structural design patterns, starting with the bridge pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the bridge pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We use the bridge pattern to decouple abstractions from their implementations
    so that they are not bound at compile time. Both the abstraction and implementation
    can vary without impacting the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the bridge design pattern if you require runtime binding of the implementation
    or sharing of the implementation between multiple objects, if a number of classes
    exist as a result of interface coupling and various implementations, or if there
    is a need for orthogonal class hierarchies to be mapped:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0574df48-c539-4718-9969-5c743b1edccb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The participants of the bridge design pattern are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Abstraction`: An abstract class that contains abstract operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RefinedAbstraction`: Inherits the `Abstraction` class and overrides the `Operation()`
    method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Implementor`: An abstract class with an abstract `Operation()` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcreteImplementor`: Inherits the `Implementor` class and overrides the `Operation()`
    method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will now implement the bridge design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding the `StructuralDesignPatterns` folder to the project, and then
    in that folder, add the `Bridge` folder. Then, add the `Implementor` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Implementor` class has just a single abstract method, called `Operation()`.
    Add the `Abstraction` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Abstraction` class has a protected field that holds the `Implementor`
    object, which is set via the `Implementor` property. A virtual method called `Operation()`
    calls the `Operation()` method on the implementor. Add the `RefinedAbstraction`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `RefinedAbstraction` class inherits the `Abstraction` class and overrides
    the `Operation()` method to call the `Operation()` method on the implementor.
    Now, add the `ConcreteImplementor` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ConcreteImplementor` class inherits the `Implementor` class and overrides
    the `Operation()` method to print out a message to the console. The code to run
    the bridge design pattern example is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a new `RefinedAbstraction` instance and then set its implementor
    to a new instance of `ConcreteImplementor`. Then, we call the `Operation()` method.
    The output from our example bridge implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/efd18efa-a5c2-4060-8e20-6848a4a241b0.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we successfully executed the concrete operation in the concrete
    implementor class. The next pattern we will look at is the composite design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the composite pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the composite design pattern, objects are composed of tree structures to
    represent part-whole hierarchies. This pattern enables you to treat individual
    objects and compositions of objects in a uniform manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use this pattern when you need to ignore the differences between individual
    objects and object compositions, when you need tree structures to represent hierarchies,
    and when a hierarchical structure requires generic functionality across its structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/049f16d8-1fd9-4029-98a0-6619358ea800.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The participants in the composite design pattern are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Component`: Composed objects interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Leaf`: A leaf in the composition that has no children'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Composite`: Stores child components and performs operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Client`: Manipulates compositions and leaves via the component interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It''s time to implement the composite pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new folder called `Composite` to the `StructuralDesignPatterns` class.
    Then, add the `IComponent` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IComponent` interface has a single method, which will be implemented by
    both leaves and composites. Add the `Leaf` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Leaf` class implements the `IComponent` interface. Its constructor takes
    a name and stores it, and the `PrintName()` method prints the name of the leaf
    to the console window. Add the `Composite` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Composite` class implements the `IComponent` interface in the same way
    that the leaf does. Additionally, `Composite` stores a list of components that
    are added via the `Add()` method. Its `PrintName()` method prints out its own
    name, followed by the names of each of the components in the list. Now, we''ll
    add the code to test our composite design pattern implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we create our composites and then our leaves. We then add the
    leaves to the appropriate composites. Then, we add our composites to the root
    composite. Finally, we call the root composite''s `PrintName()` method, which
    will print the root''s name, along with the names of all the components and leaves
    in the hierarchy. You can see the output, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/574321bd-979c-4a81-b744-ebd47516e20a.png)'
  prefs: []
  type: TYPE_IMG
- en: Our composite implementation is working as expected. The next pattern we will
    implement is the façade design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the façade pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The façade pattern is designed to make using API subsystems easier to use. Use
    this pattern to hide a large and complex system behind a much simpler interface
    for your clients to use. The main reason that programmers will implement this
    pattern is that the system they are having to use or work on is too complex and
    very hard to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other reasons why this pattern is employed include if too many classes are
    dependent on one another, or simply because programmers don''t have access to
    the source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0060eca7-5fe5-47b2-830c-c9c350bf01b9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The participants in the façade pattern are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Facade`: The simple interface, which acts as a *go-between* between the client
    and a more complex system of subsystems'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Subsystem Classes`: The subsystem classes, which are directly removed from
    client access and are directly accessed by the façade'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are now going to implement the façade design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a folder called `Facade` to the `StructuralDesignPatterns` folder. Then,
    add the `SubsystemOne` and `SubsystemTwo` classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'These classes have a single method that prints the class name and method name
    to the console window. Now, let''s add the `Facade` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Facade` class creates member variables for each system that it has knowledge
    of. It then provides a series of methods that will access various portions of
    each of the subsystems when requested to do so. We will add the code to test our
    implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'All we have to do is create a `Facade` variable, and then we can call the methods
    that execute method calls in the subsystems. You should see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b3286287-919d-4e74-876f-339c5ff907a8.png)'
  prefs: []
  type: TYPE_IMG
- en: Time to look at our final structural pattern called the flyweight pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the flyweight pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The flyweight design pattern is used to efficiently process a large number
    of fine-grained objects by reducing the overall object count. Use this pattern
    to increase performance and reduce the memory footprint by reducing the number
    of objects that you create:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41f36825-87f9-43d4-a806-4ce797c3c5e4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The participants in the flyweight design pattern are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Flyweight`: Provides an interface for flyweights so that they can receive
    an extrinsic state and act on it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcreteFlyweight`: A sharable object that adds storage for the intrinsic
    state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UnsharedConcreteFlyweight`: Used when flyweights don''t need to be shared'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FlyweightFactory`: Correctly manages flyweight objects and shares them properly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Client`: Maintains flyweight references and computes or stores the extrinsic
    state of flyweights'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extrinsic state** means that it is not part of the essential nature of the
    object and that it originates externally to the object. **Intrinsic state** means
    that the state belongs to the object and is essential to the object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement the flyweight design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding the `Flyweight` folder to the `StructuralDesignPatters` folder.
    Now, add the `Flyweight` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This class is abstract and contains an abstract method called `Operation()`,
    which is passed in the extrinsic state of the flyweight:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ConcreteFlyweight` class inherits the `Flyweight` class and overrides
    the `Operation()` method. The method outputs the method name and its extrinsic
    state. Now, add the `FlyweightFactory` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In our particular flyweight example, we store our flyweight objects in a *hashtable*.
    Three flyweight objects are created in our constructor. Our `GetFlyweight()` method
    returns the flyweight for the specified key from the hashtable. Now, add the client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'An extrinsic state can be anything you require it to be. In our example, we
    are using a string. We declare a new flyweight factory, add three flyweights,
    and execute the operation on each of them. Let''s add the code to test our implementation
    of the flyweight design pattern:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The code creates a new `Client` instance, and then calls the `ProcessFlyweights()`
    method. You should see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d3ff3dd7-d9c1-4bfb-a08c-110456c3d3b9.png)'
  prefs: []
  type: TYPE_IMG
- en: Well, that's it for the structural patterns. Now it is time for us to look at
    implementing behavioral design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of behavioral design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a programmer, your behavior on the team is governed by your methods of communication
    and interaction with other team members. The objects we program are no different.
    As programmers, we determine how objects will behave and communicate with other
    objects through the use of behavioral patterns. These behavioral patterns are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chain of responsibility**: A sequential pipeline of objects that process
    an incoming request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Command**: Encapsulates all the information that will be used to call a method
    at some point in time within an object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interpreter**: Provides interpretation of a given grammar.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Iterator**: Use this pattern to access an aggregate object''s elements sequentially
    without exposing its underlying representation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mediator**: Use this pattern to have objects communicate with each other
    via an intermediary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memento**: Use this pattern to capture and save the object''s state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Observer**: Use this pattern to observe and be notified of changes in the
    object state of the object being observed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State**: Use this pattern to alter the behavior of an object when its state
    changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strategy**: Use this pattern to define a catalog of encapsulated algorithms
    that are interchangeable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Template method**: Use this pattern to define an algorithm and the steps
    that can be overridden in subclasses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visitor**: Use this pattern to add new operations to existing objects without
    modifying them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Due to the constraints of this book, we don''t have enough pages left to cover
    the behavioral design patterns. With that in mind, I will direct you to the following
    books, which you can use to further your knowledge of design patterns. The first
    book is called *Design Patterns in C#: A Hands-on Guide with Real-World Examples*,
    by Vaskaring Sarcar, and published by Apress. The second book is called *Design
    Patterns in .NET: Reusable Approaches in C# and F# for Object-Oriented Software
    Design*, by Dmitri Nesteruk, also published by Apress. Published by Packt, the
    third book is called *Hands-On Design Patterns with C# and .NET Core*, by Gaurav
    Aroraa and Jeffrey Chilberto.'
  prefs: []
  type: TYPE_NORMAL
- en: Between these books, you will not only come to understand all the patterns,
    but you will also gain exposure to real-world examples, which will help you transition
    from simply having head knowledge to having the practical skills to use design
    patterns in a reusable way in your own projects.
  prefs: []
  type: TYPE_NORMAL
- en: That's it for our look at design pattern implementations. Before we summarize
    what we've learned, I'll leave you with some final thoughts on clean code and
    refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: Final thoughts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two types of software development—**brownfield development** and **greenfield
    development**. The majority of the code we work on throughout our careers will
    be brownfield development, which is the maintenance and extension of existing
    software, while greenfield development is the development, maintenance, and extension
    of new software. With greenfield software development, you are afforded the opportunity
    to write clean code from the start, and I encourage you to do just that.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that projects are properly planned before you work on them. Then,
    employ the tools available to you to develop clean code with confidence. When
    it comes to brownfield development, you are best off spending time getting to
    know the system inside out before you maintain or extend it. Unfortunately, you
    may not always be in a situation where time affords you such luxury. So, there
    may be times when you will set about writing the code you need, not realizing
    that code already exists to do the task you are implementing. Keeping the code
    that you do write clean and well-structured will make for easier refactoring later
    on in the project.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of whether the project you are working on is a brownfield or greenfield
    project, it is down to you to ensure that you follow the company procedures. They
    are there for good reasons, those reasons being harmony between the development
    team and a clean code base. When you encounter unclean code within the code base,
    you should look to refactor it immediately.
  prefs: []
  type: TYPE_NORMAL
- en: If the code is too complex to change immediately, and if too many changes across
    layers are necessary, then the change must be logged as technical debt on the
    project to be addressed at a later date after proper planning.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the day, whether you call yourself a software architect, software
    engineer, software developer, or anything else, for that matter, your bread and
    butter is your *programming skills*. Bad programming can be detrimental to your
    current position, and can even negatively impact your ability to find new positions.
    So, employ every resource you have to ensure that your current code leaves a lasting
    good impression of your level of ability. I once heard someone say the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"You are only as good as your last programming assignment!"*'
  prefs: []
  type: TYPE_NORMAL
- en: It is important when architecting systems not to be *too clever* and build overly
    complex systems. Keep the depth of inheritance of your programs to no greater
    than 1, and do your best to reduce loops through utilizing functional programming
    techniques such as LINQ.
  prefs: []
  type: TYPE_NORMAL
- en: You saw in [Chapter 13](0118b704-174c-4b2e-8f06-9238c871b559.xhtml), *Refactoring
    C# Code – Identifying Code Smells*, how LINQ is more performant than a `foreach`
    loop. Try to also reduce the complexity of your software by limiting the number
    of pathways through your computer program from the beginning to the end. Reduce
    boilerplate code by removing the boilerplate code to aspects that can be weaved
    into the code at compile time. This reduces the number of lines in your methods
    to only those lines that are the required business logic. Keep classes small and
    focused on only one responsibility. Also, keep methods to 10 lines of code or
    fewer. Classes and methods must only perform a single responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: Learn to keep the code you write simple so that it is easy to read and reason
    about. Understand the code you write. If you can easily understand your code,
    then you're fine. Now, ask yourself this: *after working on another project and
    coming back to this one, would you still understand the code with little or no
    effort?* When code is hard to understand, then it must be refactored and simplified.
  prefs: []
  type: TYPE_NORMAL
- en: Failure to do this can result in a bloated system that dies a slow and agonizing
    death. Use documentation comments to document publicly accessible code. For hidden
    code, only use succinct and meaningful comments when the code does not adequately
    make sense by itself. Use patterns for common code that would often be repeated
    so that you **Don't Repeat Yourself** (**DRY**). Indentation within Visual Studio
    2019 is automatic, but the default indentation is not the same across different
    document types. Therefore, it is a good idea to make sure all documentation types
    have the same levels of indentation. Use the standard naming recommendations as
    suggested by Microsoft.
  prefs: []
  type: TYPE_NORMAL
- en: Give yourself programming challenges to solve without copying and pasting other
    people's source code. Use benchmarking (profiling) to rewrite the same code with
    the aim of reducing processing time. Test your code often to ensure it is behaving
    and doing what it is supposed to. Finally, practice, practice, and then practice
    some more.
  prefs: []
  type: TYPE_NORMAL
- en: We all change our programming styles over time. Some programmers' code will
    deteriorate over time if they are within a team of programmers that adopts a lot
    of poor practices. Other programmers' code will improve over time if they are
    within a team of programmers that adopts a lot of best practices. Don't forget,
    just because code compiles and does what it is meant to, it does not necessarily
    mean that it is the cleanest or most performant code.
  prefs: []
  type: TYPE_NORMAL
- en: Your aim as a computer programmer is to write clean and efficient code that
    is easy to read, reason, maintain, and expand. Practice implementing TDD and BDD,
    along with the software paradigms of KISS, SOLID, YAGNI, and DRY.
  prefs: []
  type: TYPE_NORMAL
- en: Consider checking out some old code from GitHub to use as a training opportunity
    in migration of old .NET versions to new .NET versions, and refactoring the code
    to make it clean and performant, as well as adding documentation comments to produce
    API documentation for the development team. This is good practice for honing your
    personal computer programming skills. By doing this, you can often come across
    some rather clever code that you can personally learn from. Other times, it can
    be a case of wondering what the programmer was thinking at the time! But either
    way, improving your clean coding skills at every opportunity you have will only
    work toward making you a stronger and better programmer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another saying that I believe to be true in the field of programming is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"To become a true expert computer programmer, you have to push yourself beyond
    what you are currently capable of doing."'
  prefs: []
  type: TYPE_NORMAL
- en: So, no matter how expert you or your peers consider you to be, always remember
    that you can do even better. Therefore, keep pushing forward and upping your game.
    Then, when you retire, you can look back on your career with a righteous pride
    in your wonderful accomplishments as a computer programmer!
  prefs: []
  type: TYPE_NORMAL
- en: Let's now summarise what we have learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered several creational, structural, and behavioral design
    patterns. You used the knowledge that you gained in this chapter to look at legacy
    code and understand its goal. Then, you used the patterns that you learned to
    implement in this chapter to refactor existing code and make it easier to read,
    reason, maintain, and extend. By using the patterns in this book, and the many
    others that are available to you, you can refactor existing code and write clean
    code from the start.
  prefs: []
  type: TYPE_NORMAL
- en: You also used the creational design patterns to solve real-world problems and
    to improve the efficiency of your code. Use structural design patterns to improve
    the overall structure of code and improve relations between objects. Also, use
    behavioral design patterns to improve communication between objects whilst maintaining
    the decoupling of those objects.
  prefs: []
  type: TYPE_NORMAL
- en: Well, this is the end of the chapter, and I thank you for taking the time to
    read this book and work through the code examples. Remember, software should be
    a joy to work with. As such, we don't need unclean code causing problems for our
    business, its development and support teams, and for the customers of the software.
    So, think about the code you are writing, and always strive to be a better programmer
    than you are today—no matter how many years you have been in the industry. There
    is an old saying: *no matter how good you are, you can always do better*!
  prefs: []
  type: TYPE_NORMAL
- en: Let's test your knowledge on the contents of this chapter, and then I will leave
    you with some further reading. Happy clean coding in C#!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are GoF patterns and why would we use them?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain what creational design patterns are used for and list them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain what structural design patterns are used for and them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain what behavioral design patterns are used for and list them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it possible to overuse design patterns and call code smells?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Describe the singleton design pattern and when you'd use it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why would we use factory methods?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What design pattern would you use to hide the complexity of a system that is
    large and difficult to use?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you minimize memory usage and share common data between objects?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What pattern is used to decouple an abstraction from its implementation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you construct multiple representations of the same complex object?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you have an item that requires various stages of manipulation to get it into
    the required state, what pattern would you use and why?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Refactoring: Improving the Design of Existing Code*, by Martin Fowler'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Refactoring at Scale*, by Maude Lemaire'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Software Development, Design, and Coding: With Patterns, Debugging, Unit Testing,
    and Refactoring*, by John F. Dooley'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Refactoring for Software Design Smells*, by Girish Suryanarayana, Ganesh Samarthyam,
    and Tushar Sharma'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Refactoring Databases: Evolutionary Database Design*,by Scott W. Ambler and
    Pramod J. Sadalage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Refactoring to Patterns*,by Joshua Kerievsky'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C#7 and .NET Core 2.0 High Performance*, by Ovais Mehboob Ahmed Khan'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Improving Your C# Skills*,by Ovais Mehboob Ahmed Khan, John Callaway, Clayton
    Hunt, and Rod Stephens'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Patterns of Enterprise Application Architecture*, by Martin Fowler'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Working Effectively with Legacy Code*,by Michael C. Feathers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.dofactory.com/products/dofactory-net](https://www.dofactory.com/products/dofactory-net):
    C# Design Pattern Framework for RAD by dofactory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Hands-On Design Patterns with C# and .NET Core*, by Gaurav Aroraa and Jeffrey
    Chilberto'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Design Patterns Using C# and .NET Core*, by Dimitris Loukas'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Design Patterns in C#: A Hands-on Guide with Real-World Examples*, by Vaskaring
    Sarcar'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
