- en: Enterprise Application Integration and its Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During the course of this book, we've covered how to implement enterprise applications.
    These have been either large monoliths that implemented a lot of components in
    order to provide a certain set of functionality or microservice-based applications
    where the application consisted of several small services, all of which worked
    to provide a certain feature and provide output based on the business's needs
    by interacting with each other over the network.
  prefs: []
  type: TYPE_NORMAL
- en: But, in any enterprise, there's seldom a case that the application we have developed
    will be the only application that might be present. Rather, most of the time,
    the enterprise infrastructure will consist of a number of applications that have
    ...
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The follow up for this chapter does not require any special tools or presence
    of a particular software on the development system. But some knowledge about the
    functionality of middleware and enterprise service bus solutions will help in
    understanding the context of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The need for EAI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In any large enterprise, there're a number of applications that may exist to
    solve a particular problem domain. Each of these systems works to solve only one
    set of problems. Often, this kind of approach is desirable for building applications
    inside an enterprise, because now the applications can use the best available
    technology stack for solving the problems of their domain.
  prefs: []
  type: TYPE_NORMAL
- en: But to have any useful business impact come out of these applications, its often
    the case that these applications need to talk to each other through one way or
    another, so as to facilitate the exchange of data that may be present in one application
    and required by another.
  prefs: []
  type: TYPE_NORMAL
- en: But this integration of different applications is a challenging task due to
    a ...
  prefs: []
  type: TYPE_NORMAL
- en: Point-to-point integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the approaches to solve the problem is to enable point-to-point integration
    between the applications. By this, we mean that each application has a set of
    connectors that allows it to talk to another application. For every pair of applications
    that need to talk to each other, there needs to exist a separate connector that
    facilitates communication between the applications.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is completely fine when the number of applications that need to
    talk to each other is small. But as the enterprise grows, its needs also grow,
    which means commissioning new applications into the infrastructure. Now, as the
    number of applications grow, the number of connectors that are required to facilitate
    the communication between the different applications will also start growing,
    reaching a level at which the infrastructure will become just too complex to manage
    and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: To enable the integration of a large set of applications inside the enterprise,
    which may grow over the time, we may require something that is more flexible and
    that can help us to standardize the way these applications communicate with each
    other. The move to EAI is just the kind of architecture that we are looking at,
    as it aims to help us achieve these objectives. So, let's take a look now at what EAI
    has in store for us.
  prefs: []
  type: TYPE_NORMAL
- en: Moving towards EAI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we aim to standardize the way in which the different applications running
    in our infrastructure will communicate with each other, and how they will store
    the data, the EAI approach really provides us with an option that is not only
    flexible in nature but also scalable, without introducing unnecessary complexities
    into the infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: The EAI pattern provide us with a framework that consist of tools and technologies
    that help us standardize the way the communication between the different applications
    takes place. An EAI framework usually comes with the components that facilitate
    the exchange of data between the applications and their transformation from one
    format to another and act as a glue layer between the different ...
  prefs: []
  type: TYPE_NORMAL
- en: The traditional approach to EAI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the early days of EAI, the applications needed to interact with each other
    in various formats, which may include communicating some information or exchanging
    data. To facilitate this exchange, the organizations came up with a hub and spoke
    model for EAI.
  prefs: []
  type: TYPE_NORMAL
- en: In this hub and spoke model, there's a router-based middleware component and
    a concept of events. Whenever there was some change in the state of one of the
    applications, the application used to generate an event. The other applications
    subscribed to the event stream they were interested in.
  prefs: []
  type: TYPE_NORMAL
- en: Now, whenever a new event was generated, the router was responsible for the
    delivery of the event to the interested applications handling the conversion of
    data from one format into another, so that the applications could communicate
    with each other. In this kind of approach, the router became the central point
    of facilitating the integration between the different applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The router provided a lot of features, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adapters and SDK:** For the applications to communicate with the router to
    raise events, they need to have some kind of glue that facilitates the connection
    between the application and router. The adapters provided by the router middleware
    used to provide this necessary glue layer. In case there was no supported adapter
    for an application, the router middleware provided an SDK to facilitate the development
    of an adapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message transformation:** When a new event has been generated, the router,
    based on a set of some pre-defined rules, used to translate the messages associated
    with an event into a format that can then be consumed by another application.
    This kind of functionality was important to facilitate communication between two
    different applications, each of which have their own data storage formats and
    communications styles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intelligent routing:** For the applications to work seamlessly with each
    other, there needs to be a guarantee that the correct event is reaching the correct
    target audience. The router middleware used to implement intelligent routing based
    on which application generated the event and which applications are interested
    in listening to that event, so that the messages generated as a part of an event
    are delivered to the correct recipients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This kind of approach provided a nice mechanism to remove the unneeded complexity
    from the enterprise infrastructure that would have been developed if every application
    had to communicate with other applications directly, managing their own connector,
    and handling data consistency. Whereas, with this approach, the router facilitates
    the communication between the different applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, as good as this approach was with all of the benefits, it suffered from
    some of the following serious drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single point of failure:** The broker model to the EAI proved to be a single
    point of failure. In case the router middleware goes down, all communication between
    the different applications will come to a halt.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Centralized logic:** The logic for the transformation of the data, along
    with the routing of the data, was all centrally located inside a single router.
    This caused the broker to become a complex component making the operations and
    maintenance of the broker a difficult task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Poor scalability:** When the load on the router increases, the handling of
    the messages by the router can take a hit. This results in an inconsistent state
    of data between the different applications. Also, having a single, centrally located
    router becomes a hurdle in the geographical scalability of the router if the applications
    that are trying to connect to each other are located in the different geographies
    around the world.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Proprietary solutions:** In the earlier days, when the router-based hub and
    spoke approach of integrating enterprise applications was there, most of the solutions
    used to be proprietary in nature and supporting only a subset of vendors. To get
    some application from an unsupported vendor integration, it was a huge problem
    for the developers, who would then need to write and maintain their own adapters
    based on the provided SDK.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these issues called for a better approach to be implemented that does
    not suffer the same issues as the router-based approach had. Eventually, the enterprises
    started to shift to a **service oriented architecture** (**SOA**) model and introduced
    the use of an **Enterprise Service Bus** (**ESB**) for integrating these different
    services inside the SOA. So, let's take a look at how the ESB changed the way
    EAI happens.
  prefs: []
  type: TYPE_NORMAL
- en: The introduction of the ESB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the times moved forward, enterprises shifted to a new model of application
    development. This model used to model the applications as a service, where each
    service used to provide a certain set of business capabilities. So, for example,
    in an enterprise there will be a payroll service, which will provide all of the
    necessary functionality related to the management of the employee payroll, such
    as handling the data for the new employees, keeping a record of how much salary
    they have got and generating the monthly payslips.
  prefs: []
  type: TYPE_NORMAL
- en: Now, these services needed to be integrated with each other so that the exchange
    of data between these services could be facilitated. At this point in time, the
    enterprises needed something ...
  prefs: []
  type: TYPE_NORMAL
- en: Patterns in EAI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: EAI is an approach that has several patterns associated with it that govern
    how the applications are integrated. Which pattern to use usually depends upon
    the type of applications that are present in the enterprise infrastructure, and
    what kind of challenges there are in the integration.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's take a look at these patterns and see how they are usually implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Integration patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During the EAI, the integration patterns define how the applications will be
    integrated with each other. This may define how the different applications will
    communicate with each other and how these applications will transform the data.
    So, let's take a look at two broad ways in which the applications are integrated
    with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Mediation pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the mediation pattern of EAI, there's a central component that is responsible
    for the propagation of the events. For example, in the broker-based middleware
    model, whenever one of the applications generates an event, the event is handled
    by the middleware broker, which is then responsible for the propagation of the
    event to the other applications that are interested in that event.
  prefs: []
  type: TYPE_NORMAL
- en: In this type of integration pattern, usually the applications directly interact
    with each other, facilitated by the middleware broker who relays the events that
    happen, and after which the event handlers for the other application are responsible.
  prefs: []
  type: TYPE_NORMAL
- en: Another integration approach that usually implements the mediation pattern is
    the message bus approach, where the message bus acts as a mediator between the
    different applications delivering messages to each other to facilitate the communication
    between them.
  prefs: []
  type: TYPE_NORMAL
- en: Federation pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The federation pattern is the complete opposite of the mediation pattern in
    terms of functionality. While the mediation pattern focuses on direct communication
    between applications without providing any kind of barrier between them, the federation
    pattern usually restricts free communication between applications.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the federation pattern, there's middleware that exposes a standard set
    of endpoints through which the other applications can communicate with it. Once
    the application makes a request to an API of the federation middleware, the federation
    middleware is then responsible for translating and passing that request to the
    backend application. Once the backend application processes the request, the federation
    middleware ...
  prefs: []
  type: TYPE_NORMAL
- en: Access patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Access patterns define how the access to the data happens within the applications
    inside the enterprise infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually there are two kinds of access patterns that are followed: asynchronous
    and synchronous access patterns. Let''s take a look at what these patterns aim
    at.'
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous access patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The asynchronous access pattern follows the fire-and-forget approach to data
    access. In this case, once the middleware forwards the request, it doesn't wait
    for the response for that request to arrive back and moves on the handling of
    the newer requests that it's receiving.
  prefs: []
  type: TYPE_NORMAL
- en: The asynchronous access pattern is usually followed in the mediation approach,
    where the router middleware, once notified about the occurrence of a certain event,
    propagates the event forward and forgets about the event without waiting for its
    reply.
  prefs: []
  type: TYPE_NORMAL
- en: The same is the case with the message bus model; the message bus, once it has
    delivered a message, does not care about the response for the message being generated,
    hence making the process an ...
  prefs: []
  type: TYPE_NORMAL
- en: Synchronous access patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The synchronous access pattern works in the opposite manner to the asynchronous
    pattern. Instead of forwarding the request and forgetting about the response,
    the synchronous access pattern makes a request and then waits for the response
    to be generated by the other application.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of pattern is usually followed in the case of federated integration,
    where the middleware acts as a intermediate, handling the access to the backend
    applications it's managing.
  prefs: []
  type: TYPE_NORMAL
- en: For example, inside a gateway-based pattern, the middleware usually takes up
    the request, forwards the request to the backend application, and then waits for
    the response to arrive, before moving on to the next request.
  prefs: []
  type: TYPE_NORMAL
- en: These were just a few basic patterns that govern the process of EAI. There are
    close to 65 EAI patterns that are still in use that facilitate the concept of
    EAI.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a look at some of the common issues that prevent a successful
    integration between the different enterprise applications.
  prefs: []
  type: TYPE_NORMAL
- en: Issues in EAI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The successful integration of enterprise applications is usually affected by
    a number of factors; let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Proprietary data formats:** Some of the applications use their own proprietary
    data formats with very little documentation on how to integrate with them, preventing
    integration between the applications or causing the application integration to
    be of poor quality, and therefore resulting in a number of issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data consistency issues:** Maintaining data consistency can turn out to be
    a problem for EAI. When every application maintains their own data source, the
    consistency of data across the different data sources can turn out to be problematic,
    especially if the middleware is experiencing heavy loads, resulting in ...'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the course of this chapter, we took a look at why EAI is necessary for
    the proper functioning of enterprise business processes. Once we understood the
    necessity of EAI, we then moved on to understand the approach toward EAI, where
    we explored the point-to-point integration of application, and why the process
    of point-to-point integration is problematic. We then explored the traditional
    way of implementing EAI through the use of a broker middleware model, before continuing
    the discussion about how the model transformed as SOA came into place, and how
    the ESB took the place of the broker-based model.
  prefs: []
  type: TYPE_NORMAL
- en: We then moved on to understanding the different patterns that are in EAI and
    learned about the mediation and federation integration patterns of connecting
    the different applications, followed by understanding how the different access
    patterns, such as asynchronous and synchronous access, work in the transportation
    of information from one application to another. We concluded this chapter by exploring
    some of the issues that plague the successful integration of applications in an
    enterprise.
  prefs: []
  type: TYPE_NORMAL
- en: As we move to the next chapter, we'll learn about how the introduction of microservices
    has changed the EAI landscape and has ousted the use of the ESB, and how it's
    now being replaced by distributed message brokers and API gateways.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the issues that are usually faced during point-to-point integration?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does an ESB connect the different types of applications together?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the different types of EAI patterns that exist facilitating the approach
    of application integration?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
