- en: Flux Architecture
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have used React before, you may have heard of Flux already. If not, don’t
    worry. Flux is an architectural pattern for building React user interfaces. We
    will start off with the one-direction dataflow pattern that React uses and that
    will lead us on to Flux. Every bit that makes Flux tick is important and I highly
    recommend you spend some time on this chapter. The minimum two points you should
    take away are how to separate the code and how to split an application into parts
    using Flux. Those small services connected together are responsible for everything
    that a modern mobile application needs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: One-direction dataflow pattern
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive into the Flux architecture, let's look at the historical background
    for this pattern. I want you to understand why it was introduced.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Watching Facebook developers talking about the Flux architecture, I had a gut
    feeling that they switched to Flux from the **Model-View-Controller** (**MVC**)
    pattern. The MVC pattern the decoupling of your business model from view markup
    and coded logic. Logic is encapsulated by a function called a controller and it
    delegates work to services. Hence, we say we aim for lean controllers.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: However, at a larger scale, such as that seen at Facebook, it looks like this
    pattern is not enough. As it allows bidirectional dataflow, it quickly becomes
    hard to understand and even harder to track. One change caused by an event can
    loop back and cascade the effect throughout the application. Imagine if you had
    to find a bug in such an architecture.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: React's one-way data binding
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React's solution for the preceding problem starts with one-way data binding.
    This means that the view layer is maintained by a component and only the component
    can update the view. The resulting native code is computed by the component's
    `render` function and displayed to the end user. If the view layer needs to respond
    to the user's actions, it can only dispatch events that are handled by the component.
    It cannot directly change **state** or **props**.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following diagram, which illustrates this concept:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2e7339a9-76e7-4a9e-a140-b7678fafd51f.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
- en: 'The **App** block represents the state of the native view layer. In the diagram,
    the components are simplified to: props, state, the `render` function, and event
    listeners. Once anything changes in props or state, the watcher calls the `render`
    function to update the native view. Once the user performs an action, a respective
    event is dispatched and then picked up by event listeners.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**App**块代表了原生视图层的状态。在图中，组件被简化为：属性、状态、`render`函数和事件监听器。一旦属性或状态发生变化，观察者就会调用`render`函数来更新原生视图。一旦用户执行操作，相应的事件就会被分派，然后被事件监听器捕获。'
- en: In the two-way data binding schema, the **App** layer does not need to dispatch
    an event. It can directly modify the state of the component. We can simulate this
    with event listeners too. One example of this is controlled input, which we learned
    about in [Chapter 2](89d7ff7d-4e5b-4f17-b8f7-8d9b3574d197.xhtml), *View Patterns*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在双向数据绑定模式中，**App**层不需要分派事件。它可以直接修改组件的状态。我们也可以用事件监听器来模拟这一点。其中一个例子就是受控输入，我们在第二章中学习过，*视图模式*。
- en: Event problems
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件问题
- en: '*"With great freedom comes great responsibility."*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*"伴随着巨大的自由而来的是巨大的责任。"*'
- en: You have probably heard this saying already. This sentiment applies to events
    that we dispatch and handle. Let's discuss some of the issues.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经听过这句话。这种情绪适用于我们分派和处理的事件。让我们讨论一些问题。
- en: First of all, to listen to an event, you need to create an event listener. When
    should it be created? Usually, we create event listeners in a component with markup
    and register using `onClick={this.someEventListener}`. What if this event needs
    to cause a change to a completely different component? In this case, we need to
    lift the listener up the component tree into some container.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，要监听事件，您需要创建一个事件监听器。何时应该创建它？通常情况下，我们在具有标记的组件中创建事件监听器，并使用`onClick={this.someEventListener}`进行注册。如果这个事件需要导致完全不同的组件发生变化呢？在这种情况下，我们需要将监听器提升到组件树中的某个容器中。
- en: As we do this, we notice that we couple more and more components more tightly,
    passing increasing numbers of listeners down the prop chain. This is a nightmare
    we want to avoid, if possible.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样做时，我们注意到我们将越来越多的组件紧密耦合，将越来越多的监听器传递到属性链中。如果可能的话，这是我们想要避免的噩梦。
- en: Hence, Flux introduces the concept of the Dispatcher. The Dispatcher sends an
    event to all of the registered components. This way, every component can react
    to events related to it, while ignoring the unrelated events. We will discuss
    this concept later on in this chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Flux引入了Dispatcher的概念。Dispatcher将事件发送到所有注册的组件。这样，每个组件都可以对与其相关的事件做出反应，而忽略与其无关的事件。我们将在本章后面讨论这个概念。
- en: Further issues with binding
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定的进一步问题
- en: Using one-way data binding is not enough, as you can see. We can quickly fall
    into traps that simulate two-way data binding, or run into problems with events,
    as mentioned in the previous section.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用单向数据绑定是不够的，正如你所看到的。我们很快就会陷入模拟双向数据绑定的陷阱，或者遇到前面部分提到的事件问题。
- en: 'Everything comes down to the question: can we handle it? For large scale applications,
    the answer is usually *no*. We need a predictable model that guarantees that we
    can find out quickly what happened and why. If the events are occurring all over
    our application, the developer will obviously have to spend a lot of time finding
    out what specifically is causing the detected bug.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都归结为一个问题：我们能处理吗？对于大规模应用程序，答案通常是*不行*。我们需要一个可预测的模型，保证我们能够迅速找出发生了什么以及为什么。如果事件在我们的应用程序中随处发生，开发人员显然将不得不花费大量时间找出具体是什么导致了检测到的错误。
- en: How can we narrow down this problem? The answer is restrictions. We need some
    restrictions on the event flow. This is where the Flux architecture kicks in.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Flux
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Flux architecture creates some restrictions on communication between components.
    The main principle is that of ubiquitous actions. The application view layer responds
    to user actions by sending action objects to a Dispatcher. The Dispatcher's role
    is to send every action to subscribed **stores**. You can have many stores and
    each one can act differently in response to the user's action.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: For instance, imagine you are building a cart-based application. A user can
    tap the screen to add some item to the cart, upon which the respective action
    is dispatched and your cart store reacts to it. Also, an analytics store may track
    that such an item has been added to the user's cart. Both react to the same action
    object and use the information as needed. In the end, the view layer is updated
    with the new state.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Replacing MVC
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to enhance MVC architecture, let''s remind ourselves of how it looks:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a84b5e73-8666-42c0-9dc8-eac8267ef1c3.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
- en: Actions are handled by their respective controllers, which have access to models
    (data representations). View is usually coupled to the model and may update it
    as needed.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'When I was reading this architecture for the first time, I struggled to understand
    it. Let me give you some tips if you haven''t work with it yourself yet:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Action: Think of this as a user''s action, such as a button tap, scroll, and
    navigation change.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Controller: This is the piece responsible for handling the action and displaying
    the appropriate native view.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Model: This is a data structure that holds information separated from the view.
    The view needs a model to display it visually according to the design.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'View: This is what the end user sees. The view describes all markup code, which
    can later on be styled. The view is sometimes coupled to styles and referred to
    as one piece.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As the application grows, the little architecture sooner or later becomes something
    like the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/dc8cf004-b83c-41e8-b5d4-da53234b4c5a.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: In this diagram, I tried to show that some models rely on others by creating
    an indentation in the structure of the models. It is a similar case for views.
    This should not be considered bad. Generally, this architecture works to some
    extent. Problems arise when you identify a bug and find yourself unable to locate
    where and why something is going wrong. To be more precise, you lose control over
    the flow of information. You find yourself in a spot where so many things are
    happening at the same moment that you cannot easily predict what is responsible
    for the failure, nor why it is happening. Sometimes, you even struggle to reproduce
    the bug or validate if it is, in fact, a bug.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the diagram, you can spot an issue in model-view communication:
    it goes in both directions. This is what software has been doing for years. Some
    brilliant mind realized that in a client environment, we can afford one-direction
    dataflow. That will effectively make the architecture predictable. If our controllers only had
    a series of input data, and were then supposed to deliver a new state of the view,
    it would feel much clearer. Unit tests could provide series of data, such as an
    input, and assert on an output. Similarly, a tracking service could record any
    errors and save the input data series.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the dataflow Flux proposes:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/0374b19f-0447-4179-aa85-3ea18bc8e2ad.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
- en: All actions go through the Dispatcher and are then sent to registered store
    callbacks. In the end, the store contents are mapped to a view.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'This can get complicated with time, as can be seen in the following diagram:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/1c865594-3e35-4e8e-b74a-d8239804b78f.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
- en: You are likely to have a variety of stores that are used on different views
    or view partials. Our views are composed into one final view that the user sees.
    If something changes, another action is dispatched into the stores. These stores
    calculate a new state and refresh the views.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: This is much simpler. We can now track actions and see which action led to unwanted
    changes in the stores.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Flux by example
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we dive in-depth into Flux, let''s create a simple application using
    the Flux architecture. For this, we will use the Flux library provided by Facebook.
    The library includes all of the pieces we will need to make the application tick
    according to the new Flux flow. Install Flux and the `immutable` libraries. `immutable`
    is also crucial for further advantages as we become more familiar with Flux:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The application we will build in Flux is a Tasks application. The one we have
    already created will need some tweaking. The first thing to do is create the `Dispatcher`,
    Tasks Store, and Task Actions.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'The Flux package provides the base for our architecture. For instance, let''s
    instantiate `Dispatcher` for our Tasks application:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`Dispatcher` will be used to dispatch actions, but we need to create the actions
    first. I will follow the documentation advice and create action types as the first
    step:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now that we have created the types, we should follow up with the action creator
    itself, as seen here:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So far, we have actions and a tool to dispatch them. The missing piece is the
    `Store`, which will react to actions. Let''s create `TodoStore`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To create the Store, we import `ReduceStore` from `flux/utils`. The store class
    should be extended to provide the necessary API methods. We will cover these in
    a later section. As for now, you should have spotted that you need to pass `Dispatcher`
    to the upper class using `super` in the constructor.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'Separately, let''s implement the `reduce` case for `ADD_TASK`. The same flow
    can be tweaked to any other action type you want to create:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As we now have all of the bits for the Flux architecture (`Action`, `Dispatcher`,
    `Store`, and `View`), we can connect all of them together. For this, flux/utils
    exposes a handy container factory method. Please note that I will reuse view from
    our previous Task application. I have removed the likes counter for clarity:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you have not followed this book from the start, please note that we are using
    container component here. This pattern is fairly important to understand and we
    went through it in [Chapter 1](dd223c16-7a14-4b66-a073-2ae7c53f7352.xhtml), *React
    Component Patterns*. There, you can learn how to create container components from
    scratch.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Our application is now equipped with the Flux architecture tools. The last thing
    we need to do is refactor to follow our new principles.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, these are our tasks:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Initialize store with tasks, instead of passing JSON data directly to the view.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an add task form that dispatches an `ADD_TASK` action on submit.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first one is fairly simple:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The second one requires us to use the `Input` component. Let''s create a separate
    file that is responsible for the whole feature. In this file, we will create states
    for name and description, a `handleSubmit` function that dispatches the `ADD_TASK`
    action, and a `render` function with the form view markup:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The fully functional app will look as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 完全功能的应用程序将如下所示：
- en: '![](Images/2e0b32f7-d6bb-4a3a-9988-026c154b6ba9.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2e0b32f7-d6bb-4a3a-9988-026c154b6ba9.png)'
- en: Now that we have created our first app that follows the Flux architecture, it's
    time to deep dive into the API.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了遵循Flux架构的第一个应用程序，是时候深入了解API了。
- en: Detailed Flux diagram
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 详细的Flux图
- en: 'Let''s look at the Flux architecture in a more formalized way. Here is a little
    diagram that shows how the simplified architecture looks:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以更正式的方式来看Flux架构。这里有一个简化架构的小图表：
- en: '![](Images/94b375ec-5f50-4cfb-bd41-efd662e7ec0d.png)Flux diagram from official
    documentation: https://github.com/facebook/flux'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/94b375ec-5f50-4cfb-bd41-efd662e7ec0d.png)官方文档中的Flux图：https://github.com/facebook/flux'
- en: 'Each of the pieces in the preceding diagram has its own purpose in the circular
    chain:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，每个部分都有自己在循环链中的目的：
- en: 'Dispatcher: The manager of what''s happening in the application. This manages
    actions and provides them to registered callbacks. All actions need to pass through
    the Dispatcher. The Dispatcher must expose the `register` and `unregister` methods
    to register/unregister callbacks, and must expose the `dispatch` method, which
    dispatches actions.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度程序：应用程序中发生的一切都由它来管理。它管理动作并将它们提供给注册的回调函数。所有动作都需要通过调度程序。调度程序必须公开`register`和`unregister`方法来注册/注销回调，并必须公开`dispatch`方法来分发动作。
- en: 'Stores: The application consists of multiple stores that register callback(s)
    in the Dispatcher. Each store needs to expose a public `constructor` method that
    accepts the `Dispatcher` argument. The constructor is responsible for registering
    this store instance with the given Dispatcher.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储：应用程序由多个在调度程序中注册回调的存储组成。每个存储需要公开一个接受`Dispatcher`参数的`constructor`方法。构造函数负责使用给定的调度程序注册此存储实例。
- en: 'React views: This topic was covered in the previous chapter. Please have a
    look if you have not followed this book from the beginning.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React视图：这个主题在上一章中已经涵盖过了。如果你没有从头开始阅读这本书，请看一下。
- en: 'Action creators: These compose data into an action object that is delivered
    to the Dispatcher. This process may involve data fetching and other means to obtain
    the necessary data. , action creators may lead to **side effects**. We will cover
    this topic in the next section. The action creator must return a plain action
    object at the end.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作创建者：这些将数据组合成一个动作对象，然后交付给调度程序。这个过程可能涉及数据获取和其他手段来获取必要的数据。操作创建者可能会导致**副作用**。我们将在下一节中涵盖这个主题。操作创建者必须在最后返回一个普通的动作对象。
- en: 'You can find the full API reference for each piece under the following link:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接下找到每个部分的完整API参考：
- en: '[https://facebook.github.io/flux/.](https://facebook.github.io/flux/)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://facebook.github.io/flux/.](https://facebook.github.io/flux/)'
- en: What are side effects?
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是副作用？
- en: A side effect is an application state change that happens outside of the called
    function—to be precise, any state change other than its return value.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 副作用是在被调用函数之外发生的应用程序状态更改——确切地说，除了其返回值之外的任何状态更改。
- en: 'Here are some examples of side effects:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些副作用的例子：
- en: Modifying a global variable
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改全局变量
- en: Modifying a variable in a parent scope chain
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改父作用域链中的变量
- en: Writing to the screen
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入屏幕
- en: Writing to the file
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入文件
- en: Any network request, for instance, an AJAX request
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何网络请求，例如，AJAX请求
- en: This section on side effects is meant to get you ready for the next chapter,
    where we will talk about pure functions in the context of Redux. Also, we will
    push these ideas much further in [Chapter 9](0577761c-9fca-49f2-98ad-2d217e00e974.xhtml),
    *Functional Programming Patterns*, where you will learn how we can benefit from
    functional programming practices, such as mutable and `immutable` objects, higher
    order functions, and monads.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Why recognize side effects?
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Side effects manipulate the state that is not the property of the function.
    Hence, when we look at the function in isolation, it is hard to assess whether
    the function has any negative implications on the application. This is not only
    true in unit tests; it is also cumbersome when it comes to mathematical proofs.
    Some big applications that must be secure can strive to build a mathematical model
    that is bullet-proof. Such apps are proved using math tools that go beyond the
    material of this book.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Side effects, when isolated, may work as data providers to our app. They can
    "inject" into the flow at the best moment, and from then on, data is treated as
    if it was just a variable. Going from one side effect free, function to another.
    Such a side effect-free function chain is easier to debug, and in some cases,
    replay. By replay, I mean passing the exact same input data to assess the output
    and see it if meets business criteria.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the practical side of this concept from the perspectives of both
    MVC and Flux.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Working with side effects in MVC
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we follow classic MVC architecture, we will work with separation of concerns
    as follows: model, view, and controller. Also, the view may get exposed functions
    that directly update the model. If this happens, it may trigger side effects.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of places where side effects could be placed:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Controller initialization
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controller-related service (this service is a decoupled specialized piece of
    logic)
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The view, using the controller-related service exposed as a callback
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In some cases, on model update (server-client bidirectional model)
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I'm sure you can even come up with more than that.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'This freedom comes at a great cost. We can have virtually unlimited numbers
    of paths intertwined with side effects, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Side effect => Controller => Model => View
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controller => Side effect => Model => View
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controller => View => Model => Side effect
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This kills our ability to reason, in a functional side effect-free way, on the
    application as a whole.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: How does MVC usually handle this issue? The answer is simple—most of the time
    this architecture does not care about it. As long as we could assert the app is
    working as expected by unit tests, we would be happy enough.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: MVC通常如何处理这个问题？答案很简单——大部分时间这种架构并不关心它。只要我们能通过单元测试断言应用程序按预期工作，我们就会很满意。
- en: But then Facebook came along and claimed that we can do it better on the frontend
    side. Thanks to the specific nature of the frontend, we can be more organized
    and opinionated on the flow, without significant performance loss.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 但后来Facebook出现了，并声称我们可以在前端做得更好。由于前端的特殊性质，我们可以更有条理地组织和规定流程，而不会有显著的性能损失。
- en: Working with side effects in Flux
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Flux中处理副作用
- en: In Flux, we still retain the freedom to choose the place where side effects
    are triggered, but we must respect unidirectional flow.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flux中，我们仍然保留选择触发副作用的自由，但我们必须尊重单向流。
- en: 'Some examples of possible side effects in Flux include the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Flux中可能的副作用示例包括以下内容：
- en: Downloading data on user click and then sending it to the Dispatcher
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在用户点击时下载数据，然后将其发送给分发器
- en: The Dispatcher downloads data before sending data to registered callbacks
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分发器在发送数据给注册的回调之前下载数据
- en: The store commences synchronous side effects to retain necessary data for update
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储开始同步副作用以保留更新所需的数据
- en: A good idea is to force side effects to occur in only one place in the Flux
    architecture. We could perform side effects only on action triggers. For instance,
    when the `SHOW_MORE` action is triggered by a user click, we first download the
    data and then send the full object to the Dispatcher. Hence, neither the Dispatcher
    nor any store need to perform side effects. This nice idea is used in **Redux
    Thunk.** We will learn about Redux and Redux Thunk in the next chapter.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好主意是强制副作用只发生在Flux架构中的一个地方。我们可以只在操作触发时执行副作用。例如，当用户点击触发`SHOW_MORE`操作时，我们首先下载数据，然后将完整对象发送给分发器。因此，分发器或任何存储都不需要执行副作用。这个好主意在**Redux
    Thunk**中被使用。我们将在下一章中学习Redux和Redux Thunk。
- en: Side effects are crucial in understanding the more advanced material in this
    book. As we have now learned about side effects, let's proceed to the chapter
    summary.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 了解本书中更高级材料的关键在于副作用。现在我们已经了解了副作用，让我们继续阅读本章摘要。
- en: Summary
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: To sum up, Flux is a very good invention for large-scale applications. It solves
    problems where the classic MVC pattern struggles to do so. Events are unidirectional,
    which makes communication more predictable. The domain of your application can
    easily be mapped to stores and then maintained with a domain expert.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，Flux对于大型应用程序来说是一个非常好的发明。它解决了经典MVC模式难以解决的问题。事件是单向的，这使得通信更加可预测。您的应用程序的领域可以很容易地映射到存储，然后由领域专家维护。
- en: All of these things are available thanks to a well-thought-out pattern consisting
    of a Dispatcher, stores, and actions. In this chapter, we made our little Flux-based
    application using `flux-utils`, Facebook's official library.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都得益于一个经过深思熟虑的模式，包括一个分发器、存储和操作。在本章中，我们使用了`flux-utils`，这是Facebook的官方库，制作了基于Flux的小应用程序。
- en: Having connected all of these pieces, we are ready to deep-dive into one particular
    aspect—stores. There are a few patterns that you can use to put your store on
    another level. One of these is Redux library. We will explore the different capabilities
    that Redux provides in the next chapter.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 连接了所有这些部分后，我们准备深入研究一个特定的方面——存储。有一些模式可以让你将存储放在另一个层次上。其中一个是Redux库。我们将在下一章中探讨Redux提供的不同功能。
- en: Questions
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why did Facebook move away from the classic MVC architecture?
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么Facebook放弃了经典的MVC架构？
- en: 'Answer: Facebook identified issues with MVC experienced when working with the
    kind of large scale necessary for Facebook. In the frontend application, views
    and models were tightly coupled. Bidirectional dataflow made it even worse: it
    was hard to debug how the data transitioned between models and views and which
    parts were responsible for the end state.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: What are the main benefits of Flux's architecture?
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: Watch the video **Hacker Way: Rethinking Web App Development at Facebook**
    mentioned in the *Further reading* section or see the section on *Replacing MVC*.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Can you draw a diagram of the Flux architecture? Can you do it in detailed way
    with web APIs drawn and connected to your diagram?
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: Check *Detailed flux diagram* section.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: What is the role of the Dispatcher?
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answer: Check *Flux introduction* or *Detailed flux diagram* if you need to
    go over the full explanation again.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Can you give four examples of side effects?
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answer: Check *Flux introduction*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: How can side effects be decoupled in Flux architecture?
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: Check the section on *Working with side effects in Flux*.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The official Flux documentation page can be found at [https://facebook.github.io/flux/](https://facebook.github.io/flux/).
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flux examples from the GitHub repository can be found at [https://github.com/facebook/flux/tree/master/examples](https://github.com/facebook/flux/tree/master/examples).
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Facebook conference video (F8 2014) called **Hacker Way: Rethinking Web
    App Development at Facebook** is available at[https://www.youtube.com/watch?v=nYkdrAPrdcw](https://www.youtube.com/watch?v=nYkdrAPrdcw).'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flux in React Native** - **Yoav Amit**, Wix Engineering Tech Talks is available
    at [https://www.youtube.com/watch?v=m-rMK5ZZM5k](https://www.youtube.com/watch?v=m-rMK5ZZM5k).'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
