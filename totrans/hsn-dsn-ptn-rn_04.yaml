- en: Flux Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have used React before, you may have heard of Flux already. If not, don’t
    worry. Flux is an architectural pattern for building React user interfaces. We
    will start off with the one-direction dataflow pattern that React uses and that
    will lead us on to Flux. Every bit that makes Flux tick is important and I highly
    recommend you spend some time on this chapter. The minimum two points you should
    take away are how to separate the code and how to split an application into parts
    using Flux. Those small services connected together are responsible for everything
    that a modern mobile application needs.
  prefs: []
  type: TYPE_NORMAL
- en: One-direction dataflow pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive into the Flux architecture, let's look at the historical background
    for this pattern. I want you to understand why it was introduced.
  prefs: []
  type: TYPE_NORMAL
- en: Watching Facebook developers talking about the Flux architecture, I had a gut
    feeling that they switched to Flux from the **Model-View-Controller** (**MVC**)
    pattern. The MVC pattern the decoupling of your business model from view markup
    and coded logic. Logic is encapsulated by a function called a controller and it
    delegates work to services. Hence, we say we aim for lean controllers.
  prefs: []
  type: TYPE_NORMAL
- en: However, at a larger scale, such as that seen at Facebook, it looks like this
    pattern is not enough. As it allows bidirectional dataflow, it quickly becomes
    hard to understand and even harder to track. One change caused by an event can
    loop back and cascade the effect throughout the application. Imagine if you had
    to find a bug in such an architecture.
  prefs: []
  type: TYPE_NORMAL
- en: React's one-way data binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React's solution for the preceding problem starts with one-way data binding.
    This means that the view layer is maintained by a component and only the component
    can update the view. The resulting native code is computed by the component's
    `render` function and displayed to the end user. If the view layer needs to respond
    to the user's actions, it can only dispatch events that are handled by the component.
    It cannot directly change **state** or **props**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following diagram, which illustrates this concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2e7339a9-76e7-4a9e-a140-b7678fafd51f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The **App** block represents the state of the native view layer. In the diagram,
    the components are simplified to: props, state, the `render` function, and event
    listeners. Once anything changes in props or state, the watcher calls the `render`
    function to update the native view. Once the user performs an action, a respective
    event is dispatched and then picked up by event listeners.'
  prefs: []
  type: TYPE_NORMAL
- en: In the two-way data binding schema, the **App** layer does not need to dispatch
    an event. It can directly modify the state of the component. We can simulate this
    with event listeners too. One example of this is controlled input, which we learned
    about in [Chapter 2](89d7ff7d-4e5b-4f17-b8f7-8d9b3574d197.xhtml), *View Patterns*.
  prefs: []
  type: TYPE_NORMAL
- en: Event problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*"With great freedom comes great responsibility."*'
  prefs: []
  type: TYPE_NORMAL
- en: You have probably heard this saying already. This sentiment applies to events
    that we dispatch and handle. Let's discuss some of the issues.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, to listen to an event, you need to create an event listener. When
    should it be created? Usually, we create event listeners in a component with markup
    and register using `onClick={this.someEventListener}`. What if this event needs
    to cause a change to a completely different component? In this case, we need to
    lift the listener up the component tree into some container.
  prefs: []
  type: TYPE_NORMAL
- en: As we do this, we notice that we couple more and more components more tightly,
    passing increasing numbers of listeners down the prop chain. This is a nightmare
    we want to avoid, if possible.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, Flux introduces the concept of the Dispatcher. The Dispatcher sends an
    event to all of the registered components. This way, every component can react
    to events related to it, while ignoring the unrelated events. We will discuss
    this concept later on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Further issues with binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using one-way data binding is not enough, as you can see. We can quickly fall
    into traps that simulate two-way data binding, or run into problems with events,
    as mentioned in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything comes down to the question: can we handle it? For large scale applications,
    the answer is usually *no*. We need a predictable model that guarantees that we
    can find out quickly what happened and why. If the events are occurring all over
    our application, the developer will obviously have to spend a lot of time finding
    out what specifically is causing the detected bug.'
  prefs: []
  type: TYPE_NORMAL
- en: How can we narrow down this problem? The answer is restrictions. We need some
    restrictions on the event flow. This is where the Flux architecture kicks in.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Flux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Flux architecture creates some restrictions on communication between components.
    The main principle is that of ubiquitous actions. The application view layer responds
    to user actions by sending action objects to a Dispatcher. The Dispatcher's role
    is to send every action to subscribed **stores**. You can have many stores and
    each one can act differently in response to the user's action.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, imagine you are building a cart-based application. A user can
    tap the screen to add some item to the cart, upon which the respective action
    is dispatched and your cart store reacts to it. Also, an analytics store may track
    that such an item has been added to the user's cart. Both react to the same action
    object and use the information as needed. In the end, the view layer is updated
    with the new state.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to enhance MVC architecture, let''s remind ourselves of how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a84b5e73-8666-42c0-9dc8-eac8267ef1c3.png)'
  prefs: []
  type: TYPE_IMG
- en: Actions are handled by their respective controllers, which have access to models
    (data representations). View is usually coupled to the model and may update it
    as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'When I was reading this architecture for the first time, I struggled to understand
    it. Let me give you some tips if you haven''t work with it yourself yet:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Action: Think of this as a user''s action, such as a button tap, scroll, and
    navigation change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Controller: This is the piece responsible for handling the action and displaying
    the appropriate native view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Model: This is a data structure that holds information separated from the view.
    The view needs a model to display it visually according to the design.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'View: This is what the end user sees. The view describes all markup code, which
    can later on be styled. The view is sometimes coupled to styles and referred to
    as one piece.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As the application grows, the little architecture sooner or later becomes something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/dc8cf004-b83c-41e8-b5d4-da53234b4c5a.png)'
  prefs: []
  type: TYPE_IMG
- en: In this diagram, I tried to show that some models rely on others by creating
    an indentation in the structure of the models. It is a similar case for views.
    This should not be considered bad. Generally, this architecture works to some
    extent. Problems arise when you identify a bug and find yourself unable to locate
    where and why something is going wrong. To be more precise, you lose control over
    the flow of information. You find yourself in a spot where so many things are
    happening at the same moment that you cannot easily predict what is responsible
    for the failure, nor why it is happening. Sometimes, you even struggle to reproduce
    the bug or validate if it is, in fact, a bug.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the diagram, you can spot an issue in model-view communication:
    it goes in both directions. This is what software has been doing for years. Some
    brilliant mind realized that in a client environment, we can afford one-direction
    dataflow. That will effectively make the architecture predictable. If our controllers only had
    a series of input data, and were then supposed to deliver a new state of the view,
    it would feel much clearer. Unit tests could provide series of data, such as an
    input, and assert on an output. Similarly, a tracking service could record any
    errors and save the input data series.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the dataflow Flux proposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/0374b19f-0447-4179-aa85-3ea18bc8e2ad.png)'
  prefs: []
  type: TYPE_IMG
- en: All actions go through the Dispatcher and are then sent to registered store
    callbacks. In the end, the store contents are mapped to a view.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can get complicated with time, as can be seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/1c865594-3e35-4e8e-b74a-d8239804b78f.png)'
  prefs: []
  type: TYPE_IMG
- en: You are likely to have a variety of stores that are used on different views
    or view partials. Our views are composed into one final view that the user sees.
    If something changes, another action is dispatched into the stores. These stores
    calculate a new state and refresh the views.
  prefs: []
  type: TYPE_NORMAL
- en: This is much simpler. We can now track actions and see which action led to unwanted
    changes in the stores.
  prefs: []
  type: TYPE_NORMAL
- en: Flux by example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we dive in-depth into Flux, let''s create a simple application using
    the Flux architecture. For this, we will use the Flux library provided by Facebook.
    The library includes all of the pieces we will need to make the application tick
    according to the new Flux flow. Install Flux and the `immutable` libraries. `immutable`
    is also crucial for further advantages as we become more familiar with Flux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The application we will build in Flux is a Tasks application. The one we have
    already created will need some tweaking. The first thing to do is create the `Dispatcher`,
    Tasks Store, and Task Actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Flux package provides the base for our architecture. For instance, let''s
    instantiate `Dispatcher` for our Tasks application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`Dispatcher` will be used to dispatch actions, but we need to create the actions
    first. I will follow the documentation advice and create action types as the first
    step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have created the types, we should follow up with the action creator
    itself, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we have actions and a tool to dispatch them. The missing piece is the
    `Store`, which will react to actions. Let''s create `TodoStore`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: To create the Store, we import `ReduceStore` from `flux/utils`. The store class
    should be extended to provide the necessary API methods. We will cover these in
    a later section. As for now, you should have spotted that you need to pass `Dispatcher`
    to the upper class using `super` in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Separately, let''s implement the `reduce` case for `ADD_TASK`. The same flow
    can be tweaked to any other action type you want to create:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As we now have all of the bits for the Flux architecture (`Action`, `Dispatcher`,
    `Store`, and `View`), we can connect all of them together. For this, flux/utils
    exposes a handy container factory method. Please note that I will reuse view from
    our previous Task application. I have removed the likes counter for clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you have not followed this book from the start, please note that we are using
    container component here. This pattern is fairly important to understand and we
    went through it in [Chapter 1](dd223c16-7a14-4b66-a073-2ae7c53f7352.xhtml), *React
    Component Patterns*. There, you can learn how to create container components from
    scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Our application is now equipped with the Flux architecture tools. The last thing
    we need to do is refactor to follow our new principles.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, these are our tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize store with tasks, instead of passing JSON data directly to the view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an add task form that dispatches an `ADD_TASK` action on submit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first one is fairly simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The second one requires us to use the `Input` component. Let''s create a separate
    file that is responsible for the whole feature. In this file, we will create states
    for name and description, a `handleSubmit` function that dispatches the `ADD_TASK`
    action, and a `render` function with the form view markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The fully functional app will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2e0b32f7-d6bb-4a3a-9988-026c154b6ba9.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have created our first app that follows the Flux architecture, it's
    time to deep dive into the API.
  prefs: []
  type: TYPE_NORMAL
- en: Detailed Flux diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at the Flux architecture in a more formalized way. Here is a little
    diagram that shows how the simplified architecture looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/94b375ec-5f50-4cfb-bd41-efd662e7ec0d.png)Flux diagram from official
    documentation: https://github.com/facebook/flux'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the pieces in the preceding diagram has its own purpose in the circular
    chain:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dispatcher: The manager of what''s happening in the application. This manages
    actions and provides them to registered callbacks. All actions need to pass through
    the Dispatcher. The Dispatcher must expose the `register` and `unregister` methods
    to register/unregister callbacks, and must expose the `dispatch` method, which
    dispatches actions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Stores: The application consists of multiple stores that register callback(s)
    in the Dispatcher. Each store needs to expose a public `constructor` method that
    accepts the `Dispatcher` argument. The constructor is responsible for registering
    this store instance with the given Dispatcher.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'React views: This topic was covered in the previous chapter. Please have a
    look if you have not followed this book from the beginning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Action creators: These compose data into an action object that is delivered
    to the Dispatcher. This process may involve data fetching and other means to obtain
    the necessary data. , action creators may lead to **side effects**. We will cover
    this topic in the next section. The action creator must return a plain action
    object at the end.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find the full API reference for each piece under the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://facebook.github.io/flux/.](https://facebook.github.io/flux/)'
  prefs: []
  type: TYPE_NORMAL
- en: What are side effects?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A side effect is an application state change that happens outside of the called
    function—to be precise, any state change other than its return value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of side effects:'
  prefs: []
  type: TYPE_NORMAL
- en: Modifying a global variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying a variable in a parent scope chain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing to the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing to the file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any network request, for instance, an AJAX request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This section on side effects is meant to get you ready for the next chapter,
    where we will talk about pure functions in the context of Redux. Also, we will
    push these ideas much further in [Chapter 9](0577761c-9fca-49f2-98ad-2d217e00e974.xhtml),
    *Functional Programming Patterns*, where you will learn how we can benefit from
    functional programming practices, such as mutable and `immutable` objects, higher
    order functions, and monads.
  prefs: []
  type: TYPE_NORMAL
- en: Why recognize side effects?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Side effects manipulate the state that is not the property of the function.
    Hence, when we look at the function in isolation, it is hard to assess whether
    the function has any negative implications on the application. This is not only
    true in unit tests; it is also cumbersome when it comes to mathematical proofs.
    Some big applications that must be secure can strive to build a mathematical model
    that is bullet-proof. Such apps are proved using math tools that go beyond the
    material of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Side effects, when isolated, may work as data providers to our app. They can
    "inject" into the flow at the best moment, and from then on, data is treated as
    if it was just a variable. Going from one side effect free, function to another.
    Such a side effect-free function chain is easier to debug, and in some cases,
    replay. By replay, I mean passing the exact same input data to assess the output
    and see it if meets business criteria.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the practical side of this concept from the perspectives of both
    MVC and Flux.
  prefs: []
  type: TYPE_NORMAL
- en: Working with side effects in MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we follow classic MVC architecture, we will work with separation of concerns
    as follows: model, view, and controller. Also, the view may get exposed functions
    that directly update the model. If this happens, it may trigger side effects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of places where side effects could be placed:'
  prefs: []
  type: TYPE_NORMAL
- en: Controller initialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controller-related service (this service is a decoupled specialized piece of
    logic)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The view, using the controller-related service exposed as a callback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In some cases, on model update (server-client bidirectional model)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I'm sure you can even come up with more than that.
  prefs: []
  type: TYPE_NORMAL
- en: 'This freedom comes at a great cost. We can have virtually unlimited numbers
    of paths intertwined with side effects, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Side effect => Controller => Model => View
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controller => Side effect => Model => View
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controller => View => Model => Side effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This kills our ability to reason, in a functional side effect-free way, on the
    application as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: How does MVC usually handle this issue? The answer is simple—most of the time
    this architecture does not care about it. As long as we could assert the app is
    working as expected by unit tests, we would be happy enough.
  prefs: []
  type: TYPE_NORMAL
- en: But then Facebook came along and claimed that we can do it better on the frontend
    side. Thanks to the specific nature of the frontend, we can be more organized
    and opinionated on the flow, without significant performance loss.
  prefs: []
  type: TYPE_NORMAL
- en: Working with side effects in Flux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Flux, we still retain the freedom to choose the place where side effects
    are triggered, but we must respect unidirectional flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some examples of possible side effects in Flux include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Downloading data on user click and then sending it to the Dispatcher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Dispatcher downloads data before sending data to registered callbacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The store commences synchronous side effects to retain necessary data for update
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A good idea is to force side effects to occur in only one place in the Flux
    architecture. We could perform side effects only on action triggers. For instance,
    when the `SHOW_MORE` action is triggered by a user click, we first download the
    data and then send the full object to the Dispatcher. Hence, neither the Dispatcher
    nor any store need to perform side effects. This nice idea is used in **Redux
    Thunk.** We will learn about Redux and Redux Thunk in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Side effects are crucial in understanding the more advanced material in this
    book. As we have now learned about side effects, let's proceed to the chapter
    summary.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To sum up, Flux is a very good invention for large-scale applications. It solves
    problems where the classic MVC pattern struggles to do so. Events are unidirectional,
    which makes communication more predictable. The domain of your application can
    easily be mapped to stores and then maintained with a domain expert.
  prefs: []
  type: TYPE_NORMAL
- en: All of these things are available thanks to a well-thought-out pattern consisting
    of a Dispatcher, stores, and actions. In this chapter, we made our little Flux-based
    application using `flux-utils`, Facebook's official library.
  prefs: []
  type: TYPE_NORMAL
- en: Having connected all of these pieces, we are ready to deep-dive into one particular
    aspect—stores. There are a few patterns that you can use to put your store on
    another level. One of these is Redux library. We will explore the different capabilities
    that Redux provides in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why did Facebook move away from the classic MVC architecture?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: Facebook identified issues with MVC experienced when working with the
    kind of large scale necessary for Facebook. In the frontend application, views
    and models were tightly coupled. Bidirectional dataflow made it even worse: it
    was hard to debug how the data transitioned between models and views and which
    parts were responsible for the end state.'
  prefs: []
  type: TYPE_NORMAL
- en: What are the main benefits of Flux's architecture?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: Watch the video **Hacker Way: Rethinking Web App Development at Facebook**
    mentioned in the *Further reading* section or see the section on *Replacing MVC*.'
  prefs: []
  type: TYPE_NORMAL
- en: Can you draw a diagram of the Flux architecture? Can you do it in detailed way
    with web APIs drawn and connected to your diagram?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: Check *Detailed flux diagram* section.'
  prefs: []
  type: TYPE_NORMAL
- en: What is the role of the Dispatcher?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answer: Check *Flux introduction* or *Detailed flux diagram* if you need to
    go over the full explanation again.
  prefs: []
  type: TYPE_NORMAL
- en: Can you give four examples of side effects?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answer: Check *Flux introduction*.
  prefs: []
  type: TYPE_NORMAL
- en: How can side effects be decoupled in Flux architecture?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: Check the section on *Working with side effects in Flux*.'
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The official Flux documentation page can be found at [https://facebook.github.io/flux/](https://facebook.github.io/flux/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flux examples from the GitHub repository can be found at [https://github.com/facebook/flux/tree/master/examples](https://github.com/facebook/flux/tree/master/examples).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Facebook conference video (F8 2014) called **Hacker Way: Rethinking Web
    App Development at Facebook** is available at[https://www.youtube.com/watch?v=nYkdrAPrdcw](https://www.youtube.com/watch?v=nYkdrAPrdcw).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flux in React Native** - **Yoav Amit**, Wix Engineering Tech Talks is available
    at [https://www.youtube.com/watch?v=m-rMK5ZZM5k](https://www.youtube.com/watch?v=m-rMK5ZZM5k).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
