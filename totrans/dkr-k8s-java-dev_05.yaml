- en: Creating Images with Java Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a simple, but functional Java microservice based on Spring
    Bootstrap, we can go further. Before we deploy it using Kubernetes, let's package
    it as a Docker image. In this chapter, we will create a Docker image containing
    our application, and we will dockerize a Spring Boot application to run it in
    an isolated environment, a container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics covered in this chapter will be:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Dockerfile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dockerfile instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and removing images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's begin with the definition of a `Dockerfile` , which will be the definition
    of our container.
  prefs: []
  type: TYPE_NORMAL
- en: Dockerfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you will remember from [Chapter 1](text00022.html) , *Introduction to Docker*
    , the `Dockerfile` is kind of a recipe to build an image. It''s a plain text file
    containing instructions which are executed by Docker in the order they are placed.
    Each `Dockerfile` has a base image that the Docker engine will use to build upon.
    A resulting image will be a specific state of a file system: a read-only, frozen
    immutable snapshot of a live container, composed of layers representing changes
    in the filesystem at various points in time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The image creation flow in Docker is pretty straightforward and consists basically
    of two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, you prepare a text file named `Dockerfile` , which contains a series
    of instructions on how to build the image. The set of instructions you can use
    in the `Dockerfile` is not very broad, but sufficient to fully instruct Docker
    how to create an image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you execute the `docker build` command to create a Docker image based
    on the `Dockerfile` that you have just created. The `docker build` command runs
    within the context. The build's context is the files at a specified location,
    which can be a `PATH` or a URL. The `PATH` is a directory on your local filesystem
    and the URL is a Git repository location. A context is processed recursively.
    `PATH` will include any subdirectories. The URL will include the repository and
    its submodules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you create an image containing a Java application, you can also skip the
    second step and utilize one of the Docker Maven plugins available. After we learn
    how to build images using the `docker build` command, we will also create our
    image using Maven. When building using Maven, the context to the `docker build`
    command (or a build process, in this case) will be provided automatically by Maven
    itself. Actually, there is no need for the `Dockerfile` at all, it will be created
    automatically during the build process. We will get to this in a short while.
  prefs: []
  type: TYPE_NORMAL
- en: The standard name for a `Dockerfile` is just `Dockerfile` . It's just a plain
    text file. Depending on the IDE you use, there are plugins to provide Dockerfile
    syntax highlighting and autocompletion, which makes editing them a breeze. Dockerfile
    instructions use simple and clear syntax which makes them quite easy to understand,
    create, and use. They are designed to be self-explanatory, especially because
    they allow commenting just as properly written application source code. Let's
    get to know the `Dockerfile` instructions now.
  prefs: []
  type: TYPE_NORMAL
- en: Dockerfile instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will begin with the instruction that every Dockerfile must have at the top,
    the `FROM` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: FROM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the first instruction in the Dockerfile. It sets the base image for
    every subsequent instruction coming next in the file. The syntax for the `FROM`
    instruction is straightforward. It''s just:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FROM <image>` , or `FROM <image>:<tag>` , or `FROM <image>@<digest>`'
  prefs: []
  type: TYPE_NORMAL
- en: The `FROM` instruction takes a `tag` or `digest` as a parameter. If you decide
    to skip them, Docker will assume you want to build your image from the `latest`
    tag. Be aware that `latest` will not always be the latest version of the image
    you want to build upon. The `latest` tag is kind of a special one. Also, it may
    not work as you may expect. Well, to cut a long story short, it doesn't mean anything
    special unless the image creator (`openjdk` or `fabric8` , for example) has a
    specific `build` , `tag` , and `push` pattern. The `latest` tag assigned to an
    image simply means that it's the image that was last built and executed without
    a specific tag provided. It's easy to understand that it may be confusing, pulling
    the image tagged `latest` will not fetch the latest version of the software.
  prefs: []
  type: TYPE_NORMAL
- en: Docker will not take care of checking if you are getting the newest version
    of the software when pulling the image tagged `latest` .
  prefs: []
  type: TYPE_NORMAL
- en: Docker will throw an error during the build if it cannot find a tag or digest
    you provide. You should choose the base image wisely. My recommendation would
    be to always prefer the official repositories that can be found on Docker Hub.
    By choosing an official image you can be pretty sure it will be of high quality,
    tested, supported, and maintained.
  prefs: []
  type: TYPE_NORMAL
- en: 'For containerizing a Java application, we have two options. The first one is
    to use a base Linux image and install Java using the `RUN` instruction (we will
    cover `RUN` in a while). The second option will be to pull an image containing
    the Java runtime already installed. Here you have a lot more to choose from. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`openjdk` : An official repository containing an open-source implementation
    of the Java platform, Standard Edition. The tag `latest` , which will be used
    if you do not specify any tag, points to the `8u121-alpine` OpenJDK release, as
    of the time of writing this book'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fabric8/java-alpine-openjdk8-jdk` : This base image is actually also being
    used by the fabric8 Maven plugin'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`frolvlad/alpine-oraclejdk8` : There are three tags you can choose from: full
    (only src tarballs get removed), cleaned (desktop parts get cleaned), slim, everything
    but the compiler and JVM is removed. The tag latest points to the cleaned one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jeanblanchard/java` : A repository containing images based on Alpine Linux
    to keep the size minimal (about 25% of an Ubuntu-based image). The tag `latest`
    points to Oracle Java 8 (Server JRE)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By registering and creating your account on the Docker Hub at [https://hub.docker.com](https://hub.docker.com)
    , you will get access to the Docker Store. It's available at [https://store.docker.com](https://store.docker.com)
    . Try searching the Docker Store for Java-related images. You will find a lot
    of useful images to choose from, and one of them is the official Oracle Java 8
    SE (Server JRE) image. This Docker image provides the Server JRE, a runtime environment
    specifically targeted for deploying Java in server environments. The Server JRE
    includes tools for JVM monitoring and tools commonly required for server applications.
    You can get this official Java Docker image by buying it on the Docker Store.
    Click Get Content, it's priced $0.00, so it will be available for your development
    purposes free of charge.
  prefs: []
  type: TYPE_NORMAL
- en: Take note that images coming from the Docker Store are bound to your Docker
    Hub account. Before you pull them or build your own images having them as the
    base image, you will need to the authenticate to Docker Store using the `docker
    login` command and your Docker Hub credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our purposes, let''s choose `jeanblanchard/java` . It''s the official Oracle
    Java running on top of the Alpine Linux distribution. The base image is small
    and fast to download. Our `FROM` instruction will look the same as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If a `FROM` image is not found on your Docker host (on your local machine, for
    example), Docker will try to find and pull it out from the Docker Hub (or your
    private repository if you have it set up). All subsequent instructions in the
    `Dockerfile` will use the image specified in the `FROM` as a base starting point.
    That's why it's mandatory; a valid `Dockerfile` must have it at the top.
  prefs: []
  type: TYPE_NORMAL
- en: MAINTAINER
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By using the `MAINTAINER` instruction, you set the `Author` field of the generated
    image. This can be your name, username, or whatever you would like as an author
    of the image that will be created by using the `Dockerfile` you are writing. This
    command can be placed anywhere in a `Dockerfile` , but good practice is to place
    it on the top of the file, just after the `FROM` instruction. This is a so-called,
    non-executing command, meaning that it will not make any changes to the generated
    image. The syntax, again, is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: WORKDIR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `WORKDIR` instruction adds a working directory for any `CMD` , `RUN` , `ENTRYPOINT`
    , `COPY` , and `ADD` instructions that comes after it in the Dockerfile. The syntax
    for the instruction is `WORKDIR /PATH.` You can have multiple `WORKDIR` instructions
    in one Dockerfile, if the relative path is provided; it will be relative to the
    path of the previous `WORKDIR` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: ADD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What `ADD` basically does is copy the files from the source into the container''s
    own filesystem at the desired destination. It takes two arguments: the source
    (`<source path or URL>` ) and a destination (`<destination path>` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The source can have two forms: it can be a path to a file, a directory, or
    the URL. The path is relative to the directory in which the build process is going
    to be started (the build context we have mentioned earlier). This means you cannot
    have, for example `"../../config.json"` placed as a source path parameter of the
    `ADD` instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The source and destination paths can contain wildcards. Those are the same
    as in a conventional file system: `*` for any text string, or `?` for any single
    character.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, `ADD target/*.jar /` will add all files ending with `.jar` into
    the root directory in the image's file system.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need, you can specify multiple source paths, and separate them with
    a comma. All of them must be relative to the build context, the same as if you
    have just a single source path. If your source or destination paths contain spaces,
    you will need to use a special syntax, adding the square brackets around:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ADD ["<source path or URL>" "<destination path>"]`'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the source path doesn''t end with a trailing slash, it will be considered
    a single file and just copied into the destination. If the source path ends with
    a trailing slash, it will be considered a directory: its whole contents will then
    be copied into the destination path, but the directory itself will not be created
    at the destination path. So, as you can see, a trailing slash `/` is quite important
    when adding files or directories to an image. If the source path points to the
    compressed archive in one of the common formats such as ZIP, TAR, and so on, it
    will be decompressed into the destination path. Docker doesn''t recognize an archive
    by the filename, it checks the contents of the file.'
  prefs: []
  type: TYPE_NORMAL
- en: If the archive is damaged or unreadable by Docker in any other way, it will
    not be extracted and you will not be given an error message. The file will just
    be copied into the destination path.
  prefs: []
  type: TYPE_NORMAL
- en: The same trailing slash rules apply to the destination path; if it ends with
    a trailing slash, it means that it's a directory. Otherwise, it will be considered
    a single file. This gives you great flexibility when constructing the file system
    content of your image; you can add files into directories, add files as single
    files (with the same or different names), or just add whole directories.
  prefs: []
  type: TYPE_NORMAL
- en: The `ADD` command is not only about copying files from the local file system,
    you can use it to get the file from the network. If the source is a URL then the
    contents of the URL will be automatically downloaded and placed at the destination.
    Note that file archives that were downloaded from the network will not be decompressed.
    Again, the trailing slash is important when downloading files; if the destination
    path ends with a slash, the file will be downloaded into the directory. Otherwise,
    the downloaded file will just be saved under the name you provided as the destination
    path.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `<destination directory>` is either an absolute path or a path which is
    relative to the directory specific by the `WORKDIR` instruction (we will cover
    it in a while). The source (or multiple sources) will just be copied into the
    destination specified. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ADD config.json projectRoot/` will add the `config.json` file to `<WORKDIR>/projectRoot/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ADD config.json /absoluteDirectory/` will add the `config.json` file to the
    `/absoluteDirectory/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When it comes to the ownership of the files created in the image, they will
    always be created with the user ID (`UID` ) `0` and group ID (`GID` ) `0` . Permissions
    will be the same as in the source file, unless it''s a file downloaded from the
    remote URL: in this case, it will get permissions value `600` (only the owner
    can read and write the file). If you need to change these values (ownership or
    permissions), you will need to provide more instructions in your Dockerfile, after
    the `ADD` instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: If the files that you need to add to the image are placed on the URL that needs
    authentication, the `ADD` instruction will not work. You will need to use a shell
    command to download the file, such as `wget` or `curl` .
  prefs: []
  type: TYPE_NORMAL
- en: Note that `ADD` shouldn't be used if you don't need its special features, such
    as unpacking archives, you should use `COPY` instead.
  prefs: []
  type: TYPE_NORMAL
- en: COPY
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `COPY` instruction will copy new files or directories from `<source path>`
    and add them to the file system of the container at the path `<destination path>`
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s very similar to the `ADD` instruction, even the syntax is no different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The same rules from `ADD` apply to `COPY` : all source paths must be relative
    to the context of the build. Again the presence of the trailing slash at the end
    of the source and destination path is important: if it''s present, the path will
    be considered a file; otherwise, it will be treated as a directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, as in `ADD` , you can have multiple source paths. If source or destination
    paths contain spaces, you will need to wrap them in square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `<destination path>` is an absolute path (if begins with a slash), or a
    path relative to the path specified by the `WORKDIR` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the functionality of `COPY` is almost the same as the `ADD`
    instruction, with one difference. `COPY` supports only the basic copying of local
    files into the container. On the other hand, `ADD` gives some more features, such
    as archive extraction, downloading files through URL, and so on. Docker's best
    practices say that you should prefer `COPY` if you do not need those additional
    features of `ADD` . The `Dockerfile` will be cleaner and easier to understand
    thanks to the transparency of the `COPY` command.
  prefs: []
  type: TYPE_NORMAL
- en: There is one common, important aspect for both `ADD` and `COPY` instructions,
    a cache. Basically, Docker caches the files that go into the image during the
    build. The contents of the file or files in the image are examined and a checksum
    is calculated for each file. During the cache lookup, the checksum is compared
    against the checksum in the existing images. If anything has changed in the file(s),
    such as the contents and metadata, then the cache is being invalidated. Otherwise,
    if the source file has not changed, an existing image layer is being reused.
  prefs: []
  type: TYPE_NORMAL
- en: If you have multiple Dockerfile steps that use different files from your context,
    `COPY` them individually, rather than all at once. This will ensure that each
    step's build cache is only invalidated (forcing the step to be re-run) if the
    specifically required files change.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `COPY` instruction has almost identical syntax and behavior
    to the `ADD` instruction, but their feature set is somehow different. For files
    and directories that do not require the `ADD` feature of archive unpacking or
    fetching from the URL, you should always use `COPY` .
  prefs: []
  type: TYPE_NORMAL
- en: RUN
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `RUN` instruction is the central executing instruction for the `Dockerfile`
    . In essence, the `RUN` instruction will execute a command (or commands) in a
    new layer on top of the current image and then commit the results. The resulting
    committed image will be used as a base for the next instruction in the `Dockerfile`
    . As you will remember from [Chapter 1](text00022.html) , *Introduction to Docker*
    , layering is the core concept in Docker. `RUN` , takes a command as its argument
    and runs it to create the new layer.
  prefs: []
  type: TYPE_NORMAL
- en: This also means that `COPY` and `ENTRYPOINT` set parameters can be overridden
    at runtime, so if you don't change anything after starting your container, the
    result will always be the same. `RUN` however, will be executed at build time
    and no matter what you do at runtime, its effects will be here.
  prefs: []
  type: TYPE_NORMAL
- en: To make your Dockerfile more readable and easier to maintain, you can split
    long or complex `RUN` statements on multiple lines separating them with a backslash.
  prefs: []
  type: TYPE_NORMAL
- en: The `RUN` commands from the `Dockerfile` will be executed in the order they
    appear in it.
  prefs: []
  type: TYPE_NORMAL
- en: Each `RUN` instruction creates a new layer in the image.
  prefs: []
  type: TYPE_NORMAL
- en: As you already know from [Chapter 1](text00022.html) , *Introduction to Docker*
    , layers are being cached and reused by Docker. The cache for `RUN` instructions
    isn't invalidated automatically during the next build. For example, the cache
    for an instruction the same as `RUN apt-get upgrade -y` will be reused during
    the next build. What makes the cache important? For the most part, the cache is
    exceptionally helpful and can save you a tremendous amount of time while building
    your image. It makes building a new container really, really fast. However, there
    is a word of warning. There are times when the caching can be dangerous and provide
    unexpected results. The cache is used pretty heavily during the build process
    and this may cause issues when you want the updated output of a `RUN` command
    to make it into the new container. If the `RUN` command doesn't change between
    two builds, Docker's cache will not get invalidated. In effect, Docker will reuse
    the previous results from the cache. This is clearly harmful. Imagine a case when
    you use the `RUN` command for pulling source code from the Git repository, by
    using the `git clone` as the first step of building the image.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware when the Docker cache needs to be invalidated, otherwise you will get
    unexpected results with your image builds.
  prefs: []
  type: TYPE_NORMAL
- en: That's why it's good to know how to selectively invalidate the cache. In the
    Docker world, this is called cache busting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example. Probably the most common usecase for `RUN`
    is an application of `apt-get` , which is a package manager command for downloading
    packages on Ubuntu. Let''s say we have the following Dockerfile, installing Java
    runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we build an image from this `Dockerfile` , all layers from two `RUN` instructions
    will be put into the layers cache. But, after a while you decide you want the
    `node.js` package in your image, so now the Dockerfile looks the same as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the `docker build` for the second time, Docker will reuse the layers
    by taking them from the cache. As a result, the `apt-get update` will not be executed,
    because the cached version will be used. In effect, your newly created image will
    potentially have an outdated version of the `java` and `node.js` packages. You
    should always have the cache concept in mind when creating `RUN` instructions.
    In our example, we should always combine `RUN apt-get update` with `apt-get install`
    in the same `RUN` statement, which will create just a single layer; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Better than this, you can also use a technique called "version pinning" to avoid
    cache problems. It's nothing more than just providing a specific, concrete version
    for the package you want to install.
  prefs: []
  type: TYPE_NORMAL
- en: CMD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The purpose of a `CMD` instruction is to provide defaults for an executing
    container. You can think of the `CMD` instruction as a starting point of your
    image, when the container is being run later on. This can be an executable, or,
    if you specify the `ENTRYPOINT` instruction (we are going to explain it next),
    you can omit the executable and provide the default parameters only. The `CMD`
    instruction syntax can have two forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CMD ["executable","parameter1","parameter2"]` : This is a so called `exec`
    form. It''s also the preferred and recommended form. The parameters are JSON array,
    and they need to be enclosed in square brackets. The important note is that the
    `exec` form does not invoke a command shell when the container is run. It just
    runs the executable provided as the first parameter. If the `ENTRYPOINT` instruction
    is present in the `Dockerfile` , `CMD` provides a default set of parameters for
    the `ENTRYPOINT` instruction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMD command parameter1 parameter2` : This a shell form of the instruction.
    This time, the shell (if present in the image) will be processing the provided
    command. The specified binary will be executed with an invocation of the shell
    using `/bin/sh -c` . It means that if you display the container''s hostname, for
    example, using `CMD echo $HOSTNAME` , you should use the shell form of the instruction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have said before that the recommended form of `CMD` instruction is the `exec`
    form. Here''s why: everything started through the shell will be started as a subcommand
    of `/bin/sh -c` , which does not pass signals. This means that the executable
    will not be the container''s PID 1, and will not receive Unix signals, so your
    executable will not receive a `SIGTERM` from `docker stop <container>` . There
    is another drawback: you will need a shell in your container. If you''re building
    a minimal image, it doesn''t need to contain a shell binary. The `CMD` instruction
    using the shell form will simply fail.'
  prefs: []
  type: TYPE_NORMAL
- en: When Docker is executing the command, it doesn't check if the shell is available
    inside the container. If there is no `/bin/sh` in the image, the container will
    fail to start.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if we change the `CMD` to the `exec` form, Docker will be
    looking for an executable named `echo` , which, of course, will fail, because
    `echo` is a shell command.
  prefs: []
  type: TYPE_NORMAL
- en: Because `CMD` is the same as a starting point for the Docker engine when running
    a container, there can only be one single `CMD` instruction in a Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: If there are more than one `CMD` instruction in a Dockerfile, only the last
    one will take effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may notice that the `CMD` instruction is very similar to `RUN` . They both
    can run any command (or application). There is a key important difference: the
    time of execution. The command supplied through the `RUN` instruction is executed
    during the build time, whereas the command specified through the `CMD` instruction
    is executed when the container is launched by executing `docker run` on the newly
    created image. Unlike `CMD` , the `RUN` instruction is actually used to build
    the image, by creating a new layer on top of the previous one which is committed.'
  prefs: []
  type: TYPE_NORMAL
- en: '`RUN` is a build-time instruction, the `CMD` is a runtime instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Believe it or not, we can now have our REST example microservice containerized.
    Let''s check if it builds by executing the `mvn clean install` on the `pom.xml`
    file created in [Chapter 4](text00063.html) , *Creating Java Microservices* .
    After the successful build, we should have a target directory with the `rest-example-0.1.0.jar`
    file created. The Spring Boot application JAR in the `target` directory is an
    executable, fat JAR. We are going to run it from within the Docker container.
    Let''s write the basic `Dockerfile` using the command we already know and place
    it in the root of our project (this will be the context for our `docker build`
    command):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now run the `docker build` command, using `rest-example` as the image
    name, omitting the tag (as you will remember, omitting a tag when building an
    image will result in creating the `latest` tag):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The dot as the first parameter specifies the context for the `docker build`
    command. In our case, it will be just a root directory of our little microservice.
    During the build process, Docker will output all the steps and layer IDs. Notice
    that almost every `Dockerfile` instruction creates a new layer. If you remember
    from [Chapter 1](text00022.html) , *Introduction to Docker* , Docker utilizes
    the layer cache. If a specific layer can be reused, it will be taken from the
    cache. It greatly improves the build process performance. At the end, Docker will
    output the ID of the newly created image, as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'An image has been created, so it should be present on the images available
    to run. To list images, execute the following Docker command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the following screenshot, our `rest-example` image is present
    and ready to be run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'So far, so good. We have a basic form of our image built. Although the process
    of running images is the topic for [Chapter 6](text00108.html) , *Running Containers
    with Java Applications* , let''s quickly run it now to prove it''s working. To
    run the image, execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After a while, you should see the familiar Spring Boot banner as a sign that
    our service is running from inside the Docker container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That wasn't very tricky, right? The basic `Dockerfile` contains just three lines,
    the base image definition using `FROM` , `COPY` to transfer the executable jar
    into the image's filesystem, and a `CMD` instruction to run the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Building an application jar archive using Maven and then copying it using a
    Dockerfile `COPY` instruction simply works. What about delegating the build process
    to the Docker daemon itself? Well, we can do it, using the `Dockerfile` instructions
    we already know. The drawback of building a Java app using the Docker daemon is
    that the image will contain all of the JDK (including the Java compiler), Maven
    binaries, and our application source code. I would recommend building a single
    artifact (a JAR or WAR file), testing it thoroughly (using a release-oriented
    QA cycle), and deploying the sole artifact (with its dependencies of course) onto
    the target machine. However, to have an idea what''s possible with a `Dockerfile`
    , take a look at the following example, assuming that our application code in
    the `/app` folder on the local disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, the Maven build process will be executed by Docker.
    We just run the `apt-get` command to install Maven, add our application source
    code to the image, execute the Maven `package` command, and then run our service.
    It will behave exactly the same as if we just copy the already-built artifact
    into the image's file system.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a Dockerfile instruction which is kind of related to `CMD` instruction:
    the `ENTRYPOINT` . Let''s look at it now.'
  prefs: []
  type: TYPE_NORMAL
- en: The ENTRYPOINT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The official Docker documentation says that the `ENTRYPOINT` instruction allows
    you to configure a container that will run as an executable. It''s not very clear,
    at least for the first time. The `ENTRYPOINT` instruction is related to the `CMD`
    instruction. In fact, it can be confusing at the beginning. The reason for that
    is simple: `CMD` was developed first, then `ENTRYPOINT` was developed for more
    customization, and some functionality overlaps between those two instructions.
    Let''s explain it a bit. The `ENTRYPOINT` specifies a command that will always
    be executed when the container starts. The `CMD` , on the other hand, specifies
    the arguments that will be fed to the `ENTRYPOINT` . Docker has a default `ENTRYPOINT`
    which is `/bin/sh -c` but does not have a default `CMD` . For example, consider
    this Docker command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the image will be the latest `ubuntu` , the `ENTRYPOINT` will
    be the default `/bin/sh -c` , and the command passed to the `ENTRYPOINT` will
    be `echo "hello world"` .
  prefs: []
  type: TYPE_NORMAL
- en: The syntax for the `ENTRYPOINT` instruction can have two forms, similar to `CMD`
    .
  prefs: []
  type: TYPE_NORMAL
- en: '`ENTRYPOINT ["executable", "parameter1", "parameter2"]` is the `exec` form,
    preferred and recommended. Exactly the same as the `exec` form of the `CMD` instruction,
    this will not invoke a command shell. This means that the normal shell processing
    will not happen. For example, `ENTRYPOINT [ "echo", "$HOSTNAME" ]` will not do
    variable substitution on the `$HOSTNAME` variable. If you want shell processing
    then you need either to use the shell form or execute a shell directly. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Variables that are defined in the Dockerfile using `ENV` (we are going to cover
    this in a while), will be substituted by the Dockerfile parser.
  prefs: []
  type: TYPE_NORMAL
- en: '`ENTRYPOINT command parameter1 parameter2` is a a shell form. Normal shell
    processing will occur. This form will also ignore any `CMD` or `docker run` command
    line arguments. Also, your command will not be PID 1, because it will be executed
    by the shell. As a result, if you then `run docker stop <container>` , the container
    will not exit cleanly, and the stop command will be forced to send a `SIGKILL`
    after the timeout.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exactly the same as with the `CMD` instruction, only the last `ENTRYPOINT`
    instruction in the Dockerfile will have an effect. Overriding the `ENTRYPOINT`
    in the Dockerfile allows you to have a different command processing your arguments
    when the container is run. If you need to change the default shell in your image,
    you can do this by changing an `ENTRYPOINT` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: From now on, all parameters from `CMD` , or provided when starting the container
    using `docker run` , will be processed by the Bash shell instead of the default
    `/bin/sh -c` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this simple `Dockerfile` based on BusyBox. BusyBox is software that
    provides several stripped-down Unix tools in a single executable file. To demonstrate
    `ENTRYPOINT` , we are going to use a `ping` command from BusyBox:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s build the image using the previous Dockerfile, by executing the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If you now run the container using the `ping` image, the `ENTRYPOINT` instruction
    will be processing arguments from the supplied `CMD` argument: it will be `localhost`
    by default in our case. Let''s run it, using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, you will have a `/bin/ping localhost` command-line response, as
    you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00071.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `CMD` instruction, as you will remember from its description, sets the default
    command and/or parameters, which can be overwritten from the command line when
    you run the container. The `ENTRYPOINT` is different, its command and parameters
    cannot be overwritten using the command line. Instead, all command line arguments
    will be appended after the `ENTRYPOINT` parameters. This way you can, kind of,
    lock the command that will be executed always during the container start.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the `CMD` parameters, the `ENTRYPOINT` command and parameters are not
    ignored when a Docker container runs with command-line parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the command-line parameter will be appended to the `ENTRYPOINT` parameters,
    we can run our `ping` image with different parameters passed to the `ENTRYPOINT`
    . Let''s try it, by running our ping example with different input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This time it will behave differently. The provided argument value `www.google.com`
    will be appended to the `ENTRYPOINT` , instead of the default `CMD` value provided
    in the Dockerfile. The total command line that will be executed will be `/bin/ping
    www.google.com` , as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00072.jpg)You can use the `exec` form of `ENTRYPOINT` to set fairly
    stable default commands and arguments and then use either form of `CMD` to set
    additional defaults that are more likely to be changed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Having the `ENTRYPOINT` instruction gives us a lot of flexibility. And, last
    but not least, an `ENTRYPOINT` can be also overridden when starting the container
    using the `--entrypoint` parameter for the `docker run` command. Note that you
    can override the `ENTRYPOINT` setting using `--entrypoint` , but this can only
    set the binary to execute (no `sh -c` will be used). As you can see, both `CMD`
    and `ENTRYPOINT` instructions define what command gets executed when running a
    container. Let''s summarize what we have learned about the differences and their
    cooperation:'
  prefs: []
  type: TYPE_NORMAL
- en: A Dockerfile should specify at least one `CMD` or `ENTRYPOINT` instruction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only the last `CMD` and `ENTRYPOINT` in a Dockerfile will be used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ENTRYPOINT` should be defined when using the container as an executable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should use the `CMD` instruction as a way of defining default arguments
    for the command defined as `ENTRYPOINT` or for executing an `ad-hoc` command in
    a container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMD` will be overridden when running the container with alternative arguments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ENTRYPOINT` sets the concrete default application that is used every time
    a container is created using the image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you couple `ENTRYPOINT` with `CMD` , you can remove an executable from `CMD`
    and just leave its arguments which will be passed to `ENTRYPOINT`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The best use for `ENTRYPOINT` is to set the image's main command, allowing that
    image to be run as though it was that command (and then use `CMD` as the default
    flags)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Well, our service is running fine, but it's not very useful. First, it involves
    a lot of manual steps to get it running, that's why we are going to automate it
    later in this chapter using Maven. Second, as you will remember, our service listens
    for `HTTP` requests incoming on port number `8080` . Our basic image runs, but
    doesn't expose any network ports so no one and nothing can access the service.
    Let's continue learning about the remaining Dockerfile instructions to fix it.
  prefs: []
  type: TYPE_NORMAL
- en: EXPOSE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `EXPOSE` instruction informs Docker that the container listens on the specified
    network ports at runtime. We have already mentioned the `EXPOSE` instruction in
    [Chapter 2](text00037.html) , *Networking and Persistent Storage* . As you will
    remember, `EXPOSE` in a Dockerfile is the equivalent to the `--expose` command-line
    option. Docker uses the `EXPOSE` command followed by a port number to allow incoming
    traffic to the container. We already know that `EXPOSE` does not make the ports
    of the container automatically accessible on the host. To do that, you must use
    either the `-p` flag to publish a range of ports or the `-P` flag to publish all
    of the exposed ports at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get back to our `Dockerfile` and expose a port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If you now re-build the image using the same command, `docker build . -t rest-example`
    , you''ll notice that Docker outputs the fourth layer, saying that port `8080`
    has been exposed. Exposed ports will be available for the other containers on
    this Docker host, and, if you map them during runtime, also for the external world.
    Well, let''s try it, using the following `docker run` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If you now call the localhost with a `HTTP` request such as `POST` (for saving
    our book entities) or `GET` (for getting the list of books or a single book) as
    we have done in [Chapter 4](text00063.html) , *Creating Java Microservices* ,
    using any of the HTTP tools such as HTTPie or Postman, it will respond the same
    as before. This time, however, from with the Docker container. Now, this is something.
    Let's get to know the remaining important Dockerfile instructions.
  prefs: []
  type: TYPE_NORMAL
- en: VOLUME
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you will remember from [Chapter 1](text00022.html) , *Introduction to Docker*
    , container file systems are kind of temporary by default. If you start a Docker
    image up (that is, run the container), you'll end up with a read-write layer on
    top of the layer's stack. You can create, modify, and delete files as you wish,
    then commit the layer to persist the changes. In [Chapter 2](text00037.html) ,
    *Networking and Persistent Storage,* we have learned how to create volumes, which
    is a great way of storing and retrieving data from the Docker container. We can
    do the same in the `Dockerfile` , using the `VOLUME` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax couldn''t be simpler: it''s just `VOLUME ["/volumeName"]` .'
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameter for `VOLUME` can be a JSON array, a plain string with one or
    more arguments. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `VOLUME` instruction creates a mount point with the specified name and marks
    it as holding externally mounted volumes from a native host or other containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `VOLUME` command will mount a directory inside your container and store
    any files created or edited inside that directory on your host''s disk outside
    the container file structure. Using `VOLUME` in the `Dockerfile` let''s Docker
    know that a certain directory contains permanent data. Docker will create a volume
    for that data and never delete it, even if you remove all the containers that
    use it. It also bypasses the union file system, so that the volume is in fact
    an actual directory that gets mounted, either read-write or read-only, in the
    right place, in all the containers that share it (if they are started with the
    `--volumes-from` option, for example). To understand `VOLUME` , let''s look at
    the simple Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If you now run your container and save some files in the `/var/myVolume` , they
    will be available for other containers for sharing.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, `VOLUME` and `-v` are almost equal. The difference between `VOLUME`
    and `-v` is that you can use `-v` dynamically and mount your `host` directory
    on your container when starting it by executing `docker run` . The reason for
    that is Dockerfiles are meant to be portable and shared. The host directory volume
    is 100% host dependent and will break on any other machine, which is a little
    bit off the Docker idea. Because of this, it is only possible to use portable
    instructions within a Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fundamental difference between `VOLUME` and `-v` is this: `-v` will mount
    existing files from your operating system inside your Docker container and `VOLUME`
    will create a new, empty volume on your host and mount it inside your container.'
  prefs: []
  type: TYPE_NORMAL
- en: LABEL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To add the metadata to our image, we use the `LABEL` instruction. A single
    label is a key-value pair. If you need to have spaces in the label value, you
    will need to wrap it in a pair of quotes. Labels are additive, they include all
    labels taken from an image that is the base of your own image (the one from the
    `FROM` instruction). If Docker encounters a label that already exists, it will
    override the label having the same key with the new value. There are some rules
    that you must stick to when defining labels: keys can only consist of lowercase
    alphanumeric characters, dots, and dashes, and must begin and end with alphanumeric
    characters. To prevent naming conflicts, Docker recommends using namespaces to
    label keys using reverse domain notation. On the other hand, keys without namespaces
    (dots) are reserved for command-line use.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of the `LABEL` instruction is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To have a multiline value, separate the lines with backslashes; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You can have multiple labels in a single image. Provide them separated with
    a space or a backslash; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Actually, if you need to have multiple labels in your image, it's recommended
    to use the multi-label form of the `LABEL` instruction, because it will result
    in just one additional layer in the image.
  prefs: []
  type: TYPE_NORMAL
- en: Each `LABEL` instruction creates a new layer. If your image has many labels,
    use the multiple form of the single `LABEL` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to inspect what labels an image has, use the `docker inspect` command
    you already know about from the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: ENV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ENV` is a `Dockerfile` instruction that sets the environment variable `<key>`
    to the value `<value>` . You have two options for using `ENV` :'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one, `ENV <key> <value>` , will set a single variable to a value.
    The entire string after the first space will be treated as the `<value>` . This
    will include any character, and also spaces and quotes. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The second one, with an equal sign, is `ENV <key>=<value>` . This form allows
    setting multiple environment variables at once. If you need to provide spaces
    in the values, you will need to use quotes. If you need quotes in the values,
    use backslashes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you can use `ENV` to update the `PATH` environment variable, and
    then `CMD` parameters will be aware of that setting. This will result in a cleaner
    form of `CMD` parameters in the `Dockerfile` . For example, set the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This will ensure that `CMD ["startup.sh"]` will work, because it will find
    the `startup.sh` file in the system `PATH` . You can also use `ENV` to set the
    often-modified version numbers so that upgrades are easier to handle, as seen
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, Docker will download the version of Tomcat specified
    in the `ENV` variable, extract it to the new directory with that version in its
    name, and also set up the system `PATH` to make it available for running.
  prefs: []
  type: TYPE_NORMAL
- en: The environment variables set using `ENV` will persist when a container is run
    from the resulting image. The same as with labels created with `LABEL` , you can
    view the `ENV` values using the `docker inspect` command. The `ENV` values can
    also be overridden just before the start of the container, using `docker run --env
    <key>=<value>` .
  prefs: []
  type: TYPE_NORMAL
- en: USER
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `USER` instruction sets the username or UID to use when running the image.
    It will affect the user for any `RUN` , `CMD` , and `ENTRYPOINT` instructions
    that will come next in the `Dockerfile` .
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of the instruction is just `USER <user name or UID>` ; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `USER` command if an executable can be run without privileges.
    The Dockerfile can contain the user and group creation instruction the same as
    this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Switching USER back and forth frequently will increase the number of layers
    in the resulting image and also will make the Dockerfile more complex.
  prefs: []
  type: TYPE_NORMAL
- en: ARG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ARG` instruction is being used to pass an argument to the Docker daemon
    during the `docker build` command. An `ARG` variable definition comes into effect
    from the line on which it is defined in the `Dockerfile` . By using the `--build-arg`
    switch, you can assign a value to the defined variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The value from the `--build-arg` will be passed to the daemon building the
    image. You can specify multiple arguments using multiple `ARG` instructions. If
    you specify a build time argument that is not defined using `ARG` , the build
    will fail with an error, but the default value can be specified in the `Dockerfile`
    . You specify the default argument value this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If no argument will be specified before starting the build, the default value
    will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: It is not recommended to use `ARG` for passing secrets as GitHub keys, user
    credentials, passwords, and so on, as all of them will be visible to any user
    of the image by using the `docker history` command!
  prefs: []
  type: TYPE_NORMAL
- en: ONBUILD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ONBUILD` instruction specifies an additional instruction which will be
    triggered when some other image is built by using this image as its base image.
    In other words, the `ONBUILD` instruction is an instruction the parent `Dockerfile`
    gives to the child `Dockerfile` ( downstream build). Any build instruction can
    be registered as a trigger and those instructions will be triggered immediately
    after the `FROM` instruction in the `Dockerfile` .
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of the `ONBUILD` instruction is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Within this, `<INSTRUCTION>` is another Dockerfile build instruction, which
    will be triggered later when the child image is going to be built. There are some
    limitations: the `ONBUILD` instruction does not allow the chaining of another
    `ONBUILD` instruction and it does not allow the `FROM` and `MAINTAINER` instructions
    as `ONBUILD` triggers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is useful if you are building an image which will be used as a base to
    build other images. For example, an application build environment or a daemon
    which may be customized with a user-specific configuration. The `ONBUILD` instruction
    is very useful ([https://docs.docker.com/engine/reference/builder/#onbuild](https://docs.docker.com/engine/reference/builder/#onbuild)
    and [https://docs.docker.com/engine/reference/builder/#maintainer-deprecated](https://docs.docker.com/engine/reference/builder/#maintainer-deprecated)
    ), for automating the build of your chosen software stack. Consider the following
    example with Maven and building Java applications (yes, Maven is also available
    as a Docker container). Basically, all your project''s Dockerfile needs to do
    is reference the base container containing the `ONBUILD` instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s no magic, and everything becomes clear if you look into the parent''s
    Dockerfile. In our case, it will be a `docker-maven` Dockerfile available on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: There's a base image that has both Java and Maven installed and a series of
    instructions to copy files and run Maven.
  prefs: []
  type: TYPE_NORMAL
- en: The `ONBUILD` instruction adds to the image a trigger instruction to be executed
    at a later time, when the image is used as the base for another build. The trigger
    will be executed in the context of the child build, as if it had been inserted
    immediately after the `FROM` instruction in the child `Dockerfile` .
  prefs: []
  type: TYPE_NORMAL
- en: When Docker encounters an `ONBUILD` instruction during the build process, the
    builder adds a kind of trigger to the metadata of the image being built. But this
    is the only way this image is being affected. At the end of the build, a list
    of all triggers is stored in the image manifest, under the key `OnBuild` . You
    can see them using the `docker inspect` command, which we already know.
  prefs: []
  type: TYPE_NORMAL
- en: Later the image may be used as a base for a new build, using the `FROM` instruction.
    As part of processing the `FROM` instruction, the Docker builder looks for `ONBUILD`
    triggers, and executes them in the same order they were registered. If any of
    the triggers fail, the `FROM` instruction is aborted which will make the build
    fail. If all triggers succeed, the `FROM` instruction completes and the build
    resumes.
  prefs: []
  type: TYPE_NORMAL
- en: STOPSIGNAL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To specify what system call signal should be sent to the container to exit,
    use the `STOPSIGNAL` instruction. This signal can be a valid unsigned number that
    matches a position in the kernel''s `syscall` table: for instance `9` , or a signal
    name in the format `SIGNAME` , for instance `SIGKILL` .'
  prefs: []
  type: TYPE_NORMAL
- en: HEALTHCHECK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `HEALTHCHECK` instruction can be used to inform Docker how to test a container
    to check that it is still working. This can be checking if our rest service responds
    to `HTTP` calls or just listens on a specified port.
  prefs: []
  type: TYPE_NORMAL
- en: A container can have several statuses which can be listed using the `docker
    ps` command. These can be `created` , `restarting` , `running` , `paused` , `exited`
    , or `dead` . But sometimes this is not enough; a container may be still alive
    from Docker's point of view, but the application can hang or fail in some other
    way. An additional checking for the application status can be useful and `HEALTHCHECK`
    comes in handy.
  prefs: []
  type: TYPE_NORMAL
- en: The `HEALTHCHECK` status is initially starting. Whenever a health check passes,
    it becomes `healthy` (whatever state it was previously in). After a certain number
    of consecutive failures, it becomes `unhealthy` .
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for a `HEALTHCHECK` instruction is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `<interval>` (the default value is 30 seconds) and `<timeout>` (again,
    the default is 30 seconds) are time values, specifying the checking interval and
    timeout accordingly. The `<command>` is the command actually being used to check
    if the application is still running. The exit code of the `<command>` is being
    used by Docker to determine if a health check failed or succeeded. The values
    can be `0` , meaning the container is healthy and ready for use and `1` meaning
    that something is wrong and the container is not working correctly. The Java microservice
    `healthcheck` implementation could be just a simple `/ping` REST endpoint, returning
    whatever (as a timestamp) or even returning an empty response with `HTTP 200`
    status code proving it''s alive. Our `HEALTHCHECK` could execute a `GET` method
    on this endpoint, checking if the service is responding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, the command `curl -f http://localhost/ping` will be
    executed every 5 minutes, for the maximum timeout of 2 seconds. If a single run
    of the check takes longer than 2 seconds then the check is considered to have
    failed. If three consecutive retries fail, the container will get the `unhealthy`
    status.
  prefs: []
  type: TYPE_NORMAL
- en: There can only be one `HEALTHCHECK` instruction in a Dockerfile. If you list
    more than one then only the last `HEALTHCHECK` will take effect.
  prefs: []
  type: TYPE_NORMAL
- en: The `HEALTCHECK` instruction gives you the possibility to fine tune the container
    monitoring, and thus be sure that your container is working fine. It's better
    than just `running` , `exited` or `dead` standard Docker status.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an understanding of `Dockerfile` instructions, we are ready
    to prepare our images. Let's automate things a bit. We are going to create and
    run our image using Maven.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an image using Maven
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Naturally, we could build our Docker image using Docker itself. But this is
    not a typical use case for Spring developers. A typical use case for us would
    be to use Maven. This can be especially useful, if you have continuous integration
    flow set up, using Jenkins for example. Delegating the image build process to
    Maven gives you a lot of flexibility and also saves a lot of time. There is at
    least a couple of Docker Maven plugins available for free on GitHub, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/spotify/docker-maven-plugin](https://github.com/spotify/docker-maven-plugin)
    : A Maven plugin for building and pushing Docker images by Spotify.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: "[https://github.com/alexec/docker-maven-plugin](https://github.com/alexec/docker-maven-plugin)\
    \ . [\uFEFF](https://github.com/alexec/docker-maven-plugin)"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/fabric8io/docker-maven-plugin](https://github.com/fabric8io/docker-maven-plugin)
    : This is the one I find to be most useful and configurable. Of all the Maven
    plugins for Docker at the time of writing, Fabric8 seems to be the most robust.
    Fabric8 is an integrated open source DevOps and integration platform which works
    out of the box on any Kubernetes or OpenShift environment and provides continuous
    delivery, management, ChatOps, and a Chaos Monkey. We are going to use this one
    for the rest of the chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our use case will be using Maven to package the Spring Boot executable JAR,
    and then have that build artifact copied into the Docker image. Using the Maven
    plugin for Docker focuses on two major aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: Building and pushing Docker images which contain build artifacts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting and stopping Docker containers for integration testing and development.
    This is what we are going to focus on in [Chapter 6](text00108.html) , *Running
    Containers with Java Applications*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's focus on creating an image now starting with the plugin goals and possible
    configuration options.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fabric8 Docker plugin provides a couple of Maven goals:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker:build` : This uses the assembly descriptor format from the maven-assembly-plugin
    to specify the content which will be added from a sub-directory in the image (`/maven`
    by default)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker:push` : Images that are built with this plugin can be pushed to public
    or private Docker registries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker:start` and `docker:stop` : For or starting and stopping the container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker:watch` : This will execute `docker:build` and `docker:run` sequentially.
    It can run forever in the background (separate console), unless you stop it with
    CTRL+C. It can watch for assembly files changing and re-run the build. It saves
    a lot of time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker:remove` : This is for cleaning up the images and containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker:logs` : This prints out the output of the running containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker:volume-create` and `docker:volume-remove` : For creating and removing
    volumes, respectively. We will get back to these later in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before we can run these targets, we need to instruct the plugin how it should
    behave. We do it in the plugin configuration in the project''s `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: Maven Docker plugin configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The important part in the plugin definition is the `<configuration>` element.
    This is where you set up the plugin''s behavior. There are two main elements in
    the `<configuration>` :'
  prefs: []
  type: TYPE_NORMAL
- en: A `<build>` configuration specifying how images are built
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `<run>` configuration describing how containers should be created and started
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a simplest example of the configuration for the `fabric8` Maven plugin
    for Docker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `<dockerHost>` specifies the IP address and the port of the running Docker
    engine, so of course, to make it build you will need to have Docker running first.
    In the previous case, if you run the `mvn clean package docker:build` command
    from the shell, the Fabric8 Docker plugin will build the image using the `Dockerfile`
    you provide. But there is another way of building the image, using no `Dockerfile`
    at all, at least not defined explicitly. To do this, we need to change the plugin
    configuration a bit. Take a look at the modified configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we no longer deliver a `Dockerfile` . Instead, we just provide
    the `Dockerfile` instructions as plugin configuration elements. It''s very convenient
    because we no longer need to hardcode an executable jar name, version, and so
    on. It will be taken from the Maven build scope. For example, the name of the
    jar will be provided for the `<cmd>` element. It will result in the generation
    of a valid `CMD` instruction in the `Dockerfile` automatically. If we now build
    the project using the `mvn clean package docker:build` command, Docker will build
    an image with our application. Let''s list the configuration elements available
    for us, alphabetically:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Element** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `assembly` | The `<assembly>` element defines how to build artifacts and
    other files that can enter the Docker image. You can use `targetDir` element to
    provide a directory under which the files and artifacts contained in the assembly
    will be copied into the image. The default value for this is `/maven` . In our
    example, we will use `<descriptorRef>` to provide one of the predefined assembly
    descriptors. The `<descriptorRef>` is kind of a handy shortcut, which can take
    the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`artifact-with-dependencies` : Attaches a project''s artifact and all its dependencies.
    Also, when a classpath file exists in the target directory, this will be added
    to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`artifact` : Attaches only the project''s artifact but no dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`project` : Attaches the whole Maven project but without the `target/` directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rootWar` : Copies the artifact as `ROOT.war` to the `exposed` directory. For
    example, Tomcat can then deploy the war under `root` context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `buildArgs` | Allows for providing a map specifying the value of Docker `buildArgs`
    , which should be used when building the image with an external Dockerfile which
    uses build arguments. The key-value syntax is the same as when defining Maven
    properties (or `labels` or `env` ). |'
  prefs: []
  type: TYPE_TB
- en: '| `buildOptions` | A map specifying the build options to provide to the Docker
    daemon when building the image. |'
  prefs: []
  type: TYPE_TB
- en: '| `cleanup` | This is useful to clean up untagged images after each build (including
    any containers created from them). The default value is `try` which tries to remove
    the old image, but doesn''t fail the build if this is not possible because, for
    example, the image is still used by a running container. |'
  prefs: []
  type: TYPE_TB
- en: '| `cmd` | This is equivalent to the `CMD` instruction we already know about,
    for providing a command to execute by default. |'
  prefs: []
  type: TYPE_TB
- en: '| `compression` | Can take `none` (which is the default), `gzip` , or `bzip2`
    values. It allows us to specify the compression mode and how the build archive
    is transmitted to the Docker daemon (`docker:build` ). |'
  prefs: []
  type: TYPE_TB
- en: '| `entryPoint` | Equivalent to `ENTRYPOINT` in a Dockerfile. |'
  prefs: []
  type: TYPE_TB
- en: '| `env` | Equivalent to `ENV` in a Dockerfile. |'
  prefs: []
  type: TYPE_TB
- en: '| `from` | Equivalent to `FROM` in a Dockerfile, for specifying a base image.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `healthCheck` | Equivalent to `HEALTHCHECK` in a Dockerfile. |'
  prefs: []
  type: TYPE_TB
- en: '| `labels` | For defining labels, the same as `LABEL` in a Dockerfile. |'
  prefs: []
  type: TYPE_TB
- en: '| `maintainer` | Equivalent to `MAINTAINER` in a Dockerfile. |'
  prefs: []
  type: TYPE_TB
- en: '| `nocache` | Used to disable Docker''s build layer cache. This can be overwritten
    by setting a system property `docker.nocache` , when running a Maven command.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `optimize` | If set to true then it will compress all the `runCmds` into
    a single `RUN` directive. Highly recommended to minimize the number of image layers
    created. |'
  prefs: []
  type: TYPE_TB
- en: '| `ports` | The equivalent of `EXPOSE` in a Dockerfile. This is a list of `<port>`
    elements, one for each port to expose. The format can be either pure numerical
    as `"8080"` or with the protocol attached, as `"8080/tcp"` . |'
  prefs: []
  type: TYPE_TB
- en: '| `runCmds` | Equivalent to `RUN` , commands to be run during the build process.
    It contains `<run>` elements which will be passed to the shell. |'
  prefs: []
  type: TYPE_TB
- en: '| `tags` | Can contain a list of `<tag>` elements to provide additional tags
    which an image is to be tagged with after the build. |'
  prefs: []
  type: TYPE_TB
- en: '| `user` | Equivalent to `USER` in a Dockerfile, it specifies the user to which
    the Dockerfile should switch. |'
  prefs: []
  type: TYPE_TB
- en: '| `volumes` | Contains a list of `VOLUME` equivalents, a list of `<volume>`
    elements to create a container volume. |'
  prefs: []
  type: TYPE_TB
- en: '| `workdir` | Equivalent to `WORKDIR` from a Dockerfile, a directory to change
    into when starting the container. |'
  prefs: []
  type: TYPE_TB
- en: As you can see, the plugin configuration is very flexible, it contains a complete
    set of equivalents for Dockerfile instructions. Let's see how our `pom.xml` can
    look with the proper configuration.
  prefs: []
  type: TYPE_NORMAL
- en: The complete `pom.xml` .
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have been following our project from the beginning, the complete Maven
    POM is the same as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Building the image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To build the Docker image with our Spring Boot artifact, run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `clean` tells Maven to delete the `target` directory. Maven will always
    compile your classes with the `package` command. It is very important to run the
    `package` command with the `docker:build` command. You''ll encounter errors if
    you try to run these in two separate steps. While the Docker image is building,
    you will see the following output in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ID of a new image will be presented in the console output. If you wonder
    how the automatically generated Dockerfile looks the same as, you will find it
    in the `target/docker/rest-example/0.1.0/build` directory in your project. The
    first time you build this Docker image, it will take longer since all the layers
    are being downloaded. But every build will be a lot faster thanks to layer caching.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and removing volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Fabric8 Maven Docker plugin couldn''t be a complete solution without the
    possibility of managing volumes. Indeed, it provides two ways to handle volumes:
    `docker:volume-create` and `docker:volume-remove` . As you probably remember from
    [Chapter 2](text00037.html) , *Networking and Persistent Storage* , Docker uses
    a plugin-like architecture when handling volumes and their drivers. The `fabric8`
    plugin can be configured to pass a specific volume driver and its parameters to
    the Docker daemon. Consider the following fragment of the plugin configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we create a named volume using the local filesystem
    driver. It can be mounted during the startup of the container, as specified in
    the `<run>` section of the `pom.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how to get started with Docker containers and
    packaging Java applications. We can do it manually by hand using the `docker build`
    command and a `Dockerfile` or we can use Maven to automate things. For Java developers,
    Docker helps isolate our apps in a clean environment. Isolation is important because
    it reduces the complexity of the software environment we're using. The Fabric8
    Maven Docker plugin is a great tool which we can use to automate our image builds
    using Maven, especially when dealing with Java applications. No more writing Dockerfiles
    by hand, we just configure the plugin using the extensive set of options and we
    are done. Additionally, having this working with Maven allows us to easily incorporate
    Docker builds into our existing development flows, as continuous delivery using
    Jenkins, for example. In [Chapter 6](text00108.html) , *Running Containers with
    Java Applications* , we will go into more detail about running our Java applications
    from within a container. Of course, we will use Maven for this, as well.
  prefs: []
  type: TYPE_NORMAL
