- en: Upgrading the Snake Game with Turtle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most computer gamers regard games as exciting and appealing due to their appearance.
    To some extent, this is true. Computer games must be visually attractive so that
    the player feels like they are physically participating in them. Most game developers
    and game designers spend a profuse amount of time developing game graphics and
    animations so as to provide a better experience to the player.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will teach you how to build the basic layout of games from scratch
    using the Python `turtle` module. As we know, the `turtle` module allows us to
    make games with a two-dimensional (2D) motion; thus, we will only be making 2D
    games such as flappy bird, pong, and snake in this chapter. The concept that we
    will be covering in this chapter is extremely important in order to bind movements
    with user actions for the game character.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned how to implement data models
    by creating 2D animations and games. Consequently, you will learn how to deal
    with the different components of game logic, such as defining collisions, boundaries,
    projections, and screen tap events. By learning about such aspects of game programming,
    you will be able to learn how to define and design game components using the `turtle`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of computer pixels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple animation using the Turtle module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upgrading the snake game using Turtle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pong game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The flappy bird game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game testing and possible modifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You are expected to have the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: Python 3.5 or newer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python IDLE (Python's inbuilt IDE)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A text editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A web browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The files for this chapter can be found here: [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter10](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter10)
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2oJLeTY](http://bit.ly/2oJLeTY)'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring computer pixels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you observe the computer screen closely, you might find small dots forming
    rows and columns. From a certain distance, the matrix of dots represents images,
    which we normally see when we look at the screen. These dots are called pixels.
    Since computer games should be made to be pleasantly visual in nature, we have
    to work with these pixels in order to create and customize the game screen, and
    even use them to make a player move in the game, which will be shown on the screen.
    Whenever a player presses any key on the keyboard, changes in movement must be
    reflected in the pixels of the screen. For example, when a player presses the
    **RIGHT** key, a specific character must move a number of units in pixels to the
    right on the screen in order to represent motion. We discussed vectored motion
    in the previous chapter, which is able to override the methods of some classes
    in order to implement motion. We will use the technique of vectors to make pixel
    movement for the game characters. Let''s observe the following outline, which
    we are going to adapt for making any games using vectors and the turtle module:'
  prefs: []
  type: TYPE_NORMAL
- en: Make a `Vector` class, which will have methods such as `__add__()`, `__mul__()`,
    and `__div__()`, which will perform arithmetic operations on our vector points.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `Vector` class to instantiate a player on the game screen, with its
    aiming target or movements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a game boundary using the `turtle` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw game characters using the `turtle` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Operations such as rotate, forward, and move should be used from the `Vector`
    class in order to make a game character move.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Handle user events using the main loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will learn about pixel representation by making a simple **Mario** pixel
    art. The following code shows the representation of pixels in the multi-dimensional
    list, which is a list of lists. We have stored each pixel on a single line using
    the multi-dimensional list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding grid consists of three lines that represent the pixel positions.
    Similar to the list element extract method, the `>>> grid[1][4]` statement returns
    a positional value of '0' from the second list (that is, [0,1,0,1,0,1]) of the
    grid. (Refer to [Chapter 4](22e1090d-87f1-4dd8-9f82-ff25cd4862e2.xhtml), *Data
    Structures and Functions*, to learn more about list operations.) Thus, we can
    access any cell within the grid.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code should be written inside the Python script. By creating
    a `mario.py` file, we will use it to create Mario pixel art:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by importing turtle—`import turtle`—the only module we are going to use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instantiate the turtle module using the `>>> Pen = turtle.Turtle()` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Specify two properties for the pen using speed and color attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We must make a `new` function, named `box`, which will draw a box by drawing
    the square shape using turtle methods. This box size represents the dimension
    for the pixel art:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We must position the pen to start painting from the top-left position of the
    screen. These commands should be defined outside of the `box()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the box size, which represents the dimension of the pixel art that we
    are going to draw:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second phase, you have to declare pixels in the form of multi-dimensional
    lists, which represents the position of each pixel. The following `grid_of_pixels` variable
    represents the grid of lines that represent the positions of the pixels. The following
    line of code must be added outside the `box` function definition. (Refer to [https://github.com/PacktPublishing/Learning-Python-by-building-games](https://github.com/PacktPublishing/Learning-Python-by-building-games)
    to locate the game file, that is, `mario.py`.):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remember that a combination of pixels in a single form represents a straight
    line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the color palette for the pixel art using colors. We will use color
    code to define the colors for the art, as shown in the following code. The hexadecimal
    color code (HEX) represents the color combination of red, green, and blue (#RRGGBB).
    Refer to [https://htmlcolorcodes.com/](https://htmlcolorcodes.com/) in order to
    analyze the different codes for different colors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we should start drawing the pixel art using a grid of pixels and the
    color palette that we defined in *steps 7* and *step 8*. We have to use the `box`
    class that we made previously using the `box()` function to make the pixel art.
    The pixel art consists of rows and columns; thus, we have to declare two loops
    for drawing art. The following code calls different functions from the turtle
    module, such as `forward()`, `penup()`, and `pendown()`. We studied them in the
    previous chapter; they will make use of the pen to draw, based on the list of
    lists that were defined by the grid of pixels:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let's digest the previous code snippet. It contains a `for` loop, which loops
    from an initial value of 0 to the length of the grid of pixels that represent
    positions in the canvas. Each pixel represents one position, where we must draw
    using the pen; thus, we loop on each of those pixels, one at a time. Inside the
    2D `for` loop, we fetch the color from the palette and call the `box` method,
    which creates a rectangular box where our Mario art should be rendered. We draw
    inside this box with the turtle pen by using the `forward()` function. We do the
    same operation in the rows of pixels, as indicated by the i^(th) loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have finished combining the preceding code, that is, we have carried
    out the `box` method, initialization, and two main `for` loops, we are ready to
    run the code and observe the following Mario pixel art. After running our code,
    the pen from the `turtle` module will start drawing, and eventually it will give
    us the following art:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ffcd57a4-69b5-4504-aedf-e409af2f5370.png)'
  prefs: []
  type: TYPE_IMG
- en: Since we are familiar with the concept of pixels and vectored motion, it's time
    to make games using 2D graphics. We will be using the `turtle` module, along with
    data models, in order to create game characters and make them move. We will start
    this adventure by making a simple animation in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding simple animation using the Turtle module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By now, we are probably familiar with the different methods of the `turtle`
    module. This means we won''t have any problem creating characters for the game.
    Similarly, motions for game characters are provided using vectored movements.
    Operations such as vectored addition and subtraction provide linear movement in
    a straight line through the rotation of objects (refer to [Chapter 9](8b0bc40b-fdbc-43c6-b043-1c6d8680600d.xhtml),
    *Data Model Implementation*, for more information). The `move` operation that
    is defined in the following code snippet will provide random movements to game
    characters. The `move` method will take another vector as a catalyst and will
    perform mathematical operations in order to update the current position, while
    also considering the direction of the game character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `rotate` method will rotate the vector counter-clockwise by a specific
    angle (in-place). The following sample represents the `rotate` method call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to define the preceding two methods inside the `Vector` class. Follow
    this procedure to implement the `Vector` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You have to start by defining the `Vector` class with the class keyword. We
    will define slots as class attributes, which will contain three attributes. The
    slots represent an attribute, which contains three pieces of critical information:
    *x*, *y,* and hash. The values *x* and *y* are the current position of the game
    character, while hash is used to locate the data record. For instance, if the
    `Vector` class is instantiated with *x* and *y* coordinates, then the hash attribute
    will be activated. Otherwise, it remains deactivated.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The coordinates of the vectored elements, that is, (5,6), are represented by
    *x* and *y,* where *x = 5* and *y = 6*, and the hash variable represents whether
    the slot is empty. The hash variable is used to locate the data records and to
    check whether the `Vector` class is instantiated. If the slot attribute already
    contains *x* and *y*, this hash attribute will restrain from further assignment
    to the slots. We will also define the `PRECISION` attribute (user-defined), which
    will round the coordinates of *x* and *y* to a certain level. In order to make
    things clear, several examples have been added inside the code, and you can observe
    this inside three-line comments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to define the first member of the class. We know that the first
    member of the class is the `__init__()` method. We will define it in order to
    initialize the class attributes, which are *x* and *y*. We have rounded the values
    of *x* and *y* to a certain level of precision, as indicated by the `PRECISION`
    attribute. `round()` is a built-in function of Python. The following line of code
    contains a constructor, where we initialize the vector coordinates (*x*, *y*)
    using the `round` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You might have observed that you have made *x* and *y* attributes as private
    attributes, as they begin with a single underscore (`_x`, `_y`). Thus, direct
    initialization cannot be done in these types of attributes, which leads to **data
    encapsulation**, which we covered back in the object-oriented paradigms topic.
    Now, in order to fetch and set the values of these attributes, you have to use
    the `getter` and `setter` methods. These two methods will be a property of the
    `Vector` class. The following code represents how to implement `getter` and `setter`
    for our `Vector` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Along with the `getter` and `setter` methodologies, you may have observed `_hash`,
    which represents if the slot is already allocated or not. In order to check whether
    the slot is already appropriated, we have to implement a data model, that is, `__hash__()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Just a quick review: data models, or magic functions, allow us to change the
    implementation of a method that is provided by one of its ancestors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will define the `hash` method on our `Vector` class and implement it
    differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you have to implement two main methods in the `Vector` class: `move()`
    and `rotate()`. We will start with the `move` method. The `move` method will move
    the vector by other (in-place). Here, other is the argument that is passed to
    the `move` method. For example, `(1, 2).move(2, 3)` will result in (3, 5). Remember:
    movement is done by any of the vectored arithmetic operations, that is, add, multiply,
    divide, and so on. We will use the `__add__()` magic function (refer to [Chapter
    9](8b0bc40b-fdbc-43c6-b043-1c6d8680600d.xhtml), *Data Model Implementation*) in
    order to create movement for the vector. Before that, we have to make a copy method
    that will return the copy of the vector. The `copy()` method is essential because
    we don''t want the operations to harm our original vector; instead, we will perform
    arithmetic operations on the copy of the original vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You have to implement the `iadd` magic function before implementing the `add`
    function. We use the `__iadd__` method to implement the extended `add` operator
    assignment. We can implementing the `__iadd__()` magic function inside the `Vector`
    class as follows. We saw its implementation in the previous chapter ([Chapter
    9](8b0bc40b-fdbc-43c6-b043-1c6d8680600d.xhtml), *Data Model Implementation)*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you have to make a new method, `__add__`, which will call the preceding
    `__iadd__()` method on the copy of the original vector. The last statement, `__radd__
    = __add__`, has significant meaning. Let''s observe the following diagrammatic
    relationship between `radd` and add. It works like this: Python tries to evaluate
    the expression, *Vector(1,4) + Vector(4,5)*. First, it calls `int.__add__((1,4),
    (4,5))`, which raises an exception. After this, it will try to invoke `Vector.__radd__((1,4),
    (4,5))`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/3bc12aac-5ec9-44c4-b189-2339422283c9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It''s easy to recognize that the implementation of `__radd__` is analogous
    to `add`: (refer to the example code defined inside the comments in the `__add__()`
    method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we are ready to make the first movement sequence for our animation.
    We will start by defining the `move` method in our class. The `move()` method
    will take a single argument as a vector and add it to the current vector that
    represents the current position of the game character. The `move` method will
    implement a straight line addition. The following code represents the definition
    of the `move` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to create the `rotate()` method. This method is quite tricky
    to create, as it will rotate the vector counter-clockwise by a specified angle
    (in-place). This method will use trigonometric operations such as the sine and
    cosine of the angle; thus, we have to import a math module first: `import math`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code depicts the way of defining the rotate method; inside it,
    we have added comments to make this operation clear to you. At first, we have
    converted the angle into a radian with the: `angle*π/ 180.0` command/formula.
    After that, we fetched *x* and *y* coordinates of the vector class and performed
    the `x = x*cosθ - y*sinθ` and `y = y*cosθ + x*sinθ` operations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The mathematical formula, *x = x*cosθ - y*sin**θ*, is significant in vectored
    motion. This formula is used to provide rotational movements to the game characters. *x*cosθ*
    represents the base *x*-axis movements, while *y*sinθ* represents the vertical
    *y*-axis movements. Thus, this formula facilitates the rotation of a point in
    a 2D plane with an angle of θ.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have completed two methods: `move()` and `rotate()`. These two
    methods are completely unique, but they both represent vectored motion. The `move()`
    method has implemented the `__iadd_()` magic function, while the `rotate()` method
    has its own custom trigonometric implementation. The combination of these two
    methods can form complete movement for game characters on the canvas or game screen.
    To construct any type of 2D game, we have to implement similar kinds of movements.
    Now, we will make a simple animation of an ant game in order to begin our tour
    of our gaming adventure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps depict the procedure of making any animation for 2D games:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, you have to import the necessary module. Since we have to give random
    vector coordinates to the previously made `move()` method, we can predict that
    we will need a random module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, we need another module—a `turtle` module—which will allow us to
    call methods such as ontimer and setup. We also need the methods of a vector class,
    that is, `move()` and `rotate()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have to import it if that class is maintained in any other module or file.
    Create two files: `base.py` for vector movements and `animation.py` for animation.
    Then, import the following statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The first two statements are going to import everything from the random and
    `turtle` modules. The third statement is going to import the vector class from
    the base file or module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we need to define the initial position for the game character, along
    with its aim. It should be initialized as an instance of the vector class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you have to define the wrap method. This method takes *x* and *y* positions
    as an argument that is referred to as `value` and returns it. In the upcoming
    games, such as flappy bird and Pong, we will extend this function and make it
    wrap the value around certain boundary points:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The main controlling unit of the game is the `draw()` function, which calls
    a method to make game character move. It also draws a screen for the game. From
    the `Vector` class, we are going to call the `move` and `rotate` methods. From
    the turtle module, we are going to call the `goto`, `dot`, and `ontimer` methods.
    The `goto` method will move the turtle pen to a specified position on the game
    screen, the `dot` method will create a small dot of a specified length when called,
    and the `ontimer(function, t)` method will install a timer, which calls that function
    after `t` milliseconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the `running` variable was not declared. We will do
    it now, outside the definition of the `draw()` method. We will also set up the
    game screen using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we have completed a simple 2D animation. It consists of a simple dot
    of a length of 10 pixels, but more importantly, it has motion attached to it,
    which is the result of implementing magic functions inside the `Vector` class.
    The next section will teach us how to use the magic functions that we implemented
    in this section in order to make a more robust game, which is the Snake game.
    We will make a Snake game using the turtle module and magic functions.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading the snake game using Turtle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As it turns out, we have been building the snake game in the previous chapters
    of this book: in [Chapter 5](91942969-08b5-4e2d-a64e-3cd3a513b950.xhtml), *Learning
    About Curses by Building a Snake Game*, using the curses module; in [Chapter 6](7f11f831-b5e7-4605-a9bd-25bfb5e3098e.xhtml),
    *Object-Oriented Programming*; and in [Chapter 7](2d97aa5e-7fdd-459d-9c73-626e29c3a0ed.xhtml), *List
    Comprehension and Properties,* by refining it using properties and list comprehension.
    We started with the curses module ([Chapter 5](91942969-08b5-4e2d-a64e-3cd3a513b950.xhtml), *Learning
    About Curses by Building a Snake Game*), and modified it using an object-0riented
    paradigm. The curses module was able to provide a character-based Terminal game
    screen, which eventually made the game character look awful. Although, we learned
    how to build logic using **OOP** and curses, along with making the Snake game,
    it should be noted that games are primarily concerned with visuals: how a player
    sees and interacts with the characters. Thus, our primary concern is to make games
    visually appealing. In this section, we will try to upgrade the Snake game using
    both the turtle module and vectored movements. Since there is only one possible
    movement in the case of the Snake game, which is a straight-line movement by pressing
    the **LEFT, RIGHT, UP,** or **DOWN** key, we don''t have to define anything new
    inside the vector class of the base file. The `move()` method, which we made previously,
    is enough to provide the movements for the snake game.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start coding the Snake game using the turtle module and `Vector` class,
    by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, start by importing the necessary modules, as shown in the following
    code. It is not compulsory for you to import everything first; we can do it along
    with coding other stuff too, but it''s good practice to import everything at once
    so that we don''t forget anything afterward:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s brainstorm a little bit. We can''t use sprites or images yet. We
    will learn about these in the upcoming chapters, after we get started with Pygame.
    For now, we have to make a shape that represents a 2D snake, which is our main
    character. You have to open the `base.py` file, where we created a `Vector` class
    and defined a `Square` method. Note that the `Square` method is declared outside
    the `Vector` class. The following code is a simple implementation of the turtle
    methods that will create square shapes using the turtle pen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, import this newly made method inside the Snake game module. Now, we can
    call the square method inside our Snake game''s Python file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'After importing everything, we will declare variables such as food, snake,
    and aim. The food represents the vector coordinates, which is an instance of the
    `Vector` class, for example, vector(0,0). The snake represents the initial vectored
    position for the snake character, that is, (vector(10,0)), while the body of the
    snake must be a list of representations for the vector, that is, (vector(10,0),
    vector(10,1), and vector(10,2)) for a snake of length 3\. The `aim` vector represents
    the unit that must be added or subtracted to the current snake vector, based on
    the user''s keyboard actions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `snake-Python` file (the main file), after importing everything
    and declaring its attributes, we will start by defining the boundary for the Snake
    game, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You should also define another important method of the Snake game, which is
    known as `move()`, since this will take care of the movement of the Snake character
    on the game screen, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start by understanding the code line by line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the beginning of the `move` method, we fetched `snakehead` and performed
    a copy operation, which is defined inside the `Vector` class, and we made a snake
    move one segment ahead automatically because we want the snake to move automatically
    as soon as the user starts playing the game.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After that, the `if not inside(head) or head in snake` statement is used to
    check for any collisions. If there are any, we will return by rendering the `Red` color
    to the snake.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next line of the statement, `head == food`, we checked whether the snake
    was able to eat food or not. As soon as the player eats the food, we will make
    food appear in another random position, as well as print the score in the Python
    console.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `for body in snake: ..` statement, we looped into the entire body of
    the snake and rendered the `black` color to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `square` method, which is defined inside the `Vector` class, is called to
    create food for the game.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the last statement of the code, the `ontimer()` method was called, which
    takes the `move()` function, and it will install a timer that will call in the
    `move` method every 100 milliseconds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After defining the `move()` method, you have to set up the game screen and
    handle the turtle screen. The parameters that are passed with the `setup` method
    are the `width`, `height`, `setx`, and `sety` positions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The last part of our game is to handle the user events. We have to make the
    user play the game; thus, we must call the appropriate functions whenever a keyboard
    input is received from the user. As Snake is simple game, consisting of only a
    few movements, we will address it in the next section. As soon as the user presses
    any key, we have to handle it by changing the snake''s direction. Thus, we have
    to make one quick method for handling the user''s actions. The following `change()`
    method is going to change the snake''s direction, based on the user events. Here,
    we''ve used the `listen` interface provided by the turtle module, which will listen
    for any incoming user events or keyboard inputs. `onkey()` takes the function,
    which will call the change method based on the user events. For example, when
    `Up` is pressed, we will make changes in the *y* coordinate by increasing the
    current `y` value by 10 units:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s time to run our game, but before that, remember to keep both files (the
    file containing the `vector` and the `square` class, and the file containing the
    Snake game) in the same directory. The output of the game looks something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f5bbd336-8dfb-4c54-aeb5-520decddd003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Along with the turtle graphics, we can look at the score printed right next
    to it within the Python terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/984005d2-933c-48b4-9b5d-73f9e654662a.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have covered the Snake game by making use of several methods provided
    by the Python module and the OOP paradigm, we can reuse these things over and
    over again in the upcoming games. The `Vector` class that was defined in the `base.py`
    file can be revisited time and again for many 2D games. Thus, the reutilization
    of code is one of the prime merits that is provided by OOP. We will make several
    games, such as Pong and flappy bird, in the upcoming sections using only the `Vector`
    class. In the next section, we are going to build the Pong game from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Pong game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have covered the Snake game (although it''s cliche, it''s perfect
    to grasp the knowledge of 2D game programming) now, it''s time to make another
    interesting game. The game we are going to cover in this section is the Pong game.
    If you have played it before, you might find it easier to grasp the concept that
    we will cover in this section. For those who haven''t played it before, don''t
    worry! We will cover everything in this section, which will help you make your
    very own Pong game and play it or even share it with your friends. The following
    diagram is the pictorial representation of the Pong game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/4e32203e-d7f5-4984-8af8-cbba3d9b6b76.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding diagram depicts the playground for the Pong game, where two players
    are two rectangles. They can move up and down, but not left to right. The **dot** in
    the center is the ball, which has to be hit by either player. We have to address
    two types of motion for the game characters in this game:'
  prefs: []
  type: TYPE_NORMAL
- en: For the ball, which can move in any position, but if the player on either side
    fails to receive the ball, they lose, and the opposing player wins.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the player, they should only move either up or down: four keyboard key
    actions should be handled for two players.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apart from the motion, it is even trickier to specify the boundary for the
    game. The horizontal line, which can move up and down, is the position from where
    the ball must be hit and reflected in the other direction, but if the ball hits
    either the left or right vertical boundary, the game should be halted and the
    player who missed the ball will lose. Now, let''s brainstorm so that we know about
    the essentials before actually starting to code:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a random function, which may return a random value but within the same
    range that is determined by the screen's height and width. The value that is returned
    from this function might be useful to make it aim, which is a random movement
    for the ball in the game.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a method that will draw two rectangles on the screen, which are, in fact,
    our players of the game.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third function should be declared, which will draw the game and move the
    Pong ball across the screen. We can use the `move()` method, which is defined
    inside the previously made `Vector` class, which will move the vector by other
    (in-place).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we are done with the logistics, we can start to code. Follow these
    steps in order to make your own Pong game:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by importing the necessary modules, that is, random, turtle, and our
    custom-made module, named `base`, which has a bunch of methods for vectored motion:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code represents the definition for the `value()` method, and
    three assignments of variables. The `value()` method will randomly generate values
    between (-5, -3) and (3, 5). The three assignment statements are understandable
    by their names:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first statement represents the initial position of the ball.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second statement is the further aim of the ball.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The third statement is the `state` variable, which tracks the status of the
    two players:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The next function is an interesting one; this will render the rectangular shape
    onto the game screen. We can use the turtle module and its method to render any
    shape, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'After we make the function to draw a rectangle, we need to make a new method
    that can call the methods that were defined in the preceding steps. Along with
    this, the new method should also move the Pong ball flawlessly onto the game screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time to address the main riddle of the game: what happens when the
    ball hits the horizontal and vertical boundaries, or when it hits the player''s
    rectangular bat ? We can use the `setup` method to create the game screen with
    a custom height and width. The following code should be added within the `draw()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve addressed the movement for the game characters, we have to
    make the game screen and find a way to handle user events. The following code
    will set up the game screen, which is called in from the turtle module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'After we make a game screen, we have to listen to and handle the user''s key
    events by making a custom function. We will make the `move()` function, which
    will move the player''s position by a certain number of units that are passed
    while calling this function. This move function will take care of the up and down
    movements of the rectangular bat:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will use the `listen` interface that is provided by the turtle
    method to handle incoming key events. Since there are four possible movements,
    that is, up and down for each player, we will reserve four keyboard keys [*W*, *S*,
    *I*, and *K*], which will have the listener attached internally by turtle, as
    shown in the code that follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The previous steps are quite simple to understand, but let's grasp the concepts
    we defined in *step 4* and *step 5* more eloquently. In *step 4*, the first two
    lines of code after the `clear()` method will create a rectangular geometrical
    shape of a specified height and width. `state[1]` represents the first player,
    while `state[2]` represents the second player. The `ball.move(aim)` statement
    is a call to the `move` method that is declared inside the vector class.
  prefs: []
  type: TYPE_NORMAL
- en: This method call will perform the addition between the specified vectors, which
    results in a straight line of motion. The `dot(10)` statement will create a ball
    of a width of 10 units.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, in *step 5*, we used the `>>> setup(420, 420, 370, 0)` statement
    to create a screen that has a width of 420px and a height of 420px. There must
    be a change in direction when the ball hits the upper and lower boundaries by
    some amount, and the amount is exactly the negative of the current *y* (*-y* reverses
    the direction). However, when the ball hits either the left or right boundary,
    the game must terminate. After we check for the upper and lower boundaries, we
    make a comparison for the *x* coordinate and check for low and high states. If
    the ball is under these values, it must have collided with the bat, otherwise
    we return the `from` function. Make sure you add this code inside the previously
    defined `draw()` function.
  prefs: []
  type: TYPE_NORMAL
- en: When you run your Pong game file, you will observe two screens; one screen will
    have a turtle graphics screen consisting of two players ready to play your very
    own Pong game. The output will be similar to the diagram we saw previously when
    brainstorming the Pong game. Now that you know a lot about the ways of handling
    keyboard actions, and making a call to the custom functions with the turtle `ontimer` function,
    let's make something new, which will have a controller. It will listen for screen
    tap actions and provide responses to them. We need this in games such as flappy
    bird, where the user taps on the screen and changes the position of the bird.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the flappy bird game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever we talk about games having a screen-tap action or onscreen click action,
    flappy bird comes to mind. If you haven't played it before, make sure you check
    it out at [https://flappybird.io/](https://flappybird.io/) in order to get familiar
    with it. Although the interface that you see in this website won't be the same
    as the flappy bird game we are going to make in this section, don't worry—we will
    emulate its interface after we learn about Python's GUI module, known as *Pygame*.
    But for now, we will make a simple 2D flappy bird game using the Python turtle
    module and vectored motion. We have been using the `onkey` method to handle keyboard
    actions, and in the preceding section, we used the `onkey` method to embed a listener
    to the specific keyboard keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are also games that can be played using mouse actions—by clicking
    onto the game screen. In this section, we are going to follow these steps in order
    to create Flappy, a game inspired by flappy bird:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, you should define a boundary for the gameplay. You can make a
    function that takes an argument as a vector point and checks if it is inside the
    boundary or not and accordingly returns `True` or `False`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have to make a rendering function that will draw game characters onto the
    screen. As we know, turtle is unable to handle many images or sprites in the GUI;
    therefore, your game character will resemble geometrical shapes. You can represent
    your bird character by making any shape. If possible, try to make it small.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After making a render function, you have to create a function that will be able
    to update the objects' positions. This function should be able to handle the `tap` action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can use the predefined `Vector` blueprint throughout the coding of the flappy
    bird game. The previous roadmap clearly implies that we can make a simple flappy
    bird game by defining three functions. Let''s define each of these functions,
    one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, you have to set up the screen. This screen represents the output game
    console where you will play our flappy bird game. You can create a game screen
    using the turtle module by using `setup()`. Let''s create a screen which has a
    width of 420 pixels and a height of 420 pixels:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'You should define a function that will check whether the user has tapped or
    touched inside the boundary. This function should be a Boolean and should return
    `True` if the tapped-point is inside the boundary; otherwise, it should return `False`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'I have already recommended that you take a tour of the flappy bird game if
    you haven''t played it before. While playing it, you will observe that the goal
    of the game is to protect the *bird* character from the obstacles. In a real-world
    game, we have obstacles in the form of vertical pipes. Since we don''t have enough
    resources to use while coding with the turtle module, we won''t be able to use
    such sprites or interfaces in this section. As I have already told you, we are
    going to make cool interfaces by ourselves while learning about Pygame, but for
    now, instead of the GUI, we will be focusing highly on the game logic. Thus, we
    will give some random shapes to the game character; small round shapes for the
    bird character and big round shapes for the obstacles. The bird will be instantiated
    from the vector class, which represents its initial position. The ball (obstacles)
    must be made as a list because we want obstacles to be in the path of the bird:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you are familiar with the game characters, you can render them by
    creating some functions. In the function, we have passed `alive` as a variable,
    which will be a Boolean, and this will check whether the player is dead or not.
    If the bird is alive, we jump to that position using `goto()` and render a dot
    with a green color to it. If the bird is dead, we render the dot with a red color.
    The for loop in the following code will render a number of obstacles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'As we discussed in the previous blueprint, next up is the main controller of
    the game. This function must perform multiple tasks, but all of them will be related
    to updating the objects'' position. It will be hard for the users who haven''t
    played flappy bird before to understand the following code; that is why I had
    encouraged you to take a tour of original flappy bird game. If you inspect the
    movement of the bird in the game, it is restricted to moving in only the *y*-axis,
    that is, either up or down. Similarly for the obstacles, they must move from right
    to left, the same as vertical pipes in the real-world game. The following `move()`
    function consists of the initial motion for the bird. Initially, we want it to
    fall by 5 units, and decrease it accordingly. For the part of bird as obstacles,
    we want it to move from right to left by 3 units:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'You have to explicitly create numbers of obstacles inside the `move` function.
    Since obstacles should spawn randomly, we can use a random module to create it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to check whether the player is able to prevent the bird from
    touching the obstacles. The method to check this is simple. If the ball, or obstacle,
    is out of the left vertical boundary, we can remove it from the list of balls.
    Initially, we made the `inside` function to check whether any point is within
    the boundary; now, we can use it to check whether the obstacle is within the boundary.
    It should look something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we have added a condition for the obstacles; now, it''s time to
    add a condition to check whether the bird is alive. If the bird falls down and
    touches the lower boundary, the program should be terminated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will add another condition—one that will check whether the obstacle
    has collided with the bird. There are several ways of doing this, but for now,
    we will do this by checking the position of the ball and the obstacle. Firstly,
    you have to check the size of the obstacle and the bird: the obstacle or ball
    has a size of 20 pixels, and the bird has a size of 10 pixels (defined at point
    number 4); thus, we can assume that they have collided when the distance between
    them is 0\. Thus, the `>>> if abs(ball - bird) < 15` expression will check whether
    the distance between them is less than 15 (considering the width of the ball and
    the bird):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we are done updating the object''s position, we need to handle user
    events—this is what should be implemented when the player taps the game screen.
    When the user taps the screen, we want the bird to rise up by a certain number
    of pixels. The argument that is passed to the tap function (*x,y*) is the coordinates
    of the clicked point on the game screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, it''s time to add a listener using the turtle module. We will use
    the `onscreenclick()` function, which will take any user-defined function as an
    argument (in our case, it is the `tap()` function), which will be called with
    the coordinates of the clicked point (*x, y*) on the canvas. We have used the
    tap function to call this listener:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This seems like a lot of work, right? It is indeed. We have covered so many
    things in this section: ways to define boundaries, rendering game objects, updating
    object positions, and handling tap events or mouse events. I feel that we have
    already studied a lot about 2D game architecture using the turtle module. Although
    the games that are made by using the turtle module are not very appealing, the
    logic we learned about by building these games will be used repeatedly in the
    upcoming chapters. In these types of games, we don''t care about the interface
    too much, but we will run our game into the Python shell and observe how it looks.
    The outcome of the preceding program will be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/6d05307b-b062-4ca1-9cbb-bf7c212d3805.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Error message**: No module named ''base''. This is because you haven''t added
    your `Base` module (the Python file that contains the `Vector` class, which we
    made in the *Simple animation using Turtle module* section) and the Python game
    file to the same directory. Make sure you create a new directory and store the
    two files together, or grab the code from the following GitHub link: [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter10](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter10).'
  prefs: []
  type: TYPE_NORMAL
- en: There is little place for modifying the games that are made out of Turtle. However,
    I strongly suggest that you to go through it, test the game, and uncover the possible
    modifications by yourself. If you get any, try to implement them. In the next
    section, we will cover how to test the game properly and apply modifications so
    that these games will become more sturdy than before.
  prefs: []
  type: TYPE_NORMAL
- en: Game testing and possible modifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The fallacious misconception that many people believe is that, in order to
    become a proficient game tester, you should be a gamer. This may be true to some
    extent, but mostly, game testers don''t care about the frontend design of the
    game. They primarily focus on the backend part, which deals with *data* communicating
    between game servers and client computers. I will take you through the game testing
    and modification process for our Pong game, while covering the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enhancing game characters**: The following code represents the new model
    for the game characters. We implement it solely using the turtle module. The *Paddle* is
    the rectangular box, which represents the player of the pong game. There are two
    of them, namely paddle A and paddle B:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '**Adding the main character in the game** (**a ball**): Similar to the creation
    of the A and B paddles, we will use the turtle module along with commands such
    as `speed()`, `shape()`, and `color()` to create a ball character and add such
    functionalities to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '**Adding a score interface to the game**:We will use the turtle pen to draw
    an interface for the points scored by each player. The following code consists
    of a method call from the turtle module, that is, the `write()` method, which
    writes text. It puts the string representation of *arg* in the specified position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '**Keyboard binding with proper actions**: In the following code, we have bound
    the keyboard with proper functions. Each keyboard key, when pressed, will call
    the specified function by using `onkeypress`; this is known as **event handling**.
    Confused with methods such as `paddle_a_up` and `paddle_b_up`? Be sure to revise
    *The Pong game* section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '**Turtle screen and main game loop**:The following couple of method calls represent
    the setup for the turtle screen: the screen size and title for the game. The `bgcolor()`
    method will render the background of the turtle canvas with a specified color.
    Here, the background of the screen will be a black color:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The main game loop looks a bit trickier, but if you take a look, you will see
    that we have already learned about this concept. The main loop starts by setting
    the ball in motion. The values of `dx` and `dy` are constant units for its movement.
    For the part of **#border checking**, we start by checking the condition if the
    ball hits the upper or lower wall. If so, we reverse its direction so that the
    ball comes back into the gameplay. For **#2: For RIGHT boundary**, we check if
    the ball hit the right-hand side vertical boundary, and if so, we write the score
    to another player and we end the game. The same goes for the LEFT boundary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to address the condition where the ball hits the paddle of the
    player. The following two conditions represent the collision between the paddle
    and the ball: the former one is for paddle B and the latter for paddle A. Since
    paddle B is at the right-hand side of the screen, we check whether the ball''s
    coordinate is the same as the paddle''s coordinate, plus its width. If so, we
    reverse the ball''s direction using the `ball.dx *= -1` command. The `setx` method
    will change the first coordinate of the ball to **340**, and leaves the *y* coordinate
    unchanged. The logic here is similar to the logic that we used while making the
    Snake game, when the snake''s head collided with the food:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The benefit of implementing such a rigorous modification is to not only enhance
    the game characters, but also to control the inconsistent frame rate—the rate
    at which consecutive images, **frames**, appear on our display screen. We will
    learn about this in detail in the upcoming chapter about *Pygame*, where we will
    customize the turtle-based Snake game by using our own sprites. Before summarizing
    this chapter, let''s run the customized Pong game and observe the result, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ef58bc53-4a0b-4aaa-91bc-f82cd598211b.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the world of 2D turtle graphics, along with vectored
    motions.
  prefs: []
  type: TYPE_NORMAL
- en: I tried to make this chapter as comprehensive as I can, especially when dealing
    with vectored motion. We have created two separate files; one for the `Vector`
    class and another for the game file itself. The `Vector` class provided a way
    to represent the 2D coordinates in the *x* and *y* positions. We performed multiple
    operations, such as *move* and *rotation* using data models—overriding its actual
    behavior in our custom-made `Vector` class. We briefly observed a way of working
    with computer pixels by creating Mario pixel art. We made a grid of pixels (list
    of lists) to represent the positions of the pixels, and eventually used turtle
    methods to render the pixel art. After that, we made a simple animation using
    the turtle module by defining a separate `Vector` class which represents the position
    of the game characters. We used the turtle module and our custom-made `Vector`
    class throughout the game. Although I feel that you are ready to begin your career
    as a 2D game programmer, as we say, *Practice makes Perfect*, and you need to
    experiment with it a lot before you get comfortable with it.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter was a breakthrough for all of us who want to become game programmers.
    We learned the basics of building games with Python using the turtle module, and
    we learned how to handle different user events such as a mouse and a keyboard.
    Finally, we also learned how to create different game characters using the turtle
    module. As you continue to work through this book, you will find out how extremely
    important these concepts of turtle are, so make sure that you revise them before
    moving on.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about the Pygame module—the most important
    platform for building interactive games with Python. From the next chapter onward,
    we will delve into topics about where you can load images or sprites and making
    your own game animations. You will also find out how easy it is to build games
    with Python in comparison to C or C++.
  prefs: []
  type: TYPE_NORMAL
