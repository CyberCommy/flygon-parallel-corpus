- en: Interacting Data Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we built up our application using JavaScript/HTML and
    integrated it with RESTful APIs with AJAX. You also learned how to set cookies
    on the client and sessions on the server for a better experience for users. In
    this chapter, we will focus on improving our backend database by using a NoSQL
    database, such as MongoDB instead of an SQLite database, which we are currently
    using, or a MySQL database, and integrate our application with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics that we will cover in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up MongoDB service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating an application with MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MongoDB - How it is advantageous, and why are we using it?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we begin with the MongoDB installation, let's understand why we have
    chosen the MongoDB database and what it is needed for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the advantages of MongoDB over RDBMS:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Flexible schema**: MongoDB is a document database in which one collection
    holds multiple documents. We don''t need to define the schema of the documents
    prior to inserting the data, which means MongoDB defines the document''s schema
    based on the data inserted into the documents; whereas, in an RDBMS, we need to
    define the schema of the tables before inserting data into it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Less complexity**: There are no complex joins in MongoDB, as we have in the
    case of RDBMS (for example: MySQL) databases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easier scalability**: It is very easy to scale out MongoDB as compared to
    an RDBMS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fast accessibility**: There is faster retrieval of data in MongoDB as compared
    to an RDBMS, that is, the MySQL database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic querying**: MongoDB supports dynamic queries on documents, being
    a document-based query language, which makes it advantageous over other RDBMS,
    which could be MySQL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are the reasons why we should use MongoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB stores data in JSON-style documents, which makes it easy to integrate
    with the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can set an index on any file and property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MongoDB does auto-sharding, which makes it easy to manage and enables it to
    be faster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MongoDB provides replication and high availability when used in a cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are different use cases in which to use MongoDB. Let''s check them here:'
  prefs: []
  type: TYPE_NORMAL
- en: Big data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User data management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content delivery and management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following image shows the architecture diagram of MongoDB integration with
    your web application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: MongoDB terminology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at the different terminologies of MongoDB, which are listed next:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Database**: This is similar to the database that we have in **RDBMS (Relational
    Database Management System),** but, instead of tables, in MongoDB a database is
    a physical container of collections. MongoDB can have multiple databases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collections**: This is basically a combination of documents that has its
    own schema. Collections don''t contribute toward the schema of documents. It''s
    quite equivalent to the tables in RDBMS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Document**: This is similar to a tuple/row in an RDBMS. It''s a set of key-value
    pairs. They have a dynamic schema, where each document may or may not have the
    same schema within a single collection. They may have different fields as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code is a sample collection for your understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: MongoDB represents JSON documents in a binary-encoded format called **BSON**.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the current scenario, we are working on the Ubuntu workstation, so let's
    install MongoDB on Ubuntu as follows.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the Ubuntu package management tool, such as `apt`, to install the
    MongoDB packages by authenticating the distributor-signed packages with the GPG
    keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'To import the GPG keys, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to set the MongoDB repository path to our operating system, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this is added, we need to update our Ubuntu repository as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the repository is updated, let''s install the latest stable MongoDB
    release using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it is installed, the MongoDB service should run on port `27017`. We can
    check the service status using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If it does not run, you can start the service by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! Now we have installed MongoDB on our local machine. At this point in
    time, we only need a standalone MongoDB instance, but if you want to create a
    shared MongoDB cluster, then you can follow the steps defined on the following
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.mongodb.com/manual/tutorial/deploy-shard-cluster/](https://docs.mongodb.com/manual/tutorial/deploy-shard-cluster/)'
  prefs: []
  type: TYPE_NORMAL
- en: So, now that we have enabled the MongoDB service on our machine, we are good
    to go to create a database on top of it.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the MongoDB database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, when we were creating a database in SQLite3, we needed to create
    a database and define the schema of tables manually. Since MongoDB is schemaless,
    we will directly add new documents, and collections will get created automatically.
    Also, in this case, we will initialize the database using Python only.
  prefs: []
  type: TYPE_NORMAL
- en: Before we add new documents into MongoDB, we need to install the Python driver
    for it, that is, `pymongo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `pymongo` driver to `requirements.txt`, and then install it using the
    `pip` package manager as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it is installed, we will import it by adding the following line to `app.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have imported the MongoDB driver for Python, we will create a connection
    to MongoDB and define a function in `app.py`, which will initialize the database
    with initial **data documents**, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It is recommended that you initialize your resource collections with some documents
    in the collection so that we get some response data when we begin testing the
    APIs, otherwise, you can go ahead without initializing the collections.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding function should be called before starting the application; our
    main function will be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Integrating microservices with MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we have initialized our MongoDB database, it's time to rewrite our microservices
    functions to store and retrieve data from MongoDB instead of SQLite 3.
  prefs: []
  type: TYPE_NORMAL
- en: Previously, we used the `curl` command to get a response from the API; instead
    of that, we will use a new tool called **POSTMAN** ([https://www.getpostman.com](https://www.getpostman.com)),
    which is an application that will help you build, test, and document your APIs
    faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on the workings of POSTMAN, read the documentation at
    the following link: [https://www.getpostman.com/docs/](https://www.getpostman.com/docs/)'
  prefs: []
  type: TYPE_NORMAL
- en: POSTMAN is supported by both Chrome and Firefox, as it can be integrated very
    easily as an add-on.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will modify the `api_version` info API to collect the information
    from MongoDB instead of SQLite3, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you test it using POSTMAN, it should give an output that looks somewhat
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Great! It works. Now, let's update the other resources of microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Working with user resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will modify our user resources' API functions for different methods in `app.py`
    as follows.
  prefs: []
  type: TYPE_NORMAL
- en: GET api/v1/users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The GET API function gets a complete list of users.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to get the complete user list from the MongoDB database, we will rewrite
    the `list_users()` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s test it on POSTMAN and see if the API responds as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Since we currently have only one document in the user's collection of the MongoDB
    database, you can see only one user in the users list in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: GET api/v1/users/[user_id]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This API function gets the details of a specific user.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to list the details of a specific user from the MongoDB database,
    use the `modify list_user(user_id)` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s test it on POSTMAN to see if it works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00049.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, we need to test the scenario where a user entry is not present; try this
    out, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: POST api/v1/users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This API function adds new users to the users list.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this code, we will rewrite the `add_user(new_user)` function to interact
    with MongoDB to add a user to the users collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have modified our function, one more thing needs to be done--earlier,
    IDs were generated by SQLite 3, but now, we need to generate them with a random
    module by adding it to its route function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Let's add one record to the users list to test whether it works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output status of adding a new record using
    POSTMAN in MongoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Let's validate whether it has updated the properties in the MongoDB collection
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot validates that our new record has been added successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: PUT api/v1/users/[user_id]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This API function is used to update the attributes of the users in the MongoDB
    users collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to update the documents in the MongoDB user collection for a specific
    user, we will need to rewrite the `upd_user(user)` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have updated the method, let's test it on POSTMAN and check the
    response.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the response of the update API request using
    POSTMAN:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s validate the user document to check whether the fields were modified
    or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: DELETE api/v1/users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This API deletes a specific user from the users list.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we will modify the `del_user(del_user)` method to delete a user
    from the MongoDB users collection as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s test it out over POSTMAN and see if the response is as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we''ve deleted one user, let''s see if it made any changes in the
    overall users list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00056.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Great! We have made changes in all the RESTful API URLs for the user resources,
    and validated them as well.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the tweets resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our user resources APIs are working fine with MongoDB as the database
    service, we will do the same for the tweets resources as well.
  prefs: []
  type: TYPE_NORMAL
- en: GET api/v2/tweets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This function gets the complete list of tweets from all the users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update our `list_tweets()` method to begin getting the list of tweets
    from the tweets collection of MongoDB using the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have updated the code, let''s test it out on POSTMAN. The following
    screenshot lists all the tweets by making an API request using POSTMAN:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00057.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: GET api/v2/tweets/[user_id]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This function gets the tweets from a specific user.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to get tweets from a specific user from the tweets collection, we
    need to modify our current `list_tweet(user_id)` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s test out our API and validate whether it is working as expected or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00058.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: POST api/v2/tweets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This function adds new tweets from an existing user.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we need to modify our `add_tweet(new_tweet)` method to interact
    with users, and the tweets collection in MongoDB to add new tweets, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have modified the record, let''s test it out. The following screenshot
    shows the success status of the `POST` request to add new tweets using POSTMAN:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00059.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s now validate whether the newly added tweets were updated in the tweet
    list, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00060.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we migrated our file-based database service (SQLite) to a NoSQL-document-based
    database service (MongoDB). You learned how to integrate MongoDB with your RESTful
    APIs to respond to hold data, and respond based on the request from the client.
    The next chapter will be more interesting, as we will build our frontend web views
    using React.
  prefs: []
  type: TYPE_NORMAL
