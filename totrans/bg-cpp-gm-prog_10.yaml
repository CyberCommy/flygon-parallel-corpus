- en: Chapter 10. Layering Views and Implementing the HUD
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will get to see the real value of SFML **Views**. We will
    add a large array of SFML `Text` objects and manipulate them as we did before
    in the **Timber!!!** project. What is new is that we will draw the HUD using a
    second view instance. This way, the HUD will stay neatly positioned over the top
    of the main game action, regardless of what the background, player, zombies, and
    other game objects are doing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what we will do:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Add text and a background to the home/game over screen
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add text to the level up screen
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the second view
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a HUD
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding all the Text and HUD objects
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be manipulating a few Strings in this chapter. This is so we can format
    the HUD and the level up screen.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the extra `include` directive highlighted next so we can make some `sstream`
    objects to achieve this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next add this rather lengthy but easily explained code. To help identify where
    you should add the code, the new code is highlighted and the existing code is
    not. You may need to vary the position/size of some text/elements to suit your
    screen:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The previous code is very simple and nothing new. It basically creates a whole
    bunch of SFML `Text` objects. It assigns their colors and sizes, then formats
    their positions, using functions we have seen before.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: The most important thing to note is that we create another `View` object called
    `hudView` and initialize it to fit the resolution of the screen.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, the main view object scrolls around as it follows the player.
    In contrast, we will never move `hudView`. The result of this is that as long
    as we switch to this view before we draw the elements of the HUD, we will create
    the effect of allowing the game world to scroll by underneath while the player's
    HUD remains stationary.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As an analogy, you can think of laying a transparent sheet of plastic, with
    some writing on it, over a TV screen. The TV will carry on as normal with moving
    pictures, the text on the plastic sheet will stay in the same place regardless
    of what goes on underneath it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: The next thing to notice, however, is that the high score is not set in any
    meaningful way. We will need to wait until the next chapter, when we investigate
    file I/O to save and retrieve the high score.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Another point worth noting is that we declare and initialize a `RectangleShape`
    called `healthBar` that will be a visual representation of the player's remaining
    health. This will work in almost exactly the same way that the time-bar worked
    in the last project, except of course, it will represent health instead of time.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: In the previous code, there is a new sprite called `ammoIcon` that gives context
    to the bullet and clip statistics that we will draw next to it, in the bottom
    left of the screen.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Although there is nothing new or technical about the large amount of code that
    we just added, be sure to familiarize yourself with the details, especially the
    variable names, to make the rest of the chapter easier to follow.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Updating the HUD each frame
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you might expect, we will update the HUD variables in the update section
    of our code. We will not, however, do so every frame. The reason for this is that
    it is unnecessary and it also slows our game loop down.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: As an example, consider the scenario where the player kills a zombie and gets
    some more points. It doesn't matter whether the `Text` object that holds the score
    is updated in a thousandth, hundredth, or even tenth of a second. The player will
    discern no difference. This means there is no point rebuilding strings that we
    set to the `Text` objects every frame.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'So we can time when and how often we update the HUD, add the following variables:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the previous code, we have variables to track how many frames it has been
    since the last time the HUD was updated and the interval, measured in frames,
    we would like to wait between HUD updates.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Now we can use these new variables and actually update the HUD each frame. We
    won't actually see all the HUD elements change, however, until we begin to manipulate
    the final variables, such as `wave`, in the next chapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the highlighted code in the update section of the game loop as shown:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the new code, we update the size of the `healthBar` sprite, increment the
    `timeSinceLastUpdate` object, then increment the `framesSinceLastUpdate` variable.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Next, we start an `if` block that tests whether `framesSinceLastHUDUpdate` is
    greater than our preferred interval, which is stored in `fpsMeasurementFrameInterval`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Inside this `if` block is where all the action takes place. First, we declare
    a string stream object for each string that we need to set to a `Text` object.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Then we use each of those string stream objects in turn, and use the `setString`
    function to set the result to the appropriate `Text` object.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Finally, before the `if` block is exited, the `framesSinceLastHUDUpdate` is
    set back to zero so that the count can begin again.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Now, when we redraw the scene, the new values will appear in the player's HUD.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the HUD, and the home and level up screens
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code from the next three code blocks goes in the drawing phase of our
    game loop. All we need to do is to draw the appropriate `Text` objects during
    the appropriate states in the draw section of the main game loop.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `PLAYING` state, add the following highlighted code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The vital thing to notice in the previous block of code is that we switch views
    to the HUD view. This causes everything to be drawn at the precise screen positions
    we gave to each of the elements of the HUD. They will never move.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `LEVELING_UP` state, add the following highlighted code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the `PAUSED` state, add the following highlighted code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the `GAME_OVER` state, add the following highlighted code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now we can run the game and see our HUD update during gameplay.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing the HUD, and the home and level up screens](img/image_10_001.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
- en: 'This shows the **HI SCORE** and score on the home/game over screen:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing the HUD, and the home and level up screens](img/image_10_002.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: 'Next we see text to show what the player''s level up options are, although
    these options don''t do anything yet:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing the HUD, and the home and level up screens](img/image_10_003.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: 'And here we see a helpful message on the pause screen:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing the HUD, and the home and level up screens](img/image_10_004.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
- en: Tip
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SFML Views are more powerful than this simple HUD can demonstrate. For an insight
    into the potential of SFML Views and how easy to use they are, take a look at
    the SFML website's tutorial on `View` at [http://www.sfml-dev.org/tutorials/2.0/graphics-view.php](http://www.sfml-dev.org/tutorials/2.0/graphics-view.php).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: FAQ
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a question that might be on your mind:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Q) Where can I see more of the power of the `View` class in action?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: A) Take a look at the enhanced edition of the **Zombie Arena** game in the download
    bundle. You can use the keyboard cursor keys to spin and zoom the action. Warning!
    Spinning the scene makes the controls awkward, but you get to see some of the
    things that can be done with the `View` class.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![FAQ](img/image_10_005.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: The zoom and rotate functionality was achieved with just a few lines of code
    in the input handling section of the main game loop. You can see the code in the
    `Zombie Arena Enhanced Version` folder of the download bundle or run the enhanced
    version from the `Runnable Games/Zombie Arena` folder.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That was a quick and simple chapter. We saw how to display the value, held by
    variables of different types using `sstream` and then draw them over the top of
    the main game action using a second SFML `View` object.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: We are nearly done with Zombie Arena now. All the screenshots show a small arena
    that doesn't take advantage of the full monitor. In the final chapter for this
    project, we will put in some finishing touches such as levelingup, sound effects,
    and saving the high-score . The arena can then grow to the same size as the monitor
    and far beyond.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在几乎完成了僵尸竞技场。所有的截图都显示了一个小竞技场，没有充分利用整个显示器。在这个项目的最后阶段，我们将加入一些最后的修饰，比如升级、音效和保存最高分。竞技场可以随后扩大到与显示器相同的大小甚至更大。
