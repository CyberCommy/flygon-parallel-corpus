- en: Chapter 2. Lambdas Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll introduce the ideas of lambdas, we''ll:'
  prefs: []
  type: TYPE_NORMAL
- en: Discuss some background to lambdas and functional programming in general
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Talk about functions versus classes in Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look at the basic syntax for lambdas in Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: λs in functional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we look at things in more depth, let's look at some general background
    to lambdas.
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't seen it before, the Greek letter λ (**lambda**) is often used
    as shorthand when talking about lambdas.
  prefs: []
  type: TYPE_NORMAL
- en: 1930s and the lambda calculus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In computer science, lambdas go back to the lambda-calculus. A mathematical
    notation for functions introduced by **Alonzo Church** in the 1930s. It was a
    way to explore mathematics using functions and was later re-discovered as a useful
    tool in computer science.
  prefs: []
  type: TYPE_NORMAL
- en: It formalized the notion of *lambda terms* and the rules to transform those
    terms. These rules or *functions* map directly into modern computer science ideas.
    All functions in the lambda-calculus are anonymous which again has been taken
    literally in computer science.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of a lambda-calculus expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A lambda-calculus expression**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This defines an anonymous function or *lambda* with a single argument `x`. The
    body follows the dot and adds one to that argument.
  prefs: []
  type: TYPE_NORMAL
- en: 1950s and LISP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the 1950s, *John McCarthy* invented LISP whilst at MIT. This was a programming
    language designed to model mathematical problems and was heavily influenced by
    the lambda-calculus.
  prefs: []
  type: TYPE_NORMAL
- en: It used the word lambda as an operator to define an anonymous function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A LISP expression**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This LISP expression evaluates to a function, that when applied will take a
    single argument, bind it to `arg` and then add `1` to it.
  prefs: []
  type: TYPE_NORMAL
- en: The two expressions produce the same thing, a function to increment a number.
    You can see the two are very similar.
  prefs: []
  type: TYPE_NORMAL
- en: The lambda-calculus and LISP have had a huge influence on functional programming.
    The ideas of applying functions and reasoning about problems using functions has
    moved directly into programming languages. Hence the use of the term in our field.
    A lambda in the calculus is the same thing as in modern programming languages
    and is used in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: What is a lambda
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In simple terms then, a lambda is just an anonymous function. That's it. Nothing
    special. It's just a compact way to define a function. Anonymous functions are
    useful when you want to pass around fragments of reusable functionality. For example,
    passing functions into other functions.
  prefs: []
  type: TYPE_NORMAL
- en: Many main stream languages already support lambdas including Scala, C#, Objective-C,
    Ruby, C++(11), Python and many others.
  prefs: []
  type: TYPE_NORMAL
- en: Functions vs classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bear in mind that an anonymous *function* isn't the same as an anonymous *class*
    in Java. An anonymous class in Java still needs to be instantiated to an object.
    It may not have a proper name, but it can be useful only when it's an object.
  prefs: []
  type: TYPE_NORMAL
- en: A *function* on the other hand has no instance associated with it. Functions
    are disassociated with the data they act on whereas an object is intimately associated
    with the data it acts upon.
  prefs: []
  type: TYPE_NORMAL
- en: You can use lambdas in modern Java anywhere you would have previously used a
    single method interface so it may just look like syntactic sugar but it's not.
    Let's have a look at how they differ and compare anonymous classes to lambdas;
    classes vs. functions.
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas in modern Java
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A typical implementation of an anonymous class (a single method interface)
    in Java pre-8, might look something like this. The `anonymousClass` method is
    calling the `waitFor` method, passing in some implementation of `Condition`; in
    this case, it''s saying, wait for some server to shutdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Typical usage of an anonymous class**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The functionally equivalent lambda would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Equivalent functionality as a lambda**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Where in the interest of completeness, a naive polling `waitFor` method might
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Some theoretical differences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Firstly, both implementations are in-fact closures, the latter is also a lambda.
    We'll look at this distinction in more detail later in the *Lambdas vs closures*
    section. It means that both have to capture their "environment" at runtime. In
    Java pre-8, this means copying the things the closure needs into an instance of
    an class (an anonymous instances of Condition). In our example, the server variable
    would need to be copied into the instance.
  prefs: []
  type: TYPE_NORMAL
- en: As it's a copy, it has to be declared final to ensure that it can not be changed
    between when it's captured and when it's used. These two points in time could
    be very different given that closures are often used to defer execution until
    some later point (see [lazy evaluation](http://en.wikipedia.org/wiki/Lazy_evaluation)
    for example). Modern Java uses a neat trick whereby if it can reason that a variable
    is never updated, it might as well be final so it treats it as *effectively final*
    and you don't need to declare it as final explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: A lambda on the other hand, doesn't need to copy it's environment or capture
    any terms. This means it can be treated as a genuine function and not an instance
    of a class. What's the difference? Plenty.
  prefs: []
  type: TYPE_NORMAL
- en: Functions vs classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a start, functions; [genuine functions](http://en.wikipedia.org/wiki/Pure_function),
    don't need to be instantiated many times. I'm not sure if instantiation is even
    the right word to use when talking about allocating memory and loading a chunk
    of machine code as a function. The point is, once it's available, it can be re-used,
    it's idempotent in nature as it retains no state. Static class methods are the
    closest thing Java has to functions.
  prefs: []
  type: TYPE_NORMAL
- en: For Java, this means that a lambda need not be instantiated every time it's
    evaluated which is a big deal. Unlike instantiating an anonymous class, the memory
    impact should be minimal.
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of some conceptual differences then:'
  prefs: []
  type: TYPE_NORMAL
- en: Classes must be instantiated, whereas functions are not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When classes are newed up, memory is allocated for the object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory need only be allocated once for functions. They are stored in the *permanent*
    area of the heap.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects act on their own data, functions act on unrelated data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static class methods in Java are roughly equivalent to functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some concrete differences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some concrete differences between functions and classes include their capture
    semantics and how they shadow variables.
  prefs: []
  type: TYPE_NORMAL
- en: Capture semantics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another difference is around capture semantics for this. In an anonymous class,
    this refers to the instance of the anonymous class. For example, `Foo$InnerClass`
    and not `Foo`. That's why you have slightly odd looking syntax like `Foo.this.x`
    when you refer to the enclosing scope from the anonymous class.
  prefs: []
  type: TYPE_NORMAL
- en: In lambdas on the other hand, this refers to the enclosing scope (Foo directly
    in our example). In fact, lambdas are **entirely lexically scoped**, meaning they
    don't inherit any names from a super type or introduce a new level of scoping
    at all; you can directly access fields, methods and local variables from the enclosing
    scope.
  prefs: []
  type: TYPE_NORMAL
- en: For example, this class shows that the lambda can reference the `firstName`
    variable directly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, `firstName` is shorthand for `this.firstName` and because this refers
    to the enclosing scope (the class `Example`), it's value will be "Jack".
  prefs: []
  type: TYPE_NORMAL
- en: 'The anonymous class equivalent would need to explicitly refer to `firstName`
    from the enclosing scope. You can''t use this as in this context, this means the
    anonymous instance and there is no `firstName` there. So, the following will compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: but this will not.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You could still access the field directly (that is, simply calling return `firstName
    + " " + surname`) but you can't do so using this. The point here is to demonstrate
    the difference in capture schematics for this when used in lambdas vs. anonymous
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: Shadowed variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Referencing shadowed variables becomes much more straight forward to reason
    about with the simplified `this` semantics. For example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, because `this` is inside the lambda, it refers to the enclosing scope.
    So `this.firstName` will have the value `"Charlie"` and not the method parameter
    of the same name. The capture semantics make it clearer. If you use `firstName`
    (and drop the `this`), it will refer to the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next example, using an anonymous instance, `firstName` simply refers
    to the parameter. If you want to refer to the enclosing version, you''d use `Example.this.firstName`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions in the academic sense are very different things from anonymous classes
    (which we often treat like functions in Java pre-8). It's useful to understand
    the distinctions to be able to justify the use of lambdas for something other
    than just their concise syntax. Of course, there's lots of additional advantages
    in using lambdas (not least the retrofit of the JDK to heavily use them).
  prefs: []
  type: TYPE_NORMAL
- en: When we take a look at the new lambda syntax next, remember that although lambdas
    are used in a very similar way to anonymous classes in Java, they are technically
    different. Lambdas in Java need not be instantiated every time they're evaluated
    unlike an instance of an anonymous class.
  prefs: []
  type: TYPE_NORMAL
- en: This should serve to remind you that lambdas in Java are not just syntactic
    sugar.
  prefs: []
  type: TYPE_NORMAL
- en: λ basic syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a look at the basic lambda syntax.
  prefs: []
  type: TYPE_NORMAL
- en: A lambda is basically an anonymous block of functionality. It's a lot like using
    an anonymous class instance. For example, if we want to sort an array in Java,
    we can use the `Arrays.sort` method which takes an instance of the `Comparator`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'It would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `Comparator` instance here is a an abstract piece of the functionality;
    it means nothing on its own; it's only when it's used by the `sort` method that
    it has purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Java''s new syntax, you can replace this with a lambda which looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It's a more succinct way of achieving the same thing. In fact, Java treats this
    as if it were an instance of the `Comparator` class. If we were to extract a variable
    for the lambda (the second parameter), it's type would be `Comparator<Integer>`
    just like the anonymous instance above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Because `Comparator` has only a single abstract method on it; `compareTo`, the
    compiler can piece together that when we have an anonymous block like this, we
    really mean an instance of `Comparator`. It can do this thanks to a couple of
    the other new features that we'll talk about later; functional interfaces and
    improvements to type inference.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax breakdown
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can always convert from using a single abstract method to a using lambda.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we have an an interface `Example` with a method `apply`, returning
    some type and taking some argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We could instantiate an instance with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: And to convert to a lambda, we basically trim the fat. We drop the instantiation
    and annotation, drop the method details which leaves just the argument list and
    the body.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'we then introduce the new arrow symbol to indicate both that the whole thing
    is a lambda and that what follows is the body and that''s our basic lambda syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take the sorting example from earlier through these steps. We start
    with the anonymous instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'and trim the instantiation and method signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: introduce the lambda
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: and we're done. There's a couple of optimizations we can do though. You can
    drop the types if the compiler knows enough to infer them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'and for simple expressions, you can drop the braces to produce a lambda expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the compiler can infer enough to know what you mean. The single
    statement returns a value consistent with the interface, so it says, "no need
    to tell me that you're going to return something, I can see that for myself".
  prefs: []
  type: TYPE_NORMAL
- en: For single argument interface methods, you can even drop the first brackets.
    For example the lambda taking an argument `x` and returning `x + 1`;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: can be written without the brackets
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's recap with a summary of the syntax options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntax Summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The first example `((int x, int y) -> { return x + y; })` is the most verbose
    way to create a lambda. The arguments to the function along with their types are
    in parenthesis, followed by the new arrow syntax and then the body; the code block
    to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: You can often drop the types from the argument list, like `(x, y) -> { return
    x + y; }`. The compiler will use type inference here to try and guess the types.
    It does this based on the context that you're trying to use the lambda in.
  prefs: []
  type: TYPE_NORMAL
- en: If your code block returns something or is a single line expression, you can
    drop the braces and return statement, for example `(x, y) -> x + y;`.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of only a single argument, you can drop the parentheses `x -> x
    * 2`.
  prefs: []
  type: TYPE_NORMAL
- en: If you have no arguments at all, the "hamburger" symbol is needed,
  prefs: []
  type: TYPE_NORMAL
- en: '`() -> System.out.println("Hey there!");`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the interest of completeness, there is another variation; a kind of shortcut
    to a lambda called a *method reference*. An example is something like `System.out::println;`,
    which is basically a short cut to the lambda `(value -> System.out.prinltn(value)`.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to talk about method references in more detail later, so for now,
    just be aware that they exist and can be used anywhere you can use a lambda.
  prefs: []
  type: TYPE_NORMAL
