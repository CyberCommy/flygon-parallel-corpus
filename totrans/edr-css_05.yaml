- en: Chapter 5. File Organisation and Naming Conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter we took a high-level overview of the design considerations
    of ECSS. In this chapter we will start digging a little deeper into how we actually
    get started using ECSS.
  prefs: []
  type: TYPE_NORMAL
- en: Two cornerstones of making ECSS work for you are adhering to the file organisation
    and class naming convention principles. Let's look at each of these aspects next.
  prefs: []
  type: TYPE_NORMAL
- en: Project organisation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we want to facilitate the easy removal of code from our website/application,
    we need to think about the way we organise the files that make up our project.
    Typically, when building websites, particularly web applications, it's useful
    to think in terms of modules or components; definable sections of the user interface.
    These modules might be defined primarily by visual areas or perhaps due to the
    files that generate them. Either way, taking the time to consider the organisation
    of these modules is well worth the time investment.
  prefs: []
  type: TYPE_NORMAL
- en: Ordinarily, it's a common practice to split the files in a project by technology
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this basic folder structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In each of these folders you might name related files. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The rub though is that beyond a certain point, even giving the files related
    names, it's difficult to reason about how each style sheet, logic file and template
    in a project relate. There might be 80+ CSS partials in the `css` folder and 50+
    template stubs in the `html` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I recognise the reality is that the *view* part of a website or application
    is usually generated by any number of different technologies such as Ruby, PHP,
    .NET or even JavaScript - rather than vanilla HTML.
  prefs: []
  type: TYPE_NORMAL
- en: It then becomes increasingly necessary to rely on *find* in the text editor/IDE
    to find any templates that a certain class is being used on. The same is true
    in reverse; *find* is needed to locate the partial(s) that contain the styles
    needed for a certain module template.
  prefs: []
  type: TYPE_NORMAL
- en: This structure doesn't make things unworkable, just inefficient and it typically
    requires a little mental orientation to remember what goes with what.
  prefs: []
  type: TYPE_NORMAL
- en: 'While not essential for ECSS, it''s generally preferable that rather than organise
    by technology type, files are organised and grouped by visual or logical component.
    So, instead of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We aim for something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: At first glance this may seem like a seemingly unimportant distinction but it
    brings important benefits.
  prefs: []
  type: TYPE_NORMAL
- en: The code for each component becomes physically self-enclosed. Then, on our enduring
    project, when features need changing or are deprecated, all associated code for
    that module (styles, view logic (HTML), and JS) can be easily updated/removed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Due credit**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Nicolas Gallagher* ([http://nicolasgallagher.com/](http://nicolasgallagher.com/))
    is always ahead of the game when it comes to thinking about CSS implementations
    at scale and I took and adapted large elements (specifically code organisation
    by component) of this approach from his work. I''d been name-spacing components
    for some time (and I''m therefore claiming pseudo multiple discovery) but the
    approach of organising code by component is taken entirely from *hearing him talk*
    ([https://www.youtube.com/watch?v=m0oMHG6ZXvo](https://www.youtube.com/watch?v=m0oMHG6ZXvo))
    on this matter.'
  prefs: []
  type: TYPE_NORMAL
- en: With the exception of intentionally *global* CSS, all code that relates to the
    presentation of a component or module should be included in the partials that
    sit alongside the HTML/JS of that component.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although you may not like it, there's always a degree of global CSS needed;
    at the very least a simple set of reset or normalise styles for example.
  prefs: []
  type: TYPE_NORMAL
- en: When a module is deprecated, all files associated with it can be easily removed
    from the codebase in one go; just delete the folder containing the module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to be crystal clear, consider this folder structure for our imagined `ShoppingCart`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now suppose we create a new shopping cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As soon as our `v2` shopping cart is finished, it's easy to remove the code
    for the prior version from our code base; we just delete the folder `ShoppingCart`
    containing our old code.
  prefs: []
  type: TYPE_NORMAL
- en: When same folder organisation isn't possible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It may not be possible or preferable to contain style sheets, assets, and application
    logic within the same folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that situation, the next best choice is to mimic the structure of the logic.
    To exemplify. Suppose the logic for a component is stored in a folder structure
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We should mimic this structure as far as possible. On any sizeable application
    this will make locating related files easier. So we might do this – matching the
    folder hierarchy of the logic file as much as possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Same parent folder should definitely be considered the *gold* standard when
    using ECSS but in the absence of that, mimicking the structure of the logic files
    should provide some of the benefits.
  prefs: []
  type: TYPE_NORMAL
- en: With a concrete idea of how to organise the files within our project, let's
    turn to the principle way in which we can convey additional meaning and developer
    convenience to our selectors/classes.
  prefs: []
  type: TYPE_NORMAL
- en: Naming classes and selectors with ECSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back in [Chapter 3](ch03.html "Chapter 3. Implementing Received Wisdom"), *Implementing
    Received Wisdom*, I recognised the benefits that the BEM approach of naming CSS
    selectors gave us. Naming a block and then naming any child elements in relation
    to that block created a namespace for the child elements.
  prefs: []
  type: TYPE_NORMAL
- en: Namespacing the CSS of a module creates a form of isolation. By preventing name
    collisions with other elements, chunks of CSS can be more easily moved from one
    environment to another (from prototype to production for example). It's also far
    less likely that a change of styles on one selector would inadvertently affect
    another.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of other approaches to solve the name collision problem.
    For example, if you are building an application with the popular *React* ([https://facebook.github.io/react/](https://facebook.github.io/react/))
    framework, consider *Radium* ([https://github.com/FormidableLabs/radium](https://github.com/FormidableLabs/radium))
    which will inline the styles for each node so you can effectively serve no CSS
    at all. Naturally, there are trade-offs such as a lack of caching and no way to
    add reset styles but it it certainly solves the issue at hand. In addition, when
    not building with React, consider *CSS Modules* ([https://github.com/css-modules/css-modules](https://github.com/css-modules/css-modules)).
    While requiring more involved tooling than ECSS it means you could forgo having
    to think about naming things altogether as it creates CSS scoped for you. Read
    *more about that here* ([https://medium.com/seek-ui-engineering/the-end-of-global-css-90d2a4a06284](https://medium.com/seek-ui-engineering/the-end-of-global-css-90d2a4a06284)).
  prefs: []
  type: TYPE_NORMAL
- en: 'ECSS takes the notion of selector namespacing and turns it *up to 11* ([https://en.wikipedia.org/wiki/Up_to_eleven](https://en.wikipedia.org/wiki/Up_to_eleven)).
    Selectors are effectively namespaced in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A micro namespace: usually used to designate context but can also indicate
    a parent module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The module''s own namespace: usually the name of the logic file that created
    the element in question'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at these in more detail. The *micro* namespace is a simple 2–3 letter
    namespace for each module. Building a shopping cart? Try`.` `sc-` as your micro
    namespace. Building the next version of that same shopping cart? That'll be`.`
    `sc2-` then. It's just enough to isolate your component styles and allow the styles
    to be more self documenting. Let's consider a more involved example.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When it comes to naming things, different things will make sense in different
    projects. While ECSS can happily adapt to different approaches, I would recommend
    a consistent approach on each project.
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose the micro namespace was being used to convey the parent
    or origin of the logic that created it. Back to our shopping cart example. We
    might have a file called `ShoppingCart.php` that contains all the logic relating
    to our imaginary shopping cart. We could therefore use `sc-` as an abbreviation
    of that file name so we know that any elements that begin with that namespace
    relate to the shopping cart and are rendered by that related file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we would then have selectors like:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sc-Title` : The title of the shopping cart'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sc-RemoveBtn` : A button that removes an item from the shopping cart'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here the selectors are quite compact-aesthetically pleasing if a selector can
    even be described in that way. However, suppose we have a shopping cart which
    can live in multiple contexts. A mini cart view and a full page view. In that
    instance we might decide to use the micro namespace to convey context. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mc-ShoppingCart_Title` : The title of the shopping cart, generated by the
    file `ShoppingCart` when in the *mini cart* view/context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mc-ShoppingCart_RemoveBtn` : The remove button of the shopping cart, generated
    by the file `ShoppingCart` when in the *mini cart* view/context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Neither of these is the one true way. Part of ECSS philosophy is that while
    some core principles are essential, it can adapt to differing needs. Generally
    speaking, for smaller scale use cases, the former approach is fine. However, despite
    the comparative verbosity of the selectors in the second approach, it is the most
    resilient and self-documenting. With the second approach you know context, the
    file that generated the selector (and therefore the module it belongs to) and
    the element it relates to.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is more specific information about applying ECSS conventions to web applications
    and visual modules in [Chapter 7](ch07.html "Chapter 7. Applying ECSS to Your
    Website or Application"), *Applying ECSS to Your Website or Application*.
  prefs: []
  type: TYPE_NORMAL
- en: Reiterating the benefits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As namespaced modules and components are almost guaranteed to not leak into
    one another, it makes it incredibly easy to build out and iterate on new designs.
    It affords a hitherto un-thinkable blanket of impunity. Just make a new partial
    file for the thing you are building, assign a suitable micro-namespace and module
    name and write your styles, confident in the fact you won't be adversely affecting
    anything you don't want to. If the new thing you are building doesn't work out,
    you can just delete the partial file, also confident that you won't be removing
    the styles for something else. CSS authoring and maintenance confidence - finally!
  prefs: []
  type: TYPE_NORMAL
- en: Source order becomes unimportant
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As our rules are now isolated, it makes the order of rules in a style sheet
    unimportant. This benefit becomes essential when working on a large-scale project.
    In these scenarios it is often preferable for partial files to be assembled in
    any order. With rules isolated from each other, this is simple. With our *self-quarantined* rules,
    it makes file globbing of partial styles sheets simple and risk free. With some
    basic tooling in place you can compile all the CSS partials within a module in
    one fell swoop like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: No more writing `@import` statements for every partial in a project and worrying
    about the order they are in.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will talk more about file globbing in [Chapter 9](ch09.html "Chapter 9. Tooling
    for an ECSS Approach"), *Tooling for an ECSS Approach*.
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of the ECSS naming convention
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the naming of items is so useful and essential to achieving our goals, the
    following section documents the naming convention of ECSS in more detail. Think
    of this like a *Haynes manual* ([https://haynes.co.uk/catalog/manuals-online](https://haynes.co.uk/catalog/manuals-online))
    for your CSS selectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a breakdown of an ECSS selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To illustrate the separate sections, here is the anatomy of that selector with
    the sections delineated with square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With more than a couple of developers on a project I'd recommended that commits
    to a codebase are automatically rejected that don't follow the ECSS naming pattern.
    Some information on necessary tooling to facilitate this is covered in [Chapter
    9](ch09.html "Chapter 9. Tooling for an ECSS Approach"), *Tooling for an ECSS
    Approach*.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation of selector sections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s go back over the various parts of the ECSS selector and the allowed
    character types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Namespace`: This is a **required** part of every selector. The micro-namespace
    should be all lowercase/train-case. It is typically an abbreviation to denote
    context or originating logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Module or Component`: This is a upper camel case/pascal case. It should always
    be preceded by a hyphen character (`-`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ChildNode`: This is an optional section of the selector. It should be upper
    camel case/pascal case and preceded by an underscore (`_`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Variant`: This is a further optional section of the selector. It should be
    written all lowercase/train-case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using this syntax, each part of a class name can be logically discerned from
    another. More information on what these sections are and how they should be employed
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Namespace
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As discussed above, the first part of a HTML class/CSS selector is the micro
    namespace (all lowercase/train-case). The namespace is used to prevent collisions
    and provide some soft isolation for easier maintenance of rules.
  prefs: []
  type: TYPE_NORMAL
- en: Module or Component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the visual module or piece of logic that created the selector. It should
    be written in upper camel case. I've seen ECSS applied to great effect when the
    module or component directly references the name of the file that creates it.
    For example, a file called `CallOuts.js` could have a selector such as `sw-CallOuts`
    (the `sw-` micro namespace here used to denote it would be used *Site Wide*).
    This removes any ambiguity for future developers as to the origin point of this
    element.
  prefs: []
  type: TYPE_NORMAL
- en: Child node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If something UpperCamelCase is preceded by an underscore (`_`) it is a child
    node of a module or component.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, `_Header` is indicating that this node is the `Header` child node of the
    `Item` module or component that belongs to the `sc` namespace (and if it it were
    a component, that namespace could indicate the parent module).
  prefs: []
  type: TYPE_NORMAL
- en: Variant
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If something is all lowercase/train-case and not the first part of a class
    name it is a variant flag. The variant flag is reserved for eventualities where
    many variants of a selector need to be referenced. Suppose we have a module that
    needs to display a different background image depending upon what category number
    has been assigned to it. We might use the variant indicator like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here the `-bg3` part of the selector indicates that this`.` `sc-Item_Header`
    is the category 3 version (and can therefore have an appropriate style assigned).
  prefs: []
  type: TYPE_NORMAL
- en: Doubling up on ECSS selectors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our previous example indicates a perfect situation where it would be appropriate
    to use two classes on the element. One to assign default styles and another to
    set specifics of a variant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here we would set the universal styles for the element with `sc-Item_Header`
    and then the styles specific to the variant with `sc-Item_Header-bg1`. There's
    nothing revolutionary about this approach, I'm just documenting it here to make
    it clear there is nothing in the ECSS approach that precludes this practice.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve covered a lot of detail in this chapter. The two main areas we looked
    at were how to organise the language files of our project so that they can be
    more easily maintained and how to name HTML classes/CSS selectors in ECSS so that
    the class of an element in the DOM can tell us everything we need to know about
    its origin, purpose and intended context. We also had a detailed look at the accepted
    syntax for ECSS selectors: where and how to apply casing differences to delineate
    different parts of the selector. So far, we have only concerned ourself with static
    elements. In the next chapter we will look at how ECSS deals with the changing
    state of a website or application.'
  prefs: []
  type: TYPE_NORMAL
