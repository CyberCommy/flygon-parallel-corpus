- en: Chapter 5. File Organisation and Naming Conventions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。文件组织和命名约定
- en: In the last chapter we took a high-level overview of the design considerations
    of ECSS. In this chapter we will start digging a little deeper into how we actually
    get started using ECSS.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们对ECSS的设计考虑进行了高层次的概述。在本章中，我们将深入探讨如何实际开始使用ECSS。
- en: Two cornerstones of making ECSS work for you are adhering to the file organisation
    and class naming convention principles. Let's look at each of these aspects next.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 使ECSS适合您的两个基石是遵守文件组织和类命名约定原则。让我们接下来看看这些方面。
- en: Project organisation
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目组织
- en: If we want to facilitate the easy removal of code from our website/application,
    we need to think about the way we organise the files that make up our project.
    Typically, when building websites, particularly web applications, it's useful
    to think in terms of modules or components; definable sections of the user interface.
    These modules might be defined primarily by visual areas or perhaps due to the
    files that generate them. Either way, taking the time to consider the organisation
    of these modules is well worth the time investment.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要方便地从我们的网站/应用程序中删除代码，我们需要考虑我们组成项目的文件的方式。通常，在构建网站，特别是Web应用程序时，考虑模块或组件的方式是有用的；可定义的用户界面部分。这些模块可能主要由视觉区域定义，或者可能由生成它们的文件定义。无论哪种方式，花时间考虑这些模块的组织都是值得的。
- en: Ordinarily, it's a common practice to split the files in a project by technology
    type.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，按技术类型将项目中的文件拆分是一种常见做法。
- en: 'Consider this basic folder structure:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个基本的文件夹结构：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In each of these folders you might name related files. For example:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些文件夹中，您可能会命名相关文件。例如：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The rub though is that beyond a certain point, even giving the files related
    names, it's difficult to reason about how each style sheet, logic file and template
    in a project relate. There might be 80+ CSS partials in the `css` folder and 50+
    template stubs in the `html` folder.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，问题在于，超过一定程度后，即使给文件命名，也很难理清项目中每个样式表、逻辑文件和模板之间的关系。在`css`文件夹中可能有80多个CSS部分，在`html`文件夹中可能有50多个模板存根。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: I recognise the reality is that the *view* part of a website or application
    is usually generated by any number of different technologies such as Ruby, PHP,
    .NET or even JavaScript - rather than vanilla HTML.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我意识到现实情况是，网站或应用程序的*view*部分通常是由多种不同的技术生成的，如Ruby、PHP、.NET甚至JavaScript - 而不是纯粹的HTML。
- en: It then becomes increasingly necessary to rely on *find* in the text editor/IDE
    to find any templates that a certain class is being used on. The same is true
    in reverse; *find* is needed to locate the partial(s) that contain the styles
    needed for a certain module template.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，越来越需要依赖*find*在文本编辑器/IDE中查找某个类别正在使用的任何模板。反之亦然；需要*find*来定位包含某个模块模板所需样式的部分。
- en: This structure doesn't make things unworkable, just inefficient and it typically
    requires a little mental orientation to remember what goes with what.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构并不会使事情变得不可行，只是效率低下，通常需要一点心理定位来记住什么与什么相关。
- en: 'While not essential for ECSS, it''s generally preferable that rather than organise
    by technology type, files are organised and grouped by visual or logical component.
    So, instead of this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对于ECSS来说并非必需，但通常更倾向于按视觉或逻辑组件组织文件，而不是按技术类型组织。因此，不是这样：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We aim for something like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是这样的：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: At first glance this may seem like a seemingly unimportant distinction but it
    brings important benefits.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这似乎是一个看似不重要的区别，但它带来了重要的好处。
- en: The code for each component becomes physically self-enclosed. Then, on our enduring
    project, when features need changing or are deprecated, all associated code for
    that module (styles, view logic (HTML), and JS) can be easily updated/removed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组件的代码都是物理上自包含的。然后，在我们持久的项目中，当需要更改或废弃功能时，可以轻松更新/删除与该模块相关的所有代码（样式、视图逻辑（HTML）和JS）。
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Due credit**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**应有的赞誉**'
- en: '*Nicolas Gallagher* ([http://nicolasgallagher.com/](http://nicolasgallagher.com/))
    is always ahead of the game when it comes to thinking about CSS implementations
    at scale and I took and adapted large elements (specifically code organisation
    by component) of this approach from his work. I''d been name-spacing components
    for some time (and I''m therefore claiming pseudo multiple discovery) but the
    approach of organising code by component is taken entirely from *hearing him talk*
    ([https://www.youtube.com/watch?v=m0oMHG6ZXvo](https://www.youtube.com/watch?v=m0oMHG6ZXvo))
    on this matter.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*Nicolas Gallagher* ([http://nicolasgallagher.com/](http://nicolasgallagher.com/))
    在考虑规模化的CSS实现时总是领先一步，我从他的工作中借鉴并调整了大部分元素（特别是按组件组织代码）。我已经为组件命名空间化了一段时间（因此我宣称伪多重发现），但按组件组织代码的方法完全是从*听他谈论*
    ([https://www.youtube.com/watch?v=m0oMHG6ZXvo](https://www.youtube.com/watch?v=m0oMHG6ZXvo))
    中得来的。'
- en: With the exception of intentionally *global* CSS, all code that relates to the
    presentation of a component or module should be included in the partials that
    sit alongside the HTML/JS of that component.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除了有意的*全局*CSS之外，与组件或模块的呈现相关的所有代码都应包含在与该组件的HTML/JS并列的部分中。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although you may not like it, there's always a degree of global CSS needed;
    at the very least a simple set of reset or normalise styles for example.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可能不喜欢，但总是需要一定程度的全局CSS；至少需要一组简单的重置或规范化样式。
- en: When a module is deprecated, all files associated with it can be easily removed
    from the codebase in one go; just delete the folder containing the module.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个模块被废弃时，可以轻松地一次性从代码库中删除与之相关的所有文件；只需删除包含该模块的文件夹。
- en: 'Just to be crystal clear, consider this folder structure for our imagined `ShoppingCart`
    component:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确，考虑我们想象中的`ShoppingCart`组件的文件夹结构：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now suppose we create a new shopping cart:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们创建一个新的购物车：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As soon as our `v2` shopping cart is finished, it's easy to remove the code
    for the prior version from our code base; we just delete the folder `ShoppingCart`
    containing our old code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: When same folder organisation isn't possible
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It may not be possible or preferable to contain style sheets, assets, and application
    logic within the same folder.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'In that situation, the next best choice is to mimic the structure of the logic.
    To exemplify. Suppose the logic for a component is stored in a folder structure
    like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We should mimic this structure as far as possible. On any sizeable application
    this will make locating related files easier. So we might do this – matching the
    folder hierarchy of the logic file as much as possible:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Same parent folder should definitely be considered the *gold* standard when
    using ECSS but in the absence of that, mimicking the structure of the logic files
    should provide some of the benefits.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: With a concrete idea of how to organise the files within our project, let's
    turn to the principle way in which we can convey additional meaning and developer
    convenience to our selectors/classes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Naming classes and selectors with ECSS
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back in [Chapter 3](ch03.html "Chapter 3. Implementing Received Wisdom"), *Implementing
    Received Wisdom*, I recognised the benefits that the BEM approach of naming CSS
    selectors gave us. Naming a block and then naming any child elements in relation
    to that block created a namespace for the child elements.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Namespacing the CSS of a module creates a form of isolation. By preventing name
    collisions with other elements, chunks of CSS can be more easily moved from one
    environment to another (from prototype to production for example). It's also far
    less likely that a change of styles on one selector would inadvertently affect
    another.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of other approaches to solve the name collision problem.
    For example, if you are building an application with the popular *React* ([https://facebook.github.io/react/](https://facebook.github.io/react/))
    framework, consider *Radium* ([https://github.com/FormidableLabs/radium](https://github.com/FormidableLabs/radium))
    which will inline the styles for each node so you can effectively serve no CSS
    at all. Naturally, there are trade-offs such as a lack of caching and no way to
    add reset styles but it it certainly solves the issue at hand. In addition, when
    not building with React, consider *CSS Modules* ([https://github.com/css-modules/css-modules](https://github.com/css-modules/css-modules)).
    While requiring more involved tooling than ECSS it means you could forgo having
    to think about naming things altogether as it creates CSS scoped for you. Read
    *more about that here* ([https://medium.com/seek-ui-engineering/the-end-of-global-css-90d2a4a06284](https://medium.com/seek-ui-engineering/the-end-of-global-css-90d2a4a06284)).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'ECSS takes the notion of selector namespacing and turns it *up to 11* ([https://en.wikipedia.org/wiki/Up_to_eleven](https://en.wikipedia.org/wiki/Up_to_eleven)).
    Selectors are effectively namespaced in two ways:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'A micro namespace: usually used to designate context but can also indicate
    a parent module'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The module''s own namespace: usually the name of the logic file that created
    the element in question'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at these in more detail. The *micro* namespace is a simple 2–3 letter
    namespace for each module. Building a shopping cart? Try`.` `sc-` as your micro
    namespace. Building the next version of that same shopping cart? That'll be`.`
    `sc2-` then. It's just enough to isolate your component styles and allow the styles
    to be more self documenting. Let's consider a more involved example.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When it comes to naming things, different things will make sense in different
    projects. While ECSS can happily adapt to different approaches, I would recommend
    a consistent approach on each project.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose the micro namespace was being used to convey the parent
    or origin of the logic that created it. Back to our shopping cart example. We
    might have a file called `ShoppingCart.php` that contains all the logic relating
    to our imaginary shopping cart. We could therefore use `sc-` as an abbreviation
    of that file name so we know that any elements that begin with that namespace
    relate to the shopping cart and are rendered by that related file.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we would then have selectors like:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '`sc-Title` : The title of the shopping cart'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sc-RemoveBtn` : A button that removes an item from the shopping cart'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here the selectors are quite compact-aesthetically pleasing if a selector can
    even be described in that way. However, suppose we have a shopping cart which
    can live in multiple contexts. A mini cart view and a full page view. In that
    instance we might decide to use the micro namespace to convey context. For example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '`mc-ShoppingCart_Title` : The title of the shopping cart, generated by the
    file `ShoppingCart` when in the *mini cart* view/context.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mc-ShoppingCart_RemoveBtn` : The remove button of the shopping cart, generated
    by the file `ShoppingCart` when in the *mini cart* view/context.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Neither of these is the one true way. Part of ECSS philosophy is that while
    some core principles are essential, it can adapt to differing needs. Generally
    speaking, for smaller scale use cases, the former approach is fine. However, despite
    the comparative verbosity of the selectors in the second approach, it is the most
    resilient and self-documenting. With the second approach you know context, the
    file that generated the selector (and therefore the module it belongs to) and
    the element it relates to.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is more specific information about applying ECSS conventions to web applications
    and visual modules in [Chapter 7](ch07.html "Chapter 7. Applying ECSS to Your
    Website or Application"), *Applying ECSS to Your Website or Application*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Reiterating the benefits
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As namespaced modules and components are almost guaranteed to not leak into
    one another, it makes it incredibly easy to build out and iterate on new designs.
    It affords a hitherto un-thinkable blanket of impunity. Just make a new partial
    file for the thing you are building, assign a suitable micro-namespace and module
    name and write your styles, confident in the fact you won't be adversely affecting
    anything you don't want to. If the new thing you are building doesn't work out,
    you can just delete the partial file, also confident that you won't be removing
    the styles for something else. CSS authoring and maintenance confidence - finally!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Source order becomes unimportant
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As our rules are now isolated, it makes the order of rules in a style sheet
    unimportant. This benefit becomes essential when working on a large-scale project.
    In these scenarios it is often preferable for partial files to be assembled in
    any order. With rules isolated from each other, this is simple. With our *self-quarantined* rules,
    it makes file globbing of partial styles sheets simple and risk free. With some
    basic tooling in place you can compile all the CSS partials within a module in
    one fell swoop like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: No more writing `@import` statements for every partial in a project and worrying
    about the order they are in.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will talk more about file globbing in [Chapter 9](ch09.html "Chapter 9. Tooling
    for an ECSS Approach"), *Tooling for an ECSS Approach*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of the ECSS naming convention
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the naming of items is so useful and essential to achieving our goals, the
    following section documents the naming convention of ECSS in more detail. Think
    of this like a *Haynes manual* ([https://haynes.co.uk/catalog/manuals-online](https://haynes.co.uk/catalog/manuals-online))
    for your CSS selectors.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a breakdown of an ECSS selector:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To illustrate the separate sections, here is the anatomy of that selector with
    the sections delineated with square brackets:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With more than a couple of developers on a project I'd recommended that commits
    to a codebase are automatically rejected that don't follow the ECSS naming pattern.
    Some information on necessary tooling to facilitate this is covered in [Chapter
    9](ch09.html "Chapter 9. Tooling for an ECSS Approach"), *Tooling for an ECSS
    Approach*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个项目中有多个开发人员的情况下，我建议对不遵循ECSS命名模式的代码提交进行自动拒绝。关于必要的工具支持的一些信息在[第9章](ch09.html
    "第9章 工具支持ECSS方法")中有所涉及，*工具支持ECSS方法*。
- en: Explanation of selector sections
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择器部分的解释
- en: 'Let''s go back over the various parts of the ECSS selector and the allowed
    character types:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下ECSS选择器的各个部分和允许的字符类型：
- en: '`Namespace`: This is a **required** part of every selector. The micro-namespace
    should be all lowercase/train-case. It is typically an abbreviation to denote
    context or originating logic.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Namespace`：这是每个选择器的**必需**部分。微命名空间应该全部小写/短横线命名法。通常是一个缩写，用于表示上下文或起始逻辑。'
- en: '`Module or Component`: This is a upper camel case/pascal case. It should always
    be preceded by a hyphen character (`-`).'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`模块或组件`：这是大驼峰命名法。它应该始终前面有一个连字符（`-`）。'
- en: '`ChildNode`: This is an optional section of the selector. It should be upper
    camel case/pascal case and preceded by an underscore (`_`).'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ChildNode`：这是选择器的一个可选部分。它应该是大驼峰命名法，并且前面有一个下划线（`_`）。'
- en: '`Variant`: This is a further optional section of the selector. It should be
    written all lowercase/train-case.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Variant`：这是选择器的另一个可选部分。它应该全部小写/短横线命名法。'
- en: 'Using this syntax, each part of a class name can be logically discerned from
    another. More information on what these sections are and how they should be employed
    follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种语法，类名的每个部分都可以从另一个逻辑上区分出来。更多关于这些部分是什么以及它们应该如何使用的信息如下：
- en: Namespace
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名空间
- en: As discussed above, the first part of a HTML class/CSS selector is the micro
    namespace (all lowercase/train-case). The namespace is used to prevent collisions
    and provide some soft isolation for easier maintenance of rules.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，HTML类/CSS选择器的第一部分是微命名空间（全部小写/短横线命名法）。命名空间用于防止冲突，并为规则的更轻松维护提供一些软隔离。
- en: Module or Component
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块或组件
- en: This is the visual module or piece of logic that created the selector. It should
    be written in upper camel case. I've seen ECSS applied to great effect when the
    module or component directly references the name of the file that creates it.
    For example, a file called `CallOuts.js` could have a selector such as `sw-CallOuts`
    (the `sw-` micro namespace here used to denote it would be used *Site Wide*).
    This removes any ambiguity for future developers as to the origin point of this
    element.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建选择器的视觉模块或逻辑片段。它应该用大驼峰命名法。我看到ECSS被成功应用时，模块或组件直接引用了创建它的文件的名称。例如，一个名为`CallOuts.js`的文件可以有一个选择器，如`sw-CallOuts`（这里的`sw-`微命名空间用于表示它将被*站点范围*使用）。这样可以消除未来开发人员对该元素起点的歧义。
- en: Child node
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子节点
- en: If something UpperCamelCase is preceded by an underscore (`_`) it is a child
    node of a module or component.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个大驼峰命名法前面有一个下划线（`_`），那么它是模块或组件的子节点。
- en: 'For example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, `_Header` is indicating that this node is the `Header` child node of the
    `Item` module or component that belongs to the `sc` namespace (and if it it were
    a component, that namespace could indicate the parent module).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`_Header`表示这个节点是属于`sc`命名空间的`Item`模块或组件的`Header`子节点（如果它是一个组件，那么该命名空间可以表示父模块）。
- en: Variant
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变体
- en: 'If something is all lowercase/train-case and not the first part of a class
    name it is a variant flag. The variant flag is reserved for eventualities where
    many variants of a selector need to be referenced. Suppose we have a module that
    needs to display a different background image depending upon what category number
    has been assigned to it. We might use the variant indicator like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个东西全部小写/短横线命名法，并且不是类名的第一部分，那么它是一个变体标志。变体标志保留用于需要引用许多选择器变体的情况。假设我们有一个模块，需要根据分配给它的类别编号显示不同的背景图像。我们可以像这样使用变体指示器：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here the `-bg3` part of the selector indicates that this`.` `sc-Item_Header`
    is the category 3 version (and can therefore have an appropriate style assigned).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里选择器的`-bg3`部分表示这个`sc-Item_Header`是类别3版本（因此可以分配适当的样式）。
- en: Doubling up on ECSS selectors
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在ECSS选择器上加倍
- en: Our previous example indicates a perfect situation where it would be appropriate
    to use two classes on the element. One to assign default styles and another to
    set specifics of a variant.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的例子表明了一个完美的情况，适合在元素上使用两个类。一个用于分配默认样式，另一个用于设置变体的具体内容。
- en: 'Consider this markup:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个标记：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here we would set the universal styles for the element with `sc-Item_Header`
    and then the styles specific to the variant with `sc-Item_Header-bg1`. There's
    nothing revolutionary about this approach, I'm just documenting it here to make
    it clear there is nothing in the ECSS approach that precludes this practice.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用`sc-Item_Header`为元素设置通用样式，然后使用`sc-Item_Header-bg1`为变体设置特定样式。这种方法并不具有革命性，我只是在这里记录它，以明确指出ECSS方法中没有任何阻止这种做法的地方。
- en: Summary
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'We''ve covered a lot of detail in this chapter. The two main areas we looked
    at were how to organise the language files of our project so that they can be
    more easily maintained and how to name HTML classes/CSS selectors in ECSS so that
    the class of an element in the DOM can tell us everything we need to know about
    its origin, purpose and intended context. We also had a detailed look at the accepted
    syntax for ECSS selectors: where and how to apply casing differences to delineate
    different parts of the selector. So far, we have only concerned ourself with static
    elements. In the next chapter we will look at how ECSS deals with the changing
    state of a website or application.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们涵盖了很多细节。我们主要关注了两个方面：如何组织项目的语言文件，以便更容易维护；以及如何命名HTML类/CSS选择器，使得DOM中元素的类可以告诉我们关于其来源、目的和预期上下文的一切。我们还详细研究了ECSS选择器的接受语法：在哪里以及如何应用大小写区别来划分选择器的不同部分。到目前为止，我们只关注静态元素。在下一章中，我们将看看ECSS如何处理网站或应用程序的变化状态。
