- en: Chapter 7. Alternate Implementations of JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the chapters until now, we have worked with JSON as an HTTP data interchange
    format; now let's look at the popular alternate methods in which JSON is being
    used. In the last few years, there has been a sharp rise in the number of software
    modules and packages across all programming and scripting languages. Crowdsourcing
    software development has been on an upward climb. Web-based hosting services such
    as SourceForge, Pastebin, and GitHub have gained popularity in the last few years,
    and they have opened up doors for developers to collaborate and contribute back
    to the community. These modules and packages can be independently integrated or
    can be used as dependent programs with an existing software framework. This behavior
    has been a common practice in the open source community where developers can work
    independently to contribute software packages that enhance the frameworks that
    they are working with.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting languages such as PHP, Python, and JavaScript have a huge number of
    contributed software packages and modules. The advantage here is to use a prebuilt
    software package that provides certain functionality out of the box and has been
    heavily tested by the community. The flip side of introducing a single framework
    or multiple frameworks into a software project is having to understand how these
    frameworks are loaded into the project, how they can be accessed from different
    sections in the current project, whether these frameworks have any dependencies,
    and finally, how they affect the whole project. These issues can be addressed
    by using a **dependency manager**.
  prefs: []
  type: TYPE_NORMAL
- en: A dependency manager is a software program that keeps track of all the necessary
    base programs that are required for a dependent program to run. A common practice
    in a software development life cycle is to perform unit tests by using a unit-testing
    framework; the unit-testing framework in turn might need some base libraries to
    be installed or there might be a few settings to enable the use of that framework.
  prefs: []
  type: TYPE_NORMAL
- en: These operations are often handled by writing up quick scripts, but as the project
    grows bigger, the dependencies grow along with the project. Along the same lines,
    tracking these changes and making sure different teams working on the project
    get these updates, which is done by scripts, is a tough task. By introducing a
    dependency manager, we will be automating the whole process, which adds consistency
    and saves time.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dependency management has often been a little rocky, and for new developers
    who are coming in, adding new frameworks into their projects, setting up their
    projects, and getting them to run can be daunting. A dependency manager like Composer
    for PHP solves this issue. It is considered the "glue between all projects", and
    there is a good reason for that. Composer uses JSON to keep a track of all the
    dependencies for a given project. Composer's primary job is to download libraries
    from remote locations and store them locally. To inform Composer as to what libraries
    we need, we would need to set up the `composer.json` file. This file keeps a track
    of all the specific libraries, their versions, and the environments that a given
    library should be deployed to. For example, a unit-testing framework library should
    never make it to production. There was an instance in an old company where a colleague
    of mine who was randomly testing our production instance deleted the whole user
    table by running a unit test; we had to recover the whole user table from the
    previous night's database back ups.
  prefs: []
  type: TYPE_NORMAL
- en: Let's quickly dive in and see how JSON is being used to handle dependency management.
  prefs: []
  type: TYPE_NORMAL
- en: '![Dependency management](img/6034OS_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: composer.json
  prefs: []
  type: TYPE_NORMAL
- en: In the `composer.json` file, we are adding two requirements to install a specific
    version of PHP and PHPUnit. Once the file is added to the project, we can use
    Composer's `install` command to install these dependencies. Composer also comes
    with an `update` command that takes care of any updates that are made for a given
    package.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information about Composer, please visit [http://www.getcomposer.org](http://www.getcomposer.org).
  prefs: []
  type: TYPE_NORMAL
- en: '`Node.js` is a popular software platform that uses the JSON data format for
    tracking dependencies. **Node Packaged Modules** (**NPM**) is the package manager
    that developers use for installing and integrating external modules into their
    code. For every `Node.js` project, there is a `package.json` file in the document
    root that keeps track of all the metadata, such as the name of the project, the
    name of the author, the version number, the required modules to run that project,
    and the underlying daemons or engines that are required to run the project. Let''s
    take a peek at an example `package.json` file from one of my `Node.js` projects.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dependency management](img/6034OS_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: package.json
  prefs: []
  type: TYPE_NORMAL
- en: The `package.json` file is a big JSON object that keeps a track of metadata,
    such as the project's name, author's details, and the required modules.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information about NPM, please visit [https://www.npmjs.org](https://www.npmjs.org).
  prefs: []
  type: TYPE_NORMAL
- en: JSON for storing metadata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On the same line as dependency managers, JSON is also used to store metadata
    for software projects. Prior to JSON becoming popular, the configurations and
    metadata were either stored in a text file or in language-specific files, such
    as `config.php` for PHP, `config.py` for Python, and `config.js` for JavaScript.
    All these can now be replaced by a language-independent `config.json` file; use
    a JSON library for non-JavaScript libraries to parse it. Let''s take a quick look
    at an example `config.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![JSON for storing metadata](img/6034OS_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: config.json
  prefs: []
  type: TYPE_NORMAL
- en: In the `config.json` file, we store the metadata as a JSON object. We are specifying
    important information such as the project name, the environment of the project
    (which varies based on the server that the file is located on), any classes that
    have to be autoloaded during bootstrapping the application, and any classes or
    folders that we would want to exclude. Finally, using the `RECURSIVE` key, we
    also specify that there are folders and those folders have files.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bootstrapping is the startup process for an application, in which we prepare
    that application to serve its purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the `config.json` file available, we can use the `json.loads` method
    in Python or we can use the `json_decode` method in PHP to parse through the config
    object to retrieve the data. The JSON objects can also be used to store the database
    schema; this helps the rest of the development team to update their database schema
    when one developer on the team makes a change to the database. A smart way to
    handle this would be by writing a trigger on this `schema.json` file, and if there
    is an update to that file, the schema in the database has to be updated to reflect
    the new changes via the database migration scripts. Let's take a quick look at
    an example `schema.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: '![JSON for storing metadata](img/6034OS_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: schema.json
  prefs: []
  type: TYPE_NORMAL
- en: In the `schema.json` example, we are building the schema JSON object that will
    store the database schema information. `client` is the name of the table in our
    schema. The `client` table has three columns—the ID, name, and status of the client,
    that is, whether the client is enabled or disabled. Each of the columns contains
    the column JSON object that provides the schema information, such as the datatype
    and size of the column, whether it has a default value or a primary key constraint.
  prefs: []
  type: TYPE_NORMAL
- en: Comparisons with YAML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: YAML is another software language-agnostic data interchange format that is slowly
    gaining popularity. **YAML** is a recursive acronym for **YAML Ain't Markup Language**,
    and is commonly used to store metadata such as configurations, schemas, and properties.
    YAML is considered a human-readable data serialization standard and depends on
    white spaces, positioning, and simple characters for line terminators, similar
    to popular scripting languages such as Ruby and Python. YAML is particular about
    the spacing between the elements and is not tab friendly. Similar to JSON, YAML
    key/value pairs are separated by a colon. Similar to text formatting, hyphens
    are used to indicate list items, unlike JSON where the list items are placed in
    an array or a child object. Since YAML is software language-agnostic, we would
    need parsers to understand the contents in that file. Such parsers are available
    for most of the popular languages such as PHP, Python, C++, Ruby, and JavaScript.
    Let's build the `config.json` file in YAML to understand what YAML is.
  prefs: []
  type: TYPE_NORMAL
- en: '![Comparisons with YAML](img/6034OS_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: config.yaml
  prefs: []
  type: TYPE_NORMAL
- en: Similar to our config JSON object, the YAML file contains all the data; the
    difference is in how the data is being arranged—as a list of items—and in how
    spacing and positioning are used to arrange lists of data. There are multiple
    YAML resources that are available on the Internet to validate, serialize, and
    unserialize the YAML data.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information about YAML, please visit [http://www.yaml.org](http://www.yaml.org),
    which is represented in YAML format.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSON is quickly becoming the most popular data interchange format on the Internet,
    but it is not limited to data exchange. We can also use JSON to store metadata
    for dependency managers, package managers, configuration managers, and schema
    data stores. We were introduced to YAML, which is considered as an alternative
    to JSON. In the next chapter, we will look at the different resources that we
    can use to debug, validate, and format JSON.
  prefs: []
  type: TYPE_NORMAL
