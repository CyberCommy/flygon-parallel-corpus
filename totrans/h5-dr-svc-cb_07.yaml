- en: Chapter 7. Data Serialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Deserializing JSON to JavaScript objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serializing objects to JSON strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decoding base64 encoded binary data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encoding binary data or text to base64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serialization of binary data into JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serializing and deserializing cookies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serializing form into request strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading XML documents with DOMParser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serializing of XML document at the client side
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the basic concepts of data storage and transmission is serialization.
    We are going to go through some of the ways to prepare the data for either sending
    to another environment or saving it permanently. Besides that we will see the
    ways for reading some of the data serialized by another computer environment.
  prefs: []
  type: TYPE_NORMAL
- en: Deserializing JSON to JavaScript objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest of all cases is reading JSON data into JavaScript objects. Data
    formatted in this way is of lightweight and additionally it is a subset of JavaScript.
    There are several ways to read this data and we will take a look at how this can
    be done by creating a simple JSON snippet and then converting it to JavaScript
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This example will be simple enough to be a script in an HTML file or even executed
    on a firebug or developer tools console:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first need the following serialized JSON string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'There are few different ways to do this without adding external JavaScript
    dependency, one is through the use of `eval`, the other is through the use of
    `json`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After this we will try to access some of the attributes form the deserialized
    object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Upon execution, the first `document.writeln` method should return `undefined`,
    because we are trying to access property on a JSON string that is not yet deserialized,
    while on the other two we should get the value you.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JSON is language independent format but at the same time JSON is JavaScript,
    meaning that we can use the `eval` function. Now that it is very simple since
    this is a top level function, and it accepts string as input that will get evaluated.
    If the string passed as an argument has JavaScript statements `eval` will perform
    those. This can be a dangerous thing just because it executes the code passed
    to it. If it is used on a code you don't trust, then you might get exploits from
    potentially malicious third party. For most use cases of `eval`, there are good
    alternatives already there. Debugging also can be very hard when we use `eval`,
    so it's something we should avoid in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to JSON parsing, on most of the modern browsers we can use the
    `JSON.parse(text[, reviver])` statement that has been added to JavaScript 1.7\.
    This function parses a string as JSON and has the optional argument for having
    a `reviver`, a function that can transform the value being produced by parsing.
    For example, if we wanted to append `"a?"` to each on the values, we can define
    something as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we try to access `transformed.who` we will get `"you a?"`. The final
    object will contain the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Meaning that each of the values of the original string that was parsed had the
    value `'a?'` appended to it and the key at given iteration took the values `comment`
    and `who`.
  prefs: []
  type: TYPE_NORMAL
- en: If the `reviver` function returns `undefined` or `null` for a given value, that
    property will get deleted, so it can be used as a filtering mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What will happen in case of older browsers that don''t support JSON natively.
    There are two simple options, we can just include JSON 2 or JSON 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: JSON 3 is a polyfill that is compatible with almost all of the JavaScript platforms
    and in a way, it's the newer implementation of JSON 2 and this is what we should
    use. There are several inconsistencies and special cases that were not handled
    correctly by JSON 2, although at the time of writing the older version was more
    widespread. Additionally, JSON 3 parser does not use `eval` or `regex`, making
    it more secure and giving it performance benefits in mobile were this can be significant.
  prefs: []
  type: TYPE_NORMAL
- en: If you already have jQuery in your project that you can use `jQuery.parseJSON(
    json )` similarity Prototype JS has it's own implementation, `String#evalJSON()`
    .
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One common error is the use of single quotes instead of double quotes. Most
    implementation of JSON do not allow the use of single quote, this was probably
    done for simplicity. To quote Douglas Crockford: JSON''s design goals were to
    be minimal, portable, textual, and a subset of JavaScript. The less we need to
    agree on in order to interoperate, the more easily we can interoperate.'
  prefs: []
  type: TYPE_NORMAL
- en: Serializing objects to a JSON string
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The reverse of the previous recipe is to serialize JavaScript objects into JSON
    string. Similarly the same rules about having browser support for JSON applies
    but again this is not a problem in most of the browsers. One way would be to manually
    create the string, but that is just a way to error-prone and messy browsers, so
    we will try out some of the methods available out there.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following example we use only JavaScript, so we can place it inside
    a simple script tag in an HTML file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First need data in order to serialize it to string, so we will create a simple
    JavaScript object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We create another object where we are going to have the `toJSON()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to convert the JavaScript object to a string we will use the `JSON.stringify(value
    [, replacer [, space]])` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After that we will try out the other arguments for that same function where,
    for the `replacer`, we will create a list of allowed properties and for the third
    argument, we will try two different options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can than simply write the output to the document object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The JSON `stringify` method accepts three arguments, where the last two are
    optional. When used with only one argument it will return a JSON string form the
    JavaScript object, where if some of the properties are undefined inside an object,
    then it is omitted or censored to null when found in array. If there is a `toJSON()`
    function defined inside the object than that function is used to select the object
    that will get converted. This allows the objects to define their own JSON representation.
    In our case, the evaluated version of `JSON.stringify(customToJSON)` will be as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The full function definition of `stringify` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We can use `replacer` to filter attributes that will get white listed. The `replacer`
    can be an array of `String` and `Number` objects that will serve as an allowed
    list of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The `space` argument can be added and have a value of type `String` or a `Number`.
    If it is a `Number`, it indicates the number of space characters to use as white
    spaces. In our examples this can be seen if you open the generated HTML in the
    browser. If the `space` argument is a `String`, then the first 10 characters of
    the value passed are used as white spaces for creation of the JSON.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to note is that the order of the serialized attributes is not guaranteed
    for non-array objects. You must not rely on ordering of properties within the
    object after the object is serialized. Now serialization might not be the most
    accurate definition of the process because of this, so that is why this is called
    as stringification commonly.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Again we have the similar problems for older user agents that don''t support
    JSON. For that use we would recommend JSON 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Also you should not use the `stringify` function for debugging purposes since
    as we previously mentioned it converts undefined objects in a specific way, so
    you might get a wrong conclusion by doing so. This wrong conclusion is only related
    to the order and JSON compatibly, but it is fully valid to use it for general
    debugging of objects.
  prefs: []
  type: TYPE_NORMAL
- en: Decoding base64 encoded binary data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until very recently, JavaScript didn't have any native support for storing binary
    data types. Most binary data was handled as strings. Binary data that could not
    be handled using strings (for example, images) was handled as base64 encoded strings.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Base64 is a method to encode binary data by converting groups of bytes into
    groups of base64 numbers. The goal is to avoid data loss by safely representing
    binary data using only printable characters which will not be interpreted in a
    special way.
  prefs: []
  type: TYPE_NORMAL
- en: HTML5 has much better support for binary data, it can be stored and manipulated
    using the `ArrayBuffer` class and the typed array classes. However, legacy libraries
    and API may still use base64 data. In order to do more efficient binary processing
    in modern browsers, we might want to convert this data into array buffers.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we're going to write a conversion function that converts base64
    encoded strings to array buffers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To write this function, first we need to understand how base64 encoding works.
  prefs: []
  type: TYPE_NORMAL
- en: The usual way to access binary data is one byte at a time. A byte has 8 bits.
    If we try to assign a digit interpretation to a byte, it would be capable of representing
    2 ^ 8 = 256 different digits. In other words, a byte could represent a single
    base 256 digit.
  prefs: []
  type: TYPE_NORMAL
- en: We need to represent binary data as base64 digits. They are represented by the
    letters `A-Z`, `a-z`, `0-9`, `+`, and `/` – a total of 64 characters, enough to
    store 6 bits of data per character. To do this, we will have to take groups of
    6 bits from the binary data. The lowest common denominator of 6 bits and 8 bits
    are 24 bits, which means that every group of 3 bytes are represented by a group
    of 4 base64 digits.
  prefs: []
  type: TYPE_NORMAL
- en: We can conclude that the decoding process will take all four groups of base64
    encoded digits and produce 3 bytes from each group.
  prefs: []
  type: TYPE_NORMAL
- en: But what happens if the total number of bytes isn't divisible by 3? Base64 uses
    an additional character "`=`" (the equal sign) to denote the number of bytes missing
    from the last group. A single character is added at the end of the string to indicate
    that the last group has 1 byte less (only two in the last group). Two of them
    are added when there are 2 bytes less (only one byte in the last group).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have understood how base64 works, we're ready to write a base64
    decoder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `index.html` page containing a text field to input `text` and two
    `div` elements. One of the elements will be used to display the base64 string
    , while the other will be used to display the decimal values of the converted
    bytes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `example.js` and put the code that will apply the changes on the page
    as the user types the text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `atobuf.js`, which exports a function taking a base64 string and returns
    an ArrayBuffer object with the decoded bytes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code in `index.html` and `example.js` is fairly straightforward we set up
    a page to easily preview and test the results of our conversion function. To store
    the bytes, we create a `Uint8Array` object over the passed buffer. This is a new
    kind of array type introduced in HTML5, which enables us to read the individual
    bytes in the `ArrayBuffer` object as unsigned 8 bit integers.
  prefs: []
  type: TYPE_NORMAL
- en: A point worth noting is that a `Uint8Array` object doesn't have the `join` method.
    This is why we "borrow" the method from an empty array by writing `[].join.call(bytes,
    ' ')`, which calls the `join` method (ordinarily belonging to the empty array)
    as if it were a method of the object bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Inside `atobuf.js` we export the `atobuf` function either as a CommonJS module
    (done by attaching to the `exports` object) or as a function attached to the global
    object.
  prefs: []
  type: TYPE_NORMAL
- en: To make the conversion faster, we predefine a conversion dictionary that maps
    the characters to their appropriate numeric values.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/9282OT_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's see how the bit manipulation code works. The encoded values have 6 bits,
    while the decoded values have 8 bits. While reading the explanation, note that
    the bits are enumerated from right to left, with bit 0 being the right-most bit,
    bit 1 the second-right-most bit, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: For the first decoded byte, we need the 6 bits stored in the first encoded value
    positioned as bits 2 to 7 in the decoded value. That's why we shift them two places
    to the left. We also need bits 4 and 5 from the second encoded value for the first
    decoded value, positioned as bits 0 and 1\. This means we need to shift them to
    the right by four places.
  prefs: []
  type: TYPE_NORMAL
- en: For the second byte, we need bits 0 to 3 from the second encoded value positioned
    as bits 4 to7 in the decoded value. To do this, we zero out bits 4 and 5 using
    a binary AND operation and shift the rest four places to the left. We also need
    bits 2 to 5 from the third encoded value as bits 0 to 3, so we need to shift them
    two places to the right.
  prefs: []
  type: TYPE_NORMAL
- en: For the third byte, we need bits 0 to1 from the third encoded value at places
    6 to7, which means using AND to zero out the rest and shifting six places to the
    left. The bits on the last encoded value are all in the right place at the third
    byte, so we take them as they are.
  prefs: []
  type: TYPE_NORMAL
- en: Encoding binary data or text into base64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTML5 support for binary data is through an `ArrayBuffer` object, the related
    type arrays. When it comes to transmitting that data, usually the way to do this
    is via base64\. This is used mostly for dealing with textual data but with the
    rise of the usage of Data URI, base64 becomes more and more relevant. In this
    recipe, will see how to encode data using this scheme.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create an HTML file where we will use a `canvas` element, which will
    generate some data that will get encoded into base64:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to have binary data, we will create an image using canvas, so we add
    a `canvas` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can have some input field that could be used to show the text encoding:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Following that element we can place two output elements, one for the encoded
    binary data from the image and one for the encoded text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We then include the dependency to jQuery and `example.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we have included the `example.js` file, we can then proceed to creating
    logic for encoding the data. In order to have some binary data, we will create
    an image of a square with canvas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The current method definitions for `CanvasRenderingContext2D` can be found
    at WHATWG: [http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#canvasrenderingcontext2d](http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#canvasrenderingcontext2d).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to create base64 encoded data, we are going to convert the array to
    string, so that we can define a function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can call that function and use the internal `btoa()` method that accepts
    string that will get encoded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To demonstrate that we can go back now, we will use `atob` to decode the base64
    encoded string data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in order to get back from the decoded string data to the original binary
    array we need to define a function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'After that we can call that function on our decoded data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We will just print the base64 encoded string on to the page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Due to certain assumptions made by the base64 algorithm, UTF is not initially
    supported. There is a workaround for this, created by Johan Sundström that takes
    advantage of standard functions and makes UTF possible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This is only of interest to us for textual data, so we can try it out by connecting
    the input field with the output tag where we will have a base64 encoded text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The modern browsers have support for `atob("base64encoded")` and `btoa("stringToBeEncoded")`.
    These methods allow encoding and decoding of base64 strings. We use `btoa()` to
    encode string data and we get result that has ASCII character `A-Z,a-z,0-9`, and
    the symbols `(/,+,=)` making the data convenient for transport. The data range
    restriction comes at a price, the encoded data is now larger than the original
    binary stream with about 33 percent of overhead. On the other hand, the encoded
    data is usually more compressible, so the gzip will more or less even up the size.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript typed arrays provide a way for accessing raw binary data much more
    efficiently than using the standard types. They are supported in all of the modern
    browsers and IE 10\. More on typed arrays can be found on MDN: [https://developer.mozilla.org/en-US/docs/JavaScript/Typed_arrays](https://developer.mozilla.org/en-US/docs/JavaScript/Typed_arrays).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To the test binary data encoding, we took array generated from HTML canvas.
    To retrieve the binary array representation there, we used the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns `ImageData` object that contains properties width, height, and
    data. The data attributes is represented as an `Uint8ClampedArray` object. These
    type of arrays are similar to the standard `Array` object, where each of the items
    is an 8 bit (1 byte) unsigned integer. All the values stored in this array are
    in the range 0 to 255, which is perfect for colors. In our case, we can see the
    values stored in the array by logging with `console.log()`, and we get values
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The 0 is for red, 128 is for green, and the third 0 is for blue, the 255 value
    on the other hand is for the opacity level. Since we want to encode the data of
    the array to base64 we cannot simply call `btoa(theArray)`, since we only store
    the `toString` value and not the whole array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we are to compare `Uint8array` with `Uint8ClampedArray` the main difference
    is the first uses modulo shortening when inserted value that is out of range and
    the clamped one well clamps the values. For example, if we were to to set the
    value 300 to a 255 limited it will become 255 for `Uint8ClampedArray` but 45 for
    the other. Similarly the value -1 will be clamped to 0\. More info about `Uint8ClampedArray`
    can be found at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.khronos.org/registry/typedarray/specs/latest/#7.1](http://www.khronos.org/registry/typedarray/specs/latest/#7.1)'
  prefs: []
  type: TYPE_NORMAL
- en: The main reason why we added `arrayToString` is to create a string for us that
    we can latter use in `btoa`. Similarly we would need `stringToArray` that will
    revert the transformation.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to text the core functions `btoa()/atob()` don''t have support
    for Unicode. If we try to convert characters with a value larger than `"\u0100"`
    we will get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As a fix for this we added methods `utf8ToB64()` and `b64ToUtf8()`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These two are clever hacks done by Johan Sundström and is a recommended fix
    by MDN. More info can be obtained from [http://ecmanaut.blogspot.com/2006/07/encoding-decoding-utf8-in-javascript.html](http://ecmanaut.blogspot.com/2006/07/encoding-decoding-utf8-in-javascript.html).
  prefs: []
  type: TYPE_NORMAL
- en: The hack takes advantage of standard function pairs `encodeURIComponent()/decodeURIComponent()`
    and `escape()/unescape()`.
  prefs: []
  type: TYPE_NORMAL
- en: How does this combination of `encodeURICompoenent` and `unescape` work?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how this method works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The result we are getting is a percent-encodedstring, where the UTF-8 characters
    are replaced with the appropriate percent representation. Now we could use just
    `encodeURIComponent`, since percent encoding uses only ASCII characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: But there is a drawback with this approach and that is the resulting percent-encoded
    string is lot bigger the initial one, and since base64 adds additional overhead
    it can easily become huge.
  prefs: []
  type: TYPE_NORMAL
- en: The `escape` and `unescape` functions are deprecated, since they don't work
    for non ASCII characters but in our case the input is valid, and as such, they
    can be used. As for future versions they are not a part of the standards but they
    will probably stay. The `unescape` function returns the ASCII string for the specified
    hexadecimal encoded value. The benefit of using this is now we have representation
    that is a smaller string. Another great thing about this hack is it uses multiple
    encoding functions available by the browser to extend standard functionality.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to user agent support, IE is the only current browser that has
    not yet included `btoa()` and `atob()`, but this was only valid for versions older
    than IE 10\. In order to enable it on unsupported user agents we can use a polyfill.
    There are several different polyfills for this, but we can use the one called
    `base64.js`, ([https://bitbucket.org/davidchambers/base64.js)](https://bitbucket.org/davidchambers/base64.js)).
  prefs: []
  type: TYPE_NORMAL
- en: There is an interesting async resource loader called `yenope.js`, that is very
    fast and allows custom checks. If we want to include `base64.js` we can test for
    the existence of the needed functions and if it's not then it will automatically
    include it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Yepnope is one of the many conditional resource loaders, but it is one of the
    simple ones. The `yepnope` function is the core of the entire loader. As such
    it is very small and integrated in Modernizer; more info can be found at [http://yepnopejs.com/](http://yepnopejs.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Serializing binary data into JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with REST API's if you need to include binary data as part of the
    JSON, then one of the simplest ways is to use base64\. Images and similar resources
    should most likely exist as separate resources but they can also be part of the
    JSON document as well. In this recipe, we are going to cover a simple example
    of including image in JSON document.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will generate some binary data from a `canvas` element and serialize it
    to JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by creating an HTML file, where we can place a simple `canvas`, a
    `div` element for output, and includes jQuery together with the script will be
    created afterwards:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `example.js` script we can create a simple circle on the `canvas` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we define the same `arrayToString` function we used in the *Serializing
    binary data or text in base64* section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We then encode the data and create a JavaScript object while also creating
    two data URI form the `canvas` element, one `jpeg`, and the other `png`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to create the JSON object we can use `JSON.stringify` and then print
    the result to the `generatedJson` div:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code is very similar to the previous recipe, we created a simple circle
    using 2D context for canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Then we got the binary data from the image and applied the same logic like in
    the*Encoding binary data or text into base64* recipe. One specific feature is
    the use of Data URI that simply create a base64 encoded rendering of the image
    in the specified format. In our case we created a rending in `jpeg` and `png`.
    If you copy out the data contained in
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: and paste it into the browsers URL selection, it will render the image. Data
    URI will be looked into in great details in chapter titled *Data storage*.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The base 64 encoding can be used with XML to store more complex or binary data.
    Because the character base of the encoding does not interfere with the parsing,
    no CDATA sections are needed.
  prefs: []
  type: TYPE_NORMAL
- en: There are plenty of other format for exchange of binary data with the server
    such as BSON, Base32 or Hessian. Base64 is most commonly used since it's very
    simple and it easy to integrate.
  prefs: []
  type: TYPE_NORMAL
- en: One great usage of base64 is to store the text into a URL parameter making the
    text easy to get represented and reconstructed, you can see that on [http://hashify.me](http://hashify.me).
  prefs: []
  type: TYPE_NORMAL
- en: Serializing and deserializing cookies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Despite all the advances made in HTML5, browsers still have a very strange cookie
    API. The way it works is error-prone and inconsistent with the normal semantics
    of JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The global `document` object has a `cookie` property, if a string is assigned
    to it, it magically adds the specified cookie to the list of cookies. When an
    attempt to read the cookie is made, a different value containing all the cookies
    is returned.
  prefs: []
  type: TYPE_NORMAL
- en: This API is not very useful without a wrapper. In this recipe, we're going to
    wrap this API in a wrapper that actually makes sense. We're going to test this
    wrapper by making a form page that saves itself on every modification (preserving
    the data after a page reload) for two minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s find out how `document.cookie` works. We can set a cookie as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This sets a cookie for the whole domain of the current website called test,
    expiring on January 18 2023\. Now if we try to read from `document.cookie` we
    will get "`name=test`", which means that all the extra data has been stripped
    out. If we continue by adding another cookie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'And then try to access `document.cookie`, we get both cookies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'To actually clear the cookie we will need to set the `expires` date in the
    path as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: And then we're back to `document.cookie` containing `"name=test"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, if we omit the `expires` date, we''re going to get a cookie that lasts
    until the user closes the browser or until we clear it by setting its expire date
    in the past:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: But what happens if the value contains the character `;`? The cookie value will
    be cut off at this character and the next parameter (expire date or path) will
    be ignored. Fortunately, we can work around this by using `encodeURIComponent`
    to encode the value.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have enough information to write our cookie handling library.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s write the code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the form page in `index.html`, it will contain three text fields and
    include our cookie wrapper script and formsaving script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `cookie.js`, which implements and exports the cookie API. It will have
    the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`cookie.set`(`name, value, options`): This function sets the value of a cookie.
    The value can be an arbitrary object as long as it can be serialized by `JSON.stringify`.
    Available options are `expires`, `duration`, and `path`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `example.js` to test the new cookie API. It loads the form data when
    the document loads and saves it when it''s changed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our API implements several convenient functions to deal with cookies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cookie.set` function allows us to set a cookie. It takes three parameters:
    name, value, and options.'
  prefs: []
  type: TYPE_NORMAL
- en: The value is serialized with `JSON.stringify`, and then encoded using `encodeURIComponent`.
    As a result we can store any object that can be serialized with `JSON.stringify`
    (there are however size limits which vary between browsers).
  prefs: []
  type: TYPE_NORMAL
- en: 'The options parameter is an object which can contain three properties: expires,
    duration, and path. The `expires` property is the date when the cookie should
    expire. Alternatively, `duration` can be provided – it is the duration that the
    cookie should last in seconds. If both of these are omitted, the cookie will last
    until the end of the current browser session. Finally, the `path` property is
    a string specifying the path where the cookie is available. The default is the
    current path.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cookies should not be used to store large amount of data. Most browsers limit
    the cookie size at 4 KB per cookie. Some browsers limit the total size of all
    cookies to 4 KB. Data stored inside cookies is transferred with every request
    made to the server, increasing the total use of bandwidth.
  prefs: []
  type: TYPE_NORMAL
- en: For larger data we can use local storage instead. More information can be found
    in [Chapter 10](ch10.html "Chapter 10. Data Binding Frameworks"), *Data Binding
    Frameworks*.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this example doesn't work when opened on a local filesystem. To make
    it work, a local HTTP server must be run. See appendix for more information on
    how to run a simple HTTP server.
  prefs: []
  type: TYPE_NORMAL
- en: Serializing a form into request strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common task when working with forms is the need to create the actual request
    string. There are several different ways to do this, the first thing that comes
    to mind is just to select each individual form element and get it's value, and
    then create the string by appending the name attributes with the values. This
    is very error prone, so we are going to take a look at a better solution using
    `jQuery.serialize()`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As usual we can start with the HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First we add basic the `head` section and an output element where the generated
    request string will be shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can proceed with creating a simple form, where we add input for full
    name, e-mail, and percentage of awesomeness:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Following that we can include the needed JavaScript dependencies to jQuery
    and our `example.js` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then proceed to creating the `example.js` file, where on every update
    of the form elements the form is serialized:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `.serialize()` function converts form elements and their values into a percent-encoded
    string. Percent-encoding is often called URL encoding and is a way to represent
    information in a URI-friendly way. As such, it is a core part in most of the forms
    that are used and it has an MIME type of `application/x-www-form-urlencoded`.
  prefs: []
  type: TYPE_NORMAL
- en: If we have a button in the form it will not be considered as part of the generated
    string, because that button was not clicked in order to submit the form. Additionally,
    values from the checkboxes and radio buttons are only part of the generated string
    if they are checked.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand if we need some JSON representation then we can use `.serializeArray()`,
    a function that will create a JavaScript array. After having this array of elements
    we can create a JSON using `JSON.stringify()`. The default JSON representation
    may not be very useful in most cases but we can easily restructure and filter
    the elements.
  prefs: []
  type: TYPE_NORMAL
- en: The `.serializeArray()` and `.serialize()` functions save only "successful controls"
    as defined by the W3C ([http://www.w3.org/TR/html401/interact/forms.html#h-17.13.2](http://www.w3.org/TR/html401/interact/forms.html#h-17.13.2)),
    where you will get same behavior as if the form was submitted regularly with a
    button click.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing to note is that data from file select elements is not serialized
    using these two methods. For this purpose and other similar use cases, the `FormData`
    object was introduced in `XMLHttpRequest Level 2`. This object allows the creation
    of a set of key/value pairs in order to be sent using `XMLHttpRequest`. The data
    that will be created using this method gets sent in the same way as standard submit,
    where the encoding was set to `"multipart/form-data"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We saw in our example the creation of JSON objects from the form elements can
    get messy even with using `.serializeArray()`. In order to simplify things and
    enable easy creation of more complex JSON directly from the elements `form2js`,
    [https://github.com/maxatwork/form2js](https://github.com/maxatwork/form2js) was
    created. A small example on how this works would be to create a simple person
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'To achieve this we only create the definition in the `name` attribute and the
    script handles everything else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: There is a standard JavaScript version and a jQuery plugin for this library.
    It also has other features such as having array of objects or custom field handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Reading XML documents with DOMParser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While `XMLHttpRequest` allows us to both download and parse XML documents, sometimes
    we might want to parse XML data documents manually. For example, manual parsing
    would enable us to include arbitrary XML data (for example, XML-based templates)
    inside the page in a `script` tag. This can help to reduce the number of requests
    sent to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to read a simple XML document from a `textarea`
    input and parse it using `DOMParser`, and then display the result as a tree.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s write the test HTML page and the parser:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `index.html`, it should contain a `textarea` element to input XML (a
    sample XML document is included), a placeholder for the document `body` object,
    and some CSS styles for the document tree:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `example.js`, and add the code that parses the document and converts
    it into an HTML tree:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To parse an XML document, we create a new `DOMParser` object and call the `parseFromString`
    method. We specify the document type as application/xml – the parser can also
    parse `text/html` and return an `HTMLDocument` element, or `image/svg+xml` returning
    an `SVGDocument` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting document has a very similar API to the one found in `window.document`
    (the same DOM API is available). We create a recursive function that iterates
    all the children of the root element and generates HTML. It constructs headers
    for the element names, span elements for the attribute names and values, div elements
    for the text nodes, and calls itself to generate HTML to display element nodes.
    The result is a DOM tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/9282OT_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Serialization of XML document at the client side
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSON is extremely simple to use than JavaScript; there are lot of REST services
    already out there that use XML. In this recipe we are going to create a simple
    form that will construct an XML document using the DOM API for XML.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First we create a simple HTML document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'After this we are going to include a KML document inside the text, in a real
    life application this will probably get loaded by AJAX, but for simplicity we
    will add the data directly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You may have noticed the use of **KML** (**Keyhole Markup Language**) in this
    recipe. Originally this was a format developed by a company acquired by Google,
    but now its is an international open standard. This format is widely used for
    describing placemarks and locations. More info can be found at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developers.google.com/kml/documentation/](https://developers.google.com/kml/documentation/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following this block we can just include the JavaScript `example.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We will create a simple XML document form scratch and serialize it to a string.
    The code will simply retrieve a section of the HTML document where we have the
    KML data serializing it to a string, and then displaying the data in the text
    area:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The core of this example is the `XMLSerializer()` method, that can be used
    to convert DOM subtree or the entire document into text. The object is supported
    by most of the modern browsers and IE 9+, but for older versions, you need to
    use some fallback similar to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Standard DOM manipulation can be used to create an XML document. The same thing
    applies for jQuery where we have out-of-the-box functionality for the creation
    of documents. Things only get more complicated if we need to work with larger
    documents or do extensive work with XML. Most of the REST services these days
    have some sort of content negotiation, so usual JSON is an available and a better
    option.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is also a functionality called JXON([https://developer.mozilla.org/en-US/docs/JXON](https://developer.mozilla.org/en-US/docs/JXON)),
    which stands for JavaScript XML Object Notation is a generic name for the API
    related to creation and use of XML documents in JavaScript. This basically defines
    a convention for a two-way conversion between JSON and XML.
  prefs: []
  type: TYPE_NORMAL
- en: While working extensively with XML, XPath can be your best friend. It enables
    a very flexible way of accessing specific parts of the documents that match certain
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**XPath** **(XML Path Language**) is a query language for selecting nodes in
    an XML document. Much like SQL, it provides certain calculation functions. There
    is an extensive documentation on MDN at [https://developer.mozilla.org/en-US/docs/XPath](https://developer.mozilla.org/en-US/docs/XPath)
    as well as the specification documents at [http://www.w3.org/TR/xpath20/](http://www.w3.org/TR/xpath20/).'
  prefs: []
  type: TYPE_NORMAL
