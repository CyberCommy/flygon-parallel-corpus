- en: Service Workers - Caching and Making Things Faster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have looked at dedicated and shared workers, which help throw computationally
    expensive tasks into the background. We have even created a shared cache that
    utilizes `SharedWorker`. Now, we will take a look at service workers and learn
    how they can be used to cache both resources (such as HTML, CSS, JavaScript, and
    so on) and data for us so that we don't have to make expensive round trips to
    our server.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the ServiceWorker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching pages and templates for offline use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving requests for later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, we will be able to create offline experiences for
    our web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An editor or IDE, preferably VS Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chrome
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An environment that can run Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter's code, which can be found at [https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter11](https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter11).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the ServiceWorker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `ServiceWorker` is a proxy that sits between our web applications and the
    server. It catches requests that are made and checks if there is a pattern that
    matches it. If a pattern matches it, then it will run the code that fits that
    pattern. Writing code for a `ServiceWorker` is a bit different than it is for
    `SharedWorker` and `DedicatedWorker`, which we looked at previously. Initially,
    we set it up in some code and it downloads itself. We have various events that
    tell us the stage that the worker is in. These run in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Download**: The `ServiceWorker` is downloading itself for the domain or subdomain.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Install**: The `ServiceWorker` is attaching itself to the domain or subdomain
    where it is hosted.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Activate**: The `ServiceWorker` is fully attached and is loaded up to intercept
    requests.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The install event is especially important. This is where we can listen for a
    `ServiceWorker` that is updated. Say that we want to push new code out for our
    `ServiceWorker`. If a user is still on a page when we decide to push that code
    out to the server, they will still have the old worker. There are ways to kill
    off this old worker and force them to update (as we will see in a bit), but it
    will still utilize the old cache.
  prefs: []
  type: TYPE_NORMAL
- en: On top of this, if we are utilizing a cache to store the resources that are
    being requested, they will be stored in the old cache. If we were to update these
    resources, then we want to make sure that we dump the previous cache and start
    with a new one. We will look at an example of this later, but it is good to know
    this upfront.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, service workers will update themselves every 24 hours, so if we don't
    force the user to update the `ServiceWorker`, they will get this new copy on that
    24-hour mark. These are all ideas to keep in mind as we go through the examples
    in this chapter. We will remind you of these when we write them out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start off with a very basic example. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need a static server so that we can work with service workers. To
    do this, run `npm install serve` and add the following code to the `app.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can serve all of our content from the `source` directory. Create a
    basic HTML page and have it load in a `ServiceWorker` called `BaseServiceWorker.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a basic `ServiceWorker` that will log to our console whenever a request
    is made:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We should see two messages appear in our console. One should be static, stating
    that we have installed everything correctly, while the other will state that we
    have successfully registered a worker! Now, let's add a CSS file to our HTML and
    service it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Call our new CSS file `main.css` and add the following CSS to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Add this CSS file to the top of our HTML page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this, reload the page and see what it states in the console. Notice how
    it doesn't state that we have successfully made a request. If we keep hitting
    the reload button, we may see the message appear before the page reloads. If we
    want to see this message, we can head to the following link inside of Chrome and
    inspect the `ServiceWorker` that's there: `chrome://serviceworker-internals`.
  prefs: []
  type: TYPE_NORMAL
- en: We may see other service workers being loaded in. Quite a few sites do this
    and it is a technique for caching certain pieces of a web page. We will look at
    this in more detail soon. This is why the first load can be quite a pain for some
    applications and why they seem to load up a lot faster afterward.
  prefs: []
  type: TYPE_NORMAL
- en: 'The top of the page should show an option for starting the dev tools when we
    start the `ServiceWorker`. Go ahead and check this option. Then, stop/start the
    worker. Now, a console should open that allows us to debug our `ServiceWorker`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dcee480a-892e-4485-aca2-9ca2cf3dddd3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'While this is great for debugging, if we take a look at the page where we initiate
    this behavior, we will see a little window that states something similar to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It is getting the CSS file every single time we reload the page! If we reload
    it a few more times, we should have more of these messages. This is interesting,
    but we can definitely do a bit better than this. Let''s go ahead and cache our
    `main.css` file. Add the following to our `BaseServiceWorker.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: With this, we have introduced a cache. This cache will fetch various resources
    for us. Along with this cache, we have introduced the `waitUntil` method of the
    event. This allows us to hold up the initialization of the `ServiceWorker` until
    we are done fetching all of the data we want from the server. Inside of our fetch
    handler, we are now checking to see if we have the resource in our cache. If we
    do, we will serve that file up; otherwise, we will just make the fetch request
    on the page's behalf.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we load the page, we will notice that we just have the `we are ready`
    message. Even though we have new code, the page was cached by Chrome, so it hasn't
    let go of our old service worker. To force the new service worker to be added,
    we can go into our developer console and head to the Application tab. Then, we
    can go to the left panel and head over to the `ServiceWorker` section. There should
    be a timeline stating that there is a `ServiceWorker` waiting to be activated.
    If we click the text next to it that says skipWaiting, we can activate the new
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and click on this option. It won't look like anything has happened,
    but if we head back to the `chrome://serviceworker-internals` page, we will see
    that there is a single message. If we keep reloading the page, we will see that
    we just have the one message. This means that we have loaded in our new code!
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to check that we have successfully cached our `main.css` file is
    to throttle the download speed of our application (especially since we are hosting
    it locally). Head back to the developer tools and click the Network tab. There
    should be a dropdown of network speeds near the Disable cache option. Currently,
    it should state that we are online. Go ahead and turn this to offline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/15280a71-55c0-412f-9146-916062274e3b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Well, we just lost our page! Inside of `BaseServiceWorker.js`, we should add
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can turn our application online again and have this new `ServiceWorker`
    add itself to the page. Once it's been added, go ahead and turn our application
    offline. Now, the page works offline! We will explore this idea in more detail
    later, but this gives us a nice preview of this capability.
  prefs: []
  type: TYPE_NORMAL
- en: With this simple look at the `ServiceWorker` and caching mechanism, let's turn
    our attention to caching pages and adding some templating capabilities inside
    of our `ServiceWorker`.
  prefs: []
  type: TYPE_NORMAL
- en: Caching pages and templates for offline use
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we stated at the beginning of this chapter, one of the main uses for service
    workers is to cache page resources for future use. We saw this with our first
    simple `ServiceWorker`, but we should set up a more complicated page with more
    resources. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a brand new `ServiceWorker` called `CacheServiceWorker.js` and add the
    following template code to it. This is what most of the `ServiceWorker` instances
    will use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Update our `index.html` file in order to utilize this new `ServiceWorker`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add some buttons and tables to our page. We will utilize these
    shortly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a JavaScript file that will handle all of our interaction with the `interactions.js` page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the JavaScript file to our `ServiceWorker` as a preload:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the JavaScript file to the bottom of our `index.html` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we load our page, we should see a simple table sitting there with a
    header row and some buttons. Let''s go ahead and add some basic styling to our
    page to make it a bit easier to see. Add the following to that `main.css` file
    that we added when we were working with `BaseServiceWorker`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This CSS gives us some basic styling to work with. Now, if we hit the Add button,
    we should see the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we haven''t added any code to actually handle this, let''s go ahead and
    intercept this message inside of our `ServiceWorker`. Follow these steps to do
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following dummy code to our `fetch` event handler for the `ServiceWorker`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Click the Add button. We should see a new error stating that it could not parse
    the JSON message. Change the `Blob` data to some JSON:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Click the Add button again. We should get something that states that what we
    just passed to our handler is not of the `Node` type. Parse the data that we got
    inside of our Add button''s click handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we try to run our code, we will see something interesting: our JavaScript
    file is still the old code. The `ServiceWorker` is utilizing the old cache that
    we had. We could do one of two things here. First, we could just disable the `ServiceWorker`.
    Alternatively, we could remove the old cache and replace it with our new one.
    We will perform the second option. To do this, we will need to add the following
    code to our `ServiceWorker` inside the install listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, we could have the template loaded in on the frontend code, but we're going
    to mimic a server-side rendered system here instead. There are a couple of applications
    for this, but the main one that comes to mind is a templating system that we are
    trying out in development.
  prefs: []
  type: TYPE_NORMAL
- en: Most template systems need to be compiled to their final HTML forms before we
    can use them. We could set up a *watch* type system where these templates are
    reloaded every single time we update them, but that can become tiresome, especially
    when we only want to focus on the frontend. Another way to do this is to load
    those templates into our `ServiceWorker` and let it render them. That way, when
    we want to make updates, we just have our cache be deleted through the `caches.delete` method
    and then reload it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and set up a simple example like the preceding one, but instead
    of the template being created in our frontend code, we will have it in our `ServiceWorker`.
    Follow these steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a template file called `row.template` and fill it in with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove the templating code inside of our `interactions.js` and replace it with
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s set up some basic templating code. We will do nothing close to what
    we did in [Chapter 9](59d1466a-ef4d-42f8-bc88-f3d364c3d23e.xhtml), *Practical
    Example – Building a Static Server*. Instead, we will loop through the objects
    we get passed and fill in the parts of our template where our keys line up in
    the object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the response to the `/add` endpoint with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will grab the template we want from the server (in our case, the `row.template`
    file) and fill it with whatever data we have (again, in our case we will use stub
    data). Now, we have templating inside of our `ServiceWorker` and can easily set
    up endpoints to go through this templating system.
  prefs: []
  type: TYPE_NORMAL
- en: This can also be beneficial when we want to personalize the error pages of our
    site. If we want to have a random image appear and incorporate it in our 404 page,
    we could have this done in the `ServiceWorker` instead of hitting this server.
    We could even do this for an offline state. We would just need to implement the
    same type of templating that we did here.
  prefs: []
  type: TYPE_NORMAL
- en: With these concepts in mind, it should be easy to see the power we have when
    intercepting requests and how we can make our web applications work offline. One
    final technique that we will learn about is storing our requests when we are offline
    and running them when we go back online. This type of technique can be used for
    saving or loading files from the browser. Let's take a look.
  prefs: []
  type: TYPE_NORMAL
- en: Saving requests for later
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've learned how to intercept requests and either return or even enhance
    the response from our local system. Now, we will learn how to save requests when
    we are in offline mode and then send the calls to the server once we appear online.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and set up a new folder for just this. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder called `offline_storage` and add the following files to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`index.html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main.css`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`interactions.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OfflineServiceWorker.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add the following boilerplate code to `index.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following boilerplate code to `OfflineServiceWorker.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add the following boilerplate code to `interactions.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'With all of this code in place, let''s go ahead and change our Node.js server
    so that it points to this new folder location. We''ll do this by stopping our
    old server and changing the `app.js` file so that it points to our `offline_storage`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we can rerun our server by running `node app.js`. We may experience
    our old page showing up. If this is the case, we can go to the Application tab
    in our developer tools and click the Unregister option under the Service workers
    section. Once we reload the page, we should see the new `index.html` page show
    up. Our handlers aren''t working at the moment, so let''s add some stub code inside
    of our `ServiceWorker` that will handle the two fetch cases that we added in `interactions.js`.
    Follow these steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following support inside the fetch event handler for the request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s make sure this code handles the response correctly by making sure that
    it adds a row to our table. Reload the page and make sure a new row is added when
    we click the Request button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/1636a18d-88bd-4817-8bf2-a68b8cb20cc5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have made sure that that handler is working, let''s go ahead and
    add the other handler for our delete request. We will mimic a delete for a database
    on the server in our `ServiceWorker`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: With this, let's go ahead and test it to make sure that our rows are deleting
    when we click the Delete button. If all of this is working, we will have a functioning
    application that can work online or offline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, all we need to do is add support for requests that are going to go out
    but can''t because we are currently offline. To do this, we will store requests
    in an array, and once we detect that we are back online in our `ServiceWorker`,
    we will send all the requests out. We will also add some support to let our frontend
    know that we are waiting on so many requests and that if we want, we can cancel
    them out. Let''s add this now:'
  prefs: []
  type: TYPE_NORMAL
- en: In Chrome, switching from offline to online will trigger our **online** handler,
    but switching from online to offline doesn't seem to trigger the event. We can
    test the offline-to-online system functionality, but testing the other way around
    can be a bit more difficult. Just note that this limitation could be in place
    on many development systems and that trying to account for this can be quite difficult.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, move most of our `caches.match` code to a standalone function, like
    so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Code the standalone function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We will handle requests by polling them to see if we are back online. Set up
    a poll timer that will work every 30 seconds and change our `caches.match` handler
    like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: What we have just done is set up a return for a promise. If we can't see the
    system online, we will keep polling every 30 seconds to see if we are back online.
    Once we are back online, our promise will clear the interval and actually handle
    the request in the resolve handler. We could set a system of so many attempts
    before we cancel the request. All we would have to do is add a reject handler
    after so many times through the interval.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will add a way to stop all currently outstanding requests. To do
    this, we will need a way of keeping track of whether we have requests outstanding
    and a way to abort them in the `ServiceWorker`. This will be quite simple since
    we can easily keep track of what is still pending in the frontend. We can add
    this by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will add a display that shows how many outstanding requests we have
    in the frontend. We will put this right after our online status system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a button that will cancel all outstanding requests to our `index.html` file.
    Also, add the corresponding JavaScript code to our `interactions.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the corresponding handler to our `ServiceWorker` for the stop request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will utilize something called an `AbortController`. This system allows
    us to send signals to things such as fetch requests so that we can say that we
    want to stop the pending request. While this system is mainly for stopping fetch
    requests, we can actually utilize the signal in order to stop any asynchronous
    requests. We do this by creating an `AbortController` and grabbing the signal
    from it. Then, inside of our promise, we listen for the abort event on the signal
    and reject the promise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `AbortController`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we go into our system and ready up some requests in offline mode and
    then click the Cancel button, we will see that all of our requests get canceled!
    We could have put the `AbortController` on the fetch request in our frontend `interactions.js`
    file, but once we go back online, all of the promises would have still run, so
    we wanted to make sure that nothing was running. This is why we put it in the
    `ServiceWorker`.
  prefs: []
  type: TYPE_NORMAL
- en: By doing this, we have seen how we can not only handle requests by caching data
    for them but that we can also store those requests when we have spotty locations.
    On top of this, we have seen how we can utilize the `AbortController` to stop
    pending promises and how to utilize them besides just stopping fetch requests.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how service workers can turn our applications from
    always being online to systems where we can create truly *always working* applications.
    By saving the state, handling requests locally, enriching requests locally, and
    even saving requests for offline use, we are able to handle the full state of
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have looked at creating rich web applications from both the client
    side and the server side with JavaScript, we will start to take a look at some
    advanced techniques that we can use to create highly performant applications that
    we only thought were possible through native application code. We can do this
    by utilizing C, C++, or Rust.
  prefs: []
  type: TYPE_NORMAL
- en: However, before we get to that, one piece of application development that is
    often overlooked by application developers is the deployment process. In the next
    chapter, we will look at a way of setting up **continuous integration and continuous
    development** (**CI**/**CD**) through a popular system called CircleCI.
  prefs: []
  type: TYPE_NORMAL
