- en: Interacting with the Virtual World - Part II
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we set up our hands and learned how to animate them. As
    we mentioned then, this alone can represent a big step toward establishing presence
    in our application. Now, let's take things to the next step and start using them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use Blueprint interfaces to add functionality to a variety of Blueprints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use attachments to pick up and drop physics actors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to indicate to players when they can interact with an object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create haptic feedback effects to provide more tactile feedback to the
    user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an object we can pick up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll begin by making a few objects we can pick up. Let''s start with a simple
    cube:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in your project's `Blueprints` directory in your content browser
    and select Create Basic Asset | Blueprint Class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This time, instead of selecting one of the common classes as its parent class,
    expand the All Classes entry at the bottom of the Pick Parent Class dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select Static Mesh Actor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6241c46a-6ddd-4d3e-b5d1-b4ab61cea61c.png)'
  prefs: []
  type: TYPE_IMG
- en: Name it `BP_PickupCube`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open up `BP_PickupCube`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can see that it inherited a `Static Mesh Component`.
  prefs: []
  type: TYPE_NORMAL
- en: We could just as easily have created an `Actor` Blueprint and added a `Static
    Mesh` component, but it's a good idea to get in the habit of choosing your parent
    classes appropriately when you're building a new asset. Don't reinvent things
    if you don't have to.
  prefs: []
  type: TYPE_NORMAL
- en: Set the Static Mesh property of `Static Mesh Component` to `Engine Content/Basic
    Shapes/Cube1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Scale to `0.2, 0.2, 0.2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Materials | Element 0 to `Content/SoulCity/Environment/Materials/Props/MI_Glow`.
    (Or anything else you like, but this one will be easy to see in the map.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we want our cube to simulate physics, so let''s set a few values to make
    this happen:'
  prefs: []
  type: TYPE_NORMAL
- en: Set its Physics | Simulate Physics flag to `True`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Collision | Simulation Generates Hit Events to `True`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Collision | Generate Overlap Events to `True`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure its Collision | Collision Presets is set to `PhysicsActor`. (This
    should have been set for you automatically when you set Simulate Physics to true.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Collision | Can Ever Affect Navigation to `False`. (This will be hidden
    in the Collision section's Advanced properties.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We've now created a small glowing cube that will respond naturally to physics,
    but not block our navmesh as it moves around the world.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we're going to need to give it the ability to be picked up. There are a
    few ways we could do this. We could simply write `Pickup` and `Drop` methods right
    into blueprint of `BP_PickupCube`, but we're going to need to be able to call
    these functions from outside.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw previously, if you want to call a function from outside its blueprint,
    you have to be sure you're talking to a class that contains that function, which
    we do by casting the reference to that class. This would be fine if we only ever
    anticipated picking up cubes, but what if we want to be able to make other objects
    easy to pick up? We don't want to have to rewrite our `BP_VRHand` blueprint every
    time we add a new type of object that could be picked up, so that's not a great
    solution here.
  prefs: []
  type: TYPE_NORMAL
- en: We could derive `BP_PickupCube` from a common parent that implemented the `Pickup`
    and `Drop` methods, and just cast our references to that parent. That's better,
    but still not perfect. `BP_PickupCube` inherits from `StaticMeshActor`, but what
    if we want to make it possible for something that inherits from `SkeletalMeshActor`
    to be picked up? We don't have an easy way to create a common parent class in
    that instance.
  prefs: []
  type: TYPE_NORMAL
- en: The answer to this dilemma is a *Blueprint Interface*. An interface is a Blueprint
    object that allows us to define functions that can be called on any object that
    implements the interface, no matter what class that object derives from. It's
    a class you can attach to any object, and it acts as a promise that the object
    to which it's attached will implement each of the functions included in the interface.
    If I create an interface that declares the `Pickup` and `Drop` functions, for
    example, and I apply that interface to my `BP_PickupCube`, I can call the `Pickup`
    and `Drop` methods without having to cast the object first. This is a powerful
    pattern. You can make your code very flexible and easy to extend by using interfaces
    smartly.
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry if this isn't completely clear yet. It's going to make more sense
    once we build it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Blueprint Interface for pickup objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a Blueprint Interface, follow the given steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click in your project''s `Blueprints` directory, and select Create Advanced
    Asset | Blueprints | Blueprint Interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0f6892a9-d00b-4158-9223-4d6c0676b2bf.png)'
  prefs: []
  type: TYPE_IMG
- en: Name it `BPI_PickupActor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you open it up, you'll see that it contains a Functions list, and nothing
    else. You'll notice that the graph can't be edited. This is because the interface
    is simply a list of functions that the attached object must implement, but those
    functions don't get written in the interface.
  prefs: []
  type: TYPE_NORMAL
- en: By default, it's created a new function declaration for you. Name it `Pickup`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under the function''s Details | Inputs, add a new input. Set its type to Scene
    Component | Object Reference, and name it `AttachTo`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a302c11e-2af7-4586-a1b8-a1a1c1c400ad.png)'
  prefs: []
  type: TYPE_IMG
- en: Add another function, and call it `Drop`. This one doesn't need any input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile, save, and close the interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s apply this new interface to `BP_PickupCube`:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `BP_PickupCube`, and hit the Class Settings item on the toolbar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under Details | Interfaces, hit the Add button under Implemented Interfaces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `BPI_PickupActor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing the Pickup and Drop functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve added this interface to the `BP_PickupCube` class, we can implement
    the functions we declared in that interface in our event graph. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: In your Event Graph, right-click and select `Event Pickup` to create a Pick
    up event. This event exists on this Blueprint class now because we've attached
    an interface that declares it. You'll see that the event indicates that it's an
    interface event from `BPI_PickupActor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `Drop` event in the same way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we've created handlers for the two events coming from our interface,
    let's make them work.
  prefs: []
  type: TYPE_NORMAL
- en: When this object is picked up, we want to turn off its physics simulation so
    that it doesn't fall out of our hand, and we want to attach it to a scene component
    on the hand that's picking it up.
  prefs: []
  type: TYPE_NORMAL
- en: Drag a reference to the `Static Mesh Component` onto the Event Graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `Set Simulate Physics` on it, setting Simulate to `False`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click in the graph and select `Get Root Component`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag a connector from the Root Component reference, and select `Attach to Component`.
    You''ll see that there are two options for this. Roll over them and select the
    one whose tooltip reads Target is Scene Component, since we''re going to be attaching
    to a scene component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/430b3db9-2269-42d6-9e4b-54f0e9c46095.png)'
  prefs: []
  type: TYPE_IMG
- en: Drag the Attach To output from `Event Pickup` to the Parent input on the `Attach
    To Component` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On your `Attach To Component` node, set the Location, Rotation, and Scale rules
    to `Keep World`, and set Weld Simulated Bodies to `False`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your completed Pickup implementation should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9bcdbd11-2638-42b6-98ec-65ae2a89d680.png)'
  prefs: []
  type: TYPE_IMG
- en: When we drop this object, we want to turn its physics back on and detach it
    from the scene component we attached when we picked it up.
  prefs: []
  type: TYPE_NORMAL
- en: Select your `Static Mesh Component` reference and the `Set Simulate Physics`
    call, and hit *Ctrl* + *W* to duplicate them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect execution of Event Drop pin to the copied `Set Simulate Physics` call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set Simulate to True so that we're turning physics back on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click and create a `Detach From Actor` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the Location, Rotation, and Scale rules to `Keep World`, just as we did
    on the Attach node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your completed Drop implementation should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/75e40a5e-6086-496e-a676-0fba59a592f4.png)'
  prefs: []
  type: TYPE_IMG
- en: That's it for our `Pickup Cube` actor. We can close the blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up VRHand to pick up objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we're ready to get our hands grabbing these objects.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a function to find the nearest pickup object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next thing we need to do is find out what objects are near enough to our
    hand to be picked up. Let''s create a function to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: In `BP_VRHand`, create a new function called `FindNearestPickupObject`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Category to `Grabbing` and its Access Specifier to `Private`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In its implementation graph, right-click to create a `Get All Actors with Interface` node,
    and set its Interface value to `BPI_PickupActor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is going to give us an array of every actor in the scene that implements
    the `BPI_PickupActor` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Drag a connector from the Out Actors output and create a `For Each Loop` node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/93f533aa-f514-4685-9588-adf98fe18ba8.png)'
  prefs: []
  type: TYPE_IMG
- en: We're going to iterate through the actors that could possibly be picked up,
    ignore any actor that's too far to be considered, and then return the closest
    remaining eligible actor.
  prefs: []
  type: TYPE_NORMAL
- en: From the `For Each Loop` Array Element output, drag out a connector and call
    `Get Actor Location` on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a reference to `Hand Mesh` onto your graph and call `Get World Location`
    on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Subtract the hand mesh''s world location from the array element''s actor location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2b1f079b-6e50-42a3-85c4-95fb275647eb.png)'
  prefs: []
  type: TYPE_IMG
- en: Get `Vector Length Squared` for the resulting vector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag out its result and select Promote to local variable. Name the new variable
    `LocalCurrentActorDistSquared`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4d29b514-f173-4531-91f5-9e9fd8b773e1.png)'
  prefs: []
  type: TYPE_IMG
- en: Connect the Loop Body execution line to the local variable's setter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the output from our local variable setter and create a `<=` test to see
    whether it's equal to or shorter than the value we're going to give it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The reason why we're creating a local variable here is that we're going to need
    to use this value again if there's more than one grabbable actor in our test radius,
    and we don't want to waste time recalculating the distance, so we're stashing
    it here so that we can use it later if we need it.
  prefs: []
  type: TYPE_NORMAL
- en: Create a float variable and name it `GrabRadius`. Compile the Blueprint and
    set its value to 32.0\. (Later on, you can tune this value to whatever feels right
    for you.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Ctrl* + drag `GrabRadius` onto your graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a connector from its output and `Square` it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the result of the square to the `<=` test''s second input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2e705634-cc56-4bd7-a55b-81af28f08578.png)'
  prefs: []
  type: TYPE_IMG
- en: Remember when we mentioned that real distance checks are expensive? This is
    a place where it matters because we're going to call this function on the `Tick`
    event. Since we just want to see whether the actor is within the supplied radius,
    but we don't care how far away it really is, it's cheaper to do this test on the
    squared values.
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Branch` node from our `<=` test's output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If our actor passes the `<=` test, we know it's within the grab range. Now,
    we need to see whether it's the closest object in that range.
  prefs: []
  type: TYPE_NORMAL
- en: In the Local Variables list, create a new local variable named `ClosestRange`,
    and set its Variable Type to `Float`. Set its Default Value to `10000.0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Local variables are variables that only exist within the function in which they're
    declared. They can't be read from outside the function. It's a good idea to use
    local variables within functions for values that are only used by that function
    so that they don't clutter the surrounding object. Local variables are also reset
    to their default values each time the function is run, so you don't have to worry
    about strange values hanging around from previous function calls.
  prefs: []
  type: TYPE_NORMAL
- en: Press *Ctrl* + drag `LocalCurrentActorDistSquared` onto your graph to get its
    value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a connector from its output and create a `<` test from it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `Closest Range` local variable into the test's second input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `Branch` using the `<` test result as its condition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8c110ea9-24eb-4e36-92b0-20436c5f7893.png)'
  prefs: []
  type: TYPE_IMG
- en: If this test returns true, we've found a new closest actor. We want to save
    a reference to it and record its distance as the new closest range.
  prefs: []
  type: TYPE_NORMAL
- en: Press *Alt* + drag `Closest Range` onto the graph, and drag `LocalCurrentActorDistSquared`
    into its input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set this value from the branch's True output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new local variable named `NearestPickupActor`, and set its type to
    Actor | Object Reference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Alt* + drag it onto the graph to set its value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its value to the `For Each Loop` Array Element. (This is going to be a long
    connection. Consider creating some reroute nodes to make it more readable.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect it to the output from the `Set Closest Range` node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bd6496a1-cab8-4094-ac19-8f186c17a12a.png)'
  prefs: []
  type: TYPE_IMG
- en: Finally, once we've iterated through all of the possible objects and found our
    best pickup candidate if one exists, we want to save that value so that it can
    be used by our pickup method.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new variable (not a local variable this time—we want to read this value
    outside), name it `AvailablePickupActor`, and set its type to `Actor > Object
    Reference`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Alt* + drag it onto the event graph near the Completed output of the `For
    Each Loop`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the Completed output of the `For Each Loop` to the Set input of `Available
    Pickup Actor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag the `Nearest Pickup Actor` local variable onto the setter''s input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4865f89c-0d42-4cd8-9091-e8b89c5f71d4.png)'
  prefs: []
  type: TYPE_IMG
- en: What this is going to do is set an externally readable `Available Pickup Actor`
    variable to the actor we found when we iterated through the list of possible actors,
    if we found any. `Nearest Pickup Actor` will be `Null` if we didn't find any.
  prefs: []
  type: TYPE_NORMAL
- en: Calling Find Nearest Pickup Object on the Tick event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, it''s time to call our new function so that we know when we''re able to
    pick an object up. We don''t want to do this, however, if we''re already holding
    an object, so we should store a reference to any object we''re already holding.
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Return to your event graph of `BP_VRHand` and find `Event Tick`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `Sequence` node near `Event Tick`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want to update our hand animation only after we've looked for objects we
    could grab, so press *Ctrl* + drag the output from execution pin of Event Tick
    onto the `Sequence` node's Then 1 output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the execution pin of Event Tick to the Sequence node's input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Marquee select the node network connected to the Sequence node''s Then 1 output
    and drag them down to give yourself some room to work:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/948645f5-41bf-4f3d-944c-1742a040e197.png)'
  prefs: []
  type: TYPE_IMG
- en: Create a new variable, name it `HeldActor`, and set its Variable Type to `Actor
    > Object Reference`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Ctrl* + drag `HeldActor` onto your event graph to get its value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click it and select `Convert to Validated Get`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag a call to `Find Nearest Pickup Object` onto the graph, and call it from
    the `Held Actor` getter''s Is Not Valid output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7c4c66f1-d743-4cf8-9015-4af48453a5d1.png)'
  prefs: []
  type: TYPE_IMG
- en: This way, we're only bothering to check for pickup actors if we're not already
    holding one.
  prefs: []
  type: TYPE_NORMAL
- en: Picking up an actor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''re looking for actors we could pick up, let''s make that happen
    when we try to grab them. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up your `Grab Actor` function in `BP_VRHand`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We don't need the `Print String` node here anymore, so we can delete it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Ctrl* + drag a getter for `HeldActor` onto your graph, right-click it,
    and convert it into a validated get.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the `bWantsToGrip` setter's execution output to the `HeldActor` getter's
    input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Ctrl* + drag a getter for `AvailablePickupActor` onto the graph and make
    this a validated get too.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the Is Not Valid output from the `Held Actor` get to this getter's input,
    since we're only interested in picking up an object if we're not already holding
    one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag out a connector from `Available Pickup Actor` and call `Pickup (Message)`
    on it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5b7a1fbf-1474-4f7b-a4ff-a0fc14c84f34.png)'
  prefs: []
  type: TYPE_IMG
- en: This is why Blueprint Interfaces are so useful. We didn't need to cast the pickup
    actor to any particular class to call the interface method on it. We can simply
    make the call, and if the object implements the interface and knows what to do
    with it, the call will work. If the object doesn't implement the interface, it
    simply does nothing.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to find out whether a given actor implements an interface, call
    `Does Implement Interface` on it. This will return true if the interface is found
    on the object. In this particular case, making this call would be redundant since
    we know that `Available Pickup Actor` will always implement the BPI_PickupActor
    interface. We used that interface as a filter when we were looking for objects
    in the `Find Nearest Pickup Object` function.
  prefs: []
  type: TYPE_NORMAL
- en: Drag the Motion Controller component onto your `Pickup` node's Attach To input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `Held Actor` variable onto the output of `Available Pickup Actor` to
    set it to that value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `Return Nodes` to your exit points. (You don't have to do this, but your
    code will be far more readable in the long run if you make this a habit.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your completed `Grab Actor` graph should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/60d8fcc5-e09b-43dc-b1de-c05f624e1cb5.png)'
  prefs: []
  type: TYPE_IMG
- en: To summarize what's going on here, when `Grab Actor` is called, `bWantsToGrip`
    is set to true, and then we check to see whether we're already holding an object.
    We don't do anything more if we are. If we're not, we check to see whether we
    found an object on `Event Tick` that we could pick up. If we didn't, there's nothing
    more to do. If we did, we send a `Pickup` message to it through its interface,
    with a reference to our `Motion Controller` component as the object it should
    attach to, and we stash it as our `Held Actor`.
  prefs: []
  type: TYPE_NORMAL
- en: Releasing an actor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we can now pick an actor up, we''re also going to want to be able to
    drop it again. Let''s do this now:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up the `Release Actor` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the `Print String` node from it—we're done with it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Ctrl* + drag `Held Actor` onto the graph, right-click it, and convert
    it into a validated get.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the validated get after we set `bWantsToGrip`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect a return node to its Is Not Valid output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/44d80e44-3f0e-47ca-9c83-be8832b4f2ee.png)'
  prefs: []
  type: TYPE_IMG
- en: If we're not holding anything, there's nothing more we need to do. If we are,
    we should make sure that the actor still thinks we're the one holding it (since
    we could have grabbed it with the other hand) and drop it if it's still our object.
  prefs: []
  type: TYPE_NORMAL
- en: Drag a connector from `Held Actor` and get its `Root Component`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `Get Attach Parent` on the root component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a connector from Return Value of `Get Attach Parent` and create a `==` test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `Motion Controller` component onto the test's other input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `Branch` using this test''s result as its condition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c6ecad42-83ce-4719-93c8-a62ca4ac567a.png)'
  prefs: []
  type: TYPE_IMG
- en: From the Branch's True output, call `Drop` on the `Held Actor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Alt* + drag `Held Actor` onto the graph to create a setter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect it to the execution output from the `Drop` call, and to the `Branch`
    node''s False output so that we clear the value in either case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e35f0d9b-4de9-4ece-b48a-7f6e118ecfbe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Your completed graph should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/37bd944a-c500-4aeb-897e-376f18e2d8b5.png)'
  prefs: []
  type: TYPE_IMG
- en: To recap what's going on here, when `Release Actor` is called, we first set
    `bWantsToGrip` to false. We then check to see whether we're currently holding
    anything. If we're not, there's nothing more to do. If we think we are holding
    something, we check to make sure the object we think we're holding still sees
    our motion controller as its parent, since we could have grabbed it with the other
    hand. If we really are holding the object, we drop it and clear out the `Held
    Actor` variable. If it turned out we were no longer holding the object after all,
    we clear out the `Held Actor` variable so that we no longer think we are.
  prefs: []
  type: TYPE_NORMAL
- en: Test grabbing and releasing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s test this in our map:'
  prefs: []
  type: TYPE_NORMAL
- en: From your editor's Modes panel, select Place | Basic | Cube, and drag it into
    your scene. Set its Location to X=-2580, Y=310, Z=40 so that it's sitting near
    the player start.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Grab `BP_PickupCube` from your content browser, and place it on the cube you
    just placed. You can use the *End* key to drop it to the surface below it. (`X=-2600,
    Y=340, Z=100` is probably a decent location for it.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Press *Alt* + drag a few more of these `BP_PickupCubes` and stack them on the
    cube:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/528238fa-1aaf-43f9-9971-90f334e09cef.png)'
  prefs: []
  type: TYPE_IMG
- en: Launch a VR Preview. Walk or teleport up to the objects on the cube and use
    the triggers to pick them up, drop them, throw them, and move them from hand-to-hand.
  prefs: []
  type: TYPE_NORMAL
- en: Not bad, but there are a few things we need to fix here.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing cube collision
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, and most importantly, they''re colliding with the VRPawn''s collision
    capsule and throwing us around. We''d better fix that:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `BP_PickupCube` blueprint and select its `Static Mesh Component`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under its Details | Collision, change its Collision Presets from `PhysicsActor` to
    `Custom`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The individual collision response channels for this object are now editable.
    Set the Pawn collision response to `Overlap` instead of `Block`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f03374d8-d06f-4f7d-9de2-d9fe79f35efa.png)'
  prefs: []
  type: TYPE_IMG
- en: This way, we can still detect collisions with the pawn if we're interested in
    them, but they're not going to prevent the player from moving around.
  prefs: []
  type: TYPE_NORMAL
- en: Letting players know when they can pick something up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Secondly, we're not giving the player any visual indication that they can pick
    something up. Let's improve this.
  prefs: []
  type: TYPE_NORMAL
- en: 'First off, let''s add another state to our `EGripState` enumerator:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up `EGripState` from your project's `Blueprints` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under its Enumerators list, hit New to add another entry. Name it `CanGrab`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close and save it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we need to tell our Animation Blueprint what to do with this.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `ABP_MannequinHand_Right` animation blueprint and open its `Event Graph`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under `Event Blueprint Update Animation`, you''ll see that the `Grip State`
    `Select` node has been automatically updated to reflect the new `Can Grab` enumerator
    we added. Set its value to `0.5`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6cdbd564-b00b-479b-a391-f2b9296a3e77.png)'
  prefs: []
  type: TYPE_IMG
- en: Try it out by compiling and then changing Grip State in the Anim Preview Editor.
    The hand should go to a halfway-open state when Grip State is set to `Can Grab`.
  prefs: []
  type: TYPE_NORMAL
- en: Save and close your animation blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to get the `BP_VRHand` blueprint to set `Grip State` to `Can Grab` when
    it detects that the player can grab something. Let's create a pure function to
    determine what our `Grip State` should be.
  prefs: []
  type: TYPE_NORMAL
- en: Open Event Graph of `BP_VRHand` and find `Event Tick`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `bWantsToGrip` reference and the `Select` node connected to it and
    collapse them into a function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Name the function `DetermineGripState`, set its Category to Grabbing, set its
    Access Specifier to Private, and set Pure to True:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5c7a0977-18fe-4325-a3df-da60e3ef5d1a.png)'
  prefs: []
  type: TYPE_IMG
- en: Open up `DetermineGripState`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Ctrl* + drag `Held Actor` onto the graph and convert it into a validated
    get.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect it to the function input and add a new `Return Node` from its Is Valid
    output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set this node''s Return Value to `Gripping`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5b424d48-a4b6-43f2-a8d9-f25762d896bd.png)'
  prefs: []
  type: TYPE_IMG
- en: If we're holding an object, we don't care about anything else—we should just
    animate to the Gripping state.
  prefs: []
  type: TYPE_NORMAL
- en: Add a `Branch` node to the graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `bWantsToGrip` value into its Condition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect its True branch to the `Gripping` `Return Node` we just created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Ctrl* + drag `AvailablePickupActor` onto the graph and convert it into
    a validated get.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add another `Return Node` connected to its Is Valid output, and set its Return
    Value to `Can Grab`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add another `Return Node` to its Is Not Valid output, with the value Open:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/536a1608-bb13-48fd-a6ec-3b7b2089e5a6.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's test it out. Now, you should see the hand change its pose when it detects
    an object it can grab.
  prefs: []
  type: TYPE_NORMAL
- en: Adding haptic feedback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's one other thing we should be doing, which is adding some degree of feedback
    to the hand when the player makes contact with an object. This may seem like a
    small thing, but it's actually significant to the process of evoking presence.
    We don't have many ways at present to simulate physical sensations, but any sensation
    at all that's paired to an event or action can go a long way toward making the
    virtual world feel less "ethereal" and more physical.
  prefs: []
  type: TYPE_NORMAL
- en: Let's learn how to add a bit of rumble to our controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Haptic Feedback Effect Curve
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we need to create the haptic effect we want to play:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click in your project''s `Blueprints` directory and select Create Advanced
    Asset | Miscellaneous | Haptic Feedback Effect Curve:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d1f14b93-71a3-4087-869f-34b2d4fe91fc.png)'
  prefs: []
  type: TYPE_IMG
- en: Name it `FX_ControllerRumble`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Haptic Feedback Effect Curve we just created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You''ll see that you have two curves under Haptic Feedback Effect | Haptic
    Details: Frequency and Amplitude. We''re going to create a very simple effect
    here, but it''s really worth experimenting with these curves and figuring out
    how to create convincing feedback effects.'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on your Frequency curve's timeline near the 0.0 time and select
    `Add key to None`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Fix its Time and Value settings to read `0.0` for each:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1e8b2ce2-e5f4-41aa-8206-f41e9a90b243.png)'
  prefs: []
  type: TYPE_IMG
- en: Right-click again on the timeline and add another key. Set this one's Time to
    `0.5` and its Value to `1.0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a third key on the curve, with Time as `1.0` and Value as `0.0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the same three keys for your Amplitude curve:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/16145565-fb02-4512-aba4-465cd9a261aa.png)'
  prefs: []
  type: TYPE_IMG
- en: Your completed curves should look like what's shown in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: Save and close your new haptic effect curve.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Playing the haptic effect on command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve created a Haptic Feedback Effect Curve, let''s set up a method
    to play it:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Event Graph of `BP_VRHand` and right-click. Select Add Event | Add Custom
    Event. Name the new event `RumbleController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an Input for this event. Name it `Intensity`, and set its type to `Float`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click and create a `Get Player Controller` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a connector out from `GetPlayerController` and create a `Play Haptic Effect`
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Haptic Effect we just created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `Hand` variable into the Hand input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag the event''s Intensity output into the Scale input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cf89b216-3ece-4f85-870d-1b119b557c34.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's call this Gaptic effect whenever we make contact with a new object
    we could pick up.
  prefs: []
  type: TYPE_NORMAL
- en: Open up your `Find Nearest Pickup Object` function of `BP_VRHand`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See where we're setting `Available Pickup Actor` to the value we found in `Nearest
    Pickup Actor`? Let's detect when we're putting a new value in there and trigger
    the effect when that happens.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click your `Nearest Pickup Actor` getter, and convert it into a validated
    get.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Ctrl *+ drag the execution input into `Set Available Pickup Actor` onto
    the `Get Nearest Pickup Actor` getter's execution input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a connector from the `Nearest Pickup Actor` getter's value and create a
    `!=` (Not Equal) node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a reference to `Available Pickup Actor` from your Variables list into the
    `Not Equal` node's other input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `Branch` from its output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the Is Valid execution pin from `Nearest Pickup Actor` into the `Branch`
    input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `Rumble Controller` from its True output and set its Intensity to `0.8`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the output from `Rumble Controller` into your `Available Pickup Actor`
    setter's input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the Is Not Valid output from `Nearest Pickup Actor` into the setter of `Available
    Pickup Actor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add return nodes after `Set Available Pickup Actor` and from the `Not Equal`
    test''s `False` branch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cd15ad1a-8fc6-4fe5-a98a-73e5fcf518ee.png)'
  prefs: []
  type: TYPE_IMG
- en: To recap what's going on here, once we've completed iterating through the objects
    we could potentially pick up, we need to check whether we've found one. If we
    didn't, we just set `Available Pickup Actor` to the null value so that we're clearing
    it if it previously contained a value. If we did find an object we could pick
    up, we check to see whether it's different from our current `Available Pickup
    Actor`. If it is, we rumble the controller before we set `Available Pickup Actor`
    to the new value.
  prefs: []
  type: TYPE_NORMAL
- en: Going further
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a few ways we could further improve on what we''ve done here:'
  prefs: []
  type: TYPE_NORMAL
- en: First, detecting grabbable objects by distance gives us fuzzy results. It doesn't
    take the object's size into account. Using a sphere to represent our grabbing
    hand and testing for overlaps against this sphere is going to give us more accurate
    results. If you'd like to refactor this code to use that method, the VR Template
    project contains a good example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, our haptic feedback effect feels indistinct. It fades in and out evenly,
    and doesn't provide much of a physical sensation. Editing those curves to provide
    a sharper attack could make the effect more convincing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter picked up where the last one left off and gave us a chance to start
    picking up objects. We learned how to use Blueprint Interfaces to enable function
    calls to be made on a wide variety of objects and how to detect actors we could
    pick up and use attachments to pick them up and drop them. Finally, we also learned
    how to create haptic feedback effects to indicate to players when they've made
    contact with an object they can pick up.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned at the start of the previous chapter, hand presence is an important
    factor in driving an overall sense of presence in VR. We're aware of our hands
    all of the time in real life, and bringing them into the virtual world does a
    lot to make us feel present in the space as well. In addition, the ability to
    use our hands to manipulate objects directly is one of the crucial things we can
    do in VR that we just can't do in any other medium. (For an example of just how
    well this can be done, check out *Vinyl Reality* by **EntroPi Games** ([https://vinyl-reality.com/](https://vinyl-reality.com/))
    and then imagine trying to do the same thing with a gamepad or a keyboard.) Hands
    are important to VR, and they're unique to VR. Take the time to get them right
    in your applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to learn how to create user interfaces in VR
    to display information and to make it possible for users to interact in 3D space.
  prefs: []
  type: TYPE_NORMAL
