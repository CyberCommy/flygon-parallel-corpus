- en: Dealing with Communication Channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with email templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending an individual email
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading an email
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding subscribers to an email newsletter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending notifications via email
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Producing SMS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receiving SMS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Telegram bot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dealing with communication channels is where automating things can produce big
    gains. In this recipe, we'll see how to work with two of the most common communication
    channels—emails, including newsletters, as well as sending and receiving text
    messages by phone.
  prefs: []
  type: TYPE_NORMAL
- en: During the years, there has been a fair amount of abuse in methods of delivery,
    like spam or unsolicited marketing messages, making necessary to partner with
    external tools to avoid messages to be automatically rejected by automated filters.
    We will present the proper caveats where applicable. All the tools presented have
    excellent documentation, so do not be afraid to read it. They also have a lot
    of features, and they may be able to do something that is exactly what you're
    looking for.
  prefs: []
  type: TYPE_NORMAL
- en: Working with email templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To send an email, we first need to generate its content. In this recipe, we'll
    see how to generate a proper template, in both text-only style and HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We should start by installing the `mistune` module, which will compile Markdown
    documents into HTML. We will also use the `jinja2` module to combine HTML with
    our text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the GitHub repo, there are a couple of templates we will use—`email_template.md`
    in [https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter08/email_template.md](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter08/email_template.md)
    and a template for styling, `email_styling.html`, in [https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter08/email_styling.html](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter08/email_styling.html).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Import the modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Read both templates from disk:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `data` to include in the template. The template is quite simple
    and accepts only a single parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Render the Markdown template. This produces the text-only version of the `data`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Render the Markdown and add the styling:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the text and the HTML version to disk to check them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the text version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the HTML version in a browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/cc6cc1e0-aeaf-4e3a-911b-dacf333609ee.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Step 1 gets the modules that will be used later, and step 2 reads the two templates
    that will be rendered. `email_template.md` is the basis of the content, and it's
    a Markdown template. `email_styling.html` is an HTML template that contains the
    basic HTML surrounding and CSS styling information.
  prefs: []
  type: TYPE_NORMAL
- en: The basic structure is to create the content in Markdown format. This is a plain-text
    file that's readable and can be send as part of the email. That content can then
    be converted into HTML and surrounded with some styling to create an HTML function. `email_styling.html`
    has a content area to put the rendered HTML from Markdown.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 defines the data that will render in `email_template.md`. It is a very
    simple template that only requires a parameter called `name`.
  prefs: []
  type: TYPE_NORMAL
- en: In step 4, the Markdown template gets rendered with the `data`. This produces
    the plain-text version of the email.
  prefs: []
  type: TYPE_NORMAL
- en: The `HTML` version is rendered in step 5\. The plain-text version is rendered
    to `HTML` using `mistune`, and then it is wrapped in `email_styling.html` using
    a `jinja2` template. The final version is a self-contained HTML document.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we save both versions, plain-text (as `text`) and HTML (as `html`),
    to a file in step 6\. Steps 7 and 8 check the stored values. The information is
    the same, but in the `HTML` version, it is styled.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Markdown makes dual emails with text and HTML easy to generate. Markdown
    is quite readable in text format, and renders very naturally into HTML. That said,
    it is possible to generate a totally different HTML version, which will allow
    for more customization and taking advantage of HTML's features.
  prefs: []
  type: TYPE_NORMAL
- en: The full Markdown syntax can be found at [https://daringfireball.net/projects/markdown/syntax](https://daringfireball.net/projects/markdown/syntax) and
    a good cheat sheet with the most commonly used elements is at [https://beegit.com/markdown-cheat-sheet](https://beegit.com/markdown-cheat-sheet).
  prefs: []
  type: TYPE_NORMAL
- en: While making a plain-text-only version of an email is not strictly necessary,
    it is a good practice and shows you care about who reads the email. Most email
    clients accept HTML, but it's not totally universal.
  prefs: []
  type: TYPE_NORMAL
- en: For an HTML email, note that the whole style should be contained in the email.
    That means that the CSS needs to be embedded into the `HTML`. Avoid making external
    calls that could lead the email to not render properly in some email clients,
    or even be qualified as spam.
  prefs: []
  type: TYPE_NORMAL
- en: The styling in `email_styling.html` is based on the modest style that can be
    found here: [http://markdowncss.github.io/](http://markdowncss.github.io/). There
    are more CSS styles that can be used, and a search in Google should find more.
    Remember to remove any external references, as discussed before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Images can be included in HTML by encoding the image in `base64` format so
    it can be embedded directly in the HTML `img` tag, instead of adding a reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can find more information about this technique in this article: [https://css-tricks.com/data-uris/](https://css-tricks.com/data-uris/).
  prefs: []
  type: TYPE_NORMAL
- en: The `mistune` full docs are available at [http://mistune.readthedocs.io/en/latest/](http://mistune.readthedocs.io/en/latest/) and
    the `jinja2` documentation at [http://jinja.pocoo.org/docs/2.10/](http://jinja.pocoo.org/docs/2.10/).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Formatting text in Markdown* recipe in [Chapter 5](d628b5e8-8d78-4884-905c-18b393bfcb47.xhtml),
    *Generating Fantastic Reports*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using templates for reports recipe* in [Chapter 5](d628b5e8-8d78-4884-905c-18b393bfcb47.xhtml),
    *Generating Fantastic Reports *
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Sending transactional emails* recipe in [Chapter 5](d628b5e8-8d78-4884-905c-18b393bfcb47.xhtml),
    *Generating Fantastic Reports *
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending an individual email
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most basic way of sending an email is to send an individual one from an
    email account. This option is only recommended for very sporadic use, but for
    simple purposes such as sending a couple of emails a day to controlled addresses,
    it can be good enough.
  prefs: []
  type: TYPE_NORMAL
- en: Do not use this method to send emails in bulk to distribution lists or to customers
    with unknown email addresses. You risk being banned from your service provider
    due to anti-spam rules. See other recipes in this chapter for more options.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we'll need an email account with a service provider. There
    are small differences based on the provider to use, but we'll use a Gmail account,
    as it is very common and free to access.
  prefs: []
  type: TYPE_NORMAL
- en: Due to Gmail's security, we'll need to create a specific app password that can
    be used to send an email. Follow the instructions here: [https://support.google.com/accounts/answer/185833](https://support.google.com/accounts/answer/185833).
    This will help to generate a password for the purpose of this recipe. Remember
    to create it for mail access. You can delete the password afterwards to remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: We'll use the `smtplib` module, which is part of Python's standard library.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Import the `smtplib` and `email` modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Set up the credentials, replacing these with your own ones. For testing purposes,
    we''ll send to the same email, but feel free to use a different address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the data to be sent. Notice the two alternatives, a plain-text one and
    an HTML one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Compose the message as a `MIME` multipart, including `subject`, `to`, and `from`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Fill the data content parts of the email:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Send the email, using the `SMTP SSL` protocol:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The email is sent. Check your email account for the message. Checking the *original
    email*, you can see the full raw email, with elements in both HTML and plain-text.
    The email is presented redacted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/eedfbdbd-64da-4f0e-abd9-7fa23bbaf20d.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After step 1, making the pertinent imports from `stmplib` and `email`, step
    2 defines the credentials obtained from Gmail.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 shows the HTML and text that is going to be sent. They are alternatives,
    so they should present the same information, but in different formats.
  prefs: []
  type: TYPE_NORMAL
- en: The basic message information is set up in step 4\. It specifies the subject
    of the email, as well as the *from* and *to*. Step 5 adds multiple parts, each
    with the proper `MIMEText` type.
  prefs: []
  type: TYPE_NORMAL
- en: The last part added is the preferred alternative, according to the `MIME` format,
    so we add the `HTML` part last.
  prefs: []
  type: TYPE_NORMAL
- en: Step 6 sets up the connection with the server, logs in using the credentials,
    and sends the message. It uses a `with` context to get the connection.
  prefs: []
  type: TYPE_NORMAL
- en: If there's an error with the credentials, it will raise an exception with username
    and password not accepted.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note that `sent_to` is a list of addresses. You can send an email to more than
    one address. The only caveat is in step 4, where it needs to be specified as a
    list of comma-separated value for all addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Although it is possible to label `sent_from` as a different address than that
    used to send the email, it is not recommended. That can be interpreted as an indication
    of trying to fake the origin of the email, and provoke detection as a spam source.
  prefs: []
  type: TYPE_NORMAL
- en: 'The server used here, `smtp.gmail.com`*, *is the one specified by Gmail, and
    the defined port for `SMTPS` (secure `SMTP`) is `465`. Gmail also accepts port `587`,
    which is the standard, but requires you to specify the kind of session by calling `.starttls`,
    as shown in the next code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If you are interested in more details about these differences and both protocols,
    you can find more information in this article: [https://www.fastmail.com/help/technical/ssltlsstarttls.html](https://www.fastmail.com/help/technical/ssltlsstarttls.html).
  prefs: []
  type: TYPE_NORMAL
- en: The full `smtplib` documentation can be found at [https://docs.python.org/3/library/smtplib.html](https://docs.python.org/3/library/smtplib.html),
    and the `email` module, with info on the different formats for emails, including
    examples on `MIME` types, can be found here: [https://docs.python.org/3/library/email.html](https://docs.python.org/3/library/email.html).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Working with email templates* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Sending an individual email* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading an email
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll see how to read emails from an account. We'll use the
    `IMAP4` standard, which is the most commonly used standard for reading email.
  prefs: []
  type: TYPE_NORMAL
- en: Once read, the email can be processed and analyzed automatically to generate
    actions such as smart automated responses, forwarding the email to a different
    target, aggregating the results for monitoring, and so on. The options are unlimited!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we'll need an email account with a service provider. There
    are small differences based on the provider to use, but we'll use a Gmail account,
    as it is very common and free to access.
  prefs: []
  type: TYPE_NORMAL
- en: Due to Gmail's security, we'll need to create a specific app password to use
    to send an email. Follow the instructions here: [https://support.google.com/accounts/answer/185833](https://support.google.com/accounts/answer/185833).
    This will generate a password for the purpose of this recipe. Remember to create
    it for mail. You can delete the password afterwards to remove it.
  prefs: []
  type: TYPE_NORMAL
- en: We'll use the `imaplib` module, which is part of Python's standard library.
  prefs: []
  type: TYPE_NORMAL
- en: The recipe will read the last received email, so you can use it for better control
    over what's going to be read. We'll send a short email that looks like it was
    sent to support.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Import the `imaplib` and `email` modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Set up the credentials, replacing these with your own ones:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Connect to the email server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Select the inbox folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Read all email UIDs and retrieve the latest received email:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Parse the email into a Python object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Display the subject and sender of the email:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Retrieve the payload of the text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After importing the modules that will be used and defining the credentials,
    we connect to the server in step 3.
  prefs: []
  type: TYPE_NORMAL
- en: Step 4 connects to the `inbox`. This is a default folder in Gmail that contains
    the received email.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you may need to read a different folder. You can get a list of all
    folders by calling `mail.list()`.
  prefs: []
  type: TYPE_NORMAL
- en: In step 5, first a list of UIDs is retrieved for all the emails in the inbox
    by calling `.uid('search', None, "ALL")`. The last email received is then retrieved
    again from the server through a `fetch` action with `.uid('fetch', latest_email_uid,
    '(RFC822)')`. This retrieves the email in RFC822 format, which is the standard.
    Note that retrieving the email marks it as read.
  prefs: []
  type: TYPE_NORMAL
- en: The `.uid` command allows us to call IMAP4 commands, returning a tuple with
    the result (`OK` or `NO`) and the data. If there's an error, it will raise the
    proper exception.
  prefs: []
  type: TYPE_NORMAL
- en: The `BytesParser` module is used to transform from the raw `RFC822` email into
    a Python object. This is done in Step 6.
  prefs: []
  type: TYPE_NORMAL
- en: The metadata, including details such as the subject, the sender, and the timestamp,
    can be accessed like a dictionary, as shown in step 7\. The addresses can be parsed
    from raw text format to separate the part with `email.utils.parseaddr`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the content can be unfolded and extracted. If the type of the email
    is multipart, each of the parts can be extracted by iterating through `.get_payload()`.
    The one that's easier to deal with is `plain/text`, so assuming it is present,
    the code in step 8 will extract it.
  prefs: []
  type: TYPE_NORMAL
- en: The email body is stored in the `payload` variable.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In step 5, we are retrieving all the emails in the inbox, but that''s not necessary.
    The search can be filtered, for example by retrieving only the last day''s emails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This will search according to the date of the email. Notice the resolution is
    in days.
  prefs: []
  type: TYPE_NORMAL
- en: There are more actions that can be done through `IMAP4`. Check RFC 3501  [https://tools.ietf.org/html/rfc3501](https://tools.ietf.org/html/rfc3501) and
    RFC 6851 [https://tools.ietf.org/html/rfc6851](https://tools.ietf.org/html/rfc6851) for
    further details.
  prefs: []
  type: TYPE_NORMAL
- en: The RFCs describe the IMAP4 protocol and can be a little arid. Checking the
    possible actions will give you an idea of the possibilities to investigate in
    detail, probably by Googling for examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'The subject and body of the email, as well as other metadata such as date,
    to, from, and so on, can be parsed and processed. For example, the subject retrieved
    in this recipe can be processed in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: See [Chapter 1](e139aa50-5631-4b75-9257-d4eb2e12ef90.xhtml), *Let Us Begin Our
    Automation Journey* for more info about regular expressions and other ways of
    parsing information.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Introducing regular expressions* recipe in [Chapter 1](e139aa50-5631-4b75-9257-d4eb2e12ef90.xhtml),
    *Let Us Begin Our Automation Journey*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding subscribers to an email newsletter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common marketing tool is email newsletters. They are convenient ways of sending
    information to multiple targets. A good newsletter system is difficult to implement,
    and the recommended way is to use ones available in the market. A well known one
    is MailChimp ([https://mailchimp.com/](https://mailchimp.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: MailChimp has a lot of possibilities, but the interesting one in regard to this
    book is its API, which can be scripted to automate tools. This RESTful API can
    be accessed through Python. In this recipe, we will see how to add more subscribers
    to an existing list.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we will use MailChimp, we need to have an account available. You can create
    a free account at [https://login.mailchimp.com/signup/](https://login.mailchimp.com/signup/).
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating the account, be sure to at least have a list that we will add
    subscribers to. As part of the registration, it is possible that it has been created.
    It will appear under Lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/05182753-f7ff-4002-8e63-40cdbcfe5e36.png)'
  prefs: []
  type: TYPE_IMG
- en: The list will contain the subscribed users.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the API, we''ll need an API key. Go to Account | Extras | API keys and
    create a new one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a2174005-2a85-4c91-880a-a14ec426ca66.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will use the requests module for accessing the API. Add it to your virtual
    environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The MailChimp API uses the concept of the **DC** (**data center**) that your
    account uses. This can be obtained from the last digits of your API, or from the
    start of the URL from the MailChimp admin site. For example, in all the previous
    screenshots, it is `us19`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Import the `requests` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the authentication and base URLs. The base URL requires your `dc` at
    the start (such as `us19`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Obtain all your lists:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Filter your lists to obtain the `href` for the required list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'With the list URL, you can obtain the URL for the members of the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The list of members can be retrieved through a `GET` request to `members_url`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Append a new member to the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Retrieving the list of users with a `GET` obtains both users:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After importing the requests module in step 1, we define the basic values to
    connect in step 2, the base URL, and the credentials. Note that for the authentication,
    we only require the API key as the password, and any user (as described by the
    MailChimp documentation: [https://developer.mailchimp.com/documentation/mailchimp/guides/get-started-with-mailchimp-api-3/](https://developer.mailchimp.com/documentation/mailchimp/guides/get-started-with-mailchimp-api-3/)).
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 retrieves all the lists, calling the proper URL. The result is returned
    in JSON format. The call includes the `auth` parameter with the defined credentials.
    All subsequent calls will be made with that `auth` parameter for authentication
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Step 4 shows how to filter the returned list to grab the URL of the particular
    list of interest. Each of the returned calls includes a list of `_links` with
    related information, making it possible to walk through the API.
  prefs: []
  type: TYPE_NORMAL
- en: The URL for the list is called in step 5\. This returns information for the
    list, including the basic stats. Applying a similar filtering to step 4, we retrieve
    the URL for the members.
  prefs: []
  type: TYPE_NORMAL
- en: Due to size constraints and to show relevant data, not all of the retrieved
    elements are displayed. Feel free to analyze them interactively and find out about
    them. The data is well constructed, following the RESTful principles of discoverability;
    plus the Python ability of introspection makes it quite readable and understandable.
  prefs: []
  type: TYPE_NORMAL
- en: Step 6 retrieves the list of members, making a `GET` request to `members_url`,
    which can be seen as a single user. This can be seen in the *Getting Ready* section,
    in the web interface.
  prefs: []
  type: TYPE_NORMAL
- en: Step 7 creates a new user and posts on the `members_url` with the information
    passed in the `json` parameter, so it gets translated into JSON format. The updated
    data is retrieved in step 7, showing that there's a new user in the list.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The full MailChimp API is quite powerful and can perform a large number of tasks.
    Go to the full MailChimp documentation to discover all the possibilities: [https://developer.mailchimp.com/](https://developer.mailchimp.com/).
  prefs: []
  type: TYPE_NORMAL
- en: As a brief note, and a little out of scope of this book, please be aware of
    the legal implications of adding subscribers to an automated list. Spam is a serious
    worry and there are new regulations in place to protect the rights of customers,
    such as GPDR. Ensure that you have the permission of users to email them. The
    good thing is that MailChimp automatically implements tools to help with this,
    such as automatic unsubscribe buttons.
  prefs: []
  type: TYPE_NORMAL
- en: The general MailChimp documentation is also quite interesting and shows a lot
    of possibilities. MailChimp is capable of managing newsletter and general distribution
    lists, but it can also be tailored to generate flows, schedule the sending of
    emails, and automatically send messages to your audience based on parameters such
    as their birthday.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Sending an individual email* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Sending transactional emails* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending notifications via email
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will cover how to send emails that will be send towards customers.
    An email that is sent in response to an action by a user, for example, a confirmation
    email or an alert email, is called *a* **transactional email**. Due to spam protection
    and other limitations, it is better to implement this kind of email with the help
    of external tools.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use Mailgun ([https://www.mailgun.com](https://www.mailgun.com)),
    which is able to send this kind of email, as well as communicate responses.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll need to create an account in Mailgun. Go to [https://signup.mailgun.com](https://signup.mailgun.com/new/signup)
    to create one. Notice that the credit card information is optional.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once registered, go to Domains to see there''s a sandbox environment. We can
    use it to test the functionality, although it will only send emails to registered
    test email accounts. The API credentials will be displayed there:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f287dcdc-a84e-4cd0-9df3-abae2afae51a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We need to register the account so we''ll receive the email as an *authorized
    recipient*. You can add it here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/eacf6ffc-c628-4baf-8292-c4eec436fd98.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To verify the account, check the email of the authorized recipient and confirm
    it. The email address is now ready to receive test emails:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/485590b4-1022-4f34-82ad-2859dac25be9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will use the requests module for making the connection to the Mailgun API.
    Install it in the virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything is ready to send emails, but notice only to authorized recipients.
    Being able to send emails everywhere requires us to set up a domain. Follow the
    Mailgun documentation: [https://documentation.mailgun.com/en/latest/quickstart-sending.html#verify-your-domain](https://documentation.mailgun.com/en/latest/quickstart-sending.html#verify-your-domain).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Import the `requests` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Prepare the credentials, as well as the to and from emails. Note we''re using
    a mock from:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Prepare the email to be sent. Here, there is the HTML version and an alternative
    plain-text one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Set up the data to send to Mailgun:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Make the call to the API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Retrieve the events and check the email has been delivered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The email should appear in your inbox. As it was sent through the sandbox environment,
    be sure to check your spam folder if it doesn't show up directly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Step 1 imports the `requests` module to be used later. The credentials and the
    basic information in the message are defined in step 2, and should be extracted
    from the Mailgun web interface, as shown before.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 defines the email that will be sent. Step 4 structures the information
    in the way Mailgun expects. Notice the `html` and `text` fields. By default, it
    will set HTML as preferred and the plain-text option as an alternative. The format
    for the `TO` and `FROM` should be in the `Name <address>` format. You can use
    commas to separate multiple recipients in `TO`.
  prefs: []
  type: TYPE_NORMAL
- en: The call to the API  is made in step 5\. It is a `POST` call to the messages
    endpoint. The data is transferred in the standard way, and basic authentication
    is used with the `auth` parameter. Notice the definition in step 2\. All calls
    to Mailgun should include this parameter. It returns a message notifying you that
    it was successful and the message is queued.
  prefs: []
  type: TYPE_NORMAL
- en: In step 6, a call to retrieve the events through a `GET` request is made. This
    will show the latest actions performed, the last of which will be the recent send.
    Information about delivery can also be found.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To send emails, you'll need to set up the domain with which to send it, instead
    of using the sandbox environment. You can find the instructions here: [https://documentation.mailgun.com/en/latest/quickstart-sending.html#verify-your-domain](https://documentation.mailgun.com/en/latest/quickstart-sending.html#verify-your-domain).
    This requires you to change your DNS records to verify that you are their legitimate
    owner, and increases the deliverability of emails.
  prefs: []
  type: TYPE_NORMAL
- en: 'The emails can include attachments in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The data can include the usual info such as `cc` or `bcc`, but you can also
    delay the delivery for up to three days with the `o:deliverytime` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Mailgun can also be used to receive emails and to trigger processes when they
    arrive, for example, forwarding them based on rules. Check the Mailgun documentation
    to find more.
  prefs: []
  type: TYPE_NORMAL
- en: The full Mailgun documentation can be found here, [https://documentation.mailgun.com/en/latest/quickstart.html](https://documentation.mailgun.com/en/latest/quickstart.html).
    Be sure to check their *Best Practices* section ([https://documentation.mailgun.com/en/latest/best_practices.html#email-best-practices](https://documentation.mailgun.com/en/latest/best_practices.html#email-best-practices))
    to understand the world of sending emails and how to avoid being labeled as spam.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Working with email templates* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Sending an individual email* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Producing SMS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most widely available communication channels is text messages. Text
    messages are very convenient to use to distribute information.
  prefs: []
  type: TYPE_NORMAL
- en: SMS messages can be used for marketing purposes, but also as ways of alerting
    or sending notifications, or, very common recently, as a way of implementing two-factor
    authentication systems.
  prefs: []
  type: TYPE_NORMAL
- en: We will use Twilio, a service exposing an API to send SMS in an easy way.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to create an account for Twilio at [https://www.twilio.com/](https://www.twilio.com/).
    Go to the page and register a new account.
  prefs: []
  type: TYPE_NORMAL
- en: You'll need to follow the instructions and set up a phone number to receive
    messages. You'll need to input a code sent to this phone or receive a call to
    verify this line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new project and check the dashboard. From there, you''ll be able to
    create a first phone number, able to receive and send SMS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/93858574-0d63-4bac-b762-e8e0f5435059.png)'
  prefs: []
  type: TYPE_IMG
- en: Once the number is configured, it will appear in the Active Numbers section
    in All Products and Services | Phone Numbers*.*
  prefs: []
  type: TYPE_NORMAL
- en: On the main dashboard, check `ACCOUNT SID` and `AUTH TOKEN`. They'll be used
    later. Notice you'll need to display the auth token.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also need to install the `twilio` module. Add it to your virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the receiver phone number can only be a verified number with a trial
    account. You can verify more than one number; follow the documentation at [https://support.twilio.com/hc/en-us/articles/223180048-Adding-a-Verified-Phone-Number-or-Caller-ID-with-Twilio](https://support.twilio.com/hc/en-us/articles/223180048-Adding-a-Verified-Phone-Number-or-Caller-ID-with-Twilio).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Import the `Client` from the `twilio` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Set up the authentication credentials obtained from the dashboard before. Also,
    set your Twilio phone number; as an example, here we set `+353 12 345 6789`, a
    fake Irish number. It will be local to your country:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the `client` to access the API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Send a message to your authorized phone number. Notice the underscore at the
    end of `from_`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll receive an SMS to your phone:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/89dfa2a3-a312-4789-bbbe-74a394a84b48.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The use of the Twilio client to send messages is very straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: In step 1, we import the `Client`, and prepare the credentials and the phone
    number configured in step 2.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 creates the client with the proper authentication, and the message is
    sent in step 4.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `to` number needs to be one of the authenticated numbers while
    in a trial account, or it will produce an error. You can add more authenticated
    numbers; check the Twilio documentation.
  prefs: []
  type: TYPE_NORMAL
- en: All the messages that are sent from a trial account will include that detail
    in the SMS, as you can see in step 5.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In certain regions (US and Canada at the time of writing this), SMS numbers
    have the ability to send MMS messages, including images. To attach images to the
    message, add the `media_url` parameter and the URL of the image to send:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The client is based on a RESTful API, and allows you to perform multiple operations,
    such as create a new phone number, or obtain an available number first and then
    purchase it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Check the documentation for more available actions, but most of the dashboard
    point-and-click actions can be performed programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: Twilio is also capable of performing other phone services, such as phone calls
    and text-to-speech. Check it out in the full documentation.
  prefs: []
  type: TYPE_NORMAL
- en: The full Twilio documentation is available here: [https://www.twilio.com/docs/](https://www.twilio.com/docs/).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Receiving SMS* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a Telegram bot* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receiving SMS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SMS can also be received and processed automatically. This enables services
    such as delivering information on request (for instance, send INFO GOALS to receive
    the results from the Soccer League), but also more complex flows such as in bots,
    which can have simple conversations with users that enable rich services such
    as remotely configuring a thermostat.
  prefs: []
  type: TYPE_NORMAL
- en: Each time Twilio receives an SMS to one of your registered phone numbers, it
    performs a request to a publicly available URL. This is configured in the service,
    meaning it should be under your control. This creates the problem of having a
    URL under your control available on the internet. This means that just your local
    computer won't work, as it's not addressable. We will use Heroku ([http://heroku.com](http://heroku.com))
    to deliver an available service, but there are other alternatives. The Twilio
    documentation has examples using `grok`, which allows for local development by
    creating a tunnel between a public address and your local development environment.
    See here for more details: [https://www.twilio.com/blog/2013/10/test-your-webhooks-locally-with-ngrok.html](https://www.twilio.com/blog/2013/10/test-your-webhooks-locally-with-ngrok.html).
  prefs: []
  type: TYPE_NORMAL
- en: This way of operating is common in communication APIs. It should be noted that
    Twilio has a beta API for WhatsApp, which works in a similar way. Check the docs
    for more information at [https://www.twilio.com/docs/sms/whatsapp/quickstart/python](https://www.twilio.com/docs/sms/whatsapp/quickstart/python).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to create an account for Twilio at [https://www.twilio.com/](https://www.twilio.com/). Refer
    to the *Getting ready* section in the *Producing SMS* recipe for detailed instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this recipe, we will also need to set up a web service in Heroku ([https://www.heroku.com/](https://www.heroku.com/))
    to be able to create a webhook capable of receiving SMS addressed to Twilio. Because
    the main objective of this recipe is the SMS part, we will be concise when setting
    up Heroku, but you can refer to its excellent documentation. It is quite easy
    to use:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an account in Heroku.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You''ll need to install the command line interface for Heroku (instructions
    for all platforms are at [https://devcenter.heroku.com/articles/getting-started-with-python#set-up](https://devcenter.heroku.com/articles/getting-started-with-python#set-up))
    and then log in to the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Download a basic Heroku template from[ https://github.com/datademofun/heroku-basic-flask](https://github.com/datademofun/heroku-basic-flask).
    We will use it as a base for our server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `twilio` client to the `requirements.txt` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Replace `app.py` with the one in GitHub at [https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter08/app.py](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter08/app.py).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can keep the existing `app.py` to check the template example and how Heroku
    works. Check out the README at [https://github.com/datademofun/heroku-basic-flask](https://github.com/datademofun/heroku-basic-flask).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once done, commit the changes to Git:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new service in Heroku. It will generate a new service name randomly
    (we use `service-name-12345` here). This URL is accessible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Deploy the service. In Heroku, deploying a service pushes the code to the remote
    Git server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Check that the service is up and running at the webhook URL. Note it is displayed
    as output in the previous step. You can also check it in a browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go to Twilio and access the PHONE NUMBER section. Configure the webhook URL.
    This will make the URL be called on each received SMS. Go to the Active Numbers section
    in All Products and Services | Phone Numbers and fill in the webhook. Note the
    `/sms` at the end of the webhook. Click on Save:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/278c3fc0-7ec7-4567-815a-060e27cd40f0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The service is now up and can be used. Send an SMS to your Twilio phone number
    and you should get back an automated response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/9853424c-d223-4767-88b5-55a161028b3a.png)'
  prefs: []
  type: TYPE_IMG
- en: Note the blurred parts should be replaced with your info.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a trial account, you can only send messages back to one of your
    authorized phone numbers, so you'll need to send the text from them.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Step 1 sets up the webhook, so Twilio calls your Heroku app when receiving an
    SMS on the phone line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the code in `app.py` to see how this works. Here it is
    redacted for clarity; check the full file at [https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter08/app.py](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter08/app.py):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '`app.py` can be divided into three parts—the Python imports at start of the
    file and startup of the Flask app at the end, which is just setting up Flask (not
    shown here); the call to `homepage`, which is generated to test that the server
    is working; and `sms_reply`, which is where the magic happens.'
  prefs: []
  type: TYPE_NORMAL
- en: The `sms_reply` function obtains the phone number that sends the SMS, as well
    as the body of the message, from the `request.form` dictionary. Then, compose
    a response in `msg`, attach it to a new `MessagingResponse`, and return it.
  prefs: []
  type: TYPE_NORMAL
- en: We are using the message from the user as a whole, but remember all the techniques
    to parse text mentioned in [Chapter 1](e139aa50-5631-4b75-9257-d4eb2e12ef90.xhtml),
    *Let Us Begin Our Automation Journey*. They are all applicable here to detecting
    predefined actions or any other text processing.
  prefs: []
  type: TYPE_NORMAL
- en: The returned value will be sent back by Twilio to the sender, producing the
    result seen in step 2.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to generate automated conversations, the state of the conversation
    should be stored. For advanced state, it should probably be stored in a database,
    generating a flow, but for simple cases, storing information in `session` may
    be enough. The session is able to store information in the cookies that is persistent
    between the same combination of to and from phone numbers, allowing you to retrieve
    it between messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this modification will return not only the send body, but the
    previous one as well. Only the relevant parts have been included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The previous `body` is stored in the `MESSAGE` key of the session, which is
    carried over. Notice the requirement for a secret key to use the session data.
    Read this for information about it: [http://flask.pocoo.org/docs/1.0/quickstart/?highlight=session#sessions](http://flask.pocoo.org/docs/1.0/quickstart/?highlight=session#sessions).
  prefs: []
  type: TYPE_NORMAL
- en: To deploy the new version in Heroku, commit the new `app.py` to Git, and then
    do `git push heroku master`. The new version will be deployed automatically!
  prefs: []
  type: TYPE_NORMAL
- en: Because the main objective of this recipe is to demonstrate how to reply, Heroku
    and Flask as not described in detail, but they both have excellent documentation.
    The full documentation for Heroku can be found at [https://devcenter.heroku.com/categories/reference](https://devcenter.heroku.com/categories/reference) and
    the documentation for Flask is here: [http://flask.pocoo.org/docs/](http://flask.pocoo.org/docs/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember, the use of Heroku and Flask is just a convenience for this recipe,
    as they are great and easy tools to use. There are multiple alternatives to them,
    as long as you are able to expose a URL so Twilio can call it. Also, check the
    security measures to ensure that requests to this endpoint come from Twilio: [https://www.twilio.com/docs/usage/security#validating-requests](https://www.twilio.com/docs/usage/security#validating-requests).'
  prefs: []
  type: TYPE_NORMAL
- en: The full documentation for Twilio can be found here: [https://www.twilio.com/docs/](https://www.twilio.com/docs/).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Producing SMS* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a Telegram bot* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Telegram bot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Telegram Messenger is an instant messaging app that has good support for creating
    bots. Bots are small applications that aim to produce automatic conversations.
    The big promise of bots is as machines that can create any kind of conversation,
    totally indistinguishable from a conversation with a human being, and pass the
    *Turing Test,* but that objective is quite ambitious and not realistic yet for
    the most part.
  prefs: []
  type: TYPE_NORMAL
- en: The Turing Test was proposed by Alan Turing in 1951\. Two participants, a human
    and an Artificial Intelligence (a machine or software program), communicate via
    text (like in an instant messaging app) with a human judge that decides which
    one is human and which one is not. If the judge can only guess correctly 50% of
    the time, it can't be easily differentiated and therefore the AI passes the test.
    This was one of the first attempts to measure Artificial Intelligence.
  prefs: []
  type: TYPE_NORMAL
- en: But bots can be very useful with a more limited approach, similar to phone systems
    where you need to press *2* for checking your account, and press *3* for reporting
    a missing card. We'll see in this recipe how to generate a simple bot that will
    display offers and events for a company.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to create a new bot for Telegram. This is done through an interface
    called **the BotFather**, which is a Telegram special channel that allows us to
    create a new bot. You can access the channel here: [https://telegram.me/botfather](https://telegram.me/botfather).
    Access it through your Telegram account.
  prefs: []
  type: TYPE_NORMAL
- en: Run `/start` to start the interface and then create a new bot with `/newbot`.
    The interface will ask you the name of the bot and a username, which should be
    unique.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once it''s set up, it will give you the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The Telegram channel of your bot—`https:/t.me/<yourusername>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A token to allow access the bot. Copy it as it will be used later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can generate a new token if you lose it. Read The BotFather's documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to install the Python module `telepot`, which wraps the RESTful
    interface from Telegram:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Download the `telegram_bot.py` script from GitHub at [https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter08/telegram_bot.py](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter08/telegram_bot.py).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Setup your generated token into the `telegram_bot.py` script on the `TOKEN`
    constant in line 6:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the bot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the Telegram channel in your phone using the URL and start it. You can
    use the `help`, `offers`, and `events` commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/e8a122ba-dadf-4e78-9c32-d29e8d56449c.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Step 1 sets the token to use for your specific channel. In step 2, we start
    the bot locally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how the code in `telegram_bot.py` is structured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MarketingBot` class creates an interface to handle the communication with
    Telegram:'
  prefs: []
  type: TYPE_NORMAL
- en: When the channel is started, the `open` method will be called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a message is received, the `on_chat_message` method will be called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there's no answer in a while, `on_idle` will be called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In each case, the `self.sender.sendMessage` method is used to send a message
    back to the user. Most of the interesting bits happen in `on_chat_message`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: First, it checks whether the received message is text and returns an error message
    if it's not. It analyzes the received text, and if it's one of the defined commands,
    it executes the corresponding function to retrieve the text to return.
  prefs: []
  type: TYPE_NORMAL
- en: Then, it sends the message back to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 shows how this works from the point of view of the user who is interacting
    with the bot.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can add more info, an avatar picture, and so on to your Telegram channel
    using the `BotFather` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'To simplify our interface, we can create a custom keyboard to simplify the
    bot. Create it after defining the commands, around line 44 of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice it is creating a keyboard with three rows, each with one of the commands.
    Then, add the resulting `KEYBOARD` as the `reply_markup` on each of the `sendMessage`
    calls, for example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'This replaces the keyboard with only the defined buttons, making the interface very
    obvious:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c7d4fc8c-6861-4cb5-b4e2-72ac8dd1108c.png)'
  prefs: []
  type: TYPE_IMG
- en: These changes can be downloaded in the `telegram_bot_custom_keyboard.py` file,
    available in GitHub here: [https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter08/telegram_bot_custom_keyboard.py](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter08/telegram_bot_custom_keyboard.py).
  prefs: []
  type: TYPE_NORMAL
- en: You can create other kinds of custom interfaces, such as inline buttons or even
    a platform for creating games. Check the Telegram API docs for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with Telegram can also be done through webhooks, in a similar way
    as presented in the Receiving SMS recipe. Check the example for Flask in the `telepot`
    documentation here: [https://github.com/nickoala/telepot/tree/master/examples/webhook](https://github.com/nickoala/telepot/tree/master/examples/webhook).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Telegram webhook can be done through `telepot`. It requires that
    your service is behind an HTTPS address to ensure the communication is private.
    This can be tricky to do with simple services. You can check the documentation
    on setting up a webhook in the Telegram docs: [https://core.telegram.org/bots/api#setwebhook](https://core.telegram.org/bots/api#setwebhook).
  prefs: []
  type: TYPE_NORMAL
- en: The full Telegram API for bots can be found here: [https://core.telegram.org/bots](https://core.telegram.org/bots).
  prefs: []
  type: TYPE_NORMAL
- en: The documentation for the `telepot` module is found here: [https://telepot.readthedocs.io/en/latest/](https://telepot.readthedocs.io/en/latest/).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Producing SMS* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Receiving SMS* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
