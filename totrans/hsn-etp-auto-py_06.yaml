- en: Configuration Generator with Python and Jinja2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduces you to the YAML format for representing data and generating
    a configuration from the golden templates created by the Jinja2 language. We will
    use these two concepts in both Ansible and Python to create a data model store
    for our configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is YAML?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building golden configuration templates with Jinja2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is YAML?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**YAML Ain’t Markup Language** (**YAML**) is often called a data serialization
    language. It was intended to be human-readable and organize data into a structured
    format. Programming languages can understand the content of YAML files (which
    usually have a `.yml` or `.yaml` extension) and map them to built-in data types.
    For example, when you consume a `.yaml` file in your Python script, it will automatically
    convert the content into either a dictionary `{}` or list `[]`, so you can work
    and iterate over it.'
  prefs: []
  type: TYPE_NORMAL
- en: YAML rules help to construct a readable file so it's important to understand
    them in order to write a valid and well formatted YAML file.
  prefs: []
  type: TYPE_NORMAL
- en: YAML file formatting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There''re a few rules to follow while developing YAML files. YAML uses indentation
    (like Python), which builds the relationship of items with one another:'
  prefs: []
  type: TYPE_NORMAL
- en: So, the first rule when writing a YAML file is to make your indentation consistent,
    using either whitespace or tabs, and don't mix them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second rule is to use a colon `:` when creating a dictionary with a key
    and value (sometimes they're called associative arrays in `yaml`). The item to
    the left of the colon is the key, while the item to the right of the colon is
    the value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The third rule is to use dashes `"-" ` when grouping items inside a list. You
    can mix dictionaries and lists inside the YAML file in order to effectively describe
    your data. The left-hand side serves as a dictionary key, while the right-hand
    side serves as a dictionary value. You can create any number of levels to have
    structured data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00112.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take an example and apply these rules to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00113.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There are a number of things to look at it. Firstly, the file has one top level,
    `my_datacenter`, which serves as a top-level key and its values consists of all
    the indented lines after it, which are `GW`, `switch1`, and `switch2`. Those items
    also serve as keys and have values inside them, which are `eve_port`, `device_template`, `hostname`, `mgmt_int`, `mgmt_ip`,
    and `mgmt_subnet` and which serve as Level 3 keys and Level 2 values at the same
    time.
  prefs: []
  type: TYPE_NORMAL
- en: The other thing to notice is `enabled_ports`, which is a key but has a value
    that serves as a lists. We know this because the next level of indentation is
    a dash.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that all interfaces are sibling elements because they have the same level
    of indentation.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it's not required to have a single or double quotation around strings.
    Python will do that automatically when we load the file into it and it will also
    determine the data type and location of each item based on indentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s develop a Python script that reads this YAML file and converts
    it into dictionaries and lists using the `yaml` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00114.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this example, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We imported the `yaml` module inside our Python script in order to handle the
    YAML files. Also, we imported the `pprint` function to show the hierarchy of nested
    dictionaries and lists.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we opened the `yaml_example.yml` file using the `with` clause and the `open()`
    function as a `yaml_file`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we use the `load()` function to load the file into the `yaml_data`
    variable. At this stage, the Python interpreter will analyze the `yaml` file's
    content and build the relationships between items, then convert them to the standard
    data type. The output can be shown at the console using the `pprint()` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Script output**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00115.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'It''s now fairly easy to access any information using standard Python methods.
    For example, you can access the `switch1` config by using `my_datacenter` followed
    by the `switch1` keys, as in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, you can iterate over the keys with a simple `for` loop and print the
    values of any level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As a best practice, it's recommended you keep the key names consistent and change
    only the values while you describe your data. For example, the `hostname`, `mgmt_intf`,
    and `mgmt_ip` items exist on all devices with the same name, while they have different
    values in the `.yaml` file.
  prefs: []
  type: TYPE_NORMAL
- en: Text editor tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Correct indentation is very important for YAML data. It's recommended to use
    an advanced text editor such as, Sublime Text or Notepad++, as they have options
    that convert the tabs to a specific number of whitespaces. At the same time, you
    can choose the specific tab indentation size to be 2 or 4\. So, your editor will
    convert the tab to a static number of whitespaces whenever you click on the *Tab*
    button. Finally, you can choose to display vertical lines at each indentation
    to ensure that lines are indented the same amount.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that Microsoft Windows Notepad doesn't have that option and this
    may result in a formatting error in your YAML file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of an advanced editor called Sublime Text that
    can be configured with the aforementioned options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00116.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The screenshot shows the vertical line guides that ensure that the sibling items
    are at the same indentation level and number of spaces when you click on Tab.
  prefs: []
  type: TYPE_NORMAL
- en: Building a golden configuration with Jinja2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most network engineers have a text file that serves as a template for a specific
    device configuration. This file contains sections of network configuration with
    many values. When the network engineer wants to provision a new device or change
    its configuration, they will basically replace specific values from this file
    with another one to generate a new configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Using Python and Ansible, later in this book we will automate this process efficiently
    using the Jinja2 template language ([http://jinja.pocoo.org](http://jinja.pocoo.org)).
    The core concept of and driver for developing Jinja2 is to have a unified syntax
    across all template files for specific network/system configurations and to separate
    the data from the actual configuration. This allows us to use the same template
    multiple times but with a different set of data. Also, as shown on the Jinja2
    web page, it has some unique features that make it stand out from the other template
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some of the features mentioned on the official website:'
  prefs: []
  type: TYPE_NORMAL
- en: Powerful automatic HTML escaping system for cross-site scripting prevention.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High performance with just-in-time compilation to Python bytecode. Jinja2 will
    translate your template sources on first load into Python bytecode for the best
    runtime performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional ahead-of-time compilation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy to debug with a debug system that integrates template compile and runtime
    errors into the standard Python traceback system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Configurable syntax: For instance, you can reconfigure Jinja2 to better fit
    output formats, such as LaTeX or JavaScript.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Template designer helpers: Jinja2 ships with a wide range of useful little
    helpers that help solve common tasks in templates, such as breaking up sequences
    of items into multiple columns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another important Jinja feature is *template inheritance*, with which we can
    create a *base/parent template* that defines a basic structure for our system
    or the Day 0 initial configuration for all devices. This initial configuration
    will be the base configuration and contains the common pieces such as usernames,
    management subnet, default routes, and SNMP communities.  The other *child templates *extend
    the base template and inherit it.
  prefs: []
  type: TYPE_NORMAL
- en: The terms Jinja and Jinja2 are used interchangeably throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a few examples of building templates before we deep dive into more
    features provided by the Jinja2 language:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to make sure that Jinja2 is installed in your system by using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The package will be downloaded from PyPi and then will be installed on the site
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open your favorite text editor and write the following template, which
    represents a simple Day 0 (initial) configuration for a Layer 2 switch that configures
    the device hostname, some `aaa` parameters, default VLANs that should exist on
    each switch, and the management of IP addresses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Some text editors (such as Sublime Text and Notepad++) provide support for Jinja2
    and can do syntax highlighting and auto-completion for you, either by natively
    supporting it or through extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that in the previous template, the variables were written in double
    curly braces `{{  }}`. So, when the Python script loads the template, it will
    replace those variables with the desired values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing is we imported the `Template` class from the `jinja2` module.
    This class will validate and parse the Jinja2 file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we defined a variable, `sw1`, as a dictionary with keys that have names
    equal to variables inside the template. The dictionary values will be the data
    that renders the template.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we used the `render()` method inside the template which takes `sw1`
    as an input to connect the Jinja2 template with the rendered values and prints
    the configuration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Script output**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00117.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s enhance our script and use YAML to render the template instead
    of hard-coding the values inside dictionaries. The concept is simple: we will
    model the `day0` configuration for our lab inside the YAML file, then load this
    file into our Python script using `yaml.load()` and use the output to feed the
    Jinja2 template, which will result in generating the `day0` configuration files
    for each device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00118.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'First, we will extend the YAML file that we developed last time and add other
    devices to it while keeping the hierarchy for each node the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Following is the Python script:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We imported the `yaml` and `Jinja2` modules as usual
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we instructed the script to load the `yaml` file into the `yaml_data`
    variable, which will convert it into a series of dictionaries and lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two templates for router and switch configuration are defined as `router_day0_template`
    and `switch_day0_template` respectively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `for` loop will iterate over devices of `dc1` and check the `device_template`,
    then will render configuration for each device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Script output**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the router configuration (output omitted):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00119.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Following is the switch 1 configuration (output omitted):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00120.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Reading templates from the filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common approach for Python developers is to move the static, hard-coded values
    and templates outside the Python script and keep only the logic inside the script.
    This approach keeps your program clean and scalable, while allowing other team
    members who don't have much knowledge of Python to get the desired output by changing
    the input, and Jinja2 is no exception to this approach. You can use the `FileSystemLoader()`
    class inside the Jinja2 module to load the template from the operating system
    directories. We will modify our code and move both the `router_day0_template`
    and `switch_day0_template` contents from the script to text files, then load them
    into our script.
  prefs: []
  type: TYPE_NORMAL
- en: '**Python code**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example, instead of loading the `Template()` class from the Jinja2 module
    as we did before, we will import  `Environment()` and `FileSystemLoader()`, which
    are used to read the Jinja2 file from the specific operating system directory
    by providing them with `template_dir` where our templates are stored. Then, we
    will use the created `template_env` object, along with the `get_template()` method,
    to get the template name and render it with the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure your template file has a `.j2` extension at the end. This will make
    PyCharm recognize the text inside the file as a Jinja2 template and hence provide
    syntax highlighting and better code completion.
  prefs: []
  type: TYPE_NORMAL
- en: Using Jinja2 loops and conditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Loops and conditions in Jinja2 are used to enhance our template and add more
    functionality to it. We will start by understanding how to add the `for` loop
    inside the template in order to iterate over passed values from YAML. For example,
    we may need to add a switch configuration under each interface, such as using
    the switchport mode  and configure the VLAN ID which will be configured under
    the access port, or configure the allowed VLANs range in the case of the trunk
    ports.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, we may need to enable some interfaces in the router and add
    custom configurations to it, such as MTU, speed, and duplex. So, we will use the
    `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that part of our script logic will now be moved from Python to the Jinja2
    template. The Python script will just read the template, either externally from
    the operating system or through the `Template()` class inside the script, then
    render the template with the parsed values from the YAML file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic structure of `for` loops inside Jinja2 is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice the use of `{% %}` to define logic inside the Jinja2 file.
  prefs: []
  type: TYPE_NORMAL
- en: Also, `iteritems()` has the same function as iterating over the Python dictionary,
    which is iterating over the key and value pairs. The loop will return both the
    key and value for each element inside the `var1` dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we can have an `if` condition that validates a specific condition and,
    if it''s true, then the configuration snippets will be added to the rendered file.
    The basic `if` structure will be as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will modify our `.yaml` file which describes the data center devices,
    and add the interface configuration and enabled ports for each device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Notice, that we categorized the switch ports to either trunk port or access
    port, and also added the vlans for each one.
  prefs: []
  type: TYPE_NORMAL
- en: According to the `yaml` file, the incoming packets to the interface with switchport
    access mode will be tagged with the VLAN. In case of the switchport mode trunk,
    the incoming packets be allowed if it has a vlan ID belong to the configured list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will create two additional templates for devices Day 1 (operational)
    configuration. The first template will be `router_day1_template` and the second
    will be `switch_day1_template`, and both of them will inherit from the corresponding
    day0 template that we developed before:'
  prefs: []
  type: TYPE_NORMAL
- en: '**router_day1_template:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**switch_day1_template:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Notice the use of the `{% include <template_name.j2> %}`  tag, which refers
    to the day0 template of the device.
  prefs: []
  type: TYPE_NORMAL
- en: This template will be rendered first and filled with passed values from YAML,
    then the next parts will be filled.
  prefs: []
  type: TYPE_NORMAL
- en: The Jinja2 language inherits many writing styles and features from the Python
    language. Although it's not mandatory to follow the indentation rule when developing
    the template and inserting the tags, the author prefers to have it in a readable
    Jinja2 template.
  prefs: []
  type: TYPE_NORMAL
- en: '**Script output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about YAML and its formatting and how to work with
    text editors. We also learned about Jinja2 and its configuration. Then, we explored
    the ways in which we can use loops and conditions in Jinja2.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to instantiate and execute Python code
    in parallel using multiprocessing.
  prefs: []
  type: TYPE_NORMAL
