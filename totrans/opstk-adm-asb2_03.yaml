- en: Chapter 3. Creating Multiple Users/Projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have finally arrived to the part of the book where we put hands to the keyboard
    and create our very first OpenStack administration playbook. The task of creating
    users and projects for your OpenStack cloud is literally one of the first steps
    in setting up your cloud for user consumption. So, it is good to start here. We
    will step through how one would manually do this first and then transition into
    creating a playbook with roles to fully automate it. While creating the playbook/role,
    I will try to highlight any possible concerns and flexible ways you can accomplish
    it using Ansible. The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating users and projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automation considerations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding the playbook and roles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playbook and role review
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating users and projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although creating new users and projects seems like a trivial task as a cloud
    operator/administrator, it does become a burden if asked to create 10, 20, or
    50 users and 5, 10, or 20 projects. The process of first creating the user (with
    a corresponding complex secure password), next creating the project for the user,
    and finally linking that user to that project while assigning that user with the
    appropriate role.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine doing that over and over again. Boring! The first thing you learn as
    an administrator of anything is: figure out what your daily tasks are and then
    determine how to get them completed as fast/easily as possible. This is exactly
    what we are going to do here.'
  prefs: []
  type: TYPE_NORMAL
- en: Manually creating users and projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To further demonstrate the steps outlined earlier, we will walk through the
    commands used to create a user and a project.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For simplicity purposes, we will demonstrate the manual commands using the OpenStack
    CLI only.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a user
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Creating a user within OpenStack involves sending requests to the Identity
    service (Keystone). The Keystone request can be executed by either first sourcing
    the OpenRC file discussed in [Chapter 1](ch01.html "Chapter 1. Introduction to
    OpenStack"), *Introduction to OpenStack* or by passing the `--os-cloud` authentication
    parameter in line with the command (this is shown in the second example later).
    Next, you would be responsible for providing the required parameter values such
    as the user name and password with the command. See the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we can also use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a user](graphics/image_03_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As touched on previously, a project (formerly known as a tenant) is a segregated
    area of your cloud where you can assign users. That user can be restricted to
    just that project or allowed access to multiple projects. The process of creating
    a project is similar to the user creation process mentioned earlier. You can continue
    to execute CLI commands once you source the OpenRC file or pass an authentication
    parameter with each command. Imagine that the OpenRC file was already sourced,
    see the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a project](graphics/image_03_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Assigning a role and project access to users
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Still using the Keystone service, you would assign a specific role (user permissions)
    to a designated project for the user just created. There are default roles that
    come with a base OpenStack cloud: `admin` and `_member_`. You can also create
    custom roles as well. You would need the name of the role and project you wish
    to assign to the user. If the OpenRC file was still sourced, see the following
    example. For this command no output is printed to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you would have created a user and a project and have assigned
    that user to the project with a role, which is all done manually. Let's move forward
    into reviewing some of the considerations around the thought of automating all
    the steps mentioned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Automation considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea of taking a manual task and creating an automation script, no matter
    the automation tool, requires some base framework decisions to be made. This is
    to keep consistency within your code and allow the easy adoption of your code
    by someone else. Have you ever tried using scripts created by someone else and
    they had no code standards? It is confusing, and you waste time attempting to
    understand their approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we are going to make some framework decisions ahead of time and
    keep that consistency. My biggest disclaimer before we get started reviewing the
    considerations in order to set our framework decisions is:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many ways to approach automating tasks for OpenStack with Ansible;
    the one shown in this book is just one way I personally have found success with
    and most certainly not the only way. The playbooks/roles are intended to be working
    examples that you can use as or adjust/improve for your personal use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Now that this has been said, let's get on with it.
  prefs: []
  type: TYPE_NORMAL
- en: Defining variables globally or per role
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This topic may not seem important enough to review, but in reality with Ansible
    you have more options than usual. With that thought, you will have to decide on
    how you will define your variables within the roles.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible has a variable definition hierarchy it follows. You have the option
    to define the value of a variable placed within your playbook/role globally, assigning
    it to a group of hosts or local to that specific role only. Defining the value
    globally would mean that all playbooks/roles could use that value and apply it
    to a group of hosts. Verses if you set the value locally to that role, the role
    will pick up the variables from here first.
  prefs: []
  type: TYPE_NORMAL
- en: Globally defined variables value would be defined within a file located in the
    `group_vars/` directory of the playbook. The filename would have to match a group
    name set in the `hosts` file. To recap this process, please refer to the Defining
    variable values section in [Chapter 2](ch02.html "Chapter 2. Introduction to Ansible"),
    *Introduction to Ansible*. The advantage of this approach is you can set the variable
    value once and have your playbooks/roles just reuse the value. It simplifies defining
    variables overall and the task of updating the values as needed. The negative
    aspect to this approach is if you wish to reuse a variable name and want to provide
    a different value on a per role basis. This is where the alternative option comes
    into play.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the variable value local to the role allows the reuse of a variable
    name and the capability to define different values for that variable. Through
    my experimentation of creating playbooks/roles against an OpenStack cloud, I have
    found defining the variables locally to the role seems to be the best option.
    My overall approach to creating roles is to create roles to be as simple as possible
    and to accomplish a single administrative task. Try not to combine multiple administrative
    tasks into a single role. Keeping the role simple enables the ability to reuse
    the role and keeps in line with Ansible's best practices.
  prefs: []
  type: TYPE_NORMAL
- en: So, the first framework decision we are making here is to define variable values
    locally to the role. Now we can move on to the next consideration/decision point,
    which is whether to use the OpenStack API or CLI to execute administrative commands.
  prefs: []
  type: TYPE_NORMAL
- en: OpenStack API or CLI?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Again, this decision may seem unimportant at a high level. Deciding to use the
    OpenStack API or CLI could drastically change the overall structure and approach
    to creating your playbooks/roles. In [Chapter 1](ch01.html "Chapter 1. Introduction
    to OpenStack"), *Introduction to OpenStack*, we covered the differences between
    the OpenStack API and CLI.
  prefs: []
  type: TYPE_NORMAL
- en: One thing that should have stood out is that the CLI is much easier to use and
    code against with Ansible. Keep in mind that the CLI still executes API commands
    behind the scenes dealing with all the token and JSON interpretation stuff for
    you. This allows zero loss in functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The second framework decision we are declaring is to use the native OpenStack
    modules that come with Ansible when making calls to your OpenStack cloud. The
    only deviation from this decision would be to use CLI commands if there is not
    a module available to handle a task we need coded. With this decision, we have
    also chosen to use the `clouds.yaml` file mentioned in [Chapter 2](ch02.html "Chapter 2. Introduction
    to Ansible"), *Introduction to Ansible* to store our credentials.
  prefs: []
  type: TYPE_NORMAL
- en: One last consideration now is to decide from where do we wish to execute the
    playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: Where to run Ansible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'My next statement may be a bit obvious, but the playbooks need to be executed
    from a workstation/server with Ansible installed. Now that we have this out of
    the way, let''s explore our options:'
  prefs: []
  type: TYPE_NORMAL
- en: My first recommendation is not to run the playbooks directly from any of the
    OpenStack controller nodes. The controller nodes have plenty of work to do just
    to keep OpenStack going, no need to add additional burden.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other option is to execute the playbooks from some sort of centralized Ansible
    server in your environment. Although this is a totally viable option, I have a
    better one for you.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since I am a huge fan and advocate for the **openstack-ansible** (**OSA**) method
    of deploying OpenStack, the playbooks/roles out of the box will use some of the
    great features offered with OSA. My last sentence may seem a bit off topic, but
    it will make more sense shortly.
  prefs: []
  type: TYPE_NORMAL
- en: One of the greatest features that come with running OSA is the built-in dynamic
    inventory script. This feature removes your burden of keeping inventory of your
    OpenStack service locations in a `hosts` file. In order to benefit from this feature,
    you would need to execute the playbooks/roles from the OSA deployment server.
    This in the big picture makes sense to keep all the Ansible playbooks/roles together
    (deployment and administration scripts).
  prefs: []
  type: TYPE_NORMAL
- en: The other compelling reason why this is the best option is that the OSA deployment
    server is already set up to communicate with the LXC containers where the OpenStack
    services are located. This point becomes very important when/if you want to make
    OpenStack service configuration changes with Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: The last feature of OSA that I would like to highlight is the fact that it comes
    with a container designated just to administer your OpenStack cloud called the
    **utility** container. That container comes with every OpenStack service CLI package
    installed and ready to go. Yes, this is one less thing for you to worry about.
    This is one of the main reasons why I love me some OSA.
  prefs: []
  type: TYPE_NORMAL
- en: We now have our last framework decision, which is to execute the playbooks from
    the OSA deployment server in order to take full advantage of all the features
    OSA has to offer us (it just feels right). Now that we are all armed with a ton
    of good information and coding framework, all we have left is to create our first
    playbook and roles.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the playbooks and roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start, we should first reflect back to the beginning of this chapter.
    We outlined the steps to create users and projects within your OpenStack cloud.
    Here, they are again for a quick reference:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the user (with a corresponding complex secure password)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the project for the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linking that user to that project while assigning that user with the appropriate
    role
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first step to tackle is the user creation portion of the process. Creating
    the user is a simple task within OpenStack, so why not add some administration
    flare to go along with it. A part of the process of creating a user is assigning
    that user an appropriate password. We will include that as part of the role that
    creates the user and the project we will assign the user to.
  prefs: []
  type: TYPE_NORMAL
- en: When creating a playbook, I normally start with creating roles to handle the
    administrative tasks needed. The role will contain all the executable code against
    the OpenStack cloud. The playbook will contain the host to run the role against
    (in this case, it will be the utility container), the role(s) to execute, and
    other execution settings. The role to handle this administrative task will be
    named `create-users-env`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The directory structure for our playbook will start off looking something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we will start with the role task file assembly, let''s create the `main.yml`
    file within the `create-users-env/tasks` directory. The initail contents of this
    file will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can walk through in more detail the three preceding tasks that were
    just added to the role. The very first following task sets the groundwork to use
    the `apg` package, which generates several random passwords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Since in the second task we will use the `apg` package to generate passwords
    for us, we had to make sure that it was installed on the host executing the playbook/role.
    The `apt` module from Ansible is a very useful tool to manage Debian/Ubuntu packages.
    Defining the `{{item}}` parameter value with the module allows us to loop through
    multiple packages listed later inside the `with_items` statement. In this particular
    case, it is not needed since we are only installing one package, but at the same
    time does us no harm. Moving on to the second task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The second task now will execute the `apg` package using the command module
    from Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The command module will be one of the mostly used modules when working with
    Ansible. It basically can handle executing any command/package with the exception
    of any commands that will use shell variables and shell-specific operations, such
    as: `<`, `>`, `|`, and `&`.'
  prefs: []
  type: TYPE_NORMAL
- en: With the command module, we are passing the `apg` command with specific parameters
    `-n {{ pass_cnt }} -M NCL -q`. Most of the parameters are standard options for
    `apg` with the exception of the variable defined `{{ pass_cnt }}`. Setting this
    parameter allows us to adjust the number of passwords generated from the variable
    file set for this role (found in the `create-users-env/vars` directory). We will
    examine the variable file shortly. One of the last steps in this task is to register
    the output of the `apg` command into a variable named `passwdss`. This variable
    will be used later in this role.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third task added to the role will now create the user within your OpenStack
    cloud. As seen here again, using the `os_user` module, we will execute the Keystone
    command to create a user with authentication parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the task, we will also define a few variables to be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Placing variables within your commands sets you up to create roles with core
    code that you will not have to update every time it is used. It is a much simpler
    process to just update variable files instead of continuously altering role tasks.
  prefs: []
  type: TYPE_NORMAL
- en: The other special item part of this task is the use of the `with_together` Ansible
    loop command. This command allows us to loop through separate sets of variable
    values pairing them together in the defined order. Since the passwords are random,
    we do not care what user gets which password.
  prefs: []
  type: TYPE_NORMAL
- en: 'So now that we have our user creation code in the role, the next step is to
    create the user''s project. The next two tasks are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This first task will create the project with the `os-project` module. Project
    name and description will come from the `tenantid` variable. The next preceding
    task will then assign the user we created earlier to this newly created project
    with a role value set by the `urole` variable.
  prefs: []
  type: TYPE_NORMAL
- en: You will note that these tasks are very similar to the previous task used to
    create the user and also use similar Ansible parameters. As you can see, it will
    begin to form a repeated pattern. This really helps simply the code creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last task part of the role will simply provide an output of the users created
    and their corresponding passwords. This step will give you (as the cloud operator)
    a very simple output with all the information you would need to save and/or pass
    on to the cloud consumer. Although this step is not required to complete the overall
    administrative task, it is nice. See the following task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In this task, we will use the `debug` module to show the output of the variable
    we set either manually or dynamically using the `register` Ansible command. The
    output will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Coding the playbooks and roles](graphics/image_03_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Believe it or not, you have just created your very first OpenStack administration
    role. To support this role, we now need to create the variable file that will
    go along with it. The variable filename, `main.yml`, located in the `create-users-env/vars`
    directory, is very similar in structure to the task file.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep in mind that the values defined in the variable file are intended to be
    changed before each execution for normal every day use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The values shown in the following example are just working examples. Let''s
    take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a moment to break down each variable. The summary would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This pretty much concludes what is involved in creating a variable file. We
    can now move on to the base of this playbook and create the master playbook file
    named `base.yml`, located in the `root` directory of the playbook directory. The
    contents of the `base.yml` file would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The summary of this file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The last two areas of attention left before completing the playbook and making
    it ready for execution are creating the hosts inventory file and the global variable
    file. In this case, we are using a static host inventory file to keep things simple,
    but in future chapters, we will instead use the OSA dynamic inventory file. Because
    we are using the static inventory file, we will have to discover the name and/or
    IP address of the utility container.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be accomplished by running the following command on any of the controller
    nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, look for something similar to the highlighted item in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Coding the playbooks and roles](graphics/image_03_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, add the utility container IP address to the hosts file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Last but not least, you then would create the global variable file inside the
    `group_vars/` directory. Remember that the file must be named to match the host
    or host group defined in the master playbook. Since we called the host group `util_container`,
    we must then name the variable file the exact same name. The contents of the `util_container`
    global variable file would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**ProTip**'
  prefs: []
  type: TYPE_NORMAL
- en: Always create/use an automation service account when executing commands against
    a system remotely. Never use the built-in admin and/or your personal account for
    that system. The use of service accounts makes for simple troubleshooting and
    system audits.
  prefs: []
  type: TYPE_NORMAL
- en: Guess what...you made it! We have just completely finished our very first OpenStack
    administration playbook and role. Let's finish up this chapter with a quick review
    of the playbook and role just created.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing playbooks and roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get right to it, we can start from the top with the role we created named
    `create-users-env`. The completed role and file named `main.yml` located in the
    `create-users-env/tasks` directory looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The corresponding variable file named `main.yml`, located in the `create-users-env/vars`
    directory, for this role will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the master playbook file named `base.yml`, located in the `root` directory
    of the playbook directory, will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Following that we created the `hosts` file, which also is located in the `root`
    directory of the `playbook` directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we wrapped this playbook all up by creating the global variable file
    named `util_container`, saving it to the `group_vars/` directory of the `playbook`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As promised earlier, I felt that it was very important to provide the fully
    working Ansible playbooks and roles for your consumption. You can use them as
    is and/or as a springboard to creating new/improved Ansible code. The code can
    be found in the GitHub repository, [https://github.com/os-admin-with-ansible/os-admin-with-ansible-v2](https://github.com/os-admin-with-ansible/os-admin-with-ansible-v2).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now of course, we have to test out our work. Assuming that you have cloned
    the GitHub repository mentioned earlier, the command to test out the playbook
    from the Deployment node would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: See now that was not so bad, right? Ansible really does a great job in streamlining
    the effort involved in automating OpenStack administrative tasks. You can now
    reuse that role over and over again, cutting the amount of time creating users
    and projects down to single digit minutes. The time investment is well worth the
    benefits.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we created users and projects within OpenStack via the API
    and CLI. We gathered an understanding of basic automation considerations. We also
    developed Ansible playbooks and roles to automate the user and project creation.
  prefs: []
  type: TYPE_NORMAL
- en: With this great foundation, we are ready to move on to our next administrative
    task of customizing your clouds quotas. The next chapter will include a general
    understanding of what quotas are and how they are used within your OpenStack cloud.
    We will then transition to the exercise of creating quotas manually and then concluding
    with how to automate that task with Ansible. See you in [Chapter 4](ch04.html
    "Chapter 4. Customizing Your Clouds Quotas"), *Customizing Your Clouds Quotas*!
  prefs: []
  type: TYPE_NORMAL
