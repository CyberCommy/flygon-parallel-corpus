- en: Querying a Modern SQL Database Efficiently
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now learn how to query an SQL database efficiently using Modern SQL.
    In this chapter, we will define what Modern SQL is and how to use it. We will
    start by defining the concept of Modern SQL and understanding what makes it different
    from traditional SQL by describing many of its features. Thus, we will acquire
    knowledge of how to convert certain traditional SQL queries into modern ones and
    when it is best to do so. Moreover, by doing so, we will better understand how
    Modern SQL can help us optimize a server's performance in more than one way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we will cover the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what Modern SQL is and its features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how and when to use `WITH` and `WITH RECURSIVE`, `CASE`, `OVER AND
    PARTITION BY`, `OVER AND ORDER BY`, GROUPING SETS, JSON clauses and functions,
    `FILTER` and `LATERAL` queries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modern SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is Modern SQL and how does it distinguish itself from traditional SQL?
    What are its main features? Let's start by defining the concept itself.
  prefs: []
  type: TYPE_NORMAL
- en: Definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As Markus Winand states on his website [https://modern-sql.com](https://modern-sql.com),
    Modern SQL can be defined as "*an internationally standardized, widely available
    and Turing complete data processing language supporting relational and non-relational
    data models*." This definition refers to a set of standards that were promoted
    by the ISO and ANSI organizations over the years and that added new features to
    the SQL programming language. Since SQL-92, many new versions of the SQL standard
    were adopted and these standards introduced many new features based on relational
    and non-relational models. Here is a short list of these features with the corresponding
    standard that confirmed their adoption into the SQL language:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WITH` and `WITH RECURSIVE` (SQL:1999)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CASE` (SQL:1999 and SQL:2003)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OVER AND PARTITION BY` (SQL:2003 and SQL:2011)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OVER AND ORDER BY` (SQL:2003 and SQL:2011)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GROUPING SETS (SQL:2011)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON clauses and functions (SQL:2016)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FILTER` (SQL:2003)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LATERAL` queries (SQL:1999)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This being said, it should be noted that most of these features were not implemented
    by most **relational database management systems** (**RDBMSs**) until fairly recently.
    Most RDBMSs were only offering to their users, a more traditional SQL language
    based solely on the relational model promoted by the aging SQL-92 standard. It
    has only been in the most recent years that many, if not most, of RDBMSs have
    started implementing Modern SQL features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, let''s give this word of warning: using these features will not immediately
    yield great performance hikes for your database server. So, what is the point
    of using these features in your code base? The point is to make your code base
    compatible with future database engine optimizations and to avoid most problems
    related to slow query execution.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But, before looking further into the new SQL features, we will install `phpMyAdmin`
    inside our Linux for PHP container in order to see the results of our queries
    in a user-friendly fashion. To do so, please enter the following commands on the
    container''s CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'These commands should make it possible to access the database server from a
    web interface at `http://localhost:8181/phpmyadmin`. When visiting this address
    via your favorite browser, you should see the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a0aac6ea-6f8d-4787-a740-eb10c29e4428.png)Enter your username and
    password on phpMyAdmin''s login page'
  prefs: []
  type: TYPE_NORMAL
- en: Once `phpMyAdmin` is installed, you can log in to the database server with the
    Username `root`Â and an empty Password.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's have a look at each one of these new SQL features in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: WITH and WITH RECURSIVE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first feature is what is known as a **Common Table Expression** (**CTE**).
    A CTE is a temporary result set which allows you to join the same data to itself
    multiple times. There are two types of CTEs: non-recursive (`WITH`) and recursive
    (`WITH RECURSIVE`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The non-recursive kind of CTE works like a derived table, allowing you to `SELECT`
    from a temporary result set. A simple example, using a fictitious staff table,
    would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The recursive kind of CTE is composed of two parts. The first part of the query
    is what is called the anchor member of the CTE. The anchor's result set is what
    is considered to be the base result set (T[0]). The second part is the recursive
    member which will run with T[i] as input and T[i+1] as output until an empty result
    set is returned. The query's final result set will be a `UNION ALL` between the
    recursive result set (T[n]) and the anchor (T[0]).
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to better understand recursive CTEs and how useful they can be, let''s
    give an example. But, before we begin, let''s start by loading the following table
    into the test database. On the container''s CLI, enter this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once done, you can make sure that everything was loaded correctly by opening
    the database with `phpMyAdmin`, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5f8e9316-5aeb-4914-9e5d-428303e40b4c.png)All the rows found in the
    employees table of the test database'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to better understand CTEs, we will begin by using a basic query with
    multiple joins to obtain a hierarchical result set. To obtain the entire hierarchy
    of employees based solely on the presence of the manager''s ID in the employee''s
    record in the database, we would have to think of a query with multiple joins
    to the same table. In the SQL tab, enter this query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You will obtain this result set:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c5516de5-df0b-41d3-8bff-c9321342231e.png)Hierarchical tree of all
    the employees generated with the JOIN statements'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to notice is that this query presumes that we know in advance
    the number of levels in this hierarchy, which implies that we did a previous query
    to confirm this fact about our dataset. The second thing is the clumsiness of
    having to repeat the `JOIN` clauses in order to retrieve the entire result set.
    A recursive CTE is the perfect way to optimize such queries. To obtain the exact
    same result set with a recursive CTE, we would have to run the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If we were to compare the two previous queries by running them against MariaDB's
    performance schema, even though they do not offer the same functionality pertaining
    to the dynamic discovery of the number of levels in our hierarchy, we would get
    a better idea of what is going on under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, let''s run the multiple join query with the `EXPLAIN` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f4eb1ecc-c582-40ef-8fb8-f9e4e112e77a.png)MariaDB''s query execution
    plan with the JOIN statements'
  prefs: []
  type: TYPE_NORMAL
- en: 'And now against the RDBMS''s performance schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8fc22b94-631c-4e12-a209-4d3447747a98.png)The multiple joins caused
    65 operations in the database engine'
  prefs: []
  type: TYPE_NORMAL
- en: 'Secondly, let''s go through the same steps, but with the recursive CTE:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f055c2ca-730c-4af5-b8e7-f9504a5793b2.png)MariaDB''s query execution
    plan with the recursive CTE'
  prefs: []
  type: TYPE_NORMAL
- en: 'And, the performance schema should yield the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b0996943-fe99-42b8-8948-837863f9a63a.png)The CTE caused 47 operations
    in the database engine'
  prefs: []
  type: TYPE_NORMAL
- en: Although this recursive CTE was a little slower than the basic multiple join
    query on my computer, it did generate fewer engine operations overall when all
    the selected columns were indexed. So, why is this more performant? A recursive
    CTE will allow you to avoid the hassle of creating a stored procedure, or something
    similar, in order to recursively discover the number of levels in your hierarchy
    tree, for example. This would most certainly make the multiple join query much
    slower if we added these operations to the main query. Also, a recursive CTE might
    be a kind of derived table that is not much quicker than a View and slightly slower
    than a basic multiple join query, but it is certainly very scalable and very useful
    when querying a database in order to walk a hierarchy tree, when using ranking
    functions or when modifying table contents based on a small result subset while
    resting assured that your more complex queries will benefit, for free, from future
    engine optimizations. Moreover, it will make your development cycle more efficient
    as it will make your code more readable to other developers by keeping it **DRY**
    ("**Don't Repeat Yourself**").
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the next feature, the `CASE` expression.
  prefs: []
  type: TYPE_NORMAL
- en: CASE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though the `CASE` expression seems to remind us of imperative structures
    such asÂ `IF`, `SWITCH`, and the like, it still does not allow for program flow
    control like those imperative structures, but rather allows for declarative evaluation
    of values based on certain conditions. Let's have a look at the following example
    in order to better understand this feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please enter the following query in the SQL tab of the test database via the
    `phpMyAdmin` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This query should yield the following result set:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/777459b1-42ce-4b2f-bf6f-7b9c17dbe087.png)Result set of the query
    containing the CASE statement'
  prefs: []
  type: TYPE_NORMAL
- en: As the result shows, the row with an `id` value of `2` was filtered out from
    the input of the second `COUNT` function as the `CASE` expression applied the
    condition which states that the superiorÂ column must not have a `NULL` value in
    order to count the idÂ column. Using this feature of Modern SQL is not, for the
    most part, a question of added performance, but rather a question of avoiding
    stored procedures and controlling execution flows as much as possible, while keeping
    the code clean, easily readable and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: OVER and PARTITION BY
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`OVER` and `PARTITION BY` are window functions that allow calculations to be
    done over a set of rows. Unlike aggregate functions, window functions do not group
    the results though. In order to better understand these two window functions,
    let''s take the time to run the following query in the `phpMyAdmin` web interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After running this query, you should see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4c735583-b305-467f-9f6d-026e2f01ca5a.png)List of managers with payroll
    per manager'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the result set shows the payroll per manager column without grouping
    the results. This is why we had to use the `DISTINCT` statement in order to avoid
    having multiple rows for the same manager. Obviously, window functions allow for
    efficient querying and optimized performance when doing aggregate calculations
    on subsets of rows that have some sort of relationship to the current row.
  prefs: []
  type: TYPE_NORMAL
- en: OVER AND ORDER BY
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `OVER AND ORDER BY` window functions are very useful when it comes to ranking
    within a subset of rows, calculating running totals or simply avoiding self-joins.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate when to use this most useful feature, we will take the previous
    example and determine the best paid employees on each payroll per manager by executing
    this query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing this query will give this result set:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7db91a77-1ede-437a-bbd5-7cad5cb5a5b1.png)List of the best paid employees
    on each payroll per manager'
  prefs: []
  type: TYPE_NORMAL
- en: The returned result set allows us to see the breakdown of each payroll and ranks
    each employee within each subset. And what is the underlying execution plan that
    will allow us to get all these details about these subsets of data? The answer
    is a `SIMPLE` query! In the case of our query, there is a dependent subquery,
    but that is because we are fetching the last name of each manager in order to
    make the result set more interesting.
  prefs: []
  type: TYPE_NORMAL
- en: 'This would be the resulting query after removing the dependent subquery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the underlying execution plan for this version of the same query:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cd90e410-83c9-43db-b954-62c9bf09cf54.png)The query execution plan
    is simple when avoiding to fetch the last name of the manager'
  prefs: []
  type: TYPE_NORMAL
- en: By running the query without the dependent subquery that was returning each
    manager's last name, the `select_type` of our query execution plan is `SIMPLE`.
    This makes for a highly efficient query that will be easily maintainable in the
    future.
  prefs: []
  type: TYPE_NORMAL
- en: GROUPING SETS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GROUPING SETS make it possible to apply many `GROUP BY` clauses in one single
    query. Moreover, this new feature introduces the notion of a `ROLLUP`,Â  which
    is an extra row added to the result set that gives a summary of the results as
    a super-aggregate of previously returned values. Let''s give a very simple example
    using the employees table in the test database. Let''s execute the following query
    in the `phpMyAdmin` web interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Once executed, you should see this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/65ce923d-82e4-43dc-80bd-0ab65ea65110.png)GROUPING SETS make it possible
    to apply many GROUP BY clauses in one single query'
  prefs: []
  type: TYPE_NORMAL
- en: 'The multiple `GROUP BY` clauses have allowed us to quickly see each individual
    salary of each employee under the supervision of each manager. If we now add the
    `ROLLUP` operator to the `GROUP BY` clauses, we will obtain this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b0c388e6-2ed6-4a28-9db9-1cae7aa20bbf.png)The result set when adding
    the ROLLUP operator to the GROUP BY clauses'
  prefs: []
  type: TYPE_NORMAL
- en: The `ROLLUP` operator adds extra rows that contain a super-aggregate result
    for each subset and for the entire result set. The execution plan reveals that
    the underlying `select_type` is once more `SIMPLE` instead of having multiple
    queries united with a `UNION` operator as we would have done before this feature
    existed. Once more, Modern SQL offers us a highly optimized query which will remain
    highly maintainable for many years to come.
  prefs: []
  type: TYPE_NORMAL
- en: JSON clauses and functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the latest additions to the SQL language is the JSON features. This new
    group of features makes it easier to benefit from the advantages of storing certain
    types of unstructured and schema-less data like the JSON format in a very structured
    and relational way using SQL native functions. This allows for many things, such
    as applying integrity contraints on certain JSON fields contained in a JSON document,
    indexing certain JSON fields, easily converting and returning unstructured data
    into relational data and vice versa, and inserting or updating unstructured data
    by the means of the proven reliability of SQL transactions.
  prefs: []
  type: TYPE_NORMAL
- en: To fully appreciate this new group of features, let's insert some data into
    the test database by executing a query that will convert the JSON data into relational
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, please execute the following command on the container''s CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the new table is loaded into the database, you can execute the following
    query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Once executed, you should see this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/902782e2-c7c8-4e12-8aaf-d1238df20da2.png)The JSON functions automatically
    convert the JSON data into relational data'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, converting JSON unstructured data into relational and structured
    data was very easy using the new JSON functions. Inserting unstructured data into
    a structured database is just as easy. Moreover, the added constraint would verify
    that the JSON string being inserted is valid. To verify this feature, let''s attempt
    to insert invalid JSON data into our test table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon trying to execute the query, we would get the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ca660695-dede-40df-932e-b66f89a12210.png)The JSON constraints make
    sure that the JSON string being inserted is valid'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, Modern SQL makes working with JSON-formatted data easy in an SQL environment.
    This will greatly optimize performance at the application level, as it will now
    be possible to eliminate the overhead that comes with having to `json_encode()`
    and `json_decode()` every time an application needs to retrieve or store JSON-formatted
    data into a relational database.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many more Modern SQL features that we could try to better understand,
    but not all RDBMSs have implemented them and many of these features would require
    that we analyze implementation details. We will simply look at two more features
    that have not been implemented within the MariaDB server, but that have been within
    the PostgreSQL server. In order to start and use the PostgreSQL server that is
    included in the Linux for PHP container, please enter the following commands on
    the container''s CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After entering these commands, you should be able to access the PostgreSQL
    server via the `phpPgAdmin` web interface at `http://localhost:8181/phppgadmin`.
    Point your browser to this address and click on the Servers icon in the upper
    right-hand corner of the screen in order to see the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1c4e010d-a76d-4d51-9676-cae9bb368916.png)Only one available PostgreSQL
    server is listed and is accessible through port 5432'
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, click on the PostgreSQLÂ link in the center of the page, type `postgres`
    as the Username and leave the Password empty on the login page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c770642c-08c9-4ddb-a5a5-9b3468636b4f.png)On the login page, type
    in the username ''postgres'' and the leave the password box empty'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, click on the LoginÂ button and you should be able to access the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6bf40f18-277d-4e62-ab10-6505c96eb23b.png)The server displays postgres
    as its only available database'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will create a database that will allow us to learn how to use the
    two last Modern SQL features that we will cover in this book. In the `phpPgAdmin`
    interface, click on the Create databaseÂ link and fill out the form in order to
    create the test database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b9e3abd9-2616-4dd0-8f9c-f17aa5ce963d.png)Create the database test
    with the template1 template and an encoding of LATIN1'
  prefs: []
  type: TYPE_NORMAL
- en: 'By clicking on the CreateÂ button, you will create the test database alongside
    the postgres database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/347ae761-f294-471d-98b6-393bcdaa8114.png)Now, the server displays
    the test database alongside the postgres database'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this is done, enter the following commands on the container''s CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to try out the `FILTER` clause.
  prefs: []
  type: TYPE_NORMAL
- en: FILTER
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another very interesting feature of Modern SQL is the `FILTER` clause. It makes
    it possible to add `WHERE` clauses to aggregation functions. Let''s try the `FILTER`
    clause by executing the following query in the SQL tab of the test database in
    the `phpPgAdmin` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a84067cb-b25f-4409-bf2b-cdf8e447095a.png)Result set of the query
    containing the FILTER statement'
  prefs: []
  type: TYPE_NORMAL
- en: The `FILTER` clause is great for generating reports without adding too much
    overhead in the query's `WHERE` clauses.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, a `FILTER` clause is great for pivot tables, where grouping by year
    and month is made more complicated by the fact that it is necessary to generate
    a report that must cross month and year on two different axes (month = *x* and
    year = *y*, for example).
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue with the last Modern SQL feature, `LATERAL` queries.
  prefs: []
  type: TYPE_NORMAL
- en: LATERAL queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`LATERAL` queries allow you to select more than one column and one row in a
    correlated subquery. This is very useful when creating Top-N subqueries and trying
    to join table functions together, thus making unnesting them a clear possibility.
    The `LATERAL` query can then be thought of as a sort of SQL `foreach` loop.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s give a simple example that would illustrate how a `LATERAL` query would
    work. Let''s say that we have two hypothetical tables that contain data on films
    and actors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the `LATERAL` subquery is selecting multiple columns from the
    actor table `(actor.name and actor.biography)` while still being able to correlate
    references from the film table `(film.id)`. Many optimizations, whether it be
    performance optimizations or code readability and maintainability, become a real
    possibility with `LATERAL` queries.
  prefs: []
  type: TYPE_NORMAL
- en: For further information on Modern SQL, I invite you to consult *Markus Winand*'s
    excellent website ([https://modern-sql.com](https://modern-sql.com)), and listen
    to *Elizabeth Smith*'s great presentation on this topic at *Nomad PHP* ([https://nomadphp.com/product/modern-sql/](https://nomadphp.com/product/modern-sql/)).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to query an SQL database efficiently using
    Modern SQL. We have defined what Modern SQL is and how we can use it. We have
    acquired knowledge of how to convert certain traditional SQL queries into modern
    ones and when it is best to do so. Moreover, by doing so, we now better understand
    how Modern SQL can help us optimize a server's performance in more than one way.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover a few of JavaScriptâs best and worst parts,
    especially those that pertain to code efficiency and overall performance, and
    how a developer should always write safe, reliable and highly efficient JavaScript
    code, mostly by avoiding *danger-driven development*.
  prefs: []
  type: TYPE_NORMAL
