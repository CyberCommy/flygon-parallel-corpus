- en: Chapter 11 – Debugging with PDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Even with a comprehensive automated test suite, we can still get into situations
    where we need a debugger to figure out what’s going on. Fortunately, Python includes
    a powerful debugger with the standard library: PDB. PDB is a command-line debugger,
    and if you’re familiar with tools like GDB then you’ll already have a good idea
    of how to use PDB.'
  prefs: []
  type: TYPE_NORMAL
- en: The key advantage of PDB over other Python debuggers is that, being part of
    Python itself, PDB is available pretty much anywhere that Python is, including
    specialized environments where the Python language has been embedded into larger
    systems, such as ESRI’s *ArcGIS* Geographical Information System. That said, it
    can be much more comfortable to use a so-called *graphical* debugger, such as
    the ones included with products such as *Jetbrains*’ *PyCharm* or *Microsoft*’s
    *Python Tools for Visual Studio*. You should feel free to skip this chapter until
    such time that familiarity with PDB becomes more pressing; you won’t be missing
    anything we rely on later in this book or in *The Python Journeyman* or *The Python
    Master*.
  prefs: []
  type: TYPE_NORMAL
- en: PDB is different from many debugging tools in that it’s not really a separate
    program but rather a module just like any other Python module. You can import
    `pdb` into any program and start the debugger using the `set_trace()` function
    call. This function starts the debugger at whatever point you are at in the program’s
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our first look at PDB, let’s use a REPL and start the debugger with `set_trace()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You’ll see that after you execute `set_trace()` your prompt changes from the
    triple-chevron to `(Pdb)` – this is how you know you’re in the debugger.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first thing we’ll do is see what commands are available in the debugger
    by typing `help`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This lists a few dozen commands, some of which you’ll use in almost every debugging
    session, and some of which you may never use at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get specific help on a command by typing `help` followed by the command
    name. For example, to see what `continue` does, type `help continue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The curious parentheses in the command name tell you that ‘continue’ can be
    activated by typing `c`, `cont`, or the full word `continue`. Knowing the shortcuts
    for common PDB commands can greatly increase your comfort and speed at debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Palindrome debugging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rather than list all of the commonly useful PDB commands, we’re going to instead
    debug a simple function. Our function – `is_palindrome()` – takes in an integer
    and determines if the digits of the integer are a palindrome or not. A palindrome
    is a sequence which is the same both forwards and backwards.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we’ll do is create a new file, `palindrome.py`, with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, our code has three main parts. The first is the `digits()` function
    which converts an integer into a list of digits.
  prefs: []
  type: TYPE_NORMAL
- en: The second is the `is_palindrome()` function which first calls `digits()` and
    then checks if the resulting list is a palindrome.
  prefs: []
  type: TYPE_NORMAL
- en: The third part is a set of unit tests. We’ll use these tests to drive the program.
  prefs: []
  type: TYPE_NORMAL
- en: As you might expect, this being a section on debugging, there’s a bug in this
    code. We’re going to first run the program and notice the bug, and then we’ll
    see how to use PDB to find the bug.
  prefs: []
  type: TYPE_NORMAL
- en: Bug hunting with PDB
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'So, let’s run the program. We have three tests that we expect to run, and since
    this is a relatively simple program we expect it run very quickly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Instead of running quickly, we see that this program seems to run forever! And
    if you look at its memory usage, you’ll also see that it grows in size the longer
    it runs. Clearly something is wrong, so let’s use Ctrl-C to kill the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use PDB to try to understand what’s going on here. Since we don’t know
    where our problem might lie, we don’t know where to put a `set_trace()` call.
    So we’re going to instead start the program under the control of PDB using a command-line
    invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here we’re using the `-m` argument which tells Python to execute the specific
    module – in this case PDB – as a script. The remaining arguments are passed to
    that script. So here we’re telling Python to execute the PDB module as a script,
    and we’re passing the name of our broken file to it.
  prefs: []
  type: TYPE_NORMAL
- en: What we’re seeing is that we’re immediately taken to a PDB prompt. The arrow
    pointing to `import unittest` is telling us that this is the next statement that
    will be executed when we continue. But where is that statement?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use the `where` command to find out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `where` command reports our current call stack, with the most recent frames
    at the bottom, and we can see that PDB has paused execution at the very first
    line of `palindrome.py`. This reinforces an important aspect of Python execution
    which we’ve discussed before: everything is evaluated at runtime. In this case,
    we’ve paused execution right before an `import` statement.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can execute this import by running to the next statement using the `next`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that this takes us to the `def` call for the `digits()` function. When
    we execute another `next`, we move to the definition of the `is_palindrome()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Finding infinite loops with sampling
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We could continue using `next` to move through our program’s execution, but
    since we don’t know where the bug lies this might not be a very useful technique.
    Instead, remember that the problem with our program is that it seemed to be running
    forever. This sounds a lot like an infinite loop!
  prefs: []
  type: TYPE_NORMAL
- en: 'So rather than stepping through our code, we’ll let it execute and then we’ll
    use Ctrl-C to break back into the debugger when we think we might be in that loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'After letting the program run for a few seconds, we press Ctrl-C which halts
    the program and shows us that we’re in the the `digits()` function of `palindrome.py`.
    If we want to see the source code at that line, we can use the PDB command `list`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We see that this is indeed inside a loop, which confirms our suspicion that
    an infinite loop might be involved.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `return` command to try to run to the end of the current function.
    If this doesn’t return, we’ll have very strong evidence that this is an infinite
    loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We let this run for a few seconds to confirm that we never exit the function,
    and then we press Ctrl-C. Once we get back to a PDB prompt, let’s exit PDB with
    the `quit` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Setting explicit breaks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we know the problem lies in `digits()`, let’s set an explicit breakpoint
    in there using the `pdb.set_trace()` function mentioned earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the `set_trace()` function will halt execution and enter the debugger.
  prefs: []
  type: TYPE_NORMAL
- en: 'So now we can just execute our script without specifying the PDB module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: And we see that we almost immediately go to a PDB prompt with execution halted
    at the beginning of our `digits()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that we know where we are, let’s use `where` to see our call stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the most recent frames are at the end of this listing. After a
    lot of `unittest` functions, we see that we are indeed in the `digits()` function,
    and that it was called by `is_palindrome()`, just as we expected.
  prefs: []
  type: TYPE_NORMAL
- en: Stepping through execution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'What we want to do now is watch execution and see why we never exit this function’s
    loop. Let’s use `next` to move to the first line of the loop body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now lets look at the values of some of our variables and try to decide what
    we expect to happen. We can examine values by using the print command^([34](chap21.xhtml#fn-pdb_commands)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks correct. The `digs` list — which will contain the sequence of digits
    in the end — is empty, and `x` is what we passed in. We expect the `divmod()`
    function to return `123` and `4`, so let’s try that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks correct: `divmod()` has clipped off the least significant digits
    from our number, and the next line puts that digit into our results list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at `digs`, we’ll see that it now contains `mod`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The next line will now update `x` so that we can continue clipping digits from
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that execution goes back up to the while-loop as we expected. Let’s
    look at `x` to make sure it has the right value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Wait a second! We expect `x` to hold the digits that aren’t already in the results
    list. Instead, it contains *only* the digit in the results list. Clearly we’ve
    made a mistake in updating `x`!
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at our code, it quickly becomes apparent that we should have assigned
    `div` rather than `mod` to `x`. Let’s exit PDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note that you may have to run `quit` a few times because of how PDB and `unittest`
    interact.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the bug
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'After you’re out of PDB, let’s remove the `set_trace()` call and modify `digits()`
    to fix the problem we found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run our program now, we see that we’re passing all tests, and it runs
    very quickly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: So that’s a basic PDB session, and it demonstrates some of the core features
    of PDB. PDB has many other commands and features, however, and the best way to
    learn them is to start using PDB and trying out the commands. This palindrome
    program can serve as a good example for learning most of the features of PDB.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python’s standard debugger is called PDB.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PDB is a standard command-line debugger.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `pdb.set_trace()` method can be used to stop program execution and enter
    the debugger.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your REPL’s prompt will change to (Pdb) when you’re in the debugger.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can access PDB’s built-in help system by typing “help”.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use `python -m pdb` followed by a script name to run a program under
    PDB from the start.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PDB’s `where` command shows the current call stack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PDB’s `next` command lets execution continue to the next line of code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PDB’s `continue` command lets program execution continue indefinitely, or until
    you stop it with control-c.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PDB’s `list` command shows you the source code at your current location.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PDB’s `return` command resumes execution until the end of the current function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PDB’s `print` command lets you see the values of objects in the debugger.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `quit` to exit PDB.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Along the way we found that:'
  prefs: []
  type: TYPE_NORMAL
- en: '`divmod()` calculates the quotient and remainder for a division operation at
    one time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `reversed()` function can reverse a sequence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can pass `-m` to your Python command to have it run a module as a script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging makes it clear that Python is evaluating everything at run time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
