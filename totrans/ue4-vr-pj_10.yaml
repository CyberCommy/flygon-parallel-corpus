- en: Creating a Multiplayer Experience in VR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we're going to move into some more advanced territory. Multiplayer
    software is significantly more complicated to write than single-player applications.
    There's no way around the reality that to write successful multiplayer code, you
    have to build a clear mental model of what's going on and how your data is getting
    from one computer to the other. The good news is that's what we're here to do.
    We're going to be dropping a lot more theory in this chapter than we usually do,
    and the reason for this is that if we simply walked you through the steps of setting
    up a networked application, that's really not going to help you. You have to understand
    how networking works to understand how you need to build your application. But
    don't worry—we'll try to alternate between theory and practical examples so you
    can build a hands-on understanding of how this stuff works.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to be clear that networking is a big topic and it's fairly advanced.
    We're not going to have space in this chapter to go over every dark corner of
    the art, but we'll consider it a success if you finish this chapter with a good
    understanding of how networked applications fit together, what the major parts
    are, and how information most commonly moves around. If you come away with this
    understanding in a reasonably clear state, you'll be set up well to understand
    what you're seeing as you learn more about this topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to learn to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Work with Unreal's client-server model to ensure that important gameplay events
    happen on the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replicate actors from the server to connected clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replicate variables and call functions automatically when their values change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a pawn that looks more different to the owning player than it does to
    other players
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use remote procedure calls to call events on remote machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's jump in!
  prefs: []
  type: TYPE_NORMAL
- en: Testing multiplayer sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get into the weeds talking about how networking works, let's learn
    how to launch a multiplayer session. There are a number of ways you can do this.
    The easiest is to launch the multiplayer session directly from within your editor,
    and most of the time when you're testing network replication, this is going to
    be fine. For more comprehensive tests, or if you need one of the sessions to run
    in VR, you can launch two separate game sessions and connect them to each other.
    We'll show examples of how to do this a little later on when we discuss session
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Testing multiplayer from the editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fortunately, the Unreal editor makes it fairly easy to set up a multiplayer
    session from within the editor on a single machine. To perform this test, we''re
    going to use the **Content Examples** project:'
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't already downloaded the Content Examples project, do so now by
    selecting Content Examples | Create Project from the Unreal Engine | Learn tab
    in your Epic Games Launcher. You should get into the habit of always keeping a
    current version of Content Examples installed on your system and using it for
    reference.
  prefs: []
  type: TYPE_NORMAL
- en: Open the Content Examples project and open the Network_Features level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the dropdown beside your toolbar''s Play button and set the Multiplayer
    Options | Number of Players to 2\. Refer to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3d0d4414-ca6c-4892-8a15-53780e541672.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select New Editor Window (PIE) to launch a multiplayer session as shown in
    the following screenshot (unfortunately, we can''t use the multiplayer options
    to support a multiplayer VR session on a single machine):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/df10c014-8ab5-4341-8f6f-4cc09b4a7ea5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Explore the scene playing as both server and client. Notice the differences
    between what appears on the server and what appears on the client. We''re going
    to look at these things in greater depth shortly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ac9155ca-37df-4151-ad46-34187958b606.png)'
  prefs: []
  type: TYPE_IMG
- en: In this example, the ghost on the left is visible on the server but not on the
    client because it has not been set to replicate to clients.
  prefs: []
  type: TYPE_NORMAL
- en: Take some time to understand what each of these displays is telling you in the
    context of what we've described so far, but don't worry if some things are still
    fuzzy—we're going to make more use of these ideas in our upcoming exercises.
  prefs: []
  type: TYPE_NORMAL
- en: For additional information about multiplayer-testing options in-editor, refer
    to the documentation here: [https://docs.unrealengine.com/en-us/Gameplay/HowTo/Networking/TestMultiplayer](https://docs.unrealengine.com/en-us/Gameplay/HowTo/Networking/TestMultiplayer).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the client-server model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a running test we can play with, let's get a bit of theory
    out of the way. It wouldn't be a bad idea to leave this test level open and explore
    it while we talk about this next concept.
  prefs: []
  type: TYPE_NORMAL
- en: To understand how multiplayer gameplay works in Unreal, you first need to understand
    how information moves between the connected game sessions and how changes are
    made to the game environment. There's no way around this. To write multiplayer
    code successfully, you have to build a clear mental model of what's going on,
    or you'll wind up hitting a lot of walls. Multiplayer is challenging to debug—if
    something doesn't work, you can't simply set a breakpoint in your blueprint and
    trace through to see what happened. Very often, all you'll know is that a bit
    of information you thought should have gone to the other machine never got there.
    If you take the time to understand how networking works, you'll have a much easier
    time figuring out what's gone wrong when something doesn't work as you expected
    it to. Multiplayer is absolutely not something you can debug by stabbing in the
    dark.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's learn how networking in Unreal works.
  prefs: []
  type: TYPE_NORMAL
- en: To begin thinking about this, let's imagine a scenario. Let's say you've created
    a multiplayer shooter, and two players have joined a session and are both playing.
    One of the players aims and fires, and now we need to show both players what happened.
  prefs: []
  type: TYPE_NORMAL
- en: Sounds simple enough at first, but it isn't.
  prefs: []
  type: TYPE_NORMAL
- en: Player A is aiming, but this is happening on player A's game instance. How does
    player B's game instance know where player A is at all, let alone where they're
    aiming? Player A fires. How does player B's game instance find out that this happened?
    Now, someone needs to figure out whether player A's shot hit player B's avatar.
    Who figures out whether the shot hit? What if player B is on a slow network connection
    and the information about where player A was aiming hasn't gotten there yet? If
    both game instances were allowed to decide whether the shot hit, they wouldn't
    agree. Whose opinion would win?
  prefs: []
  type: TYPE_NORMAL
- en: The answer to the first question—how does player B's game instance know about
    player A's movements and actions—is handled through a process called **replication**.
    When player A moves, their avatar's movement is **replicated** to player B's game
    instance, and when player B moves, their movement is replicated to player A's
    game instance.
  prefs: []
  type: TYPE_NORMAL
- en: The answer to the last question—who decides whether the shot hit—is handled
    by the **server**, and it's worth taking some time to understand this.
  prefs: []
  type: TYPE_NORMAL
- en: Unreal Engine uses a **client-server** model of network management. What this
    means is that only one of the game instances connected to a game session is actually
    allowed to make important decisions about what's really happening. The server
    is **authoritative**, and the clients are not. If the server and a client come
    to two different conclusions about a thing that just happened, the server's opinion
    is the one that gets used.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a **peer-to-peer** model, everybody would be equal. Peer-to-peer network
    architectures are relatively easy to set up, but they come at a high cost: when
    one of the connected peers gets out of sync with the other, nobody knows which
    one''s state is actually true. That may be fine for a demo or a class project
    but would be absolutely unacceptable in an environment where players actually
    cared about the outcomes. We need to know without question what the actual state
    of the game and all its players is, and the client-server model gives us a reliable
    way to do this.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what actually happens:'
  prefs: []
  type: TYPE_NORMAL
- en: Player A moves, and their movement is replicated to the server, which replicates
    their movement to all the other connected game instances.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Player B and any other connected players see a **proxy** in their game sessions,
    which shows them where the server says player A's avatar is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When player A aims and fires, player A's client actually sends a request to
    the server telling it that it wants to fire, and the server makes the actual determination
    of whether it can.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the server determines that player A has ammo, is in the right state, or whatever
    the game rules specify, it fires the weapon and tells all the connected game instances
    that it did.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server has also been receiving player B's replicated movement, so it has
    the information it needs to figure out whether player A's shot hit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it determines that it did, it decreases player B's health or does whatever
    it needs to do to respond to this event and tells all the connected clients that
    player B was hit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Each client then updates its local state information, plays hit animations
    and effects, and updates its UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/39627582-40b9-4801-8485-947381232269.png)'
  prefs: []
  type: TYPE_IMG
- en: The top panel represents the server's view, while the bottom panel is the client's
    view. Lines have been added to indicate objects whose states can change and need
    to be replicated to clients.
  prefs: []
  type: TYPE_NORMAL
- en: Unreal's network architecture is astonishingly efficient, which is why a game
    such as *Fortnite* can run in real-time even when a large number of players are
    simultaneously connected. There are a number of reasons for this, and many of
    them are under your control as a developer. We'll cover a few of the important
    ones in depth later on in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a closer look at a few important concepts.
  prefs: []
  type: TYPE_NORMAL
- en: The server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term **server** refers to the **network authority** in a multiplayer environment.
    You'll hear these terms used interchangeably. Technical documentation will tend
    to use the term *network authority*, as that describes more precisely what it
    really is, while most of the other material you read will call it the *server*.
    Both refer to the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: A great deal of the time, when something goes wrong in your networked application,
    it's going to be because you allowed a client to try to change the game state
    when instead it needed to ask the network authority to make the change.
  prefs: []
  type: TYPE_NORMAL
- en: 'The architecture works like this: the server *hosts* the game and allows multiple
    clients to connect to it and communicate data back and forth. Communication happens
    between clients and the server, and clients almost never communicate directly
    with one another:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a690e3a-07d6-4d3b-9273-c4012a39b1bf.png)'
  prefs: []
  type: TYPE_IMG
- en: When a player performs an action, information about what the player is doing
    or wants to do is sent from that player's client to the server. The server validates
    this information and responds, telling the connected clients what it decided.
  prefs: []
  type: TYPE_NORMAL
- en: If, for example, you move your player avatar in a multiplayer game, you're not
    really moving your avatar locally at all. Instead, your client will tell the server
    that you want to move, and the server will then determine how you've moved and
    replicate your new position back to your client and to the other connected clients.
  prefs: []
  type: TYPE_NORMAL
- en: This is true for seemingly-direct messages between clients as well. If you send
    a chat message to another client, you're actually sending it to the server, and
    then the server decides which client or group of clients should receive it.
  prefs: []
  type: TYPE_NORMAL
- en: The server, as we mentioned previously, is the network authority responsible
    for maintaining the actual **authoritative state** of the multiplayer session.
    This idea of **authority** is one of the most important concepts to grok about
    networking and you're going to see when we get to the practical examples that
    we check for authority with almost everything we do. If you keep clear in your
    mind who should be allowed to make a change and you check to make sure that any
    change really is being made by the entity allowed to make it, you'll be ahead
    of the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good rule of thumb to follow is this: if any other player would care about
    this change, it belongs on the server. If nobody else would care, do it locally.
    So, if you''re playing a visual effect that doesn''t matter to the game, don''t
    bother running it on the server, but if you''re changing a player''s health or
    moving them around, do that on the server, since everybody else is going to need
    to agree on it.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to ensuring that there's only one description at a time of anything
    important to the game, there's another reason why it's important to maintain a
    single network authority, and that is to ensure that a player can't easily cheat
    by modifying their client. When important decisions are left to the server, the
    server can fairly easily override results on a hacked client. If the player wants
    to fire a weapon, make sure their client tells the server about it, and let the
    server decide whether they have enough ammo and are allowed to take the shot.
    Never process an important gameplay event directly on the client. Only let them
    happen once the server allows it. Never trust the client.
  prefs: []
  type: TYPE_NORMAL
- en: Listen servers, dedicated dervers, and clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three fundamental types of game session that can be running in an
    Unreal networked environment: two types of servers and one client type.'
  prefs: []
  type: TYPE_NORMAL
- en: Listen servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you run a **listen server**, your machine is acting as the host for the
    game session and as the authority over that game session, but it is also running
    a client. If you've ever set up a networked game in Unreal, it may have looked
    as though you were running a peer-to-peer session, but this is what was really
    going on. The listen server is pretty much invisible to the local player—it doesn't
    look like a separate running process, but it actually is separate from the local
    client exactly as it would be if it were on another machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command-line arguments will launch a listen server using uncooked
    editor data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Often, your easiest way to use these commands will be to create shortcuts containing
    the arguments, or to write a simple `.bat` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `.bat` file will launch a listen server using the Content Examples
    project''s Network_Features map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we're setting variables for our executable location, project
    path, and map name just to make the file easier to read and edit. We're also turning
    on the log and setting the window sizes and locations explicitly to make it easier
    to see what's going on and fit other sessions on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Dedicated servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **dedicated server** does not have a client running in the same session. It
    doesn't accept input or render output, and because of this it can be optimized
    to run less expensively than a listen server. Because dedicated servers are so
    much smaller than full game clients since they don't need to include anything
    that's going to be rendered to the player, you can fit many of them on a single
    machine for hosting. Your existing game executable can be told to run itself as
    a dedicated server, or developers have the option to compile a separate executable
    for dedicated servers, which can further deter cheating and can make the executable's
    footprint on the disk much smaller.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command will launch a dedicated server using editor data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that we've chosen to turn on the log for this session. This is because
    dedicated servers don't open a rendering window, so a visible log becomes essential
    for knowing what it's doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could modify the preceding `.bat` file to launch a dedicated server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we replaced the `?listen` directive with a `-server` argument,
    and of course we didn't need any of the window placement specifications, since
    a dedicated server won't open a game window.
  prefs: []
  type: TYPE_NORMAL
- en: Clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **client** is the point of contact between a networked application and the
    player. The client may be running on the same system as the server if we're using
    a listen server, or it may stand entirely on its own if it's connected to a remote
    host or to a dedicated server. The client is responsible for accepting input from
    the player, communicating that input to the server via **remote procedure calls**
    (**RPC**), and receiving new information about the gamestate from the server via
    replication.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command will launch a client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note that in the preceding example, `ServerIP` is the IP address of the server
    to which you're trying to connect. If you're connecting to a server running on
    your own machine for testing, the default home address of `127.0.0.1` will connect
    to a server running on the local machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `.bat` file will launch a client that connects to a server running on
    the same machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Again, the `-log` and window size arguments are entirely optional—it just makes
    it easier to test multiplayer sessions if you set up your shortcuts to place your
    windows out of each other's way when they start up.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've done a bit of preliminary experimentation and talked about a
    few fundamental ideas, let's set up our own test project so we can perform our
    own experiments.
  prefs: []
  type: TYPE_NORMAL
- en: Testing multiplayer VR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To test multiplayer in VR, you're generally going to need two separate PCs on
    the network. It is sometimes possible to test multiplayer VR on a single machine,
    but some VR headset drivers will automatically send a quit signal to a running
    3D application when a second one starts up.
  prefs: []
  type: TYPE_NORMAL
- en: As of Unreal 4.21, the HTC Vive plugin automatically shuts down an existing
    Unreal session if a second one starts up. (The code that does this lives in `FSteamVRHMD::OnStartGameFrame(),`
    but unfortunately there's no easy way for users of the installed binaries to change
    this behavior.) The Oculus HMD plugin does not automatically quit existing sessions,
    so if you're using an Oculus Rift, you'll likely be able to test multiplayer on
    a single machine, but if you're using a Vive, you'll need two PCs.
  prefs: []
  type: TYPE_NORMAL
- en: If you'd like to give it a shot, simply add the `-vr` keyword to any launch
    string.
  prefs: []
  type: TYPE_NORMAL
- en: 'A server launch string would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And, a client launch string would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Of course, if you're trying to test on a single machine, only set one session
    to use VR at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Because it's going to be impractical for many users to test multiplayer VR with
    a single machine, we're going to run through our multiplayer examples in 2D for
    the most part so you can learn the concepts in an environment that can reasonably
    support testing. We will, however, still go through certain specific things you'll
    need to do to make a player character's animations respond appropriately to headset
    and motion controller movements, so you'll exit this chapter with a good foundation
    from which to get started in multiplayer VR.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our own test project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we did with our last chapter, we''re going to start out simply by creating
    a clean project with the following settings:'
  prefs: []
  type: TYPE_NORMAL
- en: Blank blueprint template
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mobile/tablet hardware target
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scalable 3D or 2D graphics target
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No Starter Content
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As usual, here''s our project settings cheat sheet:'
  prefs: []
  type: TYPE_NORMAL
- en: Engine | Rendering | Forward Renderer | Forward Shading: True
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Engine | Rendering | Default Settings | Ambient Occlusion Static Fraction: False
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Engine | Rendering | Default Settings | Anti-Aliasing Method: MSAA
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Engine | Rendering | VR | Instanced Stereo: True
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Engine | Rendering | VR | Round Robin Occlusion Queries: True
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''re going to set one value differently, however, for this test because we''re
    going to be working mostly in the flat screen to simplify learning this challenging
    topic:'
  prefs: []
  type: TYPE_NORMAL
- en: Project | Description | Settings | Start in VR: False
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow the project to restart once all these settings have been set.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's give ourselves some environment assets to play with so we're not stuck
    looking at an empty level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your Epic Games Launcher and find the Infinity Blade: Ice Lands pack.
    Add it to your project.'
  prefs: []
  type: TYPE_NORMAL
- en: If you're unable to add a content pack to a project because it says it's not
    compatible with your current project version, you can very often get around this
    just by adding the content pack to a project built with the highest version the
    content pack allows, and then migrating its assets to your new project. So, for
    example, if I'm trying to add Ice Lands to a 4.21 project, and the launcher tells
    me I can't because Ice Lands has only been flagged as compatible with 4.20, I
    can add the content to a 4.20 project and then migrate it to a 4.21 project. Most
    of the time, this will work.
  prefs: []
  type: TYPE_NORMAL
- en: This may take a while. Once these assets have been added, open up your project.
    We're going to begin by creating a new Game Mode to get ourselves set up for a
    multiplayer session.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a network Game Mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember when we mentioned a long time ago that the Game Mode is responsible
    for the rules of a game? In a multiplayer game, this takes on additional significance
    because, as we've mentioned, important gameplay events should only ever happen
    on the server. If you put these two considerations together, then it shouldn't
    surprise you to learn that when a multiplayer game is underway, there's only one
    Game Mode, and it lives on the server.
  prefs: []
  type: TYPE_NORMAL
- en: What this means for you as a developer is if you write code that talks directly
    to the Game Mode, it's going to run fine when you test in a single-player session,
    but will fail when you try to test it in multiplayer because the game mode isn't
    going to be there on the client. This confuses many new multiplayer developers,
    so this would be a good time to take a quick look at Unreal's network framework
    and understand where different objects live.
  prefs: []
  type: TYPE_NORMAL
- en: Objects on the network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When thinking about objects in the multiplayer framework, you can think of
    them as occupying four different domains:'
  prefs: []
  type: TYPE_NORMAL
- en: Server Only: Objects exist only on the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server & Clients: Objects exist on the server and on every client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server & Owning Client: Objects exist on the server and the client that owns
    them, but they do not exist on any other client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Owning Client Only: Objects exist only on the client that owns them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2be14d13-b54d-48dc-8635-f5b958c54c20.png)'
  prefs: []
  type: TYPE_IMG
- en: While this may seem at first like an academic point, you're really going to
    need to understand this. More than once in your early networking career, you're
    going to try to communicate with an object that doesn't live where you think it
    does because in a single-player session you never needed to think about this.
    Everything lives in the same space in a single-player game. In multiplayer, they
    don't, and you need to learn where they are.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at this another way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a44a5d2-7c9a-4b48-946d-9591700d1bb9.png)'
  prefs: []
  type: TYPE_IMG
- en: Diagram based on Cedric Neukirchen's excellent Multiplayer Network Compendium,
    found here: http://cedric-neukirchen.net/2017/02/14/multiplayer-network-compendium/
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding diagram, you can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The server owns the GameMode, and no client has access to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server and each connected client can see the Game State. There's only one
    of these.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server and each connected client can see a Player State for each client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server and each connected client can see each client's pawn.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server can see each connected client's player controller, but clients can't
    see other clients' player controllers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The HUD and UI elements only exist on clients, and nobody else knows about them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's talk briefly about what each of these objects does with regard to multiplayer
    gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: Server-only objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Game Mode, as we mentioned a moment ago, lives on the server only. It runs
    the game and is the sole authority on what's going on. Clients, by design, cannot
    access the game mode directly. We've seen already that the game mode is responsible
    for deciding what object classes are created for a game. In a multiplayer game,
    the game mode often takes on additional responsibilities, such as choosing which
    team a player spawns into, where their pawn appears, and whether a match is ready
    to begin or ready to end.
  prefs: []
  type: TYPE_NORMAL
- en: The game mode also applies and enforces the rules of the game. Let's say our
    game's map was split up into sections and these sections can turn into danger
    zones that will damage players if they remain in them. The game mode would be
    responsible for determining which section turned dangerous, and when it happened.
  prefs: []
  type: TYPE_NORMAL
- en: This raises a question though. If the game mode exists only on the server and
    cannot be seen by the clients, how do the clients find out which sections are
    dangerous and which ones aren't?
  prefs: []
  type: TYPE_NORMAL
- en: This is where the next layer of objects comes in—those that exist on both client
    and server.
  prefs: []
  type: TYPE_NORMAL
- en: Server and client objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When clients need to get information about the state of the game, they get it
    from the **Game State**, which is owned by the server but replicated to clients.
    We haven't really talked about replication yet, so for now you can think of it
    as a copy of an object that gets sent from the server to the connected clients.
    The game mode reads information from the game state and writes to it, and the
    server sends copies of the updated game state to all the connected clients through
    replication.
  prefs: []
  type: TYPE_NORMAL
- en: Returning to our previous example, if the game mode simply stored information
    about which zones were dangerous in a variable contained within itself, nobody
    is going to know about it. If the game mode instead stores this information on
    a game state that's replicated to the clients, they can read this information
    from the game state and respond to it.
  prefs: []
  type: TYPE_NORMAL
- en: What if our game mode is also updating scores for each player? Where should
    we put this information? We know of course that it shouldn't go on the game mode,
    since nobody can see it there. We could put it in the game state, and maintain
    an array of scores for each player, but there's a better place for this information.
    The game state maintains an array of **Player State** objects for each connected
    client. This is an ideal place to put information such as a player's score that
    applies to a single player, but that other players need to know about.
  prefs: []
  type: TYPE_NORMAL
- en: We're already familiar with the work that pawns do—these are players' avatars
    in the virtual world. They're maintained on the server and replicated to clients,
    so their movement and other state information can be seen by other players.
  prefs: []
  type: TYPE_NORMAL
- en: Server and owning client objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've seen previously that the player controller is responsible for managing
    input coming from the player and the output being displayed to the player. It
    owns the camera and the HUD, and it handles input events. Each connected client
    in a multiplayer game has a player controller associated with it, and can access
    it just as it would in a single-player session. The server is aware of what's
    going on with each client's player controller as well, but clients cannot see
    anything about each other's player controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Owning client only objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, objects such as UI display widgets exist only on the clients to which
    they apply. The server doesn't know or care about them, and neither do any other
    clients. These are purely local objects.
  prefs: []
  type: TYPE_NORMAL
- en: That was quite a lot of of theory to dump on you, we know, but, as we mentioned,
    it's important. If you take a bit of time to internalize the structure described,
    you'll have a much less-confusing time writing multiplayer applications.
  prefs: []
  type: TYPE_NORMAL
- en: That having been said, let's get back to some hands-on work.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our network game mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re going to use this login to spawn different players at different spawn
    points. Before we go on, let''s jump into our map and add a second player start
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From your Modes panel, select Basic | Player Start, and drag it on to your
    map somewhere, and save your map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remember to use the *P* key to verify that your spawn point is on an area with
    a valid navmesh. (We don't actually need the navmesh yet, but this is a good way
    to verify that the floor collision is good in the location you've chosen and that
    it's inside the gameplay area.)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a267cc36-e75e-4d4c-870d-7bd663f0a600.png)'
  prefs: []
  type: TYPE_IMG
- en: Here we've added a second player start at the other end of the map from the
    first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create a game mode to manage our network gameplay:'
  prefs: []
  type: TYPE_NORMAL
- en: With your new project open, create a directory for it inside your Content Browser.
    Name it `Multiplayer` (or anything you like).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a blueprints subdirectory within this directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click to create Basic Asset | Blueprint Class | Game Mode Base. Name it
    `BP_MultiplayerGameMode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you look in the Content Examples project's BP_GameMode_Network, you'll see
    that it implements its own player start selection in Event OnPostLogin. You don't
    need to do this. The native GameModeBase class does it for you. If you did want
    to create special rules for selecting player starts (to select them by team, for
    example, the correct way to do this is to override the ChoosePlayerStart function.
    To do this, select Functions | Override | Choose Player Start, and put whatever
    logic you want in the resulting graph).
  prefs: []
  type: TYPE_NORMAL
- en: Open Settings | Project Settings | Project | Maps & Modes, and set the Default
    GameMode to our new game mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s test it out:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the dropdown beside your toolbar's Play button and set the Multiplayer
    Options | Number of Players to 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Play This Level in a New Window from your Play button to launch a two-player
    test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should see one player spawning at the original spawn point and the other
    spawning at the new spawn point you just created.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a network client HUD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's add a simple HUD to our clients so we can display information about the
    game to our user. Again, if we were planning this game to run exclusively in VR,
    we would not be using a HUD object, but rather building this in 3D as an attached
    widget. We're doing it this way here because we have quite a lot of ground to
    cover in this chapter and we want to keep it focused on networking.
  prefs: []
  type: TYPE_NORMAL
- en: While we're going to stay focused on creating a 2D HUD for this chapter, we
    can take this opportunity to add a bit of safety to ensure that we don't try to
    display 2D elements in 3D space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new HUD to work with:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From your project''s blueprints directory, right-click on Create Basic Asset
    | Blueprint Class, and expand the All Classes expander and select HUD as your
    class. Refer to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/44adc815-5e04-4519-9af4-bed8c5165ca1.png)'
  prefs: []
  type: TYPE_IMG
- en: Hit the Select button to create it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name it `BP_MultiplayerHUD`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open our new game mode and set this HUD as its HUD Class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a widget for our HUD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s create a widget to display on our HUD:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click or select Add New | User Interface | Widget Blueprint, and name
    the resulting widget `WBP_NetworkStatus`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open up its designer panel and drag a text block on to the lower-left corner
    of the panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that because we're creating a 2D interface in this case, we don't specify
    an explicit screen size; instead, we're allowing it to fill the screen. As you'll
    recall from our earlier UI work, when you're building a widget for 3D use, you'll
    want to specify its size.
  prefs: []
  type: TYPE_NORMAL
- en: Set the Text Block's Anchor to the lower-left corner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Position X to 64.0 and its Position Y to -64.0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Alignment to X=0.0, Y=1.0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name it `txt_ClientOrServer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hit the Bind button beside its Content | Text entry to create a binding for
    it and select Create Binding:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3e28d546-8396-489a-a8ec-ff27bfdb8617.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the resulting function graph, we''re going to check to see whether this
    widget''s owning player controller is a client or a server and we''ll set this
    widget''s text accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a Get Owning Player node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the resulting player controller reference from its return value and call
    Has Authority on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Select node from the Has Authority call's result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the Select node's return value into the function's Return Value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type `Client` into the Select node''s False entry and Server into its True
    entry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0ced092c-d829-4de8-87d1-602b24347b3d.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's talk about a few things here.
  prefs: []
  type: TYPE_NORMAL
- en: Remember how we we described the server as the *network authority*? This Has
    Authority check is now testing to see whether the owning player controller is
    resident on a server. You'll be testing for authority very frequently whenever
    you write network code, because you'll often have to do something different depending
    on whether your code is running on a client or a server. File this mentally as
    a very important concept to keep in mind. Checking for authority is how you're
    going to specify which behaviors happen on the server and which happen on the
    client.
  prefs: []
  type: TYPE_NORMAL
- en: Notice also the lightning-bolt and screen icon on the Get Owning Player node.
    In single-player applications, we didn't care about this icon, but it matters
    in a multiplayer setting. This icon is indicating that the call in question will
    only occur on a client and cannot be used on a server. In this case, this is fine.
    If you recall from the previous diagrams, the HUD and the widgets it owns exist
    on clients only, so this client-only call is going to work. The player controller
    reference it returns can exist on a client or on a server, which is why we're
    going to get a valid result from our Has Authority check.
  prefs: []
  type: TYPE_NORMAL
- en: Refer back to the network framework diagrams as you think this through.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a widget to our HUD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we''re going to add this widget to our HUD:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the HUD's Event Graph and find or create an Event BeginPlay node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an Is Head Mounted Display Enabled node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Branch using its result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Branch node's False output, drag and create a Create Widget call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Class to the widget blueprint we just made.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Get Owning Player Controller node and feed its result into the Create
    Widget node's Owning Player input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag out the Create Widget node''s Return Value and call Add to Viewport on
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/addde112-e480-4238-9cb4-6de7c08ab536.png)'
  prefs: []
  type: TYPE_IMG
- en: What we've just done here is check to see whether we're in VR, and if we're
    not, create an instance of our network status widget and add it to the HUD.
  prefs: []
  type: TYPE_NORMAL
- en: If you wanted to implement a 3D widget for use in VR, this would be a reasonable
    place to do it. You could create a 3D widget in much the same way we did before,
    and use a Get Owning Pawn call to grab the player pawn and attach the widget's
    containing actor to it. It would be equally reasonable to create a 3D widget on
    the pawn as we did earlier, and hide or destroy it if an Is Head Mounted Display
    Enabled check returned false.
  prefs: []
  type: TYPE_NORMAL
- en: Let's test it. You should see one session labeled Server, and the other session
    labeled Client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, try checking the Run Dedicated Server checkbox on the Play menu and run
    it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0dccb107-47a5-45e3-bdb8-36cdebbbfb36.png)'
  prefs: []
  type: TYPE_IMG
- en: This time, you'll see that both sessions indicate that they're clients. What's
    happened here is that a dedicated server has been spawned invisibly and both players
    have connected to it as clients. After you've run this test, uncheck Run Dedicated
    Server again. We're going to need a visible server and client for the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Network replication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've talked a bit about servers and clients, let's learn more about
    how information moves between them.
  prefs: []
  type: TYPE_NORMAL
- en: The first and most important concept to talk about is **replication**. Replication
    is a process by which an actor or a variable value that exists on one system is
    communicated to another connected system so it can be used there as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings up an important point: only those items that you choose to replicate
    will be communicated to the other connected systems, and this is deliberate. Unreal''s
    networking infrastructure is designed for efficiency, and a major way to maintain
    that efficiency, especially if you have a lot of players, is to send only the
    information you absolutely need to send over the network, and send it only to
    those who actually need to receive it. Think about a massively-scoped game such
    as *Fortnite*. It simply could not run if every single piece of data about every
    connected player was being sent to every other player. Unreal can handle very
    large player populations, and it does this by giving you as a developer complete
    control over exactly what gets replicated and to whom. With this power comes responsibility
    though. If you don''t tell an actor or a variable to replicate, it won''t, and
    you won''t see it on a connected machine.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with a simple example to see how this works.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a replicated actor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say we wanted to use a flag to mark something in the game, and it was
    important that all players could see where it was.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can begin by creating an actor for our flag, so let''s do this first:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside your `Blueprints` folder, right-click to select Create Basic Asset |
    Blueprint Class | Actor. We can name our actor `BP_ReplicatedFlag`. Open it up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Add Component | Static Mesh.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the component's Static Mesh property to `/Game/InfinityBladeIceLands/Environments/Ice/Env_Ice_Deco2/StaticMesh/SM_Env_Ice_Deco2_flag2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the static mesh component selected, select Add Component | Skeletal Mesh
    to create a child skeletal mesh attached to the flagpole's static mesh.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the component's Skeletal Mesh property to `/Game/InfinityBladeIceLands/Environments/Ice/EX_EnvAssets/Meshes/SK_Env_Ice_Deco2_BlowingFlag3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the skeletal mesh component's Location to (X=40.0, Y=0.0, Z=270.0) and its
    Scale to (X=1.8, Y=1.8, Z=1.8).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the static mesh component on to the root component and set it as the new
    root.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Point Light component and set its Location to (X=40.0, Y=0.0, Z=270.0)
    so our flag stands out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Spawning an actor on the server only
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s spawn our flag into the level, but only on the server:'
  prefs: []
  type: TYPE_NORMAL
- en: From your Modes panel, drag a Target Point somewhere on your map. Name it `FlagSpawnPoint`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open up your level blueprint, and with FlagSpawnPoint still selected, right-click
    in the event graph to create a reference to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find or create an Event BeginPlay node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the execution line from this node and create a Switch Has Authority node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the execution line from the Switch Has Authority node's Authority output
    and create a Spawn Actor from Class node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Class to the BP_ReplicatedFlag actor we just created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag an output from the reference to your flag spawn point in the level and
    call Get Actor Transform on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Feed the transform into the Spawn node''s Spawn Transform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1775344c-0812-4ac1-8e7b-3fbb40d58bbd.png)'
  prefs: []
  type: TYPE_IMG
- en: Run it. You'll see the flag spawned on your server, but you won't see it on
    the client. Let's talk this through to see why this is.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, the first thing we did on `BeginPlay` was check
    to see whether we have authority. Again, *network authority* is simply another
    term for the server. If we have authority, meaning we're running on the server,
    we spawn the flag at the location we supplied. If we're not on the server, we
    don't spawn it, which is why we didn't see it in our client view.
  prefs: []
  type: TYPE_NORMAL
- en: This is an important pattern to remember. When we talk about making sure important
    gameplay events happen only on the server, this is how you do it. Check to see
    whether you have authority, and perform the action only if you do.
  prefs: []
  type: TYPE_NORMAL
- en: Replicating the actor to the client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now of course in this instance, we want to see this actor on the client as
    well, but at present we can''t because it exists only on the server. Let''s change
    this by making it into a *replicated* actor:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open our flag actor''s blueprint, and in its Details | Replication section,
    set Replicates to true:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0b02951d-cd47-488e-b3c7-2e1afd00e7d5.png)'
  prefs: []
  type: TYPE_IMG
- en: Test it again. Now, we see the flag on the client as well.
  prefs: []
  type: TYPE_NORMAL
- en: By indicating that this actor should replicate, we've now told the server to
    send the spawned object to all of the connected clients as well. You may have
    noticed as you were testing that you're able to see the other player's location
    represented as a gray sphere floating through space. This is because the default
    pawn class we're currently using is set to replicate as well. (If you're interested
    in seeing this in the source code, open `<Your Engine Install location|\Engine\Source\Runtime\Engine\Private\DefaultPawn.cpp`,
    and you'll see that `bReplicates` is set to true in the constructor.)
  prefs: []
  type: TYPE_NORMAL
- en: Replicating a variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take this a step further and imagine that this point light we put on our
    flag is meaningful to our game. If that's the case, we need to be sure that only
    the server changes its value, and that all clients can see what that value is.
    That means that we need to ensure that we have authority before we change it,
    and then we need to replicate that change down to the connected clients.
  prefs: []
  type: TYPE_NORMAL
- en: Open the flag's blueprint and in the Variables section, and add a Boolean variable
    named `bFlagActive`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile and save your blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the event graph, on Event BeginPlay, add a Switch Has Authority node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Authority execution line, *Alt* + drag a setter for `bFlagActive` and
    set it to False.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Set Timer by Event node and connect it to your `bFlagActive` setter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Time to 3.0 and its Looping property to True.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Custom Event and name it `ToggleFlagState`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the red connector (this is called an **Event Delegate** by the way)
    from your timer to your custom event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Alt* + drag another setter for `bFlagActive` on to the graph and connect it
    to your ToggleFlagState event.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Ctrl* + drag a getter for `bFlagActive` on to the graph.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a Not Boolean node from its output and connect its result to the setter''s
    input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c41f139f-e9ff-4481-a22c-d948fdf83eab.png)'
  prefs: []
  type: TYPE_IMG
- en: What we've just done here is, if we're on the server, initialize the `bFlagActive`
    variable, and then set up a looping timer that flips its value to the opposite
    value every three seconds.
  prefs: []
  type: TYPE_NORMAL
- en: You have two Set Timer event types available to you. You can set timers to call
    functions by name when they trigger, or to call events. If you're working in the
    event graph, it's often more readable to connect an event directly to the timer's
    delegate connector. If you're working inside a function, where events are not
    available to you, call a function by name instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to give ourselves a way to see the flag changing state:'
  prefs: []
  type: TYPE_NORMAL
- en: Find or create the Event Tick node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a reference to your point light on to the graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Set Intensity node and call it on the point light.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Ctrl* + drag a getter for your `bFlagActive` variable on to the graph.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag out its result and create a Select node from it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the Select node's Return Value to the Set Intensity node's New Intensity
    input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the Select node''s False value to 0.0 and its True value to 5000.0:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c1f7bb7c-ff3e-458d-b3d8-8f7d7893dbbc.png)'
  prefs: []
  type: TYPE_IMG
- en: As you may recall, we're not fans of polling values on the tick event. It's
    a wasteful and generally sloppy technique. Don't worry—we're going to set up a
    better way to do this in just a moment.
  prefs: []
  type: TYPE_NORMAL
- en: In the meantime, though, let's test it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see our light turning on and off on the server, but not on the client.
    You may be able to guess now why this is. Because of our authority check, we''re
    only changing the value of `bFlagActive` on the server, and we''re never telling
    any of the clients about this change. Fixing this is fairly straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the `bFlagActive` variable and, in its Details section, set Variable
    | Replication to Replicated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/42d06f05-4aa6-46f1-a84f-ff9b4cf9391c.png)'
  prefs: []
  type: TYPE_IMG
- en: Run your test again. Now, you should see the flag's state changing on the client
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: This brings up an important point. Just because an actor is replicated doesn't
    mean that any of its properties, other than their initial states, are replicated.
    Again, this is deliberate. You don't want to send anything over the network that
    you don't need to send. Every bit of traffic adds to the bandwidth load and adds
    to the cost of adding additional players. Unreal by default replicates only what
    you tell it to replicate.
  prefs: []
  type: TYPE_NORMAL
- en: Notifying clients that a value has changed using RepNotify
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we mentioned a moment ago that polling values on the tick is wasteful,
    since it performs an operation on every update even if there's no need to do it.
    It's nearly always a better idea to respond to events.
  prefs: []
  type: TYPE_NORMAL
- en: 'As it turns out, this is easy to do with replicated variables:'
  prefs: []
  type: TYPE_NORMAL
- en: Select your `bFlagActive` variable and, in its Details | Variable block, set
    its Replication property to RepNotify instead of Replicated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take a look at your Functions list. A new function was just automatically added,
    called `OnRep_bFlagActive`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take everything you had on your Event Tick, select it, and *Ctrl* + *X* to cut
    it out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open up your new `OnRep_bFlagActive` function and paste everything into it,
    connecting the function''s execution line to your Set Intensity node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1f0af24f-0589-4ebf-9226-158c699bbf70.png)'
  prefs: []
  type: TYPE_IMG
- en: This is a more efficient way to respond to changes in the value. The `OnRep`
    function for a variable with its replication set to RepNotify will be called automatically
    every time that variable receives a new value from the server. This makes it easy
    and efficient to respond to those changes, and if we wanted to trigger an effect
    such as a particle system or perform some other operation when a new value arrived
    through replication, we now have a natural place to do this.
  prefs: []
  type: TYPE_NORMAL
- en: If you need something to happen when a new value arrives on a client through
    replication, use RepNotify to create an OnRep function, and do the operation there.
  prefs: []
  type: TYPE_NORMAL
- en: The example we've built so far is fairly simple, but it actually illustrates
    a number of very important points. We've talked a bit about where objects live
    in the network framework, how to determine whether an action takes place on a
    network authority (server), or on a remote (client) session, how to determine
    whether an actor replicates from a server to clients, and how to replicate new
    values to clients and respond to their changes. Now, let's take things a step
    further and start to build something that looks a bit more like a game.
  prefs: []
  type: TYPE_NORMAL
- en: Creating network-aware pawns for multiplayer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've seen a bit about how information moves from the server to the
    clients, let's explore the ways player actions get communicated from the clients
    back to the server. To get ready for this, we're going to take a shortcut and
    add a pawn that can already perform a few basic actions, and we'll get right to
    the task of making these actions work in a multiplayer setting.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a first-person pawn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re going to set ourselves up by adding the pawn from the First Person template:'
  prefs: []
  type: TYPE_NORMAL
- en: Create or open a project made using the Blueprint | First Person template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Content | FirstPersonBP | Blueprints | FirstPersonCharacter, and migrate
    this character into our working project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we need to tell our game mode to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Open BP_MultiplayerGameMode, and set its Default Pawn Class to the FirstPersonCharacter
    we just migrated in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's test it. We should see a number of problems here. Our projectiles are
    bouncing off invisible walls. When players fire, we can't see it happen from the
    other machine. The other player's representation just appears as a first-person
    weapon. We'll fix all of these.
  prefs: []
  type: TYPE_NORMAL
- en: Setting collision response presets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s fix the collision problem. While it isn''t directly network-related,
    it''s distracting and not hard to correct:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select one of the blocking volumes that''s blocking our projectiles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bdb8364d-fb07-406d-ac9a-78eeb4e340f3.png)'
  prefs: []
  type: TYPE_IMG
- en: Take a look at its Details | Collision | Collision Presets to see what collision
    preset it's using.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can see that it's using the Invisible Wall preset. Probably, this preset
    is blocking a lot of things we don't want it to block. For our game, we really
    only want to stop pawns.
  prefs: []
  type: TYPE_NORMAL
- en: Open Settings | Project Settings | Collision, and expand the Preset section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find the Invisible Wall preset, and hit the Edit button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/65cc6b46-f25e-47f6-a57a-cd92dd0a40e3.png)'
  prefs: []
  type: TYPE_IMG
- en: Here we've found and selected the InvisibleWall collision preset from the Engine
    | Collision | Preset list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sure enough, we can see that it''s blocking everything except visibility. Let''s
    change this. Set it to ignore everything except the Pawn in the Trace Type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c16e2a3-7b5d-42db-b2b3-1ee27e9925ca.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We also need to make a change to our projectile:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `Content/FirstPersonBP/Blueprints/FirstPersonProjectile`, and select its
    `CollisionComponent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under Details | Collision, set its Collision Presets property to OverlapAllDynamic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will be good enough for now. The walls no longer block anything but pawns,
    and the projectiles no longer attempt to bounce off objects in the world.
  prefs: []
  type: TYPE_NORMAL
- en: With this out of the way, let's get back to setting up our networking.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a third-person character mesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing we want to do is get our remote pawn using a proper third-person
    mesh. Let''s add the content we''re going to need for this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From your Content Browser, hit Add New | Add Feature or Content Pack..., and
    select Blueprint Feature | Third Person:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c5da0440-bd3d-4a25-a3fb-06781f14e365.png)'
  prefs: []
  type: TYPE_IMG
- en: Here we're adding the Third Person content pack to our project.
  prefs: []
  type: TYPE_NORMAL
- en: Add it to your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we''re going to modify our pawn to use the third-person mesh:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your FirstPersonCharacter blueprint, and hit Add Component | Skeletal Mesh.
    Make sure the actor or its CapsuleComponent is selected so this new component
    is created as a child of the CapsuleComponent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new component `ThirdPerson`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Details | Mesh | Skeletal Mesh to the SK_Mannequin mesh that just arrived
    with our third-person content.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Details | Animation | Anim Class to use the ThirdPerson_AnimBP_C animation
    blueprint from our third-person pack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Adjust its position so it lines up appropriately with the capsule (setting
    its Location Z value to -90.0 and its Rotation Z (Yaw) value to -90.0 works well
    enough):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a03fc764-8494-4adb-abef-27e2685bcf38.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we run it right now, we''ll see that the third-person mesh is blocking our
    camera view. We want to display this mesh for other players, but hide it for ourselves:'
  prefs: []
  type: TYPE_NORMAL
- en: Jump over to the Event Graph of FirstPersonCharacter and find its Event BeginPlay node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the Event BeginPlay node out a bit to give yourself some room to work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click and add an Is Locally Controlled node to the graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Branch from your Is Locally Controlled node, and connect execution
    output of Begin Play to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a reference to the `ThirdPerson` component on to your graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call Set Hidden in Game on it, with New Hidden set to true.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute this Set Hidden in Game call from the Branch node's True output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect execution output of Set Hidden in Game to the Branch node that Event
    BeginPlay used to feed into.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect your Is Locally Controlled branch's `False` output to the Is Head Mounted
    Display Enabled branch's input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In an instance such as this, it's a good idea to double-click your execution
    lines to create reroute nodes to avoid crossing under other nodes, and to make
    it clear where the conditional part of an execution begins and ends. This has
    no effect on the behavior of the blueprint, but it can improve its readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your graph should now look something like this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eaa574f9-dd5d-4795-bfc0-51e015af9e77.png)'
  prefs: []
  type: TYPE_IMG
- en: Checking whether an actor is locally controlled is a thing you'll do often in
    network development. In a single-player environment, of course, this isn't a consideration,
    everything is locally-controlled, but once you're dealing with objects that are
    arriving through replication, it can often be the case that you'll want to treat
    them differently if they belong to someone else.
  prefs: []
  type: TYPE_NORMAL
- en: You can also achieve this by setting the ThirdPerson component's Details | Rendering
    | Owner No See setting to True. This flag, and its companion, Only Owner See,
    can also be used to make certain things visible only to owners or invisible to
    them. You'll have to expand the Advanced area of the Rendering options to see
    it. For this example, we chose to use the Is Locally Controlled check because
    there are so many other cases in which it will be used, but it's worth it to know
    that these shortcuts exist.
  prefs: []
  type: TYPE_NORMAL
- en: Let's run it again, and you'll now see the third-person mesh for the remote
    character, and the first-person mesh for the locally-controlled character.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting the third-person weapon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The weapon is in a strange place for the third-person character. Let''s fix
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `Content/Mannequin/Character/Mesh/UE4_Mannequin_Skeleton` and find the
    hand_r bone in the skeleton tree.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click the bone and select Add Socket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/02be199f-0f1c-42b6-a391-0f071141bfa3.png)'
  prefs: []
  type: TYPE_IMG
- en: Right click the hand_r bone and select Add Socket here.
  prefs: []
  type: TYPE_NORMAL
- en: Name the new socket `Weapon`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the socket and select Add Preview Asset, and select SK_FPGun as
    the preview.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the socket until the weapon appears to be lined up properly with the hand.
    (Setting Relative Location to X=-12.5, Y=5.8, Z=0.2, and setting the Relative
    Rotation Z (Yaw) value to 80.0 seems to work well enough.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we need to attach the weapon to the socket we just made, but only for
    remote players:'
  prefs: []
  type: TYPE_NORMAL
- en: Jump back to our event graph of FirstPersonCharacter and find the Event BeginPlay
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Is Locally Controlled branch's False output, connect an AttachToComponent
    (FP_Gun) node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We've seen this before, but again, as a reminder, there are two versions of
    AttachToComponent—one works on actors, while the other works on components. Select
    the one that's bound to your FP_Gun component.
  prefs: []
  type: TYPE_NORMAL
- en: Drag your third-person component into the AttachToComponent node's parent input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the name of the socket you created on your skeleton in Socket Name. (Weapon):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/71fd75ae-93e1-4f7f-86a7-63ddf67caeae.png)'
  prefs: []
  type: TYPE_IMG
- en: Run it again. The weapon should now be more reasonably-placed. It's not aiming
    where the other player is aiming because we haven't added anything to the third-person
    animation blueprint to handle this. Adding this capability falls outside the scope
    of this chapter, since it really takes us out of networking, so for the purposes
    of our game here, we're going to leave this as it is.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing we need to do is make sure that when a player fires their weapon,
    the server handles the shot, and replicates it to the other clients.
  prefs: []
  type: TYPE_NORMAL
- en: Replicating player actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we saw earlier, in the current build players can''t see it when other players
    fire their weapons. We''ll begin simply enough, by making sure projectiles replicate
    from the server to the clients when they''re spawned:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up the FirstPersonProjectile blueprint, and in its Details | Replication
    section, set Replicates to true.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run it now, and you'll see that if you fire the weapon on the server, the client
    can see the projectiles, but if you fire the weapon on the client, the server
    doesn't see it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a moment to form a clear mental picture of why this is. Replication goes
    one way: from the server to the client. When we spawned the flag on the server
    in our earlier example, we saw it on the client because we''d told the server
    to replicate it. The same thing is now happening with the projectiles. So, the
    question, then, is how does a client tell the server that it needs to spawn a
    projectile?'
  prefs: []
  type: TYPE_NORMAL
- en: Using remote procedure calls to talk to the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The answer comes through a process called a **remote procedure** (**RPC**).
    A remote procedure call is a call made from one system that's intended to run
    on another system. In our case, when we want to fire the weapon, we'll have the
    client make an RPC to the server telling it that we want to fire, and the server
    will handle actually firing the weapon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change our pawn''s firing method to use an RPC:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your FirstPersonCharacter blueprint's Event Graph, and look for InputAction
    Fire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Somewhere nearby, create a custom event. Call it `ServerFire`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the custom event''s Details, set its Graph | Replicates value to Run on
    Server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bcbc04ea-e48b-4f85-ac3e-876bacd2560c.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's get ready to use this call. The first thing we're going to want to
    do with our weapon firing is separate those things that are gameplay-relevant
    and should be run on the server, and those things that are purely cosmetic and
    can be run on the client.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create an additional Custom Event to handle the non-essential client stuff.
  prefs: []
  type: TYPE_NORMAL
- en: Create a Custom Event and call it `SimulateWeaponFire`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unreal developers commonly follow a naming convention whereby non-essential
    cosmetic aspects of a network action are named with the prefix *simulate*. This
    indicates to the reader that this function is safe to run on the client and contains
    only non-state-changing actions (sounds, animations, particles, those sorts of
    things). It also indicates to the reader that the function in question is safe
    to skip on a dedicated server.
  prefs: []
  type: TYPE_NORMAL
- en: Grab the Play Sound at Location call and the GetActorLocation call feeding it,
    disconnect them from the SpawnActor FirstPersonProjectile node, and connect them
    to your new SimulateWeaponFire event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get rid of the Branch feeding from the InputTouch node's FingerIndex. There's
    no execution line going into it, which means it's not doing anything. This is
    just clutter; someone didn't bother to clean out the graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The partially-updated graph should look something like this, so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/968a95f1-17e2-438b-8a56-f45f94990b8f.png)'
  prefs: []
  type: TYPE_IMG
- en: The Spawn Projectile method from the Third Person content pack we migrated into
    our project
  prefs: []
  type: TYPE_NORMAL
- en: Now, grab that Montage Play call, disconnect it from the execution line it's
    currently in, and put it on to the SimulateWeaponFire execution line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What we've done now has been to take everything that's purely decorative and
    move it to its own event that can be called separately.
  prefs: []
  type: TYPE_NORMAL
- en: This is a good convention to follow even when you're developing a single-player
    application because it makes it easy to see which chunks of code are actually
    changing things and which ones are cosmetic. It's a worthwhile practice to get
    into the habit of keeping them separate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve created our `SimulateWeaponFire` event and populated it, we''ll
    make sure it gets called on any system that receives the input:'
  prefs: []
  type: TYPE_NORMAL
- en: Now, put a call to SimulateWeaponFire where the Montage Play node used to be,
    so it will get called any time this input event gets heard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Switch Has Authority node right after the Simulate Weapon Fire call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the Switch node's Authority output to the SpawnActor First Person Projectile
    call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From its Remote branch, make a call to the ServerFire node we created earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Feed the ServerFire node's execution output into the SpawnActor First Person
    Projectile node's input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your SpawnProjectile graph should now look something like this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/669f3201-9fd6-4ccc-b1a4-2f10c8ee7dc7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And, the SimulateWeaponFire graph should look like this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe474686-8ce1-4b2c-ad2d-49d46918dd35.png)'
  prefs: []
  type: TYPE_IMG
- en: Try it out. Aiming is going to be incorrect for clients because we're not doing
    anything to send the client's weapon aiming to the server, but you should now
    see the projectile spawning and hear the fire sound in both directions.
  prefs: []
  type: TYPE_NORMAL
- en: Let's improve this.
  prefs: []
  type: TYPE_NORMAL
- en: 'At present, the projectile''s spawn rotation is coming from the first-person
    camera. This isn''t going to work when communicating from the client to the server,
    because the server doesn''t know anything about that camera. Let''s replace this
    with a value the server does know about:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click in the graph to create a Get Base Aim Rotation node, and feed it
    into the Make Transform node, replacing the input from the camera''s GetWorldRotation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/4d1d9cba-f4d0-42e4-8326-5e29c02b5ea6.png)'
  prefs: []
  type: TYPE_IMG
- en: Test it again. The origin for the client's projectile when seen on the server
    is still going to be incorrect, but the aim rotation is now correct. (Fixing the
    origin would really require us to build a proper third-person animation blueprint,
    which takes us beyond the scope of this chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: Let's talk about how this is working so far. There's an important pattern embedded
    here that's worth internalizing.
  prefs: []
  type: TYPE_NORMAL
- en: When the fire input event arrives, we check to see whether we have authority
    to spawn the particle. If we do, we just go ahead and spawn it. If we don't, however,
    we make a remote procedure call to the server to tell it to spawn it. It does,
    and then we see it here on our local client because it's been replicated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most gameplay events in multiplayer games will be written according to this
    pattern. Here''s a simplified example for clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d87eab2b-5b83-4d35-a459-81372f832fed.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, the Do the thing call will only ever run on the
    server. If the event that triggers it is happening on the server, it just runs,
    and if the event is happening on a client, the client calls the Server Do the
    Thing RPC, which then handles calling Do the Thing. This pattern is worth committing
    to memory. You'll use it a lot.
  prefs: []
  type: TYPE_NORMAL
- en: There's a common convention among Unreal developers whereby we prefix the names
    of the RPCs that run on the server with the prefix *Server*. You don't have to
    do this, but it's a good idea, and Unreal developers will cast disapproving glances
    your way if you don't. It makes it much easier to see which functions are RPCs
    and which ones run locally.
  prefs: []
  type: TYPE_NORMAL
- en: Using multicast RPCs to communicate to clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There''s another problem with what we''ve written that will be difficult to
    detect if you''re testing on a single machine: the simulated sounds and animations
    only play on the owning client. If we were playing on two separate machines and
    the other player fired near us, we wouldn''t hear it.'
  prefs: []
  type: TYPE_NORMAL
- en: Why not?
  prefs: []
  type: TYPE_NORMAL
- en: In the previous screenshot, when the input event is received on the local client,
    it calls the `Simulate` method to play the sound and animation, and then checks
    to see whether it has authority to decide whether to spawn the projectile itself
    or ask the server to handle it. But, what if there's another player standing nearby?
  prefs: []
  type: TYPE_NORMAL
- en: Player A's client will send the RPC to the server to spawn the projectile, so
    everybody's going to see that, but the call to simulate the firing event only
    ever happened on player A's machine. The representation of player A's pawn over
    on player B's machine (we call this representation a *remote proxy*) was never
    told to play the animation, so it doesn't.
  prefs: []
  type: TYPE_NORMAL
- en: We can solve this using another type of RPC, called a **multicast event**.
  prefs: []
  type: TYPE_NORMAL
- en: You'll often hear developers referring to multicast events as **net multicast** events,
    or as **broadcast** events. These terms refer to the same thing. By convention,
    just as server RPC event names are prefixed with *server*, multicast events are
    often named with *broadcast* as a prefix. This is a less-commonly-followed convention
    than the *server* prefix and you don't have to do it, but you'll have an easier
    time following your blueprints later on if you make this a habit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we''ve already abstracted our simulate methods to their own event, this
    isn''t hard to do:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select your SimulateWeaponFire event, and in its Details | Graph, set its Replicates
    property to Multicast:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/74351ba0-a09d-498b-ab14-2a1f8273d3e1.png)'
  prefs: []
  type: TYPE_IMG
- en: What this will do is send this event to the server and instruct it to send it
    down to all connected clients.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when Player A fires, the call to spawn the projectile will happen only
    on the server, but the call to play the fire sound and animation will happen on
    every representation of player A's pawn across the network.
  prefs: []
  type: TYPE_NORMAL
- en: If you'd like, you can rename your `SimulateWeaponFire` event `BroadcastSimulateWeaponFire`.
    Some developers follow this convention, others don't. In general, though, the
    more information you give yourself and other developers about what you're doing,
    the easier a time you or they are going to have debugging or maintaining your
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Client RPCs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's one more type of RPC, which we're not going to demonstrate here, but
    that we should discuss for the sake of completeness. Let's say you were running
    an operation on the server and you needed to make a call specifically to the client
    that owns the object you were operating on. You can do this by setting the event
    to Run on owning Client.
  prefs: []
  type: TYPE_NORMAL
- en: Reliable RPCs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's one final determination we have to make when we're deciding how to replicate
    a function call, and that's whether to make the call reliable.
  prefs: []
  type: TYPE_NORMAL
- en: To understand what this flag means, we need to understand something critical
    about networking. The internet is an unreliable thing. Just because you send an
    RPC to someone on the other side of the globe, there's absolutely no guarantee
    that it will get there. Packets get lost all the time. That's not an unreal thing;
    it's a reality-of-the-world thing. The choice you need to make as a developer
    is what to do about this.
  prefs: []
  type: TYPE_NORMAL
- en: If an RPC is important to the game, such as firing a weapon, make it reliable.
    What this will do is instruct the network interface to re-send it until it receives
    confirmation from the other system that the call was received. This adds traffic
    to your network, however, so do it only for those calls you care about. If you're
    just broadcasting a cosmetic call, such as a weapon sound, leave it unreliable,
    since your game isn't going to break if it doesn't arrive. The call to fire the
    weapon, however, should be reliable, since it matters to the player and to the
    game whether it happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make this change now:'
  prefs: []
  type: TYPE_NORMAL
- en: Find your ServerFire custom event, and in its Details | Graph, set its Reliable
    property to true.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave your BroadcastSimulateWeaponFire event unreliable, because it's just playing
    cosmetic events that aren't important enough to be worth clogging the network.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Going further
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Networking is a substantial topic, and, to be honest, we've only scratched the
    surface here. Our purpose in writing this has been to give you a solid mental
    model from which you can understand what Unreal's network framework looks like,
    and what sorts of things you need to understand to work within it.
  prefs: []
  type: TYPE_NORMAL
- en: This is heady stuff, and it can get fairly confusing to new developers. The
    trick to network development is to create a clear mental model of what's going
    on. Take your time to understand these concepts, and you'll have a much easier
    time.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few topics we didn't cover here, such as hosting sessions and making
    it possible for others to join them, and quite a lot of the finer points of how
    networking works, such as relevance. These things are worth understanding, and
    there are a few good resources available to you to take your understanding further.
  prefs: []
  type: TYPE_NORMAL
- en: First, check out the Network Examples map in your Content Examples project,
    and take some time to understand what they're showing. Next, Cedric Neukirchen's
    *Multiplayer Network Compendium*, [http://cedric-neukirchen.net/2017/02/14/multiplayer-network-compendium/](http://cedric-neukirchen.net/2017/02/14/multiplayer-network-compendium/), is
    an outstanding resource for learning how Unreal's networking framework works.
    Unreal's documentation lives here: [https://docs.unrealengine.com/en-us/Gameplay/Networking](https://docs.unrealengine.com/en-us/Gameplay/Networking),
    and it's absolutely worthwhile to spend some time picking through its Multiplayer
    Shootout project in light of what you've learned here.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter involved a bit more theory than other chapters have, and it's entirely
    fine if a good chunk of it is still sinking in.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we talked a fair bit about Unreal's client-server architecture,
    and which objects live in which domains. It's important to get a good working
    knowledge of this structure in place. We also learned a bit about how information
    and events move between machines via replication and remote procedure calls.
  prefs: []
  type: TYPE_NORMAL
- en: It's our hope that this chapter has given you a good foundation on which to
    stand as you dig into networking and really explore how it works. Be patient with
    yourself and take time to experiment.
  prefs: []
  type: TYPE_NORMAL
- en: We've now reached the point where we've covered a huge range of things you need
    to know to develop VR using Unreal Engine. Next, we're going to take a look at
    a few tools and plugins that can greatly accelerate your work in VR. With what
    you've learned so far in this book, you should be ready to dig through them and
    understand how they can help you develop and save you substantial amounts of time.
  prefs: []
  type: TYPE_NORMAL
