- en: Chapter 4. Requirement Specification for a Modular Web Shop App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a software application from the ground up requires diverse skills,
    as it involves more than just writing down a code. Writing down functional requirements
    and sketching out a wireframe are often among the first steps in the process,
    especially if we are working on a client project. These steps are usually done
    by someone other than the developer, as they require certain insight into client
    business case, user behavior, and the like. Being part of a larger development
    team means that we, as developers, usually get requirements, designs, and wireframes
    then start coding against them. Delivering projects by oneself, makes it tempting
    to skip these steps and get our hands started with code alone. More often than
    not, this is an unproductive approach. Laying down functional requirements and
    a few wireframes is a skill worth knowing and following, even if one is just a
    developer.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, we will go over a high-level application requirement,
    alongside a rough wireframe.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining application requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wireframing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Defining technology stack:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Symfony framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Foundation framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining application requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to build a simple, but responsive web shop application. In order to
    do so, we need to lay out some basic requirements. The types of requirements we
    are interested in at the moment are those that touch upon interactions between
    a user and a system. The two most common techniques to specify requirements in
    regards to user usage are use case and user story. The user stories are a less
    formal yet descriptive enough way to outline these requirements. Using user stories,
    we encapsulate the customer and store manager actions as mentioned here.
  prefs: []
  type: TYPE_NORMAL
- en: 'A customer should be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Browse through static info pages (about us, customer service)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reach out to the store owner via a contact form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Browse the shop categories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See product details (price, description)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the product image with a large view (zoom)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See items on sale
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See best sellers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the product to the shopping cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a customer account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update customer account info
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieve a lost password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check out
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the total order cost
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose among several payment methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose among several shipment methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get an email notification after an order has been placed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check order status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cancel an order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See order history
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A store manager should be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a product (with the minimum following attributes: `title`, `price`,
    `sku`, `url-key`, `description`, `qty`, `category`, and `image`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upload a picture of the product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update and delete a product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a category (with the minimum following attributes: `title`, `url-key`,
    `description`, and `image`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upload a picture to a category
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update and delete a category
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be notified if a new sales order has been created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be notified if a new sales order has been canceled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See existing sales orders by their statuses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the status of the order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disable a customer account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete a customer account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User stories are a convenient high-level way of writing down application requirements.
    Especially useful as an agile mode of development.
  prefs: []
  type: TYPE_NORMAL
- en: Wireframing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With user stories laid out, let's shift our focus to actual wireframing. For
    reasons we will get into later on, our wireframing efforts will be focused around
    the customer perspective.
  prefs: []
  type: TYPE_NORMAL
- en: There are numerous wireframing tools out there, both free and commercial. Some
    commercial tools like [https://ninjamock.com](https://ninjamock.com), which we
    will use for our examples, still provide a free plan. This can be very handy for
    personal projects, as it saves us a lot of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The starting point of every web application is its home page. The following
    wireframe illustrates our web shop app''s homepage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wireframing](graphics/B05460_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we can see a few sections determining the page structure. The header is
    comprised of a logo, category menu, and user menu. The requirements don't say
    anything about category structure, and we are building a simple web shop app,
    so we are going to stick to a flat category structure, without any sub-categories.
    The user menu will initially show **Register** and **Login** links, until the
    user is actually logged in, in which case the menu will change as shown in following
    wireframes. The content area is filled with best sellers and on sale items, each
    of which have an image, title, price, and **Add to Cart** button defined. The
    footer area contains links to mostly static content pages, and a **Contact Us**
    page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following wireframe illustrates our web shop app''s category page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wireframing](graphics/B05460_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The header and footer areas remain conceptually the same across the entire site.
    The content area has now changed to list products within any given category. Individual
    product areas are rendered in the same manner as it is on the home page. Category
    names and images are rendered above the product list. The width of a category
    image gives some hints as to what type of images we should be preparing and uploading
    onto our categories.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following wireframe illustrates our web shop app''s product page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wireframing](graphics/B05460_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The content area here now changes to list individual product information. We
    can see a large image placeholder, title, sku, stock status, price, quantity field,
    **Add to Cart** button, and product description being rendered. The **IN STOCK**
    message is to be displayed when an item is available for purchase and **OUT OF
    STOCK** when an item is no longer available. This is to be related to the product
    quantity attribute. We also need to keep in mind the "See the product image with
    a big view (zoom)" requirement, where clicking on an image would zoom into it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following wireframe illustrates our web shop app''s register page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wireframing](graphics/B05460_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The content area here now changes to render a registration form. There are many
    ways that we can implement the registration system. More often than not, the minimal
    amount of information is asked on a registration screen, as we want to get the
    user in as quickly as possible. However, let's proceed as if we are trying to
    get more complete user information right here on the registration screen. We ask
    not just for an e-mail and password, but for entire address information as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following wireframe illustrates our web shop app''s login page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wireframing](graphics/B05460_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The content area here now changes to render a customer login and forgotten password
    form. We provide the user with **Email** and **Password** fields in case of login,
    or just an **Email** field in case of a password reset action.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following wireframe illustrates our web shop app''s customer account page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wireframing](graphics/B05460_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The content area here now changes to render the customer account area, visible
    only to logged in customers. Here we see a screen with two main pieces of information.
    The customer information being one, and order history being the other. The customer
    can change their e-mail, password, and other address information from this screen.
    Furthermore, the customer can view, cancel, and print all of their previous orders.
    The **My Orders** table lists orders top to bottom, from newest to oldest. Though
    not specified by the user stories, the order cancelation should work only on pending
    orders. This is something that we will touch upon in more detail later on.
  prefs: []
  type: TYPE_NORMAL
- en: This is also the first screen that shows the state of the user menu when the
    user is logged in. We can see a dropdown showing the user's full name, **My Account**,
    and **Sign Out** links. Right next to it, we have the **Cart (%s)** link, which
    is to list exact quantities in a cart.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following wireframe illustrates our web shop app''s checkout cart page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wireframing](graphics/B05460_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The content area here now changes to render the cart in its current state. If
    the customer has added any products to the cart, they are to be listed here. Each
    item should list the product title, individual price, quantity added, and subtotal.
    The customer should be able to change quantities and press the **Update Cart**
    button to update the state of the cart. If `0` is provided as the quantity, clicking
    the **Update Cart** button will remove such an item from the cart. Cart quantities
    should at all time reflect the state of the header menu **Cart (%s)** link. The
    right-hand side of a screen shows a quick summary of current order total value,
    alongside a big, clear **Go to Checkout** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following wireframe illustrates our web shop app''s checkout cart shipping
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wireframing](graphics/B05460_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The content area here now changes to render the first step of a checkout process,
    the shipping information collection. This screen should not be accessible for
    non-logged in customers. The customer can provide us with their address details
    here, alongside a shipping method selection. The shipping method area lists several
    shipping methods. On the right hand side, the collapsible order summary section
    is shown, listing current items in the cart. Below it, we have the cart subtotal
    value and a big clear **Next** button. The **Next** button should trigger only
    when all of the required information is provided, in which case it should take
    us to payment information on the checkout cart payment page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following wireframe illustrates our web shop app''s checkout cart payment
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wireframing](graphics/B05460_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The content area here now changes to render the second step of a checkout process,
    the payment information collection. This screen should not be accessible for non-logged
    in customers. The customer is presented with a list of available payment methods.
    For the simplicity of the application, we will focus only on flat/fixed payments,
    nothing robust such as PayPal or Stripe. On the right-hand side of the screen,
    we can see a collapsible **Order summary** section, listing current items in the
    cart. Below it, we have the order totals section, individually listing **Cart
    Subtotal**, **Standard Delivery**, **Order Total**, and a big clear **Place Order**
    button. The **Place Order** button should trigger only when all of the required
    information is provided, in which case it should take us to the checkout success
    page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following wireframe illustrates our web shop app''s checkout success page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wireframing](graphics/B05460_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The content area here now changes to output the checkout successful message.
    Clearly this page is only visible to logged in customers that just finished the
    checkout process. The order number is clickable and links to the **My Account**
    area, focusing on the exact order. By reaching this screen, both the customer
    and store manager should receive a notification email, as per the *Get email notification
    after order has been placed* and *Be notified if the new sales order has been
    created* requirements.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we conclude our customer facing wireframes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In regards to store manager user story requirements, we will simply define
    a landing administration interface for now, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wireframing](graphics/B05460_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using the framework later on, we will get a complete auto-generated CRUD interface
    for the multiple **Add New** and **List & Manage** links. The access to this interface
    and its links will be controlled by the framework's security component, since
    this user will not be a customer or any user in the database as such.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, throughout the following chapters, we will split our application
    into several modules. In such a setup, each module will take ownership of individual
    functionalities, taking care of customer, catalog, checkout, and other requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a technology stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the requirements and wireframes are set, we can focus our attention to
    the selection of a technology stack. In [Chapter 1](ch01.html "Chapter 1. Ecosystem
    Overview"), *Ecosystem Overview* we glossed over several of the most popular PHP
    frameworks, pointing out their strengths. Choosing the right one in this case,
    is more of a matter of preference, as application requirements for the most part
    can be easily met by be met any one of those frameworks. Our choice, however,
    falls to Symfony. Aside from PHP frameworks, we still need a CSS framework to
    deliver some structure, styling, and responsiveness within the browser on the
    client side. Since the focus of this book is on PHP technologies, let's just say
    we chose the Foundation CSS framework for that task.
  prefs: []
  type: TYPE_NORMAL
- en: The Symfony framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Symfony framework makes a nice choice for our application. It is an enterprise
    level framework that has been around for years, and is extremely well documented
    and supported. It can be downloaded from the official [http://symfony.com](http://symfony.com)
    page as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Symfony framework](graphics/B05460_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The benefits of using Symfony as part of our technology stack are numerous.
    The framework provides robust and well documented:'
  prefs: []
  type: TYPE_NORMAL
- en: Controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ORM (via Doctrine)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are essential features required by our application. The ORM in particular,
    plays a major role in rapid application development. Having to worry less about
    coding, every aspect of CRUD can boost the speed of development by a factor or
    two. The great thing about Symfony in this regard is that it allows for automatic
    generation of entities and CRUD actions around them by executing two simple commands
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'By doing so, Symfony generates entity models and necessary controllers that
    empower us to perform the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: List all records
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Show one given record identified by its primary key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a new record
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edit an existing record
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete an existing record
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basically, we get a minimal store manager interface for free. This alone covers
    most of the CRUD related requirements set for the store manager role. We can then
    easily modify the generated templates to further integrate the remaining functionality.
  prefs: []
  type: TYPE_NORMAL
- en: On top of that, security components provide authentication and authorization
    that we can use to satisfy the customer and store manager logins. So a store manager
    will be a fixed, pre-created user attached to Symfony's firewall, the only one
    having access to CRUD controller actions.
  prefs: []
  type: TYPE_NORMAL
- en: Foundation framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Backed by the company Zurb, the Foundation framework makes a great choice for
    a modern responsive web application. We might say it is an enterprise level framework,
    providing a collection of HTML, CSS, and JavaScript that we can build upon. It
    can be downloaded from the official [http://foundation.zurb.com](http://foundation.zurb.com
    ) page as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Foundation framework](graphics/B05460_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Foundation comes in three flavors:'
  prefs: []
  type: TYPE_NORMAL
- en: Foundation for sites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Foundation for e-mail
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Foundation for apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are interested in the sites version. Aside from general styling, Foundation
    for sites provides a great deal of controls, navigational elements, containers,
    media elements, and plugins. These will be particularly useful in our application,
    for things like header menus, category product listings, responsive cart tables,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Foundation is built as a mobile-first framework, where we code for small screens
    first and larger screens then inherit those styles. Its default 12-column grid
    system enables us to create powerful multi-device layouts quickly and easily.
  prefs: []
  type: TYPE_NORMAL
- en: We will use Foundation simply to provide structure, some basic styling, and
    responsiveness to our application, without writing a single line of CSS on our
    own. This alone should make our application visually pleasing enough to work with
    both on mobile and desktop screens, while still focusing the majority of our coding
    skills around backend things.
  prefs: []
  type: TYPE_NORMAL
- en: Aside from providing robust functionality, the company behind Foundation also
    provides premium technical support. Though we will not need it as part of this
    book, these sorts of things establish confidence when choosing application frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating web applications can be a tedious and time consuming task, web shops
    probably being one of the most robust and intensive type of application out there,
    as they encompass a great deal of features. There are many components involved
    in delivering the final product; from database, server side (PHP) code to client
    side (HTML, CSS, and JavaScript) code. In this chapter, we started off by defining
    some basic user stories which in turn defined high-level application requirements
    for our small web shop. Adding wireframes to the mix helped us to visualize the
    customer facing interface, while the store manager interface is to be provided
    out of the box by the framework.
  prefs: []
  type: TYPE_NORMAL
- en: We further glossed over two of the most popular frameworks that support modular
    application design. We turned our attention to Symfony as server side technology
    and Foundation as a client side responsive framework.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, in the next chapter, we will take a more in-depth look into
    Symfony. As well as being a set of reusable components, Symfony is also one of
    the most robust and popular full-stack PHP frameworks. Therefore, it is an interesting
    choice for rapid web application development.
  prefs: []
  type: TYPE_NORMAL
