- en: '14: Deploying apps with Docker Stacks'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deploying and managing multi-service apps at scale is hard.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Docker Stacks are here to help! They simplify application management
    by providing; *desired state, rolling updates, simple, scaling operations, health
    checks,* and more! All wrapped in a nice declarative model. Love it!
  prefs: []
  type: TYPE_NORMAL
- en: Now then, if these buzzwords are new to you or sound complicated, don’t worry!
    You’ll understand them all by the end of the chapter!
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll split this chapter into the usual three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The TLDR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The deep dive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying apps with Docker Stacks - The TLDR
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Testing and deploying simple apps on your laptop is easy. But that’s for amateurs.
    Deploying and managing multi-service apps, in real-world production environments…
    That’s for pro’s!
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, stacks are here to help!. They let you define complex multi-service
    apps in a single declarative file. They also provide a simple way deploy the app
    and manage its entire lifecycle — initial deployment > health checks > scaling
    > updates > rollbacks and more!
  prefs: []
  type: TYPE_NORMAL
- en: The process is simple. Define your app in a *Compose file*, then deploy and
    manage it with the `docker stack deploy` command. That’s it!
  prefs: []
  type: TYPE_NORMAL
- en: The Compose file includes the entire stack of services that make up the app.
    It also includes all of the volumes, networks, secrets, and other infrastructure
    the app needs. You then use the `docker stack deploy` command to deploy the app
    from the file. Simple.
  prefs: []
  type: TYPE_NORMAL
- en: To accomplish all of this, stacks build on top of Docker Swarm, meaning you
    get all of the security and advanced features that come with Swarm.
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, Docker is great for development and testing. Docker Stacks are
    great for scale and production!
  prefs: []
  type: TYPE_NORMAL
- en: Deploying apps with Docker Stacks - The Deep Dive
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you know Docker Compose, you’ll find Docker Stacks really easy. In fact,
    in many ways, stacks are what we always wished Compose was — fully integrated
    into Docker, and able to manage the entire lifecycle of applications.
  prefs: []
  type: TYPE_NORMAL
- en: Architecturally speaking, stacks are at the top of the Docker application hierarchy.
    They build on top of *services*, which in turn build on top of containers. See
    Figure 14.1.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1 AtSea Shop high level architecture](images/figure14-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.1 AtSea Shop high level architecture
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll divide this section of the chapter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the sample app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking closer at the stack file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying the app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of the sample app
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For the rest of the chapter, we’ll be using the popular **AtSea Shop** demo
    app. It lives on [GitHub](https://github.com/dockersamples/atsea-sample-shop-app)
    and is open-sourced under the [Apache 2.0 license](https://github.com/dockersamples/atsea-sample-shop-app/blob/master/LICENSE).
  prefs: []
  type: TYPE_NORMAL
- en: We’re using this app because it’s moderately complicated without being too big
    to list and describe in a book. Beneath the covers, it’s a multi-technology microservices
    app that leverages certificates and secrets. The high-level application architecture
    is shown in Figure 14.2.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.2 AtSea Shop high level architecture](images/figure14-2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.2 AtSea Shop high level architecture
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, it comprises 5 *Services*, 3 networks, 4 secrets, and 3 port
    mappings. We’ll see each of these in detail when we inspect the stack file.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** When referring to *services* in this chapter, we’re talking about
    Docker Services (a collection of containers managed as a single object and the
    service object that exists in the Docker API).'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Clone the application’s GitHub repo so that you have all of the application
    source files on your local machine.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`The application consists of several directories and source files. Feel free
    to explore them all. However, we’re going to focus on the `docker-stack.yml` file.
    We’ll refer to this as the *stack file*, as this defines the app and its requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: At the highest level, it defines 4 top-level keys.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`**Version** indicates the version of the Compose file format. This has to
    be 3.0 or higher to work with stacks. **Services** is where we define the stack
    of services that make up the app. **Networks** lists the required networks, and
    **secrets** defines the secrets the app uses.'
  prefs: []
  type: TYPE_NORMAL
- en: If we expand each top-level key, we’ll see how things map to Figure 14.1\. The
    stack file has five services called “reverse_proxy”, “database”, “appserver”,
    “visualizer”, and “payment_gateway”. So does Figure 14.1\. The stack file has
    three networks called “front-tier”, “back-tier”, and “payment”. So does Figure
    14.1\. Finally, the stack file has four secrets called “postgres_password”, “staging_token”,
    “revprox_key”, and “revprox_cert”. So does Figure 14.1.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`It’s important to understand that the stack file captures and defines many
    of the requirements of the entire application. As such, it’s a form of application
    self-documentation and a great tool for bridging the gap between dev and ops.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a closer look at each section of the stack file.
  prefs: []
  type: TYPE_NORMAL
- en: Looking closer at the stack file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The stack file is a Docker Compose file. The only requirement is that the `version:`
    key specify a value of “3.0” or higher. See the [the Docker docs](https://docs.docker.com/compose/compose-file/)
    for the latest information on Compose file versions.
  prefs: []
  type: TYPE_NORMAL
- en: One of the first things Docker does when deploying an app from a stack file,
    is check for, and create the networks listed under the `networks:` key. If the
    networks do not already exist, Docker will create them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see the networks defined in the stack file.
  prefs: []
  type: TYPE_NORMAL
- en: Networks
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`Three networks are defined; `front-tier`, `back-tier`, and `payment`. By default,
    they’ll all be created as overlay networks by the `overlay` driver. But the `payment`
    network is special — it requires an encrypted data plane.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the control plane of all overlay networks is encrypted. To encrypt
    the data plane, you have two choices:'
  prefs: []
  type: TYPE_NORMAL
- en: Pass the `-o encrypted` flag to the `docker network create` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Specify `encrypted: ''yes''` under `driver_opts` in the stack file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The overhead incurred by encrypting the data plane depends on various factors
    such traffic type and traffic flow. However, expect it to be in the region of
    10%.
  prefs: []
  type: TYPE_NORMAL
- en: As previously mentioned, all three networks will be created before the secrets
    and services.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at the secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Secrets
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Secrets are defined as top-level objects, and the stack file we’re using defines
    four:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`Notice that all four are defined as `external`. This means that they must
    already exist before the stack can be deployed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s possible for secrets to be created on-demand when the application is deployed
    — just replace `external: true` with `file: <filename>`. However, for this to
    work, a plaintext file containing the unencrypted value of the secret must already
    exist on the host’s filesystem. This has obvious security implications.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll see how to create these secrets when we come to deploy the app. For now,
    it’s enough to know that the application defines four secrets that need pre-creating.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at each of the services.
  prefs: []
  type: TYPE_NORMAL
- en: Services
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Services are where most of the action happens.
  prefs: []
  type: TYPE_NORMAL
- en: Each service is a JSON collection (dictionary) that contains a bunch of keys.
    We’ll step through each one and explain what each of the options does.
  prefs: []
  type: TYPE_NORMAL
- en: The reverse_proxy service
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As we can see, the `reverse_proxy` service defines an image, ports, secrets,
    and networks.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`The image key is the only mandatory key in the service object. As the name
    suggests, it defines the Docker image that will be used to build the replicas
    for the service.'
  prefs: []
  type: TYPE_NORMAL
- en: Docker is opinionated, so unless you specify otherwise, the **image** will be
    pulled from Docker Hub. You can specify images from 3rd-party registries by prepending
    the image name with the DNS name of the registry’s API endpoint such as `gcr.io`
    for Google’s container registry.
  prefs: []
  type: TYPE_NORMAL
- en: One difference between Docker Stacks and Docker Compose, is that stacks do not
    support **builds**. This means all images have to be built prior to deploying
    the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **ports** key defines two mappings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`80:80` maps port 80 on the Swarm to port 80 on each service replica.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`443:443` maps port 443 on the Swarm to port 443 on each service replica.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By default, all ports are mapped using *ingress mode*. This means they’ll be
    mapped and accessible from every node in the Swarm — even nodes not running a
    replica. The alternative is *host mode*, where ports are only mapped on Swarm
    nodes running replicas for the service. However, *host mode* requires you to use
    the long-form syntax. For example, mapping port 80 in *host mode* using the long-form
    syntax would be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`The long-form syntax is recommended, as it’s easier to read and more powerful
    (it supports ingress mode **and** host mode). However, it requires at least version
    3.2 of the Compose file format.'
  prefs: []
  type: TYPE_NORMAL
- en: The **secrets** key defines two secrets — `revprox_cert` and `revprox_key`.
    These must be defined in the top-level `secrets` key, and must exist on the system.
  prefs: []
  type: TYPE_NORMAL
- en: Secrets get mounted into service replicas as a regular file. The name of the
    file will be whatever you specify as the `target` value in the stack file, and
    the file will appear in the replica under `/run/secrets` on Linux, and `C:\ProgramData\Docker\secrets`
    on Windows. Linux mounts `/run/secrets` as an in-memory filesystem, but Windows
    does not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The secrets defined in this service will be mounted in each service replica
    as `/run/secrets/revprox_cert` and `/run/secrets/revprox_key`. To mount one of
    them as `/run/secrets/uber_secret` you would define it in the stack file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`The **networks** key ensures that all replicas for the service will be attached
    to the `front-tier` network. The network specified here must be defined in the
    `networks` top-level key, and if it doesn’t already exist, Docker will create
    it as an overlay.'
  prefs: []
  type: TYPE_NORMAL
- en: The database service
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The database service also defines; an image, a network, and a secret. As well
    as those, it introduces environment variables and placement constraints.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`The **environment** key lets you inject environment variables into services
    replica. This service uses three environment variables to define a database user,
    the location of the database password (a secret mounted into every service replica),
    and the name of the database.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`> **Note:** It would be more secure to pass all three values in as secrets,
    as this would avoid documenting the database name and database user in plaintext
    variables.'
  prefs: []
  type: TYPE_NORMAL
- en: The service also defines a *placement constraint* under the `deploy` key. This
    ensures that replicas for this service will always run on Swarm *worker* nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`Placement constraints are a form of topology-aware scheduling, and can be
    a great way of influencing scheduling decisions. Swarm currently lets you schedule
    against all of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Node ID. `node.id == o2p4kw2uuw2a`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node name. `node.hostname == wrk-12`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Role. `node.role != manager`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Engine labels. `engine.labels.operatingsystem==ubuntu 16.04`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom node labels. `node.labels.zone == prod1`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that `==` and `!=` are both supported.
  prefs: []
  type: TYPE_NORMAL
- en: The appserver service
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `appserver` service uses an image, attaches to three networks, and mounts
    a secret. It also introduces several additional features under the `deploy` key.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`Let’s take a closer look at the new stuff under the `deploy` key.'
  prefs: []
  type: TYPE_NORMAL
- en: First up, `services.appserver.deploy.replicas = 2` will set the desired number
    of replicas for the service to 2\. If omitted, the default value is 1\. If the
    service is running, and you need to change the number of replicas, you should
    do so declaratively. This means updating `services.appserver.deploy.replicas`
    in the stack file with the new value, and then redeploying the stack. We’ll see
    this later, but re-deploying a stack does not affect services that you haven’t
    made a change to.
  prefs: []
  type: TYPE_NORMAL
- en: '`services.appserver.deploy.update_config` tells Docker how to act when rolling-out
    updates to the service. For this service, Docker will update two replicas at-a-time
    (`parallelism`) and will perform a ‘rollback’ if it detects the update is failing.
    Rolling back will start new replicas based on the previous definition of the service.
    The default value for `failure_action` is `pause`, which will stop further replicas
    being updated. The other option is `continue`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`The `services.appserver.deploy.restart-policy` object tells Swarm how to restart
    replicas (containers) if and when they fail. The policy for this service will
    restart a replica if it stops with a non-zero exit code (`condition: on-failure`).
    It will try to restart the failed replica 3 times, and wait up to 120 seconds
    to decide if the restart worked. It will wait 5 seconds between each of the three
    restart attempts.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`###### visualizer'
  prefs: []
  type: TYPE_NORMAL
- en: The visualizer service references an image, maps a port, defines an update config,
    and defines a placement constraint. It also and mounts a volume and defines a
    custom grace period for container stop operations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`When Docker stops a container, it issues a `SIGTERM` to the process with PID
    1 inside the container. The container (its PID 1 process) then has a 10-second
    grace period to perform any clean-up operations. If it doesn’t handle the signal,
    it will be forcibly terminated after 10 seconds with a `SIGKILL`. The `stop_grace_period`
    property overrides this 10 second grace period.'
  prefs: []
  type: TYPE_NORMAL
- en: The `volumes` key is used to mount pre-created volumes and host directories
    into a service replica. In this case, it’s mounting `/var/run/docker.sock` from
    the Docker host, into `/var/run/docker.sock` inside of each service replica. This
    means any reads and writes to `/var/run/docker.sock` in the replica will be passed
    through to the same directory in the host.
  prefs: []
  type: TYPE_NORMAL
- en: '`/var/run/docker.sock` happens to be the IPC socket that the Docker daemon
    exposes all of its API endpoints on. This means giving a container access to it
    allows the container to consume all API endpoints — essentially giving the container
    the ability to query and manage the Docker daemon. In most situations this is
    a huge “No!”. However, this is a demo app in a lab environment.'
  prefs: []
  type: TYPE_NORMAL
- en: The reason this service requires access to the Docker socket is because it provides
    a graphical representation of services on the Swarm. To do this, it needs to be
    able to query the Docker daemon on a manager node. To accomplish this, a placement
    constraint forces all service replicas onto manager nodes, and the Docker socket
    is bind-mounted into each service replica. The *bind mount* is shown in Figure
    14.3.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.3](images/figure14-3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.3
  prefs: []
  type: TYPE_NORMAL
- en: payment_gateway
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `payment_gateway` service specifies an image, mounts a secret, attaches
    to a network, defines a partial deployment strategy, and then imposes a couple
    of placement constraints.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`We’ve seen all of these options before, except for the `node.label` in the
    placement constraint. Node labels are custom-defined labels added to Swarm nodes
    with the `docker node update` command. As such, they’re only applicable within
    the context of the nodes role in the Swarm (you can’t leverage them on standalone
    containers or outside of the Swarm).'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the `payment_gateway` service performs operations that require
    it to run on a Swarm node that has been hardened to PCI DSS standards. To enable
    this, you can apply a custom *node label* to any Swarm node meeting these requirements.
    We’ll do this when we build the lab to deploy the app.
  prefs: []
  type: TYPE_NORMAL
- en: As this service defines two placement constraints, replicas will only be deployed
    to nodes that match both. I.e. a **worker** node with the `pcidss=yes` node label.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’re finished examining the stack file, we should have a good understanding
    of the application’s requirements. As mentioned previously, the stack file is
    a great piece of application documentation. We know that the application has 5
    services, 3 networks, and 4 secrets. We know which services attach to which networks,
    which ports need publishing, which images are required, and we even know that
    some services need to run on specific nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s deploy it.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the app
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a few pre-requisites that need taking care of before we can deploy
    the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Swarm mode:** We’ll deploy the app as a Docker Stack, and stacks require
    Swarm mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Labels:** One of the Swarm worker nodes needs a custom node label.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secrets:** The app uses secrets which need pre-creating before we can deploy
    it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a lab for the sample app
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In this section we’ll build a three-node Linux-based Swarm cluster that satisfies
    all of the application’s pre-req’s. Once we’re done, the lab will look like this.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.4 Sample lab](images/figure14-4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.4 Sample lab
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll complete the following three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Swarm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a node label
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the secrets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s create a new three-node Swarm cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Initialize a new Swarm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the following command on the node that you want to be your Swarm manager.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`*   Add worker nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the `docker swarm join` command that displayed in the output of the previous
    command. Paste it into the two nodes you want to join as workers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`*   Verify that the Swarm is configured with one manager and two workers.'
  prefs: []
  type: TYPE_NORMAL
- en: Run this command from the manager node.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: $ docker node update --label-add pcidss=yes wrk-1
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: $ docker node inspect wrk-1
  prefs: []
  type: TYPE_NORMAL
- en: '['
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"ID": "b74rzajmrimfv7hood6l4lgz3",'
  prefs: []
  type: TYPE_NORMAL
- en: '"Version": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"Index": 27'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '"CreatedAt": "2018-01-25T10:35:18.146831621Z",'
  prefs: []
  type: TYPE_NORMAL
- en: '"UpdatedAt": "2018-01-25T10:47:57.189021202Z",'
  prefs: []
  type: TYPE_NORMAL
- en: '"Spec": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"Labels": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"pcidss": "yes"'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: <Snip>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: $ git clone https://github.com/dockersamples/atsea-sample-shop-app.git
  prefs: []
  type: TYPE_NORMAL
- en: Cloning into `'atsea-sample-shop-app'`...
  prefs: []
  type: TYPE_NORMAL
- en: 'remote: Counting objects: `636`, `done`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Receiving objects: `100`% `(``636`/636`)`, `7`.23 MiB `|` `3`.30 MiB/s, `done`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'remote: Total `636` `(`delta `0``)`, reused `0` `(`delta `0``)`, pack-reused
    `636`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Resolving deltas: `100`% `(``197`/197`)`, `done`.'
  prefs: []
  type: TYPE_NORMAL
- en: Checking connectivity... `done`.
  prefs: []
  type: TYPE_NORMAL
- en: $ `cd` atsea-sample-shop-app
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: $ docker stack deploy -c docker-stack.yml seastack
  prefs: []
  type: TYPE_NORMAL
- en: Creating network seastack_default
  prefs: []
  type: TYPE_NORMAL
- en: Creating network seastack_back-tier
  prefs: []
  type: TYPE_NORMAL
- en: Creating network seastack_front-tier
  prefs: []
  type: TYPE_NORMAL
- en: Creating network seastack_payment
  prefs: []
  type: TYPE_NORMAL
- en: Creating service seastack_database
  prefs: []
  type: TYPE_NORMAL
- en: Creating service seastack_appserver
  prefs: []
  type: TYPE_NORMAL
- en: Creating service seastack_visualizer
  prefs: []
  type: TYPE_NORMAL
- en: Creating service seastack_payment_gateway
  prefs: []
  type: TYPE_NORMAL
- en: Creating service seastack_reverse_proxy
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: $ docker stack ls
  prefs: []
  type: TYPE_NORMAL
- en: NAME                SERVICES
  prefs: []
  type: TYPE_NORMAL
- en: seastack            `5`
  prefs: []
  type: TYPE_NORMAL
- en: $ docker stack ps seastack
  prefs: []
  type: TYPE_NORMAL
- en: NAME                          NODE     DESIRED STATE    CURRENT STATE
  prefs: []
  type: TYPE_NORMAL
- en: seastack_reverse_proxy.1      wrk-2    Running          Running `7` minutes
    ago
  prefs: []
  type: TYPE_NORMAL
- en: seastack_payment_gateway.1    wrk-1    Running          Running `7` minutes
    ago
  prefs: []
  type: TYPE_NORMAL
- en: seastack_visualizer.1         mgr-1    Running          Running `7` minutes
    ago
  prefs: []
  type: TYPE_NORMAL
- en: seastack_appserver.1          wrk-2    Running          Running `7` minutes
    ago
  prefs: []
  type: TYPE_NORMAL
- en: seastack_database.1           wrk-2    Running          Running `7` minutes
    ago
  prefs: []
  type: TYPE_NORMAL
- en: seastack_appserver.2          wrk-1    Running          Running `7` minutes
    ago
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: $ docker stack ps seastack
  prefs: []
  type: TYPE_NORMAL
- en: NAME                NODE     DESIRED      CURRENT  ERROR
  prefs: []
  type: TYPE_NORMAL
- en: STATE        STATE
  prefs: []
  type: TYPE_NORMAL
- en: 'reverse_proxy.1     wrk-2    Shutdown     Failed   `"task: non-zero exit (1)"`'
  prefs: []
  type: TYPE_NORMAL
- en: '`\_`reverse_proxy.1   wrk-2    Shutdown     Failed   `"task: non-zero exit
    (1)"`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: $ docker service logs seastack_reverse_proxy
  prefs: []
  type: TYPE_NORMAL
- en: 'seastack_reverse_proxy.1.zhc3cjeti9d4@wrk-2 `|` `[`emerg`]` `1``#1: host not
    found...`'
  prefs: []
  type: TYPE_NORMAL
- en: 'seastack_reverse_proxy.1.6m1nmbzmwh2d@wrk-2 `|` `[`emerg`]` `1``#1: host not
    found...`'
  prefs: []
  type: TYPE_NORMAL
- en: 'seastack_reverse_proxy.1.6m1nmbzmwh2d@wrk-2 `|` nginx: `[`emerg`]` host not
    found..'
  prefs: []
  type: TYPE_NORMAL
- en: 'seastack_reverse_proxy.1.zhc3cjeti9d4@wrk-2 `|` nginx: `[`emerg`]` host not
    found..'
  prefs: []
  type: TYPE_NORMAL
- en: seastack_reverse_proxy.1.1tmya243m5um@mgr-1 `|` `10`.255.0.2 `"GET / HTTP/1.1"`
    `302`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: <Snip>
  prefs: []
  type: TYPE_NORMAL
- en: 'appserver:'
  prefs: []
  type: TYPE_NORMAL
- en: 'image: dockersamples/atsea_app'
  prefs: []
  type: TYPE_NORMAL
- en: 'networks:'
  prefs: []
  type: TYPE_NORMAL
- en: '- front-tier'
  prefs: []
  type: TYPE_NORMAL
- en: '- back-tier'
  prefs: []
  type: TYPE_NORMAL
- en: '- payment'
  prefs: []
  type: TYPE_NORMAL
- en: 'deploy:'
  prefs: []
  type: TYPE_NORMAL
- en: 'replicas: 2             <<Updated value'
  prefs: []
  type: TYPE_NORMAL
- en: <Snip>
  prefs: []
  type: TYPE_NORMAL
- en: 'visualizer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'image: dockersamples/visualizer:stable'
  prefs: []
  type: TYPE_NORMAL
- en: 'ports:'
  prefs: []
  type: TYPE_NORMAL
- en: '- "8001:8080"'
  prefs: []
  type: TYPE_NORMAL
- en: 'stop_grace_period: 2m     <<Updated value'
  prefs: []
  type: TYPE_NORMAL
- en: <Snip
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: $ docker stack deploy -c docker-stack.yml seastack
  prefs: []
  type: TYPE_NORMAL
- en: 'Updating service seastack_reverse_proxy `(`id: z4crmmrz7zi83o0721heohsku`)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Updating service seastack_database `(`id: 3vvpkgunetxaatbvyqxfic115`)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Updating service seastack_appserver `(`id: ljht639w33dhv0dmht1q6mueh`)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Updating service seastack_visualizer `(`id: rbwoyuciglre01hsm5fviabjf`)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Updating service seastack_payment_gateway `(`id: w4gsdxfnb5gofwtvmdiooqvxs`)`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: $ docker stack ps seastack
  prefs: []
  type: TYPE_NORMAL
- en: NAME                    NODE     DESIRED STATE   CURRENT STATE
  prefs: []
  type: TYPE_NORMAL
- en: seastack_visualizer.1   mgr-1    Running         Running `1` second ago
  prefs: []
  type: TYPE_NORMAL
- en: seastack_visualizer.1   mgr-1    Shutdown        Shutdown `3` seconds ago
  prefs: []
  type: TYPE_NORMAL
- en: seastack_appserver.1    wrk-2    Running         Running `24` minutes ago
  prefs: []
  type: TYPE_NORMAL
- en: seastack_appserver.2    wrk-1    Running         Running `24` minutes ago
  prefs: []
  type: TYPE_NORMAL
- en: seastack_appserver.3    wrk-2    Running         Running `1` second ago
  prefs: []
  type: TYPE_NORMAL
- en: seastack_appserver.4    wrk-1    Running         Running `1` second ago
  prefs: []
  type: TYPE_NORMAL
- en: seastack_appserver.5    wrk-2    Running         Running `1` second ago
  prefs: []
  type: TYPE_NORMAL
- en: seastack_appserver.6    wrk-1    Running         Starting `7` seconds ago
  prefs: []
  type: TYPE_NORMAL
- en: seastack_appserver.7    wrk-2    Running         Running `1` second ago
  prefs: []
  type: TYPE_NORMAL
- en: seastack_appserver.8    wrk-1    Running         Starting `7` seconds ago
  prefs: []
  type: TYPE_NORMAL
- en: seastack_appserver.9    wrk-2    Running         Running `1` second ago
  prefs: []
  type: TYPE_NORMAL
- en: seastack_appserver.10   wrk-1    Running         Starting `7` seconds ago
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: $ docker stack rm seastack
  prefs: []
  type: TYPE_NORMAL
- en: Removing service seastack_appserver
  prefs: []
  type: TYPE_NORMAL
- en: Removing service seastack_database
  prefs: []
  type: TYPE_NORMAL
- en: Removing service seastack_payment_gateway
  prefs: []
  type: TYPE_NORMAL
- en: Removing service seastack_reverse_proxy
  prefs: []
  type: TYPE_NORMAL
- en: Removing service seastack_visualizer
  prefs: []
  type: TYPE_NORMAL
- en: Removing network seastack_front-tier
  prefs: []
  type: TYPE_NORMAL
- en: Removing network seastack_payment
  prefs: []
  type: TYPE_NORMAL
- en: Removing network seastack_default
  prefs: []
  type: TYPE_NORMAL
- en: Removing network seastack_back-tier
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31][PRE32]`'
  prefs: []
  type: TYPE_NORMAL
