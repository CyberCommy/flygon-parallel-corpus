- en: Channels and Messages
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 2](../Text/Ch02.xhtml), *Understanding Goroutines*, we looked at
    how goroutines work, how to use them in a concurrent fashion, and some of the
    common mistakes that might occur. They were simple to use and reason about, but
    they were limited because they are able to spawn other goroutines and wait on
    system calls. In reality, goroutines are more capable than what was shown in the
    previous chapter, and to uncover their full potential we need to understand how
    to use channels, which is the aim of the current chapter. Here, we will look at
    the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Controlling parallelism
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Channels and data communication
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of channels
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closing and multiplexing channels
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling parallelism
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We know that spawned goroutines will start executing as soon as possible and
    in a simultaneous fashion. However, there is an inherent risk involved when the
    said goroutines need to work on a common source that has a lower limit on the
    number of simultaneous tasks it can handle. This might cause the common source
    to significantly slow down or in some cases even fail. As you might guess, this
    is not a new problem in the field of computer science, and there are many ways
    to handle it. As we shall see throughout the chapter, Go provides mechanisms to
    control parallelism in a simple and intuitive fashion. Let's start by looking
    at an example to simulate the problem of burdened common source, and then proceed
    to solve it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine a cashier who has to process orders, but has a limit to process only
    10 orders in a day. Let''s look at how to present this as a program:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A possible output of the program might be as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding output shows a cashier who was overwhelmed after taking 10 orders.
    However, an interesting point to note is that if you run the preceding code multiple
    times, you might get different outputs. For example, all of the 30 orders might
    be processed in one of the runs!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: This is happening because of what is known as the **race condition**. A data
    race (or race condition) occurs when multiple actors (goroutines, in our case)
    are trying to access and modify a common shared state, and this results in incorrect
    reads and writes by the goroutines.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'We can try to solve this issue in two ways:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Increasing the limit for processing orders
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increasing the number of cashiers
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Increasing the limit is feasible only to a certain extent, beyond which it
    would start degrading the system or in the case of the cashier, work will neither
    be efficient nor 100% accurate. On the contrary, by increasing the number of cashiers,
    we can start processing more orders consecutively while not changing the limit.
    There are two approaches to this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Distributed work without channels
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributed work with channels
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributed work without channels
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to distribute the work equally among the cashiers, we need to know
    the amount of orders we will get beforehand and ensure that the work each cashier
    receives is within his/her limit. This is not the most practical solution, because
    it would fail in a real-world scenario where we would need to keep track of how
    many orders each cashier has processed and divert the remaining orders to the
    other cashiers. However, before we look at the correct way to solve it, let''s
    take time to better understand the problem of uncontrolled parallelism and try
    to solve it. The following code attempts to solve it in a naïve manner, which
    should provide us with a good start:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following is one possible output:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We split the available 30 orders between cashiers `1`, `2`, and `3`, and all
    of the orders were successfully processed without anyone complaining about being
    tired. However, note that the code to make this work required a lot of work on
    our end. We had to create a function generator to create cashiers, keep track
    of which cashier to use via `cashierIndex`, and so on. And the worst part is that
    the preceding code isn''t correct! Logically, it might seem to be doing what we
    want; however, note that we are spawning multiple goroutines that are working
    on variables with a shared state, `ordersProcessed`! This is the race condition
    we discussed earlier. The good news is that we can detect it in `wochan.go` in
    two ways:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'In `createCashier` function, replace `fmt.Println("Cashier ", cashierID, "Processing
    order", orderNum)` with `fmt.Println(cashierID, "->", ordersProcessed)`. Here
    is one possible output:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The previous point proves that the code is not correct; however, we had to
    guess the possible issue in the code and then verify it. Go provides us with tools
    to detect data race so that we do not have to worry about such issues. All we
    have to do to detect data race is to test, run, build, or install the package
    (file in the case of run) with the `-race` flag . Let''s run this on our program
    and look at the output:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As can be seen, the `-race` flag helped us to detect the data race.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'Does this mean that we cannot distribute our tasks when we have shared state?
    Of course we can! But we need to use mechanisms provided by Go for this purpose:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Mutexes, semaphores, and locks
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Channels
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutex is a mutual exclusion lock that provides us with a synchronization mechanism
    to allow only one goroutine to access a particular piece of code or shared state
    at any given point in time. As already stated, for synchronization problems, we
    can use either mutex or channels, and Go recommends using the right construct
    for the right job. However, in practice, using channels provides us with a higher
    level of abstraction and greater versatility in terms of usage, though mutex has
    its uses. It is for this reason for that, throughout this chapter and the book,
    we will be making use of channels.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Distributed work with channels
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are certain about three things now: we want to distribute our orders among
    the cashiers correctly, we want to ensure that the correct number of orders are
    processed by each cashier, and we want to use channels to solve this problem.
    Before we address how to solve the cashier problem using channels, let''s first
    look at the basic syntax and usage of a channel.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: What is a channel?
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A channel is a communication mechanism that allows us to pass data between goroutines.
    It is an in-built data type in Go. Data can be passed using one of the primitive
    data types or we can create our own complex data type using structs.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example to demonstrate how to use a channel:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we run the preceding code, it would print the following output:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The basic pattern for using channels can be explained by the following steps:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Create the channel to accept the data to be processed.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch the goroutines that are waiting on the channel for data.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we can either use `main` function or other goroutines to pass data into
    the channel.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The goroutines listening on the channel can accept the data and process them
    .
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The advantage of using channels is that multiple goroutines can wait on the
    same channel and execute tasks concurrently.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Solving the cashier problem with goroutines
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we try to solve the problem, let''s first formulate what we want to
    achieve:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Create a channel `orderChannel` that accepts all orders.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch the required number of cashier goroutines that accept limited numbers
    of orders from `orderChannel`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start putting all orders into `orderChannel`.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s look at one possible solution that tries to solve the cashier problem
    using the preceding steps:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'On running the preceding code with `-race` flag, we can see that the code ran
    without any data races:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The code is quite straightforward, is easy to parallelize, and works well without
    causing any data races.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Channels and data communication
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go is a statically typed language, and this means that a given channel can
    only send or receive data of a single data type. In Go''s terminology, this is
    known as a channel''s **element type**. A Go channel will accept any valid Go
    data type including functions. Here is an example of a simple program that accepts
    and calls on functions:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code sample, we say that the channel `ch` has the element type
    of `func(int)` and the channel `done` has the element type of `bool`. There are
    a lot more interesting details in the code, but we shall discuss them in the following
    sections.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Messages and events
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far we have been using the term *data* to refer to the values that are being
    sent and received from a channel. While this might be easy to understand so far,
    Go uses two specific terms to describe the type of data that is being communicated
    over the channels. They are called **messages** and **events**. In terms of code
    they are identical, but the terms are used to help us understand the *type* of
    data that is being sent. In a nutshell:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Messages are generally values we want the goroutine to process and act on them
    if required.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events are used to signify that a certain *event* has occurred. The actual value
    received might not be as important as the act of receiving a value. Note that
    though we use the term *event*, they are still a type of *message*.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the previous code example, values sent to `ch` are messages, while the value
    sent to `done` is an event. An important point to note is that element types of
    event channels tend to be `struct{}{}`, `bool`, or `int`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand what channel element types, messages, and events are,
    let's look at the different types of channels.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Types of channels
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go provides us with three major variations on channel types. They can be broadly
    classified into:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Unbuffered
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buffered
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unidirectional (send-only and receive-only type channels)
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The unbuffered channel
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the basic channel type available in Go. It is quite straightforward
    to use—we send data into the channel and we receive data at the other end. The
    interesting part is that any goroutine operating on an unbuffered channel will
    be blocked until both the sender and receiver goroutines are available. For example,
    consider the following code snippet:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have a channel `ch` of element type `int`. We start three goroutines; one
    sends a message of `100` onto the channel (`send100`) and the other two goroutines
    (`recv1` and `recv2`) wait on the channel. `send100` is blocked until either of
    `recv1` or `recv2` starts listening on the channel to receive the message. If
    we assume that `recv2` receives the message sent on the channel by `send100`,
    then `recv1` will be waiting until another message is sent on the channel. If
    the preceding four lines are the only communications on the channel, then `recv1`
    will wait until the program ends and then will be abruptly killed off by the Go
    runtime.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: The buffered channel
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Consider the case where we are able to send more messages into a channel than
    the goroutines receiving the messages can handle them. If we use unbuffered channels,
    it would significantly slow down the program because we will have to wait for
    each message to be processed before we can put in another message. It would be
    ideal if the channel could store these extra messages or "buffer" the messages.
    This is exactly what a buffered channel does. It maintains a queue of messages
    which a goroutine will consume at its own pace. However, even a buffered channel
    has a limited capacity; we need to define the capacity of the queue at the time
    of channel creation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how do we use a buffered channel? Syntax-wise, it is identical to using
    an unbuffered channel. The behavior of a buffer channel can be explained as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '**If a buffered channel is empty**: Receiving messages on the channel is blocked
    until a message is sent across the channel'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**If a buffered channel is full**: Sending messages on the channel is blocked
    until at least one message is received from the channel, thus making space for
    the new message to be put on the channel''s buffer or queue'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**If a buffered channel is partially filled, that is, neither full nor empty**:
    Either sending or receiving messages on a channel is unblocked and the communication
    is instantaneous'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/c3be325a-235f-4cb6-9c5e-61393adb9827.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
- en: Communication over a buffered channel
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: The unidirectional buffer
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Messages can be sent and received from a channel. However, when goroutines
    use channels for communication, they are generally going to be for a single purpose:
    either to send or receive from a channel. Go allows us to specify whether a channel
    being used by a goroutine is for sending or receiving messages. It accomplishes
    this with the help of unidirectional channels. Once a channel has been identified
    as being unidirectional, we cannot perform the other operation on them. This means
    that a unidirectional send channel cannot be used to receive messages, and a unidirectional
    receive channel cannot be used to send messages. Any attempts to do so would be
    caught by the Go compiler as compile-time errors.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of using unidirectional channels correctly:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The expected output would be as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, let''s try to send over a receiving channel and see what happens. We will
    only see the changed function in the previous example here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, if we try to run or build the updated program, we will get the following
    error:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'So, how would the program behave if we used a buffered channel? Since there
    will be no blocking on an unfilled channel, the `send` goroutine sends a message
    onto the channel and then continues executing. The `recv` goroutine reads from
    the channel when it starts executing and then prints it:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output would be as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Closing channels
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous sections, we have looked at three types of channels and how
    to create them. In this section, let''s look at how to close the channels and
    how this might affect sending and receiving on these channels. We close a channel
    when we no longer want to send any messages on the said channel. How a channel
    behaves after being closed is different for each type of channel. Let''s dive
    into them:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '**Unbuffered closed channel**: Sending messages will cause panic and receiving
    on it will yield an immediate zero value of the channel''s element type.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Buffered closed channel**: Sending messages will cause panic but receiving
    on it will first yield all the values in the channel''s queue. Once the queue
    has been exhausted, then the channel will start yielding zero values of the channel''s
    element type.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a program to elucidate on the two preceding points:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following is one possible output of the program:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, here are some further useful points about closing channels and closed
    channels:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: It is not possible to determine if a channel has been closed. The best we can
    do is check if we were able to successfully retrieve a message from a channel.
    We know that the default syntax for retrieving on channel is `msg := <- ch`. However,
    there is a variant on this retrieval: `msg, ok := <-ch`. The second parameter
    tells us if the retrieval was successful. If a channel is closed, `ok` will be
    `false`. This can be used to tell when a channel has been closed.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`msg, ok := <-ch` is a common pattern when iterating over channels. As a result,
    Go allows us to `range` over a channel. When a channel closes, the `range` loop
    ends.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closing a closed channel, nil channel, or a receive-only channel will cause
    panic. Only a bidirectional channel or send-only channel can be closed.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not mandatory to close a channel and irrelevant for the **garbage collector**
    (**GC**). If the GC determines that a channel is unreachable, irrespective of
    whether it is open or closed, the channel will be garbage collected.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiplexing channels
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Multiplexing describes the methodology where we use a single resource to act
    upon multiple signals or actions. This method is used extensively in telecommunications
    and computer networks. We might find ourselves in a situation where we have multiple
    types of tasks that we want to execute. However, they can only be executed in
    mutual exclusion, or they need to work on a shared resource. For this, we make
    use of a pattern in Go known as channels multiplexing. Before we dive into how
    to actually multiplex channels, let's try to implement it on our own.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that we have a set of channels and we want to act on them as soon as
    data is sent over a channel. Here''s a naïve approach on how we want to do this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output of the preceding program is as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the loop within the goroutine, the first channel is never waited upon and
    this causes the deadlock in the goroutine. Multiplexing helps us wait upon multiple
    channels without blocking on any of the channels while acting on a message once
    it is available on a channel.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some important points to remember when multiplexing on channels:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '**Syntax**:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It is possible that, by the time `select` is executed, more than one case is
    ready with a message. In this case, `select` will not execute all of the cases,
    but will pick one at random, execute it, and then exit the `select` statement.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, the preceding point might be limited if we want to react on messages
    being sent to all channels in `select` cases. Then we can put the `select` statement
    inside a `for` loop and it will ensure that all messages will be handled.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even though the `for` loop will handle messages sent on all channels, the loop
    will still be blocked until a message is available on it. There might be scenarios
    where we do not wish to block the loop iteration and instead do some "default"
    action. This can be achieved using `default` case in `select` statement.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Updated syntax based on the preceding two points is:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the case of buffered channels, the order in which the messages are received
    is not guaranteed.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the correct way to multiplex on all the required channels
    without being blocked on any and continuing to work on all the messages being
    sent:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following is the output of the preceding program:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Unfortunately, there is one flaw with the program: it leaks the goroutine handling, `select`*.*
    This is also pointed out in the comment near the end of the `main` function. This
    generally happens when we have a goroutine that is running but we cannot directly
    reach it. Even if a goroutine''s reference is not stored, the GC will not garbage
    collect it. Thus, we need a mechanism to stop and return from such goroutines.
    In general, this can be achieved by creating a channel specifically for returning
    from the goroutine.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, we send the signal via the `done` channel. The following
    would be the output if we uncomment the lines and then run the program:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Summary
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we looked at the reason to control parallelism and developed
    an appreciation for the complexity of the task when a shared state is involved.
    We used the example of an overworked cashier as a programming problem to solve
    and to experiment with channels, and further explored different types of channels
    and the nuances involved with using them. For example, we saw that both closed
    buffered and unbuffered channels will cause panic if we try to send messages on
    them, and receiving messages from them leads to different results based on whether
    the channel is buffered and if the channel is empty or full. We also saw how to
    wait on multiple channels without blocking on any with the help of `select`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: In later chapters, from [Chapter 5](../Text/Ch05.xhtml), *Introducing Goophr*,
    through to [Chapter 8](../Text/Ch08.xhtml), *Deploying Goophr*, we will be developing
    a distributed web application. This requires us to have basic knowledge of how
    to interact with a web server, using the HTTP protocol using tools other than
    a web browser. This knowledge will come in handy not only when interacting with
    our application but also with the standard web as a developer. This will be the
    subject of the next chapter, [Chapter 4](../Text/Ch04.xhtml), *The RESTful Web*,
    where we will look at the tools and protocols we will be using to interact with
    our web application.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的章节中，从[第5章](../Text/Ch05.xhtml) *介绍Goophr* 到[第8章](../Text/Ch08.xhtml) *部署Goophr*，我们将开发一个分布式网络应用。这需要我们具备基本的知识，如何使用HTTP协议与网络服务器进行交互，而不是使用网络浏览器。这些知识不仅在与我们的应用程序交互时会派上用场，而且在作为开发人员与标准网络交互时也会派上用场。这将是下一章[第4章](../Text/Ch04.xhtml)
    *RESTful网络* 的主题，我们将看看我们将使用的工具和协议来与我们的网络应用程序进行交互。
