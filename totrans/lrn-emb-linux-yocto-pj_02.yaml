- en: Chapter 2. Cross-compiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn about toolchains, how to use and customize them,
    and how code standards apply to them. A toolchain contains a myriad of tools,
    such as compilers, linkers, assemblers, debuggers, and a variety of miscellaneous
    utilities that help to manipulate the resulting application binaries. In this
    chapter, you will learn how to use the GNU toolchain and become familiar with
    its features. You will be presented with examples that will involve manual configurations,
    and at the same time, these examples will be moved to the Yocto Project environment.
    At the end of the chapter, an analysis will be made to identify the similarities
    and differences between manual and automatic deployment of a toolchain, and the
    various usage scenarios available for it.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing toolchains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A toolchain represents a compiler and its associated utilities that are used
    with the purpose of producing kernels, drivers, and applications necessary for
    a specific target. A toolchain usually contains a set of tools that are usually
    linked to each other. It consists of `gcc`, `glibc`, `binutils`, or other optional
    tools, such as a debugger optional compiler, which is used for specific programming
    languages, such as C++, Ada, Java, Fortran, or Objective-C.
  prefs: []
  type: TYPE_NORMAL
- en: Usually a toolchain, which is available on a traditional desktop or server,
    executes on these machines and produces executables and libraries that are available
    and can run on the same system. A toolchain that is normally used for an embedded
    development environment is called is a cross toolchain. In this case, programs,
    such as gcc, run on the host system for a specific target architecture, for which
    it produces a binary code. This whole process is referred to as cross-compilation,
    and it is the most common way to build sources for embedded development.
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing toolchains](img/image00303.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In a toolchain environment, three different machines are available:'
  prefs: []
  type: TYPE_NORMAL
- en: The build machine that represents the machine on which the toolchain was created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The host machine that represents the machine on which the toolchain is executed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The target machine that represents the machine that the toolchain produces a
    binary code for
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These three machine are used to generate four different toolchain build procedures:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A native toolchain**: This is usually available on a normal Linux distribution
    or on your normal desktop system. This is usually compiled and run, and generates
    code for the same architecture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A cross-native toolchain**: This represents a toolchain built on one system,
    though it runs and produces a binary code for the target system. A normal use
    case is when a native `gcc` is needed on the target system without building it
    on the target platform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A cross-compilation toolchain**: This is the most widespread toolchain type
    used for embedded development. It is compiled and run on an architecture type,
    usually x86, and produces a binary code for the target architecture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A cross-canadian build**: This represents a process that involves building
    a toolchain on system A. This toolchain is then run on another system, such as
    B, which produces a binary code for a third system, called C. This is one of the
    most underused build processes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The three machines that generate four different toolchain build procedures
    is described in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing toolchains](img/image00304.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Toolchains represent a list of tools that make the existence of most of great
    projects available today possible. This includes open source projects as well.
    This diversity would not have been possible without the existence of a corresponding
    toolchain. This also happens in the embedded world where newly available hardware
    needs the components and support of a corresponding toolchain for its **Board
    Support Package** (**BSP**).
  prefs: []
  type: TYPE_NORMAL
- en: Toolchain configuration is no easy process. Before starting the search for a
    prebuilt toolchain, or even building one yourself, the best solution would be
    to check for a target specific BSP; each development platform usually offers one.
  prefs: []
  type: TYPE_NORMAL
- en: Components of toolchains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The GNU toolchain is a term used for a collection of programming tools under
    the **GNU Project umbrella**. This suite of tools is what is normally called a
    **toolchain**, and is used for the development of applications and operating systems.
    It plays an important role in the development of embedded systems and Linux systems,
    in particular.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following projects are included in the GNU toolchain:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GNU make**: This represents an automation tool used for compilation and build'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GNU Compiler Collection (GCC)**: This represents a compiler''s suite that
    is used for a number of available programming languages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GNU Binutils**: This contains tools, such as linkers, assemblers, and so
    on - these tools are able to manipulate binaries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GNU Bison**: This is a parser generator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GNU Debugger (GDB)**: This is a code debugging tool'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GNU m4**: This is an m4 macro processor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GNU build system (autotools)**: This consists of the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autoconf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autoheaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automake
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Libtool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The projects included in the toolchain is described in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Components of toolchains](img/image00305.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: An embedded development environment needs more than a cross-compilation toolchain.
    It needs libraries and it should target system-specific packages, such as programs,
    libraries, and utilities, and host specific debuggers, editors, and utilities.
    In some cases, usually when talking about a company's environment, a number of
    servers host target devices, and an certain hardware probes are connected to the
    host through Ethernet or other methods. This emphasizes the fact that an embedded
    distribution includes a great number of tools, and, usually, a number of these
    tools require customization. Presenting each of these will take up more than a
    chapter in a book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, however, we will cover only the toolchain building components.
    These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`binutils`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gcc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`glibc` (C libraries)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: kernel headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I will start by the introducing the first item on this list, the **GNU Binutils
    package**. Developed under the GNU GPL license, it represents a set of tools that
    are used to create and manage binary files, object code, assembly files, and profile
    data for a given architecture. Here is a list with the functionalities and names
    of the available tools for GNU Binutils package:'
  prefs: []
  type: TYPE_NORMAL
- en: The GNU linker, that is `ld`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GNU assembler, that is `as`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A utility that converts addresses into filenames and line numbers, that is `addr2line`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A utility to create, extract, and modify archives, that is `ar`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A tool used to listing the symbols available inside object files, that is `nm`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying and translating object files, that is `objcopy`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying information from object files, that is `objdump`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating an index to for the contents of an archive, that is `ranlib`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying information from any ELF format object file, that is `readelf`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing the section sizes of an object or archive file, that is `size`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing printable strings from files, that is `strings`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discarding the symbols utility that is `strip`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering or demangle encoded C++ symbols, that is `c++filt`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating files that build use DLLs, that is `dlltool`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new, faster, ELF-only linker, which is still in beta testing, that is `gold`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying the profiling information tool, that is `gprof`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting an object code into an NLM, that is `nlmconv`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Windows-compatible message compiler, that is `windmc`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A compiler for Windows resource files, that is `windres`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The majority of these tools use the **Binary File Descriptor** (**BFD**) library
    for low-level data manipulation, and also, many of them use the `opcode` library
    to assemble and disassemble operations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Useful information about `binutils` can be found at [http://www.gnu.org/software/binutils/](http://www.gnu.org/software/binutils/).
  prefs: []
  type: TYPE_NORMAL
- en: In the toolchain generation process, the next item on the list is represented
    by kernel headers, and are needed by the C library for interaction with the kernel.
    Before compiling the corresponding C library, the kernel headers need to be supplied
    so that they can offer access to the available system calls, data structures,
    and constants definitions. Of course, any C library defines sets of specifications
    that are specific to each hardware architecture; here, I am referring to **application
    binary interface** (**ABI**).
  prefs: []
  type: TYPE_NORMAL
- en: An application binary interface (ABI) represents the interface between two modules.
    It gives information on how functions are called and the kind of information that
    should be passed between components or to the operating system. Referring to a
    book, such as *The Linux Kernel Primer*, will do you good, and in my opinion,
    is a complete guide for what the ABI offers. I will try to reproduce this definition
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: An ABI can be seen as a set of rules similar to a protocol or an agreement that
    offers the possibility for a linker to put together compiled modules into one
    component without the need of recompilation. At the same time, an ABI describes
    the binary interface between these components. Having this sort of convention
    and conforming to an ABI offers the benefits of linking object files that could
    have been compiled with different compilers.
  prefs: []
  type: TYPE_NORMAL
- en: It can be easily seen from both of these definitions that an ABI is dependent
    on the type of platform, which can include physical hardware, some kind of virtual
    machine, and so on. It may also be dependent on the programming language that
    is used and the compiler, but most of it depends on the platform.
  prefs: []
  type: TYPE_NORMAL
- en: The ABI presents how the generated codes operate. The code generation process
    must also be aware of the ABI, but when coding in a high-level language, attention
    given to the ABI is rarely a problem. This information could be considered as
    necessary knowledge to specify some ABI related options.
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule, ABI must be respected for its interaction with external components.
    However, with regard to interaction with its internal modules, the user is free
    to do whatever he or she wants. Basically, they are able to reinvent the ABI and
    form their own dependence on the limitations of the machine. The simple example
    here is related to various citizens who belong to their own country or region,
    because they learned and know the language of that region since they were born.
    Hence, they are able to understand one another and communicate without problems.
    For an external citizen to be able to communicate, he or she will need to know
    the language of a region, and being in this community seems natural, so it will
    not constitute a problem. Compilers are also able to design their own custom calling
    conventions where they know the limitations of functions that are called within
    a module. This exercise is typically done for optimization reasons. However, this
    can be considered an abuse of the ABI term.
  prefs: []
  type: TYPE_NORMAL
- en: The kernel in reference to a user space ABI is backward compatible, and it makes
    sure that binaries are generated using older kernel header versions, rather than
    the ones available on the running kernel, will work best. The disadvantages of
    this are represented by the fact that new system calls, data structures, and binaries
    generated with a toolchain that use newer kernel headers, might not work for newer
    features. The need for the latest kernel headers can be justified by the need
    to have access to the latest kernel features.
  prefs: []
  type: TYPE_NORMAL
- en: The GNU Compiler Collection, also known as GCC, represents a compiler system
    that constitutes the key component of the GNU toolchain. Although it was originally
    named the GNU C Compiler, due to the fact that it only handled the C programming
    language, it soon begun to represent a collection of languages, such as C, C++,
    Objective C, Fortran, Java, Ada, and Go, as well as the libraries for other languages
    (such as `libstdc++`, `libgcj`, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: It was originally written as the compiler for the GNU operating system and developed
    as a 100 percent free software. It is distributed under the GNU GPL. This helped
    it extend to its functionalities across a wide variety of architectures, and it
    played an important role in the growth of open source software.
  prefs: []
  type: TYPE_NORMAL
- en: The development of GCC started with the effort put in by Richard Stallman to
    bootstrap the GNU operating system. This quest led Stallman to write his own compiler
    from scratch. It was released in 1987, with Stallman as the author and other as
    contributors to it. By 1991, it had already reached a stable phase, but it was
    unable to include improvements due to its architectural limitations. This meant
    that the starting point for work on GCC version 2 had begun, but it did not take
    long until the need for development of new language interfaces started to appear
    in it as well, and developers started doing their own forks of the compiler source
    code. This fork initiative proved to be very inefficient, and because of the difficulty
    of accepting the code procedure, working on it became really frustrating.
  prefs: []
  type: TYPE_NORMAL
- en: This changed in 1997, when a group of developers gathered as the **Experimental/Enhanced
    GNU Compiler System** (**EGCS**) workgroup started merging several forks in one
    project. They had so much success in this venture, and gathered so many features,
    that they made **Free Software Foundation** (**FSF**) halt their development of
    GCC version 2 and appointed EGCS the official GCC version and maintainers by April
    1999\. They united with each other with the release of GCC 2.95\. More information
    on the history and release history of the GNU Compiler Collection can be found
    at [https://www.gnu.org/software/gcc/releases.html](https://www.gnu.org/software/gcc/releases.html)
    and [http://en.wikipedia.org/wiki/GNU_Compiler_Collection#Revision_history](http://en.wikipedia.org/wiki/GNU_Compiler_Collection#Revision_history).
  prefs: []
  type: TYPE_NORMAL
- en: The GCC interface is similar to the Unix convention, where users call a language-specific
    driver, which interprets arguments and calls a compiler. It then runs an assembler
    on the resulting outputs and, if necessary, runs a linker to obtain the final
    executable. For each language compiler, there is a separate program that performs
    the source code read.
  prefs: []
  type: TYPE_NORMAL
- en: The process of obtaining an executable from source code has some execution steps.
    After the first step, an abstract syntax tree is generated and, in this stage,
    compiler optimization and static code analysis can be applied. The optimizations
    and static code analysis can be both applied on architecture-independent **GIMPLE**
    or its superset GENERIC representation, and also on architecture-dependent **Register
    Transfer Language** (**RTL**) representation, which is similar to the LISP language.
    The machine code is generated using pattern-matching algorithm, which was written
    by Jack Davidson and Christopher Fraser.
  prefs: []
  type: TYPE_NORMAL
- en: GCC was initially written almost entirely in C language, although the Ada frontend
    is written mostly in Ada language. However, in 2012, the GCC committee announced
    the use of C++ as an implementation language. The GCC library could not be considered
    finished as an implementation language, even though its main activities include
    adding new languages support, optimizations, improved runtime libraries, and increased
    speed for debugging applications.
  prefs: []
  type: TYPE_NORMAL
- en: Each available frontend generated a tree from the given source code. Using this
    abstract tree form, different languages can share the same backend. Initially,
    GCC used **Look-Ahead LR** (**LALR)** parsers, which were generated using Bison,
    but over time, it moved on to recursive-descendent parsers for C, C++, and Objective-C
    in 2006\. Today, all available frontends use handwritten recursive-descendent
    parsers.
  prefs: []
  type: TYPE_NORMAL
- en: Until recently, the syntax tree abstraction of a program was not independent
    of a target processor, because the meaning of the tree was different from one
    language frontend to the other, and each provided its own tree syntax. All this
    changed with the introduction of GENERIC and GIMPLE architecture-independent representations,
    which were introduced with the GCC 4.0 version.
  prefs: []
  type: TYPE_NORMAL
- en: GENERIC is a more complex intermediate representation, while GIMPLE is a simplified
    GENERIC and targets all the frontends of GCC. Languages, such as C, C++ or Java
    frontends, directly produce GENERIC tree representations in the frontend. Others
    use different intermediate representations that are then parsed and converted
    to GENERIC representations.
  prefs: []
  type: TYPE_NORMAL
- en: The GIMPLE transformation represents complex expressions that are split into
    a three address code using temporary variables. The GIMPLE representation was
    inspired by the SIMPLE representation used on the McCAT compiler for simplifying
    the analysis and optimization of programs.
  prefs: []
  type: TYPE_NORMAL
- en: The middle stage representation of GCC involves code analysis and optimization,
    and works independently in terms of a compiled language and the target architecture.
    It starts from the GENERIC representation and continues to the **Register Transfer
    Language** (**RTL**) representation. The optimization mostly involves jump threading,
    instruction scheduling, loop optimization, sub expression elimination, and so
    on. The RTL optimizations are less important than the ones done through GIMPLE
    representations. However, they include dead code elimination, global value numbering,
    partial redundancy elimination, sparse conditional constant propagation, scalar
    replacement of aggregates, and even automatic vectorization or automatic parallelization.
  prefs: []
  type: TYPE_NORMAL
- en: The GCC backend is mainly represented by preprocessor macros and specific target
    architecture functions, such as endianness definitions, calling conventions, or
    word sizes. The initial stage of the backend uses these representations to generate
    the RTL; this suggests that although GCC's RTL representation is nominally processor-independent,
    the initial processing of abstract instructions is adapted for each specific target.
  prefs: []
  type: TYPE_NORMAL
- en: A machine-specific description file contains RTL patterns, also code snippets,
    or operand constraints that form a final assembly. In the process of RTL generation,
    the constraints of the target architecture are verified. To generate an RTL snippet,
    it must match one or a number RTL patterns from the machine description file,
    and at the same time also satisfy the limitations for these patterns. If this
    is not done, the process of conversion for the final RTL into machine code would
    be impossible. Toward the end of compilation, the RTL representation becomes a
    strict form. Its representation contains a real machine register correspondence
    and a template from the target's machine description file for each instruction
    reference.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, the machine code is obtained by calling small snippets of code,
    which are associated with corresponding patterns. In this way, instructions are
    generated from target instruction sets. This process involves the usage of registers,
    offsets, and addresses from the reload phase.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information about a GCC compiler can be found at [http://gcc.gnu.org/](http://gcc.gnu.org/)
    or [http://en.wikipedia.org/wiki/GNU_Compiler_Collection](http://en.wikipedia.org/wiki/GNU_Compiler_Collection).
  prefs: []
  type: TYPE_NORMAL
- en: 'The last element that needs to be introduced here is the C library. It represents
    the interface between a Linux kernel and applications used on a Linux system.
    At the same time, it offers aid for the easier development of applications. There
    are a couple of C libraries available in this community:'
  prefs: []
  type: TYPE_NORMAL
- en: '`glibc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eglibc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Newlib`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bionic`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`musl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uClibc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dietlibc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Klibc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The choice of the C library used by the GCC compiler will be executed in the
    toolchain generation phase, and it will be influenced not only by the size and
    application support offered by the libraries, but also by compliance of standards,
    completeness, and personal preference.
  prefs: []
  type: TYPE_NORMAL
- en: Delving into C libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first library that we'll discuss here is the `glibc` library, which is designed
    for performance, compliance of standards, and portability. It was developed by
    the Free Software Foundation for the GNU/Linux operating system and is still present
    today on all GNU/Linux host systems that are actively maintained. It was released
    under the GNU Lesser General Public License.
  prefs: []
  type: TYPE_NORMAL
- en: The `glibc` library was initially written by Roland McGrath in the 1980s and
    it continued to grow until the 1990s when the Linux kernel forked `glibc`, calling
    it `Linux libc`. It was maintained separately until January 1997 when the Free
    Software Foundation released `glibc 2.0`. The `glibc 2.0` contained so many features
    that it did not make any sense to continue the development of `Linux libc`, so
    they discontinued their fork and returned to using `glibc`. There are changes
    that are made in `Linux libc` that were not merged into `glibc` because of problems
    with the authorship of the code.
  prefs: []
  type: TYPE_NORMAL
- en: The `glibc` library is quite large in terms of its dimensions and isn't a suitable
    fit for small embedded systems, but it provides the functionality required by
    the **Single UNIX Specification** (**SUS**), POSIX, ISO C11, ISO C99, Berkeley
    Unix interfaces, System V Interface Definition, and the X/Open Portability Guide,
    Issue 4.2, with all its extensions common with X/Open System Interface compliant
    systems along with X/Open UNIX extensions. In addition to this, GLIBC also provides
    extensions that have been deemed useful or necessary while developing GNU.
  prefs: []
  type: TYPE_NORMAL
- en: The next C library that I'm going to discuss here is the one that resides as
    the main C library used by the Yocto Project until version 1.7\. Here, I'm referring
    to the `eglibc` library. This is a version of `glibc` optimized for the usage
    of embedded devices and is, at the same time, able to preserve the compatibility
    standards.
  prefs: []
  type: TYPE_NORMAL
- en: Since 2009, Debian and a number of its derivations chose to move from the GNU
    C Library to `eglibc`. This might be because there is a difference in licensing
    between GNU LGPL and `eglibc`, and this permits them to accept patches that `glibc`
    developers my reject. Since 2014, the official `eglibc` homepage states that the
    development of `eglibc` was discontinued because `glibc` had also moved to the
    same licensing, and also, the release of Debian Jessie meant that it had moved
    back to `glibc`. This also happened in the case of Yocto support when they also
    decided to make `glibc` their primary library support option.
  prefs: []
  type: TYPE_NORMAL
- en: The `newlib` library is another C library developed with the intention of being
    used in embedded systems. It is a conglomerate of library components under free
    software licenses. Developed by Cygnus Support and maintained by Red Hat, it is
    one of the preferred versions of the C library used for non-Linux embedded systems.
  prefs: []
  type: TYPE_NORMAL
- en: The `newlib` system calls describe the usage of the C library across multiple
    operation systems, and also on embedded systems that do not require an operating
    system. It is included in commercial GCC distributions, such as Red Hat, CodeSourcery,
    Attolic, KPIT and others. It also supported by architecture vendors that include
    ARM, Renesas, or Unix-like environments, such as Cygwin, and even proprietary
    operating systems of the Amiga personal computer.
  prefs: []
  type: TYPE_NORMAL
- en: By 2007, it also got support from the toolchain maintainers of Nintendo DS,
    PlayStation, portable SDK Game Boy Advance systems, Wii, and GameCube development
    platforms. Another addition was made to this list in 2013 when Google Native Client
    SDK included `newlib` as their primary C library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bionic is a derivate of the BSD C library developed by Google for Android based
    on the Linux kernel. Its development is independent of Android code development.
    It is licensed as 3-clause BSD license and its goals are publically available.
    These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Small size**: Bionic is smaller in size compared to `glibc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Speed**: This has designed CPUs that work at low frequencies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BSD license**: Google wished to isolate Android apps from GPL and LGPL licenses,
    and this is the reason it moved to a non-copyleft license which are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android is based on a Linux kernel which is based on a GPLv2 license
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`glibc` is based on LGPL, which permits the linking of dynamic proprietary
    libraries but not with static linking'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It also has a list of restrictions compared to `glibc`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It does not include C++ exception handling, mainly because most the code used
    for Android is written in Java.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not have wide character support.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not include a Standard Template library, although it can be included
    manually.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It functions within Bionic POSIX and even system call headers are wrappers or
    stubs for Android -specific functions. This may lead to odd behavior sometimes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When Android 4.2 released, it included support for `glibc` `FORTIFY_SOURCE`
    features. These features are very often used in Yocto, and embedded systems in
    general, but are only present in the `gcc` version for Android devices with ARM
    processors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next C library that will be discussed is `musl`. It is a C library intended
    for use with Linux operating systems for embedded and mobile systems. It has a
    MIT license and was developed with the idea of having a clean, standard-compliant
    `libc`, which is time efficient, since it's been developed from scratch. As a
    C library, it is optimized for the linking of static libraries. It is compatible
    with C99 standard and POSIX 2008, and implements Linux, `glibc`, and BSD non-standard
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll discuss `uClibc`, which is a C standard library designed for Linux
    embedded systems and mobile devices. Although initially developed for μClinux
    and designed for microcontrollers, it gathered track and became the weapon of
    choice for anyone who''s has limited space on their device. This has become popular
    due to the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: It focuses on size rather than performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a GNU Lesser General Public License (LGPL) free license
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is much smaller the glibc and reduces compilation time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has high configurability due to the fact that many of its features can be
    enabled using a `menuconfig` interface similar to the one available on packages,
    such as Linux kernel, U-Boot, or even BusyBox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `uClibc` library also has another quality that makes it quite useful. It
    introduces a new ideology and, because of this, the C library does not try to
    support as many standards as possible. However, it focuses on embedded Linux and
    consists of the features necessary for developers who face the limitation of available
    space. Due to this reason, this library was written from scratch, and even though
    it has its fair share of limitations, `uClibc` is an important alternative to
    `glibc`. If we take into consideration the fact that most of the features used
    from C libraries are present in it, the final size is four times smaller, and
    WindRiver, MontaVista, and TimeSys are active maintainers of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `dietlibc` library is a standard C library that was developed by Felix
    von Leitner and released under the GNU GPL v2 license. Although it also contains
    some commercial licensed components, its design was based on the same idea as
    `uClibc`: the possibility of compiling and linking software while having the smallest
    size possible. It has another resemblance to `uClibc`; it was developed from scratch
    and has only implemented the most used and known standard functions. Its primary
    usage is mainly in the embedded devices market.'
  prefs: []
  type: TYPE_NORMAL
- en: The last in the C libraries list is the `klibc` standard C library. It was developed
    by H. Peter Anvin and it was developed to be used as part of the early user space
    during the Linux startup process. It is used by the components that run the the
    kernel startup process but aren't used in the kernel mode and, hence, they do
    not have access to the standard C library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The development of `klibc` started in 2002 as an initiative to remove the Linux
    initialization code outside a kernel. Its design makes it suitable for usage in
    embedded devices. It also has another advantage: it is optimized for small size
    and correctness of data. The `klibc` library is loaded during the Linux startup
    process from **initramfs** (a temporary Ram filesystem) and is incorporated by
    default into initramfs using the `mkinitramfs` script for Debian and Ubuntu-based
    filesystems. It also has access to a small set of utilities, such as `mount`,
    `mkdir`, `dash`, `mknod`, `fstype`, `nfsmount`, `run-init` and so on, which are
    very useful in the early init stage.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information on initramfs can be found using the kernel documentation at
    [https://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt](https://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt).
  prefs: []
  type: TYPE_NORMAL
- en: The `klibc` library is licensed under GNU GPL since it uses some components
    from the Linux kernel, so, as a whole, it is visible as a GPL licensed software,
    limiting its applicability in commercial embedded software. However, most of the
    source code of libraries is written under the BSD license.
  prefs: []
  type: TYPE_NORMAL
- en: Working with toolchains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When generating a toolchain, the first thing that needs to be done is the establishment
    of an ABI used to generate binaries. This means that the kernel needs to understand
    this ABI and, at the same time, all the binaries in the system need to be compiled
    with the same ABI.
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with the GNU toolchain, a good source of gathering information
    and understanding the ways in which work is done with these tools is to consult
    the GNU coding standards. The coding standard''s purposes are very simple: to
    make sure that the work with the GNU ecosystem is performed in a clean, easy,
    and consistent manner. This is a guideline that needs to be used by people interested
    in working with GNU tools to write reliable, solid, and portable software. The
    main focus of the GNU toolchain is represented by the C language, but the rules
    applied here are also very useful for any programming languages. The purpose of
    each rule is explained by making sure that the logic behind the given information
    is passed to the reader.'
  prefs: []
  type: TYPE_NORMAL
- en: The main language that we will be focusing on will also be the C programming
    language. With regard to the GNU coding standard compatibility regarding libraries
    for GNU, exceptions or utilities and their compatibility should be very good when
    compared with standards, such as the ones from Berkeley Unix, Standard C, or POSIX.
    In case of conflicts in compatibility, it is very useful to have compatibility
    modes for that programming language.
  prefs: []
  type: TYPE_NORMAL
- en: Standards, such as POSIX and C, have a number of limitations regarding the support
    for extensions - however, these extensions could still be used by including a
    `—posix`, `—ansi`, or `—compatible` option to disable them. In case the extension
    offers a high probability of breaking a program or script by being incompatible,
    a redesign of its interface should be made to ensure compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: A large number of GNU programs suppress the extensions that are known to cause
    conflict with POSIX if the `POSIXLY_CORRECT` environment variable is defined.
    The usage of user defined features offers the possibility for interchanging GNU
    features with other ones totally different, better, or even use a compatible feature.
    Additional useful features are always welcomed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take a quick look at the GNU Standard documentation, some useful information
    can be learned from it:'
  prefs: []
  type: TYPE_NORMAL
- en: It is better to use the `int` type, although you might consider defining a narrower
    data type. There are, of course, a number of special cases where this could be
    hard to use. One such example is the `dev_t` system type, because it is shorter
    than `int` on some machines and wider on others. The only way to offer support
    for non-standard C types involves checking the width of `dev_t` using `Autoconf`
    and, after this, choosing the argument type accordingly. However, it may not worth
    the trouble.
  prefs: []
  type: TYPE_NORMAL
- en: For the GNU Project, the implementation of an organization's standard specifications
    is optional, and this can be done only if it helps the system by making it better
    overall. In most situations, following published standards fits well within a
    users needs because their programs or scripts could be considered more portable.
    One such example is represented by the GCC, which implements almost all the features
    of Standard C, as the standard requires. This offers a great advantage for the
    developers of the C program. This also applies to GNU utilities that follow POSIX.2
    specifications.
  prefs: []
  type: TYPE_NORMAL
- en: There are also specific points in the specifications that are not followed,
    but this happens with the sole reason of making the GNU system better for users.
    One such example would be the fact that the Standard C program does not permit
    extensions to C, but, GCC implements many of them, some being later embraced by
    the standard. For developers interested in outputting an error message as *required*
    by the standard, the `--pedantic` argument can be used. It is implemented with
    a view to making sure that GCC fully implements the standard.
  prefs: []
  type: TYPE_NORMAL
- en: The POSIX.2 standard mentions that commands, such as `du` and `df`, should output
    sizes in units of 512 bytes. However, users want units of 1KB and this default
    behavior is implemented. If someone is interested in having the behavior requested
    by POSIX standard, they would need to set the `POSIXLY_CORRECT` environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: Another such example is represented by the GNU utilities, which don't always
    respect the POSIX.2 standard specifications when referring to support for long
    named command-line options or intermingling of options with arguments. This incompatibility
    with the POSIX standard is very useful in practice for developers. The main idea
    here is not to reject any new feature or remove an older one, although a certain
    standard mentions it as deprecated or forbidden.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information regarding the GNU Coding Standards, refer to [https://www.gnu.org/prep/standards/html_node/](https://www.gnu.org/prep/standards/html_node/).
  prefs: []
  type: TYPE_NORMAL
- en: Advice on robust programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make sure that you write robust code, a number of guidelines should be mentioned.
    The first one refers to the fact that limitations should not be used for any data
    structure, including files, file names, lines, and symbols, and especially arbitrary
    limitations. All data structures should be dynamically allocated. One of the reasons
    for this is represented by the fact that most Unix utilities silently truncate
    long lines; GNU utilities do not do these kind of things.
  prefs: []
  type: TYPE_NORMAL
- en: Utilities that are used to read files should avoid dropping `null` characters
    or nonprinting characters. The exception here is when these utilities, that are
    intended for interfacing with certain types of printers or terminals, are unable
    to handle the previously mentioned characters. The advice that I'd give in this
    case would be to try and make programs work with a UTF-8 character set, or other
    sequences of bytes used to represent multibyte characters.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that you check system calls for error return values; the exception
    here is when a developer wishes to ignore the errors. It would be a good idea
    to include the system error text from `strerror`, `perror`, or equivalent error
    handling functions, in error messages that result from a crashed on system call,
    adding the name of the source code file, and also the name of the utility. This
    is done to make sure that the error message is easy to read and understand by
    anyone involved in the interaction with the source code or the program.
  prefs: []
  type: TYPE_NORMAL
- en: Check the return value for `malloc` or `realloc` to verify if they've returned
    zero. In case `realloc` is used in order to make a block smaller in systems that
    approximate block dimensions to powers of 2, `realloc` may have a different behavior
    and get a different block. In Unix, when `realloc` has a bug, it destroys the
    storage block for a zero return value. For GNU, this bug does not occur, and when
    it fails, the original block remains unchanged. If you want to run the same program
    on Unix and do not want to lose data, you could check if the bug was resolved
    on the Unix system or use the `malloc` GNU.
  prefs: []
  type: TYPE_NORMAL
- en: The content of the block that was freed is not accessible to alter or for any
    other interactions from the user. This can be done before calling free.
  prefs: []
  type: TYPE_NORMAL
- en: When a `malloc` command fails in a noninteractive program, we face a fatal error.
    In case the same situation is repeated, but, this time, an interactive program
    is involved, it would be better to abort the command and return to the read loop.
    This offers the possibility to free up virtual memory, kill other processes, and
    retry the command.
  prefs: []
  type: TYPE_NORMAL
- en: To decode arguments, the `getopt_long` option can be used.
  prefs: []
  type: TYPE_NORMAL
- en: When writing static storage during program execution, use C code for its initialization.
    However, for data that will not be changed, reserve C initialized declarations.
  prefs: []
  type: TYPE_NORMAL
- en: Try to keep away from low-level interfaces to unknown Unix data structures -
    this could happen when the data structure do not work in a compatible fashion.
    For example, to find all the files inside a directory, a developer could use the
    `readdir` function, or any high-level interface available function, since these
    do not have compatibility problems.
  prefs: []
  type: TYPE_NORMAL
- en: For signal handling, use the BSD variant of `signal` and the POSIX `sigaction`
    function. The USG `signal` interface is not the best alternative in this case.
    Using POSIX signal functions is nowadays considered the easiest way to develop
    a portable program. However, the use of one function over another is completely
    up to the developer.
  prefs: []
  type: TYPE_NORMAL
- en: For error checks that identify impossible situations, just abort the program,
    since there is no need to print any messages. These type of checks bear witness
    to the existence of bugs. To fix these bugs, a developer will have to inspect
    the available source code and even start a debugger. The best approach to solve
    this problem would be to describe the bugs and problems using comments inside
    the source code. The relevant information could be found inside variables after
    examining them accordingly with a debugger.
  prefs: []
  type: TYPE_NORMAL
- en: Do not use a count of the encountered errors in a program as an exit status.
    This practice is not the best, mostly because the values for an exit status are
    limited to 8 bits only, and an execution of the executable might have more than
    255 errors. For example, if you try to return exit status 256 for a process, the
    parent process will see a status of zero and consider that the program finished
    successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'If temporary files are created, checking that the `TMPDIR` environment variable
    would be a good idea. If the variable is defined, it would be wise to use the
    `/tmp` directory instead. The use of temporary files should be done with caution
    because there is the possibility of security breaches occurring when creating
    them in world-writable directories. For C language, this can be avoided by creating
    temporary files in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This can also be done using the `mkstemps` function, which is made available
    by `Gnulib`.
  prefs: []
  type: TYPE_NORMAL
- en: For a bash environment, use the `noclobber` environment variable, or the `set
    -C` short version, to avoid the previously mentioned problem. Furthermore, the
    `mktemp` available utility is altogether a better solution for making a temporary
    file a shell environment; this utility is available in the GNU Coreutils package.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information about GNU C Standards can be found at [https://www.gnu.org/prep/standards/standards.html](https://www.gnu.org/prep/standards/standards.html).
  prefs: []
  type: TYPE_NORMAL
- en: Generating the toolchain
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After the introduction of the packages that comprise a toolchain, this section
    will introduce the steps needed to obtain a custom toolchain. The toolchain that
    will be generated will contain the same sources as the ones available inside the
    Poky dizzy branch. Here, I am referring to the `gcc` version 4.9, `binutils` version
    2.24, and `glibc` version 2.20\. For Ubuntu systems, there are also shortcuts
    available. A generic toolchain can be installed using the available package manager,
    and there are also alternatives, such as downloading custom toolchains available
    inside Board Support Packages, or even from third parties, including CodeSourcery
    and Linaro. More information on toolchains can be found at [http://elinux.org/Toolchains](http://elinux.org/Toolchains).
    The architecture that will be used as a demo is an ARM architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'The toolchain build process has eight steps. I will only outline the activities
    required for each one of them, but I must mention that they are all automatized
    inside the Yocto Project recipes. Inside the Yocto Project section, the toolchain
    is generated without notice. For interaction with the generated toolchain, the
    simplest task would be to call **meta-ide-support**, but this will be presented
    in the appropriate section as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The setup**: This represents the step in which top-level build directories
    and source subdirectories are created. In this step, variables such as `TARGET`,
    `SYSROOT`, `ARCH`, `COMPILER`, `PATH`, and others are defined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Geting the sources**: This represents the step in which packages, such as
    `binutils`, `gcc`, `glibc`, `linux kernel` headers, and various patches are made
    available for use in later steps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GNU Binutils setup** - This represents the steps in which the interaction
    with the `binutils` package is done, as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unzip the sources available from the corresponding release
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patch the sources accordingly, if this applies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure, the package accordingly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compile the sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install the sources in the corresponding location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linux kernel headers setup**: This represents the steps in which the interaction
    with the Linux kernel sources is presented, as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unzip the kernel sources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patch the kernel sources, if this applies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure the kernel for the selected architecture. In this step, the corresponding
    kernel config file is generated. More information about Linux kernel will be presented
    in [Chapter 4](part0031.xhtml#aid-TI1E1 "Chapter 4. Linux Kernel"), *Linux Kernel*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compile the Linux kernel headers and copy them in the corresponding location.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install the headers in the corresponding locations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Glibc headers setup**: This represents the steps used to setting the `glibc`
    build area and installation headers, as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unzip the glibc archive and headers files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patch the sources, if this applies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure the sources accordingly enabling the `-with-headers` variable to link
    the libraries to the corresponding Linux kernel headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compile the glibc headers files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install the headers accordingly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GCC first stage setup**: This represents the step in which the C runtime
    files, such as `crti.o` and `crtn.o`, are generated:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unzip the gcc archive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patch the gcc sources if necessary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure the sources enabling the needed features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compile the C runtime components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install the sources accordingly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build the glibc sources**: This represents the step in which the `glibc`
    sources are built and the necessary ABI setup is done, as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure the `glibc` library by setting the `mabi` and `march` variables accordingly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compile the sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install the `glibc` accordingly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GCC second stage setup**: This represents the final setup phase in which
    the toolchain configuration is finished, as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure the `gcc` sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compile the sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install the binaries in the corresponding location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After these steps are performed, a toolchain will be available for the developer
    to use. The same strategy and build procedure steps is followed inside the Yocto
    Project.
  prefs: []
  type: TYPE_NORMAL
- en: The Yocto Project reference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I have mentioned, the major advantage and available feature of the Yocto
    Project environment is represented by the fact that a Yocto Project build does
    not use the host available packages, but builds and uses its own packages. This
    is done to make sure that a change in the host environment does not influence
    its available packages and that builds are made to generate a custom Linux system.
    A toolchain is one of the components because almost all packages that are constituents
    of a Linux distribution need the usage of toolchain components.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step for the Yocto Project is to identify the exact sources and packages
    that will be combined to generate the toolchain that will be used by later built
    packages, such as U-Boot bootloader, kernel, BusyBox and others. In this book,
    the sources that will be discussed are the ones available inside the dizzy branch,
    the latest poky 12.0 version, and the Yocto Project version 1.7\. The sources
    can be gathered using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Gathering the sources and investigating the source code, we identified a part
    of the packages mentioned and presented in the preceding headings, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The GNU CC and GCC C compiler package, which consists of all the preceding
    packages, is split into multiple fractions, each one with its purpose. This is
    mainly because each one has its purpose and is used with different scopes, such
    as `sdk` components. However, as I mentioned in the introduction of this chapter,
    there are multiple toolchain build procedures that need to be assured and automated
    with the same source code. The available support inside Yocto is for gcc 4.8 and
    4.9 versions. A quick look at the `gcc` available recipes shows the available
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The GNU Binutils package represents the binary tools collection, such as GNU
    Linker, GNU Assembler, `addr2line`, `ar`, `nm`, `objcopy`, `objdump`, and other
    tools and related libraries. The Yocto Project offers support for the Binutils
    version 2.24, and is also dependent on the available toolchain build procedures,
    as it can be viewed from the inspection of the source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The last components is represented by C libraries that are present as components
    inside the Poky dizzy branch. There are two C libraries available that can be
    used by developers. The first one is represented by the GNU C library, also known
    as `glibc`, which is the most used C library in Linux systems. The sources for
    `glibc` package can be viewed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'From these sources, the same location also includes tools, such as `ldconfig`,
    a standalone native dynamic linker for runtime dependencies and a binding and
    cross locale generation tool. In the other C library, called `uClibc`, as previously
    mentioned, a library designed for embedded systems has fewer recipes, as it can
    be viewed from the Poky source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The uClibc is used as an alternative to `glibc` C library because it generates
    smaller executable footprints. At the same time, `uClibc` is the only package
    from the ones presented in the preceding list that has a `bbappend` applied to
    it, since it extends the support for two machines, `genericx86-64` and `genericx86`.
    The change between `glibc` and `uClibc` can be done by changing the `TCLIBC` variable
    to the corresponding variable in this way: `TCLIBC = "uclibc"`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned previously, the toolchain generation process for the Yocto Project
    is simpler. It is the first task that is executed before any recipe is built using
    the Yocto Project. To generate the cross-toolchain inside using Bitbake, first,
    the `bitbake meta-ide-support` task is executed. The task can be executed for
    the `qemuarm` architecture, for example, but it can, of course, be generated in
    a similar method for any given hardware architecture. After the task finishes
    the execution process, the toolchain is generated and it populates the build directory.
    It can be used after this by sourcing the `environment-setup` script available
    in the `tmp` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the `MACHINE` variable to the value `qemuarm` accordingly inside the `conf/local.conf`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The default C library used for the generation of the toolchain is `glibc`, but
    it can be changed according to the developer's need. As seen from the presentation
    in the previous section, the toolchain generation process inside the Yocto Project
    is very simple and straightforward. It also avoids all the trouble and problems
    involved in the manual toolchain generation process, making it very easy to reconfigure
    also.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you were presented with the necessary information needed to
    understand the constituent components of a Linux toolchain, and the steps undertaken
    by developers to work or configure a Linux toolchain that is specific for a board
    or architecture. You were also presented information on the packages available
    inside the Yocto Project sources, and how the processes defined inside the Yocto
    Project are very similar to the ones already used outside of the Yocto Project
    context.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will breeze through information on bootloaders, with
    special emphasis given to U-Boot bootloader. You will also be given information
    on a boot sequence and a board's configurations inside the U-Boot sources.
  prefs: []
  type: TYPE_NORMAL
