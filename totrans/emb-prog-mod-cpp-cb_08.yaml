- en: Communication and Serialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Complex embedded systems are rarely composed of a single application. Having
    all the logic in the same application is brittle, error-prone, and sometimes hardly
    feasible because different functions of the system may be developed by different
    teams and even different vendors. That is why isolating the logic of the functions
    in standalone applications and communicating with each other using a well-defined
    protocol is a common approach used to scale embedded software. In addition, this
    kind of isolation can be used with minimal modifications to communicate with applications
    hosted on remote systems, making it even more scalable. We will learn how to build
    robust and scalable applications by splitting their logic into independent components
    that communicate with each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using inter-process communication in applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the mechanisms of inter-process communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about message queue and publisher-subscriber models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using C++ lambdas for callbacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring data serialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the FlatBuffers library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The recipes in this chapter will help you understand the basic concepts of scalable
    and platform-independent data exchange. They can be used to implement data transfer
    from an embedded system to the cloud or to a remote backend, or to design an embedded
    system using microservice architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Using inter-process communication in applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most modern operating systems use memory virtualization support provided by
    the underlying hardware platform to isolate application processes from each other.
  prefs: []
  type: TYPE_NORMAL
- en: Each process has its own virtual address space that is completely independent
    of the address spaces of other applications. This provides huge benefits to developers.
    Since the address processes of applications are independent, an application cannot
    accidentally corrupt the memory of another application. As a result, a failure
    in one application does not affect the whole system. Since all the other applications
    keep working, the system can recover by restarting the failing application.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of memory isolation come at a cost. Since one process cannot access
    the memory of another, it needs to use a dedicated **A****pplication Program Interface** (**API**)
    for data exchange, or **inter-process communication **(**IPC**), which is provided
    by the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to exchange information between two processes
    using shared files. It may not be the most performance-efficient mechanism, but
    it is ubiquitous, easy to use, and good enough for various practical use cases.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will create a sample application that creates two processes.
    One process generates data while another reads the data and prints it to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: In your working directory (`~/test`), create a subdirectory called `ipc1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use your favorite text editor to create an `ipc1.cpp` file in the `ipc1` subdirectory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We are going to define two templated classes to organize our data exchange.
    The first class, `Writer`, is used to write data into a file. Let''s put its definition
    in the `ipc1.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is followed by the definition of the `Reader` class, which is responsible
    for reading data from a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define the data type that we will use for our data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To wrap everything together, we define the `DoWrites` and `DoReads` functions,
    as well as the `main` function that invokes them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, create a `CMakeLists.txt` file containing the build rules for our
    program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can now build and run the application.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our application, we explore data exchange between two independent processes
    using a shared file in a filesystem. One process writes data to a file, another
    reads data from the same file.
  prefs: []
  type: TYPE_NORMAL
- en: Files can store any unstructured sequences of bytes. In our application, we
    utilize the C++ templates' capabilities to work with strictly typed C++ values
    rather than raw byte streams. This approach helps in writing clean and error-free
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with a definition of the `Write` class. It is a simple wrapper on
    top of the standard C++ `fstream` class used for file input/output. The constructor
    of the class only opens a file stream to write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides the constructor, the class contains only one method, `Write`, which
    is responsible for writing data to a file. Since the file API operates with byte
    streams, we first need to convert our templated data type into a raw character
    buffer. We can do this using the C++ `reinterpret_cast`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Reader` class does the opposite job—it reads data written by the `Writer` class.
    Its constructor is a bit more complicated. Since the data file might not be ready
    by the time the instance of the `Reader` class is created, the constructor tries
    to open it in a loop until an open attempt succeeds. It makes `10` attempts with
    10-millisecond pauses between each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Read` method reads data from the input stream into a temporary value and
    returns it to the caller. Similar to the `Write` method, we use `reinterpret_cast`
    to access the memory of our data objects as raw character buffers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We also add a wait loop into the `Read` method to wait for data being written
    by `Write`. If we reach the end of the file, we wait for up to 1 second for new
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If data is not available in the file at this point, or in the case of an I/O
    error, we throw an exception to indicate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Please note that we do not need to add any code to handle a situation where
    a file cannot be opened within 1 second, or data is not ready within one second.
    Both of these cases are handled by the same preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the `Writer` and `Reader` classes are implemented, we can define a
    data type for our data exchange. In our application, we will exchange coordinates,
    represented as the `x` and `y` integer values. Our data message looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'For convenience, we override the `<<` operator for our `Message` structure.
    Any time an instance of `Message` is written to an output stream, it is formatted
    as `(x, y)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'With all the preparations in place, let''s write the functions for data exchange.
    The `DoWrites` function defines a vector of four coordinates and creates a `Writer`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, it writes all the coordinates in a loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DoReads` function, in turn, creates an instance of the `Reader` class
    using the same filename as the `Writer` instance before it. It enters an endless
    loop, trying to read all the messages in the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When no more messages are available, the `Read` method throws an exception
    that breaks the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main` function creates two independent processes, running `DoWrites` in
    one of them and `DoReads` in another. After running the application, we get the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f5ce532-4e3c-401e-8716-87f43e5d0c8c.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the writer did write four coordinates and the reader was able
    to read the same four coordinates using a shared file.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We created our application to be as simple as possible, focusing on strictly
    typed data exchange and leaving data synchronization and data serialization out
    of the scope. We are going to use this application as a foundation for more advanced
    techniques, which will be described in the recipes that follow.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the mechanisms of inter-process communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Modern operating systems provide a number of IPC mechanisms beyond the shared
    files we have already learned about, namely the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Pipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Named pipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shared memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is interesting that many of them provide exactly the same API that we use
    when working with regular files. As a result, switching between these types of
    IPC is trivial and the same code that we used to read and write to local files
    can be used to communicate with applications running on a remote network host.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use Portable Operating System Interface
    (**POSIX**) named pipes to communicate between two applications that reside on
    the same computer.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to use the source code of the application we created as part of
    the *Using inter-process communication in applications *recipe as a starting point
    for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will start with the source code that uses regular files
    for IPC. We will modify it to use an IPC mechanism called **named pipes**:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the contents of the `ipc1` directory into a new directory called `ipc2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `ipc1.cpp` file and add two more `include` instance after `#include
    <unistd.h>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the `Write` method of the `Writer` class by adding one more line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Modifications in the `Reader` class are more substantial. Both the constructor
    and the `Read` method are affected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a small change to the `DoWrites` function. The only difference is we add
    a 10 millisecond delay after sending each message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, modify our `main` function to create a named pipe instead of a regular
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You can now build and run the application.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you can see, we introduced a minimal number of changes to the code of our
    application. All the mechanisms and the API for reading and writing data remain
    the same. The crucial difference hides behind a single line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This line creates a special type of file called `named pipe`. It looks like
    a regular file—it has a name, permission attributes, and a modification time.
    However, it does not store any real data. Everything written to this file is immediately
    delivered to the processes that read from this file.
  prefs: []
  type: TYPE_NORMAL
- en: This difference has a number of consequences. Since no real data is stored in
    the file, all reading attempts are blocked until any data is  written. Similarly,
    writes are blocked until previous data is read by the readers.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, there is no further need for external data synchronization. Take
    a look at the `Reader` class implementation. It does not have a retry loop in
    the constructor or in the `Read` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test that we really do not need to use any additional synchronization, we
    added an artificial delay after writing each of the messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When we build and run the application, we can see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f71e499-25db-4757-96ab-21a9a119babf.png)'
  prefs: []
  type: TYPE_IMG
- en: Each `Write` method is followed by the proper `Read` method, despite the fact
    that we did not add any delays or checks anywhere in the `Reader` code. The IPC
    mechanisms of the operating system take care of data synchronization transparently
    for us, leading to cleaner and more readable code.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see, working with named pipes is as simple as working with regular
    functions. A socket API is another widely used mechanism of IPC. It is a little
    bit more complex but provides more flexibility. By choosing different transport
    layers, developers can use the same socket APIs for both local data exchange and
    for network connectivity with remote hosts.
  prefs: []
  type: TYPE_NORMAL
- en: More information about socket APIs can be found at [http://man7.org/linux/man-pages/man7/socket.7.html](http://man7.org/linux/man-pages/man7/socket.7.html.).
  prefs: []
  type: TYPE_NORMAL
- en: Learning about message queue and publisher-subscriber models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the IPC mechanisms provided by POSIX operating systems are quite basic.
    Their APIs are built using file descriptors and they treat input and output channels
    as raw sequences of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Applications, however, tend to use data fragments of specific lengths and purposes
    for data interchange messages. Despite API mechanisms of operating systems being
    flexible and generic, they are not always convenient for message exchange. That
    is why dedicated libraries and components were built on top of default IPC mechanisms
    to simplify the message exchange mode.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to implement an asynchronous data exchange
    between two applications using the **publisher-subscriber** (**pub-sub**) model.
  prefs: []
  type: TYPE_NORMAL
- en: The model is easy to understand and widely used for the development of software
    systems designed as collections of independent, loosely coupled components communicating
    with each other. The isolation of functions and asynchronous data exchange allows
    us to build flexible, scalable, and robust solutions.
  prefs: []
  type: TYPE_NORMAL
- en: In the pub-sub model, applications act as publishers, subscribers, or both.
    Instead of sending requests to particular applications and expecting them to respond,
    an application can publish a message to a specific topic or subscribe to receive
    messages on a topic it is interested in. When publishing a message, the application
    does not care how many subscribers are listening to the topic. Similarly, a subscriber
    does not know which application is going to send a message on a particular topic
    or when to expect it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The application we created as part of the *Exploring the mechanisms of IPC* recipe
    already contains a number of building blocks we can reuse to implement the pub/sub
    communication.
  prefs: []
  type: TYPE_NORMAL
- en: The `Writer` class can act as a publisher and the `Reader` class as a subscriber.
    We implemented them to handle the strictly defined data types that will define
    our messages. The named pipes mechanism we used in the preceding recipe works
    on a byte level and does not guarantee that messages are delivered automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'To overcome this limitation, we will use the POSIX message queue API instead
    of the named pipes. A name used to identify a message queue that both `Reader`
    and `Writer` will accept in their constructors will be used as a topic:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the contents of the `ipc2` directory that we created in the previous recipe
    into a new directory: `ipc3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s create a C++ wrapper for the POSIX message queue API. Open `ipc1.cpp` in
    your editor and add the required header files and constant definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, define a `MessageQueue` class. This holds a message queue handle as its
    private data member. We can use constructors and destructors to manage the opening
    and closing of the handle in a safe manner using the C++ RAII idiom:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define two simple methods to write messages into and read messages
    from the queue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We now modify our `Writer` and `Reader` classes to work with the new API. Our
    `MessageQueue` wrapper does most of the heavy lifting and the code changes are
    minimal. The `Writer` class now looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Modifications in the `Reader` class are more substantial. We make it act as
    a subscriber and we encapsulate the logic that fetches and handles messages from
    the queue directly into the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we still want to keep the `Reader` class as generic as possible, we will
    define a new class (`CoordLogger`), which is derived from `Reader`, to define
    the specific handling of our messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DoWrites` code remains mostly the same; the only change is that we use
    a different constant to identify our queue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the message handling logic was moved to the `Reader` and `CoordLogger`
    classes, `DoReads` is now as simple as this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The updated `main` function follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, our application needs to be linked with the `rt` library. We do this
    by adding one line into our `CMakeLists.txt` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You can now build and run the application.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our application, we reused a lot of the code from the application we created
    in the preceding recipe, *Exploring the mechanisms of IPC*. To implement the pub-sub
    model, we need to make two important changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Make our IPC message-based. We should be able to send and receive messages automatically.
    Messages sent by one publisher should not break messages sent by other publishers
    and subscribers should be able to read messages as a whole.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let subscribers define the callbacks that are invoked as soon as a new message
    is available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To make message-based communication, we switch from the named pipes to the POSIX
    message queue API. The message queue API differs from the regular file-based API
    of named pipes, which is why we implement a C++ wrapper on top of the plain C
    interface provided by the Linux standard library.
  prefs: []
  type: TYPE_NORMAL
- en: The main goal of the wrapper is to provide safe resource management using the **Resource
    Acquisition Is Initialization** (**RAII**) idiom. We do this by defining the constructors
    that acquire the queue handler by calling `mq_open` and the destructor that releases
    it using `mq_close`. This way, the queue is automatically closed when the corresponding
    instance of the `MessageQueue` class is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: The wrapper class has two constructors. One constructor is used to open an existing
    queue. It accepts two parameters—a queue name and access flags. The second constructor
    is used to create a new queue. It accepts two additional parameters—a message
    length and the maximal size of a message in the queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our application, we create a queue in the `main` function, passing `10`
    as the number of messages that can be stored in the queue. The size of the `Message` structure is
    the maximum size of the message in our queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Then, the `DoWrites` and `DoReads` functions open the queue already created
    with the same name.
  prefs: []
  type: TYPE_NORMAL
- en: Since the public API for our `MessageQueue` class is similar to the `fstream`
    interface we used for IPC using named pipes, it requires only minimal changes
    in the writer and reader to make them work with another IPC mechanism. We use
    an instance of `MessageQueue` instead of `fstream` as a data member, keeping other
    logic unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: 'To let subscribers define their callback methods, we need to modify the `Reader`
    class. Instead of a `Read` method that reads and returns a single method, we introduce
    the `Run` method. It loops over all the messages available in the queue. For each
    method being read, it invokes a callback method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Our goal is to keep the `Reader` class generic and reusable for different types
    of messages. However, there is no such thing as a generic callback. Each callback
    is specific and should be defined by users of the `Reader` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to resolve this contradiction is by making `Reader` an abstract class.
    We define our `Callback` method as a `virtual` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, since `Reader` is abstract, we cannot create instances of this class.
    We have to inherit it and provide a definition of the `Callback` method in a derived
    class named `CoordLogger`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note that since the `Reader` constructor accepts a parameter, we need
    to define constructors in the inherited class as well. We''ll use the inheriting
    constructors that were added in the C++11 standard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, having a `CoordLogger` class that is capable of handling the messages
    of the `Message` type, we can use it in our `DoReads` implementation. We only
    need to create an instance of this class and invoke its `Run` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the application, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39b06101-cfed-4a08-9bdd-53fe51e643b6.png)'
  prefs: []
  type: TYPE_IMG
- en: This output is not that different from the output from the preceding recipe,
    but now the implementation is much more scalable. The `DoReads` method does not
    do anything specific to messages. Its only task is to create and run subscribers.
    All data handling is encapsulated in specific classes. You can add, replace, and
    combine publishers and subscribers without changing the architecture of the application.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The POSIX message queue API provides basic functionality for message queues
    but it also has a number of limitations. It is not possible to send a message
    to multiple subscribers using one message queue. You have to create a separate
    queue for each subscriber, otherwise only one of the subscribers reading from
    a queue will receive the message.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of elaborated message queues and pub-sub middleware available
    in the form of external libraries. ZeroMQ is a powerful, flexible and—at the same
    time—lightweight transport library. This makes it an ideal choice for embedded
    applications that are built using the pub-sub model of data exchange.
  prefs: []
  type: TYPE_NORMAL
- en: Using C++ lambdas for callbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the pub-sub model, a subscriber usually registers a callback that is being
    invoked when a message from a publisher is delivered to the subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding recipe, we created a mechanism to register callbacks using
    inheritance and abstract classes. It is not the only mechanism available in C++. Lambda
    functions available in C++, starting from the C++11 standard, can be used as an
    alternative solution. This eliminates lots of boilerplate code needed to define
    derived classes and, in most cases, allows developers to express their intent
    in a clearer way.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use C++ lambda functions to define callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to use most of the code from the preceding recipe, *Learning about
    message queue and publisher-subscriber models*. We will modify the `Reader` class
    to accept a callback as a parameter. With this modification, we can use `Reader`
    directly and do not need to rely on inheritance to define a callback:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the contents of the `ipc3` directory that we created in the preceding recipe
    into a new directory: `ipc4`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Keep all the code unchanged, except for the `Reader` class. Let''s replace
    that with the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that our `Reader` class is changed, we can update the `DoReads` method.
    We can use a lambda function to define a callback handler and pass it to the `Reader` constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `CoordLogger` class is not needed anymore, so we can safely remove it from
    our code entirely.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can build and run the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we modified the preceding defined `Reader` class to accept
    an additional parameter in its constructor. This parameter has a specific data
    type—a pointer to a function, which will be used as a callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The handler is stored in the data field for future use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, every time the `Run` method reads a message, it invokes the function stored
    in the `func` field, rather than the `Callback` method that we need to override:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Getting rid of the `Callback` function makes `Reader` a concrete class and we
    can create its instance directly. However, now we need to provide a handler as
    a parameter of its constructor.
  prefs: []
  type: TYPE_NORMAL
- en: With plain C, we would have to define a `named` function and pass its name as
    a parameter. With C++, this approach is also possible, but C++ also provides the
    mechanism of anonymous functions or lambda functions, which can be defined right
    in-place.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `DoReads` method, we create a lambda function and pass it directly to
    the `Reader` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Building and running the application produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c9b5c11-a5ea-4454-8e09-6d3b1ff2e1cd.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, it is identical to the output of the application we created in
    the preceding recipe. However, we do it with less code and in a more readable
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda functions should be used wisely. They make the code more readable if
    kept minimal. If a function grows bigger than five lines, consider using a named
    function instead.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ provides flexible mechanisms for working with function-like objects and
    binds them with parameters. These mechanisms are widely used to forward calls
    and build function adapters. The *Function objects* page at [https://en.cppreference.com/w/cpp/utility/functional](https://en.cppreference.com/w/cpp/utility/functional) is
    a good starting point to get a deeper understanding of these topics.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring data serialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already briefly touched on some aspects of serialization in [Chapter 3](b89bff48-21be-4288-af10-de42f182d426.xhtml), *Working
    with Different Architectures*. When it comes to data exchange, serialization is
    crucial. The task of serialization is to represent all data being sent by the
    sender application in a way that can be unambiguously read by the receiver application.
    This task is not that straightforward, given that the sender and the receiver
    may be running on different hardware platforms and connected over a variety of
    transport links—a **Transmission Control Protocol**/**Internet Protocol** (**TCP/IP**) network,
    a **Serial Peripheral Interface** (**SPI**) bus, or a serial link.
  prefs: []
  type: TYPE_NORMAL
- en: There are many different ways of implementing serialization depending on requirements,
    which is why the C++ standard library does not provide it out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to implement simple generic serialization
    and deserialization in a C++ application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The goal of serialization is to encode any data in a way that can be properly
    decoded on another system or in another application. The typical obstacles for
    developers are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Platform-specific differences, such as data alignment and endianness.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data scattered across memory; for example, elements of a linked list can be
    located far away from each other. The representation of disconnected blocks linked
    by pointers is natural for memory but cannot be automatically translated into
    a sequence of bytes when transferring it to another process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A generic approach to this problem is letting a class define the functions to
    convert its content into a serialized form and restore an instance of a class
    from the serialized form.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our application, we will overload `operator<<` of the output stream and `operator>>`
    of the input stream to serialize and deserialize data respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: In your `~/test` working directory, create a subdirectory called `stream`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use your favorite text editor to create a `stream.cpp` file in the `stream` subdirectory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start with the definition of the data structures that you want to serialize:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we overload the `<<` and `>>` operators that are responsible for writing
    and reading the `Point` objects into and from a stream respectively. For the `Point`
    data type enter the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'They are followed by the `<<` and `>>` overloaded operators for the `Paths`
    objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s wrap everything up in the `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, create a `CMakeLists.txt` file containing the build rules for our
    program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: You can now build and run the application.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our test application, we defined a data type to represent paths from a source
    point to multiple destination points. We intentionally used hierarchical structures
    scattered in memory to demonstrate how to approach this problem in a generic way.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we do not have specific requirements for performance, one of the possible
    approaches to serialization is storing data in text format. Besides its simplicity,
    it has two major advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Text encoding automatically resolves all issues related to endianness, alignment,
    and the size of integer data types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is readable by humans. Developers can use serialized data for debugging without
    any additional tools.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To work with text representation, we can use the input and output streams provided
    by the standard library. They already define functions to write and read formatted
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: The `Point` structure is defined as two integer values: `x` and `y`. We override
    `operator<<` for this data type to write the `x` and `y` values followed by spaces.
    This way, we can read them sequentially in the overridden `operator>>` operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Path` data type is a bit trickier. It contains a linked list of destinations.
    Since the size of the list may vary, we need to write the actual size of the list
    before serializing its content to be able to recover it properly during deserialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we have the `Point` methods for the `<<` and `>>`  operators already
    overridden, we can use them in the `Paths` methods. This way, we write the `Point`
    objects to a stream or read them from a stream without knowing the contents of
    their data fields. Hierarchical data structures are handled recursively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we test our implementation of serialization and deserialization. We
    create a sample instance of the `Paths` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we serialize its content into a string using the `std::stringstream`
    data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create an empty `Path` object and deserialize the content of the string
    into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we check whether they match. When we run the application, we can use
    the following output to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f862eddd-5a3d-4234-8b4b-7edb0bf4c0ac.png)'
  prefs: []
  type: TYPE_IMG
- en: The size of the `destinations` list of the restored object matches the size
    of the `destinations` list of the original object. We can also see the content
    of the serialized data.
  prefs: []
  type: TYPE_NORMAL
- en: This example shows how to build custom serialization for any data type. It can
    be done without any external libraries. However, in cases where performance and
    memory efficiency matter, using third-party serialization libraries would be a
    more practical approach.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing serialization from scratch is difficult. The cereal library at [https://uscilab.github.io/cereal/](https://uscilab.github.io/cereal/) and
    the boost library at [https://www.boost.org/doc/libs/1_71_0/libs/serialization/doc/index.html](https://www.boost.org/doc/libs/1_71_0/libs/serialization/doc/index.html)
    provide a foundation that helps you to add serialization to applications much
    faster and more easily.
  prefs: []
  type: TYPE_NORMAL
- en: Using the FlatBuffers library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Serialization and deserialization is a complex topic. While ad hoc serialization
    may look simple and straightforward, it is difficult to make it generic, easy
    to use, and fast. Thankfully, there are libraries that handle all of these complexities.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will learn how to use one of the serialization libraries:
    FlatBuffers. It was designed with embedded programming in mind, making serialization
    and deserialization memory efficient and fast.'
  prefs: []
  type: TYPE_NORMAL
- en: FlatBuffers uses an **Interface Definition Language** (**IDL**) to define a
    data schema. The schema describes all the fields of data structures that we need
    to serialize. When the schema is designed, we use a special tool called **flatc**
    to generate the code for a particular programming language, which is C++ in our
    case.
  prefs: []
  type: TYPE_NORMAL
- en: The generated code stores all data in serialized form and provides developers
    with so-called **getter** and **setter** methods to access the data fields. The
    getters perform deserialization on the fly. Storing data in its serialized form
    makes FlatBuffers really memory efficient. There is no need for extra memory to
    store serialized data and, in most cases, the overhead of deserialization is low.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to start using FlatBuffers for data serialization
    in our applications.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'FlatBuffers is a set of tools and libraries. Before using it, we need to download
    and build it:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the most recent archive of FlatBuffers, available at [https://codeload.github.com/google/flatbuffers/zip/master](https://codeload.github.com/google/flatbuffers/zip/master),
    and extract it in the `test` directory. This will create a new directory called
    `flatbuffers-master`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Switch to the build console, change the directory to `flatbuffers-master`,
    and run the following commands to build and install the library and tools. Make
    sure you run as root. If not, press *Ctrl* + *C* to exit the user shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are ready to use FlatBuffers in our application. Let''s reuse an application
    we created in one of the previous recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the contents of the `ipc4` directory into the newly created directory named
    `flat`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file named `message.fbs`, open it in an editor, and put in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Generate the C++ source code from `message.fbs` by running the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This will create a new file called `message_generated.h`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `ipc1.cpp` in your editor. Add an `include` directive for the generated `message_generated.h`
    file after the `mqueue.h` include:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Now, get rid of the `Message` struct declared in our code. We are going to use
    the structure generated in the FlatBuffers schema file instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since FlatBuffers uses getter methods instead of direct access to the structure
    fields, we need to modify the body of the redefined `operator<<` operation we
    used to print point data to the console. The changes are minimal—we only add parentheses
    to each data field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The code modifications are done. Now, we need to update the build rules to
    link with the FlatBuffers library. Open `CMakeLists.txt` and put in the following
    lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Switch to the build console, then change to the user shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Build and run the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: FlatBuffers is an external library that is not available in the Ubuntu repository
    of packages, which is why we need to download, build, and install it first. After
    the installation is done, we can use it in our application.
  prefs: []
  type: TYPE_NORMAL
- en: We use an existing application we created for the *Using C++ lambdas for callbacks* recipe
    as a starting point. In that application, we defined a structure, called `Message`,
    to represent a type of data we use for IPC. We are going to replace it with a
    new data type provided by FlatBuffers. This new data type will perform all the
    necessary serialization and deserialization transparently for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'We remove the definition of the `Message` struct from our code completely.
    Instead, we generate a new header file, called `message_generated.h`. This file
    is generated from the `message.fbs` FlatBuffers schema file. This schema file
    defines a structure with two integer fields—`x` and `y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This definition is identical to our preceding definition; the only difference
    is the syntax—FlatBuffers' schema uses a colon to separate field names from the
    field types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once `message_generated.h` is created by the `flatc` command invocation, we
    can use it in our code. We add the proper `include` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The generated message is identical to the message structure we used before but
    as we discussed earlier, FlatBuffers stores data in serialized form and needs
    to deserialize it on the fly. That is why, instead of direct access to the data
    fields, we have to use the `x()` accessor method instead of just `x` and the `y()` accessor
    method instead of just `y`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only place we use direct access to the message data field is in the overridden
    `operator<<` operation. We add parentheses to turn direct field access into the
    invocation of the FlatBuffers getter methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s build and run the application. We will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/96e44321-cffb-4c7f-9989-b51539a077ff.png)'
  prefs: []
  type: TYPE_IMG
- en: The output is the same as for our custom message data type. With only a few
    modifications in our code, we migrated our messages to FlatBuffers. Now, we can
    run our publishers and subscribers on multiple computers—which can have different
    architectures—and be sure that each of them interprets messages correctly.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides FlatBuffers, there are a number of other serialization libraries and
    techniques, each having its own pros and cons. Refer to the *C++ Serialization
    FAQ* at [https://isocpp.org/wiki/faq/serialization](https://isocpp.org/wiki/faq/serialization)
    for a better understanding of how to design serialization in your applications.
  prefs: []
  type: TYPE_NORMAL
