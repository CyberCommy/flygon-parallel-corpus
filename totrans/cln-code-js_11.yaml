- en: Parts of Syntax and Scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will continue to explore JavaScript's syntax and constructs.
    We'll be delving into the fundamentals of expressions, statements, blocks, scopes,
    and closures. These are the less visible parts of the language. Most programmers
    assume that they already have a good grasp of how things such as expressions and
    scopes work, but, as we've seen, our intuitions of how things should work may
    not always align with how they truly do work. The constructs we'll be learning
    about in this chapter are the crucial larger building blocks of our programs,
    so it is of vital importance to understand them fully before we explore more abstract
    concepts such as control flow and design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Why are we learning this now?We've now got a solid grasp of what types are available
    in JavaScript and how to manipulate them via operators. The next logical step
    is to study *syntactic scaffolding* components, where we can place these types
    and operations, and how these scaffolding components behave. The end goal here
    is a high level of fluency in JavaScript so that we are better able to write clean
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we''re going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Expressions, statements, and blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scopes and declarations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expressions, statements, and blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are broadly three types of syntactic **container **that exist within
    JavaScript: expressions, statements, and blocks. They are all containers in that
    they all hold other pieces of syntax and all have distinct behaviors that are
    worth distinguishing.'
  prefs: []
  type: TYPE_NORMAL
- en: There are additional constructs that you can call containers, such as functions
    or modules, but for now we're only interested in the types of syntax that you
    would find *within* these. As we continue to explore the language, we are slowly
    *zooming out* all the way from granular operators and expressions to the much
    larger and more complex functions and programs in which they reside.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s best to visualize the individual syntactic parts of a program as a hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a2d15faa-d5e6-45fb-a416-a0639b87aefc.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we can see that individual **expressions **(with a lower border) are wrapped
    in **statements**, either of the **regular **or **block **variety. It's useful
    to always have this hierarchical view of the language in our mind as this is how
    our code will be parsed and understood by the machine. We don't need to see our
    code as a parser would, of course, but it's indisputably useful to know how our
    code will be parsed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This hierarchical view of the language will also help us write programs that
    communicate their intent well to our fellow programmers. Hierarchy is not only
    a syntactic concern but a human one. When we write a program, we will typically
    model problems at different layers of abstraction: each part of a program goes
    within another part, and from all these individual parts, we can build a program
    that contains many different layers of complexity.'
  prefs: []
  type: TYPE_NORMAL
- en: As we explore the syntactic parts of JavaScript, it's worth remembering how
    individual elements of a program's syntax, its expressions and statements, will
    have a natural symmetry with the individual elements and layers of the problem
    domain.
  prefs: []
  type: TYPE_NORMAL
- en: Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An expression is the most granular type of syntactic container. We''ve already
    been working a lot with expressions. Even expressing a literal value, like the
    number `1`, will produce an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Using an operator also forms an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, we can consider an operator as something that is itself applied to
    expressions. So the addition operator''s syntax can be understood like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'An expression can be as simple as a literal value or a variable reference,
    but may also be complex. The following expression encompasses a series of operations
    and is spread over a few lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Expressions are not limited to primitive types or simple literal values. Class definitions, function
    expressions, array literals, and object literals are all things that can appear
    in the context of an expression. The easy way to know whether something is an
    expression is the question of whether or not it can go within a group operator
    (that is, parentheses) without causing a `SyntaxError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntactic building blocks of any program involve various different layers
    of syntactic structures. We have individual values and references: if we zoom
    out a little bit, we have expressions, and if we zoom out even further we have
    statements, which we will now explore.'
  prefs: []
  type: TYPE_NORMAL
- en: Statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **statement** contains an expression, and is, therefore, another type of syntactic
    container. Knowing how JavaScript sees expressions as distinct from statements
    is hugely helpful in avoiding the various traps and idiosyncrasies of the language.
  prefs: []
  type: TYPE_NORMAL
- en: 'A statement is formed in a variety of situations. These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: When you terminate an expression with a semicolon (`1 + 2;`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you use any of the `for`, `while`, `switch`, `do..while`, or `if` constructs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you create a function via a function declaration (`function Something()
    {}`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are automatically formed by the language's natural **automatic semicolon
    insertion** (**ASI**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The syntax of a function declaration (`function name() {}`) will always form
    a statement unless it appears in the context of an expression, in which case it'll
    naturally be a *named function expressio**n*. For the nuanced differences between
    these, please revisit [Chapter 6](ae94cc02-a077-4ffb-903a-b9ec222a2a09.xhtml)*,* *Primitive
    and Built-In Types*.
  prefs: []
  type: TYPE_NORMAL
- en: Forming statements with semicolons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we place one expression after another, we tend to terminate each individual
    one with a semicolon. By doing this, we are forming a statement. Explicitly terminating
    a statement ensures that the JavaScript parser will not have to do so automatically.
    If you don't use semicolons, then the parser will guess where to insert them via
    a process called ASI. This process relies on our placement of new lines (that
    is, `\n`).
  prefs: []
  type: TYPE_NORMAL
- en: 'As ASI is automatic, it won''t always provide the outcomes you desire. For
    example, consider the following case where there is a function expression followed
    by a syntax that is intended as a group (that is, an expression delimited by parentheses):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will cause a mysterious `TypeError` that says: `Cannot read property join
    of undefined`. This is because, from the parser''s point of view, the following
    is what we''re doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''re creating an inline anonymous function and then immediately calling
    it, passing the `[1, 2, 3]` array as our sole argument, and then we''re attempting
    to invoke the `join` method on whatever''s returned. But as our function returns `undefined`,
    there is no `join` method there, and so we receive an error. This is a rare situation,
    but variations of this issue do crop up from time to time. The best way to avoid
    them is to consistentlyuse semicolons to terminate lines that are intended as
    statements, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'ASI can bite you in other ways as well. A common example is when you attempt
    to use a `return` statement within a function, with its intended return value
    on the next line. In such cases, you''ll get a nasty surprise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'JavaScript''s ASI mechanism will presume that the `return` statement is terminated
    if there is nothing else present on the same line, and so the following is closer
    to what the JavaScript engine will see when running the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To fix this, we can either place `a + b` on the same line as our `return` statement
    or we can use a group operator to contain our indented expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It's not necessary to know every ASI  rule, but it is very useful to know that
    it exists. The best way of working with ASI is to avoid it wherever possible.
    If you're explicit about the termination of your statements, then you won't need
    to rely on obscure ASI rules, and you won't be relying on your fellow programmers
    knowing these rules either.
  prefs: []
  type: TYPE_NORMAL
- en: Blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we consider statements as containers of expressions, then we can consider blocks as
    containers of statements. In other languages, they are sometimes called **compound
    statements** as they allow several statements to exist together.
  prefs: []
  type: TYPE_NORMAL
- en: Strictly speaking, blocks are statements. From a language-design perspective,
    this is a useful thing because it allows statements that form part of other constructs
    to be expressed as either single-line statements or entire blocks containing several
    statements—for example, following `if(...)` or `for(...)` constructs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Blocks are formed by delimiting zero or more statements with curly braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Blocks are very rarely used as completely isolated units of code (there''s
    very limited benefit from doing so). You''ll usually find them within `if`, `while`, `for` and `switch` statements,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `{...}` part of the `while` loop here is a block. It is not an inherent
    part of the `while` syntax. If we wish to, we can entirely exclude the block and
    in its place just have a regular single-line statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: That would be identical to the version in which we use a block, but obviously
    this would be limiting if we intend to add more iteration logic. As a result,
    it's usually preferable to preemptively use a block in such scenarios. Doing so
    has the added benefit of legitimizing indentation and the containment of the iteration
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Blocks are not only syntactic containers. They affect the runtime of our code
    as well by providing their own scope, which means that we can declare variables
    within via `const` and `let` statements. Observe here how we declare a variable
    within an `if` block and how it is not available outside that block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Scoping is a topic that we should not take lightly. It can be quite difficult
    to understand, and so what follows is an entire section in which we explore its
    nature and nuances.
  prefs: []
  type: TYPE_NORMAL
- en: Scopes and declarations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The scope of a given variable can be thought of as the areas within the program
    where that variable can be accessed.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we declare a variable at the beginning of a module (outside all functions),
    we think that it''s only natural that this variable should then be accessible
    to all functions within the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'And if we define a variable within a function, then we expect all inner functions
    to have access to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The fact that we can access `value` in the `doSomething` function here is thanks
    to its scope. The scope of a given variable will depend on how it is declared.
    When you declare a variable via a `var` declaration, it will have a different
    potential scope to a variable created via a `let` declaration. We will cover these
    differences soon, but first, it's useful to have a clearer idea of how scopes
    operate internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Internally, when you declare variables, JavaScript will create and store that
    variable within a lexical environment, which contains the mappings of identifiers
    to values. A typical JavaScript program can be thought of as having four types
    of lexical environments, as shown in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The global environment**: There is only one of these, and it is considered
    the outer scope of all other scopes. It is the global context in which all other
    environments (that is, scopes) exist. The global environment mirrors a global
    object that can be referred to by `window` or `self` in the browser and `global` in
    Node.js.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A module environment**: This environment will be created for each distinct
    JavaScript module that is run as part of a singular Node.js process or for each `<script
    type="module">` in the browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A function environment**: This environment will be in effect for every running
    function, however it is declared or invoked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A block environment**: This environment will be in effect for every block
    (`{...}`) in your program, whether following another language construct, such
    as `if(...)` or `while(...)`, or situated independently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you know, both functions and blocks can exist within other functions and
    blocks. Consider the following piece of code that expresses various environments
    (scopes):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'At the point where `Done Rendering!` is logged, we may expect the hierarchy
    of environments to look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This hierarchy of environments will change throughout the runtime of a given
    program. If a function is run to completion and its internal scope is no longer
    used in any exposed internal functions (known as **closures**), then the lexical
    environment will be destroyed. Essentially, when a scope is guaranteed to no longer
    be needed, then JavaScript is free to get rid of it.
  prefs: []
  type: TYPE_NORMAL
- en: Variable declarations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A variable declaration occurs via a `var` keyword followed by a valid identifier
    or an assignment of the form `a = b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We call things declared via `var` keyword variable declarations, but it's important
    to note that, in popular terminology, declarations made by both `let` and `const` are
    also considered variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables declared via `var` are scoped to the nearest function, module, or global environment—that
    is, they are not block-scoped. At parse time, variable declarations within a given
    scope will be collected and then, at the point of execution, those declared variables
    will be hoisted to the top of their execution context and initialized with the `undefined` value.
    This means that, within a given scope, technically you can access a variable prior
    to its assignment, but it''ll be `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The **execution context** is a name given to the top of the call stack, meaning
    the currently running function, script, or module. It is a concept that is only
    seen when code is run, and will change as the program progresses. You can usually
    think of it as simply the currently-running function (or outer module or `<script>`). `var` declarations
    are always hoisted to the top of their execution context and initialized to `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The hoisting behavior of `var` is in contrast to variables declared via `let` and `const`,
    which will produce an `ReferenceError` if you attempt to access them prior to
    their declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''re not careful, the hoisting behavior of `var` can lead to some unexpected
    results. For example, there may be a situation where you''re attempting to refer
    to a variable that exists within the outer scope but you are unable to do so because
    of a variable declaration in your current scope being hoisted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, the inner scope's variable declaration of `config` will be hoisted to
    the top of its scope, meaning that, from the very first line of `setupUI`, `config` is `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since variable declarations are hoisted to the very top of their execution
    context, even those within a block will be hoisted as if they were first initialized
    outside of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In summary, variable declarations create a variable that is scoped to the nearest
    function, module, or global environment. In the browser, there are no module environments,
    so it'll either be scoped to its function or the global scope. A variable declaration
    will be hoisted, before execution, to the top of its respective execution context.
    This may be the function, the module (in Node.js), or the `<script>` (in the browser).
    Variable declarations have fallen out of favor because of the more recently introduced `const` and `let` declarations,
    which are both block-scoped and do not have any odd hoisting behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Let declarations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let declarations are thankfully far simpler than `var` declarations. They will
    be scoped to their nearest environment (whether it is a block, a function, a module,
    or the global environment) and have no complicated hoisting behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Their ability to be scoped to a block means that a let declaration inside a
    block will not have an effect on the `outer` function scope. In the following
    code, we can see three different environments (scopes) with a respective `place` variable
    in each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This demonstrates two things to us:'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring via `let` will not overwrite or mutate a variable by the same name
    in an `outer` scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring via `let` will allow each scope to have its own variable, invisible
    to `outer` scopes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you use `let` in either `for(;;)`, `for...in`, or `for...of` constructs,
    even outside of the following block, then that `let` declaration will be scoped
    as if it were inside the block. This makes sense intuitively: when we initialize
    a `for` loop with let declarations, we naturally expect those to be scoped to
    the `for` loop itself and not outside of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We should only use `let` if we expect the variable to be reassigned at some
    later point. If no new assignment will occur, then we should prefer `const`, as
    it gives us a little bit of extra peace of mind.
  prefs: []
  type: TYPE_NORMAL
- en: Const declarations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `const` declaration has the same characteristics as `let`, except for one
    crucial difference: variables declared via `const` are immutable, meaning that
    the variable cannot be reassigned to a different value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s important to note that this does not affect the mutability of the value
    itself. So if the value is any type of object, then all of its properties will
    retain their mutability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Even though `const` does not protect values from all mutability, it does protect
    us from some common mistakes and bad practices, such as reusing a variable to
    refer to several different concepts, or accidentally reassigning a variable because
    of a typo. The `const` code phrase is generally safer to use than `let`, and is
    now considered the best practice for the declaration of all variables, unless
    you have an explicit need to reassign a variable after its declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should also feel free to use `const` when declaring variables in `for...of` and `for...in` iteration
    constructs, such as in the following case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: People often mistakenly opt for using `let` here because they believe that the
    looping construct will effectively reassign the variable, making `const` unsuitable.
    But in fact, the declaration within `for(...)` will be tied to a new block scope
    on each iteration, and thus the `const` variable will be newly initialized on
    each iteration within this fresh scope.
  prefs: []
  type: TYPE_NORMAL
- en: Function declarations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In terms of scoping, function declarations behave similarly to variable declarations (that
    is, `var`). They will be scoped to their closest function, module, or global environment,
    and will be hoisted to the top of their respective execution context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike variable declarations, however, a function declaration will cause the
    actual assignment of the `Function` to its identifier to be hoisted as well, meaning
    that the `Function` is effectively available before it is declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This behavior is quite obscure and as such is inadvisable unless it is very
    obvious where the definition for `myFunction` comes from upon invocation. A programmer
    will typically expect a definition for a function to exist above the place where
    it is called (or imported as a dependency at some prior point in time), so it
    can be confusing.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is further complexity if we consider the possibility of a function declaration residing
    within a block that is conditionally activated (**warning: don''t do this!**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, previous versions of ECMAScript did not prescribe the behavior
    of function declarations within blocks. This led to various browser implementations
    choosing their own unique way of handling such situations. Over time, implementations
    have begun to align. The ECMAScript 2015 specification sensibly forbids either
    of the `giveMeTheBestNumber` functions from having their values hoisted. The declaration
    itself can, however, still be hoisted, meaning that `giveMeTheBestNumber` would
    be `undefined` on lines prior to its declarations (similar to `var`), as mentioned.
    This is, at the time of writing, the prevalent behavior of most (but not all)
    implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the obscurity and the remaining inconsistencies across implementations,
    it is strongly suggested that you *don't use function declarations within blocks*.And
    ideally, it's best not to rely on their hoisting behavior (by referencing function
    declarations) unless you're confident that doing so would not be misunderstood
    by those who must read your code.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on how functions produced by function declarations differ
    from other ways of creating functions (for example, function expressions or arrow
    functions), please revisit the *Functions* section in *[Chapter 6](ae94cc02-a077-4ffb-903a-b9ec222a2a09.xhtml)*, *Primitive
    and Built-In Types*.
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inner scopes, as we''ve seen, have access to the variables of outer scopes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: What naturally follows from this is the concept of a closure. A closure is how
    JavaScript enables you to continue to access the scope of an `inner` function
    regardless of where or when it is called.
  prefs: []
  type: TYPE_NORMAL
- en: It's simplest to think of a closure as simply a retained scope. A closure is
    a wrapped-up or enclosed scope that is passed around alongside the function, invisibly.
    When you call the function, it has implicit access to its scope provided by this
    closure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following function (`fn`), which returns another function. It
    has its own scope, in which we declare the `coolNumber` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The inner function, which we return, has access to the `coolNumber `variable,
    as we would expect. When we call `fn()`, its scope is effectively kept alive so
    that, when we eventually call the `inner` function, it is still able to access
    `coolNumber`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is another example, where we''re making use of the continued
    access to the retained scope (that is, the closure) by reassigning and returning
    the local variable whenever our inner function is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The concept of closures is often over-complicated, so at the risk of doing
    that, I''ll state things quite simply. A closure is not an odd thing, really:
    it is a natural extension of how we should expect a scope to work. All functions
    have access to a given scope, so it shouldn''t matter how we then pass around
    these functions after their initial definition. They will continue to have access
    to that same scope, and are free to access or mutate variables within that scope
    as they see fit. A function is always anchored to the place it was originally
    defined and so whether it is called immediately or in a thousand minutes'' time,
    it will have access to the same scope (that is, the same set of lexical environments).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we continued to explore the JavaScript language, zooming out
    from previous chapters to consider larger pieces of syntax, such as expressions,
    statements, and blocks. These are programmatic scaffolding components in which
    we can place the types and operations we've previously learned about. We also
    covered the complicated mechanisms of scopes, hoisting, and closures. Understanding
    how these concepts all work together is vital to understanding other people's
    JavaScript programs and constructing your own.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we explore how to control flow within JavaScript. This'll
    allow us to weave together expressions and statements into larger bodies of logic
    in a clean way. We will then explore the art of abstraction design by learning
    about design patterns. Though the process of learning these topics individually
    may appear arduous, by the end of the book you'll have a thorough and powerful
    understanding of JavaScript that'll enable you to pay less attention to the oddities
    of the language and more attention to the cleanliness of your code.
  prefs: []
  type: TYPE_NORMAL
