- en: Time Interfaces in Unix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, the reader will learn how to program the POSIX and C++ time
    interfaces using C++17\. To start, this chapter will cover the UNIX epoch and
    POSIX `time.h` APIs and how to use them. Next, the C++ Chrono APIs will be briefly
    explained, how they relate to `time.h`, and some examples will also be provided.
    Finally, this chapter will conclude with two simple examples of how to use the
    time interfaces. The first example will demonstrate how to read the system clock
    and output the results to the console on an interval, and the second example will
    demonstrate how to benchmark software using the C++ high-resolution timer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning about POSIX `time.h` APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The C++ Chrono APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the read system clock with an example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An example involving a high-resolution timer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to compile and execute the examples in this chapter, the reader must
    have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A Linux-based system capable of compiling and executing C++17 (for example,
    Ubuntu 17.10+)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GCC 7+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMake 3.6+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To download all of the code in this chapter, including the examples and code
    snippets, please see the following link: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter11](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter11).
  prefs: []
  type: TYPE_NORMAL
- en: Learning about POSIX time.h APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will begin this chapter by discussing POSIX `time.h` APIs, which provide
    APIs for reading various clocks and performing calculations on these clock times.
    Although these APIs are specific to standard C, as will be demonstrated in the
    following section, the C time interfaces are still needed when working with C++,
    a problem that is being addressed in C++20.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the types of APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The UNIX epoch defines the number of seconds from January 1, 1970\. Interfaces
    described in this chapter leverage the UNIX epoch to define the notion of time.
    The POSIX `time.h` APIs, for the purpose of this chapter, define three different,
    opaque types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tm`: An opaque structure that holds a date and time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`time_t`: A `typedef` that stores a time that is typically implemented using
    an integer that stores the number of seconds from the UNIX epoch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clock_t`: A `typedef` that stores the amount of processor time the application
    has executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These APIs provide various functions for creating these types and manipulating
    them. It should be noted that there are different types of clocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**System clock**: The system clock reads the clock that the operating system
    is maintaining and stores the date and time that is presented to the user (for
    example, the clock that is shown on the taskbar). This clock can be changed at
    any point in time, so using it for timing in an application is usually discouraged
    as the clock being used might move back/forward in time in unexpected ways.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Steady clock**: A steady clock is a clock that ticks as the program executes.
    The more the program executes, the larger this clock grows. It should be noted
    that this clock will not match the results of the system clock and typically,
    only the difference between two of these clocks has any real value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High-resolution clock**: This is the same as a steady clock, with the exception
    that the result being returned has a much higher resolution. These types of clocks
    are often used for benchmarking.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The time() API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `time()` API returns the current system clock and takes on the following
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can either provide the `time()` function with a previously-defined `time_t
    variable`, or it will return one for you (if you pass `nullptr` as the argument),
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we create a variable, called `t`, using the `time()`
    API to get the current number of seconds from the UNIX epoch. We then output this
    value to `stdout`. It should be noted that the `time_t` typedef is usually implemented
    using an integer value, which is why we can output its value directly to `stdout`,
    as shown in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: 'As stated, you can also provide `time()` with your own, previously-defined,
    variable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example is identical to the first example, but instead of storing
    the return value of `time()`, we pass in our `time_t` variable as an argument
    to the function. Although this syntax is supported, the former is preferred. `time()`
    will return `-1` in the event of an error, which can be checked and handled as
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: The ctime() typedef
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `time_t` typedef is implementation-specific, and although it is typically
    implemented using an integer that stores the number of seconds from the Unix epoch,
    this is not guaranteed to be the case, meaning the preceding examples would likely
    not compile. Instead, to output the value of a `time_t` variable in a supported
    fashion, use the `ctime()` API, which takes on the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ctime()` API takes a pointer to a `time_t` variable and outputs a standard
    C character string. The memory that backs the string that is returned is maintained
    by the `time.h` API (and therefore does not need to be freed) and, as a result,
    is not thread-safe. This API may be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen from the preceding example, instead of the number of seconds
    from the Unix epoch being returned, a human-readable version of the current time
    and date is returned. It should also be noted that, in addition to the `ctime()`
    function not being thread-safe, it also does not provide a mechanism for adjusting
    its output format. As a result, the use of this function is typically discouraged
    in place of other `time.h` functions.
  prefs: []
  type: TYPE_NORMAL
- en: The localtime() and gmtime() APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `time()` API returns a `time_t` value that stores the number of seconds
    from the Unix epoch, as stated earlier. This value can further be processed to
    expose date and time information, providing us with the ability to convert the
    date and time to either the local time or **Greenwich Mean Time** (**GMT**). To
    do this, the POSIX API provides both the `localtime()` and `gmtime()` functions,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Both of these functions take a pointer to a `time_t` variable and return a pointer
    to a `tm` opaque structure. It should be noted that the structure the return value
    points to is managed, like `ctime()`, by the `time.h` implementation, and thus
    is not freed by the user, meaning the results of this function are not thread-safe.
  prefs: []
  type: TYPE_NORMAL
- en: The asctime() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To output an opaque `tm` structure to `stdout` (or, in general, just to convert
    the structure to a standard C string), the POSIX API provides the `asctime()`
    function, which has the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `asctime()` function takes the same form as `ctime()`, with the exception
    that a pointer to a `tm` structure is provided as the main argument instead of
    a `time_t` variable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding example, there is no difference in the output between
    `ctime()` and `asctime(localtime())`. To output the same time in GMT instead of
    local time, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding example, `gmtime()` and `localtime()` execute the
    same, with the only difference being a time zone change.
  prefs: []
  type: TYPE_NORMAL
- en: The strftime() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, the output of `ctime()` and `asctime()` was predetermined by the POSIX
    API. That is, there is no way to control the output format. In addition, these
    functions return internal memory, preventing their thread safety. To fix these
    issues, the POSIX API added the `strftime()` function, which is the recommended
    API for converting an opaque `tm` structure to a character string, and takes the
    following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `str` parameter accepts a preallocated, standard C string, while the `count`
    parameter defines the size of the first parameter. The `format` parameter accepts
    a null-terminated, standard C string that defines the format to which to convert
    the date and time, while the final `time` parameter accepts the opaque `tm` structure
    to convert to a string. The format string that is provided to this function is
    similar to the format string provided to other POSIX functions, such as `printf()`.
    The next couple of examples will demonstrate some of these format specifiers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate the `strftime()` function, the following outputs the current
    date to `stdout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding example, the `time()` API is used to get the current
    date and time. The `localtime()` function is used to convert the result of `time()`
    (which is `time_t`) to an opaque `tm` structure that represents the local date
    and time. The resulting `tm` structure is passed to `strftime()` with a format
    string of `"%m/%d/%Y"`, which outputs *month/day/year* to the standard C string
    provided. Finally, this string is output to the `stdout`, resulting in `07/14/2018`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Likewise, this function may be used to output the current time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example is identical to the previous example, the only difference
    being that the format specifier is `%H:%M`, which represents `hour:minute`, resulting
    in `15:41`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to output the same string as `ctime()` and `asctime()`, use the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example is identical to the previous two examples, with the exception
    that the format specifier is `"%a %b %d %H:%M:%S %Y"`, which outputs the same
    results as `ctime()` and `asctime()`.
  prefs: []
  type: TYPE_NORMAL
- en: The difftime() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Technically speaking, the `time_t` typedef is considered opaque (although it
    almost always is a signed 32-bit integer on Unix systems). For this reason, to
    ascertain the difference between two `time_t` values, the `difftime()` function
    is provided as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `difftime()` function takes two `time_t` values and returns the difference
    as a double (since a non-POSIX function might support fractional times):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding example, the `difftime()` function returns the difference
    between two times. It should be noted that although the preceding code compiles
    on most systems, `difftime()` should be used instead of the second example of
    directly subtracting two values.
  prefs: []
  type: TYPE_NORMAL
- en: The mktime() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What if you have two opaque `tm` structures and you wish to calculate their
    difference? The problem here is that the `difftime()` function only takes `time_t`
    and not the `tm` structure. To support the reverse of the `localtime()` and `gmtime()`
    functions, which convert `time_t` into a `tm` structure, the `mktime()` function
    converts a `tm` structure back into a `time_t` value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mktime()` function takes a single parameter, which is the opaque `tm`
    structure you wish to convert to a `time_t` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example gets the current time and date using the `time()` API,
    and converts the results into a `tm` structure using the `localtime()` API. The
    resulting `tm` structure is then converted back into a `time_t` value using `mktime()`,
    and the resulting is output to `stdout` using `ctime()`.
  prefs: []
  type: TYPE_NORMAL
- en: The clock() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, `time()` has been used to get the current system date and
    time. The problem with this type of clock is it returns the value the operating
    system is managing with respect to the current date and time, which can change
    at any point and time (for example, the user might be flying between time zones).
    This can be a problem, for example, if you are using the time APIs to keep track
    of how long something has executed. In this case, when a time zone change occurs,
    the application using `time()` might record the amount of time that has passed
    as being negative.
  prefs: []
  type: TYPE_NORMAL
- en: 'To overcome this issue, POSIX provides the `clock()` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `clock()` API returns a `clock_t` value, which is similar to a `time_t`
    value. The difference between `time()` and `clock()` is that `time()` returns
    the current system time, while `clock()` returns a value that represents the total
    amount of time that has passed since the start of the application, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the result of `clock()` is output to `stdout`. As
    shown, the value is implementation-specific, and only the difference between two
    `clock_t` values has any meaning. To convert `clock_t` into seconds, POSIX provides
    the `CLOCKS_PER_SEC` macro, which provides the necessary conversion, as shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `clock()` API is used to get the first clock value,
    and then the application sleeps for two seconds. Once the application is executed
    again by the operating system, the clock value is read again and the difference
    is converted into milliseconds using `CLOCKS_PER_SEC` (and then multiplied by
    1,000). Notice the value does not equate to 2,000 milliseconds. This is because
    the application does not record execution while sleeping, and thus, only the execute
    time of the application is seen by `clock()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better demonstrate the difference in time, the following example demonstrates
    a one-to-one comparison of `clock()` and `time()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example is identical to the previous example, with the exception
    being we spin for two seconds using `time()` instead of sleeping for two seconds,
    resulting in the `clock()` returning two seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring C++ Chrono APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ includes the Chrono APIs which, mostly, provide C++ wrappers around the POSIX `time.h` APIs.
    For this reason, some time.h functions are still needed to provide full functionality,
    including the conversion to standard C strings. It should be noted that although
    some additions have been made in C++17 (specifically `floor()`, `ceil()`, and
    `round()`), the Chrono APIs are expected to see a relatively large overhaul with
    the introduction of C++20, which is outside the scope of this book. For this reason,
    the C++ Chrono APIs are briefly explained in this section to provide an overview
    of the current APIs.
  prefs: []
  type: TYPE_NORMAL
- en: The system_clock() API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `std::chrono::system_clock{}` API is similar to `time()` in that it is
    capable of getting the system clock. `system_clock{}` is also the only clock that
    is capable of being converted into `time_t` (as it is likely implemented using
    `time()`), as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the current system clock is read using the `system_clock::now()`
    API, and the result is converted into a `time_t` value using the `system_clock::to_time_t()`
    API. As with the previous example, the result is the number of seconds from the
    Unix epoch.
  prefs: []
  type: TYPE_NORMAL
- en: The time_point API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The result of the `system_clock::now()` API is a `time_point{}`. C++ does not
    provide a function to convert a `time_point{}` to a string (it won''t until C++20),
    and as a result, the POSIX functions discussed in the previous section are still
    needed to perform this translation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we first define a user-defined overload for `time_point{}`,
    which is the result of the `std::chrono::system_clock::now()` API. This user-defined
    overload converts `time_point{}` into a `time_t` value using the C++ `std::chrono::system_clock::to_time_t()`
    API, and then converts `time_t` into a standard C string using `ctime()`, and
    streams the result to `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the POSIX `time.h` APIs, the Chrono libraries provided various functions
    for incrementing, decrementing, and comparing a `time_point{}` using C++ operator
    overloads, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the user-defined overload for `time_point{}` is provided
    as with the previous example. The current date and time are read using `std::chrono::system_clock::now()`,
    and the result is output to `stdout`. Finally, the resulting `time_point{}` is
    incremented by an hour, and then decremented by an hour (using the hour literal),
    and the results are also output to `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, arithmetic comparisons are supported, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the system clock is read twice, and the resulting
    `time_point{}` values are compared using the supported comparison operators. It
    should be noted that the results of this example could be different depending
    on the system this code is executed on, as the resolution of the time could be
    different.
  prefs: []
  type: TYPE_NORMAL
- en: Duration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `time_point{}` type provides arithmetic to increment, decrement, and perform
    addition and subtraction. This arithmetic is all done using a C++ Chrono `duration{}`,
    which defines a range of time. Another way to view `duration{}` is that it would
    be the resulting abstraction of the POSIX `difftime()` call. In fact, the subtraction
    of two `time_point{}` types results in a `duration{}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding examples, `time_point{}` was incremented and decremented by
    an hour using the *h* duration literal for an hour. Like the hour literal, C++
    provides the following literals for a duration of time, which may be used for
    this arithmetic:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hour**: *h*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minute**: *min*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Second**: *s*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Millisecond**: *ms*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microsecond**: *us*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nanosecond**: *ns*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Durations have a relatively complex template structure, which is outside the
    scope of this book, for defining their resolution (that is, whether a duration
    is in seconds, milliseconds, or hours), and can technically take on almost any
    resolution as a result. Although this functionality exists, C++ provides some
    predefined helpers for converting from one duration to another, preventing you
    from needing to know the inner workings of `duration{}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::chrono::nanoseconds`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::chrono::microseconds`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::chrono::milliseconds`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::chrono::seconds`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::chrono::minutes`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::chrono::hours `'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, below we will use these predefined helpers to convert the system
    clock to seconds and milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the system clock is read twice, with a sleep for two
    seconds separating each read. The resulting `time_point{}` values are then subtracted
    to create a `duration{}`, and the resulting `duration{}` is converted into seconds,
    milliseconds, and nanoseconds, with the results being output to `stdout` using
    the `count()` member function, which simply returns the value of `duration{}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like `time_point{}`, a duration can also be manipulated using arithmetic, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, two `duration{}` variables are created that represent
    a second, one with the value of `0` seconds, and the second with a value of `42`
    seconds. Arithmetic is then performed on the first duration and the results are
    output to `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, comparisons are also supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, two durations are created that represent `0` seconds
    and `42` seconds respectively, and both durations are compared using the comparison
    operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the modifications to the Chrono library that are taking place will
    likely occur in C++20 with a large number of APIs being added to address the relatively
    obvious shortcomings of the existing API. In C++17, however, the `floor()`, `ceil()`,
    `round()`, and `abs()` APIs were added to the Chrono APIs, which return the floor,
    ceil, round, or absolute values of a duration, as shown in the following example
    (with similar APIs also being added to the `time_point{}` type):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The steady_clock function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`system_clock{}` is similar to `time()`, while `steady_clock{}` is similar
    to `clock()`, and performs the same objective—to provide a clock that represents
    the amount of time the application has executed, regardless of the current system
    date and time (which might change depending on the user of the system); for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `steady_clock::now()` function is read twice,
    with a sleep separating the two calls. The resulting values are subtracted, converted
    to seconds, milliseconds, and nanoseconds, and the result is output to `stdout`.
    It should be noted that unlike `clock()`, the resulting steady clock accounts
    for the time the application slept.
  prefs: []
  type: TYPE_NORMAL
- en: The high_resolution_clock function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On most systems, `high_resolution_clock{}` and `steady_clock{}` are the same.
    In general, `high_resolution_clock{}` represents the highest-resolution clock
    available as a steady clock and, as shown in the following example, the result
    is the same with `stead_clock{}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `high_resolution_clock::now()` function is read
    twice, with a sleep separating the two calls. The resulting values are subtracted,
    converted into seconds, milliseconds, and nanoseconds, and the result is output
    to `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: Studying an example on the read system clock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we will bring everything we learned in this chapter into a
    simple demonstration that reads the system clock at an interval specified by the
    user. To accomplish this, the following inclusions and namespaces are needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Like the examples throughout this chapter, a user-defined overload for `std::ostream{}`
    is provided to convert `time_point{}` into a standard C string, and then stream
    the result to `stdout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `protected_main()` function (which is a pattern used throughout this
    book), we output the current system time on an interval provided by the user,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we convert the arguments list into `gsl::span{}`, and
    then make sure we were given an argument. If no argument is provided, we exit
    the program. The argument is then converted into `cstring_span{}`, and an infinite
    loop is started. In the loop, the system clock is read and output to `stdout`,
    and then the program sleeps for the amount of time provided by the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As with all of our examples, the `protected_main()` function is executed by
    the `main()` function, which catches exceptions should they occur.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling and testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To compile this code, we leverage the same `CMakeLists.txt` file that we have
    been using for the other examples: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter11/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter11/CMakeLists.txt).
  prefs: []
  type: TYPE_NORMAL
- en: 'With this code in place, we can compile this code using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute the example, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding snippet, the example is run with an interval of two
    seconds, and the application outputs the system clock to the console every two
    seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Studying an example on high-resolution timer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we will create a simple benchmark using `high_resolution_clock{}`. To
    accomplish this, the following inclusions and namespaces are needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a `benchmark` function, we use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This function has been seen before in [Chapter 8](da2d2789-8a5d-4da0-b374-668d06e322ec.xhtml),
    *Learning to Program File Input/Output*, The Logger Example. This code leverages
    functional programming to wrap a function call (likely a lambda) between two calls
    to the high-resolution clock. The results are then subtracted and returned. As
    we learned in this chapter, `high_resolution_clock{}` returns a `time_point{}`
    and their difference creates a `duration{}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `protected_main()` function is implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we convert the arguments list to a `gsl::span{}`, and
    then check to make sure we were given an argument. If no argument is provided,
    we exit the program. The argument is then converted into `cstring_span{}`, and
    a loop that runs for as long as the user wishes is benchmarked. The result of
    the `benchmark` is then converted into seconds, milliseconds, and nanoseconds
    and output to `stdout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As with all of our examples, the `protected_main()` function is executed by
    the `main()` function, which catches exceptions should they occur.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling and testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To compile this code, we leverage the same `CMakeLists.txt` file that we have
    been using for the other examples: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter11/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter11/CMakeLists.txt).
  prefs: []
  type: TYPE_NORMAL
- en: 'With this code in place, we can compile this code using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute the example, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding snippet, the example is run with a loop of `1000000`
    iterations, and the amount of time it takes to execute that loop is output to
    the console.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to use both the POSIX and C++ time interfaces
    to read the system clock, and a steady clock for more precise timing. This chapter
    concluded with two examples; the first example demonstrated how to read the system
    clock and output the results to the console on a user-defined interval, and the
    second demonstrated how to benchmark software using the C++ high-resolution timer. In
    the next chapter, we will learn how to program both POSIX and C++ threads with
    examples that build upon the lessons learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss C++ threads, synchronization primitives
    such as mutexes, and how to program them.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the Unix epoch?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What type does `time_t` usually represent?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between `time()` and `clock()`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why does `difftime()` return a double?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a C++ `duration{}`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between `steady_clock{}` and `high_resolution_clock{}`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/application-development/c17-example](https://www.packtpub.com/application-development/c17-example)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/application-development/getting-started-c17-programming-video](https://www.packtpub.com/application-development/getting-started-c17-programming-video)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
