- en: Methodologies, Paradigms, and Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It could be argued that software engineering, at least as it's usually thought
    of now, really came into being with the first formally identified software development
    methodology. That methodology (which was eventually dubbed Waterfall in 1976)
    made people start thinking about not just how the software worked, or how to write
    the code, but what the processes around writing the code needed to look like in
    order to make it more effective. Since then, roughly a dozen other methodologies
    have come into being, and in at least one case, the collection of various Agile
    methodologies, there are nearly a dozen distinct sub-variants, though Scrum is
    almost certainly the most widely known, and Kanban may be a close second.
  prefs: []
  type: TYPE_NORMAL
- en: While those methodologies were growing and maturing, the increase in computing
    power also led, eventually, to newer, more useful, or more efficient development
    paradigms. **Object-Oriented Programming** (**OOP**) and **Functional Programming**
    (**FP**) are probably the most well-known advances on the original procedural
    programming paradigm that dominated the scene for decades. Automation of code
    integration and promotion practices (Continuous Integration and Delivery, respectively)
    have also become popular in recent years.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Process methodologies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waterfall
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Agile:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scrum
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kanban
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Development paradigms:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object-Oriented Programming (OOP)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional Programming (FP)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Development practices:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous Integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous Delivery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process methodologies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At some level, all development process methodologies are variations on the
    theme of managing development within the boundaries of some common realities:'
  prefs: []
  type: TYPE_NORMAL
- en: There are only so many useful working hours per person per day that can be devoted
    to a project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a limit to the available resources, whether in terms of people, equipment,
    or money, available to a project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a minimum acceptable quality standard for the project when it's complete
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is sometimes expressed as the **I****ron Triangle** of project management:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e2bbcfd4-bb81-4ff6-85b1-67f7a81c3742.png)'
  prefs: []
  type: TYPE_IMG
- en: The primary concern with respect to the **Speed** point is time—the most common
    focus is probably on a project needing to be complete by a specific deadline,
    or there is some other time constraint that may only be surmountable by adding
    developers to the team (an increase in **Cost**), or by cutting corners (a decrease
    in **Quality**).
  prefs: []
  type: TYPE_NORMAL
- en: Budget variations are a common theme for the **Cost** point—anything that costs
    money, whether in the form of additional developers, newer/faster/better tools,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing the available resources/staff decreases the **Speed** of project completion
    and/or the final **Quality**.
  prefs: []
  type: TYPE_NORMAL
- en: The **Quality** point is, obviously, concerned with quality measures—which might
    include specific internal or external standards—but could easily include less
    obvious items such as longer-term maintainability and support for new features
    and functionality. Prioritizing **Quality**, at a minimum, requires more developer
    hours, decreasing **Speed**, and increasing **Cost**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, significant priority (whatever value for significant might apply) can
    only be given to two out of the three points of the triangle at most, yielding
    three priority possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Fast, inexpensive development, at the cost of quality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fast, high-quality development, but at greater cost
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High-quality, inexpensive development that takes a longer time to complete
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Lean Startup Method** (or just Lean) is sometimes cited as an alternative
    process methodology that can overcome the constraints of the Iron Triangle, but
    is beyond the scope of this book. A reasonable introduction to its concepts can
    be found at [https://www.castsoftware.com/glossary/lean-development](https://www.castsoftware.com/glossary/lean-development).
  prefs: []
  type: TYPE_NORMAL
- en: There are three specific development process methodologies that are worth an
    in-depth examination in the context of this book. The first, Waterfall, will be
    examined in order to provide a frame of reference for two Agile methodologies,
    Scrum and Kanban, and a few others will be looked at as well, at least briefly.
    A full discussion of any of them is well beyond the scope of this book, but the
    intention is to provide enough detail on each of them to illustrate what their
    focuses and priorities are, as well as their advantages and drawbacks. At a minimum,
    this should provide a baseline of what to expect while working in any of them,
    tying the phases of each methodology back to the phases of the model SDLC from
    [Chapter 3](https://cdp.packtpub.com/hands_on_software_engineering_with_python/wp-admin/post.php?post=27&action=edit), *System
    Modeling,* to show what happens, when, and how.
  prefs: []
  type: TYPE_NORMAL
- en: Waterfall
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Waterfall's ancestry can probably be traced back to manufacturing and/or construction
    planning. In many respects, it's a very simple approach to planning and implementing
    a development effort, and is essentially broken down into defining and designing
    what to build, building it, testing it, and deploying it.
  prefs: []
  type: TYPE_NORMAL
- en: 'More formally, it''s six separate phases, intended to be executed in this order:'
  prefs: []
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Installation and Operation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](assets/99fc898a-d74e-4f49-9dc5-d7f925081471.png)'
  prefs: []
  type: TYPE_IMG
- en: These phases correspond fairly neatly with the sequence of phases in the SDLC.
    They are very similar, whether by accident or design, and are intended to accomplish
    many of the same goals. Their focus is probably best summarized as an effort to
    design, document, and define everything that's needed for development to succeed,
    before handing that design off to development for implementation. In an ideal
    execution, the design and requirement information will give developers everything
    they need, and the project manager may be completely hands-off once implementation
    starts.
  prefs: []
  type: TYPE_NORMAL
- en: Conceptually, there is some merit to the approach—if everything is thoroughly
    and accurately documented, then developers will have everything that they need,
    and they can focus entirely on writing code to accomplish the requirements. Documentation,
    as part of the initial project specifications, is already created, so once the
    software is deployed, anyone managing the resulting system will have access to
    that, and some of that documentation may even be user-oriented and available to
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'If done well, it almost certainly captures and allows for dependencies during
    implementation, and it provides an easily followed sequence of events. Overall,
    the methodology is very easily understood. It''s almost a reflexive approach to
    building something: decide what to do, plan how to do it, do it, check that what
    was done is what was wanted, and then it''s done.'
  prefs: []
  type: TYPE_NORMAL
- en: In practice, though, a good Waterfall plan and execution is not an easy thing
    to accomplish unless the people executing the **Requirements**, **Analysis**,
    and **Design** phases are really good, or sufficient time is taken (maybe a lot
    of time) to arrive at and review those details. This assumes that the requirements
    are all identifiable to begin with, which is frequently not the case, and that
    they don't change mid-stream, which happens more often than might be obvious.
    Since its focus is on documentation first, it also tends to slow down over long-term
    application to large or complex systems—the ongoing updating of a growing collection
    of documentation takes time, after all—and additional (and growing) expenditure
    of time is almost always required to keep unmanageable bloat from creeping in
    to other support structures around the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first three phases of a Waterfall process (**Requirements**, **Analysis**,
    and **Design**) encompass the first five phases of the SDLC model:'
  prefs: []
  type: TYPE_NORMAL
- en: Initial concept/vision
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concept development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project management planning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requirements analysis and definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System architecture and design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These would ideally include any of the documentation/artifacts from those phases,
    as well as any *System Modeling* items ([Chapter 3](https://cdp.packtpub.com/hands_on_software_engineering_with_python/wp-admin/post.php?post=27&action=edit), *System
    Modeling*), all packaged up for developers to use and refer to. Typically, these
    processes will involve a dedicated Project planner, who is responsible for talking
    to and coordinating with the various stakeholders, architects, and so on, in order
    to assemble the whole thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a well-defined and managed Waterfall process, the artifact that comes out
    of these three phases and gets handed off to development and quality assurance
    is a document or collection of documents that make up a Project plan. Such a plan
    can be very long, since it should ideally capture all of the output from all of
    the pre-development efforts that''s of use in and after development:'
  prefs: []
  type: TYPE_NORMAL
- en: Objectives and goals (probably at a high level)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What''s included, and expected of the finished efforts:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complete requirement breakdowns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any risks, issues, or dependencies that need to be mitigated, or at least watched
    for
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Architecture, design, and system model considerations (new structures or changes
    to existing structures):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logical and/or physical architecture items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data structure and flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interprocess communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development plan(s)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quality assurance/testing plan(s)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change management plans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installation/Distribution plans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decommissioning plans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Implementation** and **Testing** phases of a Waterfall process, apart
    from having the Project plan as a starting point reference, are probably going
    to follow a simple and very typical process:'
  prefs: []
  type: TYPE_NORMAL
- en: Developer writes code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developer tests code (writing and executing unit tests), fixing any functional
    issues and retesting until it's complete
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developer hands finished code off to quality assurance for further testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quality assurance tests code, handing it back to the developer if issues are
    found
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tested/approved code is promoted to the live system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This process is common enough across all development efforts and methodologies
    that it will not be mentioned again later unless there is a significant deviation
    from it.
  prefs: []
  type: TYPE_NORMAL
- en: Waterfall's **Installation and Operation** phase incorporates the **Installation/Distribution**
    and **Operations/Use and Maintenance** phases from the SDLC model. It may also
    incorporate the **Decommissioning** phase as well, since that may be considered
    as a special **Operation** situation. Like the **Implementation** and **Testing**
    phases, chances are that these will progress in an easily anticipated manner—again,
    apart from the presence of whatever relevant information might exist in the Project
    plan documentation, there's not really anything to dictate any deviation from
    a simple, common-sense approach to those, for whatever value of common-sense applies
    in the context of the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'While Waterfall is generally dismissed as an outdated methodology, one that
    tends to be implemented in a too-rigid fashion, and that more or less requires
    rock-star personnel to work well on a long-term basis, it can still work, provided
    that one or more conditions exist:'
  prefs: []
  type: TYPE_NORMAL
- en: Requirements and scope are accurately analyzed, and completely accounted for
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requirements and scope will not change significantly during execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system is not too large or too complex for the methodology to manage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes to a system are not too large or too complex for the methodology to
    manage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of these, the first is usually not something that can be relied upon without
    policy and procedure support that is usually well outside the control of a development
    team. The latter two will, almost inevitably, be insurmountable given a long enough
    period of time, if only because it's rare for systems to become smaller or less
    complex over time, and changes to larger and more complex systems tend to become
    larger and more complex themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Agile (in general)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By the early 1990s, a sea change was under way in how development processes
    were viewed. The Waterfall process, despite widespread adoption, even in government
    contractor policies in the US, started to show more and more of the flaws inherent
    to its application to large and complex systems. Other, non-Waterfall methodologies
    that were in use were also starting to show signs of wear from being too heavy,
    too prone to counter-productive micro-management, and a variety of other complaints
    and concerns.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, a lot of thought around development processes started focusing
    on lightweight, iterative, and less management-intensive approaches, that eventually
    coalesced around the Agile Manifesto and the twelve principles that underlie it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are uncovering better ways of developing software by doing it and helping
    others do it. Through this work, we have come to value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Individuals and interactions over processes and tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working software over comprehensive documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customer collaboration over contract negotiation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Responding to change over following a plan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That is, while there is value in the items on the right, we value the items
    on the left more. We follow these principles:'
  prefs: []
  type: TYPE_NORMAL
- en: Our highest priority is to satisfy the customer through early and continuous
    delivery of valuable software.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Welcome changing requirements, even late in development. Agile processes harness
    change for the customer's competitive advantage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deliver working software frequently, from a couple of weeks to a couple of months,
    with a preference for the shorter timescale.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Business people and developers must work together daily throughout the project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build projects around motivated individuals. Give them the environment and support
    they need, and trust them to get the job done.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most efficient and effective method of conveying information to and within
    a development team is face-to-face conversation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working software is the primary measure of progress.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Agile processes promote sustainable development. Sponsors, developers, and users
    should be able to maintain a constant pace indefinitely.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous attention to technical excellence and good design enhances agility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplicity—the art of maximizing the amount of work not done—is essential.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The best architectures, requirements, and designs emerge from self-organizing
    teams.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At regular intervals, the team reflects on how to become more effective, then
    tunes and adjusts its behavior accordingly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may refer to The Agile Manifesto at [http://Agilemanifesto.org/](http://agilemanifesto.org/)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'In an application, these principles lead to a few common characteristics across
    different methodologies. There may be exceptions in other methodologies that are
    still considered Agile, but for our purposes, and with respect to the specific
    methodologies discussed here, those common traits are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Development happens in a sequence of iterations, each of which has one to many
    goals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each goal is a subset of the final system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the conclusion of each iteration, the system is deployable and operational
    (perhaps only for a given value of operational)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requirements are defined in detail in small chunks, and may not be defined at
    all until just before the iteration that they're going to be worked on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scrum is claimed to be the most popular, or at least most widely used, Agile
    development methodology (the *12^(th) Annual State* of *Agile Report* puts it
    at 56% of Agile methods in use), and as such is probably worth some more detailed
    attention. Kanban is another Agile methodology that bears some examination, if
    only because it's closer to how the main system project in this book is going
    to be presented.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few other Agile methodologies that also bear at least a quick look-over
    for some of the specific focus they can bring to a development effort, either
    on their own, or as a hybrid or mix-in with other methodologies.
  prefs: []
  type: TYPE_NORMAL
- en: Businesses are also exploring additions and modifications to textbook Agile
    processes to improve them and address needs that weren't encompassed by the original
    concept. One such process is the **Scaled Agile Framework**, which is used to
    improve the use of Agile processes at larger scales.
  prefs: []
  type: TYPE_NORMAL
- en: Scrum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Scrum has the following moving parts, broadly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Scrum methodology centers around time-limited iterations called Sprints:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Sprint is defined as taking some fixed length of time that the development
    team (and sometimes stakeholders) can agree upon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sprint durations are usually the same duration each time, but that duration
    can be changed, either temporarily or permanently (until the next time it's changed)
    if there is reason to do so
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each Sprint has a set of features/functionality associated with it that the
    development team has committed to completing by the end of the Sprint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each feature/functionality item is described by a **user story.**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The team determines what user stories they can commit to completing, given the
    duration of the Sprint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The priority of user stories is determined by a stakeholder (usually a Product
    Owner), but can be negotiated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The team gathers periodically to groom the backlog, which can include:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Estimating the size of stories that don't have one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding task-level detail to user stories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subdividing stories into smaller, more manageable chunks if there are functional
    dependencies or size-related execution concerns, and getting those approved by
    the relevant stakeholder(s)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The team reviews the Sprint at the end, looking for things that went well, or
    for ways to improve on things that went less-than-well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The team meets periodically to plan the next Sprint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The team has a short, daily meeting (a stand-up), the purpose of which is to
    reveal what status has changed since the last update. The best-known format, though
    not the only one for these meetings, is a quick statement from each participant
    on:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What they have worked on since the last stand-up, complete or otherwise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What they are planning on working on until the next stand-up.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What roadblocks they are dealing with, that someone else in the team might be
    able to assist with.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Story sizing should not be based around any sort of time estimate. Doing so
    tends to discount any assessments of complexity and risk that might be critically
    important, and implies an expectation that all developers will be able to complete
    the same story in the same length of time, which is probably not going to be the
    case. Use story points or t-shirt sizes (extra small, small, medium, large, extra
    large and extra-extra large) instead!
  prefs: []
  type: TYPE_NORMAL
- en: 'From beginning to end, a typical Sprint will unfold something like this, assuming
    all goes well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Day 1 Sprint start-up activities**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stories and tasks are set up on the task board, whether it's real or virtual,
    all in a **Not Started** status, in priority order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Team members claim a story to work on, starting with the highest priority item.
    If more than one person is working on a single story, they each claim one of the
    tasks associated with it. Claimed stories are moved to an **In Progress** status
    on the task board.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Day 1 –day before end of Sprint**: Development and QA.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Daily stand – up meeting** (probably skipped on the first day).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Development**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As tasks are completed, their status is updated on the task board to indicate
    as much.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As stories are completed, they are moved to the next status on the task board
    after development. This column might be **Dev-Complete**, **QA-Ready**, or whatever
    other status description makes sense given the team's structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If roadblocks are encountered, they are notified to the **Scrum Master**, who
    is responsible for facilitating resolving the blocking issue. If it cannot be
    resolved immediately, the status of the blocked story or task should be updated
    on the task board, and the developer moves on to the next task or story that they
    can tackle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As roadblocks get resolved, the items they were blocking reenter development
    status, and progress as normal from that point on. There is nothing to say that
    the developer who encountered the block initially has to be the one to continue
    work on the item after the block is resolved.
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Quality Assurance activities**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If QA staff are embedded into the development team, their processes are often
    similar to development activities, except that they'll start by claiming a story
    to test from whichever column indicates **Dev-Complete** items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing a story should include, at a minimum, the **acceptance criteria **of
    that story
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing may well (and probably should) include functional tests that are not
    part of the acceptance criteria
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Story Acceptance**: If there are any stories completed that haven''t been
    accepted, they can be demonstrated and accepted or declined by the relevant stakeholder(s).
    Declined items will probably go back to the **In Development** or **Not Started**
    status, depending on why they were declined, and what can be done to resolve the
    reason for being declined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sprint-Close Day**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Demonstration and acceptance of any remaining stories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If time has not been available to do so before, preparation for the next Sprint
    should take place:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sprint Planning**, to prepare the user stories for the next Sprint'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Backlog Grooming**, to prepare and define details and tasks for any user
    stories that need those details'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Acceptance of remaining stories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Retrospective meeting**—the team gathers to identify the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What worked well in the Sprint, in order to try and leverage what made it work
    well
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What worked poorly, or not at all, in order to avoid similar scenarios in the
    future
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of the daily activities orbit around a task board, which provides a quick
    mechanism for easily seeing what''s in progress, and what the status of each item
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/168e2a52-b270-4df2-a38a-d6629d9b41b9.png)An example task board,
    showing stories and tasks in different stages of developmentThe task board shown
    has more detailed status columns than are technically required—the bare-minimum
    column set would be **Stories**, where the top-level stories'' details live until
    they are done, **Not Started**, and **In Progress** for tasks that are part of
    the Sprint, and **Done**, where tasks (and possibly stories) land when they are
    complete, tested, and ready for acceptance.'
  prefs: []
  type: TYPE_NORMAL
- en: Scrum's priorities are its focus on transparency, inspection, and self-correction,
    and its adaptability to changing needs and requirements. The task board is a significant
    part of the transparency aspect of the methodology, allowing anyone with any interest
    to see at a glance what the current status of development efforts is. But it doesn't
    end there—there is a role known as the **Product Owner**, who acts as the central
    communications point between the development team and all of the stakeholders
    of the system. They attend the daily stand-ups, in order to have near-real-time
    visibility into progress, roadblocks, and so on, and are expected to speak for
    and make decisions on behalf of the entire collection of stakeholders. They are
    also responsible for connecting team members with external stakeholders in the
    event that questions or concerns arise that the Product Owner cannot address themselves.
    Their role is critical in assuring a good balance between providing transparency
    into ongoing development efforts to the stakeholders and and not burdening the
    development team with ongoing status reporting from them.
  prefs: []
  type: TYPE_NORMAL
- en: Scrum expects a fair amount of self-inspection in the process itself, and encourages
    a similar inspection of the results of the process—the software being created,
    and the practices and disciplines used in creating it—by prioritizing team openness
    and member intercommunication, providing a mechanism for raising visibility into
    risks and blocking conditions, and even, to some degree, by encouraging user stories
    that entail the smallest amount of effort to achieve a given functional goal.
    When concerns or issues arise, the emphasis on immediate communication and the
    ready availability of someone who can provide direction and make decisions resolve
    those issues quickly, and with a minimal degree of interference with the ongoing
    development process.
  prefs: []
  type: TYPE_NORMAL
- en: Scrum is, perhaps, one of the better methodologies from an adaptability-to-change
    perspective. Imagine a situation where a development team has been working on
    parts of a project for the first week of a two-week (or longer) Sprint. At that
    point, someone at the stakeholder level suddenly decides that a change needs to
    be made to one of the stories. There are several possible reasons—good, bad, or
    indifferent—for that sort of change to be necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the functionality that underlies the story is deemed obsolete, and no
    longer needed at all—if the story hasn't been completed, then it can simply be
    removed from the Sprint, and another story from the backlog pulled in to be worked
    on, if one is available that is no larger than the one being removed. If there's
    already code written against the story, it will probably need to be removed, but
    that's about it in terms of impact on the code base. If the story is complete,
    then the related code also gets removed, but no new work (additional stories)
    gets pulled in.
  prefs: []
  type: TYPE_NORMAL
- en: If the story is changed—the functionality behind it is being altered to better
    fit user needs or expectations, for example—the story gets withdrawn from the
    current Sprint in the same fashion as if it were being removed, at the very least.
    If there is time available to re-scope the story and re-insert it into the Sprint,
    that can be undertaken, otherwise it will be added to the backlog, probably at
    or near the top of the list from a priority perspective.
  prefs: []
  type: TYPE_NORMAL
- en: On occasion, it's possible for a Sprint to derail, but the methodology has expectations
    around how that gets handled as well. If a Sprint cannot complete successfully
    for any reason, it's supposed to stop, and a new Sprint is planned to pick up
    from where that one ended.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some advantageous aspects of Scrum include:'
  prefs: []
  type: TYPE_NORMAL
- en: Scrum is well-suited to work that can be broken down into small, quick efforts.
    Even in large-scale systems, if additions to or alterations of the large code
    base can be described in short, low-effort stories, Scrum is a good process to
    apply.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scrum works well for teams that have reasonably consistent skillsets within
    their domains. That is, if all developers on a team can, for example, write code
    in the main language of the project without significant assistance, that's a better
    team dynamic than if only one out of six team members can.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At the same time, because of the structure involved in a Scrum process, there
    are some caveats:'
  prefs: []
  type: TYPE_NORMAL
- en: Since a Sprint represents a commitment to complete a set of stories and functionality,
    changing an in-process Sprint, even with a really good reason, is troublesome,
    time-consuming, and disruptive. That implies, then, that whoever is in the position
    of making decisions that could require in-process Sprint changes needs to be aware
    of the potential impacts of those decisions—ideally, perhaps, they would avoid
    Sprint-disruptive changes without really, really good reasons.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scrum may not lend itself well to meeting project- or system-level deadlines
    until or unless the team has a fair amount of expertise across the entire domain
    of the system and its code base. Iteration deadlines are at less risk, though
    they may require altered or reduced scope in order to deliver working software
    on an iteration-by-iteration basis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development efforts and outputs become less predictable if the team members
    change—every new team member, especially if they join the team at different times,
    will have some impact on the team's ability to be predictable until the new team
    roster has had time to settle in. Scrum can be particularly sensitive to these
    changes, since new team members may not have all the necessary tribal knowledge
    to meet an iteration's commitments for a while.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scrum may not work well—perhaps not at all—if the members of a team aren't all
    in the same physical area. With modern teleconferencing, holding the daily stand-up
    is still possible, as are the other varied meetings, but Scrum is intended to
    be collaborative, so easier direct access to other team members tends to become
    important pretty quickly as soon as questions or issues arise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unless it's pretty carefully managed not to, Scrum tends to reinforce skill-set
    silos in a team—if only one developer knows, for example, how to write code in
    a secondary language that the system needs, that person will be tapped more frequently
    or by default for any tasks or stories that need that knowledge in order to meet
    the iteration's commitments. Making a conscious effort to turn silo-reinforcing
    stories or tasks into a team or paired development effort can go a long way toward
    reducing these effects, but if no efforts are made, or if there isn't support
    for reducing these silos, they will persist.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scrum may be challenging if the system has a lot of external dependencies (work
    from other teams, for example), or a lot of quality control effort that developers
    have to contend with. This last item can be particularly problematic if those
    quality control requirements have legal or regulatory requirements associated
    with them. Assuring that external dependencies are themselves more predictable
    can go a long way to mitigate these kinds of challenges, but that may be out of
    the team's control.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scrum and the phases of the SDLC model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The phases of our SDLC model that are important to the development effort happening
    during specific parts of a Scrum process are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before development starts:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Requirement** analysis and definition happens during the story creation and
    grooming portions of the process, often with some follow-up during Sprint planning.
    The goal is for each story''s requirements to be known and available before the
    story is included in a Sprint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System architecture and design items follow much the same pattern, though it's
    possible for a story in an iteration to have architecture and/or design tasks
    too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The development process itself:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Development**, obviously, happens during the Sprint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quality** assurance activities generally also happen as part of the Sprint,
    being applied to each story as it''s deemed complete by the developers. If testing
    activities reveal issues, the story would go back to an **In-Development** status,
    or perhaps an earlier status, on the task board, and would be picked up and corrected
    as soon as possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System integration and testing will probably happen during the Sprint as well,
    assuming that an environment is available to execute these activities with the
    new code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Acceptance **can happen on a story-by-story basis as each story makes its
    way through all the QA and System Integration and Testing activities, or it can
    happen all at once at an end-of-Sprint demo-and-acceptance meeting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's not hard to see why Scrum is popular—from a developer's perspective, with
    disciplined planning and devoting care and attention to making sure that the developers'
    time is respected and realistically allocated, their day-to-day concerns reduce
    down to whatever they're working on at the moment. Given a mature team, who have
    a reasonably consistent skill set and a good working knowledge of the system and
    its code base, Scrum will be reasonably predictable from a business perspective.
    Finally, Scrum, if managed with care and discipline, is self-correcting—as issues
    or concerns arise, with the process, *or* with the system and code base to some
    extent, the *process* will provide mechanisms for addressing and correcting those
    items.
  prefs: []
  type: TYPE_NORMAL
- en: Kanban
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kanban, as a process, has a lot of similarities to Scrum:'
  prefs: []
  type: TYPE_NORMAL
- en: The main unit of effort is a user story.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stories have the same sort of story-level process status, to the point where
    the same sort of task board, real or virtual, is used to track and provide visibility
    into work in progress.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stories should have all of their requirements and other relevant information
    ready and waiting before work on them commences. That implies that there is some
    sort of story grooming process, though it may not be as formally structured as
    the equivalent in Scrum.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kanban, unlike Scrum:'
  prefs: []
  type: TYPE_NORMAL
- en: Is not time-boxed—there is no Sprint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does not expect or require the daily status/stand-up meeting, though it's a
    useful enough tool and is thus commonly adopted. Other variants and approaches,
    perhaps focusing first on blocked items, then concerns on in-progress items, then
    anything else, are also viable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does not expect or require that stories be sized, though again it's a useful
    enough tool and is not uncommon, especially if it is a useful criterion for prioritizing
    stories for development.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kanban's primary focus might be described as an effort to minimize context changes,
    which plays out as working on single stories until they are complete before moving
    on to the next. This frequently results in prioritization of functionality by
    need, which lends itself well to situations where there are functional dependencies
    between stories.
  prefs: []
  type: TYPE_NORMAL
- en: That working-until-complete focus is probably going to occur in a Scrum process
    as well, but it's not actually expected, since the goal in Scrum is to complete
    all stories in a Sprint, and assistance from others on the team to complete a
    story may well be necessary at any point to accomplish that goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kanban''s entire process is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: Stories (and their tasks) are made ready, and prioritized for work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or more developers selects a story, and works on it until it's complete,
    then repeats the process with another story, and another, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While development and work against current stories is underway, new stories
    are made ready and added to the stack of available work as details become available,
    and prioritized accordingly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kanban, with different policies and procedures than Scrum, offers different
    advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Kanban is fairly well-suited to efforts where there are significant silos of
    knowledge or expertise, since it's focused on completion of functionality, no
    matter how long it might take
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kanban handles stories and functionality that are both large and not easily
    divisible into smaller logical or functional chunk, without having to go through
    the process of subdividing them into Sprint-sized chunks (but see the next section
    for the drawbacks of this)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kanban limits Work In Progress directly, which reduces the likelihood of overworking
    developers, provided that the flow of the work is planned correctly and well
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kanban allows the addition of new work by stakeholders at any point in time,
    and with any priority, though interruption of in-progress work is still best avoided
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provided that each story is independent and deliverable, each completed story
    is ready for installation or implementation as soon as it's been accepted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It also has its own set of caveats:'
  prefs: []
  type: TYPE_NORMAL
- en: Kanban can be more prone to bottlenecks in development, particularly if there
    are large-scale or long-duration dependencies for subsequent stories—an example
    might be a data storage system that takes three weeks to complete—that is, there
    is a dependency for a number of small class structures that need it, which could
    be implemented in a few days if the data storage system were complete.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since it doesn't really provide any concrete milestones at a higher level than
    individual stories, Kanban requires more direct and conscious effort to establish
    those milestones if they are needed for external business reasons.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More conscious thought and effort are typically needed for functionality that
    is being developed in phases in a Kanban process for it to be efficient—any functionality
    that has **must-have**, **should-have**, and **nice-to-have** capabilities that
    are all going to be implemented, for example, needs to provide some awareness
    of, and guidance future phase goals from the beginning to remain efficient.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kanban doesn't require that the team as a whole be aware of the design underlying
    the work, which can lead to misunderstandings, or even development efforts at
    cross-purposes. Making a conscious effort to **de-silo** design, and raise overall
    awareness of the larger-scale requirements may be needed, and it may not be apparent
    that it is needed at first.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kanban and the phases of the SDLC model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many Agile processes, especially those that use stories as a basic unit of
    effort or work, have a lot of similarities. Since most story-related items have
    been described in some detail in discussing Scrum, any later methodologies that
    use stories will only note variations on the themes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Before development starts:** Requirement analysis and definition, and system
    architecture and design, work in much the same way as they do in Scrum, and for
    many of the same reasons. The primary difference is that there is a less formal
    structure expected in Kanban to accomplish the attachment of requirements-and-architecture
    details to stories. It generally happens when there''s time and/or a perceived
    need, such as the development team being close to running out of workable stories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The development process itself:** Development and Quality Assurance processes
    are part of the flow of a given story as it''s being worked to completion. So,
    too is system integration and testing, and acceptance pretty much has to happen
    during a story''s life cycle, since there isn''t an end-of-Sprint meeting to demonstrate
    development results and acquire acceptance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With a less formal structure, fewer process rituals, and a readily-understandable
    just-in-time approach to its process, Kanban is easily understood, and reasonably
    easily managed. Some additional care at key points, and the ability to identify
    those key points, helps considerably in keeping things moving smoothly and well,
    but as long as the ability to recognize and address those key points improves
    over time, so too will the process.
  prefs: []
  type: TYPE_NORMAL
- en: Other Agile methodologies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scrum and Kanban aren't the only two Agile methodologies, or even the only two
    worthy of consideration. Some others that are worth noting include Extreme Programming,
    as a free-standing methodology, and Feature and Test-Driven Development, either
    as standalone methodologies or, perhaps as mix-ins to some other methodology.
  prefs: []
  type: TYPE_NORMAL
- en: Extreme programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most noticeable aspect of **Extreme Programming** (**XP**) is probably the
    **paired programming** approach, which can be an integral part of its implementation.
    The intention/expectation behind it is that two developers, using one computer,
    work on the code, which, ideally improves their focus, their ability to collaborate,
    solve any challenges more quickly, and allows for faster, better, and more reliable
    detection of potential risks that are inherent to the code being produced. In
    a paired scenario, the two developers alternate with some frequency between being
    the person writing the code and the person reviewing it as it's being written.
    Not all XP implementations use the paired approach, but when it's not in play,
    other processes, such as extensive and frequent code reviews and unit testing,
    are necessary to maintain at least some of the benefits that are lost by not using
    that option.
  prefs: []
  type: TYPE_NORMAL
- en: XP as a methodology may not be able to handle highly complex code bases or highly
    complex changes to code bases without sacrificing some of its development velocity.
    It also tends to require more intensive planning and requirements than the more
    just-in-time approaches such as Scrum and Kanban, since the paired developers
    should, ideally, be able to work on code in as autonomous a fashion as they can
    manage. The more information the pair team has up-front, the less time they will
    have to spend trying to track down information they need, and the less disruption
    will occur to their efforts. XP doesn't really have any method for tracking progress,
    or keeping efforts and roadblocks visible, but adopting or bolting on something
    from some other methodology is certainly possible.
  prefs: []
  type: TYPE_NORMAL
- en: Feature-driven development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary unit of work in a **Feature-Driven Development** (**FDD**) process
    is a feature. Those features are the end result of a detailed System Modeling
    effort, focusing on creating one-to-many domain models in significant detail,
    mapping out where features live in the system's domain, how (or if) they are expected
    to interact with each other—the sort of information that should come out of **use
    cases**, **data structures**, **flow** models, and **Interprocess Communication**
    models. Once the overall model is established, a feature list is constructed and
    prioritized, with a specific view to at least trying to keep the implementation
    time frame of each feature in the list at a reasonable maximum—two weeks seems
    to be the typical limit. If an individual feature is expected to take more than
    the longest acceptable time, it is subdivided until it can be accomplished and
    delivered in that time period.
  prefs: []
  type: TYPE_NORMAL
- en: Once the complete feature list is ready for implementation, iterations around
    completing those features are planned around a fixed time period. In each iteration,
    features or sets of features are assigned to developers, singly or in groups.
    Those developers work out a final implementation design, and review and refine
    it if needed. Once the design is deemed solid, development and testing of code
    to implement the design take place, and the resulting new code is promoted to
    the build- or distribution-ready code base for deployment.
  prefs: []
  type: TYPE_NORMAL
- en: FDD goes hand-in-hand with several development best practices—automated testing,
    configuration management, and regular builds so that, if they aren't a full, formal
    **Continuous Integration** process, they are very close to being one. The feature
    teams are generally small, dynamically formed, and intended to have at least two
    individuals, at a minimum, on them, with the intention of promoting collaboration
    and early feedback, especially on a features' designs and implementation quality.
  prefs: []
  type: TYPE_NORMAL
- en: FDD may be a good option for large and complex systems—by breaking work down
    into small, manageable features, even development in the context of very large,
    very complex systems is going to be maintainable with a good success rate. The
    processes around getting any individual feature up and running are simple and
    easily understood. Barring occasional check-ins to make sure that development
    isn't stalling for some reason, FDD is very lightweight and non-intrusive. Feature
    teams will usually have a lead developer associated with them, who has some responsibility
    for coordinating the development efforts and refining implementation details when
    and if needed. That does mean, however, that the lead developer is less likely
    to contribute to the actual code, particularly if they are spending much of their
    time executing coordination or design-refinement efforts, or mentoring other members
    of the team.
  prefs: []
  type: TYPE_NORMAL
- en: Test-driven design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Test-Driven Design** (**TDD**), as might be expected from its name, is focused
    first and foremost on using automated tests of a code base to direct development
    efforts. The overall process breaks down into the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For each functionality goal (new or enhanced feature) being implemented:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a new test or set of tests that will fail until the code being tested
    meets whatever contract and expectations are being tested.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assure that the new test(s) fail, as expected, for the reasons expected, and
    don't raise any other failures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write code that passes the new test(s). It may be horribly **kludgy** and inelegant
    initially, but this doesn't matter as long as it meets the requirements embedded
    in the test(s).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refine and/or re-factor the new code as needed, retesting to assure that the
    tests still pass, moving it to an appropriate location in the code base if necessary,
    and generally making sure that it meets whatever other standards and expectations
    are present for the code base as a whole.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run all tests to prove that the new code still passes the new tests, and that
    no other tests fail as a result of the new code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'TDD offers some obvious benefits as a process:'
  prefs: []
  type: TYPE_NORMAL
- en: All code in a system will be tested, and have a full suite of regression tests,
    at a minimum
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the primary goal of writing the code is just to pass the tests created
    for it, code will frequently be just enough to achieve that, which usually results
    in smaller, and easier-to-manage code bases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, TDD code tends to be more modular, which is almost always a good
    thing, and in turn that generally lends itself to better architecture, which also
    contributes to more manageable code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The main trade-off, also obviously, is that the test suites have to be created
    and maintained. They will grow as the system grows, and will take longer and longer
    periods of time to execute, though significant increases will (hopefully) take
    a while before they manifest. Creation and maintenance of test suites take time,
    and is a discipline all to itself—some argue that writing good tests is an art
    form, even, and there''s a fair amount of truth to that. On top of that, there''s
    a tendency to look for the wrong sort of metrics to show how well tests perform:
    metrics such as code coverage, or even just the number of individual test cases,
    which indicate nothing about the quality of the tests.'
  prefs: []
  type: TYPE_NORMAL
- en: Development paradigms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programming, when it first appeared, was often limited by hardware capabilities
    and the higher-level languages that were available at the time for simple procedural
    code. A program, in that paradigm, was a sequence of steps, executed from beginning
    to end. Some languages supported subroutines and perhaps even simple function-definition
    capabilities, and there were ways to, for example, loop through sections of the
    code so that a program could continue execution until some termination condition
    was reached, but it was, by and large, a collection of very brute-force, start-to-finish
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: As the capabilities of the underlying hardware improved over time, more sophisticated
    capabilities started to become more readily available—formal functions as they
    are generally thought of now, are more powerful , or at least have a flexible
    loop and other flow control options, and so on. However, outside a few languages
    that were generally accessible only inside the halls and walls of Academia, there
    weren't many significant changes to that procedural approach in mainstream efforts
    until the 1990s, when Object-Oriented Programming first started to emerge as a
    significant, or even dominant paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of a fairly simple procedural program that asks
    for a website URL, reads the data from it, and writes that data to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Object-oriented programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The distinctive feature of Object-Oriented Programming is (no great surprise)
    that it represents data and provides functionality through instances of objects.
    Objects are structures of data, or collections of attributes or properties, that
    have related functionality (methods) attached to them as well. Objects are constructed
    as needed from a class, through a definition of the properties and methods that,
    between them, define what an object is, or has, and what an object can do. An
    OO approach allows programming challenges to be handled in a significantly different,
    and usually more useful, manner than the equivalents in a procedural approach,
    because those object instances keep track of their own data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the same functionality as the simple procedural example shown
    previously, but written using an Object-Oriented approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Although this performs the exact same task, and in the exact same fashion as
    far as the user is concerned, underneath it all is an instance of the `PageReader`
    class that does all the actual work. In the process, it stores various data, which
    could be accessed as a member of that instance. That is, the `page_reader.url`,
    `page_reader.local_file`, and `page_reader.page_data` properties all exist and
    could be retrieved and used if there were a need to retrieve that data, and the
    `page_reader.get_page_data` method could be called again to fetch a fresh copy
    of the data on the page. It''s important to note that the properties are attached
    to the instance, so it''d be possible to have multiple instances of `PageReader`,
    each with it''s own data, that can all do the same things with their own data.
    That is, if the following code were executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It would yield the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bbdc41ff-19c3-4bdd-9c75-fc09be9e6ff2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Object-Oriented design and implementation make the development of a complex
    system, with the attendant complex interactions, considerably easier a fair portion
    of the time, though it may not be a panacea for all development challenges and
    efforts. If the basic principles of good OO designs are adhered to, however, they
    will usually make code easier to write, easier to maintain, and less prone to
    breakage. A full discussion of OO design principles is well beyond the scope of
    this book, but some of the more fundamental ones that can cause a lot of difficulty
    if they aren''t adhered to are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Objects should have a **Single Responsibility**—each should do (or represent)
    one thing, and do so well
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects should be **open** for extension but **closed** for modification—changes
    to what an instance actually does, unless it's a new functionality that flat-out
    doesn't exist, should not require modification to the actual code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects should **encapsulate** what varies—it shouldn't require the use of an
    object to know anything about how it does and what it does, just that it can do
    it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use of objects should be exercises in programming to an interface, not to an
    implementation—this is a complex topic that's worth some detailed discussion,
    with some substance and context, so it'll be looked at in some detail in [Chapter
    9](https://cdp.packtpub.com/hands_on_software_engineering_with_python/wp-admin/post.php?post=375&action=edit),
    *Testing the Business-Objects*, while working out the architecture of the `hms_sys`
    project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Functional Programming** (**FP**) is a development approach centered around
    the concept of passing control through a series of pure functions, and avoiding
    shared state and mutable data structures. That is, the majority of any real functionality
    in FP is wrapped in functions that will always return the same output for any
    given input, and don''t modify any external variables. Technically, a pure function
    should not write data to anywhere—neither logging to a console or file, nor writing
    to a file—and how the need for that sort of output is accommodated is a discussion
    well outside the scope of this book.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the same functionality that was in the previous two examples,
    but written using a Functional Programming approach (if only barely, since the
    task it''s performing isn''t all that complex):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Again, this code performs the exact same function, and it does so with the same
    discrete steps/processes as the previous two examples. It does so, however, without
    having to actually store any of the various data it's using—there are no mutable
    data elements in the process itself, only in the initial input to the `process_page`
    function, and even then, it's not usefully mutable for very long. The main function,
    `process_page`, also doesn't use any mutable values, just the results of other
    function calls. All of the component functions return something, even if it's
    only a `None` value.
  prefs: []
  type: TYPE_NORMAL
- en: Functional Programming is not a new paradigm, but it hasn't become widely accepted
    until relatively recently. It has the potential to be as fundamentally disruptive
    as Object-Oriented Programming was. It's also different, in many respects, so
    that making a transition to it might well be difficult—it relies, after all, on
    substantially different approaches, and on a stateless basis that is very atypical
    in or of other modern development paradigms. That stateless nature, though, and
    the fact that it enforces a rigid sequence of events during execution, have the
    potential to make FP-based code and processes much more stable than their OO or
    procedural counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: Development practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At least two post-development process automation practices have arisen, either
    as a result of some incremental development methodologies, or merely at the same
    time: Continuous Integration and Continuous Delivery (or Deployment).'
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Continuous Integration **(**CI**), in its simplest description, is a repeatable,
    automated process for merging new or altered code into a common, shared environment,
    either on some sort of timed basis, or as a result of some event such as committing
    changes to a source control system. Its primary goal is to try and detect potential
    integration problems as early in the code promotion or deployment process as possible,
    so that any issues that arise can be resolved before they are deployed to a live,
    production branch. In order to implement a CI process, regardless of any tools
    that might be used to control or manage it, there are a few prerequisites:'
  prefs: []
  type: TYPE_NORMAL
- en: Code needs to be maintained in a version control system of some sort, and there
    should be, ideally, one and only one branch that a CI process will execute against.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The build process should be automated, whether it fires off on a predetermined
    schedule, or as a result of a commit to the version control system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As part of that build process, all automated tests (unit tests in particular,
    but any integration or system tests that can be usefully executed should at least
    be considered for inclusion) should execute. When those test fire off may be worth
    discussing, since there may be two or more windows of opportunity, and they both
    have their advantages:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tests executed before the commit and build is complete, if the tools and processes
    can either prevent the commit or build, or roll a commit back to its last good
    state on a test failure, will prevent code that fails its tests from being committed.
    The trade-off in this scenario is that it's possible that conflicting changes
    from two or more code change sources might be significantly tangled and need correspondingly
    significant attention to remedy. Additionally, if the offending code cannot be
    committed, that may make it difficult to hand off the offending code to a different
    developer who might well be able to solve the issue quickly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tests that execute after a build will allow code that's failed one or more tests
    to be committed to the collective code base, but with known issues at a minimum.
    Depending on the shape and scope of those issues, it might well break the build—and
    that can be disruptive to the whole team's productivity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some sort of notification process needs to be in place to alert developers that
    there is an issue—particularly if the issue resulted in a broken build.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The process needs to assure that every commit is tested and successfully buildable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The results of a successful build need to be made available in some fashion—whether
    through some sort of scripted or automated deployment to a specific testing environment,
    making an installer for the new build available for download, or whatever other
    mechanism best suits the product's, team's, or stakeholders' needs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With these in place, the rest of the process is just a case of working out
    some of the process rules and expectations, and implementing, monitoring, and
    adjusting them when/if needed:'
  prefs: []
  type: TYPE_NORMAL
- en: When should commits happen? Daily? At the end of development of a story, feature,
    or whatever unit of work might apply?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How quickly does the commit-test-build process need to run? What steps can be
    taken, if any, to keep it quick enough to be useful?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous delivery or deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Continuous Delivery or Deployment** (**CD**) is a natural extension or offshoot
    of the CI process, taking each successful build, collecting all of the components
    involved, and either deploying it directly (typically for web and cloud-resident
    applications and systems), or taking whatever steps would be necessary to make
    the new build available for deployment—creating a final, end user or production-ready
    installation package, for example—but not actually deploying it.'
  prefs: []
  type: TYPE_NORMAL
- en: A complete CD process will allow for the creation, update, or recreation of
    a production system based solely on information in a source control system. It
    also likely involves some **Configuration Management **and **Release Management **tools
    at the system administration side, and those may well impose specific requirements,
    functionally or architecturally, or both, on a system's design and implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These last several chapters have hopefully given you at least a glimpse into
    all of the moving parts (outside the actual writing of code) in development efforts
    that are useful to be aware of in software engineering. The odds are good that
    any given team or company will have selected which methodology, and what pre-
    and post-development processes are going to be in play. Even so, knowing what
    to expect from them, or what might be causes for concern while working within
    their various combined contexts, is useful information, and often one of the expectations
    that divide programmers from software engineers.
  prefs: []
  type: TYPE_NORMAL
- en: With all of that said and out of the way, it's time to start looking in more
    depth and detail at the meat of any combination of these—the development processes
    themselves. To do that, we need a system—a project to work on.
  prefs: []
  type: TYPE_NORMAL
