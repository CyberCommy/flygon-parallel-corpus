- en: Flux and Mono (Reactor Support) in Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will walk the reader through more practical approaches to
    supporting Reactor in Spring 5, including Flux and Mono. The user will get hands-on
    experience with Flux and Mono, with simple JSON as the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming and benefits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive Core and Streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flux and Mono in Spring REST
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User classes with Reactive—REST
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benefits of Reactive programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's assume we have one million user transactions happening in our application.
    Next year, it is going to increase to 10 million, so we need to scale it. The
    traditional method of doing this is to add enough servers (horizontal scaling).
  prefs: []
  type: TYPE_NORMAL
- en: Instead of doing horizontal scaling, what if we get an option to scale with
    the same servers? Yes, Reactive programming will help us to do that. Reactive
    programming is all about non-blocking applications that are synchronous and event-driven,
    and it doesn't require a lot of threads to scale vertically (within the JVM) rather
    than horizontally (through clustering).
  prefs: []
  type: TYPE_NORMAL
- en: Reactive types are not intended to process requests faster. However, they focus
    more on request concurrency, especially requesting data from a remote server efficiently.
    With Reactive type support, you will get higher-quality service. While comparing
    traditional processing, which blocks the current thread while waiting for a result,
    a Reactive API requests only the amount of data that can be consumed. Reactive
    APIs deal with streams of data, not only with individual elements one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, Reactive programming is about non-blocking, event-driven applications
    that can be scaled with a small number of threads, with back pressure as a main
    component to make sure the producers (emitters) do not overwhelm consumers (receivers).
  prefs: []
  type: TYPE_NORMAL
- en: Reactive Core and Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java 8 introduced Reactive Core, which implements the Reactive programming model
    and is built on top of the Reactive Streams specification, a standard for building
    Reactive applications. As the lambda syntax gives more flexibility to go for the
    event-driven approach Java 8 provides the best way to support Reactive. Also,
    Java's lambda syntax gives us the ability to create and spawn up small and independent
    asynchronous tasks. One of the main goals of Reactive Streams is to address the
    problem of back pressure. We will talk more about back pressure in a later section
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The main difference between Java 8 Streams and Reactive Streams is that Reactive
    is a push model, whereas Java 8 Streams focuses on pulling. In Reactive Streams,
    based on consumer needs and numbers, all events will be pushed to consumers.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming model support is Spring 5's best feature since the last
    release. Also, with the support of the Akka and Play framework, Java 8 provides
    a better platform for Reactive applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reactor is built on top of the Reactive Streams specification. Reactive Streams
    is a bundle of four Java interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Publisher`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Subscriber`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Subscription`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Processor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Publisher` will publish a stream of data items to the subscribers that registered
    with the `Publisher`. Using an executor, the `Publisher` publishes the items to
    the `Subscriber`. Also, `Publisher` makes sure that the `Subscriber` method invocations
    for each subscription are strictly ordered.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Subscriber` consumes items only when requested. You can cancel the receiving
    process any time by using `Subscription`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Subscription` behaves as a message mediator between the `Publisher` and the
    `Subscriber`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Processor` represents a processing stage, which can include both `Subscriber`
    and a `Publisher`. `Processor` can initiate back pressure and cancel the subscription,
    as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Reactive Streams is a specification for asynchronous stream processing, which
    means all events can be produced and consumed asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Back pressures and Reactive Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Back pressure is a mechanism that authorizes the receiver to define how much
    data it wants from the emitter (data provider). The main objective of Reactive
    Streams is all about handling back pressure. It allows:'
  prefs: []
  type: TYPE_NORMAL
- en: The control to go to the receiver, to get data after it is ready to be processed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining and controlling the amount of data to be received
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Efficient handling of the slow emitter / fast receiver or fast emitter / slow
    receiver scenarios
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebFlux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As of September 2017, Spring announced the general availability of 5\. Spring
    5 introduced a Reactive web framework called Spring WebFlux. It is a non-blocking
    web framework that uses Reactor to support the Reactive Streams API.
  prefs: []
  type: TYPE_NORMAL
- en: As traditionally, blocking threads consume resources, there was a necessity
    for non-blocking async programming to play a better role. The Spring tech team
    introduced a non-blocking async programming model to handle a large number of
    concurrent requests, especially for latency-sensitive workloads. This concept
    will be mainly used in mobile applications and microservices. Also, this WebFlux
    will be the best fix for scenarios with many clients and uneven workloads.
  prefs: []
  type: TYPE_NORMAL
- en: Basic REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand the practical part of Reactive components such as Flux and Mono,
    we will have to create our own REST API and start implementing Flux and Mono classes
    in our API. In this chapter, we will build a simple REST web service that returns
    `Aloha`. Before moving into the implementation part, we will focus on the components
    involved in creating a RESTful web service.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Flux and Mono—introduction of Spring 5: Functional Web Framework components'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flux and Mono—in the REST API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flux is one of the main types in Reactor. A Flux is the equivalent of an RxJava
    Observable, capable of emitting zero or more items, and then, optionally, either
    completing or failing.
  prefs: []
  type: TYPE_NORMAL
- en: Flux is one of the Reactive types that implement the `Publisher` interface from
    the Reactive Streams manifesto. Flux's main role is to deal with streams of data.
    Flux mainly represents a stream of *N* elements.
  prefs: []
  type: TYPE_NORMAL
- en: Flux is a publisher, a sequence of events of a specific **Plain Old Java Object**
    (**POJO**) type.
  prefs: []
  type: TYPE_NORMAL
- en: Mono
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mono is another type of Reactor can emit only one item at the most. An asynchronous
    task that just wants to signal completion can use a Mono. Mono mainly deals with
    a stream of one element, as opposed to Flux's *N* elements.
  prefs: []
  type: TYPE_NORMAL
- en: Both Flux and Mono make use of this semantic by coercing to the relevant type
    when using some operations. For example, concatenating two Monos together will
    produce a Flux; on the other hand, calling `single()` on `Flux<T>` will return
    a `Mono <T>`.
  prefs: []
  type: TYPE_NORMAL
- en: Both Flux and Mono are **Reactive Streams** (**RS**) publisher implementations
    and conform to Reactive-pull back pressure.
  prefs: []
  type: TYPE_NORMAL
- en: Mono is used in specific scenarios like an HTTP request that produces only one
    response. In such cases, using Mono would be the right choice.
  prefs: []
  type: TYPE_NORMAL
- en: Returning a `Mono<HttpResponse>` for an HTTP request like the scenario mentioned
    earlier is better than returning a `Flux<HttpResponse>`, as it offers only operators
    that are relevant to a context of zero items or one item.
  prefs: []
  type: TYPE_NORMAL
- en: Mono can be used to represent no-value asynchronous processes that only have
    the concept of completion.
  prefs: []
  type: TYPE_NORMAL
- en: User class with Reactive – REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first chapter, we introduced `Ticket` and `User`, two classes involved
    with our web service. As the `Ticket` class is a little complex compared to the
    `User` class, we will use the `User` class to understand Reactive components.
  prefs: []
  type: TYPE_NORMAL
- en: As Reactive in Spring 5 is not fully stable yet, we are going to talk about
    Reactive in only a few chapters. So we will create a separate package for Reactive-based
    REST APIs. Also, we will add Reactive-based dependencies in our existing `pom.xml`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will have to add all Reactive dependencies. Here, we will add the
    code in our existing `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: For Reactive-related work, you can either use an existing project, or you can
    create a new project to avoid conflicts with the Non-Reactive (plain) REST API.
    You can use [https://start.spring.io](https://start.spring.io) to get the basic
    project, and then update the Maven file with the preceding configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding POM configuration, we have added Reactor dependencies on top
    of our existing dependencies (mentioned as follows):'
  prefs: []
  type: TYPE_NORMAL
- en: '`reactive-streams`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reactor-core`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reactor-netty`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tomcat-embed-core`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-webflux`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are the libraries needed in order to work with Reactors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `User` class components are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`userid`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`username`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`user_email`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`user_type` (admin, general user, CSR)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, we have four variables used for the `User` class. To make it simpler to
    understand Reactive components, we use only two variables (`userid`, `username`).
    Let's create a POJO class with only `userid` and `username`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `User` POJO class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding class, I have used two variables and a constructor to fill
    the variables while instantiating. Also, getters/setters are used to access those
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a Reactive repository for the `User` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have introduced a Reactive repository for `User` and
    a class with only one method, called `getAllUsers`. By using this method, we should
    be able to retrieve a list of users. Let's not talk about Flux now, as it will
    be discussed later.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that this `UserRepository` is an interface. We need to have a concrete
    class to implement this interface in order to use this repository. Let''s create
    a concrete class for this Reactive repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As Java 9 has immutable map available, we can make use of Immutable maps in
    our code. However these immutable objects applicable only for this chapter as
    we don't do any update on the existing entries.
  prefs: []
  type: TYPE_NORMAL
- en: In next chapter, we will use regular map as we need to edit them in CRUD operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the moment, we are able to get a list of users from the concrete class.
    Right now we need a web handler to retrieve the users in the controller. Let''s
    create a handler now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will have to create a server where we can keep REST APIs. In the
    following code, our `Server` class will create one REST API to get users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We will discuss more about how we did this in upcoming chapters. Just make sure
    that you are able to understand that the code is working and you can see the output
    on the browser by accessing the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `Server.class` and you will see the log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can access the API in a browser/SoapUI/Postman, or any other client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have used the `8081` port for the Reactive server, we will only have
    access to `8081` instead of `8080`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen how to set up a Maven build to support our basic implementation
    of a web service. Also, we learned how Maven is helpful in third-party library
    management, as well as Spring Boot, and a basic Spring REST project. In upcoming
    chapters, we will discuss more about Spring REST endpoints and Reactor support.
  prefs: []
  type: TYPE_NORMAL
