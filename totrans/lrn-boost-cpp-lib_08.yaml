- en: Chapter 8. Date and Time Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a short chapter that shows you how to use different Boost libraries
    for performing basic date and time calculations. Most practical software use date
    and time measurements in some form. Applications compute current date and time
    to produce chronological logs of application activity. Specialized programs compute
    schedules for jobs based on complex scheduling policies, and wait for specific
    points in time, or time intervals to elapse. Sometimes, applications even monitor
    their own performance and speed of execution, taking remedial steps as needed
    or raising notifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we look at Boost libraries for performing date and time calculations,
    and measuring code performance. These topics are divided into the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Date and time calculations with Boost `Date Time`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Boost Chrono to measure time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measuring program performance using Boost Timer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Date and time calculations with Boost Date Time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Date and time calculations are important in many software applications, yet
    C++03 had limited support for manipulating dates and performing calculations with
    them. The Boost `Date Time` library provides a set of intuitive interfaces for
    representing dates, timestamps, durations, and time intervals. By allowing simple
    arithmetic operations involving dates, timestamps, durations, and supplementing
    them with a set of useful date/time algorithms, it enables fairly sophisticated
    time and calendar calculations using little code.
  prefs: []
  type: TYPE_NORMAL
- en: Dates from the Gregorian calendar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Gregorian calendar, also known as the Christian calendar, was introduced
    by Pope Gregory XIII in February 1582 and over the next few centuries, replaced
    the Julian calendar in the vast majority of the western world. The `Date_Time`
    library provides a set of types for representing dates and related quantities:'
  prefs: []
  type: TYPE_NORMAL
- en: '`boost::gregorian::date`: We use this type to represent a date in the Gregorian
    calendar.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boost::gregorian::date_duration`: In addition to dates, we also need to represent
    durations—the length of time between two given dates in the calendar—in the unit
    of days. For this, we use the type `boost::gregorian::date_duration`. It refers
    to the same type as `boost::gregorian::days`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boost::date_period`: A fixed date period of the calendar starting at a given
    date and extending for a specific duration is represented using the type `boost::date_period`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating date objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can create objects of type `boost::gregorian::date` using constituent parts
    of a date, namely the year, month, and day of the month. In addition, there are
    a number of factory functions that parse date strings in different formats to
    create objects of `date`. In the following example, we illustrate the different
    ways of creating `date` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 8.1: Using boost::gregorian::date**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A default-constructed date represents an invalid date (line 7); the `is_not_a_date`
    member predicate returns true for such dates (line 8). We can construct dates
    from its constituent parts: year, month, and day. Months can be indicated using
    `enum` values named `Jan`, `Feb`, `Mar`, `Apr`, `May`, `Jun`, `Jul`, `Aug`, `Sep`,
    `Oct`, `Nov`, and `Dec`, which are abbreviated English names of the months of
    the year. Using special factory functions, dates can be constructed from other
    standard representations. We use the `boost::gregorian::from_uk_string` function
    to construct a `date` object from a string in the DD/MM/YYYY format, which is
    standard in UK (line 14). The `boost::gregorian::from_us_string` function is used
    to construct a `date` from a string in the MM/DD/YYYY format used in the US (line
    17). The function `boost::gregorian::from_simple_string` is used to construct
    a `date` from a string in the ISO 8601 YYYY-MM-DD format (line 15), and its undelimited
    form YYYYMMDD can be converted into a `date` object, using the `boost::gregorian::from_undelimited_string`
    function (line 16).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Clocks** provide a way to retrieve the current date and time on a system.
    Boost provides a couple of clocks for this purpose. The `day_clock` type provides
    the `local_day` (line 20) and `universal_day` (line 21) functions, which return
    the current date in the local and UTC time zones, which could be same or differ
    by a day, depending on the time zone and time of the day.'
  prefs: []
  type: TYPE_NORMAL
- en: Using convenient accessor member functions like `day`, `month`, `year`, and
    `day_of_week`, we can get at parts of a `date` (lines 24-25).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Date_Time` library is not a header-only library, and in order to run examples
    in this section, they must be linked to the `libboost_date_time` library. On Unix,
    with g++, you can use the following command line to compile and link examples
    involving Boost Date Time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: See [Chapter 1](ch01.html "Chapter 1. Introducing Boost"), *Introducing Boost*,
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Handling date durations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The duration of time between two dates is represented by `boost::gregorian::date_duration`.
    In the following example, we compute time durations between dates, and add durations
    to dates or subtract durations from dates to derive new dates:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 8.2: Basic date arithmetic**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We compute durations (which can be negative) as the difference of two dates
    (line 9), and print it in the unit of days (line 10). The `date_duration` object
    internally represents durations in unit of days. We can also use the types `boost::gregorian::weeks`,
    `boost::gregorian::months`, and `boost::gregorian::years` to construct `date_duration`
    objects in units of weeks, months, or years. Note that `boost::gregorian::days`
    and `boost::gregorian::date_duration` refer to the same types. We get new dates
    by adding durations to or subtracting them from dates (lines 13, 16).
  prefs: []
  type: TYPE_NORMAL
- en: Date periods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A period starting at a fixed date is represented by the type `boost::gregorian::date_period`.
    In the following example, we construct two date periods, a calendar year, and
    a US fiscal year. We calculate their overlap period, and then determine the date
    of the last Friday of each month in the overlapping period.
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 8.3: Date periods and calendar calculations**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We define date periods in terms of a start and an end date (lines 13, 14). We
    can check whether two periods overlap using the `intersects` member function of
    `date_period` (line 19), and obtain the overlap period using the `intersection`
    member function (line 20). We iterate over a period by creating a `month_iterator`
    at the start date (line 21) and iterating till the end date (line 23) using the
    preincrement operator (line 28). There are different kinds of iterators with different
    periods of iteration. We use `boost::gregorian::month_iterator` to iterate over
    successive months in the period. The `month_iterator` advances the date by a month,
    each time it is incremented. You can also use other iterators like `year_iterator`,
    `week_iterator`, and `day_iterator`, which increment the iterator by a year, a
    week, or a day at a time.
  prefs: []
  type: TYPE_NORMAL
- en: For each month in the period, we want to find the date of the last Friday in
    that month. The `Date Time` library has some interesting algorithm classes for
    calendar calculations of this sort. We use the `boost::gregorian::last_day_of_the_week_in_month`
    algorithm for performing such calculations as the date of the last Friday of a
    month. We construct an object of `last_day_of_the_week_in_month`, the constructor
    arguments being the day of the week (Friday) and the month (lines 24, 25). We
    then call its `get_date` member function, passing to it the particular year for
    which we want the date (line 26).
  prefs: []
  type: TYPE_NORMAL
- en: Posix time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Date_Time` library also provides a set of types for representing time points,
    durations, and periods.
  prefs: []
  type: TYPE_NORMAL
- en: '`boost::posix_time::ptime`: A specific point in time, or a **time point**,
    is represented by the type `boost::posix_time::ptime`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boost::posix_time::time_duration`: Like date durations, the length of time
    between two time points is called a **time duration** and is represented by the
    type `boost::posix_time::time_duration`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boost::posix_time::time_period`: A fixed interval starting at a specific time
    point and ending at another is called a **time period** and is represented by
    the type `boost::posix_time::time_period`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These types and the operations on them together define a **time system**. Posix
    Time uses `boost::gregorian::date` to represent the date part of time points.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing time points and durations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can create an instance of `boost::posix_time::ptime` from its constituent
    parts, that is, date, hours, minutes, seconds, and so on or use factory functions
    that parse timestamp strings. In the following example, we show different ways
    in which we can create `ptime` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 8.4: Using boost::posix_time**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Just as with date objects, a default-constructed `ptime` object (line 9) is
    not a valid time point (line 10). There are clocks that can be used to derive
    the current time of the day, for example, `second_clock` and `microsec_clock`,
    which give the time with second or microsecond units. Calling the `local_time`
    and `universal_time` functions (line 13) on these clocks returns the current date
    and time in the local and UTC time zones respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The `from_time_t` factory function is passed the Unix time, which is the number
    of seconds elapsed since the Unix epoch (January 1, 1970 00:00:00 UTC), and constructs
    a `ptime` object representing that point in time (line 14). The C library function
    `time`, when passed 0, returns the current Unix time in UTC time zone.
  prefs: []
  type: TYPE_NORMAL
- en: The duration between two time points, which can be negative, is computed as
    the difference between two time points (line 24). It can be streamed to an output
    stream for printing the duration, by default, in terms of hours, minutes, seconds,
    and fractional seconds. Using accessor functions `hours`, `minutes`, `seconds`,
    and `fractional_seconds`, we can get the relevant parts of a duration. Or we can
    convert the entire duration to a second or subsecond unit using the accessors
    `total_seconds`, `total_milliseconds`, `total_microseconds`, and `total_nanoseconds`
    (line 26).
  prefs: []
  type: TYPE_NORMAL
- en: We can create a `ptime` object from a Gregorian date and a duration of type
    `boost::posix_time::time_duration` (lines 18-20). We can use the shim types `hours`,
    `minutes`, `seconds`, `microseconds`, and so on in the `boost::posix_time` namespace
    to generate durations of type `boost::posix_time::time_duration` in appropriate
    units and combine them using `operator+`.
  prefs: []
  type: TYPE_NORMAL
- en: We can construct a `ptime` object from just a `boost::gregorian::date` object
    (line 28). This represents the time at midnight on the given date. We can use
    factory functions to create `ptime` objects from different string representations
    (lines 29-30). The function `time_from_string` is used to construct an instance
    of `ptime` from a timestamp string in "YYYY-MM-DD hh:mm:ss.xxx…" format, in which
    the date and time parts are separated by a whitespace (line 29). The function
    `from_iso_string` is used to construct a `ptime` instance from a non-delimited
    string in the "YYYYMMDDThhmmss.xxx…" format, where an uppercase T separates the
    date and time parts (line 30). In both cases, the minutes, seconds, and fractional
    seconds are optional and are taken to be zero if not specified. The fractional
    seconds can follow the seconds, separated by a decimal point. These formats are
    locale dependent. For example, in several European locales, a comma is used instead
    of the decimal point.
  prefs: []
  type: TYPE_NORMAL
- en: We can stream `ptime` objects to output streams like `std::cout` (line 32).
    We can also convert `ptime` instances to `string` using conversion functions like
    `to_simple_string` and `to_iso_string` (lines 32-33). In English locales, the
    `to_simple_string` function converts it to the "YYYY-MM-DD hh:mm:ss.xxx…" format.
    Notice that this is the same format expected by `time_from_string` and is also
    the format used when `ptime` is streamed. The `to_iso_string` function converts
    it to the "YYYYMMDDThhmmss.xxx…" format, same as that expected by `from_iso_string`.
  prefs: []
  type: TYPE_NORMAL
- en: Resolution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The smallest duration that can be represented using a time system is called
    its resolution. The precision with which time can be represented on a particular
    system, and therefore, the number of digits of the fractional seconds that are
    significant, depends on the resolution of the time system. The default resolution
    used by Posix Time is microsecond (10^(-6) seconds), that is, it cannot represent
    durations shorter than a microsecond and therefore cannot differentiate between
    two time points less than a microsecond apart. The following example demonstrates
    how to obtain and interpret the resolution of a time system:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 8.5: Time ticks and resolution**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `resolution` static function of the `time_duration` class returns the resolution
    as an enumerated constant (line 7); we interpret this `enum` and print a string
    to indicate the resolution (lines 7-32).
  prefs: []
  type: TYPE_NORMAL
- en: The `num_fractional_digits` static function returns the number of significant
    digits of the fractional second (line 33); on a system with microsecond resolution,
    this would be 6, and on a system with nanosecond resolution, this would be 9\.
    The `ticks_per_second` static function converts 1 second to the smallest representable
    time unit on the system (line 35); on a system with microsecond resolution, this
    would be 106, and on a system with nanosecond resolution, this would be 109.
  prefs: []
  type: TYPE_NORMAL
- en: Time periods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just as with dates, we can represent fixed time periods using `boost::posix_time::time_period`.
    Here is a short example that shows how you can create time periods and compare
    different time periods:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 8.6: Using time periods**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We create a time period called `starts_now` that starts at the current instant
    and extends for 2 hours into the future. For this, we use the two-argument constructor
    of `time_period`, passing it the current timestamp and a duration of 2 hours (line
    11). Using the `length` member function of `time_period`, we verify that the length
    of the period is indeed 2 hours (line 13).
  prefs: []
  type: TYPE_NORMAL
- en: 'We create two more time periods: `starts_in_1` that starts 1 hour later and
    extends for a duration of 3 hours (line 16), and `starts_in_3` that starts 3 hours
    later and extends for 1 hour (line 20). The member functions `begin` and `last`
    of `time_period` return the first and last time points in the period (lines 26-27).'
  prefs: []
  type: TYPE_NORMAL
- en: We express the relationships between the three time periods, `starts_now`, `starts_in_1`,
    and `starts_in_3`, using relational operators and two member functions called
    `intersects` and `contains`. Clearly, the first hour of `starts_in_1` overlaps
    with the last hour of `starts_now`, so we assert that `starts_now` and `starts_in_1`
    intersect with each other (line 35). The last hour of `starts_in_1` coincides
    with the entire period `starts_in_3`, so we assert that `starts_in_1` contains
    `starts_in_3` (line 37). But `starts_now` and `starts_in_3` do not overlap; therefore,
    we assert that `starts_now` and `starts_in_3` do not intersect (line 32).
  prefs: []
  type: TYPE_NORMAL
- en: The relational `operator<` is defined such that for two time periods `tp1` and
    `tp2`, the condition `tp1 < tp2` holds if and only if `tp1.last() < tp2.begin()`.
    Likewise, `operator>` is defined such that the condition `tp1 > tp2` holds if
    and only if `tp1.begin() > tp2.last()`. These definitions imply that `tp1` and
    `tp2` are disjoint. Thus, for the disjoint `time_period`s `starts_now` and `starts_in_3`,
    the relation `starts_now < starts_in_3` holds (line 31). These relations do not
    make sense for overlapping time periods.
  prefs: []
  type: TYPE_NORMAL
- en: Time iterator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can iterate over a time period using `boost::posix_time::time_iterator`,
    not unlike how we used `boost::gregorian::date_iterator`. The following example
    shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 8.7: Iterating over a time period**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example prints the timestamp for each completed hour in the current
    day. We instantiate a `time_iterator` (line 12), passing it the time point from
    where to begin the iteration (`start_of_day`) and the duration added for each
    increment of the iterator (1 hour). We iterate till the current time, incrementing
    printing the timestamp obtained by dereferencing the iterator (line 15) and incrementing
    the iterator (line 13). Notice that in the expression `iter < now`, we compare
    the iterator with a time point to decide when to stop iteration—a peculiar property
    of `posix_time::time_iterator`, which is not shared with other iterators.
  prefs: []
  type: TYPE_NORMAL
- en: Using Chrono to measure time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Boost Chrono is a library for time calculations having some overlapping functionality
    with the Posix Time part of the `Date Time` library. Like Posix Time, Chrono too
    uses the notion of time points and durations. Chrono does not deal with dates.
    It is a newer library than `Date Time`, and implements the facilities proposed
    in a paper from the C++ Standards Committee working group (WG21). Parts of that
    proposal made it to the C++11 Standard Library as the `Chrono` library, and much
    of the discussion on Boost Chrono also applies to Chrono Standard Library (`std::chrono`).
  prefs: []
  type: TYPE_NORMAL
- en: Durations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A duration represents an interval of time. The duration has a numeric magnitude
    and must be expressed in units of time. The `boost::chrono::duration` template
    is used to represent any such duration and is declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `Representation` type parameter identifies the underlying arithmetic type
    used for the magnitude of durations. The `Period` type parameter identifies tick
    period, which is the magnitude of one unit of time used to measure the duration.
    The period is usually expressed as a ratio or fraction of 1 second, using a template
    called `boost::ratio`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, if we want to express a duration in hundredths of seconds (centiseconds),
    we can use `int64_t` as the underlying type, and the tick period can be represented
    using the ratio (1/100) because the tick period is a hundredth of a second. Using
    `boost::ratio`, we can specialize `duration` to express centisecond intervals
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We create a `typedef` called `centiseconds` and pass `1000`, which is the number
    of centiseconds in the duration, as a constructor argument. `1000` centiseconds
    amounts to (1/100)*1000 seconds, that is, 10 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: The `boost::ratio` template is used to construct a type representing a rational
    number, that is, a ratio of two integers. We specialize `ratio` by passing the
    numerator and denominator of our rational number as its two non-type template
    arguments, in that order. The second argument defaults to 1; therefore, to express
    an integer, say 100, we can simply write `boost::ratio<100>` instead of `boost::ratio<100,
    1>`. The expression `boost::ratio<100>` does not represent a value 100 but a type
    encapsulating the rational number 100.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Chrono` library already provides a set of predefined specializations of
    `duration` for constructing durations expressed in commonly used time units. These
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`boost::chrono::hours` (tick period = `boost::ratio<3600>`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boost::chrono::minutes` (tick period = `boost::ratio<60>`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boost::chrono::seconds` (tick period = `boost::ratio<1>`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boost::chrono::milliseconds` (tick period = `boost::ratio<1, 1000>`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boost::chrono::microseconds` (tick period = `boost::ratio<1, 1000000>`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boost::chrono::nanoseconds` (tick period = `boost::ratio<1, 1000000000>`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Duration arithmetic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Durations can be added and subtracted, and durations in different units can
    be combined to form other durations. Durations in larger units can be implicitly
    converted to durations in smaller units. Implicit conversion from smaller to larger
    units is only possible if you are using a floating point representation; with
    integral representations, such conversions would incur a loss of precision. To
    handle this, we must use a function akin to a casting operator for explicit conversions
    from smaller to larger units with integral representations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 8.8: Using chrono durations**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This example illustrates the different operations you can perform with durations.
    The `boost/chrono/chrono.hpp` header includes most of the Boost Chrono facilities
    we need (line 1). We first create a `duration` of 10 centiseconds (line 9). The
    `count` member function returns the tick count of the duration, that is, the number
    of time units in the duration in the chosen unit, centiseconds (line 10). We can
    directly stream a duration to an output stream (line 11) but need to include the
    additional header `boost/chrono/chrono_io.hpp` for accessing these operators (line
    2). Streaming `csec` prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Boost Ratio provides the appropriate SI unit prefixes based on the time unit
    used by the duration, and these are used to intelligently print the appropriate
    SI prefix. This is not available in the C++11 Standard Library Chrono implementation.
  prefs: []
  type: TYPE_NORMAL
- en: We create second and millisecond durations using the appropriate duration specializations,
    and compute their sum using an overloaded `operator+` (lines 13, 14). The sum
    of a second and a millisecond duration is a millisecond duration. Implicit conversion
    of a duration in milliseconds to a duration in a larger unit like seconds would
    involve loss of precision when the representation of the larger type is an integral
    type. Hence, such implicit conversions are not supported (line 15). For example,
    10 seconds + 20 milliseconds would be computed as 10020 milliseconds. The `boost:::chrono::seconds`
    `typedef` uses a signed integral type representation, and to express 10020 milliseconds
    in seconds, the 20 milliseconds would need to be implicitly rounded off.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `duration_cast` function template, akin to C++ cast operators, to
    perform this conversion (lines 20-21), making the intent explicit. The `duration_cast`
    will effect the rounding off. On the other hand, a duration in seconds can always
    be implicitly converted to a duration in milliseconds, as there is no loss in
    precision (line 17).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Chrono` library is a separately-built library, which also depends on Boost
    System library. Thus, we must link the examples in this section to `libboost_system`.
    On Unix with g++, you can use the following command line to compile and link examples
    involving Boost Chrono:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: For Boost libraries installed at nonstandard locations, refer to [Chapter 1](ch01.html
    "Chapter 1. Introducing Boost"), *Introducing Boost*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we specialized the duration to represent seconds using a `double` instead
    of a signed integer, then things will be different. The following code will compile
    because the `double` representation would be able to accommodate fractional parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We do not cover Boost Ratio in detail in this book, but this chapter introduces
    enough details needed for the purposes of dealing with Boost Chrono. Additionally,
    you can get at the parts of a ratio and print a ratio as a rational number or
    an SI prefix, where that makes sense. The following code illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how we use the `ratio_string` template and its prefix member function
    to print SI prefixes. The code prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `std::ratio` template in the C++11 Standard Library corresponds to Boost
    Ratio and is used by `std::chrono`. There is no `ratio_string` in the Standard
    Library and therefore, SI prefix printing is absent.
  prefs: []
  type: TYPE_NORMAL
- en: Clocks and time points
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A time point is a fixed point in time as opposed to a duration. Given a time
    point, we can add or subtract a duration from it to derive another time point.
    An epoch is a reference time point in some time system that can be combined with
    durations to define other time points. The most famous epoch is the Unix or POSIX
    epoch January 1, 1970 00:00:00 UTC.
  prefs: []
  type: TYPE_NORMAL
- en: 'Boost Chrono provides several clocks for the purpose of measuring time in different
    contexts. A clock has the following associated members:'
  prefs: []
  type: TYPE_NORMAL
- en: A typedef called `duration`, which represents the smallest duration that can
    be expressed using the clock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A typedef called `time_point`, which is the type used to represent time points
    for that clock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A static member function `now`, which returns the current time point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Boost Chrono defines several clocks, some of which may or may not be available
    on your system:'
  prefs: []
  type: TYPE_NORMAL
- en: The `system_clock` type represents the wall clock or system time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `steady_clock` type represents a monotonic time system, which means that
    if the `now` function is called twice serially, the second call will always return
    a time point later than what the first call returned. This is not guaranteed for
    `system_clock`. The `steady_clock` type is available if and only if the `BOOST_CHRONO_HAS_STEADY_CLOCK`
    preprocessor macro is defined.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `high_resolution_clock` type is defined to be a `steady_clock` if it is
    available or else it is defined to be a `system_clock`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding clocks are available as part of `std::chrono` as well. They use
    an implementation-defined epoch and provide functions to convert between `time_point`
    and Unix time (`std::time_t`). The following example illustrates how clocks and
    time points are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 8.9: Using chrono system_clock**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we first print the tick period of the duration associated with
    `system_clock`. The `system_clock::period` is a typedef for `system_clock::duration::period`
    and is the `boost::ratio` type representing the tick period of the duration associated
    with `system_clock` (line 8). We pass it to `boost::ratio_string`, and use the
    `prefix` member function to print the correct SI prefix (lines 9-10).
  prefs: []
  type: TYPE_NORMAL
- en: 'It constructs two time points: a default-constructed time point for `system_clock`
    that represents the epoch of the clock (line 12), and the current time returned
    by the `now` function provided by the `system_clock` (lines 13-14). We then print
    the epoch (line 16), followed by the current time (line 17). Time points are printed
    as the number of time units since the epoch. Note that we use the `time_point_cast`
    function to convert the current time to hours since the epoch. The preceding code
    prints the following on my system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Boost Chrono also provides the following clocks, none of which are available
    as part of the C++ Standard Library Chrono:'
  prefs: []
  type: TYPE_NORMAL
- en: The `process_real_cpu_clock` type for measuring the total time since a program
    started.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `process_user_cpu_clock` type for measuring the time a program runs for
    in the user space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `process_system_cpu` type for measuring the time the kernel runs some code
    on behalf of the program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `thread_clock` type for measuring the total time for which a particular
    thread is scheduled. This clock is available if and only if the `BOOST_CHRONO_HAS_THREAD_CLOCK`
    preprocessor macro is defined.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The process clocks are available if and only if the `BOOST_CHRONO_HAS_PROCESS_CLOCKS`
    preprocessor macro is defined. These clocks can be used akin to the system clocks
    but their epochs are at program start-up for CPU clocks, or thread start-up for
    the thread clocks.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring program performance using Boost Timer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As programmers, we often need to measure performance of a section of code. While
    there are several excellent profiling tools available for this purpose, sometimes,
    being able to instrument our own code is both simple and more precise. The Boost
    Timer library provides an easy-to-use, portable interface for measuring the execution
    times and reporting them by instrumenting your code. It is a separately compiled
    library, not header-only, and internally uses Boost Chrono.
  prefs: []
  type: TYPE_NORMAL
- en: cpu_timer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `boost::timer::cpu_timer` class is used to measure the execution time of
    a section of code. In the following example, we write a function that reads the
    contents of a file and returns it in a dynamic array wrapped in a `unique_ptr`
    (see [Chapter 3](ch03.html "Chapter 3. Memory Management and Exception Safety"),
    *Memory Management and Exception Safety*). It also calculates and prints the time
    taken to read the file using `cpu_timer`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 8.10: Using cpu_timer**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We create an instance of `cpu_timer` at the start of the section of code (line
    20), which starts the timer. At the end of the section, we call the `stop` member
    function on the `cpu_timer` object (line 22), which stops the timer. We call the
    `format` member function to obtain a readable representation of the elapsed time
    and print it to the standard error (line 25). Calling this function with a file
    name, prints the following to the standard input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This indicates that the call to the `read` member function of `fstream` (line
    21) was blocked for 0.111945 seconds. This is the wall clock time, that is, the
    total elapsed time measured by the timer. 0.000000 seconds were spent by the CPU
    in user mode, and 0.060000 seconds were spent by the CPU in the kernel mode (that
    is, in system calls). Note that the read happened entirely in kernel mode, which
    is expected, because it involves invoking system calls (like read on Unix) to
    read the content of the file from the disk. The percentage of elapsed time spent
    by the CPU executing this code is 53.6\. It is computed as the sum of the durations
    spent in user mode and in kernel mode, divided by the total elapsed time, that
    is, (0.0 + 0.06)/0.111945, which is around 0.536.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Code using Boost Timer must link with `libboost_timer` and `libboost_system`.
    To build examples involving Boost Timer with g++ on a POSIX system, use the following
    command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: For Boost libraries installed at nonstandard locations, refer to [Chapter 1](ch01.html
    "Chapter 1. Introducing Boost"), *Introducing Boost*.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to measure the cumulative time taken to open the file, read from
    it and close the file, then we can use a single timer to measure the execution
    times of multiple sections, stopping and resuming the timer as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `resume` member function is called on a stopped timer and it restarts the
    timer, adding to any previous measurements. In the preceding snippet, we stop
    the timer before allocating heap memory (line 19), and resume it immediately afterwards
    (line 22).
  prefs: []
  type: TYPE_NORMAL
- en: There is also a `start` member function, which is called inside the `cpu_timer`
    constructor to start measurements. Calling `start` instead of `resume` on a stopped
    timer would wipe out any previous measurements and effectively reset the timer.
    You can also check whether the timer has stopped using the `is_stopped` member
    function, which returns `true` if the timer has stopped and `false` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get at the elapsed time (wall clock time), CPU time spent in user mode,
    and CPU time spent in kernel mode in nanoseconds by calling the `elapsed` member
    function of `cpu_timer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `elapsed` member function returns an object of type `cpu_times` (line 25),
    which contains three fields called `wall`, `user`, and `system` that carry the
    appropriate durations in units of nanoseconds (10^(-9) seconds).
  prefs: []
  type: TYPE_NORMAL
- en: auto_cpu_timer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `boost::timer::auto_cpu_timer` is a subclass of `cpu_timer` that automatically
    stops the counter at the end of its enclosing scope and writes the measured execution
    time to the standard output or another output stream provided by the user. You
    cannot stop and resume it. When you need to measure the execution of a section
    of code till the end of a scope, you can use just one line of code using `auto_cpu_timer`,
    as shown in the following snippet adapted from listing 8.10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print the measured execution time in the familiar format to the standard
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: To print it to a different output stream, we would need to pass the stream as
    a constructor argument to `timer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To measure the time taken to read the file, we simply declare the `auto_cpu_timer`
    instance before the call to `read` (line 22). If the call to read was not the
    last statement in the scope, and we did not want to measure the execution time
    of what followed, then this would not have worked. Then, we could either use `cpu_timer`
    instead of `auto_cpu_timer`, or put only the statements that we are interested
    in a nested scope with an `auto_cpu_timer` instance created at the start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we create a new scope (lines 22-25) to isolate the
    section of code to measure, using `auto_cpu_timer`.
  prefs: []
  type: TYPE_NORMAL
- en: Self-test questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For multiple choice questions, choose all options that apply:'
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following lines of code is/are not well-formed? Assume that the
    symbols are from the `boost::chrono` namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `milliseconds ms = milliseconds(5) + microseconds(10);`
  prefs: []
  type: TYPE_NORMAL
- en: b. `nanoseconds ns = milliseconds(5) + microseconds(10);`
  prefs: []
  type: TYPE_NORMAL
- en: c. `microseconds us = milliseconds(5) + microseconds(10);`
  prefs: []
  type: TYPE_NORMAL
- en: d. `seconds s = minutes(5) + microseconds(10);`
  prefs: []
  type: TYPE_NORMAL
- en: What does the type `boost::chrono::duration<std::intmax_t, boost::ratio<1, 1000000>>`
    represent?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. A millisecond duration with integral representation
  prefs: []
  type: TYPE_NORMAL
- en: b. A microsecond duration with integral representation
  prefs: []
  type: TYPE_NORMAL
- en: c. A millisecond duration with floating point representation
  prefs: []
  type: TYPE_NORMAL
- en: d. A nanosecond duration with integral representation
  prefs: []
  type: TYPE_NORMAL
- en: What are the differences between `boost::timer::cpu_timer` and `boost::timer::auto_cpu_timer`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `auto_cpu_timer` calls `start` in the constructor, `cpu_timer` does not
  prefs: []
  type: TYPE_NORMAL
- en: b. `auto_cpu_timer` cannot be stopped and resumed
  prefs: []
  type: TYPE_NORMAL
- en: c. `auto_cpu_timer` writes to an output stream at the end of a scope, `cpu_timer`
    does not
  prefs: []
  type: TYPE_NORMAL
- en: d. You can extract the wall, user, and system time from `cpu_timer`, but not
    `auto_cpu_timer`
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced libraries for measuring time and calculating dates.
    This chapter gets you up and running with the basics of date and time calculations,
    without covering the intricate details about sophisticated calendar calculations,
    time zone awareness, and custom and locale-specific formatting. The Boost online
    documentation is an excellent source for these details.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*The C++ Standard Library: A Tutorial and Reference Guide (2/e)*, *Nicolai
    M. Josuttis*, *Addison Wesley Professional*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A Foundation to Sleep On*: *Howard E. Hinnant*, *Walter E. Brown*, *Jeff Garland*,
    and *Marc Paterno* ([http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2661.htm](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2661.htm))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
