- en: Part 2. Persistence and Serialization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2部分。持久性和序列化
- en: '*[Serializing and Saving – JSON, YAML, Pickle, CSV, and XML](ch09.html "Chapter 9. Serializing
    and Saving – JSON, YAML, Pickle, CSV, and XML")*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*[序列化和保存-JSON、YAML、Pickle、CSV和XML](ch09.html "第9章。序列化和保存-JSON、YAML、Pickle、CSV和XML")*'
- en: '*[Storing and Retrieving Objects via Shelve](ch10.html "Chapter 10. Storing
    and Retrieving Objects via Shelve")*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*[通过Shelve存储和检索对象](ch10.html "第10章。通过Shelve存储和检索对象")*'
- en: '*[Storing and Retrieving objects via SQLite](ch11.html "Chapter 11. Storing
    and Retrieving Objects via SQLite")*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*[通过SQLite存储和检索对象](ch11.html "第11章。通过SQLite存储和检索对象")*'
- en: '*[Transmitting and Sharing Objects](ch12.html "Chapter 12. Transmitting and
    Sharing Objects")*'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*[传输和共享对象](ch12.html "第12章。传输和共享对象")*'
- en: '*[Configuration Files and Persistence](ch13.html "Chapter 13. Configuration
    Files and Persistence")*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*[配置文件和持久性](ch13.html "第13章。配置文件和持久性")*'
- en: Persistence and Serialization
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久性和序列化
- en: A persistent object is one that has been written to some storage medium. The
    object can be retrieved from storage and used in a Python application. Perhaps
    the object was represented in JSON and written to the filesystem. Perhaps an **object-relational
    mapping** (**ORM**) layer has represented the object as rows in SQL tables to
    store the object in a database.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 持久对象是已经写入某种存储介质的对象。可以从存储中检索对象并在Python应用程序中使用。也许对象以JSON形式表示并写入文件系统。也许一个**对象关系映射**（**ORM**）层已经将对象表示为SQL表中的行，以将对象存储在数据库中。
- en: 'Serializing objects has two purposes. We serialize objects in order to make
    them persistent in the local filesystem. We also serialize objects in order to
    exchange objects between processes or applications. While the focus is different,
    persistence generally includes serialization; so, a good persistence technique
    will also work for data interchange. We''ll look at several ways in which Python
    handles serialization and persistence. The chapters in this part are organized
    as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化对象有两个目的。我们对对象进行序列化是为了使它们在本地文件系统中持久化。我们还对对象进行序列化，以在进程或应用程序之间交换对象。虽然重点不同，但持久性通常包括序列化；因此，一个良好的持久性技术也将适用于数据交换。我们将看看Python处理序列化和持久性的几种方式。本部分的章节组织如下：
- en: '[Chapter 9](ch09.html "Chapter 9. Serializing and Saving – JSON, YAML, Pickle,
    CSV, and XML"), *Serializing and Saving – JSON, YAML, Pickle, CSV, and XML*, covers
    simple persistence using libraries focused on various data representations: JSON,
    YAML, pickle, XML, and CSV. These are common, widely used formats for Python data.
    They''re suitable for persistence as well as data exchange. They tend to focus
    more on a single object rather than a large domain of objects.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第9章](ch09.html "第9章。序列化和保存-JSON、YAML、Pickle、CSV和XML")，“序列化和保存-JSON、YAML、Pickle、CSV和XML”，涵盖了使用专注于各种数据表示的库进行简单持久化：JSON、YAML、pickle、XML和CSV。这些是Python数据的常见、广泛使用的格式。它们适用于持久性以及数据交换。它们更多地关注单个对象，而不是大量对象的持久性。'
- en: '[Chapter 10](ch10.html "Chapter 10. Storing and Retrieving Objects via Shelve"),
    *Storing and Retrieving Objects via Shelve*, covers basic database operations
    with Python modules such as Shelve (and dBm) in. These provide simple storage
    of Python objects and are focused on the persistence of multiple objects.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第10章](ch10.html "第10章。通过Shelve存储和检索对象")，“通过Shelve存储和检索对象”，涵盖了使用Python模块（如Shelve和dBm）进行基本数据库操作。这些提供了Python对象的简单存储，并专注于多个对象的持久性。'
- en: '[Chapter 11](ch11.html "Chapter 11. Storing and Retrieving Objects via SQLite"),
    *Storing and Retrieving objects via SQLite*, moves to the more complex world of
    SQL and the relational database. Because SQL features don''t match object-oriented
    programming features well, we have an impedance mismatch problem. A common solution
    is to use Object-Relational Mapping to allow us to persist a large domain of objects.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第11章](ch11.html "第11章。通过SQLite存储和检索对象")，“通过SQLite存储和检索对象”，转向更复杂的SQL和关系数据库世界。由于SQL特性与面向对象编程特性不匹配，我们面临阻抗不匹配问题。一个常见的解决方案是使用对象关系映射来允许我们持久化大量对象。'
- en: For web applications, we'll often work with **Representation State Transfer**
    (**REST**). [Chapter 12](ch12.html "Chapter 12. Transmitting and Sharing Objects"),
    *Transmitting and Sharing Objects*, will look at the HTTP protocol, JSON, YAML,
    and XML representation for transmitting an object.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Web应用程序，我们经常使用**表述状态转移**（**REST**）。[第12章](ch12.html "第12章。传输和共享对象")，“传输和共享对象”，将研究HTTP协议，JSON，YAML和XML表示传输对象。
- en: Finally, [Chapter 13](ch13.html "Chapter 13. Configuration Files and Persistence"),
    *Configuration Files and Persistence*, will cover various ways in which a Python
    application can work with a configuration file. There are a number of formats
    and a number of advantages and disadvantages to each. A configuration file is
    simply a collection of persistent objects that can be easily modified by a human
    user.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，[第13章](ch13.html "第13章。配置文件和持久性")，“配置文件和持久性”，将涵盖Python应用程序可以使用配置文件的各种方式。有许多格式，每种格式都有一些优点和缺点。配置文件只是一组可以轻松被人类用户修改的持久对象。
- en: Important topics that arise throughout this part are the design patterns that
    are used at a higher level of abstraction. We'll call these architectural patterns
    because they describe the overall architecture of an application, separating it
    into layers or tiers. We are forced to break an application into pieces so that
    we can practice the principle that is often articulated as **Separation of Concerns**.
    We'll need to separate persistence from other features such as the core processing
    of our application and the presentation of data to users. Mastering object-oriented
    design means looking at higher-level, architectural design patterns.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分中经常出现的重要主题是在更高级别的抽象中使用的设计模式。我们将这些称为架构模式，因为它们描述了应用程序的整体架构，将其分成层或层。我们被迫将应用程序分解成片段，以便我们可以实践通常被表述为**关注点分离**的原则。我们需要将持久性与其他功能（如应用程序的核心处理和向用户呈现数据）分开。精通面向对象的设计意味着要查看更高级别的架构设计模式。
- en: Chapter 9. Serializing and Saving – JSON, YAML, Pickle, CSV, and XML
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。序列化和保存-JSON、YAML、Pickle、CSV和XML
- en: To make a Python object persistent, we must convert it to bytes and write the
    bytes to a file. We'll call this **serialization**; it is also called marshaling,
    deflating or encoding. We'll look at several ways to convert a Python object to
    a string or a stream of bytes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要使Python对象持久，我们必须将其转换为字节并将字节写入文件。我们将其称为**序列化**；它也被称为编组、压缩或编码。我们将研究几种将Python对象转换为字符串或字节流的方法。
- en: Each of these serialization schemes can also be called a **physical data format**.
    Each format offers some advantages and disadvantages. There's no *best* format
    to represent the objects. We must distinguish a **logical data format**, which
    may be a simple reordering or change in the use of whitespace that doesn't change
    the value of the object but changes the sequence of bytes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些序列化方案中的每一个也可以称为**物理数据格式**。每种格式都有一些优点和缺点。没有*最佳*格式来表示对象。我们必须区分**逻辑数据格式**，它可能是简单的重新排序或更改空格使用方式，而不改变对象的值，但改变字节序列。
- en: It's important to note that (except for CSV) these representations are biased
    towards representing a single Python object. While that single object can be the
    list of objects, it's still list of a fixed size. In order to process one of the
    objects, the entire list must be de-serialized. There are ways to perform incremental
    serialization, but they involve extra work. Rather than fiddling with these formats
    to handle multiple objects, there are better approaches to process many distinct
    objects in [Chapters 10](ch10.html "Chapter 10. Storing and Retrieving Objects
    via Shelve"), *Storing and Retrieving Objects via Shelve*, [Chapter 11](ch11.html
    "Chapter 11. Storing and Retrieving Objects via SQLite"), *Storing and Retrieving
    objects via SQLite*, and [Chapter 12](ch12.html "Chapter 12. Transmitting and
    Sharing Objects"), *Transmitting and Sharing Objects*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意（除了CSV），这些表示法偏向于表示单个Python对象。虽然单个对象可以是对象列表，但它仍然是固定大小的列表。为了处理其中一个对象，整个列表必须被反序列化。有方法可以执行增量序列化，但这需要额外的工作。与摆弄这些格式以处理多个对象相比，有更好的方法来处理[第10章](ch10.html
    "第10章。通过Shelve存储和检索对象")中的许多不同对象的方法，*通过Shelve存储和检索对象*，[第11章](ch11.html "第11章。通过SQLite存储和检索对象")，*通过SQLite存储和检索对象*，以及[第12章](ch12.html
    "第12章。传输和共享对象")，*传输和共享对象*。
- en: 'As each of these schemes is focused on a single object, we''re limited to objects
    that fit in the memory. When we need to process a large number of distinct items,
    not all of which can be in memory at once, we can''t use these techniques directly;
    we''ll need to move to a larger database, server, or message queue. We''ll look
    at the following serialization representations:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个方案都专注于单个对象，我们受限于适合内存的对象。当我们需要处理大量不同的项目，而不是所有项目一次性放入内存时，我们无法直接使用这些技术；我们需要转移到更大的数据库、服务器或消息队列。我们将研究以下序列化表示：
- en: '**JavaScript Object Notation** (**JSON**): This is a widely used representation.
    For more information, see [http://www.json.org](http://www.json.org). The `json`
    module provides the classes and functions necessary to load and dump data in this
    format. In *Python Standard Library*, look at section 19, *Internet Data Handling*,
    not section 12, *Persistence*. The `json` module is focused narrowly on the JSON
    representation more than the more general problem of Python object persistence.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript对象表示法（JSON）：这是一种广泛使用的表示法。有关更多信息，请参见[http://www.json.org](http://www.json.org)。`json`模块提供了在此格式中加载和转储数据所需的类和函数。在*Python标准库*中，查看第19节*Internet
    Data Handling*，而不是第12节*Persistence*。`json`模块专注于JSON表示，而不是Python对象持久性的更一般问题。
- en: '**YAML Ain''t Markup Language** (**YAML**): This is an extension to JSON and
    can lead to some simplification of the serialized output. For more information,
    see [http://yaml.org](http://yaml.org). This is not a standard part of the Python
    library; we must add a module to handle this. The `PyYaml` package, specifically,
    has numerous Python persistence features.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: YAML不是标记语言（YAML）：这是对JSON的扩展，可以简化序列化输出。有关更多信息，请参见[http://yaml.org](http://yaml.org)。这不是Python库的标准部分；我们必须添加一个模块来处理这个问题。具体来说，`PyYaml`包具有许多Python持久性特性。
- en: '**pickle**: The `pickle` module has its own Python-specific representation
    for data. As this is a first-class part of the Python library, we''ll closely
    look at how to serialize an object this way. This has the disadvantage of being
    a poor format for the interchange of data with non-Python programs. It''s the
    basis for the `shelve` module in [Chapter 10](ch10.html "Chapter 10. Storing and
    Retrieving Objects via Shelve"), *Storing and Retrieving Objects via Shelve*,
    as well as message queues in [Chapter 12](ch12.html "Chapter 12. Transmitting
    and Sharing Objects"), *Transmitting and Sharing Objects*.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pickle**：`pickle`模块具有其自己的Python特定的数据表示形式。由于这是Python库的一部分，我们将仔细研究如何以这种方式序列化对象。这的缺点是它不适合与非Python程序交换数据。这是[第10章](ch10.html
    "第10章。通过Shelve存储和检索对象")，“通过Shelve存储和检索对象”的`shelve`模块以及[第12章](ch12.html "第12章。传输和共享对象")，“传输和共享对象”中的消息队列的基础。'
- en: '**The Comma-Separated Values (CSV) module**: This can be inconvenient for representing
    complex Python objects. As it''s so widely used, we''ll need to work out ways
    to serialize Python objects in the CSV notation. For references, look at section
    14, *File Formats*, of *Python Standard Library*, not section 12, *Persistence*,
    because it''s simply a file format and little more. CSV allows us to perform an
    incremental representation of the Python object collections that cannot fit into
    memory.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逗号分隔值（CSV）模块：这对于表示复杂的Python对象来说可能不方便。由于它被广泛使用，我们需要想办法以CSV表示法序列化Python对象。有关参考，请查看《Python标准库》第14节“文件格式”，而不是第12节“持久性”，因为它只是一个文件格式，没有更多内容。CSV允许我们对无法放入内存的Python对象集合进行递增表示。
- en: '**XML**: In spite of some disadvantages, this is very widely used, so it''s
    important to be able to convert objects into an XML notation and recover objects
    from an XML document. XML parsing is a huge subject. The reference material is
    in section 20, *Structured Markup Processing Tools*, of *Python Standard Library*.
    There are many modules to parse XML, each with different advantages and disadvantages.
    We''ll focus on `ElementTree`.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XML**：尽管存在一些缺点，但这是非常广泛使用的，因此能够将对象转换为XML表示法并从XML文档中恢复对象非常重要。XML解析是一个庞大的主题。参考资料在《Python标准库》第20节“结构化标记处理工具”中。有许多模块用于解析XML，每个都有不同的优点和缺点。我们将重点关注`ElementTree`。'
- en: Beyond these simple categories, we can also have hybrid problems. One example
    is a spreadsheet encoded in XML. This means that we have a row-and-column data
    representation problem wrapped in the XML parsing problem. This leads to more
    complex software to disentangle the various kinds of data that were flattened
    to CSV-like rows so that we can recover useful Python objects. In [Chapter 12](ch12.html
    "Chapter 12. Transmitting and Sharing Objects"), *Transmitting and Sharing Objects*,
    and [Chapter 13](ch13.html "Chapter 13. Configuration Files and Persistence"),
    *Configuration Files and Persistence*, we'll revisit a number of these topics
    as we use RESTful web services with serialized objects as well as editable serialized
    objects for configuration files.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些简单的类别，我们还可能遇到混合问题。一个例子是用XML编码的电子表格。这意味着我们有一个包裹在XML解析问题中的行列数据表示问题。这导致了更复杂的软件，以解开被扁平化为类似CSV的行的各种数据，以便我们可以恢复有用的Python对象。在[第12章](ch12.html
    "第12章。传输和共享对象")，“传输和共享对象”，以及[第13章](ch13.html "第13章。配置文件和持久性")，“配置文件和持久性”中，我们将重新讨论这些主题，因为我们使用RESTful
    web服务与序列化对象以及可编辑的序列化对象用于配置文件。
- en: Understanding persistence, class, state, and representation
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解持久性、类、状态和表示形式
- en: Primarily, our Python objects exist in volatile computer memory. They can only
    live as long as the Python process is running. They may not even live that long;
    they may only live as long as they have references in a namespace. If we want
    an object that outlives the Python process or namespace, we need to make it persistent.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 主要地，我们的Python对象存在于易失性计算机内存中。它们只能存在于Python进程运行的时间。它们甚至可能活不了那么久；它们可能只能活到它们在命名空间中有引用的时间。如果我们想要一个超出Python进程或命名空间寿命的对象，我们需要使其持久化。
- en: Most operating systems offer persistent storage in the form of a filesystem.
    This usually includes disk drives, flash drives, or other forms of non-volatile
    storage. It seems like it's simply a matter of transferring bytes from the memory
    to a disk file.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数操作系统以文件系统的形式提供持久存储。这通常包括磁盘驱动器、闪存驱动器或其他形式的非易失性存储。这似乎只是将字节从内存传输到磁盘文件的问题。
- en: The complexity arises because our in-memory Python objects have references to
    other objects. An object refers to its class. The class refers to its metaclass
    and any base classes. The object might be a container and refer to other objects.
    The in-memory version of an object is a web of references and relationships. As
    the memory locations are not fixed, the relationships would be broken by trying
    simply to dump and restore memory bytes without rewriting addresses into some
    kind of location-independent key.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂性的原因在于我们的内存中的Python对象引用其他对象。一个对象引用它的类。类引用它的元类和任何基类。对象可能是一个容器，并引用其他对象。对象的内存版本是一系列引用和关系。由于内存位置不固定，尝试简单地转储和恢复内存字节而不将地址重写为某种位置无关的键将会破坏这些关系。
- en: Many of the objects in the web of references are largely static—class definitions,
    for example, change very slowly compared to variables. Ideally, a class definition
    doesn't change at all. However, we may have class-level instance variables. More
    importantly, we need to upgrade our application software, changing class definitions,
    which changes object features. We'll call this the **Schema Migration Problem**,
    managing change to the schema (or class) of our data.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 引用网络中的许多对象在很大程度上是静态的——例如类定义变化非常缓慢，与变量相比。理想情况下，类定义根本不会改变。但是，我们可能有类级实例变量。更重要的是，我们需要升级我们的应用软件，改变类定义，从而改变对象特性。我们将这称为**模式迁移问题**，管理数据模式（或类）的变化。
- en: Python gives us a formal distinction between the instance variables of an object
    and other attributes that are part of the class. Our design decisions leverage
    this distinction. We define an object's instance variables to properly show the
    dynamic state of the object. We use class-level attributes for information that
    objects of that class will share. If we can persist only the dynamic state of
    an object—separated from the class and the web of references that are part of
    the class definition—that would be a workable solution to serialization and persistence.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Python为对象的实例变量和类的其他属性之间给出了正式的区别。我们的设计决策利用了这一区别。我们定义对象的实例变量来正确显示对象的动态状态。我们使用类级属性来存储该类的对象将共享的信息。如果我们只能持久化对象的动态状态——与类和类定义的引用网络分开——那将是一种可行的序列化和持久化解决方案。
- en: We don't actually have to do anything to persist our class definitions; we already
    have an entirely separate and very simple method for that. Class definitions exist
    primarily as source code. The class definition in the volatile memory is rebuilt
    from the source (or the byte-code version of the source) every time it's needed.
    If we need to exchange class definition, we exchange Python modules or packages.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们不必做任何事情来持久化我们的类定义；我们已经有一个完全独立且非常简单的方法来做到这一点。类定义主要存在于源代码中。易失性内存中的类定义是从源代码（或源代码的字节码版本）中每次需要时重新构建的。如果我们需要交换类定义，我们交换Python模块或包。
- en: Common Python terminologies
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常见的Python术语
- en: 'Python terminology tends to focus on the words *dump* and *load*. Most of the
    various classes we''re going to work will define methods such as the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Python术语往往侧重于*转储*和*加载*这两个词。我们将要使用的大多数各种类都将定义以下方法：
- en: '`dump(object, file)`: This will dump the given object to the given file'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dump(object, file)`: 这将把给定的对象转储到给定的文件中'
- en: '`dumps(object)`: This will dump an object, returning a string representation'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dumps(object)`: 这将转储一个对象，并返回一个字符串表示'
- en: '`load(file)`: This will load an object from the given file, returning the constructed
    object'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load(file)`: 这将从给定的文件加载一个对象，并返回构造的对象'
- en: '`loads(string)`: This will load an object from a string representation, returning
    the constructed object'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loads(string)`: 这将从一个字符串表示中加载一个对象，并返回构造的对象'
- en: There's no standard; the method names aren't *guaranteed* by any formal ABC
    inheritance or the mixin class definition. However, they're widely used. Generally,
    the file used for the dump or load can be any *file-like* object. A short list
    of methods such as `read()` and `readline()` are required for the load, but we
    need little more than this. We can, therefore, use the `io.StringIO` objects as
    well as the `urllib.request` objects as sources for the load. Similarly, dump
    places few requirements on the data source. We'll dig into these file object considerations
    next.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 没有标准；方法名并不是由任何正式的ABC继承或混合类定义*保证*的。然而，它们被广泛使用。通常，用于转储或加载的文件可以是任何*类似文件*的对象。加载需要一些方法，如`read()`和`readline()`，但我们不需要更多。因此，我们可以使用`io.StringIO`对象以及`urllib.request`对象作为加载的来源。同样，转储对数据源的要求很少。我们将在下一节中深入探讨这些文件对象的考虑。
- en: Filesystem and network considerations
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件系统和网络考虑因素
- en: As the OS filesystem (and network) works in bytes, we need to represent the
    values of an object's instance variables as a serialized stream of bytes. Often,
    we'll use a two-step transformation to bytes; we'll represent the state of an
    object as a string and rely on the Python string to provide bytes in a standard
    encoding. Python's built-in features for encoding a string into bytes neatly solves
    this part of the problem.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于操作系统文件系统（和网络）以字节为单位工作，我们需要将对象的实例变量的值表示为序列化的字节流。通常，我们会使用两步转换为字节；我们将对象的状态表示为一个字符串，并依赖于Python字符串提供标准编码的字节。Python内置的将字符串编码为字节的功能很好地解决了问题的这一部分。
- en: 'When we look at our OS filesystems, we see two broad classes of devices: block-mode
    devices and character-mode devices. Block-mode devices can also be called *seekable*
    because the OS supports a seek operation that can access any byte in the file
    in an arbitrary order. Character-mode devices are not seekable; they are interfaces
    where bytes are transmitted serially. Seeking would involve travelling backwards
    in time.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看操作系统文件系统时，我们会看到两类广泛的设备：块模式设备和字符模式设备。块模式设备也可以称为*可寻址*，因为操作系统支持可以以任意顺序访问文件中的任何字节的寻址操作。字符模式设备不可寻址；它们是以串行方式传输字节的接口。寻址将涉及向后移动时间。
- en: 'This distinction between `character` and block mode can have an impact on how
    we represent the state of a complex object or a collection of objects. The serializations
    we''ll look at in this chapter focus on the simplest common feature set: an ordered
    stream of bytes; these formats make no use of seekable devices; they will save
    the stream of bytes into either character-mode or block-mode block-mode file.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 字符和块模式之间的这种区别可能会影响我们如何表示复杂对象或对象集合的状态。本章中我们将要讨论的序列化重点是最简单的常见特性集：有序的字节流；这些格式不使用可寻址设备；它们将将字节流保存到字符模式或块模式文件中。
- en: The formats we'll look at in [Chapter 10](ch10.html "Chapter 10. Storing and
    Retrieving Objects via Shelve"), *Storing and Retrieving Objects via Shelve*,
    and [Chapter 11](ch11.html "Chapter 11. Storing and Retrieving Objects via SQLite"),
    *Storing and Retrieving Objects via SQLite*, however, will require block-mode
    storage in order to encode more objects than could possibly fit into memory. The
    `shelve` module and the `SQLite` database make extensive use of seekable files.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在[第10章](ch10.html "第10章。通过Shelve存储和检索对象")和[第11章](ch11.html "第11章。通过SQLite存储和检索对象")中我们将要讨论的格式，*通过Shelve存储和检索对象*和*通过SQLite存储和检索对象*，将需要块模式存储以便编码更多的对象，而不是可能适合内存的对象。`shelve`模块和`SQLite`数据库广泛使用可寻址文件。
- en: A minor confounding factor is the way that the OS unifies block- and character-mode
    devices into a single filesystem metaphor. Some parts of the Python Standard Library
    implement the lowest-common feature set between the block and character devices.
    When we use Python's `urllib.request`, we can access the network resources, as
    well as local files for the data. When we open a local file, this module must
    impose the limited character-mode interface on an otherwise seekable kind of file.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小的令人困惑的因素是操作系统将块和字符模式设备统一到一个单一的文件系统隐喻中的方式。Python 标准库的一些部分实现了块和字符设备之间的最低公共特性集。当我们使用
    Python 的 `urllib.request` 时，我们可以访问网络资源，以及本地文件的数据。当我们打开一个本地文件时，这个模块必须对一个本来是可寻址的文件施加有限的字符模式接口。
- en: Defining classes to support persistence
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义支持持久性的类
- en: 'Before we can work with persistence, we need some objects that we want to save.
    There are several design considerations related to persistence, so we''ll start
    with some simple class definitions. We''ll look at a simple microblog and the
    posts on that blog. Here''s a class definition for `Post`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以处理持久性之前，我们需要一些我们想要保存的对象。与持久性相关的有几个设计考虑，所以我们将从一些简单的类定义开始。我们将看一个简单的微博和该博客上的帖子。这里是
    `Post` 的一个类定义：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The instance variables are the attributes of each microblog post: a date, a
    title, some text, and some tags. Our attribute name provides us a hint that the
    text should be in RST markup, even though that''s largely irrelevant to the rest
    of the data model.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 实例变量是每个微博帖子的属性：日期、标题、一些文本和一些标签。我们的属性名称为我们提供了一个提示，即文本应该是 RST 标记，尽管这对于数据模型的其余部分来说并不重要。
- en: To support simple substitution into templates, the `as_dict()` method returns
    a dictionary of values that have been converted into string format. We'll look
    at the template processing using `string.Template` later.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持简单的替换到模板中，`as_dict()` 方法返回一个值的字典，这些值已经转换为字符串格式。我们稍后会看一下使用 `string.Template`
    进行模板处理。
- en: 'Additionally, we''ve added a few values to help with creating the RST output.
    The `tag_text` attribute is a flattened text version of the tuple of tag values.
    The `underline` attribute produces an underline string with a length that matches
    the title string; this helps the RST formatting work out nicely. We''ll also create
    a blog as a collection of posts. We''ll make this collection more than a simple
    list by including an additional attribute of a title. We have three choices for
    the collection design: wrap, extend, or invent a new class. We''ll head off some
    confusion by providing this warning: don''t extend a `list` if you intend to make
    it persistent.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们添加了一些值来帮助创建 RST 输出。`tag_text` 属性是标签值元组的扁平文本版本。`underline` 属性生成一个与标题字符串长度相匹配的下划线字符串；这有助于
    RST 格式化工作得很好。我们还将创建一个博客作为帖子的集合。我们将通过包括标题的附加属性使这个集合不仅仅是一个简单的列表。我们有三种选择用于集合设计：包装、扩展或发明一个新的类。我们将通过提供这个警告来避免一些混淆：如果你打算使它持久化，不要扩展一个
    `list`。
- en: Tip
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Extending an iterable object can be confusing**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**扩展可迭代对象可能会令人困惑**'
- en: When we extend a sequence, we might confuse some of the built-in serialization
    algorithms. The built-in algorithms may wind up bypassing the extended features
    we put in a subclass of a sequence. Wrapping a sequence is usually a better idea
    than extending one.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们扩展一个序列时，可能会混淆一些内置的序列化算法。内置算法可能会绕过我们在序列的子类中放入的扩展特性。包装序列通常比扩展序列更好。
- en: 'This forces us to look at wrapping or inventing. It''s a simple sequence, so
    why invent something new? Wrapping is what we''ll emphasize on as a design strategy.
    Here''s a collection of microblog posts. We''ve wrapped a list, as extending a
    list won''t always work well:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这迫使我们考虑包装或发明。这是一个简单的序列，为什么要发明新的东西呢？包装是我们将强调的设计策略。这里有一系列微博帖子。我们已经包装了一个列表，因为扩展列表并不总是有效的：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In addition to wrapping the list, we've also included an attribute that is the
    title of the microblog. The initializer uses a common technique to avoid providing
    a mutable object as a default value. We've provided `None` as the default value
    for `posts`. If `posts` is `None`, we use a freshly-minted empty list, `[]`. Otherwise,
    we use the given value for posts.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 除了包装列表，我们还包括了一个微博的标题属性。初始化程序使用了一种常见的技术，以避免提供可变对象作为默认值。我们为 `posts` 提供了 `None`
    作为默认值。如果 `posts` 是 `None`，我们使用一个新创建的空列表 `[]`。否则，我们使用给定的 `posts` 值。
- en: Additionally, we've defined a method that indexes the posts by their tags. In
    the resulting `defaultdict`, each key is a tag's text. Each value is a list of
    posts that share the given tag.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们定义了一个按标签索引帖子的方法。在生成的 `defaultdict` 中，每个键都是一个标签的文本。每个值都是共享给定标签的帖子的列表。
- en: 'To simplify the use of `string.Template`, we''ve added another `as_dict()`
    method that boils the entire blog down to a simple dictionary of strings and dictionaries.
    The idea here is to produce only built-in types that have simple string representations.
    We''ll show you the template rendering process next. Here''s some sample data:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化使用 `string.Template`，我们添加了另一个 `as_dict()` 方法，将整个博客简化为一个简单的字符串和字典的字典。这里的想法是只产生具有简单字符串表示的内置类型。接下来我们将展示模板渲染过程。这里是一些示例数据：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We've serialized the `Blog` and `Post` as the Python code. This isn't really
    all bad as a way to represent the blog. There are some use cases where Python
    code is a perfectly fine representation for an object. In [Chapter 13](ch13.html
    "Chapter 13. Configuration Files and Persistence"), *Configuration Files and Persistence*,
    we'll look more closely at simply using Python to encode data.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将 `Blog` 和 `Post` 序列化为 Python 代码。这并不是一个完全糟糕的表示博客的方式。有一些用例中，Python 代码是对象的一个完全合适的表示。在[第13章](ch13.html
    "第13章。配置文件和持久性") *配置文件和持久性* 中，我们将更仔细地看一下简单地使用 Python 编码数据。
- en: Rendering a blog and posts
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 渲染博客和帖子
- en: Just to be complete, here's a way to render the blog into RST. From this output
    file, the docutils `rst2html.py` tool can transform the RST output into the final
    HTML file. This saves us from having to digress into HTML and CSS. Also, we're
    going to use RST to write the documentation in [Chapter 18](ch18.html "Chapter 18. Quality
    and Documentation"), *Quality and Documentation* For more information on docutils,
    see *Some Preliminaries*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，这里有一种将博客呈现为RST的方法。从这个输出文件中，docutils的`rst2html.py`工具可以将RST输出转换为最终的HTML文件。这样我们就不必深入研究HTML和CSS了。此外，我们将使用RST来编写[第18章](ch18.html
    "第18章。质量和文档")中的文档，*质量和文档*有关docutils的更多信息，请参见*一些准备工作*。
- en: 'We can use the `string.Template` class to do this. However, it''s clunky and
    complex. There are a number of add-on template tools that can perform a more sophisticated
    substitution, including loops and conditional processing within the template itself.
    Here''s a list of alternatives: [https://wiki.python.org/moin/Templating](https://wiki.python.org/moin/Templating).
    We''re going to show you an example using the Jinja2 template tool. See [https://pypi.python.org/pypi/Jinja2](https://pypi.python.org/pypi/Jinja2).
    Here''s a script to render this data in RST using a template:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`string.Template`类来做到这一点。然而，这很笨拙和复杂。有许多附加的模板工具可以在模板本身内执行更复杂的替换，包括循环和条件处理。这里有一些替代方案：[https://wiki.python.org/moin/Templating](https://wiki.python.org/moin/Templating)。我们将向您展示一个使用Jinja2模板工具的示例。请参阅[https://pypi.python.org/pypi/Jinja2](https://pypi.python.org/pypi/Jinja2)。这是一个使用模板在RST中呈现这些数据的脚本：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `{{title}}` and `{{underline}}` elements (and all similar elements) show
    us how values are substituted into the text of the template. The `render()` method
    is called with `**travel.as_dict()` to ensure that attributes such as `title`
    and `underline` will be keyword arguments.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`{{title}}`和`{{underline}}`元素（以及所有类似的元素）向我们展示了如何将值替换为模板文本。使用`render()`方法调用`**travel.as_dict()`，以确保属性（如`title`和`underline`）将成为关键字参数。'
- en: 'The `{%for%}` and `{%endfor%}` constructs show us how Jinja can iterate through
    the sequence of `Post` entries in `Blog`. Within the body of this loop, the variable
    `e` will be the dictionary created from each `Post`. We''ve picked specific keys
    out of the dictionary for each post: `{{e.title}}`, `{{e.rst_text}}`, and so on.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`{%for%}`和`{%endfor%}`构造向我们展示了Jinja如何遍历`Blog`中`Post`条目的序列。在此循环的主体中，变量`e`将是从每个`Post`创建的字典。我们从字典中为每个帖子挑选了特定的键：`{{e.title}}`、`{{e.rst_text}}`等。'
- en: We also iterated through a `tags` collection for the `Blog`. This is a dictionary
    with the keys of each tag and the posts for the tag. The loop will visit each
    key, assigned to `t`. The body of the loop will iterate through the posts in the
    dictionary value, `tags[t]`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还遍历了`Blog`的`tags`集合。这是一个字典，其中包含每个标签的键和该标签的帖子。循环将访问每个键，分配给`t`。循环的主体将遍历字典值中的帖子，即`tags[t]`。
- en: The ``{{post.title}}`_` construct is an RST markup that generates a link to
    the section that has that title within the document. This kind of very simple
    markup is one of the strengths of RST. We've used the blog titles as sections
    and links within the index. This means that the titles *must* be unique or we'll
    get RST rendering errors.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '``{{post.title}}`_`构造是一个RST标记，它生成一个链接到文档中具有该标题的部分。这种非常简单的标记是RST的优势之一。我们已经将博客标题用作索引中的部分和链接。这意味着标题*必须*是唯一的，否则我们将获得RST呈现错误。'
- en: Because this template iterates through a given blog, it will render all of the
    posts in one smooth motion. The `string.Template`, which is built-in to Python,
    can't iterate. This makes it a bit more complex to render all of the `Posts` of
    a `Blog`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个模板遍历给定的博客，它将以一种平稳的动作呈现所有的帖子。内置于Python的`string.Template`不能进行迭代。这使得呈现`Blog`的所有`Posts`变得更加复杂。
- en: Dumping and loading with JSON
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JSON进行转储和加载
- en: 'What is JSON? A section from the [www.json.org](http://www.json.org) web page
    states that:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: JSON是什么？来自[www.json.org](http://www.json.org)网页的一节指出：
- en: JSON (JavaScript Object Notation) is a lightweight data-interchange format.
    It is easy for humans to read and write. It is easy for machines to parse and
    generate. It is based on a subset of the JavaScript Programming Language, Standard
    ECMA-262 3rd Edition - December 1999\. JSON is a text format that is completely
    language independent but uses conventions that are familiar to programmers of
    the C-family of languages, including C, C++, C#, Java, JavaScript, Perl, Python,
    and many others. These properties make JSON an ideal data-interchange language.
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JSON（JavaScript对象表示）是一种轻量级的数据交换格式。人类很容易阅读和书写。机器很容易解析和生成。它基于JavaScript编程语言的一个子集，标准ECMA-262第3版-1999年12月。JSON是一种完全与语言无关的文本格式，但使用了熟悉C系列语言的程序员的约定，包括C、C++、C#、Java、JavaScript、Perl、Python等。这些特性使JSON成为一种理想的数据交换语言。
- en: This format is used by a broad spectrum of languages and frameworks. Databases
    such as CouchDB represent their data as JSON objects, simplifying the transmission
    of data between applications. JSON documents have the advantage of looking vague
    like Python `list` and `dict` literal values. They're easy to read and easy to
    edit manually.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这种格式被广泛用于各种语言和框架。诸如CouchDB之类的数据库将其数据表示为JSON对象，简化了应用程序之间的数据传输。JSON文档具有类似Python
    `list`和`dict`文字值的优势。它们易于阅读和手动编辑。
- en: 'The `json` module works with the built-in Python types. It does not work with
    classes defined by us until we take some additional steps. We''ll look at these
    extension techniques next. For the following Python types, there''s a mapping
    to JavaScript types that JSON uses:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`json`模块与内置的Python类型一起使用。它不适用于我们定义的类，直到我们采取一些额外的步骤。接下来我们将看看这些扩展技术。对于以下Python类型，有一个映射到JSON使用的JavaScript类型：'
- en: '| Python type | JSON |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| Python类型 | JSON |'
- en: '| --- | --- |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `dict` | `object` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `dict` | `object` |'
- en: '| `list, tuple` | `array` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `list, tuple` | `array` |'
- en: '| `str` | `string` |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `str` | `string` |'
- en: '| `int, float` | `number` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `int, float` | `number` |'
- en: '| `True` | `true` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `True` | `true` |'
- en: '| `False` | `false` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `False` | `false` |'
- en: '| `None` | `null` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `None` | `null` |'
- en: 'Other types are not supported and must be coerced to one of these via the extension
    functions that we can plug into the dump and load functions. We can explore these
    built-in types by transforming our microblog objects into simpler Python `lists`
    and `dicts`. When we look at our `Post` and `Blog` class definitions, we have
    already defined the `as_dict()` methods that reduce our custom class objects to
    built-in Python objects. Here''s the code required to produce a JSON version of
    our blog data:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 其他类型不受支持，必须通过我们可以插入到dump和load函数中的扩展函数来强制转换为这些类型之一。我们可以通过将我们的微博对象转换为更简单的Python`lists`和`dicts`来探索这些内置类型。当我们查看我们的`Post`和`Blog`类定义时，我们已经定义了`as_dict()`方法，将我们的自定义类对象减少为内置的Python对象。以下是生成我们博客数据的JSON版本所需的代码：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here''s the output:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding output shows us how each of the various objects are translated
    from Python to the JSON notation. What''s elegant about this is that our Python
    objects have been written into a standardized notation. We can share them with
    other applications. We can write them to disk files and preserve them. There are
    several unpleasant features of the JSON representation:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出向我们展示了各种对象是如何从Python转换为JSON表示的。这种方法的优雅之处在于我们的Python对象已经被写入了一个标准化的表示法。我们可以与其他应用程序共享它们。我们可以将它们写入磁盘文件并保存它们。JSON表示的一些不愉快特性有：
- en: We had to rewrite our Python objects into dictionaries. It would be much nicer
    to transform Python objects more simply, without explicitly creating additional
    dictionaries.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不得不将我们的Python对象重写为字典。更好的方法是以更简单的方式转换Python对象，而不需要显式创建额外的字典。
- en: We can't rebuild our original `Blog` and `Post` objects easily when we load
    this JSON representation. When we use `json.load()`, we won't get `Blog` or `Post`
    objects; we'll just get `dict` and list objects. We need to provide some additional
    hints to rebuild the `Blog` and `Post` objects.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们加载这个JSON表示时，我们无法轻松地重建我们原来的`Blog`和`Post`对象。当我们使用`json.load()`时，我们得到的不是`Blog`或`Post`对象，而是`dict`和列表对象。我们需要提供一些额外的提示来重建`Blog`和`Post`对象。
- en: There are some values in the object's `__dict__` that we'd rather not persist,
    such as the underlined text for a `Post`.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的`__dict__`中有一些值我们不想持久化，比如`Post`的下划线文本。
- en: We need something more sophisticated than the built-in JSON encoding.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要比内置的JSON编码更复杂的东西。
- en: Supporting JSON in our classes
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在我们的类中支持JSON
- en: In order to properly support JSON, we need to inform the JSON encoders and decoders
    about our classes. For encoding our objects into JSON, we need to provide a function
    that will reduce our objects to Python primitive types. This is called a *default*
    function; it provides a default encoding for an object of an unknown class.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确支持JSON，我们需要通知JSON编码器和解码器关于我们的类。为了将我们的对象编码为JSON，我们需要提供一个函数，将我们的对象减少为Python原始类型。这被称为*默认*函数；它为未知类的对象提供默认编码。
- en: To decode our objects from JSON, we need to provide a function that will transform
    a dictionary of Python primitive types back into an object of the proper class.
    This is called the *object hook* function; it's used to transform `dict` to an
    object of a customized class.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从JSON中解码我们的对象，我们需要提供一个函数，将Python原始类型的字典转换回适当类的对象。这被称为*对象钩子*函数；它用于将`dict`转换为自定义类的对象。
- en: 'The `json` module documentation suggests that we might want to make use of
    class hinting. The Python documentation includes a reference to the JSON-RPC version
    1 specification. See [http://json-rpc.org/wiki/specification](http://json-rpc.org/wiki/specification).
    This suggestion is to encode an instance of a customized class as a dictionary
    like the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`json`模块文档建议我们可能希望使用类提示。Python文档包括对JSON-RPC版本1规范的引用。参见[http://json-rpc.org/wiki/specification](http://json-rpc.org/wiki/specification)。这个建议是将自定义类的实例编码为以下的字典：'
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The suggested value associated with the `"__jsonclass__"` key is a list of
    two items: the class name and a list of arguments required to create an instance
    of that class. The specification allows for more features, but they''re not relevant
    to Python.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 与`"__jsonclass__"`键关联的建议值是一个包含两个项目的列表：类名和创建该类实例所需的参数列表。规范允许更多的特性，但它们与Python无关。
- en: To decode an object from a JSON dictionary, we can look for the `"__jsonclass__"`
    key as a hint that one of our classes needs to be built, not a built-in Python
    object. The class name can be mapped to a class object and the argument sequence
    can be used to build the instance.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从JSON字典中解码对象时，我们可以查找`"__jsonclass__"`键作为提示，表明我们需要构建一个类，而不是一个内置的Python对象。类名可以映射到一个类对象，并且参数序列可以用来构建实例。
- en: When we look at other sophisticated JSON encoders (such as the one that comes
    with the Django Web framework), we can see that they provide a bit more complex
    encoding of a custom class. They include the class, a database primary key, and
    the attribute values. We'll look at how we implement customized encoding and decoding.
    The rules are represented as simple functions that are plugged into the JSON encoding
    and decoding functions.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看其他复杂的JSON编码器（比如Django Web框架自带的编码器）时，我们可以看到它们提供了更复杂的自定义类编码。它们包括类、数据库主键和属性值。我们将看看如何实现自定义编码和解码。规则被表示为简单的函数，这些函数被插入到JSON编码和解码函数中。
- en: Customizing JSON encoding
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义JSON编码
- en: 'For class hinting, we''ll provide three pieces of information. We''ll include
    a `__class__` key that names the target class. The `__args__` key will provide
    a sequence of positional argument values. A `__kw__` key will provide a dictionary
    of keyword argument values. This will cover all the options of `__init__()`. Here''s
    an encoder that follows this design:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类提示，我们将提供三个信息。我们将包括一个`__class__`键，命名目标类。`__args__`键将提供一个位置参数值的序列。`__kw__`键将提供一个关键字参数值的字典。这将涵盖`__init__()`的所有选项。以下是遵循这种设计的编码器：
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This function shows us two different flavors of object encodings for the three
    classes:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数展示了三个类的两种不同风格的对象编码：
- en: We encoded a `datetime.datetime` object as a dictionary of individual fields
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将一个`datetime.datetime`对象编码为一个单独字段的字典
- en: We also encoded a `Post` instance as a dictionary of individual fields
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还将一个`Post`实例编码为一个单独字段的字典
- en: We encoded a `Blog` instance as a sequence of title and post entries
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将一个`Blog`实例编码为标题和文章条目的序列
- en: 'If we can''t process the class, we invoke the existing encoder''s default encoding.
    This will handle the built-in classes. We can use this function to encode as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们无法处理这个类，我们会调用现有编码器的默认编码。这将处理内置类。我们可以使用这个函数进行编码，如下所示：
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We provided our function, `blog_encode()`, as the `default=` keyword parameter
    to the `json.dumps()` function. This function is used by the JSON encoder to determine
    the encoding for an object. This encoder leads to JSON objects that look like
    the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的函数`blog_encode()`作为`json.dumps()`函数的`default=`关键字参数提供。这个函数被JSON编码器用来确定对象的编码。这个编码器导致的JSON对象看起来像下面的代码：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We've taken out the second blog entry because the output was rather long. A
    `Blog` object is now wrapped with a `dict` that provides the class and two positional
    argument values. The `Post` and `datetime` objects, similarly, are wrapped with
    the class name and the keyword argument values.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们删除了第二个博客条目，因为输出太长了。现在，`Blog`对象用一个提供类和两个位置参数值的`dict`包装起来。同样，`Post`和`datetime`对象也用类名和关键字参数值包装起来。
- en: Customizing JSON decoding
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义JSON解码
- en: In order to decode a JSON object, we need to work within the structure of a
    JSON parsing. Objects of our customized class definitions were encoded as simple
    `dicts`. This means that each `dict` decoded by the JSON decoder *could* be one
    of our customized classes. Or, `dict` could just be a `dict`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解码一个JSON对象，我们需要在JSON解析的结构内工作。我们定制的类定义的对象被编码为简单的`dicts`。这意味着每个被JSON解码的`dict`
    *可能* 是我们定制的类之一。或者，`dict`可能只是一个`dict`。
- en: 'The JSON decoder "object hook" is a function that''s invoked for each `dict`
    to see if it represents a customized object. If `dict` isn''t recognized by the
    `hook` function, then it''s just a dictionary and should be returned without modification.
    Here''s our object hook function:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: JSON解码器的“对象钩子”是一个函数，它会为每个`dict`调用，以查看它是否表示一个定制对象。如果`dict`不被`hook`函数识别，那么它只是一个字典，应该原样返回。这是我们的对象钩子函数：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Each time this function is invoked, it checks for the keys that define an encoding
    of our objects. If the three keys are present, then the given function is called
    with the arguments and keywords. We can use this object hook to parse a JSON object
    as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用此函数时，它都会检查定义对象编码的键。如果存在这三个键，那么将使用给定的参数和关键字调用该函数。我们可以使用这个对象钩子来解析JSON对象，如下所示：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will decode a block of text, encoded in a JSON notation, using our `blog_decode()`
    function to transform `dict` into proper `Blog` and `Post` objects.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这将解码一块以JSON表示的文本，使用我们的`blog_decode()`函数将`dict`转换为正确的`Blog`和`Post`对象。
- en: The security and the eval() issue
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全和eval()问题
- en: Some programmers will object to the use of the `eval()` function in our `blog_decode()`
    function, claiming that it is a pervasive security problem. What's silly is the
    claim that `eval()` is a pervasive problem. It's a *potential* security problem
    if malicious code is written into the JSON representation of an object by some
    **Evil Genius Programmer** (**EGP**). A local EGP has access to the Python source.
    Why mess with subtle tweaking JSON files? Why not just edit the Python source?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序员会反对在我们的`blog_decode()`函数中使用`eval()`函数，声称这是一个普遍存在的安全问题。可笑的是声称`eval()`是一个普遍存在的问题。如果恶意代码被写入JSON对象的表示中，那么它就是一个*潜在*的安全问题，这是一个本地的EGP可以访问Python源代码。为什么要去微调JSON文件？为什么不直接编辑Python源代码呢？
- en: As a pragmatic issue, we have to look at transmission of the JSON documents
    through the Internet; this is an actual security problem. However, it does not
    indict `eval()` in general.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个实际问题，我们必须考虑通过互联网传输JSON文档；这是一个实际的安全问题。然而，这并不是一般情况下对`eval()`的控诉。
- en: Some provision must be made for a situation where an untrustworthy document
    has been tweaked by a **Man In The Middle** attack. In this case, a JSON document
    is doctored while passing through a web interface that includes an untrustworthy
    server acting as a proxy. SSL is usually the preferred method to prevent this
    problem.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 必须考虑一种情况，即一个不可信的文档被**中间人**攻击篡改。在这种情况下，一个JSON文档在通过包括一个不可信的服务器作为代理的网络接口时被篡改。SSL通常是防止这个问题的首选方法。
- en: 'If necessary, we can replace `eval()` with a dictionary that maps from name
    to class. We can change `eval(some_dict[''__class__''])` to `{"Post":Post, "Blog":Blog,
    "datetime.datetime":datetime.datetime`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有必要，我们可以用一个从名称到类的映射字典来替换`eval()`。我们可以将`eval(some_dict['__class__'])`改为`{"Post":Post,
    "Blog":Blog, "datetime.datetime":datetime.datetime`：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will prevent problems in the event that a JSON document is passed through
    a non-SSL-encoded connection. It also leads to a maintenance requirement to tweak
    this mapping each time the application design changes.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这将防止在通过非SSL编码连接传递JSON文档时出现问题。这也导致了一个维护要求，即每当应用程序设计发生变化时，都需要微调这个映射。
- en: Refactoring the encode function
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重构编码函数
- en: Ideally, we'd like to refactor our encoding function to focus on the responsibility
    for proper encoding on each defining class. We'd rather not pile all of the encoding
    rules into a separate function.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们希望重构我们的编码函数，专注于每个定义类的正确编码的责任。我们不想把所有的编码规则堆积到一个单独的函数中。
- en: 'To do this with library classes such as `datetime`, we would need to extend
    `datetime.datetime` for our application. If we did that, we would need to be sure
    that our application used our extended `datetime` instead of the `datetime` library.
    This can become a bit of a headache to avoid using the built-in `datetime` classes.
    Often, we have to strike a balance between our customized classes and library
    classes. Here are two class extensions that will create JSON-encodable class definitions.
    We can add a property to `Blog`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用诸如`datetime`之类的库类来做到这一点，我们需要为我们的应用程序扩展`datetime.datetime`。如果我们这样做了，我们需要确保我们的应用程序使用我们扩展的`datetime`而不是`datetime`库。这可能会变得有点头疼，以避免使用内置的`datetime`类。通常，我们必须在我们定制的类和库类之间取得平衡。以下是将创建JSON可编码类定义的两个类扩展。我们可以向`Blog`添加一个属性：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This property will provide initialization arguments that are usable by our
    decoding function. We can add these two properties to `Post`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性将提供初始化参数，可供我们的解码函数使用。我们可以将这两个属性添加到`Post`中：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As with `Blog`, this property will provide initialization arguments that are
    usable by our decoding function. We can modify the encoder to make it somewhat
    simpler. Here''s a revised version:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Blog`一样，这个属性将提供初始化参数，可供我们的解码函数使用。我们可以修改编码器，使其变得更简单一些。以下是修订后的版本：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We're still constrained by our choice to use the library `datetime` module.
    In this example, we elected not to introduce subclasses but handle the encoding
    as a special case, rather.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然受到使用库`datetime`模块的选择的限制。在这个例子中，我们选择不引入子类，而是将编码处理为特殊情况。
- en: Standardizing the date string
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标准化日期字符串
- en: Our formatting of dates doesn't make use of the widely-used ISO standard text
    format for dates. To be more compatible with other languages, we should properly
    encode the `datetime` object in a standard string and parse a standard string.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对日期的格式化没有使用广泛使用的ISO标准文本日期格式。为了与其他语言更兼容，我们应该正确地对`datetime`对象进行标准字符串编码和解析标准字符串。
- en: 'As we''re already treating dates as a special case, this seems to be a sensible
    extension of that special case treatment. It can be done without too much change
    to our encoding and decoding. Consider this small change to the encoding:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经将日期视为特殊情况，这似乎是对该特殊情况处理的合理扩展。这可以在不太改变我们的编码和解码的情况下完成。考虑对编码进行的这个小改变：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The encoded output names the static method `datetime.datetime.strptime()` and
    provides the argument encoded `datetime` as well as the format to be used to decode
    it. The output for a post now looks like the following snippet:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 编码输出命名了静态方法`datetime.datetime.strptime()`，并提供了编码的参数`datetime`以及要用于解码的格式。现在，帖子的输出看起来像以下代码片段：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This shows us that we now have an ISO-formatted date instead of individual fields.
    We've also moved away from the object creation using a class name. The `__class__`
    value is expanded to be a class name or a static method name.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这向我们表明，现在我们有一个ISO格式的日期，而不是单独的字段。我们还摆脱了使用类名创建对象的方式。`__class__`值扩展为类名或静态方法名。
- en: Writing JSON to a file
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将JSON写入文件
- en: 'When we write JSON files, we generally do something like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们写JSON文件时，我们通常会这样做：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We open the file with the required encoding. We provide the file object to
    the `json.dump()` method. When we read JSON files, we will use a similar technique:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用所需的编码打开文件。我们将文件对象提供给`json.dump()`方法。当我们读取JSON文件时，我们将使用类似的技术：
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The idea is to segregate the JSON representation as text from any conversion
    to bytes on the resulting file. There are a few formatting options that are available
    in JSON. We''ve shown you an indent of four spaces because that seems to produce
    nice-looking JSON. As an alternative, we can make the output more compact by leaving
    the indent option. We can compact it even further by making the separators more
    terse. The following is the output created in `temp.json`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是将JSON表示作为文本与生成文件上的字节转换分开。JSON中有一些可用的格式选项。我们展示了缩进四个空格，因为这似乎产生了漂亮的JSON。作为替代，我们可以通过留下缩进选项使输出更紧凑。通过使分隔符更简洁，我们甚至可以使其更加紧凑。以下是在`temp.json`中创建的输出：
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Dumping and loading with YAML
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用YAML进行转储和加载
- en: 'The [yaml.org](http://yaml.org) web page states that:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[yaml.org](http://yaml.org)网页指出：'
- en: YAML™ (rhymes with "camel") is a human-friendly, cross language, Unicode-based
    data serialization language designed around the common native data types of agile
    programming languages.
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: YAML™（与“骆驼”押韵）是一种人性化的、跨语言的、基于Unicode的数据序列化语言，旨在围绕敏捷编程语言的常见本机数据类型设计。
- en: 'The Python Standard Library documentation for the `json` module states that:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`json`模块的Python标准库文档指出：'
- en: JSON is a subset of YAML 1.2\. The JSON produced by this module's default settings
    (in particular, the default separators value) is also a subset of YAML 1.0 and
    1.1\. This module can thus also be used as a YAML serializer.
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JSON是YAML 1.2的子集。此模块的默认设置（特别是默认分隔符值）生成的JSON也是YAML 1.0和1.1的子集。因此，该模块也可以用作YAML序列化器。
- en: 'Technically, then, we can prepare YAML data using the `json` module. However,
    the `json` module cannot be used to de-serialize more sophisticated YAML data.
    There are two benefits of YAML. First, it''s a more sophisticated notation, allowing
    us to encode additional details about our objects. Second, the PyYAML implementation
    has a deep level of integration with Python that allows us to very simply create
    YAML encodings of Python objects. The drawback of YAML is that it is not as widely
    used as JSON. We''ll need to download and install a YAML module. A good one can
    be found at [http://pyyaml.org/wiki/PyYAML](http://pyyaml.org/wiki/PyYAML). Once
    we''ve installed the package, we can dump our objects in the YAML notation:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，我们可以使用`json`模块准备YAML数据。但是，`json`模块无法用于反序列化更复杂的YAML数据。YAML的两个好处。首先，它是一种更复杂的表示法，允许我们对我们的对象编码更多的细节。其次，PyYAML实现与Python有深度集成，使我们能够非常简单地创建Python对象的YAML编码。YAML的缺点是它没有像JSON那样被广泛使用。我们需要下载和安装一个YAML模块。可以在[http://pyyaml.org/wiki/PyYAML](http://pyyaml.org/wiki/PyYAML)找到一个好的模块。安装了包之后，我们可以以YAML表示法转储我们的对象：
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here''s what the YAML encoding for our microblog looks like:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们微博的YAML编码：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The output is relatively terse but also delightfully complete. Also, we can
    easily edit the YAML file to make updates. The class names are encoded with a
    YAML `!!` tag. YAML contains 11 standard tags. The `yaml` module includes a dozen
    Python-specific tags, plus five *complex* Python tags.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 输出相对简洁，但也非常完整。此外，我们可以轻松编辑YAML文件以进行更新。类名使用YAML `!!`标记进行编码。YAML包含11个标准标记。`yaml`模块包括十几个特定于Python的标记，以及五个*复杂*的Python标记。
- en: The Python class names are qualified by the defining module. In our case, the
    module happened to be a simple script, so the class names are `__main__.Blog`
    and `__main__.Post`. If we had imported these from another module, the class names
    would reflect the module that defined the classes.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Python类名由定义模块限定。在我们的情况下，该模块碰巧是一个简单的脚本，因此类名是`__main__.Blog`和`__main__.Post`。如果我们从另一个模块导入这些类，类名将反映定义类的模块。
- en: 'Items in a list are shown in a block sequence form. Each item starts with a
    `-` sequence; the rest of the items are indented with two spaces. When `list`
    or `tuple` is small enough, it can flow onto a single line. If it gets longer,
    it will wrap onto multiple lines. To load Python objects from a YAML document,
    we can use the following code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的项目以块序列形式显示。每个项目以`-`序列开头；其余项目缩进两个空格。当`list`或`tuple`足够小，它可以流到一行。如果它变得更长，它将换行到多行。要从YAML文档加载Python对象，我们可以使用以下代码：
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This will use the tag information to locate the class definitions and provide
    the values found in the YAML document to the class constructors. Our microblog
    objects will be fully reconstructed.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用标记信息来定位类定义，并将在YAML文档中找到的值提供给类构造函数。我们的微博对象将被完全重建。
- en: Formatting YAML data on a file
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在文件上格式化YAML数据
- en: 'When we write YAML files, we generally do something like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们写YAML文件时，我们通常会做这样的事情：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We open the file with the required encoding. We provide the file object to
    the `yaml.dump()` method; the output is written there. When we read YAML files,
    we will use a similar technique:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以所需的编码打开文件。我们将文件对象提供给`yaml.dump()`方法；输出将写入那里。当我们读取YAML文件时，我们将使用类似的技术：
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The idea is to segregate the YAML representation as text from any conversion
    to bytes on the resulting file. We have several formatting options to create prettier
    YAML representation of our data. Some of the options are shown in the following
    table:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 将YAML表示作为文本与结果文件上的字节转换分开的想法。我们有几种格式选项来创建更漂亮的YAML表示我们的数据。以下表格显示了一些选项：
- en: '| `explicit_start` | If `true`, writes a `---` marker before each object. |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '`explicit_start` 如果为`true`，在每个对象之前写入一个`---`标记。'
- en: '| `explicit_end` | If `true`, writes a `...` marker after each object. We might
    use this or `explicit_start` if we''re dumping a sequence of YAML documents to
    a single file and need to know when one ends and the next begins. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '`explicit_end` 如果为`true`，在每个对象之后写入一个`...`标记。如果我们将一系列YAML文档转储到单个文件并且需要知道一个结束和下一个开始时，我们可能会使用这个或`explicit_start`。'
- en: '| `version` | Given a pair of integers (x,y), writes a `%YAML x.y` directive
    at the beginning. This should be `version=(1,2)`. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '`version` 给定一对整数(x,y)，在开头写入`%YAML x.y`指令。这应该是`version=(1,2)`。'
- en: '| `tags` | Given a mapping, it emits a YAML `%TAG` directive with different
    tag abbreviations. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '`tags` 给定一个映射，它会发出一个带有不同标记缩写的YAML `%TAG`指令。'
- en: '| `canonical` | If `true`, includes a tag on every piece of data. If false,
    a number of tags are assumed. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '`canonical` 如果为`true`，则在每个数据片段上包括一个标记。如果为false，则假定一些标记。'
- en: '| `indent` | If set to a number, changes the indentation used for blocks. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '`indent` 如果设置为一个数字，改变用于块的缩进。'
- en: '| `width` | If set to a number, changes the width at which long items are wrapped
    to multiple, indented lines. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '`width` 如果设置为一个数字，改变长项换行到多个缩进行的宽度。'
- en: '| `allow_unicode` | If set to `true`, permits full Unicode without escapes.
    Otherwise, characters outside the ASCII subset will have escapes applied. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '`allow_unicode` 如果设置为`true`，允许完全使用Unicode而无需转义。否则，ASCII子集之外的字符将被应用转义。'
- en: '| `line_break` | Uses a different line-ending character; the default is a newline.
    |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '`line_break` 使用不同的换行符；默认为换行符。'
- en: Of these options, `explicit_end` and `allow_unicode` are perhaps the most useful.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些选项中，`explicit_end`和`allow_unicode`可能是最有用的。
- en: Extending the YAML representation
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展YAML表示
- en: Sometimes, one of our classes has a tidy representation that is nicer than the
    default YAML dump of attribute values. For example, the default YAML for our Blackjack
    `Card` class definitions will include several derived values that we don't really
    need to preserve.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们的类之一具有整洁的表示，比默认的YAML转储属性值更好。例如，我们的Blackjack `Card`类定义的默认YAML将包括一些我们不需要保留的派生值。
- en: 'The `yaml` module includes a provision for adding a **representer** and a **constructor**
    to a class definition. The representer is used to create a YAML representation,
    including a tag and value. The constructor is used to build a Python object from
    the given value. Here''s yet another `Card` class hierarchy:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`yaml`模块包括为类定义添加**representer**和**constructor**的规定。representer用于创建YAML表示，包括标记和值。构造函数用于从给定值构建Python对象。这是另一个`Card`类层次结构：'
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We've used the superclass for number cards and defined two subclasses for aces
    and face cards. In previous examples, we made extensive use of a factory function
    to simplify the construction. The factory handled mapping from a rank of 1 to
    a class of `AceCar` and from ranks of 11, 12, and 13 to class of `FaceCard`. This
    was essential so that we could easily build a deck using a simple `range(1,14)`
    for the rank values.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了数字卡的超类，并为A和面值卡定义了两个子类。在先前的示例中，我们广泛使用了工厂函数来简化构建。工厂处理了从1到`AceCar`类的等级的映射，以及从11、12和13等级到`FaceCard`类的映射。这是必不可少的，这样我们就可以轻松地使用简单的`range(1,14)`来构建一副牌。
- en: 'When loading from YAML, the class will be fully spelled out via the YAML `!!`
    tags. The only missing information would be the hard and soft values associated
    with each subclass of the card. The hard and soft points have three relatively
    simple cases that can be handled through optional initialization parameters. Here''s
    how it looks when we dump these objects into the YAML format using default serialization:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 从YAML加载时，类将通过YAML`!!`标记完全拼写出来。唯一缺少的信息将是与卡片的每个子类关联的硬值和软值。硬点和软点有三种相对简单的情况，可以通过可选的初始化参数来处理。当我们将这些对象转储到YAML格式时，它看起来是这样的：
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'These are correct, but perhaps a bit wordy for something as simple as a playing
    card. We can extend the `yaml` module to produce smaller and more focused output
    for these simple objects. What we''ll do is define representers and constructors
    for our `Card` subclasses. Here are the three functions and registrations:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是正确的，但对于像扑克牌这样简单的东西来说可能有点啰嗦。我们可以扩展`yaml`模块，以便为这些简单对象生成更小、更专注的输出。我们将为`Card`子类定义表示和构造函数。以下是三个函数和注册：
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We've represented each `Card` instance as a short string. YAML includes a tag
    to show which class should be built from the string. All three classes use the
    same format string. This happens to match the `__str__()` method, leading to a
    potential optimization.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将每个`Card`实例表示为一个简短的字符串。YAML包括一个标记，显示应从字符串构建哪个类。所有三个类使用相同的格式字符串。这恰好与`__str__()`方法匹配，从而导致潜在的优化。
- en: 'The other problem we need to solve is constructing `Card` instances from the
    parsed YAML document. For that, we need constructors. Here are three constructors
    and the registrations:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要解决的另一个问题是从解析的YAML文档构造`Card`实例。为此，我们需要构造函数。以下是三个构造函数和注册：
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As a scalar value is parsed, the tag will be used to locate a specific constructor.
    The constructor can then decompose the string and build the proper subclass of
    a `Card` instance. Here''s a quick demo that dumps one card of each class:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当解析标量值时，标记将用于定位特定的构造函数。然后构造函数可以分解字符串并构建`Card`实例的适当子类。这是一个快速演示，演示了每个类的一张卡片：
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following is the output:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This gives us short, elegant YAML representations of cards that can be used
    to reconstruct Python objects.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们提供了可以用来重建Python对象的卡片的简短而优雅的YAML表示。
- en: 'We can rebuild our 3-card deck using the following simple statement:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下简单语句重新构建我们的3张牌组：
- en: '[PRE32]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This will parse the representation, use the constructor functions, and build
    the expected objects. Because the constructor function ensures that proper initialization
    gets done, the internal attributes for the hard and soft values are properly rebuilt.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这将解析表示，使用构造函数，并构建预期的对象。因为构造函数确保适当的初始化完成，硬值和软值的内部属性将被正确重建。
- en: Security and safe loading
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全和安全加载
- en: In principle, YAML can build objects of any type. This allows an attack on an
    application that transmits YAML files through the Internet without proper SSL
    controls in place.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，YAML可以构建任何类型的对象。这允许对通过互联网传输YAML文件的应用程序进行攻击，而不需要适当的SSL控制。
- en: The YAML module offers a `safe_load()` method that refuses to execute arbitrary
    Python code as part of building an object. This severely limits what can be loaded.
    For insecure data exchanges, we can use `yaml.safe_load()` to create Python `dict`
    and `list` objects that contain only built-in types. We can then build our application
    classes from the `dict` and `list` instances. This is vaguely similar to the way
    we use JSON or CSV to exchange `dict` that must be used to create a proper object.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: YAML模块提供了一个`safe_load()`方法，拒绝执行任意Python代码作为构建对象的一部分。这严重限制了可以加载的内容。对于不安全的数据交换，我们可以使用`yaml.safe_load()`来创建仅包含内置类型的Python`dict`和`list`对象。然后我们可以从`dict`和`list`实例构建我们的应用程序类。这与我们使用JSON或CSV交换必须用于创建正确对象的`dict`的方式有些相似。
- en: 'A better approach is to use the `yaml.YAMLObject` mixin class for our own objects.
    We use this to set some class-level attributes that provide hints to `yaml` and
    ensure the safe construction of objects. Here''s how we define a superclass for
    safe transmission:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是为我们自己的对象使用`yaml.YAMLObject`混合类。我们使用这个类来设置一些类级别的属性，为`yaml`提供提示，并确保对象的安全构建。以下是我们如何定义用于安全传输的超类：
- en: '[PRE33]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The two attributes will alert `yaml` that these objects can be safely loaded
    without executing arbitrary and unexpected Python code. Each subclass of `Card2`
    only has to set the unique YAML tag that will be used:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个属性将警告`yaml`，这些对象可以安全加载，而不会执行任意和意外的Python代码。`Card2`的每个子类只需设置将要使用的唯一YAML标记：
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We've added an attribute that alerts `yaml` that these objects use only this
    class definition. The objects can be safely loaded; they don't execute arbitrary
    untrustworthy code.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个属性，警告`yaml`，这些对象仅使用此类定义。这些对象可以安全加载；它们不执行任意不可信代码。
- en: With these modifications to the class definitions, we can now use `yaml.safe_load()`
    on the YAML stream without worrying about the document having malicious code inserted
    over an unsecured Internet connection. The explicit use of the `yaml.YAMLObject`
    mixin class for our own objects coupled with setting the `yaml_tag` attribute
    has several advantages. It leads to slightly more compact files. It also leads
    to a better-looking YAML files—the long, generic `!!python/object:__main__.AceCard`
    tags are replaced with shorter `!AceCard2` tags.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对类定义进行这些修改，我们现在可以在YAML流上使用`yaml.safe_load()`，而不必担心文档在不安全的互联网连接上插入恶意代码。对我们自己的对象使用`yaml.YAMLObject`混合类以及设置`yaml_tag`属性具有几个优点。它导致文件稍微更紧凑。它还导致更美观的YAML文件——长而通用的`!!python/object:__main__.AceCard`标记被更短的`!AceCard2`标记替换。
- en: Dumping and loading with pickle
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用pickle进行转储和加载
- en: The `pickle` module is Python's native format to make objects persistent.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`pickle`模块是Python的本机格式，用于使对象持久化。'
- en: 'The Python Standard Library says this about `pickle`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库对`pickle`的描述如下：
- en: The pickle module can transform a complex object into a byte stream and it can
    transform the byte stream into an object with the same internal structure. Perhaps
    the most obvious thing to do with these byte streams is to write them onto a file,
    but it is also conceivable to send them across a network or store them in a database.
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: pickle模块可以将复杂对象转换为字节流，并且可以将字节流转换为具有相同内部结构的对象。对这些字节流最明显的用途可能是将它们写入文件，但也可以想象将它们发送到网络或存储在数据库中。
- en: The focus of `pickle` is Python and only Python. This is not a data interchange
    format such as JSON, YAML, CSV, or XML that can be used with applications written
    in other languages.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`pickle`的重点是Python，仅限于Python。这不是诸如JSON、YAML、CSV或XML之类的数据交换格式，可以与其他语言编写的应用程序一起使用。'
- en: The `pickle` module is tightly integrated with Python in a variety of ways.
    For example, the `__reduce__()` and `__reduce_ex__()` methods of a class exist
    to support the `pickle` processing.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`pickle`模块与Python紧密集成在各种方式。例如，类的`__reduce__()`和`__reduce_ex__()`方法存在以支持`pickle`处理。'
- en: 'We can easily pickle our microblog in the following manner:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地将我们的微博pickle如下：
- en: '[PRE35]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This exports the entire `travel` object to the given file. The file is written
    as raw bytes, so the `open()` function uses the `"wb"` mode.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 将整个`travel`对象导出到给定文件。该文件以原始字节形式写入，因此`open()`函数使用`"wb"`模式。
- en: 'We can easily recover a picked object in the following manner:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式轻松恢复一个picked对象：
- en: '[PRE36]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As pickled data is written as bytes, the file must be opened in the `"rb"` mode.
    The pickled objects will be correctly bound to the proper class definitions. The
    underlying stream of bytes is not intended for human consumption. It is readable
    after a fashion, but it is not designed for readability like YAML.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 由于pickled数据是以字节形式写入的，因此文件必须以`"rb"`模式打开。pickled对象将正确绑定到适当的类定义。底层的字节流不是为人类消费而设计的。它在某种程度上是可读的，但它不像YAML那样设计用于可读性。
- en: Designing a class for reliable pickle processing
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计一个可靠的pickle处理类
- en: The `__init__()` method of a class is not actually used to unpickle an object.
    The `__init__()` method is bypassed by using `__new__()` and setting the pickled
    values into the object's `__dict__` directly. This distinction matters when our
    class definition includes some processing in `__init__()`. For example, if `__init__()`
    opens external files, creates some part of a GUI interface, or performs some external
    update to a database, then this will not be performed during unpickling.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 类的`__init__()`方法实际上并不用于取消封存对象。通过使用`__new__()`并将pickled值直接设置到对象的`__dict__`中，`__init__()`方法被绕过。当我们的类定义包括`__init__()`中的一些处理时，这一区别很重要。例如，如果`__init__()`打开外部文件，创建GUI界面的某个部分，或者对数据库执行某些外部更新，则在取消封存时不会执行这些操作。
- en: If we compute a new instance variable during the `__init__()` processing, there
    is no real problem. For example, consider a Blackjack `Hand` object that computes
    the total of the `Card` instances when the `Hand` is created. The ordinary `pickle`
    processing will preserve this computed instance variable. It won't be recomputed
    when the object is unpickled. The previously computed value will simply be unpickled.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`__init__()`处理期间计算一个新的实例变量，就没有真正的问题。例如，考虑一个Blackjack`Hand`对象，在创建`Hand`时计算`Card`实例的总数。普通的`pickle`处理将保留这个计算出的实例变量。在取消封存对象时，不会重新计算它。先前计算出的值将被简单地取消封存。
- en: 'A class that relies on processing during `__init__()` has to make special arrangements
    to be sure that this initial processing will happen properly. There are two things
    we can do:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖于`__init__()`期间处理的类必须特别安排以确保此初始处理将正确进行。我们可以做两件事：
- en: Avoid eager startup processing in `__init__()`. Instead, do one-time initialization
    processing. For example, if there are external file operations, these must be
    deferred until required.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在`__init__()`中进行急切的启动处理。相反，进行一次性的初始化处理。例如，如果有外部文件操作，必须推迟到需要时才执行。
- en: Define the `__getstate__()` and `__setstate__()` methods that can be used by
    pickle to preserve the state and restore the state. The `__setstate__()` method
    can then invoke the same method that `__init__()` invokes to perform a one-time
    initialization processing in ordinary Python code.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义`__getstate__()`和`__setstate__()`方法，这些方法可以被pickle用来保存状态和恢复状态。然后，`__setstate__()`方法可以调用与`__init__()`在普通Python代码中执行一次性初始化处理的相同方法。
- en: 'We''ll look at an example where the initial `Card` instances loaded into a
    `Hand` are logged for audit purposes by the `__init__()` method. Here''s a version
    of `Hand` that doesn''t work properly when unpickling:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一个例子，其中由`__init__()`方法记录为审计目的加载到`Hand`中的初始`Card`实例。以下是在取消封存时无法正常工作的`Hand`版本：
- en: '[PRE37]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This has two logging locations: during `__init__()` and `append()`. The `__init__()`
    processing doesn''t work consistently between initial object creation and unpickling
    to recreate an object. Here''s the logging setup to see this problem:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这有两个记录位置：在`__init__()`和`append()`期间。`__init__()`处理在初始对象创建和取消封存以重新创建对象之间不能一致工作。以下是用于查看此问题的日志设置：
- en: '[PRE38]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This setup creates the log and ensures that the logging level is appropriate
    for seeing the audit information. Here''s a quick script that builds, pickles,
    and unpickles `Hand`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 此设置创建日志并确保日志级别适合查看审计信息。以下是一个快速脚本，用于构建、pickle和unpickle`Hand`：
- en: '[PRE39]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: When we execute this, we see that the log entries that are written during `__init__()`
    processing are not written when unpickling `Hand`. In order to properly write
    an audit log for unpickling, we could put lazy logging tests throughout this class.
    For example, we could extend `__getattribute__()` to write the initial log entries
    whenever any attribute is requested from this class. This leads to stateful logging
    and an `if` statement that is executed every time a hand object does something.
    A better solution is to tap into the way state is saved and recovered by `pickle`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行这个时，我们发现在处理`__init__()`时写入的日志条目在反拾取`Hand`时没有被写入。为了正确地为反拾取编写审计日志，我们可以在这个类中放置延迟日志测试。例如，我们可以扩展`__getattribute__()`以在从这个类请求任何属性时写入初始日志条目。这导致了有状态的日志记录和每次手对象执行操作时执行的`if`语句。一个更好的解决方案是利用`pickle`保存和恢复状态的方式。
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `__getstate__()` method is used while picking to gather the current state
    of the object. This method can return anything. In the case of objects that have
    internal memoization caches, for example, the cache might not be pickled in order
    to save time and space. This implementation uses the internal `__dict__` without
    any modification.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`__getstate__()` 方法在拾取时用于收集对象的当前状态。这个方法可以返回任何东西。例如，对于具有内部记忆缓存的对象，缓存可能不会被拾取以节省时间和空间。这个实现使用内部的`__dict__`而没有任何修改。'
- en: The `__setstate__()` method is used while unpickling to reset the value of the
    object. This version merges the state into the internal `__dict__` and then writes
    the appropriate logging entries.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`__setstate__()` 方法在反拾取时用于重置对象的值。这个版本将状态合并到内部的`__dict__`中，然后写入适当的日志条目。'
- en: Security and the global issue
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全和全局问题
- en: During unpickling, a global name in the pickle stream can lead to the evaluation
    of arbitrary code. Generally, the global names are class names or a function name.
    However, it's possible to include a global name that is a function in a module
    such as `os` or `subprocess`. This allows an attack on an application that attempts
    to transmit pickled objects through the Internet without strong SSL controls in
    place. This is no concern for completely local files.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在反拾取期间，pickle流中的全局名称可能导致任意代码的评估。一般来说，全局名称是类名或函数名。然而，可能包括一个函数名是`os`或`subprocess`等模块中的全局名称。这允许对试图通过互联网传输拾取对象的应用程序进行攻击，而没有强大的SSL控制。这对于完全本地文件来说并不是问题。
- en: 'In order to prevent the execution of arbitrary code, we must extend the `pickle.Unpickler`
    class. We''ll override the `find_class()` method to replace it with something
    more secure. We have to account for several unpickling issues, such as the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止执行任意代码，我们必须扩展`pickle.Unpickler`类。我们将覆盖`find_class()`方法以替换为更安全的内容。我们必须考虑几个反拾取问题，例如：
- en: We have to prevent the use of the built-in `exec()` and `eval()` functions.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须防止使用内置的`exec()`和`eval()`函数。
- en: We have to prevent the use of modules and packages that might be considered
    unsafe. For example, `sys` and `os` should be prohibited.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须防止使用可能被认为是不安全的模块和包。例如，应该禁止使用`sys`和`os`。
- en: We have to permit the use of our application modules.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须允许使用我们的应用程序模块。
- en: 'Here''s an example that imposes some restrictions:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个施加一些限制的示例：
- en: '[PRE41]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This version of the `Unpickler` class will help us avoid a large number of potential
    problems that could stem from a pickle stream that was doctored. It permits the
    use of any built-in function except `exec()` and `eval()`. It permits the use
    of classes defined only in `__main__`. In all other cases, it raises an exception.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Unpickler`类的版本将帮助我们避免由篡改的pickle流可能引起的大量潜在问题。它允许使用除了`exec()`和`eval()`之外的任何内置函数。它允许仅在`__main__`中定义的类的使用。在所有其他情况下，它会引发异常。
- en: Dumping and loading with CSV
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CSV进行转储和加载
- en: The `csv` module encodes and decodes simple `list` or `dict` instances into
    the CSV notation. As with the `json` module, discussed previously, this is not
    a very complete persistence solution. The wide adoption of CSV files, however,
    means that it often becomes necessary to convert between Python objects and CSV.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`csv`模块将简单的`list`或`dict`实例编码和解码为CSV符号。与之前讨论的`json`模块一样，这并不是一个非常完整的持久性解决方案。然而，由于CSV文件的广泛采用，通常需要在Python对象和CSV之间进行转换。'
- en: Working with CSV files involves a manual mapping between our objects and CSV
    structures. We need to design the mapping carefully, remaining cognizant of the
    limitations of the CSV notation. This can be difficult because of the mismatch
    between the expressive powers of objects and the tabular structure of a CSV file.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 处理CSV文件涉及我们的对象和CSV结构之间的手动映射。我们需要仔细设计映射，注意CSV符号的限制。这可能很困难，因为对象的表达能力与CSV文件的表格结构之间存在不匹配。
- en: The content of each column of a CSV file is—by definition—pure text. When loading
    data from a CSV file, we'll need to convert these values to more useful types
    inside our applications. This conversion can be complicated by the way spreadsheets
    perform unexpected type coercion. We might, for example, have a spreadsheet where
    US ZIP codes have been changed into floating-point numbers by the spreadsheet
    application. When the spreadsheet saves to CSV, the ZIP codes could become odd-looking
    numeric values.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: CSV文件的每一列的内容—根据定义—都是纯文本。从CSV文件加载数据时，我们需要将这些值转换为更有用的类型。这种转换可能会受到电子表格执行意外类型强制转换的影响。例如，我们可能有一个电子表格，其中美国邮政编码已被电子表格应用程序更改为浮点数。当电子表格保存为CSV时，邮政编码可能会变成看起来奇怪的数值。
- en: Consequently, we might need to use a conversion such as `('00000'+row['zip'])[-5:]`
    to restore the leading zeroes. Another scenario is having to use something such
    as `"{0:05.0f}".format(float(row['zip']))` to restore the leading zeroes. Also,
    don't forget that a file might have a mixture of ZIP and ZIP+4 postal codes, making
    this even more challenging.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可能需要使用转换，比如`('00000'+row['zip'])[-5:]`来恢复前导零。另一种情况是必须使用类似`"{0:05.0f}".format(float(row['zip']))`来恢复前导零。另外，不要忘记文件可能包含ZIP和ZIP+4邮政编码的混合，这使得这个过程更具挑战性。
- en: To further complicate working with CSV files, we have to be aware that they're
    often touched manually and are often subtly incompatible because of human tweaks.
    It's important for software to be flexible in the face of real-world irregularities
    that arise.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更复杂地处理CSV文件，我们必须意识到它们经常被手动操作，并且由于人为调整，它们经常不兼容。软件在面对现实世界中出现的不规则性时保持灵活是很重要的。
- en: When we have relatively simple class definitions, we can often transform each
    instance into a simple, flat row of data values. Often, `namedtuple` is a good
    match between a CSV source file and Python objects. Going the other way, we might
    need to design our Python classes around `namedtuples` if our application will
    save data in the CSV notation.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有相对简单的类定义时，我们通常可以将每个实例转换为简单的扁平数据值行。通常情况下，`namedtuple`是CSV源文件和Python对象之间的良好匹配。反过来，如果我们的应用程序将数据保存在CSV符号中，我们可能需要围绕`namedtuples`设计我们的Python类。
- en: When we have classes that are containers, we often have a difficult time determining
    how to represent structured containers in flat CSV rows. This is an **impedance
    mismatch** between object models and flat normalized tabular structure used for
    CSV files or relational databases. There's no good solution for the impedance
    mismatch; it requires careful design. We'll start with simple, flat objects to
    show you some CSV mappings.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有容器类时，通常很难确定如何在扁平的CSV行中表示结构化容器。这是对象模型和用于CSV文件或关系数据库的扁平规范化表结构之间的**阻抗不匹配**。阻抗不匹配没有好的解决方案；它需要仔细设计。我们将从简单的扁平对象开始，向您展示一些CSV映射。
- en: Dumping simple sequences to CSV
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将简单序列转储到CSV
- en: 'An ideal mapping is between the `namedtuple` instances and rows in a CSV file.
    Each row represents a different `namedtuple`. Consider the following Python class:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 理想的映射是`namedtuple`实例和CSV文件中的行之间的映射。每一行代表一个不同的`namedtuple`。考虑以下Python类：
- en: '[PRE42]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We''ve defined the objects to be a simple, flat sequence of attributes. The
    database architects call this **First Normal Form**. There are no repeating groups
    and each item is an atomic piece of data. We might produce these objects from
    a simulation that looks like the following code:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了对象为简单的扁平属性序列。数据库架构师称之为**第一范式**。没有重复的组，每个项目都是原子数据。我们可能会从一个看起来像以下代码的模拟中产生这些对象：
- en: '[PRE43]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This iterator will create Blackjack simulations with a given player and betting
    strategy. It will execute the game until the player is broke or has sat at the
    table for 100 individual rounds of play. At the end of each session, it will yield
    a `GameStat` object with the player strategy, betting strategy, the number of
    rounds, and the final stake. This will allow us to compute statistics for each
    play or betting strategy or combination. Here''s how we can write this to a file
    for later analysis:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这个迭代器将创建具有给定玩家和投注策略的二十一点模拟。它将执行游戏，直到玩家破产或者在100个独立的游戏回合中坐在桌子旁。在每个会话结束时，它将产生一个带有玩家策略、投注策略、回合数和最终赌注的`GameStat`对象。这将允许我们为每个玩法或投注策略或组合计算统计数据。以下是我们如何将其写入文件以供以后分析：
- en: '[PRE44]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'There are three steps to create a CSV writer:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 创建CSV写入器有三个步骤：
- en: Open a file with the newline option set to `""`. This will support the (possibly)
    nonstandard line ending for CSV files.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个带有newline选项设置为`""`的文件。这将支持CSV文件的（可能）非标准行结束。
- en: Create a CSV `writer` object. In this example, we created the `DictWriter` instance
    because it allows us to easily create rows from dictionary objects.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建CSV `writer`对象。在这个例子中，我们创建了`DictWriter`实例，因为它允许我们轻松地从字典对象创建行。
- en: Put a header in the first line of the file. This makes data exchange slightly
    simpler by providing some hint as to what's in the CSV file.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件的第一行放一个标题。这样做可以通过提供一些关于CSV文件中内容的提示，使数据交换稍微简单一些。
- en: 'Once `writer` object has been prepared, we can use the writer''s `writerow()`
    method to write each dictionary to the CSV file. We can, to an extent, simplify
    this slightly by using the `writerows()` method. This method expects an iterator
    instead of an individual row. Here''s how we can use `writerows()` with an iterator:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`writer`对象准备好了，我们可以使用writer的`writerow()`方法将每个字典写入CSV文件。我们可以在一定程度上通过使用`writerows()`方法稍微简化这个过程。这个方法期望一个迭代器而不是一个单独的行。以下是我们如何使用`writerows()`与一个迭代器：
- en: '[PRE45]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We've assigned the iterator to a variable, `data`. For the `writerows()` method,
    we get a dictionary from each row produced by the iterator.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将迭代器分配给一个变量`data`。对于`writerows()`方法，我们从迭代器产生的每一行得到一个字典。
- en: Loading simple sequences from CSV
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从CSV加载简单序列
- en: 'We can load simple sequential objects from a CSV file with a loop that looks
    like the following code:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类似以下代码的循环从CSV文件中加载简单的顺序对象：
- en: '[PRE46]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We've defined a `reader` object for our file. As we know that our file has a
    proper heading, we can use `DictReader`. This will use the first row to define
    the attribute names. We can now construct the `GameStat` objects from the rows
    in the CSV file. We've used a generator expression to build rows.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为文件定义了一个`reader`对象。由于我们知道文件有一个适当的标题，我们可以使用`DictReader`。这将使用第一行来定义属性名称。现在我们可以从CSV文件中的行构造`GameStat`对象。我们使用了一个生成器表达式来构建行。
- en: 'In this case, we''ve assumed that the column names match the attribute names
    of our `GameStat` class definition. We can, if necessary, confirm that the file
    matches the expected format by comparing `reader.fieldnames` with `GameStat._fields`.
    As the order doesn''t have to match, we need to transform each list of field names
    into a set. Here''s how we can check the column names:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们假设列名与我们的“GameStat”类定义的属性名匹配。如果必要，我们可以通过比较“reader.fieldnames”和“GameStat._fields”来确认文件是否与预期格式匹配。由于顺序不必匹配，我们需要将每个字段名称列表转换为集合。以下是我们如何检查列名：
- en: '[PRE47]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We''ve ignored the data types of the values that were read from the file. The
    two numeric columns will wind up being string values when we read from the CSV
    file. Because of this, we need a more sophisticated row-by-row transformation
    to create proper data values. Here''s a typical factory function that performs
    the required conversions:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们忽略了从文件中读取的值的数据类型。当我们从CSV文件中读取时，两个数值列将最终成为字符串值。因此，我们需要进行更复杂的逐行转换，以创建正确的数据值。以下是执行所需转换的典型工厂函数：
- en: '[PRE48]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We''ve applied the `int` function to the columns that are supposed to have
    numeric values. In the rare event where the file has the proper headers but improper
    data, we''ll get an ordinary `ValueError` from a failed `int()` function. We can
    use this generator function as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将“int”函数应用于应该具有数值的列。在文件具有正确的标题但数据不正确的罕见情况下，我们将从失败的“int（）”函数中获得普通的“ValueError”。我们可以使用这个生成器函数如下：
- en: '[PRE49]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This version of the reader has properly reconstructed the `GameStat` objects
    by performing conversions on the numeric values.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的读取器通过对数值进行转换，正确重建了“GameStat”对象。
- en: Handling containers and complex classes
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理容器和复杂类
- en: 'When we look back at our microblog example, we have a `Blog` object that contains
    many `Post` instances. We designed `Blog` as a wrapper around `list`, so that
    the `Blog` would contain a collection. When working with a CSV representation,
    we have to design a mapping from a complex structure to a tabular representation.
    We have three common solutions:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们回顾我们的微博示例时，我们有一个包含许多“Post”实例的“Blog”对象。我们设计“Blog”作为“list”的包装器，以便“Blog”包含一个集合。在处理CSV表示时，我们必须设计从复杂结构到表格表示的映射。我们有三种常见的解决方案：
- en: 'We can create two files: a blog file and a posting file. The blog file has
    only the `Blog` instances. Each `Blog` has a title in our example. Each `Post`
    row can then have a reference to the `Blog` row to which the posting belongs.
    We need to add a key for each `Blog`. Each `Post` would then have a foreign key
    reference to the `Blog` key.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建两个文件：一个博客文件和一个帖子文件。博客文件只包含“Blog”实例。在我们的示例中，每个“Blog”都有一个标题。然后，每个“Post”行可以引用帖子所属的“Blog”行。我们需要为每个“Blog”添加一个键。然后，每个“Post”将具有对“Blog”键的外键引用。
- en: We can create two kinds of rows in a single file. We will have the `Blog` rows
    and `Post` rows. Our writers entangle the various types of data; our readers must
    disentangle the types of data.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在单个文件中创建两种类型的行。我们将有“Blog”行和“Post”行。我们的写入器纠缠了各种类型的数据；我们的读取器必须解开数据类型。
- en: We can perform a relational database join between the various kinds of rows,
    repeating the `Blog` parent information on each `Post` child.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在各种行之间执行关系数据库连接，重复在每个“Post”子行上的“Blog”父信息。
- en: There's no *best* solution among these choices. We have to design a solution
    to the impedance mismatch between flat CSV rows and more structured Python objects.
    The use cases for the data will define some of the advantages and disadvantages.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些选择中没有*最佳*解决方案。我们必须设计一个解决扁平CSV行和更结构化的Python对象之间的阻抗不匹配的解决方案。数据的用例将定义一些优点和缺点。
- en: Creating two files requires that we create some kind of unique identifier for
    each `Blog` so that a `Post` can properly refer to the `Blog`. We can't easily
    use the Python internal ID, as these are not guaranteed to be consistent each
    time Python runs.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 创建两个文件需要我们为每个“Blog”创建某种唯一标识符，以便“Post”可以正确地引用“Blog”。我们不能轻易使用Python内部ID，因为这些ID不能保证在每次Python运行时保持一致。
- en: A common assumption is that the `Blog` title is a unique key; as this is an
    attribute of `Blog`, it is called a natural primary key. This rarely works out
    well; we cannot change a `Blog` title without also updating all of the `Posts`
    that refer to the `Blog`. A better plan is to invent a unique identifier and update
    the class design to include that identifier. This is called a **surrogate key**.
    The Python `uuid` module can provide unique identifiers for this purpose.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的假设是“Blog”标题是一个唯一的键；由于这是“Blog”的属性，它被称为自然主键。这很少能奏效；我们不能更改“Blog”标题而不更新所有引用“Blog”的“Posts”。一个更好的计划是发明一个唯一标识符，并更新类设计以包括该标识符。这被称为**代理键**。Python的“uuid”模块可以为此目的提供唯一标识符。
- en: The code to use multiple files is nearly identical to the previous examples.
    The only change is to add a proper primary key to the `Blog` class. Once we have
    the keys defined, we can create writers and readers as shown previously to process
    the `Blog` and `Post` instances into their separate files.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个文件的代码几乎与先前的示例相同。唯一的变化是为“Blog”类添加适当的主键。一旦定义了键，我们就可以像以前一样创建写入器和读取器来处理“Blog”和“Post”实例到它们各自的文件中。
- en: Dumping and loading multiple row types in a CSV file
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在CSV文件中转储和加载多种行类型
- en: Creating multiple kinds of rows in a single file makes the format a bit more
    complex. The column titles must become a union of all the available column titles.
    Because of the possibility of name clashes between the various row types, we can
    either access rows by position—preventing us from simply using `csv.DictReader`—or
    we must invent a more sophisticated column title that combines class and attribute
    names.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个文件中创建多种类型的行使格式变得更加复杂。列标题必须成为所有可用列标题的并集。由于各种行类型之间可能存在名称冲突的可能性，我们可以通过位置访问行，防止我们简单地使用“csv.DictReader”，或者我们必须发明一个更复杂的列标题，结合类和属性名称。
- en: 'The process is simpler if we provide each row with an extra column that acts
    as a class discriminator. This extra column shows us what type of object the row
    represents. The object''s class name would work out well for this. Here''s how
    we might write blogs and posts to a single CSV file using two different row formats:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为每一行提供一个额外的列作为类别鉴别器，那么这个过程就会更简单。这个额外的列告诉我们行代表的是什么类型的对象。对象的类名会很好地起作用。以下是我们可能使用两种不同的行格式将博客和帖子写入单个CSV文件的方法：
- en: '[PRE50]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We created two varieties of rows in the file. Some rows have `'Blog'` in the
    first column and contain just the attributes of a `Blog` object. Other rows have
    `'Post'` in the first column and contain just the attributes of a `Post` object.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在文件中创建了两种行的变体。一些行在第一列中有`'Blog'`，只包含`Blog`对象的属性。其他行在第一列中有`'Post'`，只包含`Post`对象的属性。
- en: We did not make the titles unique, so we can't use a dictionary reader. When
    allocating columns by position like this, each row allocates unused columns based
    on the other types of rows with which it must coexist. These additional columns
    are filled with `None`. As the number of distinct row types grows, keeping track
    of the various positional column assignments can become challenging.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有使标题唯一，因此无法使用字典读取器。像这样按位置分配列时，每行都会根据它必须共存的其他类型的行来分配未使用的列。这些额外的列填充为`None`。随着不同行类型的数量增加，跟踪各个位置列的分配可能变得具有挑战性。
- en: 'Also, the individual data type conversions can be somewhat baffling. In particular,
    we''ve ignored the data type of the timestamp and tags. We can try to reassemble
    our `Blogs` and `Posts` by examining the row discriminators:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，单独的数据类型转换可能有些令人困惑。特别是，我们忽略了时间戳和标签的数据类型。我们可以尝试通过检查行鉴别器来重新组装我们的`Blogs`和`Posts`：
- en: '[PRE51]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This snippet will construct a list of `Blog` objects. Each `'Blog'` row uses
    columns in `slice(1,2)` to define the `Blog` object. Each `'Post'` row uses columns
    in `slice(2,6)` to define a `Post` object. This requires that each `Blog` be followed
    by the relevant `Post` instances. A foreign key is not used to tie the two objects
    together.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将构建一个`Blog`对象列表。每个`'Blog'`行使用`slice(1,2)`中的列来定义`Blog`对象。每个`'Post'`行使用`slice(2,6)`中的列来定义`Post`对象。这要求每个`Blog`后面都跟着相关的`Post`实例。外键不用于将这两个对象联系在一起。
- en: We've used two assumptions about the columns in the CSV file that has the same
    order and type as the parameters of the class constructors. For `Blog` objects,
    we used `blog= Blog( *r[1:2] )` because the one-and-only column is text, which
    matches the class constructor. When working with externally supplied data, this
    assumption might prove to be invalid.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对CSV文件中的列做了两个假设，即它们的顺序和类型与类构造函数的参数相同。对于`Blog`对象，我们使用了`blog= Blog( *r[1:2]
    )`，因为唯一的列是文本，这与类构造函数匹配。在处理外部提供的数据时，这个假设可能是无效的。
- en: 'To build the `Post` instances, we''ve used a separate function to map from
    columns to class constructor. Here''s the mapping function:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建`Post`实例，我们使用了一个单独的函数来从列映射到类构造函数。以下是映射函数：
- en: '[PRE52]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This will properly build a `Post` instance from a row of text. It converts the
    text for `datetime` and the text for the tags to their proper Python types. This
    has the advantage of making the mapping explicit.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从文本行正确构建一个`Post`实例。它将`datetime`的文本和标签的文本转换为它们正确的Python类型。这有一个使映射明确的优点。
- en: 'In this example, we''re using `ast.literal_eval()` to decode more complex Python
    literal values. This allows the CSV data to include a tuple of string values:
    `"(''#RedRanger'', ''#Whitby42'', ''#ICW'')"`.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`ast.literal_eval()`来解码更复杂的Python文字值。这允许CSV数据包括一个字符串值的元组："('#RedRanger',
    '#Whitby42', '#ICW')"。
- en: Filtering CSV rows with an iterator
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用迭代器过滤CSV行
- en: 'We can refactor the previous load example to iterate through the `Blog` objects
    rather than constructing a list of the `Blog` objects. This allows us to skim
    through a large CSV file and locate just the relevant `Blog` and `Post` rows.
    This function is a generator that yields each individual `Blog` instance separately:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重构先前的加载示例，通过迭代`Blog`对象而不是构建`Blog`对象的列表。这使我们能够浏览大型CSV文件并定位只有相关的`Blog`和`Post`行。这个函数是一个生成器，分别产生每个单独的`Blog`实例：
- en: '[PRE53]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This `blog_iter()` function creates the `Blog` object and appends the `Post`
    objects. Each time a `Blog` header appears, the previous `Blog` is complete and
    can be yielded. At the end, the final `Blog` object must also be yielded. If we
    want the large list of `Blog` instances, we can use the following code:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`blog_iter()`函数创建`Blog`对象并附加`Post`对象。每当出现一个`Blog`标题时，前一个`Blog`就完成了并且可以被产出。最后，最终的`Blog`对象也必须被产出。如果我们想要大量的`Blog`实例列表，我们可以使用以下代码：
- en: '[PRE54]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This will use the iterator to build a list of `Blogs` in the rare cases that
    we actually want the entire sequence in memory. We can use the following to process
    each `Blog` individually, rendering it to create RST files:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用迭代器在极少数情况下构建一个`Blogs`列表，实际上我们确实希望整个序列保存在内存中。我们可以使用以下方法逐个处理每个`Blog`，将其呈现为创建RST文件：
- en: '[PRE55]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We used the `blog_iter()` function to read each blog. After being read, it can
    be rendered to an RST-format file. A separate process can run `rst2html.py` to
    convert each blog to HTML.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`blog_iter()`函数来读取每个博客。读取后，它可以呈现为一个RST格式文件。一个单独的进程可以运行`rst2html.py`将每个博客转换为HTML。
- en: We can easily add a filter to process only selected `Blog` instances. Rather
    than simply rendering all the `Blog` instances, we can add an `if` statement to
    decide which `Blogs` should be rendered.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地添加一个过滤器来处理只选择的`Blog`实例。我们可以添加一个`if`语句来决定应该呈现哪些`Blogs`，而不仅仅是呈现所有的`Blog`实例。
- en: Dumping and loading joined rows in a CSV file
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在CSV文件中转储和加载连接的行
- en: Joining the objects together means that each row is a child object, joined with
    all of the parent objects that child. This leads to repetition of the parent object's
    attributes for each child object. When there are multiple levels of containers,
    this can lead to large amounts of repeated data.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象连接在一起意味着每一行都是一个子对象，与所有父对象连接在一起。这会导致每个子对象重复父对象的属性。当存在多层容器时，这可能导致大量重复的数据。
- en: The advantage of this repetition is that each row stands alone and doesn't belong
    to a context defined by the rows above it. We don't need a class discriminator
    as parent values are repeated for each child object.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这种重复的优势在于每行都是独立的，不属于由其上面的行定义的上下文。我们不需要类鉴别器，因为父值为每个子对象重复。
- en: This works well for data that forms a simple hierarchy; each child has some
    parent attributes added to it. When the data involves more complex relationships,
    the simplistic parent-child pattern breaks down. In these examples, we've lumped
    the `Post` tags into a single column of text. If we tried to break the tags into
    separate columns, they would become children of each `Post`, meaning that the
    text of `Post` might be repeated for each tag. Clearly, this isn't a good idea!
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于形成简单层次结构的数据效果很好；每个子对象都添加了一些父属性。当数据涉及更复杂的关系时，简单的父子模式就会崩溃。在这些例子中，我们将`Post`标签合并到一个文本列中。如果我们尝试将标签分成单独的列，它们将成为每个`Post`的子对象，这意味着`Post`的文本可能会重复出现。显然，这不是一个好主意！
- en: 'The column titles must become a union of all the available column titles. Because
    of the possibility of name clashes between the various row types, we''ll qualify
    each column name with the class name. This will lead to column titles such as
    `''Blog.title''` and `''Post.title''`, which prevents name clashes. This allows
    for the use of `DictReader` and `DictWriter` rather than the positional assignment
    of the columns. However, these qualified names don''t trivially match the attribute
    names of the class definitions; this leads to somewhat more text processing to
    parse the column titles. Here''s how we can write a joined row that contains parent
    as well as child attributes:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 列标题必须成为所有可用列标题的并集。由于各种行类型之间可能存在名称冲突的可能性，我们将用类名限定每个列名。这将导致列标题，如`'Blog.title'`和`'Post.title'`，从而避免名称冲突。这允许使用`DictReader`和`DictWriter`而不是列的位置赋值。然而，这些有资格的名称并不会简单地匹配类定义的属性名称；这会导致更多的文本处理来解析列标题。以下是我们如何编写一个包含父属性和子属性的联合行：
- en: '[PRE56]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We saw qualified column titles. In this format, each row now contains a union
    of the `Blog` attribute and the `Post` attributes. This is somewhat easier to
    prepare, as there''s no need to fill unused columns with `None`. As each column
    name is unique, we could easily switch to a `DictWriter` too. Here''s a way to
    reconstruct the original container from the CSV rows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了有资格的列标题。在这种格式中，每一行现在包含了`Blog`属性和`Post`属性的并集。这样更容易准备，因为不需要用`None`填充未使用的列。由于每个列名都是唯一的，我们也可以很容易地切换到`DictWriter`。以下是从CSV行重构原始容器的方法：
- en: '[PRE57]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The first row of data is used to build a `Blog` instance and the first `Post`
    in that `Blog`. The invariant condition for the loop that follows assumes that
    there''s a proper `Blog` object. Having a valid `Blog` instance makes the processing
    logic much simpler. The `Post` instances are built with the following function:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行数据用于构建`Blog`实例和该`Blog`中的第一个`Post`。随后的循环不变条件假设存在一个合适的`Blog`对象。拥有一个有效的`Blog`实例使得处理逻辑变得简单得多。`Post`实例是用以下函数构建的：
- en: '[PRE58]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We mapped the individual columns in each row through a conversion to the parameters
    of the class constructor. This makes all of the conversions explicit. It properly
    handles all of the type conversions from the CSV text to Python objects.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将每行中的单独列映射到类构造函数的参数来映射。这使得所有的转换都是显式的。它正确处理了从CSV文本到Python对象的所有类型转换。
- en: 'We might want to refactor the `Blog` builder to a separate function. However,
    it''s so small that adherence to the DRY principle seems a bit fussy. Because
    the column titles match the parameter names, we might try to use something like
    the following code to build each object:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想要将`Blog`构建器重构为一个单独的函数。但是，它非常小，遵循DRY原则似乎有点麻烦。因为列标题与参数名称匹配，我们可以尝试使用以下代码构建每个对象：
- en: '[PRE59]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We used two generator expressions here. The first generator expression splits
    the column names into the class and attribute and builds a 3-tuple with the full
    key, the class name, and the attribute name. The second generator expression filters
    the class for the desired target class; it builds a sequence of 2-tuples with
    the attribute and value pairs that can be used to build a dictionary.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了两个生成器表达式。第一个生成器表达式将列名拆分为类和属性，并构建一个包含完整键、类名和属性名的3元组。第二个生成器表达式过滤了所需目标类的类；它构建了一个包含属性和值对的2元组序列，可以用来构建字典。
- en: This doesn't handle the data conversion for `Posts`. The individual column mappings
    simply don't generalize well. Adding lots of processing logic to this isn't very
    helpful when we compare it to the `post_builder5()` function.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不处理`Posts`的数据转换。单个列映射并不通用。当与`post_builder5()`函数相比时，向此添加大量处理逻辑并不是很有帮助。
- en: In the unlikely event that we have an empty file—one with a header row but zero
    `Blog` entries—the initial `row=next(rdr)` function will raise a `StopIteration`
    exception. As this generator function doesn't handle the exception, it will propagate
    to the loop that evaluated `blog_iter2()`; this loop will be terminated properly.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个空文件，即有标题行但没有`Blog`条目的文件，初始的`row=next(rdr)`函数将引发`StopIteration`异常。由于这个生成器函数没有处理异常，它将传播到评估`blog_iter2()`的循环；这个循环将被正确终止。
- en: Dumping and loading with XML
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用XML进行转储和加载
- en: Python's `xml` package includes numerous modules that parse XML files. There
    is also a **Document Object Model** (**DOM**) implementation that can produce
    an XML document. As with the previous `json` module, this is not a very complete
    persistence solution for Python objects. Because of the wide adoption of the XML
    files, however, it often becomes necessary to convert between Python objects and
    XML documents.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`xml`包包括许多解析XML文件的模块。还有一个**文档对象模型**（**DOM**）实现，可以生成XML文档。与之前的`json`模块一样，这对于Python对象来说并不是一个非常完整的持久性解决方案。然而，由于广泛采用XML文件，通常需要在Python对象和XML文档之间进行转换。
- en: Working with XML files involves a manual mapping between our objects and XML
    structures. We need to design the mapping carefully, remaining cognizant of the
    constraints of XML's notation. This can be difficult because of the mismatch between
    the expressive powers of objects and the strictly hierarchical nature of an XML
    document.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 处理XML文件涉及我们的对象和XML结构之间的手动映射。我们需要仔细设计映射，同时要意识到XML符号的约束。这可能很困难，因为对象的表达能力与XML文档的严格分层性质之间存在不匹配。
- en: The content of an XML attribute or tag is pure text. When loading an XML document,
    we'll need to convert these values to more useful types inside our applications.
    In some cases, the XML document might include attributes or tags to indicate the
    expected type.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: XML属性或标记的内容是纯文本。在加载XML文档时，我们需要将这些值转换为我们应用程序内部更有用的类型。在某些情况下，XML文档可能包括属性或标记以指示预期的类型。
- en: If we are willing to put up with some limitations, we can use the `plistlib`
    module to emit some built-in Python structures as XML documents. We'll examine
    this module in [Chapter 13](ch13.html "Chapter 13. Configuration Files and Persistence"),
    *Configuration Files and Persistence*, where we'll use it to load the configuration
    files.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愿意忍受一些限制，我们可以使用`plistlib`模块将一些内置的Python结构发出为XML文档。我们将在[第13章](ch13.html "第13章。配置文件和持久性")中详细介绍这个模块，*配置文件和持久性*，在那里我们将使用它来加载配置文件。
- en: Note
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `json` module offers ways to extend the JSON encoding to include our customized
    classes; the `plistlib` module doesn't offer this additional hook.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`json`模块提供了将JSON编码扩展到包括我们自定义类的方法；`plistlib`模块没有提供此额外的钩子。'
- en: 'When we look at dumping a Python object to create an XML document, there are
    three common ways to build the text:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑将Python对象转储为XML文档时，有三种常见的构建文本的方法：
- en: Include XML output methods in our class design. In this case, our classes emit
    strings that can be assembled into an XML document.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的类设计中包含XML输出方法。在这种情况下，我们的类发出可以组装成XML文档的字符串。
- en: Use `xml.etree.ElementTree` to build the `ElementTree` nodes and return this
    structure. This can be rendered as text.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`xml.etree.ElementTree`构建`ElementTree`节点并返回此结构。这可以呈现为文本。
- en: Use an external template and fill attributes into that template. Unless we have
    a sophisticated template tool, this doesn't work out well. The `string.Template`
    class in the standard library is only suitable for very simple objects.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用外部模板并将属性填充到该模板中。除非我们有一个复杂的模板工具，否则这样做效果不佳。标准库中的`string.Template`类仅适用于非常简单的对象。
- en: There are some examples of generic Python XML serializers. The problem with
    trying to create a generic serializer is that XML is extremely flexible; each
    application of XML seems to have unique **XML Schema Definition** (**XSD**) or
    **Document Type Definition** (**DTD**) requirements.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些通用的Python XML序列化器示例。尝试创建通用序列化器的问题在于XML非常灵活；每个XML应用似乎都有独特的**XML模式定义**（**XSD**）或**文档类型定义**（**DTD**）要求。
- en: 'One open design question is how to encode an atomic value. There are a large
    number of choices. We could use a type-specific tag with an attribute name in
    the tag''s attributes: `<int name="the_answer">42</int>`. Another possibility
    is to use an attribute-specific tag with the type in the tag''s attributes: `<the_answer
    type="int">42</the_answer>`. We can also use nested tags: `<the_answer><int>42</int></the_answer>`.
    Or, we could rely on a separate schema definition to suggest that `the_answer`
    should be an integer and merely encode the value as text: `<the_answer>42</the_answer>`.
    We can also use adjacent tags: `<key>the_answer</key><int>42</int>`. This is not
    an exhaustive list; XML offers us a lot of choices.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 一个开放的设计问题是如何编码原子值。有很多选择。我们可以在标记的属性中使用特定类型的标记：`<int name="the_answer">42</int>`。另一种可能性是在标记的属性中使用特定类型的标记：`<the_answer
    type="int">42</the_answer>`。我们还可以使用嵌套标记：`<the_answer><int>42</int></the_answer>`。或者，我们可以依赖于单独的模式定义，建议`the_answer`应该是一个整数，并仅将值编码为文本：`<the_answer>42</the_answer>`。我们还可以使用相邻的标记：`<key>the_answer</key><int>42</int>`。这并不是一个详尽的列表；XML为我们提供了很多选择。
- en: When it comes to recovering Python objects from an XML document, we are constrained
    by the APIs of our parsers. Generally, we have to parse the document and then
    examine the XML tag structure, assembling Python objects from the available data.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 当从XML文档中恢复Python对象时，我们受到解析器API的限制。通常，我们必须解析文档，然后检查XML标记结构，从可用数据中组装Python对象。
- en: 'Some Web frameworks, such as Django, include XML serialization of Django-defined
    classes. This isn''t general serialization of arbitrary Python objects. The serialization
    is narrowly defined by Django''s data modeling components. Additionally, there
    are packages such as `dexml`, `lxml`, and `pyxser` as alternative bindings between
    Python objects and XML. See [http://pythonhosted.org/dexml/api/dexml.html](http://pythonhosted.org/dexml/api/dexml.html),
    [http://lxml.de](http://lxml.de), and [http://coder.cl/products/pyxser/](http://coder.cl/products/pyxser/).
    Here''s a longer list of candidate packages: [https://wiki.python.org/moin/PythonXml](https://wiki.python.org/moin/PythonXml).'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Web框架，如Django，包括Django定义类的XML序列化。这不是任意Python对象的通用序列化。序列化由Django的数据建模组件严格定义。此外，还有诸如`dexml`、`lxml`和`pyxser`等软件包，作为Python对象和XML之间的替代绑定。请参阅[http://pythonhosted.org/dexml/api/dexml.html](http://pythonhosted.org/dexml/api/dexml.html)、[http://lxml.de](http://lxml.de)和[http://coder.cl/products/pyxser/](http://coder.cl/products/pyxser/)。以下是候选软件包的更长列表：[https://wiki.python.org/moin/PythonXml](https://wiki.python.org/moin/PythonXml)。
- en: Dumping objects using string templates
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用字符串模板转储对象
- en: 'One way to serialize a Python object into XML is by creating the XML text.
    This is a kind of manual mapping that''s often implemented as a method function
    that emits a snippet of XML that corresponds to the Python object. In the case
    of a complex object, the container must get the XML for each item inside the container.
    Here are two simple extensions to our microblog class structure that add the XML
    output capability as text:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 将Python对象序列化为XML的一种方法是创建XML文本。这是一种手动映射，通常实现为一个方法函数，该函数发出与Python对象对应的XML片段。对于复杂对象，容器必须获取容器内每个项目的XML。以下是我们的微博类结构的两个简单扩展，添加了文本的XML输出功能：
- en: '[PRE60]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We''ve written some highly class-specific XML output methods. These will emit
    the relevant attributes wrapped in XML syntax. This approach doesn''t generalize
    well. The `Blog_X.xml()` method emits a `<blog>` tag with a title and entries.
    The `Post_X.xml()` method emits a `<post>` tag with the various attributes. In
    both of these methods, subsidiary objects were created using `"".join()` or `"\n".join()`
    to build a longer string from shorter string elements. When we convert a `Blog`
    object to XML, the results look like this:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了一些高度特定于类的XML输出方法。这些方法将发出包装在XML语法中的相关属性。这种方法不太通用。`Blog_X.xml()`方法发出带有标题和条目的`<blog>`标记。`Post_X.xml()`方法发出带有各种属性的`<post>`标记。在这两种方法中，使用`"".join()`或`"\n".join()`创建了较短字符串元素的较长字符串。当我们将`Blog`对象转换为XML时，结果如下：
- en: '[PRE61]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This approach has two disadvantages:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有两个缺点：
- en: We've ignored the XML namespaces. That's a small change to the literal text
    for emitting the tags.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们忽略了XML命名空间。这是发出标记的文字的一个小改变。
- en: Each class would also need to properly escape the `<`, `&`, `>`, and `"` characters
    into the XML entities `&lt;`, `&gt;`, `&amp;`, and `&quot;`. The `html` module
    includes the `html.escape()` function that does this.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个类还需要正确转义`<`、`&`、`>`和`"`字符为XML实体`&lt;`、`&gt;`、`&amp;`和`&quot;`。`html`模块包括`html.escape()`函数来执行此操作。
- en: This does emit proper XML; it can be relied upon to work; it isn't very elegant
    and doesn't generalize well.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实发出了正确的XML；可以依赖它工作；它不太优雅，也不太通用。
- en: Dumping objects with xml.etree.ElementTree
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用xml.etree.ElementTree转储对象
- en: We can use the `xml.etree.ElementTree` module to build `Element` structures
    that can be emitted as XML. It's challenging to use `xml.dom` and `xml.minidom`
    for this. The DOM API requires a top-level document that then builds individual
    elements. The presence of this necessary context object creates clutter when trying
    to serialize a simple class with several attributes. We have to create the document
    first and then serialize all the elements of the document, providing the document
    context as an argument.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`xml.etree.ElementTree`模块构建可以作为XML发出的`Element`结构。使用`xml.dom`和`xml.minidom`进行这项工作是具有挑战性的。DOM
    API需要一个顶级文档，然后构建单独的元素。当尝试序列化具有多个属性的简单类时，必要的上下文对象的存在会导致混乱。我们必须首先创建文档，然后序列化文档的所有元素，并将文档上下文作为参数提供。
- en: 'Generally, we''d like each class in our design to build a top-level element
    and return that. Most top-level elements will have a sequence of subelements.
    We can assign text as well as attributes to each element that we build. We can
    also assign a *tail* that is the extraneous text that follows a closed tag. In
    some content models, this is just whitespace. Because of the long name, it might
    be helpful to import `ElementTree` in the following manner:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们希望设计中的每个类都构建一个顶级元素并返回。大多数顶级元素将具有一系列子元素。我们可以为构建的每个元素分配文本以及属性。我们还可以分配一个*tail*，即跟在封闭标记后面的多余文本。在某些内容模型中，这只是空白。由于名称很长，可能有助于以以下方式导入`ElementTree`：
- en: '[PRE62]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Here are two extensions to our microblog class structure that add the XML output
    capability as the `Element` instances. We add the following method to the `Blog`
    class:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的微博类结构的两个扩展，将XML输出功能添加为`Element`实例。我们向`Blog`类添加了以下方法：
- en: '[PRE63]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We add the following method to the `Post` class:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向`Post`类添加了以下方法：
- en: '[PRE64]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We've written highly class-specific XML output methods. These will build the
    `Element` objects that have the proper text values.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了高度特定于类的XML输出方法。这些方法将构建具有适当文本值的`Element`对象。
- en: Note
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There's no fluent shortcut for building the subelements. We have to insert each
    text item individually.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 没有用于构建子元素的流畅快捷方式。我们必须逐个插入每个文本项。
- en: In the `blog` method, we were able to perform `Element.extend()` to put all
    of the individual post entries inside the `<entry>` element. This allows us to
    build the XML structure flexibly and simply. This approach can deal gracefully
    with the XML namespaces. We can use the `QName` class to build qualified names
    for XML namespaces. The `ElementTree` module correctly applies the namespace qualifiers
    to the XML tags. This approach also properly escapes the `<`, `&`, `>`, and `"`
    characters into the XML entities `&lt;`, `&gt;`, `&amp;`, and `&quot;`. The XML
    output from these methods will mostly match the previous section. The whitespace
    will be different.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在`blog`方法中，我们能够执行`Element.extend()`将所有单独的帖子条目放在`<entry>`元素内。这使我们能够灵活而简单地构建XML结构。这种方法可以优雅地处理XML命名空间。我们可以使用`QName`类为XML命名空间构建合格的名称。`ElementTree`模块正确地将命名空间限定符应用于XML标记。这种方法还可以将`<`、`&`、`>`和`"`字符正确转义为XML实体`&lt;`、`&gt;`、`&amp;`和`&quot;`。这些方法生成的XML输出大部分将与上一节相匹配。空格将不同。
- en: Loading XML documents
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载XML文档
- en: Loading Python objects from an XML document is a two-step process. First, we
    need to parse the XML text to create the document objects. Then, we need to examine
    the document objects to produce Python objects. As noted previously, the tremendous
    flexibility of XML notation means that there isn't a single XML-to-Python serialization.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 从XML文档加载Python对象是一个两步过程。首先，我们需要解析XML文本以创建文档对象。然后，我们需要检查文档对象以生成Python对象。正如前面所述，XML符号的巨大灵活性意味着没有单一的XML到Python序列化。
- en: 'One approach to walk through an XML document involves making XPath-like queries
    to locate the various elements that were parsed. Here''s a function to walk an
    XML document, emitting the `Blog` and `Post` objects from the available XML:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历XML文档的一种方法涉及进行类似XPath的查询，以定位解析的各种元素。以下是一个遍历XML文档的函数，从可用的XML中发出`Blog`和`Post`对象：
- en: '[PRE65]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This snippet traverses a `<blog>` XML document. It locates the `<title>` tag
    and gathers all of the text within that element to create the top-level `Blog`
    instance. It then locates all the `<entry>` subelements found within the `<entries>`
    element. These are used to build each `Post` object. The various attributes of
    the `Post` object are converted individually. The text of each individual `<tag>`
    element within the `<tags>` element is turned into a list of text values. The
    date is parsed from its text representation. The `Post` objects are each appended
    to the overall `Blog` object. This *manual* mapping from XML text to Python objects
    is an essential feature of parsing XML documents.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码遍历了一个`<blog>` XML文档。它定位了`<title>`标记，并收集该元素内的所有文本，以创建顶层的`Blog`实例。然后，它定位了`<entries>`元素内找到的所有`<entry>`子元素。这些用于构建每个`Post`对象。`Post`对象的各种属性被单独转换。`<tags>`元素内每个单独的`<tag>`元素的文本被转换为文本值列表。日期从其文本表示中解析出来。每个`Post`对象都被追加到整体的`Blog`对象中。这种从XML文本到Python对象的*手动*映射是解析XML文档的一个重要特性。
- en: Summary
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: We've looked at a number of ways to serialize Python objects. We can encode
    our class definitions in notations, including JSON, YAML, pickle, XML, and CSV.
    Each of these notations has a variety of advantages and disadvantages.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过了多种序列化Python对象的方法。我们可以在各种符号中对我们的类定义进行编码，包括JSON、YAML、pickle、XML和CSV。每种符号都有各种优点和缺点。
- en: These various library modules generally work around the idea of loading objects
    from an external file or dumping objects to a file. These modules aren't completely
    consistent with each other, but they're very similar, allowing us to apply some
    common design patterns.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不同的库模块通常围绕着从外部文件加载对象或将对象转储到文件的想法。这些模块并不完全一致，但它们非常相似，允许我们应用一些常见的设计模式。
- en: Using CSV and XML tends to expose the most difficult design problems. Our class
    definitions in Python can include object references that don't have a good representation
    in the CSV or XML notation.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CSV和XML往往会暴露出最困难的设计问题。我们在Python中的类定义可以包括在CSV或XML符号中没有很好表示的对象引用。
- en: Design considerations and trade-offs
  id: totrans-373
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计考虑和权衡
- en: 'There are many ways to serialize and persist Python objects. We haven''t seen
    all of them yet. The formats in this section are focused on two essential use
    cases:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以序列化和持久化Python对象。我们还没有看到它们的全部。本节中的格式侧重于两个基本用例：
- en: '**Data interchange with other applications**: We might be publishing data for
    other applications or accepting data from other applications. In this case, we''re
    often constrained by the other applications'' interfaces. Often, JSON and XML
    are used by other applications and frameworks as their preferred form of data
    interchange. In some cases, we''ll use CSV to exchange data.'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与其他应用程序的数据交换**：我们可能会为其他应用程序发布数据或接受其他应用程序的数据。在这种情况下，我们通常受到其他应用程序接口的限制。通常，其他应用程序和框架使用JSON和XML作为其首选的数据交换形式。在某些情况下，我们将使用CSV来交换数据。'
- en: '**Persistent data for our own applications**: In this case, we''re often going
    to choose `pickle` because it''s complete and is already part of the Python Standard
    Library. However, one of the important advantages of YAML is its readability;
    we can view, edit and even modify the file.'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们自己应用程序的持久数据**：在这种情况下，我们通常会选择`pickle`，因为它是完整的，并且已经是Python标准库的一部分。然而，YAML的一个重要优势是它的可读性；我们可以查看、编辑甚至修改文件。'
- en: When working with each of these formats, we have a number of design considerations.
    First and foremost, these formats are biased towards serializing a single Python
    object. It might be a list of other objects, but it is essentially a single object.
    JSON and XML, for example, have ending delimiters that are written after the serialized
    object. For persisting individual objects from a larger domain, we can look at
    `shelve` and `sqlite3` in [Chapter 10](ch10.html "Chapter 10. Storing and Retrieving
    Objects via Shelve"), *Storing and Retrieving Objects via Shelve* and [Chapter
    11](ch11.html "Chapter 11. Storing and Retrieving Objects via SQLite"), *Storing
    and Retrieving Objects via SQLite*.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理这些格式时，我们有许多设计考虑。首先，这些格式偏向于序列化单个Python对象。它可能是其他对象的列表，但本质上是单个对象。例如，JSON和XML具有在序列化对象之后编写的结束分隔符。对于从较大域中持久化单个对象，我们可以查看[第10章](ch10.html
    "第10章。通过Shelve存储和检索对象")中的`shelve`和`sqlite3`，*通过Shelve存储和检索对象*和[第11章](ch11.html
    "第11章。通过SQLite存储和检索对象")中的`shelve`和`sqlite3`，*通过SQLite存储和检索对象*。
- en: JSON is a widely-used standard. It's inconvenient for representing complex Python
    classes. When using JSON, we need to be cognizant of how our objects can be reduced
    to a JSON-compatible representation. JSON documents are human-readable. JSON's
    limitations make it potentially secure for the transmission of objects through
    the Internet.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: JSON是一个广泛使用的标准。它不方便表示复杂的Python类。在使用JSON时，我们需要意识到我们的对象如何被简化为与JSON兼容的表示形式。JSON文档是人类可读的。JSON的限制使其在通过互联网传输对象时可能更安全。
- en: YAML is not as widely used as JSON, but it solves numerous problems in serialization
    and persistence. YAML documents are human-readable. For editable configuration
    files, YAML is ideal. We can make YAML secure using the safe-load options.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: YAML并不像JSON那样广泛使用，但它解决了序列化和持久性中的许多问题。YAML文档是人类可读的。对于可编辑的配置文件，YAML是理想的。我们可以使用safe-load选项使YAML安全。
- en: Pickle is ideal for the simple, fast local persistence of Python objects. It
    is a compact notation for the transmission from Python-to-Python. CSV is a widely-used
    standard. Working out representations for Python objects in CSV notation is challenging.
    When sharing data in the CSV notation, we often end up using `namedtuples` in
    our applications. We have to design a mapping from Python to CSV and CSV to Python.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: Pickle非常适合于Python对象的简单，快速的本地持久性。它是从Python到Python的传输的紧凑表示。CSV是一个广泛使用的标准。在CSV表示中为Python对象制定表示形式是具有挑战性的。在CSV表示中共享数据时，我们经常在应用程序中使用`namedtuples`。我们必须设计一个从Python到CSV和从CSV到Python的映射。
- en: XML is another widely-used notation for serializing data. XML is extremely flexible,
    leading to a wide variety of ways to encode Python objects in XML notation. Because
    of the XML use cases, we often have external specifications in the form of an
    XSD or DTD. The process for parsing XML to create Python objects is always rather
    complex.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: XML是另一种广泛使用的序列化数据的表示形式。XML非常灵活，导致了多种在XML表示中编码Python对象的方式。由于XML用例，我们经常有外部规范，如XSD或DTD。解析XML以创建Python对象的过程总是相当复杂的。
- en: Because each CSV row is largely independent of the others, CSV allows us to
    encode or decode extremely large collections of objects. For this reason, CSV
    is often handy for encoding and decoding gargantuan collections that can't fit
    into the memory.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个CSV行在很大程度上独立于其他行，CSV允许我们编码或解码极大的对象集合。因此，CSV通常用于编码和解码无法放入内存的巨大集合。
- en: In some cases, we have a hybrid design problem. When reading most modern spreadsheet
    files, we have the CSV row-and-column problem wrapped in the XML parsing problem.
    For example, [OpenOffice.org](http://OpenOffice.org). ODS files are zipped archives.
    One of the files in the archive is the `content.xml` file. Using an XPath search
    for `body/spreadsheet/table` elements will locate the individual tabs of the spreadsheet
    document. Within each table, we'll find the `table-row` elements that (usually)
    map to Python objects. Within each row, we'll find the `table-cell` elements that
    contain the individual values that build up the attributes of an object.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们面临混合设计问题。在阅读大多数现代电子表格文件时，我们遇到了CSV行列问题和XML解析问题。例如，[OpenOffice.org](http://OpenOffice.org)。ODS文件是压缩存档。存档中的一个文件是`content.xml`文件。使用XPath搜索`body/spreadsheet/table`元素将定位电子表格文档的各个选项卡。在每个表格中，我们会找到通常映射到Python对象的`table-row`元素。在每行中，我们会找到包含构建对象属性的单个值的`table-cell`元素。
- en: Schema evolution
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模式演变
- en: When working with persistent objects, we have to address the problem of schema
    evolution. Our objects have a dynamic state and a static class definition. We
    can easily persist the dynamic state. Our class definitions are the schema for
    the persistent data. The class, however, is not *absolutely* static. When a class
    changes, we need to make a provision to load data that was dumped by the previous
    release of our application.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理持久对象时，我们必须解决模式演变的问题。我们的对象具有动态状态和静态类定义。我们可以轻松地保存动态状态。我们的类定义是持久数据的模式。然而，类并非*绝对*静态。当类发生变化时，我们需要提供加载由应用程序的先前版本转储的数据的方法。
- en: It's best to think of external file compatibility to distinguish between major
    and minor release numbers. A major release should mean that a file is no longer
    compatible and a conversion must be done. A minor release should mean that the
    file formats are compatible and no data conversion will be involved in the upgrade.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 最好考虑外部文件兼容性，以区分主要和次要发布版本号。主要发布应意味着文件不再兼容，必须进行转换。次要发布应意味着文件格式兼容，升级不涉及数据转换。
- en: One common approach is to include the major version number in the file extension.
    We might have filenames that end in `.json2` or `.json3` to indicate which format
    of data is involved. Supporting multiple versions of a persistent file format
    often becomes rather complex. To provide a seamless upgrade path, an application
    should be able to decode previous file formats. Often, it's best to persist data
    in the latest and greatest file format, even if the other formats are supported
    for input.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的方法是在文件扩展名中包含主版本号。我们可能会有以`.json2`或`.json3`结尾的文件名，以指示涉及哪种数据格式。支持持久文件格式的多个版本通常变得相当复杂。为了提供无缝升级路径，应用程序应能够解码先前的文件格式。通常，最好将数据持久化在最新和最好的文件格式中，即使其他格式也支持输入。
- en: In the next chapters, we'll address serialization that's not focused on a single
    object. The `shelve` and `sqlite3` modules give us ways to serialize a universe
    of distinct objects. After that, we'll return to using these techniques for **Representational
    State Transfer** (**REST**) to transmit objects from process to process. Also,
    we'll use these techniques yet again to process the configuration files.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论不专注于单个对象的序列化。`shelve`和`sqlite3`模块为我们提供了序列化一系列不同对象的方法。之后，我们将再次使用这些技术来进行**表述状态转移**（**REST**）以将对象从一个进程传输到另一个进程。此外，我们还将再次使用这些技术来处理配置文件。
- en: Looking forward
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 展望未来
- en: In [Chapter 10](ch10.html "Chapter 10. Storing and Retrieving Objects via Shelve"),
    *Storing and Retrieving Objects via Shelve* and [Chapter 11](ch11.html "Chapter 11. Storing
    and Retrieving Objects via SQLite"), *Storing and Retrieving Objects via SQLite*,
    we'll look at two common approaches to make larger collections of persistent objects.
    These two chapters show us different approaches to create a database of Python
    objects.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](ch10.html "第10章。通过Shelve存储和检索对象")和[第11章](ch11.html "第11章。通过SQLite存储和检索对象")中，我们将看到两种常见的方法来创建更大的持久对象集合。这两章向我们展示了创建Python对象数据库的不同方法。
- en: In [Chapter 12](ch12.html "Chapter 12. Transmitting and Sharing Objects"), *Transmitting
    and Sharing Objects*, we'll apply these serialization techniques to the problem
    of making an object available in another process. We'll focus on RESTful web services
    as a simple and popular way to transmit an object among processes.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](ch12.html "第12章。传输和共享对象")中，*传输和共享对象*，我们将把这些序列化技术应用到使对象在另一个进程中可用的问题上。我们将专注于RESTful
    web服务作为在进程之间传输对象的简单和流行的方式。
- en: In [Chapter 13](ch13.html "Chapter 13. Configuration Files and Persistence"),
    *Configuration Files and Persistence*, we'll apply these serialization techniques
    yet again. In this case, we'll use representations such as JSON and YAML to encode
    the configuration information for an application.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第13章](ch13.html "第13章。配置文件和持久化")中，*配置文件和持久化*，我们将再次应用这些序列化技术。在这种情况下，我们将使用JSON和YAML等表示形式来编码应用程序的配置信息。
- en: Chapter 10. Storing and Retrieving Objects via Shelve
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。通过Shelve存储和检索对象
- en: There are many applications where we need to persist objects individually. The
    techniques we looked at in [Chapter 9](ch09.html "Chapter 9. Serializing and Saving
    – JSON, YAML, Pickle, CSV, and XML"), *Serializing and Saving – JSON, YAML, Pickle,
    CSV, and XML*, were biased towards handling a single object. Sometimes, we need
    to persist separate, individual objects from a larger domain.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多应用程序需要单独持久化对象。我们在[第9章](ch09.html "第9章。序列化和保存-JSON、YAML、Pickle、CSV和XML")中看到的技术，*序列化和保存-JSON、YAML、Pickle、CSV和XML*，偏向于处理单个对象。有时，我们需要持久化来自更大领域的单独对象。
- en: 'Applications with persistent objects may demonstrate four use cases, summarized
    as the **CRUD Operations**: Create, Retrieve, Update, and Delete. In the general
    case, any of these operations may be applied to any object in the domain; this
    leads to the need for a more sophisticated persistence mechanism than a monolithic
    load or dump to a file. In addition to squandering memory, simple loads and dumps
    are often less efficient than fine-grained, object-by-object storage.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 具有持久对象的应用程序可能展示四种用例，总结为**CRUD操作**：创建、检索、更新和删除。在一般情况下，这些操作中的任何一个都可以应用于域中的任何对象；这导致需要比单一的加载或转储到文件更复杂的持久化机制。除了浪费内存外，简单的加载和转储通常比精细的、逐个对象的存储效率低。
- en: 'Using more sophisticated storage will lead us to look more closely at the allocation
    of responsibility. The various concerns give us overall design patterns for the
    architecture of the application software. One example of these higher-level design
    patterns is the **Three-Tier Architecture**:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 使用更复杂的存储将使我们更加关注责任的分配。各种关注点为我们提供了应用软件架构的整体设计模式。这些更高级别的设计模式之一是**三层架构**：
- en: '**Presentation tier**: This may be a web browser or mobile app, sometimes both.'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表示层**：这可能是Web浏览器或移动应用程序，有时两者都有。'
- en: '**Application tier**: This is often deployed on an application server. The
    application tier should be subdivided into an application layer and a data model
    layer. The processing layer involves the classes that embody an application''s
    behavior. The data model layer defines the problem domain''s object model.'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用层**：这通常部署在应用服务器上。应用层应该被细分为应用层和数据模型层。处理层涉及体现应用行为的类。数据模型层定义了问题域的对象模型。'
- en: '**Data tier**: This includes an access layer and a persistence layer. The access
    layer provides uniform access to persistent objects. The persistence layer serializes
    objects and writes them to the persistent storage.'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据层**：这包括访问层和持久化层。访问层提供对持久对象的统一访问。持久化层将对象序列化并将其写入持久存储。'
- en: This model can be applied to a single GUI application. The presentation tier
    is the GUI; the application tier is the relevant processor and the data model;
    the access tier is the persistence modules. It even applies to a command-line
    application where the presentation tier is merely an options parser as well as
    the `print()` functions.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型可以应用于单个GUI应用程序。表示层是GUI；应用层是相关的处理器和数据模型；访问层是持久性模块。它甚至适用于命令行应用程序，其中表示层仅仅是一个选项解析器以及`print()`函数。
- en: The `shelve` module defines a mapping-like container in which we can store objects.
    Each stored object is pickled and written to a file. We can also unpickle and
    retrieve any object from the file. The `shelve` module relies on the `dbm` module
    to save and retrieve objects.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '`shelve`模块定义了一个类似映射的容器，我们可以在其中存储对象。每个存储的对象都被pickled并写入文件。我们还可以从文件中unpickle并检索任何对象。`shelve`模块依赖于`dbm`模块来保存和检索对象。'
- en: This section will focus on the data model taken from the application tier and
    the access and persistence taken from the data tier. The interface between these
    tiers can simply be a class interface within a single application. Or, it can
    be a more elaborate networked interface. We'll focus on the simple class-to-class
    interface in this chapter. We'll look at a network-based interface in [Chapter
    12](ch12.html "Chapter 12. Transmitting and Sharing Objects"), *Transmitting and
    Sharing Objects*, using REST.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将重点关注从应用程序层获取的数据模型以及从数据层获取的访问和持久性。这两个层之间的接口可以简单地是单个应用程序内的类接口。或者，它可以是一个更复杂的网络接口。在本章中，我们将重点关注简单的类与类接口。我们将在第12章中，使用REST，*传输和共享对象*，关注基于网络的接口。
- en: Analyzing persistent object use cases
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析持久对象的用例
- en: 'The persistence mechanisms we looked at in [Chapter 9](ch09.html "Chapter 9. Serializing
    and Saving – JSON, YAML, Pickle, CSV, and XML"), *Serializing and Saving – JSON,
    YAML, Pickle, CSV, and XML*, focused on reading and writing a compact file with
    a serialized object. If we wanted to update any part of the file, we were forced
    to replace the entire file. This is a consequence of using a compact notation
    for the data; it''s difficult to reach the position of an object within a file,
    and it''s difficult to replace an object if the size changes. Rather than addressing
    these difficulties with clever, complex algorithms, the object was simply serialized
    and written. When we have a larger domain of many persistent, mutable objects,
    we introduce some additional depth to the use cases. Here are some additional
    considerations:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第9章中看到的持久性机制，*序列化和保存 - JSON、YAML、Pickle、CSV和XML*，侧重于读取和写入一个序列化对象的紧凑文件。如果我们想要更新文件的任何部分，我们被迫替换整个文件。这是使用紧凑表示法的后果；很难到达文件中对象的位置，如果大小发生变化，替换对象也很困难。我们并没有用巧妙、复杂的算法来解决这些困难，而是简单地对对象进行了序列化和写入。当我们有一个更大的领域，有许多持久的、可变的对象时，我们引入了一些额外的深度到用例中。以下是一些额外的考虑：
- en: We may not want to load all the objects into the memory at one time. For many
    *Big Data* applications, it might be impossible to load all the objects into the
    memory at one time.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能不想一次将所有对象加载到内存中。对于许多*大数据*应用程序，一次性加载所有对象可能是不可能的。
- en: We may be updating only small subsets—or individual instances—from our domain
    of objects. Loading and then dumping all the objects to update one object is relatively
    inefficient processing.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能只更新来自对象领域的小子集或单个实例。加载然后转储所有对象以更新一个对象是相对低效的处理。
- en: We may not be dumping all the objects at one time; we may be accumulating objects
    incrementally. Some formats such as YAML and CSV allow us to append themselves
    to a file with little complexity. Other formats such as JSON and XML have terminators
    that make it difficult to simply append to a file.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能不会一次性转储所有对象；我们可能会逐渐累积对象。一些格式，如YAML和CSV，允许我们以很少的复杂性将自己附加到文件上。其他格式，如JSON和XML，有终止符，使得简单地附加到文件变得困难。
- en: There are still more features we might want. It's common to conflate serialization,
    persistence, as well as concurrent update or write access into a single umbrella
    concept of *database*. The `shelve` module is not a comprehensive database solution
    by itself. The underlying `dbm` module used by `shelve` does not directly handle
    concurrent writes. It doesn't handle multioperation transactions either. It's
    possible to use low-level OS locking on the files to tolerate concurrent updating,
    but this tends to be highly OS-specific. For concurrent write access, it's better
    to either use a proper database or a RESTful data server. See [Chapter 11](ch11.html
    "Chapter 11. Storing and Retrieving Objects via SQLite"), *Storing and Retrieving
    objects via SQLite*, and [Chapter 12](ch12.html "Chapter 12. Transmitting and
    Sharing Objects"), *Transmitting and Sharing Objects*.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能还想要更多的功能。将序列化、持久性以及并发更新或写访问混为一谈，统称为*数据库*是很常见的。`shelve`模块本身并不是一个全面的数据库解决方案。`shelve`使用的底层`dbm`模块并不直接处理并发写。它也不处理多操作事务。可以使用低级别的操作系统文件锁定来容忍并发更新，但这往往是高度依赖操作系统的。对于并发写访问，最好使用适当的数据库或RESTful数据服务器。参见[第11章](ch11.html
    "第11章。通过SQLite存储和检索对象")，*通过SQLite存储和检索对象*，以及[第12章](ch12.html "第12章。传输和共享对象")，*传输和共享对象*。
- en: The ACID properties
  id: totrans-409
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ACID属性
- en: Our design must consider how the **ACID properties** apply to our `shelve` database.
    Our application will often make changes in bundles of related operations that
    should change the database from one consistent state to the next consistent state.
    The collection of operations to change a database can be called a transaction.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的设计必须考虑**ACID属性**如何适用于我们的`shelve`数据库。我们的应用程序通常会对相关操作进行捆绑更改，这些操作应该将数据库从一个一致的状态更改到下一个一致的状态。改变数据库的一系列操作可以称为事务。
- en: 'An example of multiple-operation transactions could involve updating two objects
    so that a total is kept invariant. We might be deducting from one financial account
    and depositing into another. The overall balance must be held constant for the
    database to be in a consistent, valid state. The ACID properties characterize
    how we want the database transactions to behave as a whole. There are four rules
    that define our expectations:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 多操作事务的一个例子可能涉及更新两个对象，以保持总和不变。我们可能会从一个财务账户中扣除并存入另一个账户。整体余额必须保持恒定，以使数据库处于一致的有效状态。ACID属性表征了我们希望数据库事务作为一个整体的行为。有四条规则定义了我们的期望：
- en: '**Atomicity**: A transaction must be atomic. If there are multiple operations
    in a transaction, either all the operations should be completed or none of them
    should be completed. It should never be possible to view a shelf with a partially-completed
    transaction.'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子性**：事务必须是原子的。如果事务中有多个操作，要么所有操作都完成，要么都不完成。不应该可能查看一个部分完成的事务的架子。'
- en: '**Consistency**: A transaction must assure consistency. It will change the
    database from one valid state to another. A transaction should not corrupt the
    database or create inconsistent views among concurrent users. All users see the
    same net effect of completed transactions.'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：事务必须保证一致性。它将把数据库从一个有效状态改变为另一个有效状态。事务不应该损坏数据库或在并发用户之间创建不一致的视图。所有用户看到已完成事务的相同净效果。'
- en: '**Isolation**: Each transaction should operate properly as if in complete isolation.
    We can''t have two concurrent users interfering with each other''s attempted updates.
    We must be able to transform concurrent access into (possibly slower) serial access
    and the database updates will produce the same results.'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离性**：每个事务应该像完全隔离一样正常运行。我们不能让两个并发用户干扰彼此的尝试更新。我们必须能够将并发访问转换为（可能更慢的）串行访问，并且数据库更新将产生相同的结果。'
- en: '**Durability**: The changes to the database are **durable**; they persist properly
    in the filesystem.'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久性**：对数据库的更改是**持久的**；它们在文件系统中正确地持久存在。'
- en: When we work with in-memory Python objects, clearly, we get **ACI** but don't
    get **D**. In-memory objects are not durable by definition. If we attempt to use
    the `shelve` module from several concurrent processes without locking or versioning,
    we may get only D but lose the ACI properties.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用内存中的Python对象时，显然，我们得到了**ACI**，但没有得到**D**。内存中的对象根据定义是不持久的。如果我们尝试在几个并发进程中使用`shelve`模块而没有锁定或版本控制，我们可能只得到D，但失去ACI属性。
- en: The `shelve` module doesn't provide direct support for atomicity; it doesn't
    have a way to handle transactions that consists of multiple operations. If we
    have multiple-operation transactions and we need atomicity, we must ensure they
    all work or all fail as a unit. This can involve the rather complex `try:` statements
    that must restore the previous state of the database in the event of a failure.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '`shelve`模块不直接支持原子性；它没有处理由多个操作组成的事务的方法。如果我们有多个操作的事务并且需要原子性，我们必须确保它们全部成功或全部失败。这可能涉及到相当复杂的`try:`语句，必须在失败的情况下恢复数据库的先前状态。'
- en: The `shelve` module doesn't guarantee durability for all kinds of changes. If
    we place a mutable object onto the shelf and then change the object in memory,
    the persistent version on the shelf file will not change *automatically*. If we're
    going to mutate shelved objects, our application must be explicit about updating
    the shelf. We can ask a shelf object to track changes via the *writeback mode*,
    but using this feature can lead to poor performance.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '`shelve`模块不保证对所有种类的更改都是持久的。如果我们将一个可变对象放到架子上，然后在内存中更改对象，架子文件上的持久版本将不会*自动*更改。如果我们要改变架子上的对象，我们的应用程序必须明确地更新架子。我们可以要求架子对象通过*写回模式*跟踪更改，但使用这个特性可能会导致性能不佳。'
- en: Creating a shelf
  id: totrans-419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个架子
- en: The first part of creating a shelf is done using a module-level function, `shelve.open()`,
    to create a persistent shelf structure. The second part is closing the file properly
    so that all changes are written to the underlying filesystem. We'll look at this
    in a more complete example later.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 创建架子的第一部分是使用模块级函数`shelve.open()`来创建一个持久的架子结构。第二部分是正确关闭文件，以便所有更改都被写入底层文件系统。我们稍后会在一个更完整的例子中看到这一点。
- en: Under the hood, the `shelve` module is using the `dbm` module to do the real
    work of opening a file and mapping from key to value. The `dbm` module itself
    is a wrapper around an underlying DBM-compatible library. Consequently, there
    are a number of potential implementations for the `shelve` features. The good
    news is that the differences among the `dbm` implementations are largely irrelevant.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，`shelve`模块使用`dbm`模块来进行真正的工作，打开文件并从键到值的映射。`dbm`模块本身是一个围绕底层DBM兼容库的包装器。因此，`shelve`功能有许多潜在的实现。好消息是，`dbm`实现之间的差异在很大程度上是无关紧要的。
- en: 'The `shelve.open()` module function requires two parameters: the filename and
    the file access mode. Often, we want the default mode of `''c''` to open an existing
    shelf or create one if it doesn''t exist. The alternatives are for specialized
    situations:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '`shelve.open()`模块函数需要两个参数：文件名和文件访问模式。通常，我们希望使用`''c''`的默认模式来打开一个现有的架子，如果不存在则创建一个。专门情况下的替代方案有：'
- en: '`''r''` is a read-only shelf'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''r''`是一个只读的架子'
- en: '`''w''` is a read-write shelf that *must* exist or an exception will be raised'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''w''`是一个读写的架子，*必须*存在，否则将引发异常'
- en: '`''n''` is a new, empty shelf; any previous version will be overwritten'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''n''`是一个新的、空的架子；任何以前的版本都将被覆盖'
- en: It's absolutely essential to close a shelf to be sure that it is properly persisted
    to disk. The shelf is not a context manager itself, but the `contextlib.closing()`
    function can be used to make sure the shelf is closed. For more information on
    context managers, see [Chapter 5](ch05.html "Chapter 5. Using Callables and Contexts"),
    *Using Callables and Contexts.*
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭架子以确保它被正确地持久化到磁盘是绝对必要的。架子本身不是上下文管理器，但`contextlib.closing()`函数可以用来确保架子被关闭。有关上下文管理器的更多信息，请参见[第5章](ch05.html
    "第5章。使用可调用和上下文")，“使用可调用和上下文”。
- en: 'Under some circumstances, we might also want to explicitly synchronize a shelf
    to a disk without closing the file. The `shelve.sync()` method will persist changes
    prior to a close. The ideal lifecycle looks something like the following code:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能还希望显式地将架子与磁盘同步，而不关闭文件。`shelve.sync()`方法将在关闭之前持久化更改。理想的生命周期看起来像以下代码：
- en: '[PRE66]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We've opened a shelf and provided that open shelf to some function that does
    the real work of our application. When this process is finished, the context will
    ensure that the shelf is closed. If the `process()` function raises an exception,
    the shelf will still be properly closed.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打开了一个架子，并将打开的架子提供给一些执行我们应用程序真正工作的函数。当这个过程完成时，上下文将确保架子被关闭。如果`process()`函数引发异常，架子仍将被正确关闭。
- en: Designing shelvable objects
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计可架架对象
- en: If our objects are relatively simple, then putting them on a shelf will be trivial.
    For objects that are not complex containers or large collections, we only have
    to work out a key to value mapping. For objects that are more complex—typically
    objects that contain other objects—we have to make some additional design decisions
    regarding the granularity of access and references among objects.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的对象相对简单，那么将它们放在架子上将是微不足道的。对于不是复杂容器或大型集合的对象，我们只需要解决键到值的映射。对于更复杂的对象——通常包含其他对象的对象——我们必须就访问的粒度和对象之间的引用做出一些额外的设计决策。
- en: We'll look at the simple case first, where all we have to design is the key
    that is used to access our objects. Then, we'll look at the more complex cases,
    where granularity and object references come into play.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先看一个简单的情况，我们只需要设计用于访问我们对象的键。然后，我们将看一些更复杂的情况，其中粒度和对象引用起作用。
- en: Designing keys for our objects
  id: totrans-433
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为我们的对象设计键
- en: The important feature of `shelve` (and `dbm`) is immediate access to any object
    in an arbitrarily huge universe of objects. The `shelve` module works with a mapping
    that is much like a dictionary. The shelf mapping exists on the persistent storage,
    so any object we put onto the shelf will be serialized and saved. The `pickle`
    module is used to do the actual serialization.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '`shelve`（和`dbm`）的重要特性是可以立即访问任意大的对象宇宙中的任何对象。`shelve`模块与类似字典的映射一起工作。架子映射存在于持久存储上，因此我们放在架子上的任何对象都将被序列化和保存。`pickle`模块用于执行实际的序列化。'
- en: We must identify our shelved objects with some kind of key that will map to
    the object. As with a dictionary, the keys are hashed, which is a very quick calculation.
    It's fast because the key is limited to being a byte string; the hash is a modulus
    summation of those bytes. Since Python strings are trivially encoded into bytes,
    it means that string values are a common choice for keys. This is unlike a built-in
    `dict`, where any immutable object can be used as a key.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须用某种键来标识我们的架子对象，这个键将映射到对象。与字典一样，键是经过哈希处理的，这是一个非常快速的计算。这很快是因为键被限制为字节字符串；哈希是这些字节的模和。由于Python字符串可以轻松编码为字节，这意味着字符串值是键的常见选择。这与内置的`dict`不同，其中任何不可变对象都可以用作键。
- en: 'Since the key locates the value, it means the key must be unique. This imposes
    some design considerations on our classes to provide an appropriate unique key.
    In some cases, the problem domain will have an attribute that is an obvious unique
    key. In that case, we can simply use that attribute to construct this key: `shelf[object.key_attribute]=
    object`. This is the simplest case but doesn''t generalize well.'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 由于键定位值，这意味着键必须是唯一的。这对我们的类施加了一些设计考虑，以提供适当的唯一键。在某些情况下，问题域将具有一个明显的唯一键属性。在这种情况下，我们可以简单地使用该属性来构造这个键：`shelf[object.key_attribute]=
    object`。这是最简单的情况，但不太通用。
- en: In other cases, our application problem doesn't offer us an appropriate unique
    key. This problem arises frequently when every attribute of an object is potentially
    mutable or potentially non-unique. It arises when working with U.S. citizens,
    for example, because social security numbers are not unique; they can be reused
    by the Social Security Administration. Additionally, a person can misreport a
    SSN and the application might need to change it; as it can change, there's a second
    reason it's not acceptable as a primary key.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，我们的应用问题没有提供适当的唯一键。例如，当对象的每个属性都可能是可变的或潜在的非唯一时，就会经常出现这个问题。例如，在处理美国公民时，社会安全号码并不是唯一的；它们可以被社会安全管理局重新使用。此外，一个人可能会错误报告社会安全号码，应用程序可能需要更改它；因为它可以更改，这是它不适合作为主键的第二个原因。
- en: Our application may have non-string values that are candidate or primary keys.
    For example, we might have a `datetime` object, a number, or even a tuple as a
    unique identifier. In all of these cases, we might want to encode the value as
    bytes or a string.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序可能有候选或主键的非字符串值。例如，我们可能有一个`datetime`对象、一个数字，甚至一个元组作为唯一标识符。在所有这些情况下，我们可能希望将值编码为字节或字符串。
- en: In the cases where there is no obvious primary key, we can try to locate a combination
    of values that create a unique **composite key**. This isn't always a terribly
    good idea, because now the key is not atomic, and a change to any of the parts
    of the key creates data update problems.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有明显主键的情况下，我们可以尝试找到一组值的组合，创建一个唯一的**复合键**。这并不总是一个非常好的主意，因为现在键不是原子的，对键的任何部分的更改都会创建数据更新问题。
- en: 'It''s often simplest to follow a design pattern called a **surrogate key**.
    This key doesn''t depend on data within an object; it''s a surrogate for the object.
    This means any of the attributes of the object can be changed without leading
    to complications or restrictions. Python''s internal object IDs are an example
    of a kind of surrogate key. The string representation of a shelf key can follow
    this pattern: `class:oid`.'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循一种称为**代理键**的设计模式通常是最简单的。这个键不依赖于对象内部的数据；它是对象的代理。这意味着对象的任何属性都可以更改而不会导致复杂或限制。Python的内部对象ID就是一种代理键的例子。架子键的字符串表示可以遵循这种模式：`class:oid`。
- en: The key string includes the class of the object paired with the unique identifier
    for an instance of the class. We can easily store diverse classes of objects in
    a single shelf using keys of this form. Even when we think there will be only
    one type of object in the shelf, this format is still helpful to save a namespace
    for indexes, administrative metadata, and future expansion.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 键字符串包括与对象实例的唯一标识符配对的对象类。我们可以使用这种形式的键轻松地将各种类的对象存储在单个架子中。即使我们认为架子中只会有一种类型的对象，这种格式仍然有助于为索引、管理元数据和未来扩展保存命名空间。
- en: 'When we have a suitable natural key, we might do something like this to persist
    objects in the shelf: `self[object.__class__.__name__+":"+object.key_attribute]=
    object`'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个合适的自然键时，我们可以这样做来将对象持久化到架子中：`self[object.__class__.__name__+":"+object.key_attribute]=
    object`
- en: This provides us with a distinct class name along with the unique key value
    as a simple identifier for each object. For surrogate keys, we'll need to define
    some kind of generator for the key.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了一个独特的类名，以及一个简单的标识符作为每个对象的唯一键值。对于代理键，我们需要为键定义某种生成器。
- en: Generating surrogate keys for objects
  id: totrans-444
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为对象生成代理键
- en: We'll generate unique surrogate keys with an integer counter. To be sure that
    we keep this counter properly updated, we will store it in the shelf along with
    the rest of our data. Even though Python has an internal object ID, we should
    not use Python's internal identifier for a surrogate key. Python's internal ID
    numbers have no guarantees of any kind.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用整数计数器生成唯一的代理键。为了确保我们正确更新这个计数器，我们将把它与我们的其他数据一起存储在架子中。尽管Python有一个内部对象ID，但我们不应该使用Python的内部标识符作为代理键。Python的内部ID号没有任何保证。
- en: 'As we''re going to add some administrative objects to our shelf, we must give
    these objects unique keys with a distinctive prefix. We''ll use `_DB`. This will
    be a fake class of the objects in our shelf. The design decisions for these administrative
    objects are similar to the design of the application objects. We need to choose
    the granularity of storage. We have two choices:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将向我们的架子中添加一些管理对象，我们必须给这些对象分配具有独特前缀的唯一键。我们将使用`_DB`。这将是我们架子中对象的一个虚假类。这些管理对象的设计决策与应用程序对象的设计类似。我们需要选择存储的粒度。我们有两种选择：
- en: '**Coarse-Grained**: We can create a single `dict` object with all the administrative
    overheads for surrogate key generations. A single key such as `_DB:max` can identify
    this object. Within this `dict`, we could map class names to maximum identifier
    values used. Every time we create a new object, we assign the ID from this mapping
    and then also replace the mapping in the shelf. We''ll show the coarse-grained
    solution in the next section.'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**粗粒度**：我们可以创建一个带有所有代理键生成的管理开销的单个`dict`对象。一个单一的键，比如`_DB:max`可以标识这个对象。在这个`dict`中，我们可以将类名映射到使用的最大标识符值。每次创建一个新对象，我们都会从这个映射中分配ID，然后在架子中替换映射。我们将在下一节展示粗粒度解决方案。'
- en: '**Fine-Grained**: We can add many items to the database, each of which has
    the maximum key value for a different class of objects. Each of these additional
    key items has the form `_DB:max:class`. The value for each of these keys is just
    an integer, the largest sequential identifier assigned so far for a given class.'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**细粒度**：我们可以向数据库添加许多项目，每个项目都具有不同类的对象的最大键值。这些额外的键项中的每一个都具有形式`_DB:max:class`。每个键的值只是一个整数，迄今为止为给定类分配的最大顺序标识符。'
- en: An important consideration here is that we've separated the key design from
    the class design for our application's classes. We can (and should) design our
    application objects as simply as possible. We should add just enough overhead
    to make `shelve` work properly, but no more.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个重要考虑因素是，我们已经将应用程序类的键设计与类设计分开。我们可以（也应该）尽可能简单地设计我们的应用程序对象。我们应该添加足够的开销，使`shelve`正常工作，但不要过多。
- en: Designing a class with a simple key
  id: totrans-450
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计一个带有简单键的类
- en: It is helpful to store the `shelve` key as an attribute of a shelved object.
    Keeping the key in the object makes the object easier to delete or replace. Clearly,
    when creating an object, we'll start with a keyless version of the object until
    it's stored in the shelf. Once stored, the Python object needs to have a key attribute
    set so that each object in the memory contains a correct key.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 将`shelve`键存储为存储对象的属性是有帮助的。将键保留在对象中使得删除或替换对象更容易。显然，在创建对象时，我们将从不带键的对象开始，直到它存储在架子上。一旦存储，Python对象需要设置一个键属性，以便内存中的每个对象都包含正确的键。
- en: When retrieving objects, there are two use cases. We might want a specific object
    that is known by the key. In this case, the shelf will map the key to the object.
    We might also want a collection of related objects, not known by their keys but
    perhaps known by the values of some other attributes. In this case, we'll discover
    the keys of objects through some kind of search or query. We'll look at the search
    algorithms in the next section.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在检索对象时，有两种用例。我们可能需要一个已知键的特定对象。在这种情况下，架子将键映射到对象。我们可能还需要一组相关对象，不是通过它们的键而是通过其他属性的值来识别。在这种情况下，我们将通过某种搜索或查询来发现对象的键。我们将在下一节中讨论搜索算法。
- en: 'To support saving the shelf keys in objects, we''ll add an `_id` attribute
    to each object. It will keep the shelve key in each object that has been put onto
    the shelf or retrieved from the shelf. This will simplify managing objects that
    need to be replaced in or removed from the shelf. We have the following choices
    for adding this to the class:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '**No**: It''s not essential to the class; it''s just an overhead for the persistence
    mechanism'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Yes**: It''s important data, and we should initialize it properly in `__init__()`'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We suggest not defining surrogate keys in the `__init__()` method; they''re
    not essential, and are just part of a persistence implementation. A surrogate
    key won''t have any method functions, for example, and it is never part of the
    processing layer of the application tier or the presentation tier. Here''s a definition
    for an overall `Blog`:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We've provided just a `title` attribute and a little more. The `Blog.as_dict()`
    method can be used with a template to provide string values in the RST notation.
    We'll leave the consideration of individual posts within the blog for the next
    section.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a `Blog` object in the following manner:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'When we store this simple object in the shelf, we can do things like this:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We started by opening a new shelf. The file was called "`blog`". We put a key,
    '`Blog:1`', into our `Blog` instance, `b1`. We stored that `Blog` instance in
    the shelf using the key given in an `_id` attribute.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: 'We can fetch the item back from the shelf like this:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'When we refer to `shelf[''Blog:1'']`, it will fetch our original `Blog` instance
    from the shelf. We''ve put only one object on the shelf, as we can see from the
    list of keys. Because we closed the shelf, the object is persistent. We can quit
    Python, start back up again, open the shelf, and see that the object remains on
    the shelf, using the assigned key. Previously, we mentioned a second use case
    for retrieval: locating an item without knowing the key. Here''s a search that
    locates all blogs with a given title:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: We opened the shelf to get access to the objects. The `results` generator expression
    examines each item in the shelf to locate those items where the key starts with
    `'Blog:'`, and the object's title attribute is the string `'Travel Blog'`.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: What's important is that the key, `'Blog:1'`, is stored within the object itself.
    The `_id` attribute ensures that we have the proper key for any item that our
    application is working with. We can now mutate the object and replace it in the
    shelf using its original key.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: Designing classes for containers or collections
  id: totrans-470
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we have more complex containers or collections, we have more complex design
    decisions to make. The first question is about the scope of the containment. We
    must decide on the **granularity** of our shelved objects.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: When we have a container, we can persist the entire container as a single, complex
    object on our shelf. To an extent, this might defeat the purpose of having multiple
    objects on a shelf in the first place. Storing one large container gives us coarse-grained
    storage. If we change one contained object, the entire container must be serialized
    and stored. If we wind up effectively pickling the entire universe of objects
    in a single container, why use `shelve`? We must strike a balance that is appropriate
    to the application's requirements.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: The alternative is to decompose the collection into separate, individual items.
    In this case, our top-level `Blog` object won't be a proper Python container anymore.
    The parent might refer to each child with a collection of keys. Each child object
    could refer to the parent by the key. This use of keys is unusual in object-oriented
    design. Normally, objects simply contain references to other objects. When using
    `shelve` (or other databases), we must use indirect references by the key.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: 'Each child will now have two keys: its own primary key, plus a **foreign key**
    that is the primary key of the parent object. This leads to a second design question
    about representing the key strings for the parents and their children.'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: Referring to objects via foreign keys
  id: totrans-475
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The key that we use to uniquely identify an object is its **primary key**.
    When child objects refer to a parent object, we have additional design decisions
    to make. How do we structure the children''s primary keys? There are two common
    design strategies for child keys, based on the kind of dependence that exists
    between the classes of objects:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '`"Child:cid"`: We''ll use this when we have children that can exist independently
    of an owning parent. For example, an item on an invoice refers to a product; the
    product can exist even if there''s no invoice item for the product.'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"Parent:pid:Child:cid"`: We''ll use this when the child cannot exist without
    a parent. A customer address doesn''t exist without a customer to contain the
    address in the first place. When the children are entirely dependent on the parent,
    the child''s key can contain the owning parent''s ID to reflect this dependency.'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As with the parent class design, it''s easiest if we keep the primary key and
    all foreign keys associated with each child object. We suggest not initializing
    them in the `__init__()` method, as they''re just features of persistence. Here''s
    the general definition for `Post` within `Blog`:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We''ve provided several attributes for each microblog post. The `Post.as_dict()`
    method can be used with a template to provide string values in the RST notation.
    We''ve avoided mentioning the primary key or any foreign keys for `Post`. Here
    are two examples of the `Post` instances:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We can now associate these with their owning blog, both by setting attributes
    and by assigning keys that will define the relationships. We''ll do this through
    several steps:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll open the shelf and retrieve a parent `Blog` object. We''ll call it `owner`:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: We've used the primary key to locate the owner item. An actual application might
    have used a search to locate this item by title. We might also have created an
    index to optimize the search. We'll look at the index and search below.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can assign this owner''s key to each `Post` object and persist the
    objects:'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We put the parent information into each `Post`. We used the parent information
    to build the primary key. For this dependent kind of key, the `_parent` attribute
    value is redundant; it can be deduced from the key. If we used an independent
    key design for `Posts`, however, `_parent` would not be duplicated in the key.
    When we look at the keys, we can see the `Blog` plus both `Post` instances:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'When we fetch any child `Post`, we''ll know the proper parent `Blog` for the
    individual posting:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Following the keys the other way—from parent `Blog` down to child `Post`—is
    a bit more complex. We'll address this separately because we often want to optimize
    the path from parent to children with an index.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: Designing CRUD operations for complex objects
  id: totrans-494
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we decompose a larger collection into a number of separate fine-grained
    objects, we will have multiple classes of objects on the shelf. Because they are
    independent objects, they will lead to separate sets of CRUD operations for each
    class. In some cases, the objects are independent, and operations on an object
    of one class have no impact outside that individual object.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, however, the `Blog` and `Post` objects have a dependency relationship.
    The `Post` objects are children of a parent `Blog`; the child can''t exist without
    the parent. When we have these dependent relationships, we have a more entangled
    collection of operations to design. Here are some of the considerations:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: 'CRUD operations on independent (or parent) objects:'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We may create a new, empty parent, assigning a new primary key to this object.
    We can later assign children to this parent. Code such as `shelf['parent:'+object._id]=
    object` will create parent objects.
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We may update or retrieve this parent without any effect on the children. We
    can perform `shelf['parent:'+some_id]` on the right-hand side of the assignment
    to retrieve a parent. Once we have the object, we can perform `shelf['parent:'+object._id]=
    object` to persist a change.
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting the parent can lead to one of two behaviors. One choice is to cascade
    the deletion to include all the children that refer to the parent. Alternatively,
    we may write code to prohibit the deletion of parents that still have child references.
    Both are sensible, and the choice is driven by the requirements imposed by the
    problem domain.
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CRUD operations on dependent (or child) objects:'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can create a new child that refers to an existing parent. We must tackle
    the key design issue to decide what kind of keys we want to use for children.
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can update, retrieve, or delete the child outside the parent. This can even
    include assigning the child to a different parent.
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the code to replace an object is the same as the code to update an object,
    half of the CRUD processing is handled through the simple assignment statement.
    Deletion is done with the `del` statement. The issue of deleting children associated
    with a parent might involve a retrieval to locate the children. What's left, then,
    is an examination of retrieve processing, which can be a bit more complex.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: Searching, scanning, and querying
  id: totrans-505
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Don''t panic; these are all just synonyms. We''ll use the words interchangeably*.'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: We have two design choices when looking at database searches. We can either
    return a sequence of keys or we can return a sequence of objects. As our design
    emphasizes storing the keys in each object, getting a sequence of objects from
    the database is sufficient, so we'll focus on that kind of design.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: A search is inherently inefficient. We'd prefer to have more focused indices.
    We'll look at how we can create more useful indices in the following section.
    The fallback plan of brute-force scans, however, always works.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: 'When a child class has an independent-style key, we can easily scan a shelf
    for all instances of some `Child` class using a simple iterator over the keys.
    Here''s a generator expression that locates all the children:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This looks at every single key in the shelf to pick the subset that begins
    with `"Child:"`. We can build on this to apply more criteria by using a more complex
    generator expression:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We've used a nested generator expression to expand on the initial `children`
    query, adding criteria. Nested generator expressions like this are remarkably
    efficient in Python. This does not make two scans of the database. It's a single
    scan with two conditions. Each result from the inner generator feeds the outer
    generator to build the result.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: 'When a child class has a dependent-style key, we can search the shelf for children
    of a specific parent using an iterator with a more complex matching rule. Here''s
    a generator expression that locates all children of a given parent:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This dependent-style key structure makes it particularly easy to remove a parent
    and all children in a simple loop:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'When using hierarchical "`Parent:` *pid* `:Child:` *cid*" keys, we do have
    to be careful when separating parents from their children. With this multi-part
    key, we''ll see lots of object keys that start with "Parent:*pid*". One of these
    keys will be the proper parent, simply "`Parent:` *pid*". The other keys will
    be children with "`Parent:` *pid* `:Child:` *cid*". We have three kinds of conditions
    that we''ll often use for these brute-force searches:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: '`key.startswith("Parent:pid")` finds a union of parents and children; this
    isn''t a common requirement.'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`key.startswith("Parent:pid:Child:")` finds just children of the given parent.
    We might use a regular expression such as `r"^(Parent:\d+):(Child:\d+)$"` to match
    the keys.'
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`key.startswith("Parent:pid")` and `":Child:"` key finds just parents, excluding
    children. We might use a regular expression such as `r"^Parent:\d+$"` to match
    the keys.'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these queries can be optimized by building indices.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: Designing an access layer for shelve
  id: totrans-523
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s how `shelve` might be used by an application. We''ll look at parts
    of an application that edits and saves microblog posts. We''ll break the application
    into two tiers: the application tier and the data tier. Within an application
    tier, we''ll distinguish between two layers:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: '**Application processing**: These objects are not persistent. These classes
    will embody the behavior of the application as a whole. These classes respond
    to the user selection of commands, menu items, buttons, and other processing elements.'
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Problem domain data model**: These are the objects that will get written
    to a shelf. These objects embody the state of the application as a whole.'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The definitions of blog and post shown previously have no formal association
    between blog and its collection of posts. The classes are independent so that
    we can process them separately on the shelf. We don't want to create a single,
    large container object by turning `Blog` into a collection class.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the data tier, there might be a number of features, depending on the
    complexity of the data storage. We''ll focus on just two features:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: '**Access**: These components provide uniform access to the problem domain objects.
    We''ll define an `Access` class that provides access to the `Blog` and `Post`
    instances. It will also manage the keys to locate `Blog` and `Post` objects in
    the shelf.'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Persistence**: The components serialize and write problem domain objects
    to persistent storage. This is the `shelve` module.'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ll break the `Access` class into three separate pieces. Here''s the first
    part with various parts of file open and close:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: For `Access.new()`, we'll create a new, empty shelf. For `Access.open()`, we'll
    open an existing shelf. For closing and synchronizing, we've made sure to post
    a small dictionary of the current maximum key values into the shelf.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: 'We haven''t addressed things such as implementing a `Save As...` method to
    make a copy of the file. Nor have we addressed a quit-without-saving option to
    revert to the previous version of a database file. These additional features involve
    the use of the `os` module to manage the file copies. We''ve provided you with
    both `close()` and `quit()` methods. This can make it slightly simpler to design
    a GUI application. Here are the various methods to update the shelf with `Blog`
    and `Post` objects:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: We've provided a minimal set of methods to put `Blog` in the shelf with its
    associated `Post` instances. When we add `Blog`, the `add_blog()` method first
    computes a new key, then updates the `Blog` object with the key, and finally,
    it persists the `Blog` object in the shelf. We've highlighted the lines that change
    the shelf contents. Simply setting an item in the shelf, similar to setting an
    item in a dictionary, will make the object persistent.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: When we add a post, we must provide the parent `Blog` so that the two are properly
    associated on the shelf. In this case, we get the `Blog` key, create a new `Post`
    key, and then update the `Post` with the key values. This updated `Post` can be
    persisted on the shelf. The highlighted line in `add_post()` makes the object
    persistent in the shelf.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: In the unlikely event that we try to add a `Post` without having previously
    added the parent `Blog`, we'll have attribute errors because the `Blog._id` attribute
    will not be available.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve provided representative methods to replace `Post` and delete `Post`.
    There are several other possible operations; we didn''t include methods to replace
    `Blog` or delete `Blog`. When we write the method to delete `Blog`, we have to
    address the question of preventing the deletion when there are still `Posts` or
    cascading the deletion to include `Posts`. Finally, there are some search methods
    that act as iterators to query `Blog` and `Post` instances:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: We've defined the default iterator, `__iter__()`, that filters out the internal
    objects that have keys beginning with `_`. So far, we've only defined one such
    key, `_DB:max`, but this design leaves us with room to invent others.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: The `blog_iter()` method iterates through the `Blog` entries. As both `Blog`
    and `Post` entries have keys that begin with `"Blog:"`, we must explicitly discard
    the `Post` entries that are children of `Blog`. A purpose-built index object is
    often a better approach. We'll look at that in the following section.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: The `post_iter()` method iterates through posts that are a part of a specific
    blog. The `title_iter()` method examines posts that match a particular title.
    This examines each key in the shelf—a potentially inefficient operation.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: We've also defined an iterator that locates posts that have the requested title
    in a given blog. This is a simple generator function that uses the `post_iter()`
    method function and returns only matching titles.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: Writing a demonstration script
  id: totrans-545
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ll use a technology spike to show you how an application might use this
    `Access` class to process the microblog objects. The spike script will save some
    `Blog` and `Post` objects to a database to show a sequence of operations that
    an application might use. This demonstration script can be expanded into unit
    test cases. More complete unit tests would show us that all the features are present
    and work correctly. This small spike script shows us how `Access` works:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: We've created the `Access` class on the access layer so that it's wrapped in
    a context manager. The objective is to be sure that the access layer is closed
    properly, irrespective of any exceptions that might get raised.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: With `Access.new()`, we've created a new shelf named `'blog'`. This might be
    done by a GUI by navigating to **File** **|** **New**. We added the new blog,
    `b1`, to the shelf. The `Access.add_blog()` method will update the `Blog` object
    with its shelf key. Perhaps someone filled in the blanks on a page and clicked
    on **New Blog** on their GUI application.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: Once we've added `Blog`, we can add two posts to it. The key from the parent
    `Blog` entry will be used to build the keys for each of the child `Post` entries.
    Again, the idea is that a user filled in some fields and clicked on **New Post**
    on a GUI.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: There's a final set of queries that dumps the keys and objects from the shelf.
    This shows us the final outcome of this script. We can perform `Access.get_blog()`
    to retrieve a blog entry that was created. We can iterate through the posts that
    are part of that blog using `Access.post_iter()`. The final `Access.quit()` assures
    that the maxima used to generate unique keys are recorded and the shelf is closed
    properly.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: Creating indexes to improve efficiency
  id: totrans-552
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the rules of efficiency is to avoid search. Our previous example of using
    an iterator over the keys in a shelf is inefficient. To state that more strongly,
    search *defines* inefficiency. We'll emphasize this.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-554
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Brute-force search is perhaps the worst possible way to work with data. We must
    always design indexes that are based on subsets or mappings to improve performance.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: To avoid searching, we need to create indexes that list the items we want. This
    saves reading through the entire shelf to find an item or subset of items. A shelf
    index can't reference Python objects, as that would change the granularity at
    which the objects are stored. A shelf index must only list key values. This makes
    navigation among objects indirect but still much faster than a brute-force search
    of all items in the shelf.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example of an index, we can keep a list of the `Post` keys associated
    with each `Blog` in the shelf. We can easily change the `add_blog()`, `add_post()`,
    and `delete_post()` methods to update the associated `Blog` entry too. Here are
    the revised versions of these blog update methods:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The `add_blog()` method ensures that each `Blog` has an extra attribute, `_post_list`.
    This will be updated by other methods to maintain a list of keys for each `Post`
    that belongs to `Blog`. Note that we're not adding `Posts` themselves. If we do
    this, we collapse an entire `Blog` into a single entry into the shelf. By adding
    just the key information, we keep the `Blog` and `Post` objects separated.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: The `add_post()` method adds `Post` to the shelf. It also appends `Post._id`
    to a list of keys maintained at the `Blog` level. This means any `Blog` object
    will have `_post_list` that provides a sequence of keys for the child posts.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: This method makes two updates to the shelf. The first is simply saving the `Post`
    object. The second update is important. We do not attempt to simply mutate the
    `Blog` object that exists in the shelf. We intentionally store the object to the
    shelf to be sure that the object is persisted in its updated form.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the `delete_post()` method keeps the index up-to-date by removing
    an unused post from `_post_list` of the owning blog. As with `add_post()`, two
    updates are done to the shelf: a `del` statement removes `Post` and then the `Blog`
    object is updated to reflect the change in the index.'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: 'This change alters our queries for the `Post` objects in profound ways. Here
    is the revised version of the search methods:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'We''re able to replace the scan in `post_iter()` with a much more efficient
    operation. This loop will rapidly yield the `Post` objects based on the keys saved
    in the `_post_list` attribute of `Blog`. We could consider replacing this `for`
    statement with a generator expression:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The point of this optimization to the `post_iter()` method is to eliminate
    the search of *all* the keys for the matching keys. We''ve replaced searching
    all keys with simple iteration over an appropriate sequence of relevant keys.
    A simple timing test, which alternates between updating `Blog` and `Post` and
    rendering the `Blog` to RST, shows us the following results:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: As expected, eliminating the search reduced the time required to process `Blog`
    and its individual `Posts`. The change is profound; almost 25 percent of the processing
    time is wasted in the search.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: Creating top-level indices
  id: totrans-570
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We added an index to each `Blog` that locates `Posts` which belong to that
    `Blog`. We can also add a top-level index to the shelf that locates all `Blog`
    instances. The essential design is similar to what''s been shown previously. For
    each blog to be added or deleted, we must update an index structure. We must also
    update the iterators to properly use the index. Here''s another class design for
    mediating the access to our objects:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: When creating a new database, we add an administrative object and an index,
    with a key of `"_DB:Blog"`. This index will be a list where we'll store the keys
    to each `Blog` entry. When we add a new `Blog` object, we also update this `"_DB:Blog"`
    object with the revised list of keys. We didn't show the delete implementation.
    It should be self-evident.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: 'When we iterate through `Blog` postings, we use the index list instead of a
    brute-force search of keys in the database. Here are the performance results:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: We can conclude from this that *most* of the processing time is wasted in a
    brute-force search of keys in the database. This should reinforce the notion that
    everything we can possibly do to avoid the search will dramatically improve the
    performance of our programs.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: Adding yet more index maintenance
  id: totrans-577
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Clearly, the index maintenance aspect of a shelf can grow. With our simple
    data model, we could easily add more top-level indexes for tags, dates, and titles
    of `Posts`. Here''s another access layer implementation that defines two indices
    for `Blogs`. One index simply lists the keys for `Blog` entries. The other index
    provides keys based on the `Blog` title. We''ll assume the titles are not unique.
    We''ll present this access layer in three parts. Here''s the *Create* part of
    the CRUD processing:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'We''ve added two indices: a simple list of the `Blog` keys plus `defaultdict`
    that provides us with a list of keys for a given title string. If each title is
    unique, the lists will all be singletons. If the titles are not unique, then each
    title will have a list of the `Blog` keys.'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: 'When we add a `Blog` instance, we also update the two indices. The simple list
    of keys is updated by appending the new key and saving it to the shelf. The title
    index requires us to get the existing `defaultdict` from the shelf, append to
    the list of keys mapped to the `Blog''s` title, and then put the `defaultdict`
    back onto the shelf. The next section shows us the *Update* part of the CRUD processing:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: When we update a `Blog` object, we might be changing the title of the `Blog`
    attribute. If our model had more attributes and more indices, we might want to
    compare the revised value with the value in the shelf to see which attributes
    changed. For this simple model—with only one attribute—no comparison is required
    to determine which attributes have changed.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: The first part of the operation is to remove the key of the `Blog` from the
    index. As we haven't cached the previous value of the `Blog.title` attribute,
    we can't simply remove the key based on the old title. Instead, we're forced to
    search the index for the key of `Blog` and remove the key from whatever title
    it's associated with.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-585
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Blog` with a unique title will leave the title''s list of keys empty. We should
    clean up an unused title too.'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the key associated with the old title has been removed from the index,
    we can append the key to the index using the new title. These final two lines
    are identical to the code used when creating `Blog` in the first place. Here are
    some retrieve processing examples:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The `blog_iter()` method function iterates through all the blogs by fetching
    the index object from the shelf. The `blog_title_iter()` method function uses
    the index to fetch all the blogs with a given title. When there are many individual
    blogs, this should find a blog by title very quickly.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: The writeback alternative to index updates
  id: totrans-590
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can request that a shelf be opened with `writeback=True`. This will track
    changes to mutable objects by keeping a cached version of each object. Rather
    than burdening the `shelve` module with tracking all accessed objects to detect
    and preserve changes, the designs shown here will update a mutable object and
    specifically force the shelf to update the persistent version of the object.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: This is a small shift in the runtime performance. An `add_post()` operation,
    for example, becomes slightly more costly because it also involves updating a
    `Blog` entry. If multiple `Posts` are added, these additional `Blog` updates become
    a kind of an overhead. However, this cost may be balanced by the improved performance
    of rendering `Blog` by avoiding a lengthy search of the shelf keys to track down
    the posts for a given blog. The designs shown here avoid creating a `writeback`
    cache that could grow unbounded during the running of an application.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: Schema evolution
  id: totrans-593
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working with `shelve`, we have to address the problem of schema evolution.
    Our objects have a dynamic state and a static class definition. We can easily
    persist the dynamic state. Our class definitions are the schema for the persistent
    data. The class, however, is not *absolutely* static. If we change a class definition,
    how will we fetch objects from the shelf? A good design often involves some combination
    of the following techniques.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: Changes to method functions and properties don't change the persisted object
    state. We can classify these as minor changes, as the shelved data is still compatible
    with the changed class definition. A new software release can have a new minor
    version number and users should be confident that it will work without problems.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: Changes to attributes will change the persisted objects. We can call these major
    changes, and the shelved data will no longer be compatible with the new class
    definition. These kinds of changes should not be made by *modifying* a class definition.
    These kinds of changes should be made by defining a new subclass and providing
    an updated factory function to create instances of any version of the class.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: 'We can be flexible about supporting multiple versions, or we can use one-time
    conversions. To be flexible, we must rely on factory functions to create instances
    of objects. A flexible application will avoid creating objects directly. By using
    a factory function, we''re assured that all parts of an application can work consistently.
    We might do something like this to support flexible schema changes:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'This kind of factory function requires a `_version` keyword argument to specify
    which `Blog` class definition to use. This allows us to upgrade a schema to use
    different classes without breaking our application. The `Access` layer can rely
    on this kind of function to instantiate correct versions of objects. We can also
    make a fluent factory that looks like this:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'We can use this factory as follows:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: A shelf should include the schema version information, perhaps as a special
    `__version__` key. This will provide information for an access layer to determine
    what version of a class should be used. Applications should fetch this object
    first after opening the shelf and fail quickly when the schema version is wrong.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to this level of flexibility is a one-time conversion. This feature
    of the application will fetch all shelved objects using their old class definition,
    convert to the new class definition, and store them back to the shelf in the new
    format. For a GUI application, this may be part of an open file or a saved file.
    For a web server, this may be a script that is run by an administrator as part
    of an application release.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-605
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've seen the basics of how to use the `shelve` module. This includes creating
    a shelf and designing keys to access the objects we've placed in the shelf. We've
    also seen the need for an access layer to perform the lower-level CRUD operations
    on the shelf. The idea is that we need to distinguish between the class definitions
    that are focused on our application and other administrative details that support
    persistence.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: Design considerations and trade-offs
  id: totrans-607
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the strengths of the `shelve` module is allowing us to persist distinct
    items. This imposes a design burden to identify the proper granularity of the
    items. Too fine a granularity and we waste time assembling containers from their
    pieces. Too coarse a granularity and we waste time fetching and storing items
    that aren't relevant.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: Since a shelf requires a key, we must design appropriate keys for our objects.
    We must also manage the keys for our various objects. This means using additional
    attributes to store keys and possibly creating additional collections of keys
    to act as indices for items on the shelf.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: A key used to access an item in a `shelve` database is like a `weakref`; it's
    an indirect reference. This means that extra processing is required to track and
    access the items from the reference. For more information on `weakref`, see [Chapter
    2](ch02.html "Chapter 2. Integrating Seamlessly with Python Basic Special Methods"),
    *Integrating Seamlessly with Python – Basic Special Methods*.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: One choice for a key is to locate an attribute or combination of attributes
    that are proper primary keys and cannot be changed. Another choice is to generate
    surrogate keys that cannot be changed; this allows all other attributes to be
    changed. As `shelve` relies on `pickle` to represent the items on the shelf, we
    have a high-performance native representation of the Python objects. This reduces
    the complexity of designing classes that will be placed onto a shelf. Any Python
    object can be persisted.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: Application software layers
  id: totrans-612
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because of the relative sophistication available when using `shelve`, our application
    software must become more properly layered. Generally, we''ll look at software
    architectures with layers such as the following:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: '**Presentation layer**: The top-level user interface, either a web presentation
    or a desktop GUI.'
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application layer**: The internal services or controllers that make the application
    work. This could be called the processing model, different from the logical data
    model.'
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Business layer or** **problem domain model layer**: The objects that define
    the business domain or problem space. This is sometimes called the logical data
    model. We''ve looked at how we might model these objects, using a microblog `Blog`
    and `Post` example.'
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Infrastructure**: It often includes several layers as well as other cross-cutting
    concerns such as logging, security, and network access.'
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data access layer**. These are protocols or methods to access data objects.
    We''ve looked at designing classes to access our application objects from the
    `shelve` storage.'
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Persistence layer**. This is the physical data model as seen in file storage.
    The `shelve` module implements persistence.'
  id: totrans-619
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When looking at this chapter and [Chapter 11](ch11.html "Chapter 11. Storing
    and Retrieving Objects via SQLite"), *Storing and Retrieving Objects via SQLite*,
    it becomes clear that mastering object-oriented programming involves some higher-level
    design patterns. We can't simply design classes in isolation, but we need to look
    at how classes are going to be organized into larger structures. Finally, and
    most importantly, brute-force search is a terrible thing. It simply must be avoided.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: Looking forward
  id: totrans-621
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next chapter will roughly parallel this chapter. We'll look at using SQLite
    instead of shelve for the persistence of our objects. The complexity is that a
    SQL database doesn't provide a way to store complex Python objects, leading to
    the impedance mismatch problem. We'll look at two ways to solve this problem when
    using a relational database such as SQLite.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 12](ch12.html "Chapter 12. Transmitting and Sharing Objects"), *Transmitting
    and Sharing Objects*, will shift the focus from simple persistence to transmitting
    and sharing objects. This will rely on the persistence we''ve seen in this part;
    it will add network protocols to the mix.'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11. Storing and Retrieving Objects via SQLite
  id: totrans-624
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many applications where we need to persist objects individually. The
    techniques we looked at in [Chapter 9](ch09.html "Chapter 9. Serializing and Saving
    – JSON, YAML, Pickle, CSV, and XML"), *Serializing and Saving - JSON, YAML, Pickle,
    CSV, and XML*, were biased towards handling a single, monolithic object. Sometimes,
    we need to persist separate, individual objects from a larger domain. We might
    be saving blog entries, blog posts, authors, and advertising in a single file
    structure.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 10](ch10.html "Chapter 10. Storing and Retrieving Objects via Shelve"),
    *Storing and Retrieving Objects via Shelve*, we looked at storing distinct Python
    objects in a `shelve` data store. This allowed us to implement the CRUD processing
    on a large domain of objects. Any individual object can be created, retrieved,
    updated, or deleted without having to load and dump the entire file.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll look at mapping Python objects to a relational database;
    specifically, the `sqlite3` database that is bundled with Python. This will be
    another example of the **Three-Tier Architecture** design pattern**.**
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the SQLite data tier is a more sophisticated database than Shelve.
    SQLite can allow concurrent updates via locking. SQLite offers an access layer
    based on the SQL language. It offers persistence by saving SQL tables to the filesystem.
    Web applications are one example where a database is used instead of simple file
    persistence to handle concurrent updates to a single pool of data. RESTful data
    servers, too, frequently use a relational database to provide access to persistent
    objects.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: For scalability, a standalone database server process can be used to isolate
    all the database transactions. This means that they can be allocated to one relatively
    secure host computer, separate from the Web application servers and behind appropriate
    firewalls. MySQL, for example, can be implemented as a standalone server process.
    SQLite is not a standalone database server; it must exist as part of a host application;
    for our purposes, Python is the host.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: SQL databases, persistence, and objects
  id: totrans-630
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When using SQLite, we will use a relational database with an access layer based
    on the SQL language. The SQL language is a legacy from an era when object-oriented
    programming was a rarity. The SQL language is heavily biased towards procedural
    programming, creating what''s termed an impedance mismatch between the relational
    model of data and the object model of data. Within SQL databases, we generally
    focus on three tiers of data modeling, which are shown here:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: '**Conceptual model**: These are the entities and relationships implied by the
    SQL model. In most cases, these can map to Python objects and should correspond
    with the data model layer of the application tier. This is the place where an
    **Object-Relational Mapping** layer is useful.'
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logical model**: These are the tables, rows, and columns that appear to be
    in the SQL database. We''ll address these entities in our SQL data manipulation
    statements. We say that these appear to exist because they''re implemented by
    a physical model that may be somewhat different from the tables, rows, and columns
    in the database schema. The results of a SQL query, for example, look table-like,
    but may not involve storage that parallels the storage of any defined table.'
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Physical model**: These are the files, blocks, pages, bits, and bytes of
    persistent physical storage. These entities are defined by the administrative
    SQL statements. In some more complex database products, we can exercise some control
    over the physical model of the data to further tweak the performance. In SQLite,
    however, we have almost no control over this.'
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are confronted with a number of design decisions when using SQL databases.
    Perhaps the most important one is deciding how to cover the impedance mismatch.
    How do we handle the mapping between SQL''s legacy data model to a Python object
    model? There are three common strategies:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: '**No mapping to Python**: This means that we don''t fetch complex Python objects
    from the database but work entirely within the SQL framework of independent atomic
    data elements and processing functions. This approach will avoid a deep emphasis
    on object-oriented programming with persistent database objects. This limits us
    to the four essential SQLite types of NULL, INTEGER, REAL, and TEXT, plus the
    Python additions of `datetime.date` and `datetime.datetime`.'
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Manual mapping**: We define an access layer to map between our class definitions
    and the SQL logical model of tables, columns, rows, and keys.'
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ORM layer**: We download and install an ORM layer to handle the mapping between
    classes and the SQL logical model.'
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll look at all the three choices in the following examples. Before we can
    look at the mappings from SQL to objects, we'll look at the SQL logical model
    in some detail and cover the no-mapping option in the process.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: The SQL data model – rows and tables
  id: totrans-640
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SQL data model is based on named tables with named columns. The table contains
    multiple rows of data. Each row is vaguely like a mutable `namedtuple`. The overall
    table is like `list`.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: When we define a SQL database, we define the tables and their columns. When
    we use a SQL database, we manipulate the rows of data in the tables. In the case
    of SQLite, we have a narrow domain of data types that SQL will process. SQLite
    handles `NULL`, `INTEGER`, `REAL`, `TEXT`, and `BLOB` data. Python types `None`,
    `int`, `float`, `str`, and `bytes` are mapped to these SQL types. Similarly, when
    data of these types is fetched from a SQLite database, the items are converted
    into Python objects.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: We can mediate this conversion by adding even more conversion functions to SQLite.
    The `sqlite3` module adds the `datetime.date` and `datetime.datetime` extensions
    this way. We'll address this under manual mapping, which follows in the next section.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQL language can be partitioned into three sublanguages: a **data definition
    language** (**DDL**), a **data manipulation language** (**DML**), and a **data
    control language** (**DCL**). The DDL is used to define tables, their columns,
    and indices. For an example of DDL, we might have some tables defined the following
    way:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'We''ve created four tables to represent the `Blog` and `Post` objects for a
    microblogging application. For more information on the SQL language processed
    by SQLite, see [http://www.sqlite.org/lang.html](http://www.sqlite.org/lang.html).
    For a broader background in SQL, books such as *Creating your MySQL Database:
    Practical Design Tips and Techniques* will introduce the SQL language in the context
    of the MySQL database. The SQL language is case insensitive. For no good reason,
    we prefer to see SQL in all uppercase to distinguish it from the surrounding Python
    code.'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: The `BLOG` table defines a primary key with the `AUTOINCREMENT` option; this
    will allow SQLite to assign the key values, saving us from having to generate
    the keys in our code. The `TITLE` column is the title for a blog. We've defined
    it to be `TEXT`. In some database products, we must provide a maximum size; this
    is not required in SQLite, so we'll avoid the clutter.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: The `POST` table defines a primary key as well as date, title, and RST text
    for the body of the post. Note that we did not reference the tags in this table
    definition. We'll return to the design patterns required for the following SQL
    tables. The `POST` table does, however, include a formal `REFERENCES` clause to
    show us that this is a foreign key reference to the owning `BLOG`. The `TAG` table
    defines the individual tag text items, and nothing more.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have an association table between `POST` and `TAG`. This table
    has only two foreign keys. It associates tags and posts, allowing an unlimited
    number of tags per post as well as an unlimited number of posts to share a common
    tag. This association table is a common SQL design pattern to handle this kind
    of a relationship. We''ll look at some other SQL design patterns in the following
    section. We can execute the preceding definitions to create our database:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: All database access requires a connection, created with the module function,
    `sqlite3.connect()`. We provided the name of the file to assign to our database.
    We'll look at the additional parameters for this function in separate sections.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: The DB-API presumes that there is a separate database server process on which
    our application process is connecting. In the case of SQLite, there isn't really
    a separate process. A `connect()` function is used, however, to comply with the
    standard.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: The `sql_ddl` variable is simply a long string variable with the four `CREATE
    TABLE` statements. If there are no error messages, then it means that the table
    structures have been defined.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Connection.executescript()` method is described in the Python Standard
    Library as a *nonstandard shortcut*. Technically, database operations involve
    `cursor`. The following is a standardized approach:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: As we're focused on SQLite, we'll use the nonstandard shortcuts heavily. If
    we were concerned about portability to other databases, we'd shift focus to a
    more strict compliance with DB-API. We'll return to the nature of a cursor object
    in the following section, when looking at queries.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: CRUD processing via SQL DML statements
  id: totrans-657
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following four canonical CRUD operations map directly to SQL language statements:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: The creation is done via the `INSERT` statement
  id: totrans-659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Retrieval is done via the `SELECT` statement
  id: totrans-660
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Updates is done via the `UPDATE` statement as well as the `REPLACE` statement,
    when it's supported
  id: totrans-661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The deletion is done via the `DELETE` statement
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have to note that there's a literal SQL syntax, and syntax with binding variable
    placeholders instead of literal values. The literal SQL syntax is acceptable for
    scripts; however, because the values are always literal, it is perfectly awful
    for application programming. Building literal SQL statements in an application
    involves endless string manipulation and famous security problems. See [http://xkcd.com/327/](http://xkcd.com/327/)
    for a specific security issue with assembling literal SQL. We'll focus exclusively
    on SQL with binding variables.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: Literal SQL is widely used, which is a mistake.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-665
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Never build literal SQL DML statements with string manipulation.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: The Python DB-API interface, **Python Enhancement Proposal** (**PEP**) 249,
    [http://www.python.org/dev/peps/pep-0249/](http://www.python.org/dev/peps/pep-0249/),
    defines several ways to bind application variables into SQL statements. SQLite
    can use positional bindings with `?` or named bindings with `:name`. We'll show
    you both styles of binding variables.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: 'We use an `INSERT` statement to create a new `BLOG` row as shown in the following
    code snippet:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: We created a SQL statement with a positional bind variable, `?`, for the `TITLE`
    column of the `BLOG` table. We then execute that statement after binding a tuple
    of values to the bind variables. There's only one bind variable, so there's only
    one value in the tuple. Once the statement has been executed, we have a row in
    the database.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: We show the SQL statements clearly separated from the surrounding Python code
    in triple-quoted long string literals. In some applications, the SQL is stored
    as a separate configuration item. Keeping SQL separate is best handled as a mapping
    from a statement name to the SQL text. We could, for example, keep the SQL in
    a JSON file. This means we can use `SQL=json.load("sql_config.json")` to fetch
    all SQL statements. We can then use `SQL["some statement name"]` to refer to the
    text of a particular SQL statement. This can simplify application maintenance
    by keeping the SQL out of the Python programming.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: 'The `DELETE` and `UPDATE` statements require a `WHERE` clause to specify which
    rows will be changed or removed. To change a blog''s title, we might do something
    as follows:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The `UPDATE` statement has two named bind variables: `:new_title` and `:old_title`.
    This transaction will update all the rows in the `BLOG` table that have the given
    old title, setting the title to the new title. Ideally, the title is unique, and
    only a single row is touched. SQL operations are defined to work on sets of rows.
    It''s a matter of database design to ensure that a desired row is the content
    of a set. Hence, the suggestion is to have a unique primary key for every table.'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: 'When implementing a delete operation, we always have two choices. We can either
    prohibit deletes of a parent when children still exist, or we can cascade the
    deletion of a parent to also delete the relevant children. We''ll look at a cascading
    delete of `Blog`, `Post`, and tag associations. Here''s a `DELETE` sequence of
    statements:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: We've done a three-step delete operation. First, we deleted all the rows from
    `ASSOC_POST_TAG` for a given `Blog` based on the title. Note the nested query;
    we'll look at queries in the next section. Navigation among tables is a common
    issue with SQL construction. In this case, we have to query the `BLOG-POST` relationship
    to locate the `POST` IDs that will be removed; then, we can remove rows from `ASSOC_POST_TAG`
    for the posts associated with a blog that will be removed. Next, we deleted all
    the posts belonging to a particular blog. This too involves a nested query to
    locate the IDs of the blog based on the title. Finally, we can delete the blog
    itself.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: This is an example of an explicit cascade delete design, where we have to cascade
    the operation from the `BLOG` table to two other tables. We wrapped the entire
    suite of deletes in a `with` context so that it would all commit as a single transaction.
    In the event of failure, it would roll back the partial changes, leaving the database
    as it was.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: Querying rows with the SQL SELECT statement
  id: totrans-679
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's possible to write a substantial book on the `SELECT` statement alone. We'll
    skip all but the most fundamental features of `SELECT`. Our purpose is to cover
    just enough SQL to store and retrieve objects from a database.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: Previously, we mentioned that, technically, we're supposed to use a cursor when
    executing SQL statements. For DDL and other DML statements, the presence or absence
    of a cursor doesn't matter very much. We'll use the explicit creation of the cursor
    because it greatly simplifies SQL programming.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: 'For a query, however, the cursor is essential for retrieving the rows from
    the database. To locate a blog by title, we can start with something as simple
    as the following code:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: We need to fetch the resulting collection of row objects. Even when we're expecting
    one row as a response, in the SQL world, everything is a collection. Generally,
    every result set from a `SELECT` query looks like a table with rows and columns
    defined by the `SELECT` statement instead of any `CREATE TABLE` DDL.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, using `SELECT *` means we''ve avoided enumerating the expected
    result columns. This might lead to a large number of columns being retrieved.
    Here''s a common optimization for doing this using the SQLite shortcuts:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: In the `SELECT` statement, the `*` is shorthand for all the available columns.
    It's only really useful for simple queries that involve a single table.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: We've bound the requested blog title to the "`?`" parameter in the `SELECT`
    statement. The result of the `execute()` function is a cursor object. A cursor
    is iterable; it will yield all the rows in the result set and all the rows that
    match the selection criteria in the `WHERE` clause.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: 'To be fully compliant with the Python DB-API standard, we could break it down
    into the following steps:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: This shows us how we use the connection to create a cursor object. We can then
    execute a query statement using the cursor object. Once we've executed the query,
    we can fetch all the rows in the result set. Each row will be a tuple of the values
    from the `SELECT` clause. In this case, as the `SELECT` clause is `*`, it means
    that all the columns from the original `CREATE TABLE` statement will be used.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: SQL transactions and the ACID properties
  id: totrans-692
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we've seen, the SQL DML statements map to the CRUD operations. When discussing
    the features of the SQL transactions, we'll be looking at the sequences of the
    `INSERT`, `SELECT`, `UPDATE`, and `DELETE` statements.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: The SQL DML statements all work within the context of a SQL transaction. The
    SQL statements executed within a transaction are a logical unit of work. The entire
    transaction can be committed as a whole or rolled back as a whole. This supports
    the Atomicity property.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: SQL DDL statements (that is, `CREATE`, `DROP`) do not work within a transaction.
    They implicitly end any previous in-process transaction. After all, they're changing
    the structure of the database; they're a different kind of statement, and the
    transaction concept doesn't apply.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: The ACID properties are Atomic, Consistent, Isolated, and Durable. These are
    essential features of a transaction that consists of multiple database operations.
    For more information, see [Chapter 10](ch10.html "Chapter 10. Storing and Retrieving
    Objects via Shelve"), *Storing and Retrieving Objects via Shelve*.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: Unless working in a special **read uncommitted** mode, each connection to the
    database sees a consistent version of the data containing only the results of
    the committed transactions. Uncommitted transactions are generally invisible to
    other database client processes, supporting the Consistency property.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: A SQL transaction also supports the Isolation property. SQLite supports several
    different **isolation level** settings. The isolation level defines how the SQL
    DML statements interact among multiple, concurrent processes. This is based on
    how locks are used and how a processes' SQL requests are delayed waiting for locks.
    From Python, the isolation level is set when the connection is made to the database.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: Each SQL database product takes a different approach to the isolation level
    and locking. There's no single model.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of SQLite, there are four isolation levels that define the locking
    and the nature of transactions. For details, see [http://www.sqlite.org/isolation.html](http://www.sqlite.org/isolation.html).
    Here are the isolation levels:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: '`isolation_level=None`: This is the default, otherwise known as the **autocommit**
    mode. In this mode, each individual SQL statement is committed to the database
    as it''s executed. This breaks Atomicity unless, by some weird quirk, all of the
    transactions happen to involve only a single SQL statement.'
  id: totrans-701
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isolation_level=''DEFERRED''`: In this mode, locks are acquired as late as
    possible in the transaction. The `BEGIN` statement, for example, does not immediately
    acquire any locks. Other read operations (that is, the `SELECT` statements) will
    acquire shared locks. Write operations will acquire reserved locks. While this
    can maximize the concurrency, it can also lead to deadlocks among competing processes.'
  id: totrans-702
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isolation_level=''IMMEDIATE''`: In this mode, the transaction `BEGIN` statement
    acquires a lock that prevents all writes. Reads, however, will continue normally.'
  id: totrans-703
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isolation_level=''EXCLUSIVE''`: In this mode, the transaction `BEGIN` statement
    acquires a lock that prevents almost all access. There''s an exception for connections
    in a special read uncommitted mode that ignores locking.'
  id: totrans-704
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Durability property is guaranteed for all committed transactions. The data
    is written to the database file.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQL rules require us to execute `BEGIN TRANSACTION` and `COMMIT TRANSACTION`
    statements to bracket a sequence of steps. In the event of an error, a `ROLLBACK
    TRANSACTION` statement is required to unwind the potential changes. The Python
    interface simplifies this. We can execute a `BEGIN` statement. The other statements
    are provided as functions of the `sqlite3.Connection` object; we don''t execute
    SQL statements to end a transaction. We might write things such as the following
    code to be explicit:'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'We selected an isolation level of `DEFERRED` when we made the database connection.
    This leads to a requirement that we explicitly begin and end each transaction.
    One typical scenario is to wrap the relevant DML in a `try` block and commit the
    transaction if things worked, or roll back the transaction in the case of a problem.
    We can simplify this by using the `sqlite3.Connection` object as a context manager:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: This is similar to the previous example. We opened the database in the same
    way. Rather than executing an explicit `BEGIN` statement, we entered a context;
    the context handles `Begin` for us.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the `with` context, `database.commit()` will be done automatically.
    In the event of an exception, a `database.rollback()` will be done, and the exception
    will be raised by the `with` statement.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: Designing primary and foreign database keys
  id: totrans-712
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SQL tables don't specifically require a primary key. However, it's a rather
    poor design that omits primary keys for the rows of a given table. As we noted
    in [Chapter 10](ch10.html "Chapter 10. Storing and Retrieving Objects via Shelve"),
    *Storing and Retrieving Objects via Shelve*, there might be an attribute (or a
    combination of attributes) that makes a proper primary key. It's also entirely
    possible that no attribute is suitable as a primary key and we must define surrogate
    keys.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: The previous examples use surrogate keys created by SQLite. This is perhaps
    the simplest kind of design because it imposes the fewest constraints on the data.
    One kind of constraint is that a primary key cannot be updated; this becomes a
    rule that the application programming must enforce. In some cases—for example,
    when correcting an error in the primary key value—we need to somehow update the
    primary key. One way to do this is to drop and recreate the constraints. Another
    way to do this is to delete the faulty row and reinsert the row with the corrected
    key. When there are cascading deletes, then the transaction required to correct
    a primary key can become very complex. Using a surrogate key prevents these kinds
    of problems.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: 'All relationships among tables are done via the primary keys and foreign key
    references. There are two extremely common design patterns for relationships.
    The preceding tables show us these two principle design patterns. There are three
    design patterns for relationships, shown in the following bullet list:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: '**One-to-many**: This relationship is between one parent blog and many child
    posts. The `REFERENCES` clause shows us that many rows in the `POST` table will
    reference one row from the `BLOG` table. If viewed from the direction of child
    to parent, it would be called a **Many-to-One** relationship.'
  id: totrans-716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Many-to-many**: This relationship is between many posts and many tags. This
    requires an intermediate association table between the `POST` and `TAG` tables;
    the intermediate table has two (or more) foreign keys. The many-to-many association
    table can also have attributes of its own.'
  id: totrans-717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**One-to-one**: This relationship is a less common design pattern. There''s
    no technical difference from a one-to-many relationship; the cardinality of either
    zero rows or one row is a constraint that the application program must manage.'
  id: totrans-718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In a database design, there might be constraints on the relationships: the
    relationship might be described as optional or mandatory; there might be cardinality
    limits on the relationship. Sometimes, these optionality and cardinality constraints
    are summarized with short descriptions such as "0:m" meaning "zero to many" or
    "optional one to many". The optionality and cardinality constraints are part of
    the application programming logic; there are no formal ways to state these constraints
    in the SQLite database. The essential table relationships can be implemented in
    the database in either or both of the following ways:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: '**Explicit**: We could call these declared, as they''re part of the DDL declaration
    for a database. Ideally, they''re enforced by the database server, and failure
    to comply with the relationship''s constraints can lead to an error of some kind.
    These relationships will also be repeated in queries.'
  id: totrans-720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implicit**: These are relationships that are stated only in queries; they
    are not a formal part of the DDL.'
  id: totrans-721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that our table definitions implemented a one-to-many relationship between
    a blog and the various entries within that blog. We've made use of these relationships
    in the various queries that we wrote.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: Processing application data with SQL
  id: totrans-723
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The examples in the previous sections show us what we can call **procedural**
    SQL processing. We''ve eschewed any object-oriented design from our problem domain
    objects. Rather than working with the `Blog` and `Post` objects, we''re working
    with the data elements that SQLite can process: string, date, float, and integer
    values. We''ve used mostly procedural-style programming.'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that a series of queries can be done to locate a blog, all posts
    that are part of the blog, and all tags that are associated with a post associated
    with a blog. The processing would look like the following code:'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: We defined three SQL queries. The first will fetch the blogs by the title. For
    each blog, we fetched all the posts that belong to this blog. Finally, we fetched
    all tags that are associated with a given post.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: The second query implicitly repeats the `REFERENCES` definition between the
    `POST` table and the `BLOG` table. We're finding child posts of a specific blog
    parent; we need to repeat some of the table definitions during the query.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
- en: The third query involves a relational join between rows of the `ASSOC_POST_TAG`
    table and the `TAG` table. The `JOIN` clause recapitulates the foreign key reference
    in the table definitions. The `WHERE` clause also repeats a `REFERENCES` clause
    in the table definitions.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: Because multiple tables were joined in the third query, using `SELECT *` will
    produce columns from all of the tables. We're really only interested in attributes
    of the `TAG` table, so we use `SELECT TAG.*` to produce only the desired columns.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: These queries provide us with all of the individual bits and pieces of the data.
    However, these queries don't reconstruct Python objects for us. If we have more
    complex class definitions, we have to build objects from the individual pieces
    of data that we retrieved. In particular, if our Python class definitions have
    important method functions, we'll need a better SQL to Python mapping to make
    use of more complete Python class definitions.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
- en: Implementing class-like processing in pure SQL
  id: totrans-732
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s look at a somewhat more complex definition of a `Blog` class. This definition
    is repeated from [Chapter 9](ch09.html "Chapter 9. Serializing and Saving – JSON,
    YAML, Pickle, CSV, and XML"), *Serializing and Saving – JSON, YAML, Pickle, CSV,
    and XML*; we''ve highlighted a method function that''s of interest:'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The `Blog.by_tag()` feature of a blog will become a rather complex SQL query.
    As object-oriented programming, it simply iterates through a collection of `Post`
    instances, creating `defaultdict`, which maps each tag to a sequence of `Posts`
    that share that tag. Here''s a SQL query that produces similar results:'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'This query''s result set is a table-like sequence of rows with three attributes:
    `TAG.PHRASE`, `POST.TITLE`, and `POST.ID`. Each `POST` title and the `POST` ID
    will be repeated with all of the associated `TAG` phrases. To turn this into a
    simple-looking, HTML-friendly index, we need to group all the rows with the same
    `TAG.PHRASE` into a subsidiary list, as shown in the following code:'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: This additional processing would group two-tuples of the `POST` title and the
    `POST` ID into a useful structure that can be used to produce the RST and HTML
    output. The SQL query plus associated Python processing is quite long—longer than
    the native object-oriented Python.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, the SQL query is dissociated from the table definition. SQL
    is not an object-oriented programming language. There's no tidy class to bundle
    data and processing together. Using procedural programming with SQL like this
    has effectively turned off object-oriented programming. From a strictly object-oriented
    programming perspective, we can label this "EPIC FAIL".
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: There is a school of thought that suggests that this kind of SQL-heavy, object-free
    programming is more appropriate for certain kinds of problems than Python. Often,
    these kinds of problems involve the SQL `GROUP BY` clause. While it is convenient
    in SQL, it is also implemented very effectively by Python's `defaultdict` and
    `Counter`. The Python version is often so effective that a small program that
    queries lots of rows using a `defaultdict` might be faster than a database server
    doing SQL with `GROUP BY`. When in doubt, measure. When exhorted by database administrators
    that SQL is magically faster, measure.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: Mapping Python objects to SQLite BLOB columns
  id: totrans-742
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can map SQL columns to class definitions so that we can create proper Python
    object instances from data in a database. SQLite includes a **Binary Large Object**
    (**BLOB**) data type. We can pickle our Python objects and store them in the BLOB
    columns. We can work out a string representation of our Python objects (for example,
    using the JSON or YAML notation) and use SQLite text columns too.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
- en: This technique must be used cautiously because it effectively defeats SQL processing.
    A BLOB column cannot be used for SQL DML operations. We can't index it or use
    it in the search criteria of DML statements.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: SQLite BLOB mapping should be reserved for objects where it's acceptable to
    be opaque to the surrounding SQL processing. The most common examples are media
    objects such as videos, still images, or sound clips. SQL is biased towards text
    and numeric fields. It doesn't generally handle more complex objects.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: If we're working with financial data, our application should use the `decimal.Decimal`
    values. We might want to query or calculate in SQL using this kind of data. As
    `decimal.Decimal` is not directly supported by SQLite, we need to extend SQLite
    to handle values of this type.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two directions to this: conversion and adaptation. We need to **adapt**
    Python data to SQLite, and we need to **convert** SQLite data back to Python.
    Here are two functions and the requests to register them:'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: We've written an `adapt_currency()` function that will adapt `decimal.Decimal`
    objects into a suitable form for the database. In this case, we've done nothing
    more than a simple conversion to a string. We've registered the adapter function
    so that SQLite's interface can convert objects of class `decimal.Decimal` using
    the registered adapter function.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: We've also written a `convert_currency()` function that will convert SQLite
    bytes objects into the Python `decimal.Decimal` objects. We've registered the
    `converter` function so that columns of the `DECIMAL` type will be properly converted
    to Python objects.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve defined the adapters and converters, we can use `DECIMAL` as a
    fully supported column type. For this to work properly, we must inform SQLite
    by setting `detect_types=sqlite3.PARSE_DECLTYPES` when making the database connection.
    Here''s a table definition that uses our new column data type:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'We can use our new column definition like this:'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: We created a database connection that requires declared types to be mapped via
    a converter function. Once we have the connection, we can create our table using
    a new `DECIMAL` column type.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
- en: 'When we insert rows into the table, we use proper `decimal.Decimal` objects.
    When we fetch rows from the table, we''ll see that we get proper `decimal.Decimal`
    objects back from the database. The following is the output:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: This shows us that our `decimal.Decimal` objects were properly stored and recovered
    from the database. We can write adapters and converters for any Python class.
    We need to invent a proper byte representation. As a string is so easily transformed
    into bytes, creating a string is often the simplest way to proceed.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: Mapping Python objects to database rows manually
  id: totrans-759
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can map SQL rows to class definitions so that we can create proper Python
    object instances from the data in a database. If we're careful with our database
    and class definitions, this isn't impossibly complex. If, however, we're careless,
    we can create Python objects where the SQL representation is quite complex. One
    consequence of the complexity is that numerous queries are involved in mapping
    between object and database rows. The challenge is to strike a balance between
    object-oriented design and the constraints imposed by the SQL database.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: We will have to modify our class definitions to be more aware of the SQL implementation.
    We'll make several modifications to the `Blog` and `Post` class designs shown
    in [Chapter 10](ch10.html "Chapter 10. Storing and Retrieving Objects via Shelve"),
    *Storing and Retrieving Objects via Shelve*.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a `Blog` class definition:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: We allowed for a database ID as a first-class part of the object. Further, we've
    modified the initialization to be entirely based on keywords. Each keyword value
    is popped from the `kw` parameter. Any extra values will raise a `TooManyValues`
    exception.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two previously unanswered questions. How do we handle the list of posts
    associated with a blog? We''ll modify the following class to add this feature.
    Here''s a `Post` class definition:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'As with `Blog`, we''ve allowed for a database ID as a first-class part of the
    object. Further, we''ve modified the initialization to be entirely based on keywords.
    Here''s the exception class definition:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Once we have these class definitions, we can write an access layer that moves
    data between objects of these classes and the database. The access layer implements
    a more complex version of converting and adapting Python classes to rows of a
    table in the database.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: Designing an access layer for SQLite
  id: totrans-770
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this small object model, we can implement the entire access layer in a single
    class. This class will include methods to perform CRUD operations on each of our
    persistent classes. In larger applications, we may have to decompose the access
    layer into an individual **Strategy** class for each persistent class. We'd then
    unify all of these under a single access layer **Facade** or **Wrapper**.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: 'This example won''t painstakingly include all of the methods for a complete
    access layer. We''ll show you the important ones. We''ll break this down into
    several sections to deal with `Blogs`, `Posts`, and iterators. Here''s the first
    part of our access layer:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: This class sets `Connection.row_factory` to use the `sqlite3.Row` class instead
    of a simple tuple. The `Row` class allows access via the numeric index as well
    as the column name.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
- en: The `get_blog()` method constructs a `Blog` object from the database row that
    is fetched. Because we're using the `sqlite3.Row` object, we can refer to columns
    by name. This clarifies the mapping between SQL and Python class.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
- en: The `add_blog()` method inserts a row into the `BLOG` table based on a `Blog`
    object. This is a two-step operation. First, we create the new row. Then, we perform
    a SQL query to get the row ID that was assigned to the row.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that our table definitions use `INTEGER PRIMARY KEY AUTOINCREMENT`. Because
    of this, the table''s primary key will match the row ID and the assigned row ID
    will be available through the `last_insert_rowid()` function. This allows us to
    retrieve the row ID that was allocated; we can then put this into the Python object
    for future reference. Here''s how we can retrieve an individual `Post` object
    from the database:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'To build `Post`, we have two queries: first, we fetch a row from the `POST`
    table to build part of the `Post` object. Then, we fetch the association rows
    joined with the rows from the `TAG` table. This is used to build the tag list
    for the `Post` object.'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: 'When we save a `Post` object, it will have several parts. A row must be added
    to the `POST` table. Additionally, rows need to be added to the `ASSOC_POST_TAG`
    table. If a tag is new, then a row might need to be added to the `TAG` table.
    If the tag exists, then we''re simply associating the post with an existing tag''s
    ID. Here''s the `add_post()` method function:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: The process of creating a complete post in the database involves several SQL
    steps. We've used the `insert_post` statement to create the row in the `POST`
    table. We'll also use the generic `get_last_id` query to return the assigned primary
    key for the new `POST` row.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: The `query_tag` statement is used to determine whether the tag exists in the
    database or not. If the result of the query is not `None`, it means that a `TAG`
    row was found, and we have the ID for that row. Otherwise, the `insert_tag` statement
    must be used to create a row; the `get_last_id` query must be used to determine
    the assigned ID.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: 'Each `POST` is associated with the relevant tags by inserting rows into the
    `ASSOC_POST_TAG` table. The `insert_association` statement creates the necessary
    row. Here are two iterator-style queries to locate `Blogs` and `Posts`:'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: The `blog_iter()` method function locates all the `BLOG` rows and builds `Blog`
    instances from the rows.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: The `post_iter()` method function locates `POST` IDs that are associated with
    a `BLOG` ID. The `POST` IDs are used with the `get_post()` method to build the
    `Post` instances. As `get_post()` will perform another query against the `POST`
    table, there's an optimization possible between these two methods.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: Implementing container relationships
  id: totrans-788
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our definition of the `Blog` class included two features that required access
    to all the posts contained within that blog. The `Blog.entries` attribute and
    `Blog.by_tag()` method functions both assume that a blog contains the complete
    collection of the `Post` instances.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
- en: 'For this to work, the `Blog` class must be made aware of the `Access` object
    so that it can use the `Access.post_iter()` method to implement `Blog.entries`.
    We have two overall design patterns for this:'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
- en: A global `Access` object is simple and works nicely. We have to be sure that
    the global database connection is opened appropriately, something that can be
    challenging with a global `Access` object.
  id: totrans-791
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inject the `Access` object into each `Blog` object that we're going to persist.
    This is a bit more complex because we have to tweak each object associated with
    the database.
  id: totrans-792
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As each database-related object should be created by the `Access` class, the
    Access class would fit the **Factory** pattern. We can make three kinds of changes
    to this factory. These will ensure that a blog or post is made aware of the active
    `Access` object:'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
- en: Each `return blog` needs to be expanded to `blog._access= self; return blog`.
    This happens in `get_blog()`, `add_blog()`, and `blog_iter()`.
  id: totrans-794
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each `return post` needs to be expanded to `post._access= self; return post`.
    This happens in `get_post()`, `add_post()` and `post_iter()`.
  id: totrans-795
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Revise the `add_blog()` method to accept arguments to build the `Blog` object
    rather than accepting a `Blog` or `Post` object that is built outside the `Access`
    factory. The definition would look something like the following: `def add_blog(
    self, title ):`'
  id: totrans-796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Revise the `add_post()` method to accept a blog and the arguments to build
    a `Post` object. The definition would look something like: `def add_post( self,
    blog, title, date, rst_text, tags ):`'
  id: totrans-797
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once we have the `_access` attribute injected into each `Blog` instance, we
    can do this:'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: This will return the sequence of Post objects that belong to a Blog object.
    This allows us to define the methods in our class definitions that will process
    children or parents as if they were contained within the object.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
- en: Improving performance with indices
  id: totrans-801
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the ways to improve the performance of a relational database such as
    SQLite is to make join operations faster. The ideal way to do this is to include
    enough index information so that slow search operations aren't done to find matching
    rows. Without an index, an entire table must be read to find referenced rows.
    With an index, just a relevant subset of rows can be read.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
- en: When we define a column that might be used in a query, we should consider building
    an index for that column. This means adding yet more SQL DDL statements to our
    table definitions.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
- en: 'An index is a separate storage but is tied to a specific table and column.
    The SQL looks like the following code:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: This will create an index on the `title` column of the `Blog` table. Nothing
    else needs to be done. The SQL database will use the index when performing queries
    based on the indexed column. When data is created, updated, or deleted, the index
    will be adjusted automatically.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
- en: Indexes involve storage and computational overheads. An index that's rarely
    used might be so costly to create and maintain that it becomes a performance hindrance
    rather than a help. On the other hand, some indexes are so important that they
    can have spectacular performance improvements. In all cases, we don't have direct
    control over the database algorithms being used; the best we can do is create
    the index and measure the performance's impact.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, defining a column to be a key might automatically include having
    an index added. The rules for this are usually stated quite clearly in the database''s
    DDL section. SQLite, for example, says this:'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, UNIQUE and PRIMARY KEY constraints are implemented by creating
    a unique index in the database.
  id: totrans-809
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It goes on to list two exceptions. One of these, the integer primary key exception,
    is the design pattern we've been using to force the database to create surrogate
    keys for us. Therefore, our integer primary key design will not create any additional
    indices.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
- en: Adding an ORM layer
  id: totrans-811
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a fairly large number of Python ORM projects. A list of these can
    be found here: [https://wiki.python.org/moin/HigherLevelDatabaseProgramming](https://wiki.python.org/moin/HigherLevelDatabaseProgramming).'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
- en: We're going to pick just one of these as an example. We'll use SQLAlchemy because
    it offers us a number of features and is reasonably popular. As with many things,
    there's no *best*; other ORM layers have different advantages and disadvantages.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
- en: Because of the popularity of using a relational database to support Web development,
    Web frameworks often include ORM layers. Django has its own ORM layer, as does
    web.py. In some cases, we can tease the ORMs out of the larger framework. However,
    it seems simpler to work with a standalone ORM.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
- en: The documentation, installation guide, and code for SQLAlchemy is available
    at [http://www.sqlalchemy.org](http://www.sqlalchemy.org). When installing, using
    `--without-cextensions` can simplify the process if the high-performance optimizations
    aren't required.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that SQLAlchemy can completely replace all of an application's
    SQL statements with first-class Python constructs. This has the profound advantage
    of allowing us to write applications in a single language, Python, even though
    a second language (SQL) is used under the hood as part of the data access layer.
    This can save some complexity in the development and debugging.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
- en: This does not, however, remove the obligation to understand the underlying SQL
    database constraints and how our design must fit within these constraints. An
    ORM layer doesn't magically obviate the design considerations. It merely changes
    the implementation language from SQL to Python.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
- en: Designing ORM-friendly classes
  id: totrans-818
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When using an ORM, we will fundamentally change the way we design and implement
    our persistent classes. We''re going to expand the semantics of our class definitions
    to have three distinct levels of meaning:'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
- en: The class will be a Python class and can be used to create Python objects. The
    method functions are used by these objects.
  id: totrans-820
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class will also describe a SQL table and can be used by the ORM to create
    the SQL DDL that builds and maintains the database structure.
  id: totrans-821
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class will also define the mappings between the SQL table and Python class.
    It will be the vehicle to turn Python operations into SQL DML and build Python
    objects from SQL queries.
  id: totrans-822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most ORMs are designed so that we will use descriptors to formally define the
    attributes of our class. We do not simply define attributes in the `__init__()`
    method. For more information on descriptors, see [Chapter 3](ch03.html "Chapter 3. Attribute
    Access, Properties, and Descriptors"), *Attribute Access, Properties, and Descriptors*.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy requires us to build a **declarative base class**. This base class
    provides a metaclass for our application's class definitions. It also serves as
    a repository for the metadata that we're defining for our database. If we follow
    the defaults, it's easy to call this class `Base`.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the list of imports that might be helpful:'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: We imported some essential definitions to create a column of a table, column,
    and to create the rare table that doesn't specifically map to a Python class,
    `Table`. We imported all of the generic column type definitions. We'll only use
    a few of these column types. Not only does SQLAlchemy define these generic types,
    it defines the SQL standard types, and it also defines vendor-specific types for
    the various supported SQL dialects. It seems easy to stick to the generic types
    and allow SQLAlchemy to map between generic, standard, and vendor types.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
- en: 'We also imported two helpers to define the relationships among tables, `relationship`,
    and `backref`. SQLAlchemy''s metaclass is built by the `declarative_base()` function:'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: The `Base` object that was created must be the metaclass for any persistent
    class that we're going to define. We'll define three tables that are mapped to
    Python classes. We'll also define a fourth table that's simply required by SQL
    to implement a many-to-many relationship.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the `Blog` class:'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Our `Blog` class is mapped to a table named `"BLOG"`. We've included two descriptors
    for the two columns we want in this table. The `id` column is defined as an `Integer`
    primary key. Implicitly, this will be an autoincrement field so that surrogate
    keys are generated for us.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
- en: The title column is defined as a generic string. We could have used `Text`,
    `Unicode`, or even `UnicodeText` for this. The underlying engine might have different
    implementations for these various types. In our case, SQLite will treat all of
    these nearly identically. Also note that SQLite doesn't need an upper limit on
    the length of a column; other database engines might require an upper limit on
    the size of `String`.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
- en: 'The `as_dict()` method function refers to an `entries` collection that is clearly
    not defined in this class. When we look at the definition of the `Post` class,
    we''ll see how this `entries` attribute is built. Here''s the definition of the
    `Post` class:'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: This class has five attributes, two relationships, and a method function. The
    `id` attribute is an integer primary key; this will be an autoincrement value
    by default. The `title` attribute is a simple string. The `date` attribute will
    be a `DateTime` column; `rst_text` is defined as `UnicodeText` to emphasize our
    expectation of any Unicode character in this field.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
- en: The `blog_id` is a foreign key reference to the parent blog that contains this
    post. In addition to the foreign key column definition, we also included an explicit
    `relationship` definition between post and the parent blog. This `relationship`
    definition becomes an attribute that we can use for navigation from the post to
    the parent blog.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
- en: The `backref` option includes a backwards reference that will be added to the
    `Blog` class. This reference in the `Blog` class will be the collection of `Posts`
    that are contained within the `Blog`. The `backref` option names the new attribute
    in the `Blog` class to reference the child `Posts`.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
- en: The `tags` attribute uses a `relationship` definition; this attribute will navigate
    via an association table to locate all the `Tag` instances associated with the
    post. We'll look at the following association table. This, too, uses `backref`
    to include an attribute in the `Tag` class that references the related collection
    of the `Post` instances.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
- en: 'The `as_dict()` method makes use of the `tags` attribute to locate all of `Tags`
    associated with this `Post`. Here''s a definition for the `Tag` class:'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: We defined a primary key and a `String` attribute. We included a constraint
    to ensure that each tag is explicitly unique. An attempt to insert a duplicate
    will lead to a database exception. The relationship in the `Post` class definition
    means that additional attributes will be created in this class.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
- en: 'As required by SQL, we need an association table for the many-to-many relationship
    between tags and posts. This table is purely a technical requirement in SQL and
    need not be mapped to a Python class:'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: We have to explicitly bind this to the `Base.metadata` collection. This binding
    is automatically a part of the classes that use `Base` as the metaclass. We defined
    a table that contains two `Column` instances. Each column is a foreign key to
    one of the other tables in our model.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
- en: Building the schema with the ORM layer
  id: totrans-847
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to connect to a database, we''ll need to create an engine. One use
    for the engine is to build the database instance with our table declarations.
    The other use for the engine is to manage the data from a session, which we''ll
    look at later. Here''s a script that we can use to build a database:'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: When we create an `Engine` instance, we use a URL-like string that names the
    vendor product and provides all the additional parameters required to create the
    connection to that database. In the case of SQLite, the connection is a filename.
    In the case of other database products, there might be server host names and authentication
    credentials.
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the engine, we've done some fundamental metadata operations. We've
    done the `create_all()`, which builds all of the tables. We might also perform
    a `drop_all()` that will drop all of the tables, losing all the data. We can,
    of course, create or drop an individual schema item, too.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
- en: If we change a table definition during software development, it will not automagically
    mutate the SQL table definition. We need to explicitly drop and rebuild the table.
    In some cases, we might want to preserve some operational data, leading to potentially
    complex surgery to create and populate new table(s) from old table(s).
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
- en: 'The `echo=True` option writes log entries with the generated SQL statements.
    This can be helpful to determine whether the declarations are complete and create
    the expected database design. Here''s a snippet of the output that is produced:'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: This shows SQL us the `CREATE TABLE` statements that were created based on our
    class definitions.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
- en: Once the database has been built, we can create, retrieve, update, and delete
    objects. In order to work with database objects, we need to create a session that
    acts as a cache for the ORM-managed objects.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating objects with the ORM layer
  id: totrans-857
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to work with objects, we''ll need a session cache. This is bound to
    an engine. We''ll add new objects to the session cache. We''ll also use the session
    cache to query objects in the database. This assures us that all objects that
    need to be persistent are in the cache. Here is a way to create a working session:'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: We used the SQLAlchemy `sessionmaker()` function to create a `Session` class.
    This is bound to the database engine that we created previously. We then used
    the `Session` class to build a `session` object that we can use to perform data
    manipulation. A session is required to work with the objects in general.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
- en: Generally, we build one `sessionmaker` class along with the engine. We can then
    use that one `sessionmaker` class to build multiple sessions for our application
    processing.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
- en: 'For simple objects, we create them and load them into the session as in the
    following code:'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: This puts a new `Blog` object into the session named `session`. The `Blog` object
    is not *necessarily* written to the database. We need to commit the session before
    the database writes are performed. In order to meet the Atomicity requirements,
    we'll finish building a post before committing the session.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll look up the `Tag` instances in the database. If they don''t exist,
    we''ll create them. If they do exist, we''ll use the tag found in the database:'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: We use the `session.query()` function to examine instances of the given class.
    Each `filter()` function appends a criterion to the query. The `one()` function
    ensures that we've found a single row. If an exception is raised, then it means
    that `Tag` doesn't exist. We need to build a new `Tag` and add it to the session.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve found or created the `Tag` instance, we can append it to a local
    list named `tags`; we''ll use this list of `Tag` instances to create the `Post`
    object. Here''s how we build a `Post`:'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-869
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: This includes a reference to the parent blog. It also includes the list of `Tag`
    instances that we built (or found in the database).
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
- en: The `Post.blog` attribute was defined as a relationship in the class definitions.
    When we assign an object, SQLAlchemy plucks out the proper ID values to create
    the foreign key reference that the SQL database uses to implement the relationship.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
- en: The `Post.tags` attribute was also defined as a relationship. The `Tag` objects
    are referenced via the association table. SQLAlchemy tracks the ID values properly
    to build the necessary rows in the SQL association table for us.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to associate the `Post` with the `Blog`, we''ll make use of the `Blog.posts`
    attribute. This, too, was defined as a relationship. When we assign a list of
    `Post` objects to this relationship attribute, the ORM will build the proper foreign
    key reference in each `Post` object. This works because we provided the `backref`
    attribute when defining the relationship. Finally, we commit the session:'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: The database inserts are all handled in a flurry of automatically generated
    SQL. The objects remained cached in the session. If our application continues
    using this session instance, then the pool of objects remains available without
    necessarily performing any actual queries against the database.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
- en: If, on the other hand, we would like to be absolutely sure that any updates
    written by other concurrent processes are included in a query, we can create a
    new, empty session for that query. When we discard a session and use an empty
    session, objects must be fetched from the database to refresh the session.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write a simple query to examine and print all of the `Blog` objects:'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: This will retrieve all the `Blog` instances. The `Blog.as_dict()` method will
    retrieve all of the posts within a blog. The `Post.as_dict()` method will retrieve
    all of the tags. The SQL queries will be generated and executed automatically
    by SQLAlchemy.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
- en: We didn't include the rest of the template-based formatting from [Chapter 9](ch09.html
    "Chapter 9. Serializing and Saving – JSON, YAML, Pickle, CSV, and XML"), *Serializing
    and Saving – JSON, YAML, Pickle, CSV, and XML*. It doesn't change. We are able
    to navigate from the `Blog` object via the `entries` list to the `Post` objects
    without writing elaborate SQL queries. Translating navigation into queries is
    the job of SQLAlchemy. Using a Python iterator is sufficient for SQLAlchemy to
    generate the right queries to refresh the cache and return the expected objects.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
- en: If we have `echo=True` defined for the `Engine` instance, then we'll be able
    to see the sequence of SQL queries performed to retrieve the `Blog`, `Post`, and
    `Tag` instances. This information can help us understand the workload that our
    application places on the database server process.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
- en: Querying post objects given a tag string
  id: totrans-882
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An important benefit of a relational database is our ability to follow the relationships
    among the objects. Using SQLAlchemy's query capability, we can follow the relationship
    from `Tag` to `Post` and locate all `Posts` that share a given `Tag` string.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
- en: A query is a feature of a session. This means that objects already in the session
    don't need to be fetched from the database, a potential time-saver. Objects not
    in the session are cached in the session so that updates or deletes can be handled
    at the time of the commit.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
- en: 'To gather all of the posts that have a given tag, we need to use the intermediate
    association table as well as the `Post` and `Tag` tables. We''ll use the query
    method of the session to specify what kinds of objects we expect to get back.
    We''ll use the fluent interface to join in the various intermediate tables and
    the final table that we want with the selection criteria. Here''s how it looks:'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'The `session.query()` method specifies the table that we want to see. If we
    left it at that, we''d see every row. The `join()` methods identify the additional
    tables that must be matched. Because we provided the relationship information
    in the class definitions, SQLAlchemy can work out the SQL details required to
    use primary keys and foreign keys to match rows. The final `filter()` method provides
    the selection criteria for the desired subset of rows. Here''s the SQL that was
    generated:'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: The Python version is a bit easier to understand, as the details of the key
    matching can be elided. The `print()` function uses `post.blog.title` to navigate
    from the `Post` instance to the associated blog and show the `title` attribute.
    If the blog was in the session cache, this navigation is done quickly. If the
    blog was not in the session cache, it will be fetched from the database.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
- en: 'This navigation behavior applies to `[t.phrase for t in post.tags]`, too. If
    the object is in the session cache, it''s simply used. In this case, the collection
    of the `Tag` objects associated with a post might lead to a complex SQL query:'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: In Python, we simply navigated via `post.tags`. SQLAlchemy generated and executed
    the SQL for us.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
- en: Improving performance with indices
  id: totrans-893
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the ways to improve the performance of a relational database such as
    SQLite is to make join operations faster. We don't want SQLite to read an entire
    table to find matching rows. By building an index on a particular column, SQLite
    can examine the index and read just the relevant rows from the table.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
- en: When we define a column that might be used in a query, we should consider building
    an index for that column. This is a simple process that uses SQLAlchemy. We simply
    annotate the attribute of the class with `index=True`.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make fairly minor changes to our `Post` table, for example. We can do
    this to add indexes:'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Adding two indices for the title and date will usually speed up queries for
    the posts by the title or by the date. There's no guarantee that there must be
    an improvement in the performance. Relational database performance involves a
    number of factors. It's important to measure the performance of a realistic workload
    both with the index and without it.
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
- en: Adding an index by `blog_id`, similarly, might speed up the join operation between
    rows in the `Blog` and `Post` tables. It's also possible that the database engine
    uses an algorithm that doesn't benefit from having this index available.
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
- en: Indexes involve storage and computational overheads. An index that's rarely
    used might be so costly to create and maintain that it becomes a problem, not
    a solution. On the other hand, some indexes are so important that they can have
    spectacular performance improvements. In all cases, we don't have direct control
    over the database algorithms being used; the best we can do is create the index
    and measure the performance impact.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
- en: Schema evolution
  id: totrans-901
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working with a SQL database, we have to address the problem of schema evolution.
    Our objects have a dynamic state and a static class definition. We can easily
    persist the dynamic state. Our class definitions are part of the schema for the
    persistent data; we also have mappings to the formal SQL schema. Neither class
    nor SQL schema is *absolutely* static.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
- en: If we change a class definition, how will we fetch objects from the database?
    If the database must change, how do we upgrade the Python mappings and still map
    the data? A good design often involves some combination of several techniques.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
- en: The changes to the method functions and properties of the Python classes don't
    change the mapping to the SQL rows. These can be termed minor changes, as the
    tables in the database are still compatible with the changed class definition.
    A new software release can have a new minor version number.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
- en: The changes to Python class attributes will not necessarily change the persisted
    object state. SQL can be somewhat flexible when converting the data types from
    the database to the Python objects. An ORM layer can add flexibility. In some
    cases, we can make some class or database changes and call it a minor version
    update because the existing SQL schema will still work with new class definitions.
    We can, for example, alter a SQL table from an integer to a string without significant
    breakage because of SQL and ORM conversions.
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
- en: Changes to the SQL table definitions will clearly modify the persisted objects.
    These can be called major changes when the existing database rows will no longer
    be compatible with the new class definition. These kinds of changes should not
    be made by *modifying* the Python class definitions. These kinds of changes should
    be made by defining a new subclass and providing an updated factory function to
    create instances of either the old or new class.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with persistent SQL data, a schema change can be accomplished
    by one of the following two ways:'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
- en: Using SQL `ALTER` statements on the existing schema. Some kinds of changes can
    be done incrementally to a SQL schema. There are a number of constraints and restrictions
    on what changes are permitted. This doesn't generalize well; it should be seen
    as an exceptional situation that might work for minor changes.
  id: totrans-908
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating new tables and dropping old tables. In general, a SQL schema change
    will be significant enough for us to require to create a new version of table(s)
    from old table(s), making profound changes to the data's structure.
  id: totrans-909
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL database schema changes typically involve running a one-time conversion
    script. This script will use the old schema to query the existing data, transform
    it to new data, and use the new schema to insert new data into the database. Of
    course, this must be tested on a backup database before being run on the user's
    preferred, live, operational database. Once the schema change has been accomplished,
    the old schema can be safely ignored and later dropped to free up storage.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
- en: This kind of transformation can be done in a single database using different
    table names or different schema names (for databases that support named schema.)
    If we keep old data and new data side-by-side, we have a flexible upgrade path
    from old applications to the new applications. This is particularly important
    with websites that try to offer 24 x 7 availability.
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
- en: In some situations, it becomes necessary to add tables to the schema with purely
    administrative details such as the identification of schema version. Applications
    can then query this table first after establishing a database connection and fail
    quickly when the schema version is wrong.
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-913
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We looked at the basics of using SQLite in three ways: directly, via an access
    layer, and via the SQLAlchemy ORM. We have to create SQL DDL statements; we can
    do this directly in our applications or in an access layer. We can also have DDL
    built by the SQLAlchemy class definitions. To manipulate data, we''ll use SQL
    DML statements; we can do this directly in a procedural style, or we can use our
    own access layer or SQLAlchemy to create the SQL.'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
- en: Design considerations and trade-offs
  id: totrans-915
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the strengths of the `sqlite3` module is that it allows us to persist
    distinct items. As we're using a database that supports concurrent writes, we
    can have multiple processes updating the data, relying on SQLite to handle concurrency
    via its own internal locking.
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a relational database imposes numerous restrictions. We must consider
    how to map our objects to rows of tables in the database:'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
- en: We can use SQL directly, using only the supported SQL column types and largely
    eschewing object-oriented classes
  id: totrans-918
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use a manual mapping that extends SQLite to handle our objects as SQLite
    BLOB columns
  id: totrans-919
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can write our own access layer to adapt and convert between our objects and
    SQL rows
  id: totrans-920
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use an ORM layer to implement a row-to-object mapping
  id: totrans-921
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping alternatives
  id: totrans-922
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The problem with mixing Python and SQL is that there can be an impetus towards
    something that we might call the "All Singing, All Dancing, All SQL" solution.
    The idea here is that the relational database is somehow the ideal platform and
    Python corrupts this by injecting needless object-oriented features.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
- en: The all-SQL, object-free design strategy is sometimes justified as being more
    appropriate for certain kinds of problems. Specifically, proponents will point
    out summarizing large sets of data using the SQL `GROUP BY` clause as an ideal
    use for SQL.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
- en: This is implemented very effectively by Python's `defaultdict` and `Counter`.
    The Python version is often so effective that a small Python program querying
    lots of rows and accumulating summaries using `defaultdict` might be faster than
    a database server performing SQL with `GROUP BY`.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
- en: When in doubt, measure. Some nonsense is spouted by SQL database proponents.
    When confronted with claims that SQL should magically be faster that Python, gather
    evidence. This data gathering is not confined to one-time initial technical spike
    situations either. As usage grows and changes, the relative merit of SQL database
    versus Python will shift too.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
- en: A home-brewed access layer will tend to be highly specific to a problem domain.
    This might have the advantage of high performance and relatively transparent mapping
    from row to object. It might have the disadvantage of being annoying to maintain
    every time a class changes or the database implementation changes.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
- en: A well-established ORM project might involve some initial effort to learn the
    features of the ORM, but the long-term simplifications are important benefits.
    Learning the features of an ORM layer can involve both initial work and rework
    as lessons are learned. The first attempts at a design that has good object features
    and still fits within the SQL framework will have to be redone as the application
    trade-offs and considerations become clearer.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
- en: Keys and key designs
  id: totrans-929
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because SQL depends on keys, we must take care to design and manage keys for
    our various objects. We must design a mapping from an object to the key that will
    be used to identify that object. One choice is to locate an attribute (or combination
    of attributes) that are proper primary keys and cannot be changed. Another choice
    is to generate surrogate keys that cannot be changed; this allows all other attributes
    to be changed.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
- en: Most relational databases can generate surrogate keys for us. This is usually
    the best approach. For other unique attributes or candidate key attributes, we
    can define SQL indexes to improve the processing performance.
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
- en: 'We must also consider the foreign key relationships among objects. There are
    several common design patterns: One-to-Many, Many-to-One, Many-to-Many, and Optional
    One-to-One. We need to be cognizant of how SQL uses keys to implement these relationships
    and how SQL queries will be used to fill in the Python collections.'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
- en: Application software layers
  id: totrans-933
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because of the relative sophistication available when using `sqlite3`, our
    application software must become more properly layered. Generally, we''ll look
    at software architectures with layers resembling the following ones:'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
- en: 'The presentation layer: This is a top-level user interface, either a web presentation
    or a desktop GUI.'
  id: totrans-935
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The application layer: This is the internal service or controllers that make
    the application work. This could be called the processing model, different from
    the logical data model.'
  id: totrans-936
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The business layer or the problem domain model layer: These are the objects
    that define the business domain or the problem space. This is sometimes called
    the logical data model. We looked at how we might model these objects using a
    microblog blog and post example.'
  id: totrans-937
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Infrastructure: This often includes several layers as well as other cross-cutting
    concerns such as logging, security, and network access:'
  id: totrans-938
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The data access layer: These are protocols or methods to access the data objects.
    It is often an ORM layer. We''ve looked at SQLAlchemy. There are numerous other
    choices for this.'
  id: totrans-939
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The persistence layer: This is the physical data model as seen in file storage.
    The `sqlite3` module implements persistence. When using an ORM layer such as SQLAlchemy,
    we only reference SQLite when creating an Engine.'
  id: totrans-940
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When looking at `sqlite3` in this chapter and `shelve` in [Chapter 10](ch10.html
    "Chapter 10. Storing and Retrieving Objects via Shelve"), *Storing and Retrieving
    Objects via Shelve*, it becomes clear that mastering object-oriented programming
    involves some higher-level design patterns. We can't simply design classes in
    isolation, but we need to look at how classes are going to be organized into larger
    structures.
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
- en: Looking forward
  id: totrans-942
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at transmitting and sharing objects using REST.
    This design pattern shows us how to manage the representation of the state and
    how to transfer the object state from process to process. We'll leverage a number
    of persistence modules to represent the state of an object that is being transmitted.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 13](ch13.html "Chapter 13. Configuration Files and Persistence"),
    *Configuration Files and Persistence*, we'll look at configuration files. We'll
    look at several ways to make use of persistent representations of data that controls
    an application.
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 12. Transmitting and Sharing Objects
  id: totrans-945
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll expand on our serialization techniques for the object representation shown
    in [Chapter 9](ch09.html "Chapter 9. Serializing and Saving – JSON, YAML, Pickle,
    CSV, and XML"), *Serializing and Saving – JSON, YAML, Pickle, CSV, and XML*. When
    we need to transmit an object, we're performing some kind of **Representational
    State Transfer** (**REST**). When we serialize an object, we're creating a representation
    of the state of an object. This representation can be transferred to another process
    (usually on another host computer); the other process can then build a version
    of the original object from the representation of the state and a local definition
    of the class.
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
- en: We can perform REST processing in a number of ways. One aspect of it is the
    state representation that we can use. Another aspect is the protocol to control
    the transfer. We won't cover all of the combinations of these aspects. Instead,
    we'll focus on two combinations.
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
- en: For internet transfers, we'll leverage the HTTP protocol to implement **Create-Retrieve-Update-Delete**
    (**CRUD**) processing operations. This is commonly called a REST web server. We'll
    look at providing RESTful web services as well. This will be based on Python's
    **Web Service Gateway Interface** (**WSGI**) reference implementation, the `wsgiref`
    package.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
- en: For local transfers among processes on the same host, we'll look at the local
    message queues provided by the `multiprocessing` module. There are numerous sophisticated
    queue management products. We'll focus on the standard library offerings.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
- en: This kind of processing builds on using JSON or XML to represent an object.
    For WSGI, we're adding the HTTP protocol and a set of design patterns to define
    transactions in a web server. For multiprocessing, we're adding a processing pool.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an additional consideration when working with REST transfers: the
    source or the data might not be trustworthy. We must implement some security.
    When it comes to the commonly used representations, JSON and XML, there are few
    security considerations. YAML introduces a security concern and supports a safe
    load operation; see [Chapter 9](ch09.html "Chapter 9. Serializing and Saving –
    JSON, YAML, Pickle, CSV, and XML"), *Serializing and Saving – JSON, YAML, Pickle,
    CSV, and XML* for more information on this. Because of the security issue, the
    `pickle` module also offers a restricted unpickler that can be trusted to not
    import unusual modules and execute damaging code.'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
- en: Class, state, and representation
  id: totrans-952
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some cases, we might be creating a server that will provide data to remote
    clients. In other cases, we might want to consume data from remote computers.
    We may have a hybrid situation where our application is both a client of remote
    computers and servers to mobile applications. There are many situations where
    our application works with objects that are persisted remotely.
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
- en: We need a way to transmit objects from process to process. We can decompose
    the larger problem into two smaller problems. The inter-networking protocols can
    help us transmit bytes from a process on one host to a process on another host.
    Serialization can transform our objects into bytes.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the object state, we transmit class definitions through an entirely separate
    and very simple method. We exchange class definitions via the source code. If
    we need to supply a class definition to a remote host, we send the Python source
    code to that host. The code must be properly installed to be useful; this is often
    a manual operation performed by an administrator.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
- en: Our networks transmit bytes. Therefore, we need to represent the values of an
    object's instance variables as a stream of bytes. Often, we'll use a two-step
    transformation to bytes; we'll represent the state of an object as a string and
    rely on the string to provide bytes in one of the standard encodings.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
- en: Using HTTP and REST to transmit objects
  id: totrans-957
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Hypertext Transfer Protocol** (**HTTP**) is defined through a series of **Request
    for Comments** (**RFC**) documents. We won''t review all of the particulars, but
    we will touch on three high points.'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP protocol includes requests and replies. A request includes a method,
    a **Uniform Resource Identifier** (**URI**), some headers, and optional attachments.
    A number of available methods are defined in the standards. Most browsers focus
    on making the `GET` and `POST` requests. The standard browsers include the `GET`,
    `POST`, `PUT`, and `DELETE` requests, which are the ones that we'll leverage because
    they correspond to the CRUD operations. We'll ignore most of the headers and focus
    on the path portion of the URI.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
- en: A reply includes a status code number and reason, headers, and some data. There
    are a variety of status code numbers. Of them, we're interested in just a few.
    The `200` status code is the generic `OK` response from a server. A `201` status
    code is the `Created` response, which might be appropriate to show us that a post
    worked and data was posted. A `204` status code is the `No Content` response,
    which might be appropriate for `DELETE`. The `400` status code is `Bad Request`,
    the `401` status code is `Unauthorized`, the `404` status code is `Not Found`.
    These status code are commonly used to reflect operations that cannot be performed,
    or are not valid.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
- en: Most `2xx` successful replies will include an encoded object or sequence of
    objects. A `4xx` error reply may include a more detailed error message.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
- en: HTTP is defined to be stateless. The server is not expected to have any recollection
    of previous interactions with a client. We have a number of candidate workarounds
    to this limitation. For interactive websites, cookies are used to track the transaction
    state and improve the application behavior. For web services, however, the client
    will not be a person; each request can include the authentication credentials.
    This imposes the further obligation to secure the connection. For our purposes,
    we'll assume that the server will use **Secure Sockets Layer** (**SSL**) and use
    an HTTPS connection on port 443 instead of HTTP on port 80.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
- en: Implementing CRUD operations via REST
  id: totrans-963
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We'll look at three fundamental ideas behind the REST protocol. The first idea
    is to use any handy text serialization of an object's state. Second, we can use
    the HTTP request URI to name an object; a URI can include any level of detail,
    including a schema, module, class, and object identity in a uniform format. Finally,
    we can use the HTTP method to map to CRUD rules to define the action to be performed
    on the named object.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of HTTP for RESTful services pushes the envelope on the original definitions
    of HTTP requests and replies. This means that some of the request and reply semantics
    are open to active, ongoing discussion. Rather than presenting all of the alternatives,
    each of which has unique merits, we''ll suggest a single approach. Our focus is
    on the Python language, not the more general problem of designing RESTful web
    services. A REST server will often support CRUD operations via the following five
    essential use cases:'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
- en: '**Create**: We''ll use an `HTTP POST` request to create a new object and a
    URI that provides class information only. A path such as `//host/app/blog/` might
    name the class. The response could be a 201 message that includes a copy of the
    object as it was finally saved. The returned object information may include the
    URI assigned by the RESTful server for the newly created object or the relevant
    keys to construct the URI. A `POST` request is expected to change the RESTful
    resources by creating something new.'
  id: totrans-966
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Retrieve – Search**: This is a request that can retrieve multiple objects.
    We''ll use an `HTTP GET` request and a URI that provides search criteria, usually
    in the form of a query string after the `?` character. The URI might be `//host/app/blog/?title="Travel
    2012-2013"`. Note that `GET` never makes a change to the state of any RESTful
    resources.'
  id: totrans-967
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Retrieve – Instance**: This is a request for a single object. We''ll use
    an `HTTP GET` request and a URI that names a specific object in the URI path.
    The URI might be `//host/app/blog/id/`. While the response is expected to be a
    single object, it might still be wrapped in a list to make it compatible with
    a search response. As this response is `GET`, there''s no change in the state.'
  id: totrans-968
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Update**: We''ll use an `HTTP PUT` request and a URI that identifies the
    object to be replaced. The URI might be `//host/app/blog/id/`. The response could
    be a 200 message that includes a copy of the revised object. Clearly, this is
    expected to make a change to the RESTful resources. There are good reasons to
    use other status responses than 200\. We''ll stick to 200 for our examples here.'
  id: totrans-969
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Delete**: We''ll use an `HTTP DELETE` request and a URI that looks like `//host/app/blog/id/`.
    The response could be a simple `204 NO CONTENT` without providing any object details
    in the response.'
  id: totrans-970
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the HTTP protocol is stateless, there's no provision for logon and logoff.
    Each request must be separately authenticated. We will often make use of the HTTP
    `Authorization` header to provide the username and password credentials. When
    doing this, we absolutely must also use SSL to provide security for the content
    of the `Authorization` header. There are more sophisticated alternatives that
    leverage separate identity management servers to provide authentication tokens
    rather than credentials.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
- en: Implementing non-CRUD operations
  id: totrans-972
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some applications will have operations that can't be easily characterized as
    CRUD. We might, for example, have a **Remote Procedure Call** (**RPC**) style
    application that performs a complex calculation. The calculation's arguments are
    provided via the URI, so there's no change RESTful in the server state.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, these calculation-focused operations can be implemented as
    the `GET` requests as there's no change in the state. However, we might consider
    making them `POST` requests if we are going to preserve a log of the request and
    reply as part of a non-repudiation scheme. This is particularly important in websites
    where a fee is charged for the services.
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
- en: The REST protocol and ACID
  id: totrans-975
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ACID properties are defined in [Chapter 10](ch10.html "Chapter 10. Storing
    and Retrieving Objects via Shelve"), *Storing and Retrieving Objects via Shelve*.
    These properties are Atomic, Consistent, Isolated, and Durable. These are essential
    features of a transaction that consists of multiple database operations. These
    properties don't automatically become part of the REST protocol. We must consider
    how HTTP works when we ensure that the ACID properties are met.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
- en: Each HTTP request is atomic; therefore, we should avoid designing an application
    that makes a series of related `POST` requests that we hope become atomic. Instead,
    we should look for a way to bundle all of the information into a single request.
    Additionally, we have to be aware that requests will often be interleaved from
    a variety of clients; therefore, we don't have a tidy way to handle isolation
    among interleaved sequences of requests. If we have a properly multilayered design,
    we should delegate the durability to a separate persistence module.
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
- en: In order to achieve the ACID properties, a common technique is to define the
    `POST`, `PUT`, or `DELETE` requests that contain *all* the relevant information.
    By providing a single composite object, the application can perform all of the
    operations in a single REST request. These larger objects become *documents* that
    might contain several items that are part of the more complex transaction.
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
- en: 'When looking at our blog and post relationships, we see that we might want
    to handle two kinds of `HTTP POST` requests to create a new `Blog` instance. The
    two requests are as follows:'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
- en: '**A blog with only a title and no additional post entries**: We can easily
    implement ACID properties for this, as it''s only a single object.'
  id: totrans-980
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A composite object that is a blog plus a collection of post entries**: We
    need to serialize the blog and all of the relevant `Post` instances. This needs
    to be sent as a single `POST` request. We can then implement the ACID properties
    by creating the blog, the related posts, and returning a single `201 Created`
    status when the entire collection of objects has been made durable. This may involve
    a complex multistatement transaction in the database that supports the RESTful
    web server.'
  id: totrans-981
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing a representation – JSON, XML, or YAML
  id: totrans-982
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There''s no good reason to pick a single representation; it''s relatively easy
    to support a number of representations. The client should be permitted to demand
    a representation. There are several places where a client can specify the representation:'
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
- en: We can use a part of a query string, `https://host/app/class/id/?form=XML`.
  id: totrans-984
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use a part of the URI: `https://host/app;XML/class/id/`. In this example,
    we''ve used a sub-delimiter for the application to identify the required representation.
    The `app;XML` syntax names the application, `app`, and the format, `XML`.'
  id: totrans-985
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use the fragment identifier, `https://host/app/class/id/#XML`.
  id: totrans-986
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can provide it in a header. The `Accept` header, for example, can be used
    to specify the representation.
  id: totrans-987
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: None of these is *clearly* superior. Compatibility with existing RESTful web
    services may suggest a particular format. The relative ease with which a framework
    parses a URI pattern may suggest a format.
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
- en: JSON is preferred by many JavaScript presentation layers. Other representations
    such as XML or YAML can be helpful for other presentation layers or other kinds
    of clients. In some cases, there may be yet another representation. For example,
    MXML or XAML might be required by a particular client application.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a REST server – WSGI and mod_wsgi
  id: totrans-990
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As REST is built on HTTP, a REST sever is an extension to an HTTP server. For
    robust, high-performance, secure operations, common practice is to build on a
    server such as **Apache httpd** or the **nginx**. These servers don't support
    Python by default; they require an extension module to interface with a Python
    application.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
- en: One widely used interface between web servers and Python is the WSGI. For more
    information, see [http://www.wsgi.org](http://www.wsgi.org). The Python Standard
    Library includes a WSGI reference implementation. See PEP 3333, [http://www.python.org/dev/peps/pep-3333/](http://www.python.org/dev/peps/pep-3333/),
    for the ways this reference implementation works in Python 3.
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind WSGI is to standardize the HTTP request-reply processing around
    a relatively simple and extensible Python API. This allows us to architect complex
    Python solutions out of relatively independent components. The goal is to create
    a nested series of applications that perform incremental processing on the request.
    This creates a kind of pipeline where each stage adds information to the request
    environment.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
- en: 'Each WSGI application must have this API:'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-995
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: The `environ` variable must be `dict` with environmental information. The `start_response`
    function must be used to start preparing a response to the client; this is how
    the response status code and headers are sent. The return value must be an iterable
    over strings; that is, the body of the response.
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
- en: The term *application* is used flexibly in the WSGI standard. A single server
    might have many WSGI applications. It's not the intent of WSGI to encourage or
    require programming at a low level of WSGI-compliant applications. The intent
    is to use larger, more sophisticated web frameworks. The web frameworks would
    all use the WSGI API definition to ensure compatibility.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
- en: The WSGI reference implementation is not intended to be a public-facing web
    server. This server doesn't handle SSL directly; some work needs to be done to
    wrap the sockets with proper SSL encryption. In order to access port 80 (or port
    443), the process must execute in the `setuid` mode with a privileged user ID.
    One common practice is to install the WSGI extension module in a web server or
    use a web server that supports a WSGI API. This means that web requests are routed
    to Python from the web server using the standard WSGI interface. This allows the
    web server to provide static content. The Python applications available through
    the WSGI interface will provide the dynamic content.
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
- en: Here's a list of web servers that are either written in Python or have Python
    plugins, [https://wiki.python.org/moin/WebServers](https://wiki.python.org/moin/WebServers).
    These servers (or plugins) are intended to provide robust, secure, public-facing
    web servers.
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
- en: An alternative is to build a standalone Python server and use redirection to
    shunt requests from the public-facing server to the separate Python daemon. When
    working with Apache httpd, a separate Python daemon can be created via the `mod_wsgi`
    module. As our focus is Python, we'll avoid nginx or Apache httpd details.
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple REST application and server
  id: totrans-1001
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We'll write a very simple REST server that provides spins of a Roulette wheel.
    This is an example of a service that makes a response to a simple request. We'll
    focus on the RESTful web server programming in Python. There are additional details
    required to plug this software into a larger web server such as Apache httpd or
    nginx.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll define a simplified Roulette wheel:'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-1004
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: The `Wheel` class is a list of bins. Each bin is `dict`; the keys are bets that
    will be winners if the ball lands in that bin. The values in a bin are the payout
    ratios. We've only shown you a short list of bets. The complete list of available
    Roulette bets is quite large.
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we''ve omitted the zero or double zero bins. There are two different
    kinds of commonly used wheels. Here are two mixin classes that define the different
    kinds of commonly used wheels:'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-1007
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: The `Zero` mixin includes an initialization for a single zero. The `DoubleZero`
    mixin includes the double zero. These are relatively simple bins; they only payoff
    if a bet is made on the number itself.
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
- en: We've used mixins here because we're going to tweak the definition of `Wheel`
    in some of the following examples. By using mixins, we can ensure that each extension
    to the base class, `Wheel`, will work consistently. For more information on the
    mixin-style design, see [Chapter 8](ch08.html "Chapter 8. Decorators and Mixins
    – Cross-cutting Aspects"), *Decorators and Mixins – Cross-cutting Aspects*.
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the two subclasses that define the different kinds of commonly used
    wheels:'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-1011
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'These two definitions extend the basic `Wheel` class with mixins that will
    initialize the bins properly for each kind of wheel. These concrete subclasses
    of `Wheel` can be used as follows:'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-1013
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Each evaluation of `spin()` produces a simple dictionary like the following
    one:'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-1015
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'The keys in this `dict` are the bet names. The value is a two-tuple with the
    payout ratio. The previous example shows us the Red 12 as a winner; it''s also
    low and even. If we had placed a bet on 12, our winnings would be 35 times our
    bet, a payout of 35 to 1\. The other propositions have payout of 1 to 1: we''d
    double our money.'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
- en: We'll define a WSGI application that uses a simple path to determine which type
    of wheel to use. A URI such as `http://localhost:8080/european/` will use the
    European wheel. Any other path will use the American wheel.
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a WSGI application that uses a `Wheel` instance:'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-1019
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: This shows us some of the essential ingredients in a WSGI application.
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
- en: First, we used the `wsgiref.util.shift_path_info()` function to examine the
    `environ['PATH_INFO']` value. This will parse one level of the path information
    in the request; it will either return the string value that was found, or return
    `None` in the case of a path not being provided at all.
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
- en: Second, the logging line shows us that we *must* write to `sys.stderr` if we
    want to produce a log. Anything written to `sys.stdout` will be used as part of
    the response from the WSGI application. Anything that we attempt to print before
    the call to `start_response()` will lead to exceptions because the status and
    headers were not sent.
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
- en: Third, we evaluated the request to compute the response. We used two globals,
    `european` and `american`, to provide a consistently randomized sequence of responses.
    If we attempt to create a unique `Wheel` instance for each request, we make inappropriate
    use of the random number generator.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
- en: Fourth, we formulated a response with a proper status code and HTTP headers.
    The body of the response is a JSON document that we've encoded using UTF-8 to
    make a proper byte stream as required by HTTP.
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start a demonstration version of this server with a function such as
    the following:'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-1026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: The `wsgiref.simple_server.make_server()` function creates the server object.
    The object will invoke the callable `wheel()` to process each request. We've used
    the local hostname `''` and a non-privileged port, `8080`. Using the privileged
    port `80` requires `setuid` privileges and is better handled by the **Apache httpd**
    server.
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
- en: Once the server is built, it can be left to run by itself; this is the `httpd.serve_forever()`
    method. For unit testing, however, it often works out much better to handle a
    finite number of requests and then stop the server.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
- en: We can run this function from the command line in a terminal window. Once we
    are running the function, we can use a browser to see the responses when we make
    requests to `http://localhost:8080/`. This can be helpful when creating a technical
    spike or debugging.
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a REST client
  id: totrans-1030
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before looking at a smarter REST server application, we''ll look at writing
    a REST client. Here''s a function that will make a simple `GET` request to a REST
    server:'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-1032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'This shows us the essence of working with a RESTful API. The `http.client`
    module has a four-step process:'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
- en: To establish a connection via `HTTPConnection()`
  id: totrans-1034
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To send a request with a command and a path
  id: totrans-1035
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To get a response
  id: totrans-1036
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To read the data in the response
  id: totrans-1037
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The request can include an attached document (used for POST) as well as additional
    headers. In this function, we printed several parts of the response. In this example,
    we read the status code number and the reason text. Most of the time, we expect
    a status of 200 and a reason of `OK`. We also read and printed all of the headers.
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we read the entire response into a temporary string, named `raw`. If
    the status code was 200, we used the `json` module to load objects from the response
    string. This recovered whatever JSON-encoded objects were serialized and sent
    from the server.
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
- en: If the status code is not 200, we just print the available text. It might be
    an error message or other information that is useful for debugging.
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
- en: Demonstrating and unit testing the RESTful services
  id: totrans-1041
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's relatively easy to perform a spike demonstration of a RESTful server. We
    can import the server class and function definitions and run the server function
    from a terminal window. We can connect with `http://localhost:8080` to see the
    responses.
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
- en: For proper unit testing, we want a more formal exchange between a client and
    a server. For a controlled unit test, we'll want to start and then stop a server
    process. We can then exercise the server and examine the responses to the client.
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `concurrent.futures` module to create a separate subprocess
    to run the server. Here''s a snippet that shows us the kind of processing that
    can become part of a unit test case:'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-1045
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: We created a separate process by creating an instance of `concurrent.futures.ProcessPoolExecutor`.
    We can then submit a function to this server, with appropriate argument values.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we executed our `json_get()` client function to read the default
    path, `/`, twice. Then we performed the `GET` operation on the "`/european/`"
    path two times.
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
- en: 'The `executor.submit()` function makes the process pool evaluate the `roulette_server(4)`
    function. This will handle four requests and then terminate. Because `ProcessPoolExecutor`
    is a context manager, we''re assured that all of the resources will be properly
    cleaned up. The output log from the unit test includes groups of lines in the
    following way:'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-1049
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: The `wheel 'european'` line is the log output from our `wheel()` WSGI application.
    The `127.0.0.1 - - [08/Dec/2013 09:32:08] "GET /european/ HTTP/1.1" 200 62` log
    line is written by default from the WSGI server, which shows us that the request
    was processed completely without an error.
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
- en: The next three lines are written by the client `json_get()` function. The `200
    OK` line is the first `print()` function. These lines are the headers that were
    sent as part of the server response. Finally, we show you the decoded dictionary
    object that was sent from the server to the client. In this case, the winner was
    20 Black.
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, note that our original tuples were transformed into lists by the JSON
    encoding and decoding process. Our original dict had `''20'': (35, 1)`. The result
    here after encoding and decoding is `''20'': [35, 1]`.'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the module being tested will be imported by the `ProcessPool` server.
    This import will locate the named function, `roulette_server()`. Because the server
    will import the module under test, the module under test must properly use `__name__
    == "__main__"` guards to be sure that it won''t perform any additional processing
    during the import; it must only provide definitions. We must be sure to use this
    kind of construct in the script that defines a server:'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-1054
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: Using Callable classes for WSGI applications
  id: totrans-1055
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can implement WSGI applications as `Callable` objects instead of standalone
    functions. This allows us to have stateful processing in our WSGI server without
    the potential confusion of global variables. In our previous example, the `get_spin()`
    WSGI application relied on two global variables, `american` and `european`. The
    binding between the application and global can be mysterious.
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
- en: 'The point of defining a class is to encapsulate the processing and data into
    a single package. We can use `Callable` objects to encapsulate our applications
    in a better manner. This can make the binding between stateful `Wheel` and WSGI
    applications clearer. Here is an extension to the `Wheel` class that makes it
    into a callable WSGI application:'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-1058
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'We extended the base `Wheel` class to include the WSGI interface. This doesn''t
    do any parsing of the request; the WSGI processing has been pared down to just
    two steps: evaluation and response. We''ll handle parsing and logging in a higher-level,
    wrapper application. This `Wheel2` application simply picks a result and encodes
    it as the result.'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
- en: Note that we've added a distinct design feature to the `Wheel2` class. This
    is an example of a concern that is not part of the *is-a* definition of `Wheel`.
    This is more of an *acts-as* feature. This should, perhaps, be defined as a mixin
    or a decorator rather than a first-class feature of the class definition.
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are two subclasses that implement American and European variations on
    Roulette:'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-1062
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: These two subclasses rely on the `__call__()` method function in the superclass.
    As with the preceding examples, we're using the mixins to add appropriate zero
    bins to the wheel.
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve changed the wheel from being a simple object to being a WSGI application.
    This means that our higher-level wrapper application can be somewhat simpler.
    Rather than evaluating some other object, the higher-level application simply
    delegates the request to the object. Here''s a revised wrapper application that
    selects the wheel to be spun and delegates the request:'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-1065
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: When we create an instance of this `Wheel3` class, it will create the two wheels.
    Each wheel is a WSGI application.
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
- en: When a request is handled, the `Wheel3` WSGI application will parse the request.
    It will then hand the two arguments (`environ` and the `start_response` function)
    over to another application to perform the actual evaluation and compute a response.
    In many cases, this delegation will also include updating the `environ` variable
    with arguments and parameters parsed from the request path or headers. Finally,
    this `Wheel3.__call__()` function will return the response from the other application
    that was invoked.
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
- en: 'This style of delegation is characteristic of WSGI applications. It''s the
    reason that WSGI applications nest together so elegantly. Note that a wrapper
    application has two places to inject the processing:'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
- en: Before invoking another application, it will tweak the environment to add information
  id: totrans-1069
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After invoking another application, it can tweak the response document
  id: totrans-1070
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generally, we like to focus on tweaking the environment in a wrapping application.
    In this case, however, there was no real need to update the environment with any
    additional information, as the request was so trivial.
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
- en: Designing RESTful object identifiers
  id: totrans-1072
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Object serialization involves defining some kind of identifier for each object.
    For `shelve` or `sqlite`, we need to define a string key for each object. A RESTful
    web server makes the same demands to define a workable key that can be used to
    unambiguously track down objects.
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
- en: A simple, surrogate key can work out for a RESTful web service identifier as
    well. It can easily parallel the key used for `shelve` or `sqlite`.
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
- en: What's important is the idea that c*ool URIs don't change*. See [http://www.w3.org/Provider/Style/URI.html](http://www.w3.org/Provider/Style/URI.html).
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
- en: It is important for us to define a URI that isn't going to change, ever. It's
    essential that stateful aspects of an object are never used as part of the URI.
    For example, a microblogging application may support multiple authors. If we organize
    blog posts into folders by the author, we create problems for shared authorship
    and we create larger problems when one author takes over another author's content.
    We don't want the URI to switch when a purely administrative feature such as *ownership*
    changes.
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
- en: A RESTful application may offer a number of indices or search criteria. However,
    the essential identification of a resource or object should never change as the
    indices are changed or reorganized.
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
- en: For relatively simple objects, we can often find some sort of identifier—often,
    a database surrogate key. In the case of blog posts, it's common to use a publication
    date (as that can't change) and a version of the title with punctuation and spaces
    replaced by `_` characters. The idea is to create an identifier that will not
    change no matter how the site gets reorganized. Adding or changing indexes can't
    change the essential identification of a microblog post.
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
- en: For more complex objects that are containers, we have to decide on the granularity
    with which we can refer to these more complex objects. Continuing the microblog
    example, we have blogs as a whole, which contain a number of individual posts.
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
- en: 'The URI for a blog can be something simple like this:'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-1081
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: The top-most name (`microblog`) is the overall application. Then, we have the
    type of resource (`blog`) and finally, an ID for a specific instance.
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
- en: 'URI names for a post, however, have several choices:'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-1084
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: The first URI doesn't work well when different blogs have posts with the same
    title. In this case, an author may see their title made unique with an extra `_2`
    or some other decoration that forces the title to be unique. This is often undesirable.
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
- en: The second URI uses the blog ID (`bid`) as a context or namespace to ensure
    that the `Post` titles are treated as unique within the context of a blog. This
    kind of technique is often extended to include additional subdivisions such as
    a date to further shrink the search space.
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
- en: 'The third example uses an explicit class/object naming at two levels: `blog/bid`
    and the `post/title_string`. This has the disadvantage of longer paths, but it
    has the advantage of allowing a complex container to have multiple items in distinct
    internal collections.'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
- en: Note that REST services have the effect of defining an API for persistent storage.
    In effect, the URIs are similar to names of the interface methods. They must be
    chosen with an eye toward clarity, meaning, and durability.
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
- en: Multiple layers of REST services
  id: totrans-1089
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here''s a smarter, multilayered REST server application. We''ll show you this
    in pieces. First, we need to supplement our `Wheel` class with a Roulette table:'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-1091
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: The `Table` class tracks bets from a single, anonymous player. Each bet is a
    string name for a space on the Roulette table and an integer amount. When resolving
    the bets, a single spin from the `Wheel` class is provided to the `resolve()`
    method. The bets that are placed are compared to the winning bets from the spin
    and the player's stake is adjusted as bets are won or lost.
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll define a RESTful Roulette server that shows us a stateful transaction
    that is implemented via an `HTTP POST` method. We''ll break the game of Roulette
    into three URIs:'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
- en: '`/player/`'
  id: totrans-1094
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET` to this URI will retrieve a JSON-encoded `dict` with facts about the
    player, including their stake and the number of rounds played so far. A future
    expansion would be to define a proper `Player` object and return a serialized
    instance.'
  id: totrans-1095
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A future expansion would be to handle `POST` to create additional players who
    place bets.
  id: totrans-1096
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/bet/`'
  id: totrans-1097
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST` to this URI will include a JSON-encoded `dict` or a list of dicts that
    will create bets. Each bet dictionary will have two keys: `bet` and `amount`.'
  id: totrans-1098
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET` will return a JSON-encoded `dict` that shows us the bets and amounts
    placed so far.'
  id: totrans-1099
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/wheel/`'
  id: totrans-1100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`—with no data—to this URI will spin and compute the payout. This is implemented
    as `POST` to reinforce the sense that it is making a stateful change to the available
    bets and the player.'
  id: totrans-1101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET` could, perhaps, repeat the previous results, showing us the last spin,
    last payout, and player''s stake. This might be part of a non-repudiation scheme;
    it returns an additional copy of a spin receipt.'
  id: totrans-1102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are two helpful class definitions for our family of WSGI applications:'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-1104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'We made a simple extension to `Callable` to make it clear that we''re going
    to define a WSGI application class. We also defined an exception that we can use
    within our WSGI applications to send back error status codes that are different
    from the generic 500 error that the `wsgiref` implementation provides for Python
    errors. Here''s the top level of the Roulette server:'
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-1106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: We defined a WSGI application that wraps the other applications. The `wsgiref.util.shift_path_info()`
    function will parse the path, breaking on `/` to get the first word. Based on
    this, we'll invoke one of three other WSGI applications. In this case, each application
    is going to be a method function within this class definition.
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
- en: 'We provided an overall exception handler that will turn any of the `RESTException`
    instances into a proper RESTful response. Exceptions that we did not catch will
    turn into generic status code 500 errors from `wsgiref`. Here''s the `player_app`
    method function:'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  id: totrans-1109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: We created a response object, `details`. We then serialized this object into
    a JSON string and further encoded that string into bytes using UTF-8.
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
- en: In the unlikely event of an attempt to Post (or Put or Delete) to the `/player/`
    path, an exception will be raised. This will be caught in the top-level `__call__()`
    method and transformed into an error response.
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the `bet_app()` function:'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  id: totrans-1113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: This does two things, depending on the request method. When a `GET` request
    is used, the result is a dictionary of current bets. When a `POST` request is
    used, there must be some data to define the bets. When any other method is attempted,
    an error is returned.
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
- en: In the `POST` case, information on the bet is provided as the data stream attached
    to the request. We have to perform several steps to read and process this data.
    The first step is to use the value of `environ['CONTENT_LENGTH']` to determine
    how many bytes to read. The second step is to decode the bytes to get the string
    value that was sent.
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
- en: We used the JSON encoding of the request. This, emphatically, is not the way
    a browser or web application server handles the `POST` data from an HTML form.
    When using a browser to post data from an HTML form, the encoding is a simple
    set of escapes, implemented by the `urllib.parse` module. The `urllib.parse.parse_qs()`
    module function will parse the encoded query string with HTML data.
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
- en: For RESTful web services, `POST` compatible data is sometimes used so that form-based
    processing is very similar to RESTful processing. In other cases, a separate encoding
    such as JSON is used to create data structures that are easier to work with than
    the quoted data produced by a web form.
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the string, `raw`, we use `json.loads()` to get the object represented
    by that string. We expect one of the two classes of objects. A simple `dict` object
    will define a single bet. A sequence of `dict` objects will define multiple bets.
    As a simple generalization, we make the single `dict` into a singleton sequence.
    We can then use the general sequence of `dict` instances to place the required
    bets.
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
- en: Note that our exception handling will leave some bets in place but will send
    an overall `403 Forbidden` message. A better design is to follow the **Memento**
    design pattern. When placing bets, we would also create a memento object that
    can be used to undo any bets. One implementation of the Memento is to use the
    **Before Image** design pattern. The Memento could include a copy of all the bets
    prior to applying a change. In the event of an exception, we can delete the damaged
    version and restore the previous one. When working with nested containers of mutable
    objects, this can be complex, because we have to be sure to make a copy of any
    mutable objects. As this application uses only immutable strings and integers,
    a shallow copy of `table.bets` will work nicely.
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
- en: For both `POST` and `GET` methods, the response is the same. We'll serialize
    the `table.bets` dictionary into JSON and send it back to the REST client. This
    will confirm that the expected bets were placed.
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
- en: 'The final part of this class is the `wheel_app()` method:'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  id: totrans-1122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: This method first checks that it is invoked with a post that supplies no data.
    Just to be sure that the socket is properly closed, all the data is read and ignored.
    This can prevent a poorly written client from crashing when the socket is closed
    with unread data.
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
- en: Once that bit of housekeeping is out of the way, the remaining processing is
    performed to develop a new spin from the wheel, resolve the various bets, and
    produce a response that includes the spin, the payout, the player's stake, and
    the number of rounds. This report is built as a `dict` object. It's then serialized
    into JSON, encoded into UTF-8, and sent back to the client.
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
- en: Note that we've avoided handling multiple players. This would add a class and
    another `POST` method under the `/player/` path. It would add a bit of definition
    and bookkeeping. The `POST` processing to create a new player would be similar
    to the processing for placing a bet. This is an interesting exercise, but it doesn't
    introduce any new programming techniques.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
- en: Creating the roulette server
  id: totrans-1126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once we have a callable `Roulette` class, we can create a WSGI server in the
    following manner:'
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  id: totrans-1128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: This function creates our Roulette WSGI application, `roulette`. It uses `wsgiref.simple_server.make_server()`
    to create a server that will use the `roulette` callable for each request.
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we've also included the `wsgiref.validate.validator()` WSGI application.
    This application validates the interface used by the roulette application; it
    decorates the various APIs with assert statements to provide some diagnostic information.
    It also produces slightly easier-to-read error messages in the event of a more
    serious programming problem in a WSGI application.
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
- en: Creating the roulette client
  id: totrans-1131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's common practice to define a module with a RESTful client API. Often, the
    client API will have functions that are specifically tailored to the requested
    services.
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of defining a specialized client, we''ll define a generic client function
    that works with a variety of RESTful servers. This might serve as the foundation
    for a Roulette-specific client. Here''s a generic client function that will work
    with our `Roulette` server:'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  id: totrans-1134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: This client makes the `GET` or `POST` requests, and it will encode the data
    for a `POST` request as a JSON document. Note that the JSON encoding of the request
    data is emphatically not the way a browser handles an HTML form's `POST` data.
    Browsers use the encoding implemented by the `urllib.parse.urlencode()` module
    function.
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
- en: 'Our client function decodes the JSON document and returns it when the status
    code is in the half-open range, ![Creating the roulette client](graphics/0971OS_12_01.jpg).
    These are the success status codes. We can exercise our client and server as follows:'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  id: totrans-1137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: First, we create `ProcessPool` as the context for the exercise. We submit a
    request to this server; in effect, the request is `roulette_server_3(4)`. Once
    the server has started, we can exercise that server.
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we made four requests. We check the player's status. We place
    a bet and then we check the bet. Finally, we spin the wheel. At each step, we
    print the JSON response documents.
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
- en: 'The log looks like this:'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  id: totrans-1141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: This shows us that our server responds to requests, creates bets on the table,
    creates random spins of the wheel, and properly updates the player with the outcomes.
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
- en: Creating a secure REST service
  id: totrans-1143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can break application security down into two considerations: authentication
    and authorization. We need to know who the user is and we need to be sure that
    the user is authorized to execute the particular WSGI application. This is handled
    relatively simply using both the HTTP `Authorization` header for credentials to
    ensure an encrypted transmission of these credentials.'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
- en: If we use SSL, we can simply use the HTTP Basic Authorization mode. This version
    of the `Authorization` header can include a username and password in each request.
    For more elaborate measures, we can use HTTP Digest Authorization, which requires
    an exchange with the server to get a piece of data called a **nonce** that's used
    to create the digest in a more secure fashion.
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
- en: Generally, we'll handle authentication as early in the process as possible.
    This means a frontend WSGI application that checks for the `Authorization` header
    and updates the environment or returns an error. Ideally, we'll be using a sophisticated
    web framework that offers us this feature. See the next section for more information
    on these web framework considerations.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps the most important advice that can possibly be offered on the subject
    of security is the following:'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Never Store Passwords**'
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
- en: The only thing that can be stored is a repeated cryptographic hash of password
    plus salt. The password itself must be unrecoverable; research fully on *Salted
    Password Hashing* or download a trusted library for this. Do not ever store a
    plaintext password or an encrypted password.
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example class that shows us how salted password hashing works:'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  id: totrans-1152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: This class defines an `Authentication` object for a given username. The object
    contains the username, a unique random salt created each time the password is
    set or reset, and the final hash of the salt plus the password. This class also
    defines a `match()` method that will determine whether a given password will produce
    the same hash as the original password.
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
- en: Note that the passwords are not stored. Only hashes of passwords are retained.
    We provided a comment ("`# Constant Time is Best`") on the comparison function.
    An algorithm that runs in constant time—and isn't particularly fast—is ideal for
    this comparison. We haven't implemented it.
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
- en: We also included an equality test and a hash test to emphasize that this object
    is immutable. We can't tweak any of the values. We can only discard and rebuild
    the entire `Authentication` object when users changes their password. An additional
    design feature would be to use `__slots__` to save storage.
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that these algorithms work with byte strings, not Unicode strings. We
    either need to work with bytes or we need to work with the ASCII encoding of a
    Unicode username or password. Here''s how we might create a collection of users:'
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  id: totrans-1157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: We created an extension to `dict` that introduces an `add()` method to save
    an `Authentication` instance and a match method that determines whether the users
    are in this dictionary and whether their credentials match.
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
- en: Note that our match needs to be a constant time comparison. We created an additional
    dummy user for a situation where an unknown username is supplied. By performing
    the match against a dummy user—which will always fail—the execution timing doesn't
    provide many hints as to what's wrong with the credentials. If we simply returned
    `False`, a mismatched username would respond faster than a mismatched password.
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
- en: 'We specifically disallowed setting the authentication for a username of `""`
    or matching a username of `""`. This will ensure that the dummy username is never
    changed to a valid entry that might possibly match, and any attempt to match it
    will always fail. Here''s a sample user that we built:'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  id: totrans-1161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'Just to see what''s going on inside this class, we can manually create a user:'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  id: totrans-1163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: The salt is a string of 24 bytes that's reset when the user's password is created
    or changed. The hash is a repeated hash of username, password, and salt.
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
- en: The WSGI Authentication application
  id: totrans-1165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once we have a way to store the users and credentials, we can examine the `Authentication`
    header in a request. Here''s a WSGI application that checks the header and updates
    the environment for validated users:'
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  id: totrans-1167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'This WSGI application contains a pool of users in addition to a a target application.
    When we create an instance of this `Authenticate` class, we''ll provide another
    WSGI application as `target_app`; this wrapped application will only see requests
    from authenticated users. When the `Authenticate` application is invoked, it performs
    several tests to be sure that the request is from an authenticated user:'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
- en: There must be an HTTP `Authorization` header. This header is saved with the
    `HTTP_AUTHORIZATION` key in the `environ` dict
  id: totrans-1169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The header must have `Basic` as the authentication scheme
  id: totrans-1170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The credentials in the Basic scheme must be base 64 encoding of `username+b":"+password`;
    this must match the credentials of one of the defined users
  id: totrans-1171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If all of these tests are passed, we can update the `environ` dict with the
    authenticated username. Then, the target application can be invoked.
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
- en: The wrapped application can then handle the authorization details knowing that
    the user is authenticated. This separation of concerns is one elegant feature
    of WSGI applications. We have put the authentication in exactly one place.
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
- en: Implementing REST with a web application framework
  id: totrans-1174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a REST web server is a web application, we can leverage any of the popular
    Python web application frameworks. Writing a RESTful server from scratch is a
    step that can be taken after demonstrating that a framework provides unacceptable
    problems. In many cases, a technical spike using a framework can help clarify
    any issues and allow a detailed comparison against a REST application written
    without a framework.
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
- en: Some of the Python web frameworks include one or more REST components. In some
    cases, the RESTful features are almost entirely built-in. In other cases, an add-on
    project can help define RESTful web services with minimal programming.
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a list of Python web frameworks: [https://wiki.python.org/moin/WebFrameworks](https://wiki.python.org/moin/WebFrameworks).
    The point of these projects is to provide a reasonably complete environment to
    build web applications.'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a list of Python web component packages: [https://wiki.python.org/moin/WebComponents](https://wiki.python.org/moin/WebComponents).
    These are bits and pieces that can be used to support web application development.'
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
- en: Searching PyPI, [https://pypi.python.org](https://pypi.python.org), for REST
    will turn up a large number of packages. Clearly, there are numerous solutions
    that are already available.
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
- en: Taking time to search, download, and learn a number of existing frameworks can
    reduce some of the development effort. Security, in particular, is challenging.
    Home-brewed security algorithms are often filled with serious deficiencies. Using
    someone else's proven security tools can have some advantages.
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
- en: Using a message queue to transmit objects
  id: totrans-1181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `multiprocessing` module uses serialization and transmission of objects,
    too. We can use queues and pipes to serialize objects that are then transmitted
    to other processes. There are numerous external projects to provide sophisticated
    message queue processing. We'll focus on the `multiprocessing` queue because it's
    built-in to Python and works nicely.
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
- en: For high-performance applications, a faster message queue may be necessary.
    It may also be necessary to use a faster serialization technique than pickling.
    For this chapter, we'll focus only on the Python design issues. The multiprocessing
    module relies on `pickle` to encode objects. See [Chapter 9](ch09.html "Chapter 9. Serializing
    and Saving – JSON, YAML, Pickle, CSV, and XML"), *Serializing and Saving – JSON,
    YAML, Pickle, CSV, and XML*, for more information. We can't provide a restricted
    unpickler easily; therefore, this module offers us some relatively simple security
    measures put into place to prevent unpickle problems.
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important design consideration when using `multiprocessing`: it''s
    generally best to avoid having multiple processes (or multiple threads) attempting
    to update shared objects. The synchronization and locking issues are so profound
    (and easy to get wrong) that the standard joke is,'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
- en: When confronted with a problem, the programmer thinks, "I'll use multiple threads."
  id: totrans-1185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Using process-level synchronization via RESTful web services or `multiprocessing`
    can prevent synchronization issues because there are no shared objects. The essential
    design principle is to look at the processing as a pipeline of discrete steps.
    Each processing step will have an input queue and an output queue; the step will
    fetch an object, perform some processing, and write the object.
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
- en: The `multiprocessing` philosophy matches the POSIX concept of a shell pipeline
    written as `process1 | process2 | process3`. This kind of shell pipeline involves
    three concurrent processes interconnected with pipes. The important difference
    is that we don't need to use STDIN, STDOUT, and explicit serialization of the
    objects. We can trust the `multiprocessing` module to handle the OS-level infrastructure.
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
- en: The POSIX shell pipelines are limited, in that each pipe has a single producer
    and a single consumer. The Python `multiprocessing` module allows us to create
    message queues that include multiple consumers. This allows us to have a pipeline
    that fans out from one source process to multiple sink processes. A queue can
    also have multiple consumers that allow us to build a pipeline where the results
    of multiple source processes can be combined by a single sink process.
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
- en: To maximize throughput on a given computer system, we need to have enough work
    pending so that no processor or core is ever left with nothing useful to do. When
    any given OS process is waiting for a resource, at least one other process should
    be ready to run.
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
- en: When looking at our casino game simulations, for example, we need to gather
    statistically significant simulation data by exercising a player strategy or betting
    strategy (or both) a number of times. The idea is to create a queue of processing
    requests so that our computer's processors (and cores) are fully engaged in processing
    our simulations.
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
- en: Each processing request can be a Python object. The `multiprocessing` module
    will pickle that object so that it is transmitted via the queue to another process.
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
- en: We'll revisit this in [Chapter 14](ch14.html "Chapter 14. The Logging and Warning
    Modules"), *The Logging and Warning Modules*, when we look at how the `logging`
    module can use `multiprocessing` queues to provide a single, centralized log for
    separate producer processes. In these examples, the objects transmitted from process
    to process will be the `logging.LogRecord` instances.
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
- en: Defining processes
  id: totrans-1193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We must design each processing step as a simple loop that gets a request from
    a queue, processes that request, and places the results into another queue. This
    decomposes the larger problem into a number of stages that form a pipeline. As
    each of these stages will run concurrently, the system resource use will be maximized.
    Furthermore, as the stages involve simple gets and puts into independent queues,
    there's no issue with complex locking or shared resources. A process can be a
    simple function or a callable object. We'll focus on defining processes as subclasses
    of `multiprocessing.Process`. This gives us the most flexibility.
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
- en: 'For the simulation of our casino game, we can break the simulation down into
    a three-step pipeline:'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
- en: An overall driver puts simulation requests into a processing queue.
  id: totrans-1196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A pool of simulators will get a request from the processing queue, perform the
    simulation, and put the statistics into a results queue.
  id: totrans-1197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A summarizer will get the results from the results queue and create a final
    tabulation of the results.
  id: totrans-1198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a process pool allows us to have as many simulations running concurrently
    as our CPU can handle. The pool of simulators can be configured to ensure that
    simulations run as quickly as possible.
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a definition of the simulator process:'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  id: totrans-1201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'We''ve extended `multiprocessing.Process`. This means that we must do two things
    to work properly with multiprocessing: we must assure that `super().__init__()`
    is executed, and we must override `run()`.'
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the body of `run()`, we''re using two queues. The `setup_queue` queue
    instance will contain two-tuples of the `Table` and `Player` objects. The process
    will use these two objects to run a simulation. It will put the resulting three-tuple
    into `result_queue` queue instance. The API for the `Simulate` class is this:'
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  id: totrans-1204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'The iterator will yield the requested number, `samples`, of statistical summaries.
    We''ve included a provision for a **sentinel object** to arrive via `setup_queue`.
    This object will be used to gracefully close down the processing. If we don''t
    use a sentinel object, we''re forced to terminate the processes, which can disrupt
    locks and other system resources. Here''s the summarization process:'
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  id: totrans-1206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: This also extends `multiprocessing.Process`. In this case, we're fetching items
    from a queue and simply counting them. A more useful process might use several
    `collection.Counter` objects to accumulate more interesting statistics.
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
- en: As with the `Simulation` class, we're also going to detect a sentinel and gracefully
    close down the processing. The use of a sentinel object allows us to close down
    processing as soon as the work is completed by the process. In some applications,
    the child process can be left running indefinitely.
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
- en: Building queues and supplying data
  id: totrans-1209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Building queues involves creating instances of `multiprocessing.Queue` or one
    of its subclasses. For this example, we can use the following:'
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  id: totrans-1211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'We created two queues that define the processing pipeline. When we put a simulation
    request into `setup_q`, we expect that a `Simulation` process will pick up the
    request pair and run the simulation. This should generate a results three-tuple
    of table, player and results in the `results_q` Queue. in `results_q`. The results
    triple should, in turn, lead to work being done by the `Summarize` process. Here''s
    how we can start a single `Summarize` process:'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  id: totrans-1213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'Here''s how we can create four concurrent simulation processes:'
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  id: totrans-1215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'The four concurrent simulators will be competing for work. Each one will be
    attempting to grab the next request from the queue of pending requests. Once all
    four simulators are busy working, the queue will start to get filled with unprocessed
    requests. Once the queues and processes are waiting, the driver function can start
    putting requests into the `setup_q` queue. Here''s a loop that will generate a
    flood of requests:'
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  id: totrans-1217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'We created a `Table` object. For each of the three betting strategies, we created
    a `Player` object, and then queued up a simulation request. The pickled two-tuple
    will be fetched from the queue by the `Simulation` object and then it will be
    processed. In order to have an orderly termination, we''ll need to queue sentinel
    objects for each simulator:'
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  id: totrans-1219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: We put a sentinel object into the queue for each simulator to consume. Once
    all the simulators have consumed the sentinels, we can wait for the processes
    to finish execution and join back into the parent process.
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the `Process.join()` operation is finished, no more simulation data will
    be created. We can enqueue a sentinel object into the simulation results queue
    as well:'
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  id: totrans-1222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: Once the results sentinel object is processed, the `Summarize` process will
    stop accepting input and we can `join()` it as well.
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
- en: We used multiprocessing to transmit objects from one process to another. This
    gives us a relatively simple way to create high-performance, multi-processing
    data pipelines. The `multiprocessing` module uses `pickle`, so there are few limitations
    on the nature of objects that can be pushed through the pipelines.
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-1225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We looked at transmitting and sharing objects using RESTful web services and
    the `wsgiref` module, as well as the `multiprocessing` module. Both of these architectures
    provide for communicating a representation of an object's state. In the case of
    `multiprocessing`, pickle is used to represent the state. In the case of building
    RESTful web services, we have to choose the representation(s) used. In the examples
    used here, we focused on JSON because it's widely used and has a simple implementation.
    Many frameworks will offer simple implementations of XML as well.
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
- en: Performing RESTful web services using a WSGI application framework formalizes
    the process of receiving HTTP requests, deserializing any objects, performing
    the requested processing, serializing any results, and providing a response. Because
    WSGI applications have a simple, standardized API, we can easily create composite
    applications and write wrapper applications. We can often leverage wrapper applications
    to handle the authentication elements of security in a simple, consistent manner.
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at using `multiprocessing` to enqueue and dequeue messages from
    shared queues. The beauty of using message queues is that we can avoid the locking
    problems associated with concurrent updates to shared objects.
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
- en: Design considerations and trade-offs
  id: totrans-1229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We must also decide what grain of objects to make available and how to identify
    those objects with sensible URIs. With larger objects, we can easily achieve ACID
    properties. However, we may also be uploading and downloading too much data for
    our application''s use cases. In some cases, we''ll need to provide alternative
    levels of access: large objects to support ACID properties, small objects to allow
    rapid response when a client application wants a subset of the data.'
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
- en: To implement more localized processing, we can leverage the `multiprocessing`
    module. This is focused more on building high-performance processing pipelines
    within a trusted host or network of hosts.
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, the two design patterns are combined so that a RESTful request
    is handled by a multiprocessing pipeline. A conventional web server (such as Apache
    HTTPD) working through the `mod_wsgi` extension can use multiprocessing techniques
    to pass a request through a named pipe from the Apache frontend to the WSGI application
    backend.
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
- en: Schema evolution
  id: totrans-1233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working with a public-facing API for RESTful services, we have to address
    the schema evolution problem. If we change a class definition, how will we change
    the response messages? If the external RESTful API must change for compatibility
    with other programs, how do we upgrade the Python web services to support a changing
    API?
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
- en: Often, we'll have to provide a major release version number as part of our API.
    This might be provided explicitly as part of the path, or implicitly via data
    fields included in the `POST`, `PUT`, and `DELETE` requests.
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
- en: We need to distinguish between changes that don't alter the URI paths or responses
    and changes that will alter a URI or response. Minor changes to functionality
    will not change a URI or the structure of a response.
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
- en: Changes to the URIs or the structure of a response may break an existing application.
    These are major changes. One way to make an application work gracefully through
    schema upgrades is to include version numbers in the URI paths. For example, `/roulette_2/wheel/`
    specifically names the second release of the roulette server.
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
- en: Application software layers
  id: totrans-1238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because of the relative sophistication available when using `sqlite3`, our application
    software must become more properly layered. For a REST client, we might look at
    a software architecture with layers.
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
- en: When we are building a RESTful server, the presentation layer becomes greatly
    simplified. It is pared down to the essential request-response processing. It
    parses URIs and responds with documents in JSON or XML (or some other representation.)
    This layer should be reduced to a thin RESTful facade over the lower level features.
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
- en: In some complex cases, the front-most application—as viewed by human users—involves
    data from several distinct sources. One easy way to integrate data from diverse
    sources is to wrap each source in a RESTful API. This provides us with a uniform
    interface over distinct sources of data. It allows us to write applications that
    gather these diverse kinds of data in a uniform way.
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
- en: Looking forward
  id: totrans-1242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the next chapter, we'll use persistence techniques to handle configuration
    files. A file that's editable by humans is the primary requirement for the configuration
    data. If we use a well-known persistence module, then our application can parse
    and validate the configuration data with less programming on our part.
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 13. Configuration Files and Persistence
  id: totrans-1244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A configuration file is a form of object persistence. It contains a serialized,
    editable representation of some default state for an application program or server.
    We'll expand on our serialization techniques for the object representation shown
    in [Chapter 9](ch09.html "Chapter 9. Serializing and Saving – JSON, YAML, Pickle,
    CSV, and XML"), *Serializing and Saving – JSON, YAML, Pickle, CSV, and XML* to
    create configuration files.
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to having a plain-text editable configuration file, we must also
    design our application to be configurable. Further, we must define some kind of
    configuration object (or collection) that our application can use. In many cases,
    we''ll have a series of default values that include system-wide defaults and user-specific
    overrides to those defaults. We''ll look at six representations for the configuration
    data:'
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
- en: INI files use a format that was pioneered as part of Windows. It's popular in
    part because it is an incumbent format, and many other configuration files might
    use this notation.
  id: totrans-1247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PY files are plain-old Python code. This has numerous advantages because of
    the familiarity and simplicity of working with it.
  id: totrans-1248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON or YAML are both designed to be human-friendly and easy to edit.
  id: totrans-1249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Property files are often used in a Java environment. They're relatively easy
    to work and are also designed to be human-friendly.
  id: totrans-1250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XML files are popular but are wordy and are sometimes difficult to edit properly.
    The Mac OS uses an XML-based format called a property list or the `.plist` file.
  id: totrans-1251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these forms offers us some advantages and some disadvantages. There's
    no single technique that's the best. In many cases, the choice is based on compatibility
    with other software or familiarity with another format in the user community.
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
- en: Configuration file use cases
  id: totrans-1253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two configuration file use cases. Sometimes, we can stretch the definition
    a bit to add a third use case. The first two should be pretty clear:'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
- en: A person needs to edit a configuration file
  id: totrans-1255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A piece of software will read a configuration file and make use of the options
    and arguments to tailor its behavior
  id: totrans-1256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration files are rarely the *primary* input to an application program.
    The big exception is a simulation where the configuration might be the primary
    input. In most other cases, the configuration isn't primary. For example, a web
    server's configuration file might tailor the behavior of the server, but the web
    requests are one primary input, and a database or filesystem is the other primary
    input. In the case of a GUI application, the user's interactive events are one
    input, and files or database may be another input; a configuration file may fine-tune
    the application.
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
- en: There's a blurry edge to this distinction between primary and configuration
    input. Ideally, an application has one behavior irrespective of the configuration
    details. Pragmatically, however, the configuration might introduce additional
    strategies or states to an existing application, changing its behavior. In this
    case, the configuration can straddle the line and become part of the code, not
    merely a configuration to a fixed code base.
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
- en: 'A possible third use case is to save a configuration back to a file after an
    application has updated it. This use of persistent stateful objects is atypical
    because the configuration file has morphed into a primary input in which the program
    is saving its operating state. This use case may indicate that two things have
    been conflated into a single file: configuration parameters and the persistent
    operating state. It''s better to design this as a persistent state that uses a
    human-readable format.'
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
- en: 'A configuration file can provide a number of kinds of arguments and parameter
    values to an application. We need to look a little more deeply at some of these
    various kinds of data to decide how to represent them best:'
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
- en: Default values
  id: totrans-1261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Device names, which may overlap with the filesystem's location
  id: totrans-1262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filesystem locations and search paths
  id: totrans-1263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limits and boundaries
  id: totrans-1264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message templates and data format specifications
  id: totrans-1265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message text, possibly translated for internationalization
  id: totrans-1266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network names, addresses, and port numbers
  id: totrans-1267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional behaviors
  id: totrans-1268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security keys, tokens, usernames, passwords
  id: totrans-1269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Value domains:'
  id: totrans-1270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These values are values of relatively common types: strings, integers, and
    floating-point numbers. All of those values have a tidy textual representation
    that''s relatively easy for a person to edit. They''re also straightforward for
    our Python applications to parse the human input.'
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, we may have lists of values. For example, a domain of values
    or a path might be a collection of simpler types. Often, this is a simple sequence
    or a sequence of tuples. A dict-like mapping is often used for message texts so
    that an application's software key can be mapped to customized natural language
    wording.
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one additional configuration value that isn''t a simple type with
    a tidy text representation. We could add this bullet to the preceding list:'
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional features, plugins, and extensions that are code:'
  id: totrans-1274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is challenging because we''re not necessarily providing a simple string
    value to the application. The configuration provides an object that the application
    will use. When the plugin has more of Python code, we can provide the path to
    an installed Python module as it would be used in an `import` statement using
    this dotted name: ''`package.module.object`''. An application can then perform
    the expected ''`from package.module import object`'' code and use the given class
    or function.'
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
- en: 'For non-Python code, we have two other techniques to import the code in a way
    it can be used:'
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
- en: For binaries that aren't proper executable programs, we can try to use the `ctypes`
    module to call defined API methods
  id: totrans-1277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For binaries that are executable programs, the `subprocess` module gives us
    ways to execute them
  id: totrans-1278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both of these techniques aren't about Python specifically and push the edge
    of the envelope for this chapter. We'll focus on the core issue of getting the
    arguments or the parameter values. How these values are used is a very large topic.
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
- en: Representation, persistence, state, and usability
  id: totrans-1280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When looking at a configuration file, we''re looking at a human-friendly version
    of the state of one or more objects. When we edit a configuration file, we''re
    changing the persistent state of an object that will get reloaded when the application
    is started (or restarted.) We have two common ways to look at a configuration
    file:'
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
- en: A mapping or a group of mappings from parameter names to values
  id: totrans-1282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A serialized object that's more than a simple mapping
  id: totrans-1283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we try to reduce a configuration file to a mapping, we might be limiting
    the scope of relationships that may exist within the configuration. In a simple
    mapping, everything must be referred to by a name, and we have to work through
    the same key design issues that we looked at in [Chapter 10](ch10.html "Chapter 10. Storing
    and Retrieving Objects via Shelve"), *Storing and Retrieving Objects via Shelve*,
    and [Chapter 11](ch11.html "Chapter 11. Storing and Retrieving Objects via SQLite"),
    *Storing and Retrieving Objects via SQLite*, when talking about the keys for `shelve`
    and `sqlite`. We provide a unique name in one part of a configuration so that
    other parts can refer to it properly.
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
- en: It's helpful to look at the `logging` configuration for examples of how it can
    be very challenging to configure a complex system. The relationships among Python
    logging objects—loggers, formatters, filters, and handlers—must all be bound together
    to create usable loggers. Section 16.8 of *Standard Library Reference* shows us
    two different syntaxes for the logging configuration files. We'll look at logging
    in [Chapter 14](ch14.html "Chapter 14. The Logging and Warning Modules"), *The
    Logging and Warning Modules*.
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, it may be simpler to serialize complex Python objects or resort
    to using Python code directly as the configuration file. If a configuration file
    adds too much complexity, then it may not be of any real value.
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
- en: Application configuration design patterns
  id: totrans-1287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two core design patterns for the application configuration:'
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
- en: '**Global property map**: A global object will contain all of the configuration
    parameters. This can be either a map of `name:value` pairs, or a big namespace
    object of attribute values. This may follow a **Singleton** design pattern to
    ensure that only one instance exists.'
  id: totrans-1289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Object Construction**: Instead of a single object, we''ll define a kind of
    **Factory** or collection of **Factories** that use the configuration data to
    build the objects of the application. In this case, the configuration information
    is used once when a program is started and never again. The configuration information
    isn''t kept around as a global object.'
  id: totrans-1290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The global property map design is very popular because it is simple and extensible.
    We might have an object as simple as the following code:'
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  id: totrans-1292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'We can use the preceding class definition as a global container of attributes.
    During the initialization, we might have something like this as part of parsing
    a configuration file:'
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  id: totrans-1294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: Everywhere else in the program, we can use the value of `Configuration.some_attribute`.
    A variation on this theme is to make a more formal **Singleton** object design
    pattern. This is often done with a global module, as that can be easily imported
    in a way that provides us with an accessible global definition.
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
- en: 'We might have a module named `configuration.py`. In that file, we can have
    a definition like the following:'
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  id: totrans-1297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: Now, the application can use `configuration.settings` as a global repository
    for all of the application's settings. A function or class can parse the configuration
    file, loading this dictionary with the configuration values that the application
    will then use.
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
- en: 'In a Blackjack simulation, we might see code like the following:'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  id: totrans-1300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'Or, we might possibly see code like the following one:'
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  id: totrans-1302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: Often, we'll try to avoid having a global variable. Because a global variable
    is implicitly present everywhere, it can be overlooked. Instead of a global variable,
    we can often handle the configuration slightly more neatly through object construction.
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
- en: Configuring via object construction
  id: totrans-1304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When configuring an application via object construction, the objective is to
    build the required objects. In effect, the configuration file defines the various
    initialization parameters for the objects that will be built.
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
- en: We can often centralize much of this kind of initial object construction in
    a single, overall the `main()` function. This will create the objects that do
    the real work of the application. We'll revisit and expand on these design issues
    in [Chapter 16](ch16.html "Chapter 16. Coping With the Command Line"), *Coping
    with the Command Line*.
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a simulation of Blackjack playing and betting strategies. When we
    run a simulation, we want to gather the performance of a particular combination
    of independent variables. These variables might include some casino policies including
    the number of decks, table limits, and dealer rules. The variables might include
    the player''s game strategies for when to hit, stand, split, and double down.
    It would also include the player''s betting strategies of flat betting, Martingale
    betting, or some more Byzantine betting system. Our baseline code starts out something
    like the following code:'
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  id: totrans-1308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: This is a kind of technology spike that has hardcoded all of the object classes
    and initial values. We'll need to add configuration parameters to determine the
    classes of objects and their initial values.
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Simulate` class has an API that looks like the following code:'
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  id: totrans-1311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: This allows us to build the `Simulate()` object with some appropriate initialization
    parameters. Once we've built an instance of `Simulate()`, we can iterate through
    that object to get a series of statistical summary objects.
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
- en: The interesting part is using the configuration parameters instead of class
    names. For example, some parameter should be used to decide whether to create
    an instance of `Hit17` or `Stand17` for the `dealer_rule` value. Similarly, the
    `split_rule` value should be a choice among several classes that embody several
    different split rules used in casinos.
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
- en: In other cases, parameters should be used to provide arguments to the class
    `__init__()` method. For example, the number of decks, the house betting limit,
    and the Blackjack payout values are configuration values used to create the `Table`
    instance.
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the objects are built, they interact normally via the `Simulate.run()`
    method to produce statistical output. No further need of a global pool of parameters
    is required: the parameter values are bound into the objects via their instance
    variables.'
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
- en: The object construction design is not as simple as a global property map. It
    has the advantage of avoiding a global variable, and it also has the advantage
    of making the parameter processing central and obvious in some main factory function.
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
- en: Adding new parameters when using object construction may lead to refactoring
    the application to expose a parameter or a relationship. This can make it seem
    more complex than a global mapping from name to value.
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
- en: One significant advantage of this technique is the removal of the complex `if`
    statements deep within the application. Using the `Strategy` design patterns tends
    to push decision making forward into object construction. In addition to simplifying
    the processing, the elimination of the `if` statements can be a performance boost.
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a configuration hierarchy
  id: totrans-1319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We often have several choices on where a configuration file should be placed.
    There are five common choices, and we can use all five to create a kind of inheritance
    hierarchy for the parameters:'
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
- en: '**The application''s installation directory**: In effect, these are analogous
    to base class definitions. There are two subchoices here. Smaller applications
    can be installed in Python''s library structure; an initialization file too can
    be installed there. Larger applications will often have their own username that
    owns one or more installation directory trees.'
  id: totrans-1321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Python installation directory**: We can find the installed location for a
    module using the `__file__` attribute of the module. From here, we can use `os.path.split()`
    to locate a configuration file:'
  id: totrans-1322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE192]'
  id: totrans-1323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '**Application installation directory**: This will be based on an owning username,
    so we can use `~theapp/` and `os.path.expanduser()` to track down the configuration
    defaults.'
  id: totrans-1324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A system-wide configuration directory**: This is often present in `/etc`.
    This can be transformed into `C:\etc` on Windows. Alternatives include the value
    of `os.environ[''WINDIR'']` or `os.environ[''ALLUSERSPROFILE'']`.'
  id: totrans-1325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The current user''s home directory**: We can generally use `os.path.expanduser()`
    to translate `~/` into the user''s home directory. For Windows, Python will properly
    use the `%HOMEDRIVE%` and `%HOMEPATH%` environment variables.'
  id: totrans-1326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The current working directory**: The directory is usually known as `./`,
    although `os.path.curdir` is more portable.'
  id: totrans-1327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A file named in the command-line parameters**: This is an explicitly named
    file and no further processing should be done to the name.'
  id: totrans-1328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An application can integrate configuration options from all of these sources
    from the base class (listed first) to the command-line options. In this way, the
    installation default values are the most generic and least user-specific; these
    values can be overridden by more specific and less-generic values.
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that we''ll often have a list of files like the following code:'
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  id: totrans-1331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: We've taken a tuple of alternative file directories and created a list of candidate
    filenames by joining the directory with the configuration filename.
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have this list of configuration filenames, we can append any filename
    supplied via the command-line arguments to the end of the list with the following
    code:'
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  id: totrans-1334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: This gives us a list of locations that we can examine to locate a configuration
    file or configuration defaults.
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
- en: Storing the configuration in the INI files
  id: totrans-1336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The INI file format has historical origins from early Windows OS. The module
    to parse these files is `configparser`.
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
- en: 'For additional details on the INI file, see this Wikipedia article: [http://en.wikipedia.org/wiki/INI_file](http://en.wikipedia.org/wiki/INI_file).'
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
- en: 'An INI file has sections and properties within each section. Our sample main
    program has three sections: the table configuration, player configuration, and
    overall simulation data gathering.'
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
- en: 'We can imagine an INI file that looks like the following code:'
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  id: totrans-1341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: We've broken the parameters into three sections. Within each section, we've
    provided some named parameters that correspond to the class names and initialization
    values shown in our preceding model application initialization.
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
- en: 'A single file can be parsed very simply:'
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  id: totrans-1344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: We've created an instance of the parser and provided the target configuration
    filename to that parser. The parser will read the file, locate the sections, and
    locate the individual properties within each section.
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
- en: If we want to support multiple locations for files, we can use `config.read(config_names)`.
    When we provide the list of filenames to `ConfigParser.read()`, it will read the
    files in an order. We want to provide the files from the most generic first to
    the most specific last. The generic configuration files that are part of the software
    installation will be parsed first to provide defaults. The user-specific configuration
    will be parsed later to override these defaults.
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve parsed the file, we need to make use of the various parameters
    and settings. Here''s a function that constructs our objects based on a given
    configuration object created by parsing the configuration files. We''ll break
    this into three parts. Here''s the part that builds the `Table` instance:'
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  id: totrans-1348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'We''ve used properties from the `[table]` section of the INI file to select
    class names and provide initialization values. There are three broad kinds of
    cases here:'
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
- en: '**Mapping string to a class name**: We''ve used a mapping to look up an object
    based on a string class name. This was done to create `dealer_rule` and `split_rule`.
    If this was subject to considerable change, we might be able to extract this mapping
    into a separate factory function.'
  id: totrans-1350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Getting a value that ConfigParser can parse for us**: The class can directly
    handle `str`, `int`, `float`, and `bool`. The class has a sophisticated mapping
    from string to Boolean, using a wide variety of common code and synonyms for `True`
    and `False`.'
  id: totrans-1351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Evaluating something that''s not built-in**: In the case of `payout`, we
    had a string value, `''(3,2)''`, that is not a directly supported data type for
    `ConfigParser`. We have two choices to handle this. We can try and parse it ourselves,
    or we can insist that the value be a valid Python expression and make Python do
    this. In this case, we''ve used `eval()`. Some programmers call this a *security
    problem*. The next section deals with this.'
  id: totrans-1352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the second section of this example, which uses properties from the
    `[player]` section of the INI file to select classes and argument values:'
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  id: totrans-1354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: This uses string-to-class mapping as well as built-in data types. It initializes
    two strategy objects and then creates `Player` from those two strategies plus
    two integer configuration values.
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the final section; this creates the overall simulator:'
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  id: totrans-1357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: We've used two parameters from the `[simulator]` section that are outside the
    narrow confines of object creation. The `outputfile` property is used to name
    a file; the `samples` property is provided as an argument to a method function.
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
- en: Handling more literals via the eval() variants
  id: totrans-1359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A configuration file may have values of types that don't have simple string
    representations. For example, a collection might be provided as a `tuple` or `list`
    literal; a mapping might be provided as a `dict` literal. We have several choices
    to handle these more complex values.
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
- en: The choices resolve around an issue of how much Python syntax the conversion
    is able to tolerate. For some types (`int`, `float`, `bool`, `complex`, `decimal.Decimal`,
    `fractions.Fraction`), we can safely convert the string to a literal value because
    the object `__init__()` for these types handle string values without tolerating
    any additional Python syntax.
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
- en: 'For other types, however, we can''t simply do the string conversion. We have
    several choices on how to proceed:'
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
- en: Forbid these data types and rely on the configuration file syntax plus processing
    rules to assemble complex Python values from very simple parts. This is tedious
    but can be made to work.
  id: totrans-1363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `ast.literal_eval()` as it handles many cases of Python literal values.
    This is often the ideal solution.
  id: totrans-1364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `eval()` to simply evaluate the string and create the expected Python object.
    This will parse more kinds of objects than `ast.literal_eval()`. Is this level
    of generality really needed?
  id: totrans-1365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `ast` module to compile and vet the resulting code object. This vetting
    process can check for the `import` statements as well as use some small set of
    permitted modules. This is quite complex; if we're effectively allowing code,
    perhaps we should be designing a framework instead of an application with a configuration
    file.
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
- en: In the case where we are performing RESTful transfers of Python objects through
    the network, `eval()` of the resulting text absolutely cannot be trusted. See
    [Chapter 9](ch09.html "Chapter 9. Serializing and Saving – JSON, YAML, Pickle,
    CSV, and XML") - *Serializing and Saving - JSON, YAML, Pickle, CSV and XML*.
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
- en: In the case of reading a local configuration file, however, `eval()` may be
    usable. In some cases, the Python code is as easily modified as the configuration
    file. Worrying about `eval()` may not be helpful when the base code can be tweaked.
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we use `ast.literal_eval()` instead of `eval()`:'
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  id: totrans-1370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: This broadens the domain of possible values in a configuration file. It doesn't
    allow arbitrary objects, but it allows a broad spectrum of literal values.
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
- en: Storing the configuration in PY files
  id: totrans-1372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The PY file format means using Python code as the configuration file as well
    as the language to implement the application. We will have a configuration file
    that's simply a module; the configuration is written in the Python syntax. This
    removes the need to parse the module.
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Python gives us a number of design considerations. We have two overall
    strategies to use Python as the configuration file:'
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
- en: '**A top-level script**: In this case, the configuration file is simply the
    top-most main program'
  id: totrans-1375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**An exec() import**: In this case, our configuration file provides parameter
    values that are collected into module global variables'
  id: totrans-1376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can design a top-level script file that looks like the following code:'
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  id: totrans-1378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: This shows us our various configuration parameters that are used to create and
    initialize objects. We've simply written the configuration parameters directly
    into the code. We've factored out the processing into a separate function, `simulate()`.
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
- en: One potential disadvantage of using Python as the configuration language is
    the potential complexity of the Python syntax. This is usually an irrelevant problem
    for two reasons. First, with some careful design, the syntax of the configuration
    should be simple assignment statements with a few `()` and `,`. Second, and more
    important, other configuration files have their own complex syntax, distinct from
    the Python syntax. Using a single language with a single syntax is a reduction
    in the complexity.
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
- en: 'The `simulate()` function is imported from the overall `simulator` application.
    This `simulate()` function might look like the following code:'
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  id: totrans-1382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: This function is generic with respect to the table, player, filename, and number
    of samples.
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
- en: 'The difficulty with this kind of configuration technique is the lack of handy
    default values. The top-level script must be complete: *all* of the configuration
    parameters must be present. It can be tiresome to provide all of the values; why
    provide default values that are rarely changed?'
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, this is not a limitation. In the cases where default values are
    important, we'll look at two ways around this limitation.
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
- en: Configuration via class definitions
  id: totrans-1386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The difficulty that we sometimes have with top-level script configuration is
    the lack of handy default values. To provide defaults, we can use ordinary class
    inheritance. Here''s how we can use the class definition to build an object with
    the configuration values:'
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  id: totrans-1388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: This allows us to define `Default_App` with a default configuration. The class
    that we've defined here can be reduced to providing only override values from
    the `Default_App` version.
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
- en: We can also use mixins to break the definition down into reusable pieces. We
    might break our classes down into the table, player, and simulation components
    and combine them via mixins. For more information on the mixin class design, see
    [Chapter 8](ch08.html "Chapter 8. Decorators and Mixins – Cross-cutting Aspects"),
    *Decorators and Mixins – Cross-cutting Aspects*.
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
- en: In two small ways, this use of a class definition pushes the envelope. There
    are no method definitions; we're only going to use this class to define one instance.
    However, it is a very tidy way to pack up a small block of code so that the assignment
    statements fill in a small namespace.
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
- en: 'We can modify our `simulate()` function to accept this class definition as
    an argument:'
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  id: totrans-1393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'This function has picked out the relevant values from the overall configuration
    object and used them to build a `Simulate` instance and execute that instance.
    The results are the same as the previous `simulate()` function, but the argument
    structure is different. Here''s how we provide the single instance of the class
    to this function:'
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  id: totrans-1395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: One small disadvantage of this approach is that it is not compatible with `argparse`
    to gather command-line arguments. We can solve this by using a `types.SimpleNamespace`
    object.
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
- en: Configuration via SimpleNamespace
  id: totrans-1397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using a `types.SimpleNamespace` object allows us to simply add attributes as
    needed. This will be similar to using a class definition. When defining a class,
    all of the assignment statements are localized to the class. When creating a `SimpleNamespace`
    object, we''ll need to explicitly qualify every name with the `NameSpace` object
    that we''re populating. Ideally, we can create `SimpleNamespace` like the following
    code:'
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  id: totrans-1399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'This works delightfully well if all of the configuration values are independent
    of each other. In our case, however, we have some complex dependencies among configuration
    values. We can handle this in one of the following two ways:'
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
- en: We can provide only the independent values and leave it to the application to
    build the dependent values
  id: totrans-1401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can build the values in the namespace incrementally
  id: totrans-1402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To create only the independent values, we might do something like this:'
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  id: totrans-1404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: Here, we created `SimpleNamespace` with the six independent values for the configuration.
    Then, we updated the configuration to add two more values that are dependent on
    four of the independent values.
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
- en: 'The `config5a` object is nearly identical to the object that was created by
    evaluating `Example4()` in the preceding example . The base class is different,
    but the set of attributes and their values are identical. Here''s the alternative,
    where we build the configuration incrementally in a top-level script:'
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  id: totrans-1407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: The same `simulate_c()` function shown previously can be used for this kind
    of configuration.
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
- en: 'Sadly, this suffers from the same problem as configuration via a top-level
    script. There''s no handy way to provide default values to a configuration object.
    We might want to have a factory function that we can import, which creates `SimpleNamespace`
    with the appropriate default values:'
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  id: totrans-1410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: If we used something like the preceding code, then we could have the default
    values assigned by the factory function, `make_config()`. Each user-supplied configuration
    could then provide only the necessary overrides to the default values.
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
- en: 'Our default-supplying `make_config()` function would have the following kind
    of code:'
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  id: totrans-1413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 'The `make_config()` function would build a default configuration through a
    sequence of assignment statements. An application can then set only the interesting
    *override* values:'
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  id: totrans-1415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: 'This allows the application to build the configuration and then use it in a
    relatively simple way. The main script is quite short and to the point. If we
    use keyword arguments, we can easily make this more flexible:'
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  id: totrans-1417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'This allows us to create a configuration including the overrides like this:'
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  id: totrans-1419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: This is slightly shorter and seems to retain the clarity of the previous example.
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
- en: All of the techniques from [Chapter 1](ch01.html "Chapter 1. The __init__()
    Method"), *The __init__() Method*, apply to the definition of this kind of configuration
    factory function. We can build in a great deal of flexibility if we need to. This
    has the advantage of fitting nicely with the way that the `argparse` module parses
    command-line arguments. We'll expand on this in [Chapter 16](ch16.html "Chapter 16. Coping
    With the Command Line"), *Coping with the Command Line*
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
- en: Using Python with exec() for the configuration
  id: totrans-1422
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we decide to use Python as the notation for a configuration, we can use
    the `exec()` function to evaluate a block of code in a constrained namespace.
    We can imagine writing configuration files that look like the following code:'
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  id: totrans-1424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'This is a pleasant, easy-to-read set of configuration parameters. It''s similar
    to an INI file and a property file that we''ll look at in the following section.
    We can evaluate this file, creating a kind of namespace, with the `exec()` function:'
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  id: totrans-1426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: In this example, we decided to explicitly build a code object with the `compile()`
    function. This isn't required; we can simply provide the text of the file to the
    `exec()` function and it will compile the code.
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
- en: 'The call to `exec()` provides three arguments: the code, a dictionary that
    should be used to resolve any global names, and a dictionary that will be used
    for any locals that get created. When the code block is finished, the assignment
    statements will have been used to build values in the local dictionary; in this
    case, the `config` variable. The keys will be the variable names.'
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then use this to build objects during the program''s initialization.
    We pass the necessary objects to the `simulate()` function to perform the simulation.
    The `config` variable will get all the local assignments and will have a value
    like the following code:'
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  id: totrans-1430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'However, the initialization must be a written dictionary notation: `config[''table'']`,
    `config[''player'']`.'
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
- en: 'As the dictionary notation is inconvenient, we''ll use a design pattern based
    on ideas from [Chapter 3](ch03.html "Chapter 3. Attribute Access, Properties,
    and Descriptors"), *Attribute Access, Properties, and Descriptors*. This is a
    class that provides named attributes based on the keys of a dictionary:'
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  id: totrans-1433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: 'This class can only work if the keys are proper Python variable names. Interestingly,
    this is all that can be created by the `exec()` function if we initialize the
    `config` variable this way:'
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  id: totrans-1435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: 'Then, we can use a simpler attribute notation, `config.table`, `config.player`,
    for doing the initial object construction and initialization. This little bit
    of syntactic sugar can be helpful in a complex application. An alternative is
    to define this class:'
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  id: totrans-1437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'We can then do this to convert a simple `dict` to an object with pleasant,
    named attributes:'
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  id: totrans-1439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: This will convert `dict` to an object with easy-to-use attribute names. This
    only works, of course, if the dictionary keys are already Python variable names.
    It's also limited to structures that are flat. This won't work for nested dictionary-of-dictionary
    structures that we see with other formats.
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
- en: Why is exec() a nonproblem?
  id: totrans-1441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous section has a discussion on `eval()`. The same considerations apply
    to `exec()`.
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
- en: Generally, the set of available `globals()` is tightly controlled. Access to
    the `os` module or the `__import__()` function can be eliminated by removing them
    from the globals provided to `exec()`.
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
- en: If you have an evil programmer who will cleverly corrupt the configuration files,
    recall that they have complete access to all Python source. Why would they waste
    time cleverly tweaking configuration files when they can just change the application
    code itself?
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
- en: 'One common question is this: "What if someone thinks they can monkey patch
    a broken application by forcing new code in via the configuration file?" This
    person is just as likely to break the application into a number of other equally
    clever/deranged ways. Avoiding Python configuration files won''t stop the unscrupulous
    programmer from breaking things by doing something that''s ill-advised. There
    are a myriad of potential weaknesses; needless worrying about `exec()` may not
    be beneficial.'
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, it may be necessary to change the overall philosophy. An application
    that's highly customizable might actually be a general framework, not a tidy,
    finished application.
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
- en: Using ChainMap for defaults and overrides
  id: totrans-1447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll often have a configuration file hierarchy. Previously, we listed several
    locations where configuration files can be installed. The `configparser` module,
    for example, is designed to read a number of files in an order and integrate the
    settings by having later files override values from earlier files.
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
- en: We can implement an elegant default-value processing using the `collections.ChainMap`
    class. See [Chapter 6](ch06.html "Chapter 6. Creating Containers and Collections"),
    *Creating Containers and Collections*, for some background on this class. We'll
    need to keep the configuration parameters as `dict` instances, which is something
    that works out well using `exec()` to evaluate Python-language initialization
    files.
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
- en: Using this will require us to design our configuration parameters as a flat
    dictionary of values. This may be a bit of a burden for applications with a large
    number of complex configuration values that are integrated from several sources.
    We'll show you a sensible way to flatten names.
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll build a list of files based on the standard locations:'
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  id: totrans-1452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 'We started with a list of directories: the installation directory, a system
    global directory, a user''s home directory, and the current working directory.
    We put the configuration filename into each directory and then confirmed that
    the file actually exists.'
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the names of the candidate files, we can build `ChainMap` by folding
    each file in:'
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  id: totrans-1455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: Each file involves creating a new, empty map that can be updated with local
    variables. The `exec()` function will add the file's local variables to the empty
    map created by `new_child()`. Each new child is more localized, overriding previously
    loaded configurations.
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
- en: 'In `ChainMap`, every name is resolved by searching through the sequence of
    maps looking for a value. When we''ve loaded two configuration files into `ChainMap`,
    we have a structure like the following code:'
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  id: totrans-1458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: We have a sequence of maps; the first map is the most local variables, defined
    last. These are overrides. The second map has application defaults. There's a
    third, empty map because `ChainMap` always has at least one map; when we build
    the initial value for `config`, an empty map has to be created.
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
- en: The only downside of this is that the initialization will be using dictionary
    notation, `config['table']`, `config['player']`. We can extend `ChainMap()` to
    implement the attribute access in addition to the dictionary item access.
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a subclass of `ChainMap` that we can use if we find the `getitem()`dictionary
    notation too cumbersome:'
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  id: totrans-1462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: 'We can now say `config.table` instead of `config[''table'']`. This reveals
    an important restriction on our extension to `ChainMap`: we can''t use `maps`
    as an attribute. The `maps` key is a first-class attribute of the parent `ChainMap`
    class.'
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
- en: Storing the configuration in JSON or YAML files
  id: totrans-1464
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can store configuration values in JSON or YAML files with relative ease.
    The syntax is designed to be user friendly. We can represent a wide variety of
    things in YAML. We''re somewhat restricted to a narrower variety of object classes
    in JSON. We can use a JSON configuration file that looks like the following code:'
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  id: totrans-1466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: 'The JSON document looks like a dictionary of dictionaries. This is precisely
    the object that will be built when we load this file. We can load a single configuration
    file with the following code:'
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  id: totrans-1468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: This allows us to use `config['table']['dealer']` to look up the specific class
    to be used for the dealer's rules. We can use `config['player']['betting']` to
    locate the player's particular betting strategy class name.
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
- en: Unlike INI files, we can easily encode `tuple` like a sequence of values. So,
    the `config['table']['payout']` value will be a proper two-element sequence. It
    won't—strictly speaking—be `tuple`, but it will be close enough for us to use
    it without having to use `ast.literal_eval()`.
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we''d use this nested structure. We''ll only show you the first
    part of the `main_nested_dict()` function:'
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  id: totrans-1472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: This is very similar to the `main_ini()` function shown previously. When we
    compare this with the preceding version, using `configparser`, it's clear that
    the complexity is almost the same. The naming is slightly simpler. We use `config.get('table',{}).get('decks')`
    instead of `config.getint('table','decks')`.
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
- en: The largest difference is shown in the highlighted line. The JSON format provides
    us properly decoded integer values and proper sequences of values. We don't need
    to use `eval()` or `ast.literal_eval()` to decode the tuple. The other parts,
    to build `Player` and configure the `Simulate` object, are similar to the `main_ini()`
    version.
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
- en: Using flattened JSON configurations
  id: totrans-1475
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we want to provide for default values by integrating multiple configuration
    files, we can't use both `ChainMap` and a nested dictionary-of-dictionaries like
    this. We have to either flatten out our program's parameters or look at an alternative
    to merging the parameters from different sources.
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily flatten the names by using simple `.` separators between names.
    Our JSON file might then look like the following code:'
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  id: totrans-1478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: 'This has the advantage of allowing us to use `ChainMap` to accumulate the configuration
    values from various sources. It also slightly simplifies the syntax to locate
    a particular parameter value. Given a list of configuration filenames, `config_names`,
    we might do something like this:'
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  id: totrans-1480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: This builds a proper `ChainMap` from a *reversed* list of configuration file
    names. Why reversed? We must reverse the list because we want the list to be ordered
    from the most specific first to the most general last. This is the reverse of
    how the list is used by `configparser` and the reverse of how we incrementally
    built `ChainMap` by adding children to the front of the list of mappings. Here,
    we're simply loading a list of `dict` into `ChainMap`, and the first `dict` will
    be the first one searched for by the key.
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a method like this to exploit `ChainMap`. We''ll only show you the
    first part, which builds the `Table` instance:'
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  id: totrans-1483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: The other parts, to build `Player` and configure the `Simulate` object, are
    similar to the `main_ini()` version.
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
- en: When we compare this to the previous version, using `configparser`, it's clear
    that the complexity is almost the same. The naming is slightly simpler. Here,
    we use `int(config.get('table.decks'))` instead of `config.getint('table','decks')`.
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
- en: Loading a YAML configuration
  id: totrans-1486
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As YAML syntax contains JSON syntax, the previous examples can be loaded with
    YAML as well as JSON. Here''s a version of the nested dictionary-of-dictionaries
    technique from the JSON file:'
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  id: totrans-1488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: 'This is a better file syntax than pure JSON; it''s easier to edit. For applications
    where the configuration is dominated by strings and integers, this has a number
    of advantages. The process to load this file is the same as the process to load
    the JSON file:'
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  id: totrans-1490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: This has the same limitations as the nested dictionaries. We don't have an easy
    way to handle default values unless we flatten the names.
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
- en: 'When we move beyond simple strings and integers, however, we can try to leverage
    YAML''s ability to encode class names and create instances of our customized classes.
    Here''s a YAML file that will directly build the configuration objects that we
    need for our simulation:'
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  id: totrans-1493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: 'We have encoded class names and instance construction in YAML, allowing us
    to define the complete initialization for `Table` and `Player`. We can use this
    initialization file as follows:'
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  id: totrans-1495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: This shows us that a YAML configuration file can be used for human editing.
    YAML provides us with the same capabilities as Python, but with a different syntax.
    For this type of example, a Python configuration script might be better than YAML.
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
- en: Storing the configuration in property files
  id: totrans-1497
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The property files are often used with Java programs. There''s no reason we
    can''t use them with Python. They''re relatively easy to parse and allow us to
    encode the configuration parameters in a handy, easy-to-use format. For more information
    on the format, see this: [http://en.wikipedia.org/wiki/.properties](http://en.wikipedia.org/wiki/.properties).
    Here''s what a properties file might look like:'
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  id: totrans-1499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: This has some advantages in terms of simplicity. The `section.property` qualified
    names are commonly used. These can become long in a very complex configuration
    file.
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
- en: Parsing a properties file
  id: totrans-1501
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There's no built-in properties parser in the Python Standard Library. We can
    download a property file parser from the Python Package Index ([https://pypi.python.org/pypi](https://pypi.python.org/pypi)).
    However, it's not a complex class, and it's a good exercise in advanced object-oriented
    programming.
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll break the class down into the top-level API functions and the lower-level
    parsing functions. Here are some of the overall API methods:'
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  id: totrans-1504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: The essential feature here is that it will parse a filename, a file, or a block
    of text. This follows the design pattern from `configparser`. A common alternative
    is to have fewer methods and use `isinstance()` to determine the type of the argument,
    and also determine what processing to perform on it.
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
- en: 'File names are strings. Files themselves are generally instances of `io.TextIOBase`.
    A block of text is also a string. For this reason, many libraries use `load()`
    to work with files or filenames and `loads()` to work with a simple string. Something
    like this would echo the design pattern of `json`:'
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  id: totrans-1507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: 'These methods will also handle a file, filename, or block of text. These extra
    method names give us an alternative API that might be easier to work. The deciding
    factor is achieving a coherent design among the various libraries, packages, and
    modules. Here''s the `_parse()` method:'
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  id: totrans-1509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: This method starts with three generator expressions to handle some overall features
    of the physical lines and logical lines within a properties file. The generator
    expressions separate three syntax rules. Generator expressions have the advantage
    of being executed lazily; no intermediate results are created from these expressions
    until they're evaluated by the `for line in non_comment` statement.
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
- en: The first expression, assigned to `logical_lines`, merges physical lines that
    end with `\` to create longer logical lines. The leading (and trailing) spaces
    are stripped away, leaving just the line content. **Regular Expression** (**RE**)
    `r"\\\n\s*"` is intended to match `\` at the end of a line and all of the leading
    spaces from the next line.
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
- en: The second expression, assigned to `non_empty`, will only iterate over lines
    with a nonzero length. Blank lines will be rejected by this filter.
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
- en: Third, the `non_comment` expression will only iterate over lines that do not
    start with `#` or `!`. Lines that start with `#` or `!` will be rejected by this
    filter.
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
- en: Because of these three generator expressions, the `for line in non_comment`
    loop only iterates through noncomment, nonblank, logical lines that are properly
    merged with spaces stripped. The body of the loop picks apart each remaining line
    to separate the key and element and then apply the `self._escape()` function to
    expand any escape sequences.
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
- en: The key-element pattern, `key_element_pat`, looks for explicit separators of
    non-escaped`:`, `=` or a space surrounded by whitespace. This pattern uses the
    negative look behind an assertion, an RE of `(?<!\\)`, to indicate that the following
    RE must be non-escaped; the following pattern must not be preceded by `\`. This
    means that `(?<!\\)[:=\s]` is non-escaped `:`, or `=`, or space.
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
- en: If the key-element pattern can't be found, there's no separator. We interpret
    this lack of a matching pattern to indicate that the line is a degenerate case
    of only a key; no value was provided.
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
- en: 'As the keys and elements form a sequence of 2-tuples, the sequence can be easily
    turned into a dictionary, providing a configuration map much like other configuration
    representation schemes that we''ve seen. They can also be left as a sequence to
    show the original content of the file in an order. The final part is a small method
    function to transform the escapes to their final character:'
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  id: totrans-1518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: 'This `_escape()` method function performs two substitution passes. The first
    pass replaces the escaped punctuation marks with their plain-text versions: `\:`,
    `\#`, `\!`, `\=`, and `\` all have `\` removed. For the Unicode escapes, the string
    of digits is used to create a proper Unicode character that replaces the `\uxxxx`
    sequence. The hex digits are turned into an integer, which is turned into a character
    for the replacement.'
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
- en: 'The two substitutions can be combined into a single operation to save creating
    an intermediate string that will only get discarded. This will improve the performance.
    It might look like the following code:'
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  id: totrans-1521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: The benefit of better performance might be outweighed by the complexity of the
    RE and the replacement function.
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
- en: Using a properties file
  id: totrans-1523
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have two choices for how we use a properties file. We could follow the design
    pattern of `configparser` and parse multiple files to create a single mapping
    from the union of the various values. Or, we could follow the `ChainMap` pattern
    and create a sequence of properties mappings for each configuration file.
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ChainMap` processing is reasonably simple and provides us with all the
    required features:'
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  id: totrans-1526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: 'We''ve taken the list in a reverse order: the most specific settings will be
    first in the internal list; the most general settings will be the last. Once `ChainMap`
    has been loaded, we can use the properties to initialize and build our `Player`,
    `Table`, and `Simulate` instances.'
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
- en: This seems simpler than updating a single mapping from several sources. Also,
    this follows the pattern used to process JSON or YAML configuration files.
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a method like this to exploit `ChainMap`. This is very similar to
    the `main_cm()` function shown previously. We''ll only show you the first part,
    which builds the `Table` instance:'
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  id: totrans-1530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: The difference between this version and the `main_cm()` function is the handling
    of the payout tuple. In the previous version, JSON (and YAML) could parse the
    tuple. When using the properties files, all values are simple strings. We must
    use `eval()` or `ast.literal_eval()` to evaluate the given value. The other portions
    of this `main_cm_str()` function are identical to `main_cm()`.
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
- en: Storing the configuration in XML files – PLIST and others
  id: totrans-1532
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we noted in [Chapter 9](ch09.html "Chapter 9. Serializing and Saving – JSON,
    YAML, Pickle, CSV, and XML"), *Serializing and Saving – JSON, YAML, Pickle, CSV,
    and XML*, Python's `xml` package includes numerous modules that parse the XML
    files. Because of the wide adoption of the XML files, it often becomes necessary
    to convert between XML documents and Python objects. Unlike JSON or YAML, the
    mapping from XML is not simple.
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
- en: 'One common way to represent the configuration data in XML is the `.plist` file.
    For more information on the `.plist` format, see this: [http://developer.apple.com/documentation/Darwin/Reference/ManPages/man5/plist.5.html](http://developer.apple.com/documentation/Darwin/Reference/ManPages/man5/plist.5.html)'
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
- en: Macintosh users can perform `man plist` to see this man page. The advantages
    of the `.plist` format are that it uses a few, very general tags. This makes it
    easy to create `.plist` files and parse them. Here's the sample `.plist` file
    from with our configuration parameters.
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  id: totrans-1536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: We're showing you the nested dictionary-of-dictionary structure in this example.
    There are a number of Python-compatible types encoded with XML tags.
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
- en: '| Python type | Plist tag |'
  id: totrans-1538
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1539
  prefs: []
  type: TYPE_TB
- en: '| `str` | `<string>` |'
  id: totrans-1540
  prefs: []
  type: TYPE_TB
- en: '| `float` | `<real>` |'
  id: totrans-1541
  prefs: []
  type: TYPE_TB
- en: '| `int` | `<integer>` |'
  id: totrans-1542
  prefs: []
  type: TYPE_TB
- en: '| `datetime` | `<date>` |'
  id: totrans-1543
  prefs: []
  type: TYPE_TB
- en: '| `boolean` | `<true/> or <false/>` |'
  id: totrans-1544
  prefs: []
  type: TYPE_TB
- en: '| `bytes` | `<data>` |'
  id: totrans-1545
  prefs: []
  type: TYPE_TB
- en: '| `list` | `<array>` |'
  id: totrans-1546
  prefs: []
  type: TYPE_TB
- en: '| `dict` | `<dict>` |'
  id: totrans-1547
  prefs: []
  type: TYPE_TB
- en: 'As shown in the preceding example, the dict `<key>` values are strings. This
    makes the plist a very pleasant encoding of our parameters for our simulation
    application. We can load a `.plist` with relative ease:'
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  id: totrans-1549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: This will reconstruct our configuration parameters. We can then use this nested
    dictionary-of-dictionaries structure with the `main_nested_dict()` function shown
    in the preceding section on JSON configuration files.
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
- en: Using a single module function to parse the file makes the `.plist` format very
    appealing. The lack of support for any customized Python class definitions makes
    this equivalent to JSON or a properties file.
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
- en: Customized XML configuration files
  id: totrans-1552
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For a more complex XML configuration file, see [http://wiki.metawerx.net/wiki/Web.xml](http://wiki.metawerx.net/wiki/Web.xml).
    These files contain a mixture of special-purpose tags and general-purpose tags.
    These documents can be challenging to parse. There are two general approaches:'
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
- en: Write a document processing class that uses XPath queries to locate the tags
    in a document that contain interesting data. In this case, we'll write properties
    (or methods) that will locate the requested information in the XML document structure.
  id: totrans-1554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unwind the XML document into a Python data structure. This is the approach followed
    by the `plist` module, shown previously.
  id: totrans-1555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Based on examples of the `web.xml` files, we''ll design our own customized
    XML document to configure our simulation application:'
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  id: totrans-1557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: 'This is a specialized XML file. We didn''t provide a DTD or an XSD, so there''s
    no formal way to validate the XML against a schema. However, this file is small,
    easily debugged, and parallels other example initialization files. Here''s a `Configuration`
    class that can use XPath queries to retrieve information from this file:'
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  id: totrans-1559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: 'We''ve implemented three methods to load the XML document: `read()`, `read_file()`,
    and `read_string()`. Each of these simply delegates itself to an existing method
    function of the `xml.etree.ElementTree` class. This parallels the `configparser`
    API. We could use `load()` and `loads()` too, as they would delegate themselves
    to `parse()` and `fromstring()`, respectively.'
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
- en: 'For access to the configuration data, we implemented two methods: `get()` and
    `__getitem__()`. The `get()` method allows us to use code like this: `stake= int(config.get(''player.stake'',
    50))`. The `__getitem__()` method allows us to use code like this: `stake= config[''player''][''stake'']`.'
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
- en: The parsing is a trifle more complex than a `.plist` file. However, the XML
    document is much simpler than an equivalent `.plist` document.
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `main_cm_str()` function shown in the previous section on the
    property files to process this configuration.
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-1564
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We looked at a number of ways to represent the configuration parameters. Most
    of these are based on more general serialization techniques that we saw in [Chapter
    9](ch09.html "Chapter 9. Serializing and Saving – JSON, YAML, Pickle, CSV, and
    XML"), *Serializing and Saving – JSON, YAML, Pickle, CSV, and XML*. The `configparser`
    module provides an additional format that's comfortable for some users.
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
- en: The key feature of a configuration file is that the content can be easily edited
    by a human. For this reason, pickle files aren't suggested as a good representation.
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
- en: Design considerations and trade-offs
  id: totrans-1567
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Configuration files can simplify running application programs or starting servers.
    This can put all the relevant parameters in one easy-to-read and easy-to-modify
    file. We can put these files under the configuration control, track change history,
    and generally use them to improve the software's quality.
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
- en: 'We have several alternative formats for these files, all of which are reasonably
    human friendly to edit. They vary in how easy they are to parse and any limitations
    on the Python data that can be encoded:'
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
- en: '**INI files**: These files are easy to parse and are limited to strings and
    numbers.'
  id: totrans-1570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Python code (PY files)**: These files use the main script for the configuration.
    No parsing, no limitations. They use an `exec()` file. It is easy to parse and
    has no limitations.'
  id: totrans-1571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JSON or YAML files**: These files are easy to parse. They support strings,
    numbers, dicts, and lists. YAML can encode Python, but why not just use Python?'
  id: totrans-1572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Property Files**: These files require a special parser. They are limited
    to strings.'
  id: totrans-1573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XML files**:'
  id: totrans-1574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.plist` **files**: These files are easy to parse. They supports strings, numbers,
    dicts, and lists.'
  id: totrans-1575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Customized XML**: These files require a special parser. They are limited
    to strings.'
  id: totrans-1576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coexistence with other applications or servers will often determine a preferred
    format for the configuration files. If we have other applications that use the
    `.plist` or INI files, then our Python applications should make choices that are
    more comfortable for users to use.
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
- en: 'Viewed from the breadth of objects that can be represented, we have four broad
    categories of configuration files:'
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple files with only strings**: Custom XML, properties files.'
  id: totrans-1579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simple files with simple Python literals**: INI files.'
  id: totrans-1580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**More complex files with Python literals, lists, and dict**s: JSON, YAML,
    `.plist`, and XML.'
  id: totrans-1581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Anything. Python**: We can use YAML for this, but it seems silly when Python
    has a clearer syntax.'
  id: totrans-1582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a shared configuration
  id: totrans-1583
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we look at module design considerations in [Chapter 17](ch17.html "Chapter 17. The
    Module and Package Design"), The *Module and Package Design*, we'll see how a
    module conforms to the **Singleton** design pattern. This means that we can import
    a module only once, and the single instance is shared.
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
- en: Because of this, it's often necessary to define a configuration in a distinct
    module and import it. This allows separate modules to share a common configuration.
    Each module will import the shared configuration module; the configuration module
    will locate the configuration file(s) and create the actual configuration objects.
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
- en: Schema evolution
  id: totrans-1586
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The configuration file is part of the public-facing API. As application designers,
    we have to address the problem of schema evolution. If we change a class definition,
    how will we change the configuration?
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
- en: Because configuration files often have useful defaults, they are often very
    flexible. In principle, the content is entirely optional.
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
- en: As a piece of software undergoes major version changes— changes that alter the
    APIs or the database schema—the configuration files too might undergo major changes.
    The configuration file's version number may have to be included in order to disambiguate
    legacy configuration parameters from current release parameters.
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
- en: For minor version changes, the configuration files, such as database, input
    and output files, and APIs should remain compatible. Any configuration parameter
    handling should have appropriate defaults to cope with minor version changes.
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
- en: A configuration file is a first-class input to an application. It's not an after-thought
    or a workaround. It must be as carefully designed as the other inputs and outputs.
    When we look at larger application architecture design in [Chapter 14](ch14.html
    "Chapter 14. The Logging and Warning Modules"), *The Logging and Warning Modules*
    and [Chapter 16](ch16.html "Chapter 16. Coping With the Command Line"), *Coping
    with the Command Line*, we'll expand on the basics of parsing a configuration
    file.
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
- en: Looking Forward
  id: totrans-1592
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the next chapters, we'll look at larger-scale design considerations. [Chapter
    14](ch14.html "Chapter 14. The Logging and Warning Modules"), *The Logging and
    Warning Modules*, will look at using the `logging` and `warnings` modules to create
    audit information as well as to debug. We'll look at designing for testability
    and how we use `unittest` and `doctest` in [Chapter 15](ch15.html "Chapter 15. Designing
    for Testability"), *Designing for Testability*. [Chapter 16](ch16.html "Chapter 16. Coping
    With the Command Line"), *Coping with the Command Line*, will look at using the
    `argparse` module to parse options and arguments. We'll take this a step further
    and use the **Command** design pattern to create program components that can be
    combined and expanded without resorting to writing shell scripts. In [Chapter
    17](ch17.html "Chapter 17. The Module and Package Design"), *The* *Module and
    Package Design*, we'll look at module and package design. In [Chapter 18](ch18.html
    "Chapter 18. Quality and Documentation"), *Quality and Documentation*, we'll look
    at how we can document our design to create the trust that our software is correct
    and is properly implemented.
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
