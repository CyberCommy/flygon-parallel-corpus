- en: Chapter 5. Responsive Complex Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will create user interfaces that demonstrate some advanced
    features of GWT.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tasks that we will address are:'
  prefs: []
  type: TYPE_NORMAL
- en: Pageable tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editable tree nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log spy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sticky notes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jigsaw puzzle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pageable Tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to start exploring more complex GWT user interfaces in this chapter.
    We routinely come across some cases in today's business world where we need to
    use tables to display a large amount of data. Displaying all of the available
    data in a table at once is not a viable option, either from the point of view
    of usability or from a practical perspective.
  prefs: []
  type: TYPE_NORMAL
- en: We can also potentially lock up the browser that is displaying the table, if
    the dataset retrieved is of a large enough size. A much better way to display
    this data to users would be to show them a fixed number of results first, and
    then provide them with the mechanism to navigate through the results; so that
    they can page back and forward through the data at their leisure. This makes for
    a nicer user experience, and also loads the smaller dataset much faster.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to create an application that provides this functionality.
    As a part of this sample, we are also going to learn how to use an embedded database
    with a GWT application.
  prefs: []
  type: TYPE_NORMAL
- en: Time for Action—Interfacing a Dataset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create an application that will let us retrieve data in chunks or pages,
    instead of getting everything at once. We will do this by retrieving the first
    ten items as a result of a query, and provide a way for the user to either go
    forward or backward through this set of results. The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Java file named `PageableDataService.java` in the `com.packtpub.gwtbook.samples.client`
    package. Define the `PageableDataService` interface with one method to retrieve
    the customer data, by providing a start index and the number of items to retrieve
    as parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the asynchronous version of this service definition interface in a new
    Java file named `PageableDataServiceAsync.java` in the `com.packtpub.gwtbook.samples.client`
    package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the implementation of our pageable data service in a new Java file named
    `PageableDataServiceImpl.java` in the `com.packtpub.gwtbook.samples.server` package.
    Create a private `ArrayList` object named `customerData` that will be the container
    for the customer data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It will be simpler if we use a database for storing our data instead of managing
    data structures in our service. We are going to use HSQLDB—a small embedded database
    for storing the data that we will be accessing in this service. First, load the
    data from the pre-populated database into a list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We call the `loadData()` function in the constructor for the service, so that
    all the required data is loaded and is available after the service is initialized:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now add the service-implementation method that will send back only the requested
    subset of the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create the user interface for interacting with the pageable data service.
    Create a new Java file named `PageableDataPanel.java` in the `com.packtpub.gwtbook.samples.client.panels`
    package. As mentioned at the beginning of the previous chapter, each of the user
    interfaces created in this book will be added to a sample application that is
    similar to the `KitchenSink` application that is available as one of the sample
    projects with the GWT download. That is why we will create each user interface
    as a panel that extends the `SamplePanel` class, and we will add the created panel
    to the list of sample panels in the sample application. The `SamplePanel` class
    and the structure of our `Samples` application are discussed at the beginning
    of the previous chapter. Add a `FlexTable` class for displaying the data, along
    with buttons for paging *forward* and *backward* through the data. Create an array
    of strings to store the column headers, and an integer variable to store the start
    index into the customer data list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the service class that we will use for invoking the service to get the
    data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a private method for clearing out the table before we populate it with
    data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a private method for updating the table with data retrieved from the service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constructor for `PageableDataPanel`, create a `VerticalPanel` object
    that will be the container panel for this user interface, and initialize the table
    that will hold the customer data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an inner navigation bar that holds the back and forward buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an event handler to listen for clicks on the back button to the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an event handler to listen for clicks on the forward button to the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in the constructor, add the customer data table and the navigation
    bar to the work panel. Create a little info panel that displays descriptive text
    about this application, so that we can display the text when this sample is selected
    in the list of available samples in our `Samples` application. Add the info panel
    and the work panel to a dock panel, and initialize the widget. Call the `update()`
    method, so that we can get the first batch of customer data and display it when
    the page is initially loaded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the service to the module file for the `Samples` application—`Samples.gwt.xml`—in
    the `com.packtpub.gwtbook.samples` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the user interface for the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for Action—Interfacing a Dataset](img/1007_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click on the buttons to go either forward or backward in the list.
  prefs: []
  type: TYPE_NORMAL
- en: What Just Happened?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are using an embedded database (Hypersonic SQL—HSQLDB— [http://www.hsqldb.org](http://www.hsqldb.org))
    containing the customer data that we will page through, displaying only ten results
    at a time. All the components required to use this database are contained in the
    `hsqldb.jar` file. In order to use it in a GWT project, we need to ensure that
    the `hsqldb.jar` file is added to the `buildpath` for the Eclipse project. Then
    it will be available on the `classpath`, when you either run or debug the project.
  prefs: []
  type: TYPE_NORMAL
- en: The in-memory version of HSQLDB is being used, which means that the database
    runs in the same Java Virtual Machine as our GWT application. After initializing
    the JDBC driver for HSQLDB, we get a connection to a database named `samplesdb`,
    by specifying the database file path. If this file does not exist, it will be
    created, and if it does exist, the database will be loaded by the database engine.
    The file path provided is relative to the directory from which this JVM was started;
    so in our case, the database file will be created in the root directory of our
    project.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The data from the customer table is retrieved and stored in a local `ArrayList`.
    This list data structure contains one `ArrayList` per row in the customers table.
    It will be used as the base for retrieving sets of information. Each request to
    retrieve customer data will provide a start index and the number of items to be
    retrieved. The start index tells us the offset into the `ArrayList`, while the
    number of items limits the results returned.
  prefs: []
  type: TYPE_NORMAL
- en: The user interface for the application displays a table along with two buttons.
    The back button pages backward through the dataset, while the forward button lets
    us move forward through the list. When the page is loaded, an asynchronous call
    is made to the `PageableDataService` interface to get the first ten items and
    display them in the table. Event handlers are registered to listen for clicks
    on the two buttons. Clicking on either of the buttons triggers a call to the remote
    service to get the next set of items. We store the start index of the currently
    displayed table items in a private variable. This variable is decremented when
    we click on the back button, and incremented when we click on the forward button.
    It is provided as a parameter to the remote method when we request the next set
    of data. The result from the request is used to populate the table on the page.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We clear out the data in the table and then add new data by setting the text
    for each column.
  prefs: []
  type: TYPE_NORMAL
- en: Editable Tree Nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tree controls provide a very user-friendly way to display a set of hierarchical
    data—the common examples being the directory structure on your file system or
    the nodes in an XML document. GWT provides a tree widget that can display this
    data, but does not provide any way to modify the nodes of the tree itself. One
    of the most common uses of modifying a displayed node in a tree control is the
    renaming of files and folders in your file explorer, on your favorite platform.
    We are going to create an application that shows how to edit the displayed node
    in a tree by just clicking on it and typing in the new text. This sample also
    demonstrates how easy it is to extend GWT to make it do some of the things that
    are not provided out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: Time for Action—Modifying the Node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create an application that contains a tree that behaves similarly to
    the Windows file explorer, by allowing us to click on a node and edit the text
    for the node. The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the user interface for this application in a new Java file named `EditableTreeNodesPanel.java`
    in the `com.packtpub.gwtbook.samples.client.panels` package. This class also extends
    the `SamplePanel` class like all the other user interfaces in this book. A `SamplePanel`
    class extends the `Composite` class, and is a simple way to create several user
    interfaces, and add each of them to our `Samples` application, so that we can
    display a list of all the applications in a manner similar to the `KitchenSink`
    sample project from the GWT distribution. We have described the sample application
    structure in a section at the beginning of[Chapter 4](ch04.html "Chapter 4. Interactive
    Forms"). Create a tree, a text box, and a label. Finally, create variables for
    the work panel and the work pane:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a private method that populates the tree with some nodes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constructor for `EditableTreeNodesPanel`, initialize the tree and add
    an event handler for listening to clicks on the tree node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constructor, create a little info panel that displays descriptive text
    about this application, so that we can display the text when this sample is selected
    in the list of available samples in our `Samples` application. Add the info panel
    and the work panel to the dock panel, and initialize the widget:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for Action—Modifying the Node](img/1007_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can click on a tree node and change the text in the text box that is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: What Just Happened?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Tree controls are a nice way to visualize and explore hierarchical data. In
    this sample, we create a tree with ten nodes, each node containing a string value.
    We register an event handler that listens for selection events on the tree nodes.
    When a tree node is selected, we create a text box that contains the same text
    as the tree node, and position the text box over the tree node. The text box is
    positioned by retrieving the left and top coordinates for the tree node. The currently
    selected tree node is stored in a private variable. An event handler is registered
    to listen for focus events from the newly added text box. When the text box loses
    focus, we take the current text and modify the tree item value with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `isAttached()` function enables us to check if the sender widget is actually
    attached to the root panel, or if it has already been destroyed. We avoid setting
    anything on the widget if it is no longer attached to the panel. That's all! GWT
    makes it that simple to add support for inline editing of tree nodes. The current
    GWT release does not yet support adding widgets other than strings to the tree
    as a tree item. Once that support is available, it would be simple to refactor
    this example to use text boxes as tree nodes, and make them editable or non-editable
    based on the click event.
  prefs: []
  type: TYPE_NORMAL
- en: Log Spy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will look how a server can be polled, based on a time interval
    set by the client. This will involve using the GWT Timer object, and is very useful
    for situations where you need to perform an action on the server, based on a repeating
    time interval, and then asynchronously update a section of the web page with the
    results of the action. We will create a simple application that can monitor and
    display the contents of a log file in real time.
  prefs: []
  type: TYPE_NORMAL
- en: Time for Action—Updating a Log File
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Almost every application has log files that contain debugging information.
    This information is usually read by logging in to a server, navigating to a folder
    containing the log file, and then opening the file in a text editor to actually
    view the contents. This is a tedious way of checking log files. The better and
    more user-friendly way is to use GWT to create an application that can display
    the contents of the log file in a web page. The contents are updated in real time,
    as messages are added to the log file. The following steps will give us the desired
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Java file named `LogSpyService.java` in the `com.packtpub.gwtbook.samples.client`
    package. Define a `LogSpyService` interface with two methods—one method for retrieving
    all log entries and one method for retrieving only the new entries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the asynchronous version of this service definition interface in a new
    Java file named `LogSpyServiceAsync.java` in the `com.packtpub.gwtbook.samples.client`
    package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the implementation of the log spy service in a new Java file named `LogSpyServiceImpl.java`
    in the `com.packtpub.gwtbook.samples.server` package. First create a private method
    for reading a log file, a variable for holding the file pointer, and a variable
    with the name of the log file that you want to read:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the two methods that implement the service interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now create the user interface for interacting with the log spy service. Create
    a new Java file named `LogSpyPanel.java` in the `com.packtpub.gwtbook.samples.client.panels`
    package. Create variables for the work panel, a text box for setting the monitoring
    interval, a label, and **Start** and **Stop** buttons. We will also need a Boolean
    flag to indicate the current status of monitoring.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Create panels that will contain the **Start** and **Stop** buttons, the text
    box and the label for the monitoring interval, and a timer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a listbox for displaying the log messages, and the service interface
    that we will be invoking to get the log entries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constructor, set the initial value of the monitoring interval text box
    to 1000, and disable the **Stop** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the styles for the panels, the text box, and the label:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an event handler to listen for clicks on the **Start** button, and invoke
    the log spy service from the handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an event handler to listen for clicks on the **Stop** button and stop monitoring:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Limit the number of visible items in the list to eight items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in the constructor, create a little info panel that displays descriptive
    text about this application, so that we can display this text when this sample
    is selected in the list of available samples, in our `Samples` application. Add
    the monitoring interval panel and the start-stop buttons panel to the work panel.
    Add the info panel and the work panel to the dock panel, and initialize the widget:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the service to the module file for the `Samples` application—`Samples.gwt.xml`
    in the `com.packtpub.gwtbook.samples` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Here is a screenshot of the application that displays the entries in the log
    file—`test.log:`
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for Action—Updating a Log File](img/1007_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As entries are added to this file, they will be added in real time to the list,
    with the first item in the list being the latest log entry. You can monitor any
    file that you want. Just change the value of the `logFile` variable in the `LogSpyServiceImpl`
    class to contain the requisite file name.
  prefs: []
  type: TYPE_NORMAL
- en: What Just Happened?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Log files are usually just text files that have messages appended to them, as
    applications write to the log file. This sample is using a simple log file and
    can be modified to use any file that you want to monitor. We read the file using
    a `RandomAccessFile` class so that we can access only the sections of the file
    that we want, without needing to read the whole file into memory every time. A
    private variable that contains the last file pointer is stored in the class. This
    pointer is a cursor into the file. We have a method `readLogFile()` that accesses
    the file and reads only the data from the file pointer to the end of the file.
    Every time the file is read, the pointer is updated to store the last read position.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: If the file has not been modified since we last read it, we return an empty
    list without trying to read the file. Whenever the client makes a request to get
    the new log entries, we read the file and return the new entries.
  prefs: []
  type: TYPE_NORMAL
- en: 'The user interface consists of a list box, a text box that can be used to specify
    how often you want to monitor the log file, and buttons for starting and stopping
    the monitoring of the file. When the **Start** button is clicked, we start a timer
    that is scheduled to go off after the provided time interval. Every time the timer
    goes off, we make a request to get the log entries, and then in the `onSuccess()`
    callback method we add the returned entries to the listbox. We insert the log
    entry to the list and then set the last added entry as the selected item, so it
    visually indicates the latest item in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: If we click the **Stop** button, the timer is canceled, and the monitoring is
    halted. We do something very different here, compared to all the other samples.
    We call the service on a repeating time interval based on the time interval set
    by the user in the text box. So we make an asynchronous request every time the
    timer goes off. This technique can be used to do some very useful things for updating
    portions or sections of a page on a scheduled time interval by making synchronous
    calls to the server to get fresh information.
  prefs: []
  type: TYPE_NORMAL
- en: Sticky Notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Document Object Model** (**DOM**) describes the structure of an HTML document
    in the form of a tree structure that can be accessed using a language such as
    JavaScript. All the modern web browsers facilitate the access to a loaded web
    page through DOM scripting. GWT provides a rich set of methods that enable you
    to manipulate the DOM of a web page. We can even intercept and preview DOM events.
    We are going to learn how to use the GWT DOM methods and dialog boxes, leverage
    them to provide the ability to create sticky notes similar to the ubiquitous post-it
    notes, and drag them around to place them anywhere in the browser window.
  prefs: []
  type: TYPE_NORMAL
- en: Time for Action—Playing with Sticky Notes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create sticky notes that can be moved around in your browser window
    and placed anywhere. The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Java file named `StickyNotesPanel.java` in the `com.packtpub.gwtbook.samples.client.panels`
    package. Create a work panel, a button for creating the note, a text box for the
    name of the note, and variables to hold the x and y coordinates of the note. Also
    create an integer variable to hold the amount by which the coordinates of a new
    note are to be incremented:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new class named `StickyNote` that extends `DialogBox`. In the constructor
    for this class, set the title for the note if provided, and add a text area that
    will be used to type in the actual note:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a method in the `StickyNote` class that intercepts the DOM events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constructor for the `StickyNotesPanel` class, create a little info panel
    that displays descriptive text about this application, so that we can display
    the text when this sample is selected in the list of available samples in our
    `Samples` application. Add this class as a listener to click events on the **Create
    Note** button. Add the button for creating the note along with the title text
    box to the work panel. Add the info panel and the work panel to the dock panel,
    and initialize the widget:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Make the `StickyNotesPanel` class implement the `ClickListener` interface,
    and add code to the `onClick()` method to create a new note when the **Create
    Note** button is clicked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a screenshot of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for Action—Playing with Sticky Notes](img/1007_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you create several notes, you can drag the notes around and place them
    anywhere on the browser window.
  prefs: []
  type: TYPE_NORMAL
- en: What Just Happened?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This sample demonstrates the ease with which you can generate some really cool
    interfaces and applications using GWT. The sticky notes application creates notes
    on your screen that you can drag around inside the web browser and place anywhere
    you want. The user interface contains a text box for typing in the name of the
    note, and a button for creating a new note with the provided name. If no name
    is provided, it is created with a default name **New Note**.
  prefs: []
  type: TYPE_NORMAL
- en: The note itself is a subclass of `DialogBox`. It has a title and a text area
    for typing in the note. A `DialogBox` class inherits from a `PopupPanel` class,
    and implements the `EventPreview` interface. We implement the `onEventPreview()`
    method, as given in step 3, from this interface, so that we can preview all the
    browser events first, before they are sent to their targets. That essentially
    means that our sticky notes panel sits at the top of the browser event preview
    stack.
  prefs: []
  type: TYPE_NORMAL
- en: We preview the keyboard events and then pass them on, down to the target. This
    enables us to take a dialog box that is modal, and introduce non-modal behavior
    to it. If we do not do this, once we create the first note, the note will be modal,
    and will not allow us to create another note by clicking on the **Create** button,
    unless we close the note first.
  prefs: []
  type: TYPE_NORMAL
- en: Now the note passes on the events after previewing them to the underlying panel,
    and we can create as many notes as we want. An event handler is registered to
    listen for clicks on the **Create Note** button. When the button is clicked, a
    new note is created and we set its position relative to the browser window, and
    then show it. We maintain a private variable that contains the left position of
    the last created note, so that we can stagger the position of the notes as we
    create them, as we have done in step 5\. This arranges the notes nicely on the
    screen so that the notes do not cover each other.
  prefs: []
  type: TYPE_NORMAL
- en: As our notes inherit from `DialogBox`, they are draggable; we can drag them
    around the screen, and position them anywhere we want!
  prefs: []
  type: TYPE_NORMAL
- en: Jigsaw Puzzle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous sample demonstrated some of the dragging capabilities and DOM event
    previewing in GWT. In this example, we are going to use the same DOM methods but
    a different way to intercept or preview the DOM events. We will also demonstrate
    some of the absolute positioning capabilities in GWT by using `AbsolutePanel`.
    We will be creating a simple Mona Lisa puzzle that can be solved by dragging and
    rearranging the pieces of the puzzle.
  prefs: []
  type: TYPE_NORMAL
- en: Time for Action—Let's Create a Puzzle!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create a simple jigsaw puzzle, whose pieces were created by dividing
    a Mona Lisa image into nine pieces. The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Java file named `JigsawPuzzlePanel.java` in the `com.packtpub.gwtbook.samples.client.panels`
    package that implements the `MouseListener` interface. Create an `AbsolutePanel`
    class that will be the main panel to which all the widgets will be added. Also
    add two variables to store the `x` and `y` positions of the mouse cursor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constructor for `JigsawPuzzlePanel`, add the Mona Lisa images to the
    panel, and add the panel as a listener for mouse events from the images:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Register to intercept the DOM mouse events in the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the method to listen for mouse down events in the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the method to listen for mouse move events in the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the method to listen for mouse up events in the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally in the constructor, create a little info panel that displays descriptive
    text about this application, so that we can display the text when this sample
    is selected in the list of available samples in our `Samples` application. Add
    the info panel and the work panel to the dock panel, and initialize the widget:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the puzzle when you first visit the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for Action—Let''s Create a Puzzle!](img/1007_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the solved puzzle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for Action—Let''s Create a Puzzle!](img/1007_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What Just Happened?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This sample demonstrates the absolute positioning capabilities in GWT. An image
    file of the Mona Lisa was split into nine equal-sized images. We jumble the images
    and present them on the screen in a 3x3 square, when the application is rendered.
    The user can then rearrange the image pieces by dragging them around and repositioning
    them on the screen to recreate the Mona Lisa.
  prefs: []
  type: TYPE_NORMAL
- en: We use an `AbsolutePanel` class as our work panel in this sample. It has the
    ability to position all of its child widgets absolutely, and even allows the widgets
    to overlap. We add the nine images to the panel by positioning them absolutely,
    so they form a nice 3x3 grid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is one column of the grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we were able to implement the `onEventpreview()` method
    to preview the browser events first before they are sent to their target. We were
    able to do this as the note was a subclass of `PopupPanel`, which provides this
    ability. But in the current sample we are not using a pop-up panel. So we use
    another method to add ourselves to the top of the event preview stack. This time
    we are using the `addEvetnpreview()` method in the DOM object, as illustrated
    in step 3.
  prefs: []
  type: TYPE_NORMAL
- en: In step 4, we implement the `MouseListener` interface and register ourselves
    as the event handler for mouse events in the panel. When the user clicks on an
    image prior to dragging it, we get the element that was clicked and set it as
    the mouse-capture. This ensures that element will receive all of the mouse events,
    until it is released from the mouse-capture. We store the `x` and `y` coordinates
    of the element in a private variable. We also set a flag that tells us that we
    are currently in the mode of dragging an element.
  prefs: []
  type: TYPE_NORMAL
- en: Once the user starts dragging an image, we check to see if we are in drag mode,
    and we set the position of the widget, which will move the widget to the new position.
    You can only set the absolute widget position by calling the absolute panel that
    contains the widget; so we have to get the parent object of the image and then
    cast it to the right class. We have covered all this in step 5.
  prefs: []
  type: TYPE_NORMAL
- en: When the user has finished dragging an image to a position and releasing the
    mouse, we release the element from the mouse-capture and set the drag flag to
    false, as in step 6.
  prefs: []
  type: TYPE_NORMAL
- en: The absolute positioning support in GWT still needs some work, and can act quite
    different in Firefox and Internet Explorer, and their multiple versions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to create tables that can page through a set
    of data in a user-friendly manner, and extended a tree widget to add simple support
    for editing the tree nodes in place. We utilized the `timer` object to create
    a log spy application that monitors a given log file for new entries, and displays
    them in a list that is updated in real time.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to use some of the DOM methods and the DOM event preview capability
    in GWT, and leveraged it to implement a draggable sticky notes application. We
    also learned how to make dialog boxes non-modal, so that we can adapt them for
    our use. Finally, utilizing the absolute positioning functionality and an alternate
    method of previewing DOM events, we created a puzzle application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to integrate third-party JavaScript libraries
    with GWT using the JavaScript Native Interface.
  prefs: []
  type: TYPE_NORMAL
