- en: Chapter 9. Working with Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we discussed optimizing code to develop efficient
    code. Now, we are going to discuss the pattern that will make our code flow in
    a regular order so that it will be easier to maintain and understand the flow
    of the program. The main topics we are going to discuss in this chapter are pattern
    matching and Monad as a design pattern. Pattern matching will match the condition
    using a mathematical approach so that we will get a functional taste of things.
    And Monad is an inseparable part of the functional programming since it''s a design
    pattern for complex problems in software design. Using Monad, we can give more
    power to existing data types by amplifying their behavior. This chapter will look
    further into pattern matching and `Monad` , and we will discuss the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding pattern matching in functional programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforming data and switching decisions using pattern matching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplifying pattern matching in order to make it more functional
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing pattering matching feature in C# 7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding out which C# types implement Monad naturally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating monadic types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the rules of Monad
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dissecting pattern matching in functional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In functional programming, pattern matching is a form of dispatch to choose
    the correct variant of the functions to be called. It''s actually inspired by
    a standard mathematical notation with the syntax to express conditional execution.
    We can start our discussion on matching pattern by borrowing the code from [Chapter
    1](text00016.html#ch01 "Chapter 1. Tasting Functional Style in C#") , *Tasting
    Functional Style in C#* , when we talked about recursion. The following is the
    `GetFactorial()` functional we used to retrieve a factorial value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding code, it gives us two definitions. In this case,
    the dispatcher is chosen based on whether the actual `intNumber` parameter pattern
    matches 0 or not. The use of the pattern matching are closer to this `if` conditional
    expression since we have to decide which section will be selected by providing
    a specific input.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming data using pattern matching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Pattern matching is somehow transforming data. Let''s borrow another function
    from the previous chapter to continue the discussion. As we might remember, we
    had a function in the extension method called `IsPrime()` to check whether or
    not it is a prime number. We will use it again to demonstrate pattern matching
    to transform data. For those who have forgotten the implementation of the `IsPrime()`
    function, here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we use pattern matching to determine whether the number is a prime number,
    composite number, or neither. However, now we will transform the `int` number
    into text, as we can see in the following `NumberFactorType()` function, which
    we can find in the `MatchingPattern.csproj` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code, we use the `if...else` conditional statement
    to match the condition instead of the `if` conditional statement we used in the
    previous example. Now, let''s call the `NumberFactorType()` function to match
    the int number we give and transform it into text using the following `TransformIntIntoText()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We pass the number 0 to 9 into the `NumberFactorType()` function to get a matching
    result. And if we run the `TransformIntIntoText()` function, we get the following
    output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Transforming data using pattern matching](img/Image00106.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the preceding screenshot, we have successfully used pattern
    matching to transform `int` into text.
  prefs: []
  type: TYPE_NORMAL
- en: Switching for pattern matching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We know that pattern matching can transform data into another form. This is
    actually similar to the `Select()` method in LINQ and conceptually similar to
    the switch case statement. Now let''s take a look at the following `HexCharToByte()`
    function to convert a hexadecimal character into `byte` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add a wrapper to convert the hexadecimal in string into `int` , as
    shown in the following `HexStringToInt()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, we can see that we call the `HexCharToByte()` function
    to get each `int` value for each hexadecimal character. Then, we use the power
    of 16 to get all the hexadecimal values. Suppose we have the following `GetIntFromHexString()`
    function to convert several hexadecimal digits in a string into `int` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the `GetIntFromHexString()` function, we get the following output
    on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Switching for pattern matching](img/Image00107.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding screenshot, each hexadecimal character in the
    string is converted into the `int` value and then it sums up all the results.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To convert a hexadecimal character into a byte, we can use the `Parse` and `TryParse`
    methods or format it using the `String.Format` . `HexCharToByte()` function we
    discussed earlier, which is for sample purposes only.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying pattern matching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have successfully used the `switch` statement to implement pattern matching.
    However, the example doesn''t apply a functional approach since the `res` variable
    in the `HexCharToByte()` function is mutated during execution. Now, we are going
    to refactor the `HexCharToByte()` function in order to apply a functional approach.
    Let''s take a look at the following `HexCharToByteFunctional()` function, which
    can be found in the `SimplifyingPatternMatching.csproj` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `HexCharToByteFunctional()` function is refactored from the `HexCharToByte()`
    function and now implements the functional approach. As you can see, we have four
    methods similar to the `switch` statement or the `if...else` condition statement: `Match()`
    , `With()` , `Else()` , and `Do()` . Let''s take a look at the following `Match()`
    function used by the preceding `HexCharToByteFunctional()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `Match()` function returns the new `PatternMatchContext`
    data type. The `PatternMatchContext` class implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `Match()` function generates a new instance of `PatternMatchContext`
    , its constructor stores the value passed as an argument to the `_value` private
    variable, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In this `PatternMatchContext` class, there is also a method called `With()`
    , which we can compare with the `_value` value. The method will invoke the `With()`
    method inside the `PatternMatchOnValue` class, the implementation of which is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the preceding code, when the `With()` method, which is
    a member of the `PatternMatchContext` class, returns a new instance of `PatternMatchOnValue`
    , its constructor also stores the value to the `_value` private variable, as shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'It then calls the `With()` method, which is passed an anonymous method as `condition`
    and an expected value as `result` , as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This `With()` method then calls another `With()` method, which passes `Predicate<T>`
    and `Func<T1, T2>` as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This `With()` method collects all cases and stores them in the `_cases` list
    typed as `PatternMatchCase` , the implementation of which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have provided all the conditions, we call the `Else()` method, which
    contains the default result. The implementation of the `Else()` method is as shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We then invoke another `Else()` method passing `Func<T1, T2>` , as shown in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'After we collect all `_cases` and `_elseCase` variables, we have to invoke
    the `Do()` method to compare all cases. The implementation of the `Do()` method
    can be seen in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `Do(` ) method will assign the `_elseCase` variable, if
    any, to the `_cases` list using the `With()` method, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It then compares all `_cases` list members using the `foreach` loop to find
    the correct _`value` value using the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Although invoking the `Else()` method is optional, it''s mandatory to match
    one of all the `With()` method invocations. If not, the `Do()` method will throw
    an `IncompletePatternMatchException` exception, as shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'For now, we don''t need to implement anything in the `IncompletePatternMatchException`
    exception, so we just need to create a new class implementation `Exception` class,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Until here, we have successfully refactored the `HexCharToByte()` function
    into the `HexCharToByteFunctional()` function. We can modify the `HexStringToInt()`
    function to invoke the `HexCharToByteFunctional()` function, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the `HexStringToInt()` function does not implement the functional
    approach. We can refactor it to the `HexStringToIntFunctional()` function, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding `HexStringToIntFunctional()` function, we can see that,
    first, we convert the strings into a list of characters by reversing the order
    of the list. This is because we need to assign the least significant byte with
    the lowest index. We then select each member of the list and create a new class
    that contains the character itself and the index. Afterwards, we sum them up based
    on their index and value. Now, we have the following `GetIntFromHexStringFunctional()`
    function, and it invokes the `HexStringToIntFunctional()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This is actually similar to the `GetIntFromHexString()` function in the `MatchingPattern.csproj`
    project. If we run the `GetIntFromHexStringFunctional()` function, we will get
    the following output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simplifying pattern matching](img/Image00108.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we get the exact same output compared to the `GetIntFromHexString()`
    function in the `MatchingPattern.csproj` project since we have successfully refactored
    it to functional pattern matching.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a simpler method in pattern matching, we can use the `Simplicity` NuGet
    package, which we can download directly from Visual Studio using **Package Manager
    Console** and typing `Install-PackageSimplicity` .
  prefs: []
  type: TYPE_NORMAL
- en: Welcoming the coming of pattern matching feature in C# 7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The planned language features in C# 7 includes pattern matching which has the
    extensions to the `is` operator. We now can introduce a new variable after the
    type and this variable is assigned to the left-hand side operand of the `is` operator
    but with the type specified as the right-hand side operand. Let''s make it clear
    using the following code snippet which we can find in `MatchingPatternCSharp7.csproj`
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'And the `GetData()` function implementation is as follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding `IsOperatorBeforeCSharp7()` function, we should assign `s`
    variable with the value of `o` after we check the content of the `o` object variable
    in `if` statement. It is what we can do before C# 7 introduce pattern matching
    feature. Now, let''s compare the preceding code with the following `IsOperatorInCSharp7()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we now can assign `s` variable with the content of `o` variable
    but with the string data type, as we have discussed earlier. We assign the `s`
    variable inside the `if` statement when the condition is checked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, this feature can also be applied in switch statement as we can
    see in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding `SwitchCaseInCSharp7()` function, we can assign
    `s` and `i` variable with the content of `x` variable in the `case` checking so
    we don't need to assign the variable again.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information about pattern matching feature in C# 7, we can find it
    in official Roslyn GitHub page on [https://github.com/dotnet/roslyn/blob/features/patterns/docs/features/patterns.md](https://github.com/dotnet/roslyn/blob/features/patterns/docs/features/patterns.md)
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Monad as a design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s quite difficult to explain **Monad** in an **object-oriented programming**
    ( **OOP** ) language such as C#. However, in OOP, there is one useful idea to
    explain Monad: design patterns. A design pattern is a reusable solution for complex
    problems in software design. Imagine a design pattern in architecture. Many buildings
    in this world must have the same pattern: doors, windows, walls, and so on. If
    we compare design patterns in architecture with design patterns in software design,
    we''ll realize that they both have the same idea. In a design pattern for software
    design, we have functions, types, variables, and so on. These design pattern have
    been available in the C# language and will come together to build an application.'
  prefs: []
  type: TYPE_NORMAL
- en: Considering this design pattern definition, we now have a definition of Monad
    itself. Monad is a type that uses a Monad pattern. And the Monad pattern is a
    design pattern for types.
  prefs: []
  type: TYPE_NORMAL
- en: In C#, there are some types that have actually implemented Monad naturally;
    they are `Nullable<T>` , `IEnumerable<T>` , `Func<T>` , `Lazy<T>` , and `Task<T>`
    . Some of these types had been discussed in the previous chapter. However, we
    will discuss them again in correlation with an explanation of Monad.
  prefs: []
  type: TYPE_NORMAL
- en: These five types have several things in common; obviously, they are generic
    types that take only one parameter, `T` . They implement monad naturally since
    they have certain rules that have certain operations provided; in other words,
    they are amplifiers of types. They can take a type and turn it into a special
    type.
  prefs: []
  type: TYPE_NORMAL
- en: We can say that `Nullable<T>` is an amplifier of types because it can turn,
    for instance, `int` to null, which is impossible without the use of `Nullable<T>`
    since `int` can only handle `-2,147,483,648` to `2,147,483,647` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following code, which we can find in the `AmplifierOfTypes.csproj`
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will convert the number in the `string` type into the `int`
    type. However, since the `string` type is allowed to be null, the `int` type will
    not be able to handle this data type. For this purpose, we use `Nullable<int>`
    as a return type; so now, the returning value can be null, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can invoke the preceding `WordToNumber()` function using the following
    `PrintStringNumber()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can return `null` to the `int` data type since it has become a `Nullable`
    type, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet will handle the null string input that is passed
    to the `WordToNumber()` function. And now we can invoke the preceding `PrintStringNumber()`
    function using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the `PrintIntContainingNull()` function, we will get the following
    output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing Monad as a design pattern](img/Image00109.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding screenshot, you can see that we now can give the `int` data
    types' `null` value since it has implemented monad naturally and has been amplified
    using the amplifier of types.
  prefs: []
  type: TYPE_NORMAL
- en: '`IEnumerable<T>` also implements monad because it can amplify the type of `T`
    we pass to `IEnumerable<T>` . Suppose we want to amplify the string type using
    `IEnumerable<T>` in order for it to be enumerated and sorted; we can use the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `AmplifyString()` function, we are going to show that we can leverage
    the `string` type to store multiple values and represent the enumeration and sorting,
    as shown in the following code snippet, to initialize the enumerable string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the following code snippet to sort the enumerable string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of the `YieldNames()` function we use to initialize the
    enumerable string is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'And the implementation of the `SortAscending()` function that we use to sort
    the enumerable string will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, in the `YieldNames()` function implementation, the function
    will yield five people-name-typed strings. These people names will be kept in
    the `stringEnumerable` variable typed `IEnumerable<string>` . It becomes obvious
    that `stringEnumerable` has now been leveraged so that it can handle multiple
    values. And in the `SortAscending()` function, we can see that `stringEnumerable`
    has been leveraged so that it can be sorted and ordered. If we run the preceding
    `AmplifyString()` function, we will get the following output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing Monad as a design pattern](img/Image00110.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding screenshot, we can see that we have successfully amplified
    the `string` type so it can now enumerate multiple `string` values and can sort
    their values.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have discussed in many ways in the previous chapter, `Func<T>` is an
    encapsulate method that returns a value of the type specified by the `T` parameter
    with no need to pass any parameter. For this purpose, we will create the following
    `Func<T>` method in our `AmplifiedFuncType.csproj` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '`MultipliedFunc` is a delegate that will take care of a function that returns
    the `int` value with no passing argument. Now, the following code will explain
    that `Func<T>` also implements monad naturally. However, before we go through
    with the `Func<T>` explanation, we are going to create a wrapper using the `Nullable`
    type we discussed earlier. Let''s take a look at the following `MultipliedByTwo()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GetNullableFromInt()` function in the `MultipliedByTwo()` function has
    the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MultipliedByTwo()` function is simple. Obviously, it will wrap the unwrapped
    value after we perform the multiplication operator on that unwrapped value. Suppose
    we have the following `RunMultipliedByTwo()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding `RunMultipliedByTwo()` function, we will have the following
    output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing Monad as a design pattern](img/Image00111.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding screenshot, you can see that there's a general pattern provided
    by the function. The unwrapped 1, 2, 3, 4, 5 will be multiplied by two and will
    be wrapped into 2, 4, 6, 8, 10.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to explain `Func<T>` . Let''s create the following `GetFuncFromInt()`
    function, which will return the value typed `Func<int>` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `GetFuncFromInt()` function will generate a brand new `Func<T>`
    method from the `int` value. Again, we will create the `MultipliedByTwo()` function
    but with a different signature, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding will successfully compile. However, suppose we have the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding `RunMultipliedByTwoFunc()` function, we will get the
    fixed result `4` rather that the formula `(1 + 1) * 4` . To solve this problem,
    we can create new code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Using the preceding `MultipliedByTwoFunction()` function, the original function
    delegate value is kept every time the new value is requested. And now we can conclude
    that our previous code will use the unwrapped value and then perform some operation
    on it. There are differences between using the `Nullable<int>` operation and the
    `Func<int>` operation, such as how the wrapped type result is created. Using the
    `Nullable` monad, we can directly use the unwrapped value , perform a computation,
    and then produce the wrapped value. Using `Func` Monad, however, we have to be
    smarter since, as we discussed earlier, we have to produce a delegate in order
    to keep the previous `Func` Monad.
  prefs: []
  type: TYPE_NORMAL
- en: And in Monad, we can see that by multiplying two into the wrapped `int` , the
    function can produce another wrapped `int` so that we can call it *amplification*
    .
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Monadic M<T> type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we are going to implement higher-order programming in monad by refactoring
    our previous code. Let''s take a look at the following `MultipliedByTwoFunction()`
    function, which we can find in the `GeneratingMonadInCSharp.csproj` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding `MultipliedByTwoFunction()` function, you can see that we
    now use `Func<int, int>` , which passes an integer argument to produce an integer
    result. We also get the `Nullable<int>` parameter directly from the argument now.
    And we can have the following `MultipliedByTwo()` function get the value of multiplying
    by two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding `MultipliedByTwo()` function, we see that we define the `iNullable`
    value and the anonymous method, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'And suppose we have the following `RunMultipliedByTwo()` function to call the
    `MultipliedByTwo()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding `RunMultipliedByTwo()` function, we will get the following
    output on the console screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the Monadic M<T> type](img/Image00112.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the preceding screen shot, we have successfully refactored
    our `MultipliedByTwo()` function in the `AmplifiedFuncType.csproj` project.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the generic data type to Monad
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can also make our previous `MultipliedByTwo()` function more general by
    implementing generics, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'And if for some reason we need to have a function that passes an integer value
    but results in a double-for instance, and we want to divide an integer number,
    we can amplify that function so that it can modify the value from `int` to `double`
    , as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'And since `Nullable` is a amplification of type in the preceding `MultipliedByTwoFunction()`
    method, we can modify it to any other types, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'As we discussed earlier, `MultipliedByTwoFunction()` has a monad pattern since
    it passes a value of a particular type and turns it into a value of the amplified
    type. In other words, we have a function that has a pattern to turn a function
    from `V` to `R` into a function from `M<V>` to `M<R>` , where `M<R>` is an amplified
    type. This is so that we can write a method that has a Monad pattern like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have a monadic `M<T>` type, which is to be used if we need to implement
    a Monad pattern in our function. However, if we take a look at our previous `MultipliedByTwoFunction<V,
    R>()` method, we can see that there is something we can improve in it, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We have modified the second parameter from `Func<V, R>` to `Func<V, Nullable<R>>`
    . This is done to prevent an inappropriate result, such as `Nullable<Nullable<double>>`
    , if we expect the return type `Nullable<double>` . We can also implement it to
    another type, such as `Func<T>` , as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Implementing Monad to Lazy<T> and Task<T>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Besides type `Func<T>` , we can also implement Monad to `Lazy<T>` and `Task<T>`
    , as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we can implement it for `IEnumerable<T>` . The code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'After we dissect the `MultipliedByTwoFunctionSpecial()` function for various
    data types, such as `Nullable` , `Func` , `Lazy` , `Task` , and `IEnumerable`
    , we can see that a monadic type has flattened `M<M<R>>` into `M<R>` . We can
    see that, when using the `Nullable` type, we have to avoid making `Nullable<Nullable<R>>`
    by checking whether the passing `Nullable` type''s argument has a value. If not,
    just return a null `Nullable<R>` type, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'When we use task, we also have to await the outer task and then await the inner
    task to avoid creating a `<Task<R>>` task, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The other monadic types have the same pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Rules of the Monad pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have discussed that the Monad pattern will always wrap up a value typed
    `T` into an instance of `M<T>` , as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, in the monad pattern, we can transform the instance of `M<V>` to an instance
    of `M<R>` if we have a function from `V` to `R` , as shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Another rule the Monad pattern has is that we can transform the type of `V`
    to an instance of `M<R>` and then apply it to an instance of `M<V>` if we have
    a function from `V` to `M<R>` , as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pattern matching is a form of dispatch to choose the correct variant of functions
    to be called. In other words, its concept is close to the `if` conditional expression
    because we have to decide the correct selection by providing specific input. The
    matching process can be simplified to make it implement a functional approach.
    We discussed the `switch` case and then refactored it using LINQ so it became
    functional.
  prefs: []
  type: TYPE_NORMAL
- en: 'We learned the definition of monad itself: a type that uses the Monad pattern,
    which is a design pattern for types. In C#, there are some types that have implemented
    Monad naturally; they are `Nullable<T>` , `IEnumerable<T>` , `Func<T>` , `Lazy<T>`
    , and `Task<T>` .'
  prefs: []
  type: TYPE_NORMAL
- en: For now, we have enough knowledge about functional programming in C#. In the
    next chapter, we will use everything you learned in this and previous chapters
    to develop an application that implements a functional approach. In the upcoming
    chapter, we will transform imperative code into functional code.
  prefs: []
  type: TYPE_NORMAL
