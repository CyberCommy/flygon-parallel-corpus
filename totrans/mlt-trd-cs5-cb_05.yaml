- en: Chapter 5. Using C# 5.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will look through the native asynchronous programming support
    in the C# 5.0 programming language. You will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the await operator to get asynchronous task results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the await operator in a lambda expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the await operator with consequent asynchronous tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the await operator for the execution of parallel asynchronous tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling exceptions in asynchronous operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid using the captured synchronization context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working around the async void method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a custom awaitable type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the dynamic type with await
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we learned about Task Parallel Library, the latest asynchronous programming
    infrastructure from Microsoft. It allows us to design our program in a modular
    manner, combining different asynchronous operations together.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, it is still difficult to understand the actual program flow when
    reading such a program. In a large program, there will be numerous tasks and continuations
    that depend on each other, continuations that run other continuations, continuations
    for exception handling, and they are all gathered together in the program code
    in very different places. Therefore, to understand the sequence of which operation
    goes first and what happens next becomes a very challenging problem.
  prefs: []
  type: TYPE_NORMAL
- en: Another issue to watch out for is to see if the proper synchronization context
    is propagated to each asynchronous task that could touch user interface controls.
    It is only permitted to use these controls from the UI thread; else, we would
    get a multithreaded access exception.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking about exceptions, we also have to use separate continuation tasks to
    handle errors that occur inside the antecedent asynchronous operation or operations.
    This in turn results in complicated error-handling code that is spread through
    different parts in the code, not logically related to each other.
  prefs: []
  type: TYPE_NORMAL
- en: To address these issues, the authors of C# 5.0 introduced new language enhancements
    called **asynchronous functions**. They really make asynchronous programming simple,
    but at the same time, it is a higher-level abstraction over TPL. As we mentioned
    in [Chapter 4](ch04.html "Chapter 4. Using Task Parallel Library"), *Using Task
    Parallel Library*, abstraction hides important implementation details and makes
    asynchronous programming easier at the cost of taking away many important things
    from the programmer. It is very important to understand the concept behind asynchronous
    functions to create robust and scalable applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an asynchronous function, first you mark a method with the `async`
    keyword. It is not possible to have the async property or event accessor methods
    and constructors without first doing this. The code will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Another important fact is that asynchronous functions must return the `Task`
    or `Task<T>` type. It is possible to have the `async void` methods, but it is
    preferable to use the `async Task` method instead. The only reasonable option
    to use `async void` functions is when using top-level UI control event handlers
    in your application.
  prefs: []
  type: TYPE_NORMAL
- en: Inside a method marked with the `async` keyword, you can use the `await` operator.
    This operator works with tasks from TPL and gets the result of the asynchronous
    operation inside the task. The details will be covered later in the chapter. You
    cannot use the `await` operator outside the `async` method; there will be a compilation
    error. In addition, asynchronous functions should have at least one `await` operator
    inside its code. However, it will lead to just a compilation warning, not an error.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that this method returns immediately after the line
    with the `await` call. In case of synchronous execution, the executing thread
    will be blocked for 2 seconds and then return a result. Here, we wait asynchronously
    while returning a worker thread to a thread pool, immediately after executing
    the `await` operator. After 2 seconds, we get the worker thread from a thread
    pool once again and run the rest of the asynchronous method on it. This allows
    us to re-use this worker thread to do some other work while these 2 seconds pass,
    which is extremely important for application scalability. With the help of asynchronous
    functions we have a linear program control flow, but it is still asynchronous.
    This is both very comfortable and very confusing. The recipes in this chapter
    will help you to learn every important aspect of asynchronous functions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From my experience, there is a common misunderstanding about how programs work
    if there are two consecutive `await` operators in it. Many people think that if
    we use the `await` function on one asynchronous operation after another, they
    run in parallel. However, they actually run sequentially; the second one starts
    only when the first operation completes. It is very important to remember this,
    and later in the chapter, we will cover this topic in detail.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of limitations connected with using `async` and `await` in
    C# 5.0\. For example, it is not possible to mark the console application's `Main`
    method as `async`; you cannot have the `await` operator inside a `catch`, `finally`,
    `lock`, or `unsafe` block. It is not allowed to have `ref` and `out` parameters
    on an asynchronous function. There are more subtleties, but these are the major
    points.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous functions are turned into complex program constructs by the C#
    compiler behind the scenes. I intentionally will not describe this in detail;
    the resulting code is quite similar to another C# construct, called **iterators**,
    and is implemented as a sort of state machine. Since many developers have started
    to use the `async` modifier almost on every method, I would like to emphasize
    that there is no sense in marking a method as `async` if it is not intended to
    be used in an asynchronous or parallel manner. Calling the `async` method includes
    a significant performance hit, and the usual method call is going to be about
    40 to 50 times faster as compared to the same method marked with the `async` keyword.
    Please be aware of that.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn to use the C# 5.0 `async` and `await` keywords
    to work with asynchronous operations. We will cover how to await the asynchronous
    operations sequentially and in parallel. We will discuss how to use `await` in
    lambda expressions, how to handle exceptions, and how to avoid pitfalls when using
    the `async void` methods. To conclude the chapter, we will dive deep into synchronization
    context propagation and learn how to create our own awaitable objects instead
    of using tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Using the await operator to get asynchronous task results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe walks through the basic scenario of using asynchronous functions.
    We will compare how to get an asynchronous operation result with TPL and with
    the `await` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter5\Recipe1`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use the `await` operator to get asynchronous task results, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the program runs, we run two asynchronous operations. One of them is standard
    TPL-powered code, and the second one uses the new `async` and `await` C# features.
    The `AsynchronyWithTPL` method starts a task that runs for 2 seconds and then
    returns a string with information about the worker thread. Then, we define a continuation
    to print out the asynchronous operation result after the operation completes,
    and another one to print the exception details in case errors occur. Finally,
    we return a task representing one of the continuation tasks, and wait for its
    completion in the `Main` method.
  prefs: []
  type: TYPE_NORMAL
- en: In the `AsynchronyWithAwait` method, we achieve the same result by using `await`
    with the task. It is as if we write just usual synchronous code – we get the result
    from the task, print out the result, and catch an exception if the task is completed
    with errors. The key difference is that we actually have an asynchronous program.
    Immediately after using `await`, C# creates a task that has a continuation task
    with all the remaining code after the `await` operator, and deals with exception
    propagation as well. Then, we return this task to the `Main` method and wait until
    it completes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that depending on the nature of the underlying asynchronous operation
    and the current synchronization context, the exact means of executing the asynchronous
    code may differ. We will explain this later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we can see that the first and the second parts of the program are
    conceptually equivalent, but in the second part the C# compiler does the work
    of handling asynchronous code implicitly. It is, in fact, even more complicated
    than the first part, and we will cover the details in the next few recipes of
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Please remember that it is not recommended to use the `Task.Wait` and `Task.Result`
    methods in environments, such as Windows GUI or ASP.NET. This could lead to deadlocks
    if the programmer is not 100% aware of what is really going on in the code. This
    was illustrated in the *Tweaking tasks execution with TaskScheduler* recipe of
    [Chapter 4](ch04.html "Chapter 4. Using Task Parallel Library"), *Using Task Parallel
    Library*, when we used `Task.Result` in the WPF application.
  prefs: []
  type: TYPE_NORMAL
- en: To test how exception handling works, just uncomment the `throw new Exception`
    line inside the `GetInfoAsync` method.
  prefs: []
  type: TYPE_NORMAL
- en: Using the await operator in a lambda expression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show how to use `await` inside a lambda expression. We will
    write an anonymous method that uses `await`, and get a result of the method execution
    asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter5\Recipe2`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To write an anonymous method that uses `await` and get a result of the method
    execution asynchronously by using the `await` operator in a lambda expression,
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we move out the asynchronous function into the `AsynchronousProcessing`
    method since we cannot use `async` with `Main`. Then, we describe a lambda expression
    using the `async` keyword. As the type of any lambda expression cannot be inferred
    from the lambda itself, we have to specify its type to the C# compiler explicitly.
    In our case, the type means that our lambda accepts one string parameter, and
    returns a `Task<string>` object.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we define the lambda expression body. One aberration is that the method
    is defined to return a `Task<string>` object, but we actually return a string,
    and get no compilation errors! The C# compiler automatically generates a task
    and returns it for us.
  prefs: []
  type: TYPE_NORMAL
- en: The last step is to await the asynchronous lambda expression execution and print
    out the result.
  prefs: []
  type: TYPE_NORMAL
- en: Using the await operator with consequent asynchronous tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show how exactly the program flows when we have several consecutive
    `await` methods in the code. We will learn how to read the code with the `await`
    methods and understand why the `await` call is an asynchronous operation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter5\Recipe3`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand a program flow in the presence of consecutive `await` methods,
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the program runs, we run two asynchronous operations just as in the first
    recipe. However, this time we shall start from the `AsynchronyWithAwait` method.
    It still looks like the usual synchronous code; the only difference is the two
    `await` statements. The most important point is that the code is still sequential,
    and the `Async 2` task will start only after the previous one completes. When
    we read the code, the program flow is very clear: we see what runs first, and
    what goes after. Then, how is this program asynchronous? Well, first, it is not
    always asynchronous. If a task is already complete when we use `await`, we will
    get its result synchronously. Otherwise, the common approach when we see an `await`
    statement inside the code is to note that at this point the method will return
    immediately and the rest of the code will be run in a continuation task. Since
    we do not block the execution waiting for the result of an operation, it is an
    asynchronous call. Instead of calling `t.Wait` in the `Main` method, we can perform
    any other task, while the code in `AsynchronyWithAwait` method is executing. However,
    the main thread must wait until all the asynchronous operations complete, or they
    will be stopped as they run on background threads.'
  prefs: []
  type: TYPE_NORMAL
- en: The `AsynchronyWithTPL` method imitates the same program flow as the `AsynchronyWithAwait`
    method does. We need a container task to handle all the dependent tasks together.
    Then, we start the main task, and add a set of continuations to it. When the task
    is complete, we print out the result; we then start one more task, which in turn
    has more continuations to continue work after the second task completes. To test
    the exception handling, we throw an exception on purpose when running the second
    task and get its information printed out. This set of continuations creates the
    same program flow as in the first method, and when we compare it to the code with
    the `await` methods, we can see that it is much easier to read and understand.
    The only trick is to remember that asynchrony does not always mean parallel execution.
  prefs: []
  type: TYPE_NORMAL
- en: Using the await operator for the execution of parallel asynchronous tasks execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use `await` to run asynchronous operations
    in parallel instead of the usual sequential execution.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter5\Recipe4`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand the use of `await` operator for parallel asynchronous tasks execution,
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here we define two asynchronous tasks running for 3 and 5 seconds respectively.
    Then, we use a `Task.WhenAll` helper method to create another task that will complete
    only when all of the underlying tasks complete. Then, we await the result of this
    combined task. After 5 seconds, we get all the results, which means that the tasks
    were running simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is one interesting observation. When you run the program, you
    might notice that both tasks are likely to be served by the same worker thread
    from a thread pool. How is that possible when we have run the tasks in parallel?
    To make things even more interesting, let's comment out the `await Task.Delay`
    line inside the `GetIntroAsync` method and uncomment the `await Task.Run` line,
    and then run the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see that in this case both the tasks will be served by different worker
    threads. The difference is that `Task.Delay` uses a timer under the hood, and
    the processing goes as follows: we get the worker thread from a thread pool, which
    awaits the `Task.Delay` method to return a result. Then, the `Task.Delay` method
    starts the timer and specifies a piece of code that will be called when the timer
    counts the number of seconds specified to the `Task.Delay` method. Then we immediately
    return the worker thread to a thread pool. When the timer event runs, we get any
    available worker thread from a thread pool once again (which could be the same
    thread we used first) and run the code provided to the timer on it.'
  prefs: []
  type: TYPE_NORMAL
- en: When we use the `Task.Run` method, we get a worker thread from a thread pool
    and make it block for a number of seconds, provided to the `Thread.Sleep` method.
    Then, we get a second worker thread and block it as well. In this scenario, we
    consume two worker threads and they do absolutely nothing, not being able to perform
    any other task while waiting.
  prefs: []
  type: TYPE_NORMAL
- en: We will talk in detail about the first scenario in [Chapter 9](ch09.html "Chapter 9. Using
    Asynchronous I/O"), *Using asynchronous I/O*, where we will discuss a large set
    of asynchronous operations working with data inputs and outputs. Using the first
    approach whenever possible is the key to creating scalable server applications.
  prefs: []
  type: TYPE_NORMAL
- en: Handling exceptions in the asynchronous operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will describe how to deal with exception handling using asynchronous
    functions in C#. We will learn how to work with aggregate exceptions in case you
    use `await` with multiple parallel asynchronous operations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter5\Recipe5`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand handling exceptions in asynchronous operations, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We run three scenarios to illustrate the most common cases of error handling
    using `async` and `await` in C#. The first case is very simple, and almost identical
    to the usual synchronous code. We just use the `try`/`catch` statement and get
    the exception's details.
  prefs: []
  type: TYPE_NORMAL
- en: A very common mistake is using the same approach when more than one asynchronous
    operation is being awaited. If we use the `catch` block the same way as before,
    we will get only the first exception from the underlying `AggregateException`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: To collect all the information, we have to use the awaited tasks' `Exception`
    property. In the third scenario, we flatten the `AggregateException` hierarchy,
    and then unwrap all the underlying exceptions from it using the `Flatten` method
    of `AggregateException`.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid using the captured synchronization context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe talks about the details of synchronization context behavior when
    `await` is used to get asynchronous operation results. We will learn how and when
    to turn off the synchronization context flow.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter5\Recipe6`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand details of synchronization context behavior when `await` is used
    and to learn how and when to turn off the synchronization context flow, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add references to Windows Presentation Foundation Library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the **References** folder in the project, and select the **Add
    reference…** menu option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add references to the following libraries: **PresentationCore**, **PresentationFramework**,
    **System.Xaml**, and **Windows.Base**. You can use the search function in the
    reference manager dialog as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/7644OT_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the `Main` method with the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we will study one of the most important aspects of an asynchronous
    function's default behavior. We already know about task schedulers and synchronization
    contexts from [Chapter 4](ch04.html "Chapter 4. Using Task Parallel Library"),
    *Using Task Parallel Library*. By default, the `await` operator tries to capture
    synchronization contexts, and executes the following code on it. As we already
    know, this helps us write asynchronous code by working with user interface controls.
    In addition, deadlock situations like those that were described in the previous
    chapter will not happen when using `await`, since we do not block the UI thread
    while waiting for the result.
  prefs: []
  type: TYPE_NORMAL
- en: It is reasonable, but let's see what can potentially happen. In this example,
    we create a Windows Presentation Foundation application programmatically and subscribe
    to its button-click event. When clicking the button, we run two asynchronous operations.
    One of them uses a regular `await` operator while the other uses the `ConfigureAwait`
    method with `false` as a parameter value. It explicitly instructs that we should
    not use captured synchronization contexts to run continuation code on it. Inside
    each operation, we measure the time they take to complete, and then we display
    the respective time and ratios on the main screen.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, we see that the regular `await` operator takes much more time to
    complete. This is because we post one hundred thousand continuation tasks on the
    UI thread, which uses its message loop to asynchronously work with those tasks.
    In this case, we do not need this code to run on the UI thread, since we do not
    access the UI components from the asynchronous operation; using `ConfigureAwait`
    with `false` will be a much more efficient solution.
  prefs: []
  type: TYPE_NORMAL
- en: There is one more thing worth noting. Try to run the program by just clicking
    on the button and waiting for the results. Now do the same thing again, but this
    time click on the button and try to drag the application window from side-to-side
    in a random manner. You will notice that the code on the captured synchronization
    context becomes slower! This funny side-effect perfectly illustrates how dangerous
    asynchronous programming is. It is very easy to experience a situation like this,
    and it would be almost impossible to debug if you have never experienced such
    a behavior before.
  prefs: []
  type: TYPE_NORMAL
- en: To be fair, let's see the opposite scenario. In the preceding code snippet,
    inside the `Click` method, uncomment the commented line and comment its immediately
    preceding line. When running the application, we will get a multithreaded control
    access exception, because the code that sets the `Label` control text will not
    be posted on the captured context, but will be executed on a thread pool worker
    thread instead.
  prefs: []
  type: TYPE_NORMAL
- en: Working around the async void method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe describes why `async void` methods are quite dangerous to use. We
    will learn in what situations it is acceptable to use this method, and what to
    use instead when possible.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter5\Recipe7`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To learn how to work with the `async void` method, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the program starts, we start two asynchronous operations by calling the
    two methods, `AsyncTask` and `AsyncVoid`. The first method returns a `Task` object
    while the other returns nothing since it is declared as `async void`. They both
    return immediately since they are asynchronous, but then the first one can be
    easily monitored with the returned task status or just by calling the `Wait` method
    on it. The only way to wait for the second method to complete is to literally
    wait for some time because we have not declared any object we can use to monitor
    the state of the asynchronous operation. Of course, it is possible to use some
    kind of shared state variable and set it from the `async void` method while checking
    it from the `calling` method, but it is better to just return a `Task` object
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: The most dangerous part is exception handling. In case of the `async void` method,
    the exception handling methods will be posted to a current synchronization context;
    in our case, a thread pool. An unhandled exception on a thread pool will terminate
    the whole process. It is possible to intercept unhandled exceptions using the
    `AppDomain.UnhandledException` event, but there is no way to recover the process
    from there. To experience this, we should uncomment the `try`/`catch` block inside
    the `Main` method, and then run the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another fact about using the `async void` lambda expressions: they are compatible
    with the `Action` type, which is being widely used in the standard .NET Framework
    class library. It is very easy to forget about exception handling inside this
    lambda, which will crash the program again. To see an example of this, uncomment
    the second commented-out block inside the `Main` method.'
  prefs: []
  type: TYPE_NORMAL
- en: I strongly recommended using `async void` only in UI event handlers. In all
    other situations, use the methods that return `Task` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a custom awaitable type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows how to design a very basic awaitable type that is compatible
    with the `await` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter5\Recipe8`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For designing a custom awaitable type, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To be compatible with the `await` operator, a type should comply with a number
    of requirements, stated in the C# 5.0 specification. If you have Visual Studio
    2012 installed, you may find the specifications document inside the `C:\Program
    Files\Microsoft Visual Studio 11.0\VC#\Specifications\1033` folder (assuming you
    have used the default installation path).
  prefs: []
  type: TYPE_NORMAL
- en: 'In paragraph 7.7.7.1, we find a definition of awaitable expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The task of an await expression is required to be awaitable. An expression
    t is awaitable if one of the following holds:*'
  prefs: []
  type: TYPE_NORMAL
- en: '*t is of compile time type dynamic*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*t has an accessible instance or extension method called GetAwaiter with no
    parameters and no type parameters, and a return type A for which all of the following
    hold:*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A implements the interface System.Runtime.CompilerServices.INotifyCompletion
    (hereafter known as INotifyCompletion for brevity)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A has an accessible, readable instance property IsCompleted of type bool*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A has an accessible instance method GetResult with no parameters and no type
    parameters*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This information is enough to get started. First, we define an awaitable type
    `CustomAwaitable` and implement the `GetAwaiter` method, that in turn returns
    an instance of the `CustomAwaiter` type. `CustomAwaiter` implements the `INotifyCompletion`
    interface; has the `IsCompleted` property of type `bool`, and has the `GetResult`
    method, which returns a `string` type. Finally, we write a piece of code that
    creates two `CustomAwaitable` objects and awaits both of them.
  prefs: []
  type: TYPE_NORMAL
- en: Now we should understand the way `await` expressions are evaluated. This time,
    the specifications have not been quoted to avoid unnecessary details. Basically,
    if the `IsCompleted` property returns `true`, we just call the `GetResult` method
    synchronously. This prevents us from allocating resources for asynchronous task
    execution if the operation has already been completed. We cover this scenario
    by providing the `completeSynchronously` parameter to the constructor method of
    the `CustomAwaitable` object.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, we register a callback action to the `OnCompleted` method of `CustomAwaiter`
    and start the asynchronous operation. When it completes, it calls the provided
    callback, which will get the result by calling the `GetResult` method on the `CustomAwaiter`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This implementation has been used for educational purposes only. Whenever you
    write asynchronous functions, the most natural approach is to use the standard
    `Task` type. You should define your own awaitable type only if you have a solid
    reason why you cannot use `Task`, and you know exactly what you are doing.
  prefs: []
  type: TYPE_NORMAL
- en: There are many other topics related to designing custom awaitable types, such
    as the `ICriticalNotifyCompletion` interface implementation and synchronization
    context propagation. After understanding the basics of how an awaitable type is
    designed, you will be able to use the C# language specification and other information
    sources to find out the details you need with ease. But I would like to emphasize
    that you just use the `Task` type, unless you have a really good reason not to.
  prefs: []
  type: TYPE_NORMAL
- en: Using the dynamic type with await
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows how to design a very basic type that is compatible with the
    `await` operator and dynamic C# type.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2012\. You will need
    Internet access to download the NuGet package. There are no other prerequisites.
    The source code for this recipe can be found at `BookSamples\Chapter5\Recipe9`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To learn how to use the `dynamic` type with `await`, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add references to the **ImpromptuInterface** NuGet package by following these
    steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the **References** folder in the project and select the Manage
    NuGet Packages… menu option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now add your preferred references to the **ImpromptuInterface NuGet** package.
    You can use the search function in the **Manage NuGet Packages** dialog as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/7644OT_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the `Program.cs` file, use the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we repeat the trick from the previous recipe, but this time with the help
    of dynamic expressions. We can achieve this goal with the help of NuGet—a package
    manager that contains many useful libraries. This time we will use a library that
    dynamically creates wrappers, implementing the interfaces we need.
  prefs: []
  type: TYPE_NORMAL
- en: To start with, we create two instances of the `ExpandoObject` type and assign
    them to dynamic local variables. These variables will be our awaitable and awaiter
    objects. Since an awaitable object just requires having the `GetAwaiter` method,
    there are no problems with providing it. `ExpandoObject` combined with the `dynamic`
    keyword allows us to customize it and add properties and methods by assigning
    corresponding values. It is in fact a dictionary-type collection with keys of
    type `string` and values of type `object`. If you are familiar with the JavaScript
    programming language, you might notice that this is very similar to JavaScript
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Since `dynamic` allows us to skip compile-time checks in C#, `ExpandoObject`
    is written in such a way that if you assign something to a property, it creates
    a dictionary entry, where the key is the property name and a value is any value
    supplied. When you try to get the property value, it goes into the dictionary
    and provides the value that is stored in the corresponding dictionary entry. If
    the value is of the type `Action` or `Func`, we actually store a delegate, which
    in turn can be used like a method. Therefore, a combination of the `dynamic` type
    with `ExpandoObject` allows us to create an object and dynamically provide it
    with properties and methods.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to construct our awaiter and awaitable objects. Let's start with
    the awaiter. First, we provide a property called `Message` and an initial value
    to this property. Then, we define the `GetResult` method, by using a `Func<string>`
    type, we assign a lambda expression, which returns the `Message` property value.
    We next implement the `IsCompleted` property. If it is set to `true`, we can skip
    the rest of the work and proceed to our awaitable object, stored in the `result`
    local variable. We just need to add a method returning the `dynamic` object and
    return our awaiter from it. Then, we can use `result` as the await expression;
    however, it will run synchronously.
  prefs: []
  type: TYPE_NORMAL
- en: The main challenge is implementing asynchronous processing on our dynamic object.
    C# language specifications state that an awaiter must implement the `INotifyCompletion`
    or `ICriticalNotifyCompletion` interface, which `ExpandoObject` does not do. And
    even when we implement the `OnCompleted` method dynamically, adding it to the
    awaiter object, we will not succeed because our object does not implement either
    of the mentioned interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: To work around this problem, we use the `ImpromptuInterface` library that we
    obtained from NuGet. It allows us to use the `Impromptu.ActLike` method for dynamically
    creating proxy objects that will implement the required interface. If we try to
    create a proxy implementing the `INotifyCompletion` interface, we will still fail,
    because the proxy object is not dynamic anymore, and this interface has the `OnCompleted`
    method only, but does not have the `IsCompleted` property or the `GetResult` method.
    As the last workaround, we define a generic interface, `IAwaiter<T>`, which implements
    `INotifyCompletion` and adds all the required properties and methods. Now, we
    use it for proxy generation and change the `result` object to return a proxy instead
    of awaiter from the `GetAwaiter` method. The program now works; we have just constructed
    an awaitable object that is completely dynamic at runtime.
  prefs: []
  type: TYPE_NORMAL
