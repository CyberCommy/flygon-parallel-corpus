- en: Building a Chat Room Application Using Socket.IO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to cover how to build an Angular chat room application
    using Socket.IO in order to delve into the ability to send messages back and forth
    between the client and server without having to establish REST APIs or through
    the use of GraphQL queries. The technology we are going to use involves the establishment
    of a long-running connection from the client to the server, making communication
    as simple as passing a message.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Long-running client/server communications using Socket.IO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Socket.IO server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an Angular client and adding Socket.IO support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using decorators to add client-side logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Bootstrap in our client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Bootstrap navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signing up to Auth0 to authenticate our client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Auth0 support to our client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding secure Angular routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hooking up to Socket.IO messages at our client and server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Socket.IO namespaces to segregate messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding room support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receiving and sending messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The finished project can be downloaded from [https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter06](https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter06)[.](https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter06)
  prefs: []
  type: TYPE_NORMAL
- en: After downloading the project, you will have to install the package requirements
    using the `npm install` command.
  prefs: []
  type: TYPE_NORMAL
- en: Long-running client/server communications using Socket.IO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have covered a variety of ways of communicating back and forth between
    a client and a server, but they have all had one thing in common—they were reacting
    to some form of interaction to trigger the transfer of data. Irrespective of whether
    we clicked a link or pushed a button, there was some user input that triggered
    that back and forth between the two sides.
  prefs: []
  type: TYPE_NORMAL
- en: There are some situations, however, where we would like to keep the lines of
    communication between the client and the server open permanently so that data
    can be pushed as soon as it's available. If we were playing an online game, for
    instance, we wouldn't want to have to push a button just to get other players'
    statuses updated on our screen. What we need is a technology that maintains the
    connection for us and allows us to pass messages without issues.
  prefs: []
  type: TYPE_NORMAL
- en: Over the years, there have been a number of technologies that have evolved with
    a view of addressing precisely this problem. Some of these technologies, such
    as flash sockets, have fallen out of favor because they rely on proprietary systems.
    Collectively, these are known as **push technologies**, and a standard called
    **WebSocket** has emerged and become commonplace, with all the major browsers
    supporting it. What is worth knowing is that WebSocket sits alongside HTTP as
    a cooperative protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a piece of WebSocket trivia for you. While HTTP uses HTTP or HTTPS to
    identify the protocol, the specification for WebSockets defines **WS** or **WSS **(short
    for **WebSocket Secure**) as the protocol identifier.
  prefs: []
  type: TYPE_NORMAL
- en: In the node world, Socket.IO has become the *de facto* standard for enabling
    WebSocket communication. We are going to use it to build a chat room application
    that keeps the chat open for all connected users.
  prefs: []
  type: TYPE_NORMAL
- en: Project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *classic* socket-based application is creating a chat room. It's almost
    the *Hello World* of socket applications. The reason that a chat room is so useful
    for this is because it allows us to explore techniques such as sending messages
    to other users, reacting to messages from other users, and using rooms to separate
    where chats are sent.
  prefs: []
  type: TYPE_NORMAL
- en: Material design played a large part in its development over the past couple
    of chapters, so now is a suitable time for us to return to Bootstrap 4 and see
    how we can use it to lay out the interface in an Angular application. We will
    also work with Socket.IO at the client and the server to enable bi-directional
    communication. Something that has been lacking in previous chapters has been the
    ability to authenticate the user. In this chapter, we are going to bring in authentication
    support by signing up to use Auth0 ([https://auth0.com/](https://auth0.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Working alongside the GitHub code, this chapter should take about two hours
    to complete. When completed, the application should appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dc5c7471-d8bc-47a2-be5f-b0db66be0c1b.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we know what type of application we want to build, and what we want
    it to look like, we are ready to start building our application. In the next section,
    we are going to look at how to add external authentication to our application
    using Auth0.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Socket.IO and Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the requirements, such as Node.js and Mongoose, are the same as in earlier
    chapters, so we are no longer going to list the additional components. As we go
    through this chapter, we will call out any new components that we need. As always,
    the canonical place for finding out what we are using is the code in GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: As part of this chapter, we are going to use Auth0 ([https://auth0.com](https://auth0.com))
    to authenticate our users. Auth0 is one of the most popular choices available
    for authentication as it takes care of all of the infrastructure. All we need
    to provide is a secure login and information storage mechanism. The idea behind
    us using Auth0 is that we will take advantage of their APIs to verify the identity
    of someone who is using our application through the use of the **open authentication** (**OAuth**)
    framework, which allows us to automatically show or hide access to parts of our
    application based on this authentication. With OAuth, and its successor OAuth
    2, we are using a standard authorization protocol that allows authenticated users
    access to features of our application without having to sign up to our site and
    provide login information.
  prefs: []
  type: TYPE_NORMAL
- en: Initially, this chapter was going to use a passport to provide authentication
    support but, given recent high-profile security issues from companies such as
    Facebook, I decided that we would look at Auth0 to take care of and manage our
    authentication. With authentication, I find that it's best to make sure I'm using
    the best of breed when it comes to security.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we write any code at all, we are going to sign up to Auth0 and create
    the infrastructure we need for a single page web application. Begin by clicking
    the Sign Up button, which will redirect you to the following URL: [https://auth0.com/signup?&signUpData=%7B%22category%22%3A%22button%22%7D](https://auth0.com/signup?&signUpData=%7B%22category%22%3A%22button%22%7D).
    I chose to sign up with my GitHub account, but you can choose any of the options
    available.'
  prefs: []
  type: TYPE_NORMAL
- en: Auth0 provides us with a variety of premium paid-for services as well as the
    free version. We only require the basic features, so the free version is perfect
    for our needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have signed up, you need to press the Create Application button, which
    will bring up the Create Application dialog. Give it a name and choose Single
    Page Web App before clicking the CREATE button to create the Auth0 application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9f145e06-448b-4ac8-803f-133153f590d8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you click the Settings tab, you should have something that looks like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1d372384-f3ed-4778-ad9e-73ba49ea0f4f.png)'
  prefs: []
  type: TYPE_IMG
- en: There are options available for callback URLs, allowed web origins, logout URLs,
    CORS, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The full scope of Auth0 is outside the scope of this book, but I would recommend
    reading the documentation provided and setting these settings as appropriate for
    any applications you create.
  prefs: []
  type: TYPE_NORMAL
- en: 'Security note: Where I am providing details about client IDs or similar unique
    identifiers in this book, these are purely for the purpose of illustrating the
    code. Any live IDs will be deactivated as a matter of security. I would advise
    you to adopt similar good practices and not commit live identifiers or passwords
    in a public location such as GitHub.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a chat room application using Socket.IO, Angular, and Auth0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start with our development, we should figure out what we want to
    build. Since a chat room is a common enough application, it is easy for us to
    come up with a standard set of requirements that will help us exercise the different
    aspects of Socket.IO. The requirements for the application we are going to build
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A user will be able to send a message to be seen by all users in a general chat
    page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user will be able to log in to the application, at which point a secure
    page will be available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logged-in users will be able to send messages that are visible only to other
    logged-in users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Old messages will be retrieved and displayed to the user when they connect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By now, creating a node application should be second nature, so we aren''t
    going to cover how to do that anymore. The `tsconfig` file that we are going to
    use is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The incremental flag in the settings is a new feature introduced in TypeScript
    3.4 that allows us to perform incremental builds. What this feature does is build
    something called a project graph when the code is compiled. The next time the
    code is built, the project graph is used to identify code that hasn't changed,
    meaning that it doesn't need to be rebuilt. In bigger applications, this can save
    a lot of time in terms of compiling.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to save messages to a database, so it''s going to come as no surprise
    that we are going to start off with the database connection code. What we are
    going to do on this occasion is move our database connection to a class decorator
    that accepts the name of the database as the parameter to the decorator factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to install `mongoose` and `@types/mongoose` before creating this.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in place, when we create our `server` class, we simply need to decorate
    it, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: That's it. When `SocketServer` is instantiated, the database will be connected
    automatically. I have to admit that I really like the simplicity of this approach.
    It's an elegant technique that can be carried over into other applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapter, we built a `DataAccessBase` class to simplify the
    way we worked with data. We are going to take that class and remove some of the
    methods we aren''t going to use in this application. At the same time, we are
    going to see how we can remove the hard model constraints. Let''s start with the
    class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Add` method should also look familiar from the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous chapter, we had a constraint that finding a record needed to
    have a field called `Id` on it. While that was an acceptable limitation there,
    we really don''t want to force applications to have `Id` as a field. We are going
    to provide a more open implementation that will allow us to specify any criteria
    we need for retrieving records and the ability to select what fields to return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like in the previous chapter, we are going to create a `mongoose.Document`-based
    interface and a `Schema` type. This will form the message contract and will store
    details about the room, the message text, and the date when we received the message.
    These will then be combined to create the physical model that we need to use as
    our database. Let''s see how:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define the `mongoose.Document` implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Schema` type that corresponds to this looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we create a `MessageModel` instance, which we will use to create the
    data access class that we will use to save and retrieve data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Adding Socket.IO support to our server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have now reached the point where we are ready to bring Socket.IO into our
    server and create a running server implementation. Run the following command to
    incorporate Socket.IO and the related `DefinitelyTyped` definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With these definitions available to us, we are going to bring Socket.IO support
    into our server and begin running it, ready to receive and transmit messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameter that our `OnConnect` method receives is the starting point for
    receiving and reacting to messages in Socket.IO. We use this to *listen* for a
    connection message that will indicate that a client has connected. When the client
    connects, it opens up what amounts to a socket for us on which to start receiving
    and sending messages. When we want to send messages directly to a particular client,
    we will use methods available from the `socket` that''s returned in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we need to understand that even though the name of the technology
    is Socket.IO, this is not a WebSocket implementation. While it can use web sockets,
    there is no guarantee that it actually will; for instance, corporate policies
    might prohibit the use of sockets. So, how does Socket.IO actually work? Well,
    Socket.IO is made up of a number of different cooperating technologies, one of
    which is called Engine.IO, and this provides the underlying transport mechanism.
    The first type of connection it takes, when connecting, is an HTTP long poll,
    which is a fast and efficient transport mechanism to open. During idle periods,
    Socket.IO attempts to determine whether the transport can be changed over to a
    socket and, if it can use a socket, it seamlessly and invisibly upgrades the transport
    to use sockets. As far as the client is concerned, they connect quickly, and messages
    are reliable since the Engine.IO part establishes connections even if firewalls
    and load balancers are present.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the things we want to provide for our clients is a history of the conversations
    that have gone on beforehand. This means that we want to read and save our messages
    to the database. Inside our connection, we are going to read all of the messages
    for the room the user is currently in and return them to the user. If a user has
    not logged in, they will only be able to see messages where the room has not been
    set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax looks slightly strange, so we will break it down step by step. The
    call to `GetAll` is calling the general-purpose `GetAll` method from our `DataAccessBase`
    class. When we created that implementation, we discussed the need to make it more
    general purpose, and to allow the calling code to specify what fields to filter
    on as well as what fields to return. When we say `{room: room}`,  we are telling
    Mongo that we want to filter our results based on the room. We can think of the
    equivalent SQL clause as being `WHERE room = roomVariable`. We also want to indicate
    what results we want back; in this case, we only want `messageText` without the
    `_id` field, so we use the `{messageText: 1, _id: 0}` syntax. When the results
    come back, we need to send the array of messages over to the client using `socket.emit`.
    This command sends these messages to the client that opened the connection, using
    `allMessages` as the key. If the client has code to receive `allMessages`, it
    will be able to react to these messages.'
  prefs: []
  type: TYPE_NORMAL
- en: The event name that we choose as the message leads us on to one of the limitations
    of Socket.IO. There are certain event names that we cannot use as a message because
    they have been restricted due to them having a special meaning to Socket.IO. These
    are `error`, `connect`, `disconnect`, `disconnecting`, `newListener`, `removeListener`,
    `ping`, and `pong`.
  prefs: []
  type: TYPE_NORMAL
- en: There isn't much point creating the server and sending messages if we haven't
    got anything at the client end to receive them. Even though we don't have all
    of our messages in place yet, we have sufficient infrastructure in place to start
    writing our client.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our chat room client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Again, we are going to create our Angular application using the `ng new` command.
    We are going to be providing routing support, but when we get around to doing
    the routing part, we will see how we can ensure that users cannot bypass our authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Since our Angular client will be making regular use of Socket.IO, we are going
    to bring support in for Socket.IO using an Angular-specific Socket.IO module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In `app.module.ts`, we will create a connection to our Socket.IO server by
    creating a configuration that points to the server URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This configuration is passed into the static `SocketIoModule.forRoot` method
    when we import the module, which will configure the client-side socket for us.
    As soon as our client starts, it will establish a connection, triggering the connect
    message sequence we described in the server code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Using decorators to add client-side logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the features we want to use in our client code is to be able to log
    method calls, along with the parameters that are passed into them. We have encountered
    this type of feature before when we looked at creating decorators. In this case,
    we want to create a `Log` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The way that the `Log` decorator works is that it starts off by copying the
    method from `propertyDescriptor.value`. We then replace this method by creating
    a function that takes in any parameters that are passed into the method. Inside
    this inner function, we use `args.map` to create a stringified representation
    of the parameter and value, which then joins them together. After calling `method.apply` to
    run the method, we write out details pertaining to the method and parameters to
    the console. With the preceding code, we now have a simple mechanism to automatically
    log methods and parameters just by using `@Log`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Bootstrap in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Instead of using Material in Angular, we can choose to use Bootstrap to style
    our pages. Adding support is a simple enough task. We begin, as always, by installing
    the relevant packages. In this case, we are going to install Bootstrap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have installed Bootstrap, we simply need to add a reference to our
    Bootstrap to our `styles` section in `angular.json`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, we are going to create a `navigation` bar that will sit
    at the top of our page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we add the `navigation` component body, we should replace the content
    of our `app.component.html` file so that it is serving up our navigation on every
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Bootstrap navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Bootstrap provides the `nav` component to which we can add `navigation`. Inside
    this, we are going to create a series of links. Like in the previous chapter,
    we will use `routerLink` to say what Angular should route to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Where things get interesting with routing concerns the use of authentication
    to show and hide links. If the user is authenticated, we want them to be able
    to see the Secret and Logout links. If the user has not been authenticated, we
    want them to see the Login link.
  prefs: []
  type: TYPE_NORMAL
- en: In the navigation, we can see a number of auth references. Behind the scenes,
    these all map back to `OauthAuthorizationService`. We teased the use of this back
    when we signed up to Auth0 at the beginning of this chapter. Now, it's time for
    us to add the authorization service that will connect our users up to Auth0.
  prefs: []
  type: TYPE_NORMAL
- en: Authorizing and authenticating users using Auth0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our authorization is going to consist of two parts—a service to perform the
    authorization, and a model to make working with the authorization simple. We will
    start off by creating our `Authorization` model, which contains the details we
    will receive back from a successful login. Note that the constructor brings in
    the `Socket` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this to create a series of useful helper methods. The first one
    we are going to create is a method to set the public properties if the user logs
    in. We are identifying a successful login as one where we receive an access token
    and an ID token as part of the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When the user logs on, we are going to send a `loggedOn` message back to the
    server, passing over the `Email` address. We will come back to this message shortly
    when we cover sending the messages to the server and handling the responses that
    come back. Note that we are logging the method and the properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user logs off, we want to clear the values and send the `loggedOff`
    message to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The final helper tells us whether the user has been authenticated by checking
    whether the `AccessToken` field is present, and whether the date when the ticket
    is due to expire exceeds the time when we perform the check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we create our `OauthAuthorizationService` service, we need some means
    of communicating with Auth0, so we will bring in support for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, we add a reference to `auth0.js` as a `script` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have all the pieces in place to create our service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The start of our service is straightforward enough. When we construct the service,
    we instantiate the helper class we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to hook up to Auth0\. You may recall that, when we signed
    up to Auth0, we were given a series of settings. From the settings, we require
    the client ID and domain. We are going to use these when we instantiate `WebAuth`
    from `auth0-js`, in order to uniquely identify our application. `responseType`
    tells us that we need the user''s authentication token and ID token back following
    a successful login. `scope` tells the user what features we want access to when
    they log in. If we wanted the profile, for instance, we could set the scope to
    `openid email profile`. Finally, we supply `redirectUri` to tell Auth0 what page
    we want to come back to following a successful login:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`redirectUri` must match precisely what is contained in the Auth0 settings
    section. I prefer to set it to a page that doesn''t exist on the site and control
    the redirection manually, so callback is a useful one for me because I can apply
    conditional logic to determine the page the user is redirected to if needs be.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can add in our `Login` method. This uses the `authorize` method to
    load up the authentication page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Logging out is as simple as calling `logout` and then calling `Clear` on our
    helper class to reset the expiration point and clear the other properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, we are going to need a means to check the authentication. The following
    method retrieves the authentication in the URL hash and parses it using the `parseHash` method.
    If the authentication is unsuccessful, the user is redirected back to the general
    page, which does not require a login. On the other hand, if the user is authenticated
    successfully, the user is directed to a secret page that is only available to
    authenticated users. Note that we are calling the `SetFromAuthorizationResult` method
    we wrote earlier to set the access token, expiry time, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user comes back to the site, it''s good practice to let them access
    it again without requiring them to reauthenticate themselves. The following `Renew`
    method checks their session and, if they were successful, resets their authenticated
    status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is all well and good, but where do we use it? In `app.component.ts`,
    we bring in our authorization service and check the user authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t forget to add a reference to  `NavigationComponent` to hook up `OauthAuthorizationService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Using secure routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With our authentication in place, we want to ensure that users cannot bypass
    it just by typing in the URL of the page. We wouldn''t have much security set
    up if users could easily bypass it, especially after we went to all the trouble
    of providing secure authorization. What we are going to do is put another service
    in place that the router will use to determine whether it can activate the route.
    First, we create the service, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The service itself is going to implement the `CanActivate` interface, which
    the router will use to determine whether the route can be activated. The constructor
    for this service simply takes in the router and our `OauthAuthorizationService` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The boilerplate code for the `canActivate` signature looks a lot more complicated
    than it needs to for our purposes. What we are really going to do here is check
    the authentication status and, if the user is not authenticated, we will reroute
    the user back to the general page. If the user is authenticated, we return `true`
    and the user continues on to the secured page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We have two routes that we are going to follow here, as we saw in the navigation
    links. Before we add our routes, let''s create the components that we are going
    to show:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have reached the point where we are going to hook up the routes.
    As we saw in the previous chapter, adding routes is straightforward. The secret
    sauce that we are going to add is `canActivate`. With that in our route, the user
    cannot bypass our authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Even though we have to supply a callback URL in our Auth0 configuration, we
    don't include it in our routes because we want to control the page—we do it to
    navigate to and from our authorization service.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we want to start writing messages from the client to the server
    and receive messages from it.
  prefs: []
  type: TYPE_NORMAL
- en: Adding client-side chat capabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we wrote our authentication code, we relied heavily on putting services
    in place to take care of it. In a similar way, we are going to provide a chat
    service that provides the central point of the client-side socket messaging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Unsurprisingly, this service will also incorporate `Socket` in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'When we send a message from the client to the server, we use the `emit` method
    on the socket. The text that we want to send from the user will be sent over by
    means of the `message` key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Working in rooms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Socket.IO, we use rooms to segregate messages as a means to send them only
    to certain users. When a client joins a room, any messages sent to that room will
    be available. A useful way to think of this is to imagine the rooms as being like
    rooms in a house with the doors shut. When someone wants to tell you something,
    they have to be in the same room as you to tell you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both our general and secret links will tie into rooms. The general page will
    use a blank room name that equates to the default Socket.IO room. The secret link
    will join a room called *secret* so that any messages sent to *secret* will automatically
    appear to any user on that page. To make our life easy, we will provide a helper
    method to `emit` the `joinRoom` method from the client to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: When we join a room, any messages that we send using `socket.emit` are automatically
    sent to the correct room. We don't have to do anything clever since Socket.IO
    takes care of this for us automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For both the general and the secret messages pages, we are going to be getting
    the same data. We are going to use RxJS to create an observable that wraps getting
    a single message back from the server as well as getting all currently sent messages
    back from the server.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the room string that's passed in, the `GetMessages` method joins
    either a secret room, just for logged in users, or the general room, available
    to all users. Having joined the room, we return an `Observable` instance where, on a
    particular event, we react. In the case of receiving the single message, we call
    the `Observable` instance's `next` method. This will be subscribed to by the client
    component, which will write this out. Similarly, we also subscribe on the socket
    to `allMessages` in order to receive all of the previously sent messages when
    we join the room. Again, we iterate over the messages and use `next` to write
    the message out.
  prefs: []
  type: TYPE_NORMAL
- en: 'My favorite part of this section is `fromEvent`. This is synonymous with the
    `socket.on` method of the `userLogOn` message and allows us to write out details
    about who logged in during the session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Thus far, I have been fairly loose when using the terms *messages* and *events*
    to help with the flow of reading this chapter. In this instance, they both refer
    to the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: Finishing the server sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we add the actual component implementations, we are going to add in
    the rest of our server-side socket behavior. You may remember that we added the
    ability to read all the historical records and send them back to the newly connected
    client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: What we have here is the server reacting to `joinRoom` coming over from the
    client. When we receive this event, we leave the last room if it has been set
    and then join the room that's passed over from the client; again, only if it has
    been set. This allows us to get all the records and then `emit` them back on the
    current socket connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the client sends the `message` event to the server, we are going to write
    the message to the database so that it can be retrieved later on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This method starts off by saving the message to the database. If the room is
    set, we use `io.sockets.in` to `emit` the message to all of the clients who are
    actively in the room. If there is no room set, we want to send the message to
    all the clients in the general page by using `io.emit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have seen the primary difference between `io.` and `socket.`. When
    we want to send the message to just the currently connected client, we use the
    `socket` part. When we need to send the message to a wider number of clients,
    we use the `io` part.
  prefs: []
  type: TYPE_NORMAL
- en: 'Saving the message is as simple as doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Something you might be asking yourself is why we allocate the date on the server rather
    than when we create the message at the client end. When we are running the client
    and the server on the same machine, it doesn't really matter which way we do it,
    but when we build distributed systems, we should always refer to a centralized
    time. Use of the centralized date and time means that events from all over the
    world will be coordinated as the same time zone.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the client side, we reacted to a slightly more complex log-on event. We
    create the equivalent server-side event as follows when we receive the `loggedOn`
    event, transmitting it to anyone listening in the secret room:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We now have client infrastructure in place and the server has been completed.
    All we need to do now is add in the server-side components. Functionally speaking,
    since the `GeneralChat` and `SecretChat` components are almost identical (the
    only difference being the room they are listening to), we will concentrate on
    just one of them.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces in Socket.IO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that we are writing a server that can be used by any number of client
    applications, and those client applications could be using any number of other
    Socket.IO servers as well. We could be introducing bugs into the client application
    if we use the same message names as the messages coming from the other Socket.IO
    servers. To circumvent this issue, Socket.IO uses a concept called **namespaces**
    to allow us to segregate our messages so that they don't conflict with other applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'A namespace is a convenient way to provide a unique endpoint to connect to,
    and we connect to it using code that looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar because, apart from `io.of(...)`, it's the same
    code that we used previously to connect to a socket. What may come as a surprise
    is that our code has already been using namespaces, even though we didn't specify
    it ourselves. Unless we specify a namespace ourself, our sockets will connect
    to the default namespace, which is equivalent to `io.of('/)`.
  prefs: []
  type: TYPE_NORMAL
- en: When coming up with a name for your namespace, try to think of something that
    would be unique and meaningful. One standard I have seen adopted in the past utilizes
    the company name and the project to create the namespace. So, if your company
    was called `WonderCompany` and you were working on `Project Antelope`, you might
    use `/wonderCompany_antelope` as the namespace. Don't just assign random characters
    since they are hard for people to remember, and this would increase the possibility
    that they will make mistakes typing it in, meaning that the sockets would not
    connect.
  prefs: []
  type: TYPE_NORMAL
- en: Finishing off our application with the GeneralchatComponent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start off by adding in the Bootstrap code for displaying the messages.
    We wrap the `row` message inside a Bootstrap container, or rather `container-fluid`
    in this case. In our component, we are going to be reading the messages from the
    array of messages we received over the socket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We are also going to add a text box to the `navigation` bar at the bottom of
    our screen. This is bound to the `CurrentMessage` field in the component. We send
    the message using `SendMessage()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'In the component behind this HTML, we need to hook up to the `ChatMessageService`.
    We are going to take a `Subscription` instance and use this to populate the `messages`
    array shortly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'When the users type in a message and press the Send button, we are going to
    send it to the server using the chat service''s `SendMessage` method. The groundwork
    we put in earlier really starts to pay off here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we only have two bits left to add. In our component initialization, we
    are going to retrieve the `Observable` instance from `GetMessages` and `subscribe`
    to it. When a message comes in on this subscription, we push it onto the messages
    where the magic of Angular binding really comes into play, and the interface is
    updated with the latest message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `GetMessages` method is the point where we link in the room. In
    `SecretchatComponent`, this will become `this.chatService.GetMessages('secret')`.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the things we did is take a reference to the subscription. When we destroy
    the current page, we are going to clear up the subscription so that we don''t
    leak memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: A final note on this implementation. When we started writing the code here,
    we had to make a conscious decision about how to populate the current screen with
    the message when the user pressed Send. Effectively, we had two choices. We could
    either choose to add the current message to the end of the messages array directly and
    not send it back from the server to the client, or we could send it to the server
    and then let the server send it back to us. We could choose either method, so
    why did I choose to send it to the server and then round trip it back to the client?
    The answer to this has to do with sequencing. In most chat applications I have
    used, the messages are seen by each user in exactly the same order. The easiest
    way to do this is to let the server coordinate the messages for us.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discovered how to write code that established a permanent
    connection between the client and server, enabling us to pass messages back and
    forth in response to messages. We also saw how to sign up to Auth0 and use this
    as the authentication mechanism for our application. Then, we learned how to write
    client-side authentication. Having spent the last couple of chapters investigating
    Material in Angular, we moved back to using Bootstrap and saw how simple it is
    to use in Angular.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn how to apply Bing maps in order to
    create a custom map-based application that lets us select and save points of interest
    in a cloud-based database that also uses location-based searches to retrieve business
    information.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How would we send a message to all users?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we send a message to just the users in a certain room?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we send a message to all users except the user who sent the original
    message?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why shouldn't we use a message called connect?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Engine.IO?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our application, we only used a single room. Add other rooms that do not
    require the user to be authenticated prior to use and add rooms that do require
    the user to be authenticated. We also didn't store the details of who sent the
    messages. Enhance the application to store these details and transmit them both
    ways as part of the message.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to find out how to use particular features of Socket.IO, I would
    recommend *Socket.IO Cookbook* by Tyson Cadenhead ([https://www.packtpub.com/web-development/socketio-cookbook](https://www.packtpub.com/web-development/socketio-cookbook)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
