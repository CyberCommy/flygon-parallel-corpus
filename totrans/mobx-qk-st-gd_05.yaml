- en: Derivations, Actions, and Reactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the MobX foundations have been laid with the three pillars of *observables*,
    *actions*, and *reactions*, it's time we go deeper and understand the finer aspects.
    In this chapter, we will explore the core philosophies and nuances of the MobX
    API, as well as some special APIs to simplify asynchronous programming in MobX.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: Computed properties (also known as derivations) and their various options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actions, with special focus on async actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactions and the rules governing when MobX reacts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be required to have Node.js installed on a system. Finally, to use
    the Git repository of this book, the user needs to install Git.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/MobX-Quick-Start-Guide/tree/master/src/Chapter05](https://github.com/PacktPublishing/MobX-Quick-Start-Guide/tree/master/src/Chapter05)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2mAvXk9](http://bit.ly/2mAvXk9)'
  prefs: []
  type: TYPE_NORMAL
- en: Derivations (computed properties)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Derivation* is a term that is used quite frequently in the MobX parlance.
    It is given special emphasis in client-state modeling. As we saw in the previous
    chapter, the observable state can be determined by the combination of the *core-mutable-state*
    and a *derived-read-only-state*:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Observable State = (Core-mutable-State) + (Derived-readonly-State)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is essential to keep the core state as lean as possible. This is the part
    that is expected to stay stable and grow slowly during the lifetime of the application.
    It is only the core state that is actually mutable and the *actions* always mutate
    only the *core state*. The derived state depends on the core state and is kept
    up-to-date by the MobX reactivity system. We know that *computed properties* act
    as the derived state in MobX. They can depend not only on the *core state* but
    also on other derived states, creating a dependency tree that is kept alive by
    MobX:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A key characteristic of the derived state is that it is *read only*. Its job
    is to generate a *computed value* (using the *core state*) but never mutate the
    *core state*. MobX is smart to cache these computed values and not perform any
    unnecessary computation. It also does efficient clean-ups when there are no observers
    of the *computed values*. It is highly recommended to leverage the computed properties
    as much as possible and not worry about the performance impact.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take an example where you can have a minimal core state and a derived
    state for satisfying the UI needs. Consider the humble `Todo`, `TodoList`, and
    `TodoManager`. You can probably guess what these classes do. They form the observable
    state of a *Todos* application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding code, the core state is defined by the properties
    marked with `@observable`. They are the mutable properties of these classes. For
    a *Todos* app, the core state is primarily the list of `Todo` items.
  prefs: []
  type: TYPE_NORMAL
- en: 'The derived state, which is mostly to take care of the filtering needs of the
    UI, includes the properties marked with `@computed`. Of particular interest is
    the `TodoList` class, which only has one `@observable`: an array of `todos`. Rest
    is the derived state consisting of the `pendingTodos`, `pendingTodosDescription`,
    and `completedTodos`, all marked by `@computed`.'
  prefs: []
  type: TYPE_NORMAL
- en: By keeping a lean core state, we can produce many variations of the derived
    state, as needed by the UI. Such a derived state could also help in keeping the
    semantic model clean and simple. This also gives you a chance to *enforce the
    vocabulary of the domain* rather than exposing the raw core state directly.
  prefs: []
  type: TYPE_NORMAL
- en: Is it a side effect?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](part0023.html#LTSU0-58c2559ca4304cecab9bc46f496bc070), *Introduction
    to State Management*, we talked about the role of side effects. These are the
    reactive aspects of the application that produce *external effects* based on changes
    in state (also known as data). If we now look at *computed properties* through
    the lens of side effects, you can find it very similar to the reactions in MobX.
    After all, a reaction in MobX looks at observables and produces side effects.
    This is what a computed-property does too! It depends on observables and produces
    an observable-value as side effect. So, shouldn't *computed properties* be considered
    as side effects?
  prefs: []
  type: TYPE_NORMAL
- en: Very sound argument indeed. It can appear as a side effect from the way it is
    derived, but the fact that it generates an *observable-value* brings it back into
    the world of *client-state* rather than becoming an external effect. Computed
    properties are, in fact, data for the UI and other state-management aspects. Unlike
    the side effect-causing functions of MobX, such as `autorun()`, `reaction()`,
    and `when()`, computed properties don't cause any *external* side effects and
    stay within the confines of the client-state.
  prefs: []
  type: TYPE_NORMAL
- en: Another clear distinction between MobX reactions and computed properties is
    that there is an implicit expectation that *computed properties will give back
    a value*, whereas reactions are *fire-and-forget* with no expectation of getting
    back a value. Also, with computed properties the re-evaluation (the *side effect*
    part of a computed-property) can stop as soon as there are no more observers.
    However, with reactions, it is not always clear when to stop them. For example,
    it is not always clear when logging or a network request should be stopped.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's rest the case by saying that *computed properties* are only a *partial
    side effect* and not the full-on, fire-and-forget reactions of MobX.
  prefs: []
  type: TYPE_NORMAL
- en: There's more to computed()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have looked at the use of the `@computed` decorator along with `@computed.struct`,
    where structural equality was crucial. There is of course more to the `computed`
    function, which also takes several options for a fine-grained customization. These
    options are available when used in the `decorate()` function, the `@computed`
    decorator, or when creating *boxed-computed observables*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following snippet, we see the usage in the `decorate()` function, which
    is more common:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Options for `computed()` can be passed as an *object-argument* with several
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: This is useful when combined with MobX DevTools (part of the ***mobx-react-devtools***
    NPM package). The name specified here is used in logs and also when introspecting
    the *observables* of a rendered React component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`context`: The value of *"****this**"* inside the computed function. In general,
    you don''t need to specify as it will default to the decorated instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set`: A *computed-property* is most often used as a *getter*. But, you could
    supply a setter too. This is not to replace the value of the computed property,
    but rather acts as an *inverse*. Consider the following example, where the setter
    for `fullName` is splitting it into `firstName` and `lastName`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To do the same inside the class, without `decorate()`, you just add a setter,
    as seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`keepAlive`: There are times when you need a computed value to be always available,
    even when there are no tracking observers. This option keeps the computed value
    *hot* and always updated. One caution with this option is that the computed value
    will *always be cached* and you may want to think more deeply for possible memory
    leaks and expensive computations. Objects with computed properties with `{ keepAlive:
    true }` can only be garbage-collected when all of their dependent observables
    are garbage-collected. So, use this option with care.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`requiresReaction`: This is a property meant to safeguard against *expensive
    computations running more often than expected*. The default is set to `false`,
    which means even without an observer (also known as reaction) it will be evaluated
    the first time. When set to `true`, it does not perform the computation if there
    are no observers. Instead, it throws an error informing you of the need for an
    observer. It is possible to change the global behavior by calling `configure({
    computedRequiresReaction: Boolean })`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`equals`: This sets the equality checker for the computed property. The equality
    check determines if a notification needs to be fired to inform all observers (also
    known as reactions). As we know, only when the *newly-computed value* is different
    from the *previously-cached-value* will a notification be fired. The default is
    `comparer.identity`, which does a `===` check. In other words, a value and a reference
    check. The other kind of equality check is with `comparer.structural`, which performs
    a deep comparison of the values to determine if they are equal. Conceptually,
    it is similar to an `observable.struct` decorator. This is also the comparer used
    for the `computed.struct` decorator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Error handling inside computed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Computed properties have the special ability to recover from errors thrown during
    computation. Rather than bailing out immediately, they catch and hold on to the
    error. It is only when you try to read from a *computed-property*, that it will rethrow
    the error. This gives you the chance to recover by resetting some state and getting
    back to some default state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example is straight from the MobX docs, and aptly demonstrates
    the error recovery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Actions* are the way to mutate the core state of your application. In fact,
    MobX strongly recommends that you always use actions and never do any mutations
    outside of an action. It even goes to the extent of enforcing this requirement
    across your app if you `configure` MobX with: `{ enforceActions: true }`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Let the preceding lines of code be the starting point of your *MobX-driven*
    React app. It's obvious that there are some benefits to using actions for all
    state-mutation. But so far, it hasn't been very clear. Let's drill a little deeper
    to uncover these hidden benefits.
  prefs: []
  type: TYPE_NORMAL
- en: '`configure({ enforceActions: true })` isn''t the only option available for
    guarding state-mutation. There is a stricter form with `{ enforceActions: ''strict''
    }`. The difference is subtle but worth calling out. When set to `true`, you are
    still allowed to make stray mutations outside of an action, **if** there are *no
    observers* tracking the mutating observable. This may seem like a slip on the
    part of MobX. However, it is OK to allow this because there are no side effects
    happening yet, since there are no observers. It won''t cause any harm to the consistency
    of the MobX reactivity system. It''s like the old saying, *If a tree falls in
    the forest and no one is around, does it make a sound? *Maybe too philosophical,
    but the gist is: without observers, you have no-one tracking observables and causing
    side effects, so you can safely apply the mutation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But, if you do want to go the purist route, you can use `{ enforceActions:
    ''strict'' }` and call foul even in cases where there are no observers. It''s
    really a personal choice here.'
  prefs: []
  type: TYPE_NORMAL
- en: Why an action?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When an observable is changed, MobX immediately fires a notification informing
    every observer of the change. So, if you happen to change 10 observables, 10 notifications
    will be sent out. At times, this is just excessive. You don't want a noisy system
    that notifies too eagerly. It is better to batch up the notifications and send
    them in one shot instead. It saves on CPU cycles, keeps your battery on your mobile
    device happy, and in general leads to a balanced, healthier app.
  prefs: []
  type: TYPE_NORMAL
- en: That is exactly what an `action()` achieves when you put all your mutations
    inside it. It wraps the mutating-function with `untracked()` and `transaction()`,
    two special-purpose, low-level utilities inside MobX. `untracked()` prevents tracking
    of observables (also known as creation of new *observable-observer* relationships)
    inside the mutating function; whereas `transaction()` batches the notifications,
    coerces notifications on the same observable, and then dispatches the minimal
    set of notifications at the end of ***action***.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more core utility function that is used by actions, which is `allowStateChanges(true)`.
    This ensures state changes do happen on the observables and they get their new
    values. The combination of *untracked*, *transaction*, and *allowStateChanges*
    is what makes up an action:'
  prefs: []
  type: TYPE_NORMAL
- en: '*action = untracked(transaction(allowStateChanges(true, <mutating-function>)
    ) )*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This combination has the following much-intended effects:'
  prefs: []
  type: TYPE_NORMAL
- en: Reducing excessive notifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving efficiency by batching up a minimal set of notifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimizing executions of *side effects*, for observables that change several
    times in an *action*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In fact, actions can be nested within each other, which ensures the notifications
    only go out after the *outermost action* has finished executing.
  prefs: []
  type: TYPE_NORMAL
- en: '*Actions* also help bring out the semantics of the domain and enable your app
    to become more declarative. By wrapping the details of how the observables are
    mutated, you give a *distinct name* to the operation that changes state. This
    emphasizes the *vocabulary* of your domain and codifies it as part of your *state-management*.
    This is a nod to the principles of *Domain-Driven Design* that brings the ubiquitous
    language (the terms of your domain) into the client-side code.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Actions* help in bridging the gap between the vocabulary of your domain and
    names used in the actual code. Besides the efficiency benefits, you also get the
    semantic benefits that keep the code more readable.'
  prefs: []
  type: TYPE_NORMAL
- en: We saw earlier, in the *Derivations (computed properties)* section, that you
    can also have setters. These setters are automatically wrapped by an `action()`
    by MobX. A setter for a computed-property is not really changing the computed-property
    directly. Instead, it is the inverse that mutates the dependent observables that
    make up the computed-property. Since we are mutating observables, it makes sense
    to wrap them in an action. MobX is smart enough to do this for you.
  prefs: []
  type: TYPE_NORMAL
- en: Async actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Asynchronous programming is pervasive in JavaScript, and MobX fully embraces
    that idea without adding too much ceremony. Here is a small snippet showing some
    async code interspersed with MobX state mutation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Looks normal, like any other async code. This is exactly the point. By default,
    MobX simply steps aside and lets you mutate the observables as expected. However,
    if you configure MobX to `{ enforceActions: ''strict'' }`, you get a warm **red**
    welcome on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: What's wrong here, you may ask? It has to do with our use of `async-await` operators.
    You see, the code that follows the `await` is *not executed* synchronously. It
    executes *after* the `await` promise fulfills. Now, the `action()` decorator can
    only guard code that is executed synchronously within its block. Code that is
    run asynchronously is not considered, and thus runs outside the `action()`. Hence,
    the code following `await` is not part of `action` anymore, causing MobX to complain.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping with runInAction()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The way to circumvent this problem is to use a utility function provided by
    MobX, called `runInAction()`. This is a handy function that takes in a *mutating-function* and
    executes it inside an `action()`. In the following code, you can see the use of
    `runInAction()` to wrap the mutations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have applied `runInAction()` to the code following `await`, both
    in the *try-block* and in the *catch-block*.
  prefs: []
  type: TYPE_NORMAL
- en: '`runInAction(fn)` is just a convenience utility that is equivalent to `action(fn)()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although *async-await* provides a beautiful, concise syntax to write `async`
    code, beware of the parts of code that are not synchronous. The co-location of
    the code within the `action()` block can be misleading. At runtime, not all statements
    execute synchronously. The code that follows `await` is always run `async`, after
    the *awaited-promise* fulfills. Wrapping the parts that are `async` with `runInAction()`
    gives us back the benefits of the `action()` decorator. Now, MobX has no more
    complaints when you configure `({ enforceActions: ''strict'' })`.'
  prefs: []
  type: TYPE_NORMAL
- en: flow()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous, simple example, we only had to wrap two segments of the code
    in `runInAction()`. That was quite straightforward and did not involve too much
    effort. However, there will be cases where you will have multiple `await` statements
    within a function. Consider the `login()` method shown next, which performs an
    action involving multiple *awaits*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Wrapping the state-mutations in `runInAction()` after each `await` can quickly
    turn cumbersome. You can even forget wrapping some parts if there are more conditionals
    involved or if the mutations are spread across multiple functions. What if there
    was a way to automatically wrap the asynchronous parts of the code in `action()`?
  prefs: []
  type: TYPE_NORMAL
- en: 'MobX provides a solution for this use-case too. There is a utility function
    called `flow()` that takes a *generator-function* as input. Instead of `await`,
    you use the `yield` operator instead. Conceptually, it is very similar to the *async-await*
    kind of code, but uses a *generator function* with `yield` statements to achieve
    the same effect. Let''s rewrite the code from the previous example, using the
    `flow()` utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Notice the use of the generator `function*()` instead of the regular function,
    which is passed as argument to `flow()`. Structurally, it is no different than
    the *async-await* style of code, but has the added benefit of automatically wrapping
    the parts of code following a `yield` with an `action()`. With `flow()`, you are
    back to being more declarative with your async code.
  prefs: []
  type: TYPE_NORMAL
- en: There is yet another benefit that `flow()` gives you. It is the ability to *cancel
    execution of the async code*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The return value of `flow()` is a function that you can invoke to execute the
    async code. This is the `login` method of the `AuthStore`, in the preceding example.
    When you call `new AuthStore().login()`, you get back a promise that has been
    enhanced by MobX with the `cancel()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is useful for canceling a long-running operation by giving user-level control.
  prefs: []
  type: TYPE_NORMAL
- en: Reactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Observables and actions keep things within the confines of the MobX reactivity
    system. Actions mutate the observables and, through the power of notifications,
    the rest of the MobX system aligns to the mutation to keep the state consistent.
    To start making a change outside of this MobX system, you need *reactions*. It
    is the bridge to the outside world that informs the *state-changes* happening
    within the MobX world.
  prefs: []
  type: TYPE_NORMAL
- en: '*Consider reactions to be the reactive-bridge-crossing between MobX and  the
    outside world. These are also the side effect producers of your application.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We know that reactions come in three flavors: `autorun`, `reaction`, and `when`.
    These three flavors have distinct characteristics that tackle the various scenarios
    within your app.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When determining which one to pick, you can apply this simple decision-making
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Each of the reactions give you back a *disposer-function*, which can be used
    to prematurely dispose the reaction thus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Going back to the preceding diagram on the decision-tree, we can now define
    what it means to be *long-running*: the reaction does not dispose itself automatically
    after executing the first time. It continues to live until explicitly disposed
    using the *disposer-function*. `autorun()` and `reaction()` fall under the category
    of long-running reactions, whereas `when()` is one-time only. Note that `when()`
    also gives back a *disposer-function*, which can pre-maturely cancel the `when()`
    effect. However, the *one-time* behavior means that after the effect executes,
    `when()` will automatically dispose of itself, without requiring any clean up.'
  prefs: []
  type: TYPE_NORMAL
- en: The second defining characteristic that is covered in the decision-tree is about
    *selecting the observables* to track. This is a guarding condition for the *effect-function*
    to execute. `reaction()` and `when()` have the ability to decide which observables
    to use for tracking, whereas, `autorun()` implicitly selects all observables in
    its *effect-function*. In the case of `reaction()` it's the *tracking-function*, and
    for `when()` it's the *predicate-function*. These functions are expected to produce
    a value, and when it changes, the *effect-function* is executed.
  prefs: []
  type: TYPE_NORMAL
- en: The *selector-function* of `reaction()` and `when()` is where the observable
    tracking happens. The *effect-function* is only for causing side effects with
    no tracking. `autorun()` implicitly combines the *selector-function* and the *effect-function*
    into just one function.
  prefs: []
  type: TYPE_NORMAL
- en: Using the decision tree, you can classify the different *side effects* in your
    application. In [Chapter 6](part0101.html#30A8Q0-58c2559ca4304cecab9bc46f496bc070),
    *Handling Real-World Use Cases*, we will look at various examples that will make
    this selection process more natural.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring autorun() and reaction()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both `autorun()` and `reaction()` offer an extra argument to customize the behavior
    a little more. Let's look at the most common properties that can be passed as
    options.
  prefs: []
  type: TYPE_NORMAL
- en: Options for autorun()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second argument to `autorun()` is an object that carries the *options*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'It has the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: This is useful for debugging purposes, especially in the context of
    MobX DevTools, where the `name` is printed in the logs. The name is also used
    with the `spy()` utility function provided by MobX. Both of these will be covered
    in a later chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delay`: This acts as a debouncer for frequently changing observables. The
    *effect-function* will wait for the `delay` period (specified in milliseconds)
    before re-executing. In the example shown next, we want to be careful not to fire
    a network request for every change to `profile.couponsUsed`. An easy guard is
    to use the `delay` option:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`onError`: Errors thrown during the execution of the *effect-function* can
    be safely handled by providing the `onError` handler. The error is given as input
    to the `onError` handler, which can then be used to recover, and prevent the exceptional
    state for subsequent runs of the *effect-function*. Note that by providing this
    handler, MobX continues tracking even after an error occurs. This keeps the system
    running and allows other scheduled *side effects*, which are possibly unrelated,
    to run as expected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, we have an `onError` handler that deals with cases
    where the number of coupons is greater than two. Providing this handler keeps
    the `autorun()` running without interfering with the rest of the MobX reactivity
    system. We are also removing the excess coupons to prevent this from happening
    again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Options for reaction()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to `autorun()`, we can pass an extra argument to `reaction()` that
    contains the *options*:'
  prefs: []
  type: TYPE_NORMAL
- en: '`*reaction(() => {/* tracking data */}, (data) => { /* side effects */}, options)*`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the options, as shown below, are exactly like *autorun*, which keeps
    it consistent:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delay`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onError`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, there are additional options, specifically for `reaction()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fireImmediately`: This is a boolean value that indicates whether the *effect-function*
    should be triggered immediately after the first invocation of the *tracking-function*.
    Notice that this behavior gets us closer to `autorun()`, which also runs immediately.
    By default, it is set to `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`equals`: Notice that the *tracking-function* in a `reaction()` gives back `data`
    that is used to compare with the previously produced value. For primitive values,
    the default *equality comparison* (`comparer.default`), which is based on value,
    works well. However, you are free to supply a structural comparer (`comparer.structural`)
    to ensure a deeper comparison is performed. The equality check is important, because
    only when the values (produced by *tracking-function*) differ, will the *effect-function*
    be invoked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When does MobX react?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The MobX reactivity system starts with the tracking or observation of the *observables*.
    This is an important aspect of building the reactivity graph, so tracking the
    correct observables is key. By following a simple set of rules, you can guarantee
    the outcome of the tracking process and ensure your reactions fire correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the term *tracking-function* to mean any one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The function passed into `autorun()`. The observables used in that function
    are tracked by MobX.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *selector-function* (first argument) of a `reaction()` or `when()`. The
    observables used in it are tracked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `render()` method of an *observer*-React-component. The observables used
    during the execution of the `render()` method are tracked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With each of the following rules, we will look at an example of the rule in
    action:'
  prefs: []
  type: TYPE_NORMAL
- en: Always dereference observables during the execution of the tracking-function. Dereferencing
    is the key to establishing the MobX tracker.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, the `autorun()` is not invoked again since there
    is no observable property being dereferenced. For MobX to react to changes, it
    needs an observable property being read inside the *tracking-function*. One possible
    fix is to read the `item.price` inside the `autorun()`, which will re-trigger
    anytime `item.price` is changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Tracking only happens in the synchronously executing code of the tracking-function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The observables should be accessed directly in the tracking-function and not
    in an async function inside.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following code, MobX will never react to the change in `item.quantity`.
    Although we are dereferencing the observable inside `autorun()`, it is not being
    done synchronously. Hence, MobX will never re-execute `autorun()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To fix, we can pull the code out from the `setTimeout()` and place it directly
    inside `autorun()`. If the use of `setTimeout()` is to add some delayed execution,
    we can do that with the `delay` option of `autorun()`. The following code shows
    the fix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Only observables that already exist will be tracked:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, we are dereferencing an observable (a computed property),
    which does not exist on the `item` at the time `autorun()` executes. Hence, MobX
    never tracks it. Later in the code, we are changing the `item.quantity`, resulting
    in a change in `item.description`, but `autorun()` still doesn''t execute:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'An easy fix is to ensure the observable actually exists before `autorun()`
    executes. By changing the order of statements, we can get the desired behavior,
    as seen in the following snippet. In practice, you should declare upfront all
    the properties you will need. This helps MobX to track properties correctly when
    required, helps type-checkers (for example, TypeScript) ensure the correct properties
    are being used, and also expresses the intent clearly to the readers of your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the snippet* before the fix*, if we had also read the `item.quantity` in `autorun()`,
    then this *tracking-function* would re-execute on changes to `item.quantity`.
    That happens as the observable property exists at the time the `autorun()` executes
    for the first time. The second time `autorun()` executes (due to change in `item.quantity`),
    `item.description` would also be available and MobX can start tracking that as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: 'One exception to the previous rule is for Observable Maps where a dynamic key
    is also tracked:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, `autorun()` will re-execute since `twitterUrls`
    is an `observable.map`, which tracks the addition of new keys. Thus, the key, `Sara`,
    is still tracked even though it is non-existent at the time `autorun()` executes.
  prefs: []
  type: TYPE_NORMAL
- en: In MobX 5, it can track *not-yet-existing* properties for all objects created
    using the `observable()` API.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The mental model for MobX apps is geared towards thinking about the *observable
    state*. This itself is divided into the *minimal core state* and a *derived state*.
    Derivations are how we handle the various projections of the core state onto the
    UI and places where we need to perform domain-specific operations. Before adding
    more core state, think about whether it can be rolled in as derived state. Only
    when that is not possible should you introduce new core state.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how an *async action* is quite similar to a regular *action* without
    much ceremony. The only caveat is when you have configured MobX to `enforceActions`.
    In that case, you have to wrap *state mutations* in the async code inside `runInAction()`.
    When there are several async parts within the action, **`flow()`** is a better
    option. It takes a generator function (denoted by `function*(){ }`) that is interspersed
    with `yield` to the various *promise-based* calls.
  prefs: []
  type: TYPE_NORMAL
- en: '`reaction()` and `autorun()` offer extra options to control their behavior.
    They share most of the options, such as *name*, *delay*, and *onError*. `reaction()`
    has two more options: to control how comparisons are made on the data produced
    by the *tracking-function* (`equals`), and if the *effect-function* should be
    fired immediately after the first run of the *tracking-function* (`fireImmediately`).'
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 6](part0101.html#30A8Q0-58c2559ca4304cecab9bc46f496bc070), *Handling
    Real-World Use Cases*, we can start exploring approaches to tackling various common
    scenarios with MobX. If the chapters until now seemed like *science*, the next
    one is *applied-science*!
  prefs: []
  type: TYPE_NORMAL
