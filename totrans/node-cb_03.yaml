- en: Chapter 3. Working with Data Serialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Converting an object to JSON and back again
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting an object to XML and back again
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Browser-server transmission via AJAX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Working with real data: fetching trending tweets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we want to give third parties safe access to raw data, we can use serialization
    to send it in a format that the requester will understand. In this chapter, we'll
    be looking at data serialization in two well-known standards, JSON and XML.
  prefs: []
  type: TYPE_NORMAL
- en: Converting an object to JSON and back again
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JSON (JavaScript Object Notation)** is very closely related to JavaScript
    objects because it''s a subset of JavaScript. This task will demonstrate how to
    use the building blocks of JSON conversion: `JSON.parse` and `JSON.stringify.`'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll need to create two new files called `profiles.js` and `json_and_back.js`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create the object that we'll later be converting to JSON.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This object contains profile information on some of the leading members of the
    Node Community (though it's entirely non-exhaustive and doesn't even contain all
    of the core development team). One thing to note here is the use of `module.exports`.
    We'll be seeing more of this In [Chapter 9](ch09.html "Chapter 9. Writing Your
    Own Node Modules"), *Writing Your Own Module*. We're using `module.exports` to
    modularize our `profiles` object here in a bid to keep our code uncluttered. We
    can load any expression into `module.exports`, save it as a separate file (which
    in our case, we'll call `profiles.js)`, and use `require` in our main file to
    dynamically load it at initialization.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Nice and tidy. To convert our `profiles` object into a JSON representation,
    we use `JSON.stringify`, which will return a string composed of JSON data. We're
    going to fundamentally alter our object (which is now a string) using `replace`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here we have called `replace`, using a regular expression with the global `g`
    option to change every occurrence of `name` in our JSON string to `fullname`.
  prefs: []
  type: TYPE_NORMAL
- en: 'But wait! There appears to be some kind of mistake. Felix''s last name is missing
    an umlaut! Let''s correct it by converting our JSON data back into an object,
    and correct his name by altering the value of the re-designated `fullname` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run our application, `console.log` will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first key is now `fullname`, and `Geisendörfer` is spelled correctly.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we have an everyday JavaScript object, which we serialize into a JSON
    representation. We also call the `String.replace` method on our JSON string, changing
    every occurrence of `name` into `fullname`.
  prefs: []
  type: TYPE_NORMAL
- en: Using replace in this way and context isn't an advisable practice since any
    occurrences of `name` are replaced. There could very easily have been other places
    in the string where `name` may have existed, which would be replaced unintentionally.
    We used `replace` here to affirm that profiles have become a JSON string, as we
    couldn't use `replace` on an object.
  prefs: []
  type: TYPE_NORMAL
- en: Then we convert our modified JSON string back into an object, using `JSON.parse`.
    To test that our keys were indeed transformed from `name` to `fullname`, and to
    affirm that we are again working with an object, we correct the `felix` profile
    via `profiles.felix.fullname`, and then log `profiles.felix` to the console.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JSON is a highly versatile and flexible tool for cross-platform communication.
    Let's look at a more advanced application of the standard.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing JSONP responses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**JSONP (JSON with Padding)** is a cross-domain policy workaround that allows
    developers to interface with resources on other domains. It involves defining
    a callback function on the client side that handles JSON via its first parameter,
    then passing the name of this callback as a query argument in the `src` attribute
    of a `script` element, which points to a web service on another domain. The web
    service then returns the JSON data, wrapped in a function named according to the
    query argument set client side. It''s possibly easier to illustrate this in code.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We define a function called `cb` which takes an object as its parameter, then
    we output the `name` and `description` properties. Prior to this, we set a variable
    called `who` which will be passed to the server to grab specific data for us.
    We then dynamically inject a new script element, setting `src` to a figurative
    third-party domain (which for easy demonstration is localhost) and adding `callback`
    and `who` query arguments. The value of `callback` matches the name of our function
    `cb` function. Our server uses this parameter to wrap JSON in a function invocation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We create a server, extract the `callback` and `who` query parameters, and write
    a response containing a function call passing our JSON data in as its parameter.
    This script is loaded by our client, where the `cb` function is called and JSON
    is received into the function as an object (because it looks like one).
  prefs: []
  type: TYPE_NORMAL
- en: Security and JSONP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since JSONP uses script injection, any script could be inserted into our page.
    Therefore, it's highly recommended that this method only be used with trusted
    sources. An untrusted source could run evil code on the page.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Browser-server transmission via AJAX* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Working with real data: fetching trending tweets* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting an object to XML and back again
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since JSON is a string-based representation of a JavaScript object, converting
    between the two is straightforward. However, XML is less convenient to work with.
    Nevertheless, there may be times we have to work with it, for instance, if an
    API works only in XML or if we were contracted with a project that specifies XML
    support.
  prefs: []
  type: TYPE_NORMAL
- en: There are various non-core XML parsers available. One such parser is the non-core
    module `xml2js`. The premise of `xml2js` is that working with objects in JavaScript
    is more suitable than working with XML. `xml2js` provides a basis for us to interact
    with XML by converting it to a JavaScript object.
  prefs: []
  type: TYPE_NORMAL
- en: In this task, we're going to write a function that uses our `profiles` object
    featured in the previous recipe to create a valid XML string, which we'll then
    push through `xml2js`, thus converting it back into an object.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we start, let's create our file `xml_and_back.js`, making sure we have
    our separately modularized `profiles.js` in the same directory. We should also
    install `xml2js`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To begin with, we'll need to require our `profiles` object along with `xml2js:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice that rather than just requiring the `xml2js` module, we've initialized
    a new instance of its `Parser` method and loaded that as our `xml2js` variable.
    This is to do with the way the `xml2js` module works. We have to create a new
    `Parser` instance in order to parse a piece of XML into an object. Since our code
    is relatively simple we may as well do the initialization work while we require
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as XML has a tree-like structure, objects can have objects nested within
    them. We need a function that can loop through our object and all sub-objects,
    converting all properties into parent XML nodes, and all non-object values into
    text XML nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`buildXml` takes two parameters, the object and a string to name the first
    root XML node, and returns a string of XML data representing our object.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's replace all occurrences of `name` with `fullname` as in our *Converting
    an object to JSON and back again* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now we'll turn `profiles` back into an object, correct Felix Geisendörfer's
    name using the renamed `fullname` property, then log Felix to console to show
    it has worked.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`xml2js.parseString` takes the XML (which at this point is held in the `profiles`
    variable) and assembles it into an object which is passed through as the `obj`
    parameter in its callback.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A JavaScript object is a key value store, whereas XML is a resource-centric
    markup language. In XML, keys and values could be represented in two ways: either
    as a parent node and a child node or as attributes on an XML node. We converted
    our keys and values to parent and child nodes, mainly because a single XML node
    is filled with lots of attributes, while valid XML, seems to violate the spirit
    of XML.'
  prefs: []
  type: TYPE_NORMAL
- en: We achieved our conversion with `buildXml`, which is a function wrapping another
    self-calling recursive function named `traverse`. We do this to take advantage
    of the closure principle in JavaScript which allows us to share variables between
    inner and outer function. This enables us to use the outer `xml` variable to assemble
    our serialized XML.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our outer function, we begin with the`<?xml?>` declaration setting the required
    `version` attribute and the optional `encoding` attribute to `UTF-8`. We also
    wrap any output that `traverse` renders in an ending and closing tag named after
    our `rootName` parameter. So in our case, `buildXml` puts the following into our
    `xml` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If `rootName` is missing, we default to`<xml>` as the root node. Our `traverse`
    inner function takes a single parameter, which is the object to be converted to
    XML. We pass in `rootObj` to the calling parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`traverse` uses `forEach` to loop through the keys of this object, accessing
    each key via the first parameter of the `forEach` callback. We use the name of
    each `key` to generate the opening and closing of XML tags, and append the `open`
    tag to our shared `xml` variable. Then we check our `isTxt` variable, which tests
    for a nested object and returns `true` if it''s not an object (assuming it must
    therefore be text). If `isTxt` is `true`, we output the value of our current property
    and return from the `forEach` callback, continuing onto the next property. This
    is how we get our text nodes — the values. Otherwise, we append a line feed to
    `xml` and call `traverse` on the sub-object, going through the exact same process,
    only this time it''s embedded in the parent `traverse` function. Once our nested
    call to `traverse` has returned, we append the `close` tag to `xml` and our `traverse`
    function is complete. Finally, our outer function appends the closing root node
    tag and returns all the generated XML.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can adapt our code further to better integrate with the `xml2js` library
    by mirroring its interpretations of certain XML features into JavaScript object
    equivalents. We can also extend it to translate more complex JavaScript objects
    into valid XML.
  prefs: []
  type: TYPE_NORMAL
- en: Objects containing arrays and functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As well as objects and strings, object properties can contain functions and
    arrays. As it stands, our recipe will interpret these as text, outputting a comma-separated
    list of values where arrays are concerned, and returning the contents of functions
    within text nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This isn''t ideal, so we''ll alter our `traverse` function to handle these
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We'll save our altered code as `xml_with_arrays_and_functions.js`. For semantics'
    sake, we renamed `isTxt` to `nonObj` and added two more tester variables, `isArray`
    and `isFunc`. If the value of the object we are traversing is an array, we create
    a temporary `childNode` object which we pass back into `traverse`. We do the same
    for each value of the array, each time creating a new `childNode` object where
    the key is the same but the value is the next array element. This effectively
    creates multiple child nodes of the same name.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the array support, let''s copy our `profiles.js` file to `profiles_with_arrays_and_functions.js`,
    requiring it instead of `profiles.js`. Ryan Dahl also pushes to another Github
    account: joyent. So let''s update his profile with an array of Github accounts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And take a look at the output, we''ll see that Ryan has two Github XML nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Our other variable, `isFunc`, is checked within the `nonObj` conditional statement.
    We use it to determine whether we should just add the text of our object property
    to our `xml` variable, or else call the object property to receive its return
    value. Bert''s IRC, Twitter, and Github accounts are all the same, so let''s add
    methods that pull the IRC and Twitter values from his Github value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If we build our XML from our object and then convert it back to an object using
    `xml2js`, these properties should no longer be functions, but instead be the returned
    values of the functions/methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And the output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Generating XML attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In XML, we can either express data relationships with parent, child, and text
    nodes, or by using attributes. If we want to include the ability of our `buildXml`
    function to cater to XML attributes, we need a convention for defining attributes
    within our objects. When converting from XML to objects, `xml2js` interprets attributes
    by adding a property containing an object that has a special `@` property, which
    in turn holds another sub-object containing the attributes. By implementing the
    same convention in `buildXml`, we can make our code work nicely alongside `xml2js`.
    Let''s take the `profiles` object in `profiles_with_arrays_and_functions.js` and
    further update the `location` properties as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We'll save this as `profiles_with_attributes.js`, and alter the `require` location
    for the `profiles` variable in our `xml_and_back_with_arrays_and_functions.js`
    code, saving as `xml_and_back_with_attributes.js:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write another function that should be placed inside the `buildXml` function
    to handle our attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Our new `attributes` function should be placed within our `buildXml` function
    and will be called inside `traverse`, just after we add our key''s `open` tag
    variable to the `xml` variable, and just before we check for `nonObj` nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We pass in the object and key currently being handled by our `traverse` function,
    which checks if this particular property of `obj` contains a property named `@`.
    We're also implicitly checking if the value of our current object key is in itself
    an object as only objects have properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'The current attribute `@` property corresponds to the current tag. So if an
    `@` property is found, we remove the last character of `xml` (which would be a
    right angle bracket`>)` and loop through the keys of our sub-object (`obj[key][@]`)
    adding each key and its value to the last `open` tag to be appended to `xml`,
    re-appending the right angle bracket when done. If we left the `@` object inside
    our `profiles` object, it would later be passed back into the `traverse` function
    causing the following behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We don''t want that, so we finish off by removing the `attributes` sub-object
    from our object. Underneath our `buildXml` function we have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This changes `name` keys to `fullname` and outputs our XML to console, rendering
    `location` tags with attributes like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Text values alongside attribute declarations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our attribute solution uncovers another issue. There isn't a way for attributed
    nodes to contain text nodes, since we convert string types to text nodes but use
    an object to declare attributes. `xml2js` answers the antipathy of this problem
    with the `charkey` property. With the following code we become fully compatible
    with `xml2js:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the dilemma is resolved and we can explicitly add attributed nodes which
    contain text nodes, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Which renders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Converting an object to JSON and back again* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Browser-server transmission via AJAX* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Working with real data: fetching trending tweets* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Browser-server transmission via AJAX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can enhance the user experience by loading new content directly into the
    page via AJAX, rather than loading a new page for each content request.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we're going to transfer our serialized data to the browser as
    the user requests it and then interact with our client-side data. We'll implement
    a profile viewer in the browser, which retrieves a selected profile in either
    JSON or XML, outputting the key-values or parent-child nodes for that profile.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''re going to continue to work with our `profiles.js` object module (from
    the first two recipes of this chapter). For XML delivery, we''ll also grab our
    `buildXml` function from the *Converting an object to XML and back again* recipe,
    converting it to a simple module (just like we did with our `profiles` object
    in the previous recipe):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll save this as `buildXml.js` and place it in a folder with a copy of our
    `profiles.js` file, along with two newly created files: `server.js` and `index.html`.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start with our `index.html` file. We'll quickly implement a rough layout
    for our profile viewer consisting of a `form` with two `select` elements, a `div`
    for outputting formatted object data, and a `textarea` element for presenting
    the raw serialized data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we've included jQuery to obtain cross-browser benefits, particularly
    in the area of AJAX requests. We'll be utilizing jQuery in our client-side script
    shortly, but first let's make our server.
  prefs: []
  type: TYPE_NORMAL
- en: For our modules, we'll need `http, path`, and `fs` along with our custom `profiles`
    and `buildXml` modules. For our code to work, we'll need to have `index.html`
    hosted within our server in order to prevent cross-origin policy errors.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We've also defined `routes` and `mimes` variables so we can answer requests
    for specific data from the client along with the correct `Content-Type` header.
    We'll create two routes, one will deliver a list of profile names, the other will
    indicate a request for a particular profile.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `output` function, which we just referred to in `routes`, should be placed
    above the `routes` object and looks like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To finish our server, we simply call `http.createServer` and interact with
    our `routes` object inside the callback, outputting `index.html` where no routes
    are found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to write our client-side code to interface with our server
    over AJAX, which is to be placed in script tags just underneath our `#raw` textarea,
    but above the closing`</body>` tag (to ensure the HTML elements have loaded before
    script execution) of our `index.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's begin with the server. Inside our `http.createServer` callback, we set
    the appropriate header and check to see if the `routes` object has the specified
    directory name. If the directory name exists in `routes`, we call it as a function
    passing in `basename` and `extname` (we use `extname` to determine the desired
    format). In cases where there is no directory name match, we check for an existing
    property matching `basename`. If there is one, we call it and pass in the extension
    (if any). If both tests turn out to be false, we simply output the contents of
    our `index.html` file.
  prefs: []
  type: TYPE_NORMAL
- en: Our two routes are `profiles` and `/profile`, the latter has a preceding slash
    which corresponds to the way `path.dirname` returns the directory name of a path.
    Our `/profile` route is designed to allow for a sub-path containing the requested
    profile and format. For instance, `http://localhost:8080/profile/ryan.json` will
    return Ryan's profile in JSON format (if no extension is given, we default to
    JSON format).
  prefs: []
  type: TYPE_NORMAL
- en: Both the `profiles` and `/profile` methods utilize our custom `output` function
    which, using the `format` parameter (originally `extname` in the `http.createServer`
    callback), generates either JSON (using `JSON.stringify)` or XML (with our very
    own `buildXml` function) from the `content` passed to it. `output` also takes
    a conditional third parameter, which is passed along to `buildXml` to define the
    `rootNode` of the generated XML.
  prefs: []
  type: TYPE_NORMAL
- en: On the client side, the first thing we do is call the jQuery `$.get` method
    for `http://localhost:8080/profiles`. This causes the server to call the `profiles`
    method on the `route` object. This in turn calls our `output` function with an
    array of top-level properties from our `profiles.js` object. Since we didn't specify
    an extension in `$.get`, the `output` function will default to JSON format and
    deliver the result of `JSON.stringify` into `response.end.`
  prefs: []
  type: TYPE_NORMAL
- en: Back on the client side, our third argument in the first `$.get` call is`'json'`,
    this ensures `$.get` interprets the incoming data as JSON, converting it to an
    object. The object is passed in as the first parameter of the function callback
    of `$.get` (second parameter of `$.get)`, which we named `profile_names`. We use
    jQuery's `$.each` to loop through the `profile_names`, populating the first `select`
    element (`#profiles`) by applying jQuery's `append` method to the element, and
    adding each profile name inside the`<option>` elements as we loop through `$.each`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we apply a listener to our two `select` elements (`change`) whose callback
    assembles a URL dependent upon the user's selection, passing this URL into another
    AJAX request using `$.get`.
  prefs: []
  type: TYPE_NORMAL
- en: This time on the server side, the `/profile route` method is invoked, passing
    in the corresponding profile from our `profiles` object to `output`. This property
    will contain an object holding the profile information of the requested individual.
  prefs: []
  type: TYPE_NORMAL
- en: In our second `$.get` call, we set the third argument to`'text'`. This will
    force jQuery not to automatically interpret incoming data as JSON or XML. This
    gives us more control and makes it easier to output the raw data into `textarea`.
    Inside the `$.get` callback, we use the `jqXHR` parameter to determine the `Content-Type`
    to see if we have JSON or XML. We loop through the returned data according to
    its type (either Object or XMLObject) and append it to our `#output div`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can also convert our objects to JSON and XML in the browser and send them
    over to our server, where we can interact with them as objects again.
  prefs: []
  type: TYPE_NORMAL
- en: Sending serialized data from client to server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's extend our example to add new profiles to our `profiles` object on the
    server using our browser interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with `index.html` (which we''ll copy to `add_profile_index.html —
    we''ll` also copy `server.js` to `add_profile_server.js)`, let''s append a form
    called `#add`, and style it. Here''s the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'And some additional styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re going to be using our `buildXml` function on the client side (we created
    `buildXml` in the *Converting an object to XML and back again* recipe). This function
    is already available on our server, so we''ll make it available to the client
    by converting it to a string on server starts and supplying a route for the client
    to access it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We also updated our `mimes` object ready to deliver `application/javascript
    Content-Type` and altered the index variable to use our new `add_profile_index.html`
    file. Back in our client-side code, we fetch our `buildXml` function by including
    another`<script>` tag in the head section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll wrap our initial `$.get` call to the server (which fetches all the profile
    names for the `select` element) in a function called `load`. This allows us to
    dynamically reload the profile names once a profile has been added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we define a handler for the `#add` form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Our handler builds an object from the form input serializing it to the specified
    format. It uses `jQuery.ajax` to send serialized data to our server, and afterwards
    reloads the profiles. On our server, we''ll write a function to handle the POST
    request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'For our new `addProfile` function to work, we need to include the `xml2js`
    module which is used to convert the serialized XML back into an object. So alongside
    all our initial variables we add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As in the first recipe of[Chapter 2](ch02.html "Chapter 2. Exploring the HTTP
    Object"), *Exploring the HTTP Object*, in handling POST data, `addProfile` compiles
    all the incoming data together. In the `end` event, we convert the serialized
    data to an object using the method appropriate to its type. We take this object
    and add it to our `profiles` object using the `profileName` property as the key
    for our sub-object. Once we've added the object, we `delete` the redundant `profileName`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: To return data to the client, the `addProfile` function invokes the callback
    (cb) parameter, passing in our custom `output` function which will return serialized
    data according to the specified format (which is determined by using `replace`
    on the `Content-Type` header).
  prefs: []
  type: TYPE_NORMAL
- en: 'We include our `addProfile` function in our server like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Within our `addProfile` callback function, we simply end the response with the
    data returned from the `output` function, accessing this data via the `output`
    parameter as defined in the `addProfile` callback. The new profiles are only saved
    in operational memory, so they will be lost on server restarts. If we were to
    store this data on disc, we would ideally want to save it in a database, which
    we'll talk about in the next chapter, *Interfacing with Databases*.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Setting up a router* discussed In [Chapter 1](ch01.html "Chapter 1. Making
    a Web Server"),Making a Web Server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Processing POST data* discussed In [Chapter 2](ch02.html "Chapter 2. Exploring
    the HTTP Object"),Exploring the HTTP Object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Converting an object to JSON and back again* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Converting an object to XML and back again* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Working with real data: fetching trending tweets'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many online entities format their response data as JSON and XML in their Application
    Programmer Interfaces (APIs) to expose pertinent information to third-party developers
    who can subsequently integrate this data into their applications.
  prefs: []
  type: TYPE_NORMAL
- en: One such online entity is Twitter. In this recipe, we are going to make a command-line
    application that makes two requests to Twitter's REST service. The first will
    retrieve the most popular current topics on Twitter and the second will return
    the most recent tweets regarding the hottest topic on Twitter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create our file and name it `twitter_trends.js`. We may also wish to
    install the third-party `colors` module to make our output more beautiful:'
  prefs: []
  type: TYPE_NORMAL
- en: npm install colors
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll need the `http` module in order to make requests, and the `colors` module
    to get some color in our console output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We're going to be making a GET request inside another GET request. Between these
    requests we'll be processing JSON data to either pass into the subsequent request
    or to output to console. In the spirit of DRY (Don't Repeat Yourself), and to
    demonstrate how to avoid spaghetti code, we'll abstract our GET requests and JSON
    handling into a function called `makeCall`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Notice the mysterious appearance of `trendingTopics` and its `jsonHandler method.
    trendingTopics` is an object that is going to provide all the settings and methods
    for our Twitter interactions. `jsonHandler` is a method on the `trendingTopics`
    object for receiving the response stream and converting the JSON to an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to set up options for our calls to the trends and tweets APIs, along
    with some Twitter interaction-related functionality. So above our `makeCall` function,
    we''ll create the `trendingTopics` object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: While creating the `trendingTopics` variable, we also turn the object into a
    module by simultanouesly loading it into `module.exports`. See how we use this
    in the *There's more..*. section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within our `trendingTopics` object, we have the `trends` and `tweets` objects
    and two methods: `jsonHandler` and `tweetPath.`'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we'll invoke our `makeCall` function to request the top global trends
    from the Twitter trends API, converting the returned JSON to an object, AND using
    this object to ascertain the path to request tweets on the highest trending topic
    for using another embedded `makeCall` invocation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's pick apart the `trendingTopics` object. `trends` and `tweets` provide
    settings relevant to Twitter's API. For `trends` this is simply a URL options
    object to be passed into `http.get` later on. In the `tweets` object, we have
    the URL object along with some other properties pertaining to options we can set
    within our REST call to the Twitter search API.
  prefs: []
  type: TYPE_NORMAL
- en: Twitter API and the User-Agent header
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice we've gone to the trouble of setting a `User-Agent` header. This is due
    to the Twitter API policy, which penalizes a lack of `User-Agent` string by imposing
    a lower rate limit.
  prefs: []
  type: TYPE_NORMAL
- en: Our `jsonHandler` method on the `trendingTopics` object takes a `reponse` and
    `cb` (callback) parameter. `trendingTopics.jsonHandler` uses the `response` object
    from the `http.get` call to capture the incoming data stream into a variable (`json`).
    When the stream has ended, which is detected using the `end` event listener on
    `response, cb` is invoking converted JSON as the parameter. The callback from
    `trendingTopics.jsonHandler` finds its way up into the `makeCall` callback.
  prefs: []
  type: TYPE_NORMAL
- en: '`makeCall` abstractly combines the GET request and JSON handling, and provides
    a callback with a single parameter which is the data returned by Twitter as parsed
    JSON (in this case, it is an array of objects).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the outer `makeCall` invocation we call the parameter `trendsArr`, because
    Twitter returns its JSON data in an array wrapper. We use `trendsArr` to locate
    the query fragment representation of the Twitter''s top trend and pass it to the
    final method of our `trendingTopics` object: `trendingTopics.tweetPath`. This
    method takes a query fragment (`q`) as its single parameter. It then uses this
    parameter along with the options in `trendingTopics.tweets` to build the final
    Search API path. It injects this path into the `urlOpts` object of `trendingTopics.tweets`,
    which is then passed through into the inner `makeCall` invocation.'
  prefs: []
  type: TYPE_NORMAL
- en: In the inner `makeCall` invocation we name the parameter `tweetsArr`. This is
    an array of objects containing tweet data as returned from the Twitter Search
    API in response to a query searching for the top trend discovered via the former
    (outer) call to the Trend API. We loop through the array using the veritable `forEach`
    (ES5) looping function, handling each element passed through the loop as `tweet`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The objects contained in the `tweetsArr` array contain lots of data, such as
    time information, amount of re-tweets, and so forth. However, we''re just interested
    in the content of the tweet, and who tweeted. So we log the `from_user` and `text`
    properties of each `tweet` to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Twitter API and the User-Agent header](img/7188-03-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is also where the `colors` module comes in handy since, within `console.log`
    we have `tweet.from_user.yellow.bold`. The colors are not properties on the object
    returned by Twitter, but rather some trickery performed by the `colors` module
    to provide an easy interface for styling console text.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look into working with an XML-based service.
  prefs: []
  type: TYPE_NORMAL
- en: Cross referencing Google Hot Trends with Twitter tweets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It may be noticed that trending tweets tend to have rather fad-like influences
    generated from within the Twitter community. Google Hot Trends is another source
    of trending information. It provides hourly updates of the highest trending searches.
  prefs: []
  type: TYPE_NORMAL
- en: We can extend our example to access and process Google's Hot Trends XML atom
    feed, and then integrate the top result into our Twitter Search API request. To
    do this, let's create a new file called `google_trends.twitter.js`. It's nice
    to work with XML data as a JavaScript object, so we'll require the non-core `xml2js`
    featured in the *Converting an object to XML and back again* recipe in this chapter,
    along with `http, colors`, and our own `trendingTopics` module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Now we'll extend our `trendingTopics` object by inheriting from it using the
    EcmaScript 5 `Object.create` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We declared a variable called `hotTrends`, and used `Object.create` to initialize
    an instance of `trendingTopics`, re-substantiating the `trends` property via the
    property declarations object (the second parameter of `Object.create)`. This means
    that instead of `trends` being an inherited property, it now belongs to `hotTrends`
    and we haven't overwritten the `trends` property in `trendingTopics` when adding
    it to our new `hotTrends` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then add a new method: `hotTrends.xmlHandler`. This combines all the incoming
    chunks into the `hotTrendsfeed` variable. Once the stream has ended, it invokes
    `xml2js.parseString` and passes the XML contained in `hotTrendsfeed` into it.
    In the callback of the first `parseString` method, we invoke `xml2js.parseString`
    again. Why? Because we have to parse two sets of XML, or rather one set of XML
    and one set of adequately formed HTML. (If we head to [http://www.google.com/trends/hottrends/atom/hourly](http://www.google.com/trends/hottrends/atom/hourly)
    it will be rendered as HTML. If we view the source, we''ll then see an XML document
    with embedded HTML content.)'
  prefs: []
  type: TYPE_NORMAL
- en: Google's Hot Trends XML feed delivers the Hot Trends as HTML inside of its `content`
    XML node.
  prefs: []
  type: TYPE_NORMAL
- en: The HTML is wrapped within a `CDATA` section, so it isn't parsed by `xml2js`
    the first time round. Ergo, we create a new `Parser` and then parse the HTML via
    `obj.entry.content['#']`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `hotTrends.xmlHandler` method completes in the second embedded
    `xml2js` callback where it executes its own callback parameter (cb) with a query
    fragment generated from the top list item element in HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Now all we have to do is make some adjustments to `makeCall:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'As we are now dealing with both JSON and XML, we slipped in another parameter
    to our `makeCall` function declaration: `handler`. The `handler` parameter allows
    us to specify whether to use the inherited `jsonHander` method or our supplemented
    `xmlHandler` method.'
  prefs: []
  type: TYPE_NORMAL
- en: When we invoke the outer `makeCall`, we pass in `hotTrends.xmlHandler`, naming
    the parameter `query`. This is done because we are directly passing in the query
    fragment generated by `xmlHandler` instead of the array returned from Twitter.
    This is passed directly into the `tweetPath` method, which consequently updates
    the `path` property of the `hotTrends.tweets.urlOpts` object.
  prefs: []
  type: TYPE_NORMAL
- en: We pass `hotTrends.tweets.urlOpts` into the second `makeCall`, this time setting
    the `handler` parameter to `hotTrends.jsonHandler`.
  prefs: []
  type: TYPE_NORMAL
- en: The second `makeCall` callback behaves exactly the same as in the main recipe.
    It outputs the tweets to the console. This time, however, it outputs tweets based
    on Google Hot Trends.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using Node as an HTTP client* discussed In [Chapter 2](ch02.html "Chapter 2. Exploring
    the HTTP Object"),Exploring the HTTP Object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Converting an object to JSON and back again* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Converting an object to XML and back again* discussed in'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
