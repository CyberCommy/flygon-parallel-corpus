- en: Cryptography and Tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Three may keep a Secret, if two of them are dead."– Benjamin Franklin, Poor
    Richard''s Almanack'
  prefs: []
  type: TYPE_NORMAL
- en: In this short chapter, I am going to give you a brief overview of the cryptographic
    services offered by the Python standard library. I am also going to touch upon
    something called JSON Web Token, which is a very interesting standard to represent
    claims securely between two parties.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, we are going to explore the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Hashlib
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secrets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HMAC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON Web Tokens with PyJWT, which seems to be the most popular Python library
    for dealing with JWTs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by spending a moment talking about cryptography and why it is so
    important.
  prefs: []
  type: TYPE_NORMAL
- en: The need for cryptography
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to the statistics you can find all over the web, the estimated amount
    of smartphone users in 2019 will be around 2.5 billion. Each of those people know
    the PIN to unlock their phone, the credentials to log in to applications we all
    use to do, well, basically everything, from buying food to finding a street, from
    sending a message to a friend, to seeing if our bitcoin wallet has increased in
    value since we last checked 10 seconds ago.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are an application developer, you have to take security very, very seriously.
    It doesn''t matter how small or apparently insignificant your application is:
    security should always be a concern for you.'
  prefs: []
  type: TYPE_NORMAL
- en: Security in information technology is achieved by employing several different
    means, but by far, the most important one is cryptography. Everything you do with
    your computer or phone should include a layer where cryptography takes place (and
    if not, that's really bad). It is used to pay online with a credit card, to transfer
    messages over the network in a way that even if someone intercepts them, they
    won't be able to read them, and it is used to encrypt your files when you back
    them up in the cloud (because you do, right?). Lists of examples are endless.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the purpose of this chapter is not that of teaching you the difference
    between hashing and encryption, as I could write a whole other book on the subject.
    Rather, it is that of showing you how you can use the tools that Python offers
    you to create digests, tokens, and in general, to be on the safe(r) side when
    you need to implement something cryptography-related.
  prefs: []
  type: TYPE_NORMAL
- en: Useful guidelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Always remember the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule number one**: Do not attempt to create your own hash or encryption functions.
    Simply don''t. Use tools and functions that are there already. It is incredibly
    tough to come up with a good, solid, robust algorithm to do hashing or encryption,
    so it''s best to leave it to professional cryptographers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule number two**: Follow rule number one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those are the only two rules you need. Apart from them, it is very useful to
    understand cryptography, so you need to try and learn as much as you can about
    this subject. There is plenty of information on the web, but for your convenience,
    I'll put some useful references at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s dig into the first of the standard library modules I want to show
    you: `hashlib`.'
  prefs: []
  type: TYPE_NORMAL
- en: Hashlib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This module exposes a common interface to many different secure hash and message
    digest algorithms. The difference in those two terms is simply historical: older
    algorithms were called **digests**, while the modern algorithms are called **hashes**.'
  prefs: []
  type: TYPE_NORMAL
- en: In general, a hash function is any function that can be used to map data of
    an arbitrary size to data of a fixed size. It is a one-way type of encryption,
    in that it is not expected to be able to recover the message given its hash.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several algorithms that can be used to calculate a hash, so let''s
    see how to find out which ones are supported by your system (note, your results
    might be different than mine):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'By opening a Python shell, we can get the list of available algorithms for
    our system. If our application has to talk to third-party applications, it''s
    always best to pick an algorithm out of those guaranteed, though, as that means
    every platform actually supports them. Notice that a lot of them start with **sha**,
    which means **secure hash algorithm**. Let''s keep going in the same shell: we
    are going to create a hash for the binary string `b''Hash me now!''`, and we''re
    going to do it in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We have used the `blake2b` cryptographic function, which is quite sophisticated
    and was added in Python 3.6\. After creating the hash object `h`, we update its
    message in two steps. Not that we need to, but sometimes we need to hash data
    that is not available all at once, so it's good to know we can do it in steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the message is like we want it to be, we get the hex representation of
    the digest. This will use two characters per byte (as each character represents
    4 bits, which is half a byte). We also get the byte representation of the digest,
    and then we inspect its details: it has a block size (the internal block size
    of the hash algorithm in bytes) of 128 bytes, a digest size (the size of the resulting
    hash in bytes) of 64 bytes, and a name. Could all this be done in one simpler
    line? Yes, of course:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the same message produces the same hash, which of course is expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what we get if, instead of the `blake2b` function, we use `sha256`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The resulting hash is shorter (and therefore less secure).
  prefs: []
  type: TYPE_NORMAL
- en: 'Hashing is a very interesting topic, and of course the simple examples we''ve
    seen so far are just the start. The `blake2b` function allows us a great deal
    of flexibility in terms of customization. This is extremely useful to prevent
    some kinds of attacks (for the full explanation of those threats, please do refer
    to the standard documentation at: [https://docs.python.org/3.7/library/hashlib.html](https://docs.python.org/3.7/library/hashlib.html)
    for the `hashlib` module). Let''s see another example where we customize a hash
    by adding a `key`, a `salt`, and a `person`. All of this extra information will
    cause the hash to be different than the one we would get if we didn''t provide
    them, and are crucial in adding extra security to the data handled in our system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The resulting hash is only 16 bytes long. Among the customization parameters,
    `salt` is probably the most famous one. It is random data that is used as an additional
    input to a one-way function that hashes data. It is commonly stored alongside
    the resulting hash, in order to provide the means to recover the same hash given
    the same message.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to make sure you hash a password properly, you can use `pbkdf2_hmac`,
    a key derivation algorithm that allows you to specify a `salt` and also the number
    of iterations used by the algorithm itself. As computers get more and more powerful,
    it is important to increase the amount of iterations we do over time, otherwise
    the likelihood of a successful brute-force attack on our data increases as time
    passes. Here''s how you would use such an algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice I have used `os.urandom` to provide a 16 byte random salt, as recommended
    by the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: I encourage you to explore and experiment with this module, as sooner or later
    you will have to use it. Now, let's move on to the `secrets` one.
  prefs: []
  type: TYPE_NORMAL
- en: Secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This nice, small module is used for generating cryptographically strong, random
    numbers suitable for managing data such as passwords, account authentication,
    security tokens, and related secrets. It was added in Python 3.6, and basically
    deals with three things: random numbers, tokens, and digest comparison. Let''s
    explore them very quickly.'
  prefs: []
  type: TYPE_NORMAL
- en: Random numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use three functions in order to deal with random numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The first one, `choice`, picks an element at random from a non-empty sequence.
    The second one, `randbelow`, generates a random integer between `0` and the argument
    you call it with, and the third one, `randbits`, generates an integer with *n* random
    bits in it. Running that code produces the following output (which is always different):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You should use these functions instead of those from the `random` module whenever
    you need randomness in the context of cryptography, as these are specially designed
    for this task. Let's see what the module gives us for tokens.
  prefs: []
  type: TYPE_NORMAL
- en: Token generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Again, we have three functions that all produce a token, albeit in different
    formats. Let''s see the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The first one, `token_bytes`, simply returns a random byte string containing *n*
    bytes (`16`, in this example). The other two do the same, but `token_hex` returns
    a token in hexadecimal format, and `token_urlsafe` returns a token that only contains
    characters suitable for being included in a URL. Let''s see the output (which
    is a continuation from the previous run):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is all nice, so why don't we have some fun and write a random password
    generator using these tools?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we defined two functions. `generate_pwd` simply generates
    a random string of given length by joining together `length` characters picked
    at random from a string that contains all the letters of the alphabet (lowercase
    and uppercase), and the 10 decimal digits.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we define another function, `generate_secure_pwd`, that simply keeps calling `generate_pwd`
    until the random string we get matches the requirements, which are quite simple.
    The password must have at least one lowercase character, `upper` uppercase characters, `digits`
    digits, and `length` length.
  prefs: []
  type: TYPE_NORMAL
- en: Before we dive into the `while`loop, it's worth noting that if we sum together
    the requirements (uppercase, lowercase, and digits) and that sum is greater than
    the overall length of the password, there is no way we can ever satisfy the condition
    within the loop. So, in order to avoid getting stuck in an infinite loop, I have
    put a check clause in the first line of the body, and I raise a `ValueError` in
    case I need it. Could you think of how to write a test for this edge case?
  prefs: []
  type: TYPE_NORMAL
- en: 'The body of the `while` loop is straightforward: first we generate the random
    password, and then we verify the conditions by using `any` and `sum`. `any` returns `True`
    if any of the items in the iterable it''s called with evaluate to `True`. The
    use of sum is actually slightly more tricky here, in that it exploits polymorphism.
    Can you see what I''m talking about before you read on?'
  prefs: []
  type: TYPE_NORMAL
- en: Well, it's very simple: `True` and `False` in Python are subclasses of integer
    numbers, therefore when summing on an iterable of `True`/`False` values, they
    will automatically be interpreted like integers by the `sum` function. That is
    called **polymorphism**, and we've briefly talked about it in [Chapter 6](part0163.html#4REBM0-2ddb708647cc4530a187c2c6c0e9acfe),
    *OOP, Decorators, and Iterators*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the example produces the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The second password is probably not too secure...
  prefs: []
  type: TYPE_NORMAL
- en: 'One last example, before we move on to the next module. Let''s generate a reset
    password URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is so easy I will only show you the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Digest comparison
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is probably quite surprising, but within `secrets`, you can find the `compare_digest(a,
    b)` function, which is the equivalent of comparing two digests by simply doing `a
    == b`. So, why do we need that function? It's because it has been designed to
    prevent timing attacks. These kind of attacks can infer information about where
    the two digests start being different, according to the time it takes for the
    comparison to fail. So, `compare_digest` prevents this attack by removing the
    correlation between time and failures. I think this is a brilliant example of
    how sophisticated attacking methods can be. If you raised your eyebrows in astonishment,
    maybe now it's clearer why I said to never implement cryptography functions by
    yourself.
  prefs: []
  type: TYPE_NORMAL
- en: And that's it! Now, let's check out `hmac`.
  prefs: []
  type: TYPE_NORMAL
- en: HMAC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This module implements the HMAC algorithm, as described by RFC 2104 ([https://tools.ietf.org/html/rfc2104.html](https://tools.ietf.org/html/rfc2104.html)).
    Since it is very small, but nonetheless important, I will provide you with a simple
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the interface is always the same or similar. We first convert
    the key and the message into bytes, and then create a `digest` instance that we
    will use to get a hexadecimal representation of the hash. Not much else to say,
    but I thought to add this module anyway, for completeness.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s move on to a different type of token: JWTs.'
  prefs: []
  type: TYPE_NORMAL
- en: JSON Web Tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **JSON Web Token**, or **JWT**, is a JSON-based open standard for creating
    tokens that assert some number of claims. You can learn all about this technology
    on the website ([https://jwt.io/](https://jwt.io/)). In a nutshell, this type
    of token is comprised of three sections, separated by a dot, in the format *A.B.C*. *B*
    is the payload, which is where we put the data and the claims. *C* is the signature,
    which is used to verify the validity of the token, and *A* is the algorithm used
    to compute the signature. *A*, *B*, and *C* are all encoded with a URL safe Base64
    encoding (which I'll refer to as Base64URL).
  prefs: []
  type: TYPE_NORMAL
- en: Base64 is a very popular binary-to-text encoding scheme that represents binary
    data in an ASCII string format by translating it into a radix-64 representation.
    The radix-64 representation uses the letters *A-Z*, *a-z*, and the digits *0-9*,
    plus the two symbols *+* and */* for a grand total of 64 symbols altogether. Therefore,
    not surprisingly, the Base64 alphabet is made up of these 64 symbols. Base64 is
    used, for example, to encode images attached in an email. It happens seamlessly,
    so the vast majority of people are completely oblivious of this fact.
  prefs: []
  type: TYPE_NORMAL
- en: The reason why a JWT is encoded using Base64URL is because of the characters `+`
    and `/`, which in a URL context mean space, and path separator, respectively.
    Therefore in the URL safe version, they are replaced with `-` and `_`. Moreover,
    any padding character (`=`), which is normally used in Base64, is stripped out,
    as this too has a specific meaning within a URL.
  prefs: []
  type: TYPE_NORMAL
- en: The way this type of token works is therefore slightly different than what we
    are used to when we work with hashes. In fact, the information that the token
    carries is always visible. You just need to decode *A* and *B* to get the algorithm
    and the payload. However, the security lies in part *C*, which is a HMAC hash
    of the token. If you try to modify the *B* part by editing the payload, encoding
    it back to Base64, and replacing it in the token, the signature won't match any
    more, and therefore the token will be invalid.
  prefs: []
  type: TYPE_NORMAL
- en: This means that we can build a payload with claims such as *logged in as admin*,
    or something along those lines, and as long as the token is valid, we know we
    can trust that that user is actually logged in as an admin.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with JWTs, you want to make sure you have researched how to handle
    them safely. Things like not accepting unsigned tokens, or restricting the list
    of algorithms you use to encode and decode, as well as other security measures,
    are very important and you should take the time to investigate and learn them.
  prefs: []
  type: TYPE_NORMAL
- en: For this part of the code, you will have to have the `PyJWT` and `cryptography`
    Python packages installed. As always, you will find them in the requirements of
    the source code of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We define the `data` payload, which contains an ID and some payload data. Then,
    we create a token using the `jwt.encode` function, which takes at least the payload
    and a secret key, which is used to compute the signature. The default algorithm
    used to calculate the token is `HS256`. Let''s see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: So, as you can see, the token is a binary string of Base64URL-encoded pieces
    of data. We have called `jwt.decode`, providing the correct secret key. Had we
    done otherwise, the decoding would have broken.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, you might want to be able to inspect the content of the token without
    verifying it. You can do so by simply calling `decode` this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This is useful, for example, when values in the token payload are needed to
    recover the secret key, but that technique is quite advanced so I won''t be spending
    time on it in this context. Instead, let''s see how we can specify a different
    algorithm for computing the signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The output is our original payload dictionary. In case you want to allow more
    than one algorithm in the decoding phase, you can even specify a list of them,
    instead of only one.
  prefs: []
  type: TYPE_NORMAL
- en: Now, while you are free to put whatever you want in the token payload, there
    are some claims that have been standardized, and they enable you to have a great
    deal of control over the token.
  prefs: []
  type: TYPE_NORMAL
- en: Registered claims
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the time of writing this book, these are the registered claims:'
  prefs: []
  type: TYPE_NORMAL
- en: '`iss`: The *issuer* of the token'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sub`: The *subject* information about the party this token is carrying information
    about'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aud`: The *audience* for the token'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exp`: The *expiration time*, after which the token is considered to be invalid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nbf`: The *not before (time)*, or the time before which the token is considered
    to be not valid yet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iat`: The time at which the token was *issued*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jti`: The token *ID*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Claims can also be categorized as public or private:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Private**: Are those that are defined by users (consumers and producers)
    of the JWTs. In other words, these are ad hoc claims used for a particular case.
    As such, care must be taken to prevent collisions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Public**: Are claims that are either registered with the IANA JSON Web Token
    Claims Registry (a registry where users can register their claims and thus prevent
    collisions), or named using a collision resistant name (for instance, by prepending
    a namespace to its name).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To learn all about claims, please refer to the official website. Now, let's
    see a couple of code examples involving a subset of these claims.
  prefs: []
  type: TYPE_NORMAL
- en: Time-related claims
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how we might use the claims related to time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we set the issued at (`iat`) claim to the current UTC time
    (**UTC** stands for **Universal Time Coordinated**). We then set the not before
    (`nbf`) and expire time (`exp`) at `1` and `3` seconds from now, respectively.
    We then defined a decode helper function that reacts to a token not being valid
    yet, or being expired, by trapping the appropriate exceptions, and then we call
    it three times, interspersed by two calls to sleep. This way, we will try to decode
    the token when it''s not valid yet, then when it''s valid, and finally when it''s
    already expired. This function also prints a useful timestamp before attempting
    decryption. Let''s see how it goes (blank lines have been added for readability):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it all executed as expected. We get nice, descriptive messages
    from the exceptions, and get the original payload back when the token is actually
    valid.
  prefs: []
  type: TYPE_NORMAL
- en: Auth-related claims
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see another quick example involving the issuer (`iss`) and audience
    (`aud`) claims. The code is conceptually very similar to the previous example,
    and we''re going to exercise it in the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this time, we have specified `issuer` and `audience`. It turns
    out that if we don't provide the issuer when decoding the token, it won't cause
    the decoding to break. However, providing the wrong issuer will actually break
    decoding. On the other hand, both failing to provide the audience, or providing
    the wrong audience, will break decoding.
  prefs: []
  type: TYPE_NORMAL
- en: 'As in the previous example, I have written a custom decode function that reacts
    to the appropriate exceptions. See if you can follow along with the calls and
    the relative output that follows (I''ll help with some blank lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's see one final example for a more complex use case.
  prefs: []
  type: TYPE_NORMAL
- en: Using asymmetric (public-key) algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, using a shared secret is not the best option. In those cases, it
    might be useful to adopt a different technique. In this example, we are going
    to create a token (and decode it) using a pair of RSA keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Public key cryptography, or asymmetrical cryptography, is any cryptographic
    system that uses pairs of keys: public keys which may be disseminated widely,
    and private keys which are known only to the owner. If you are interested in learning
    more about this topic, please see the end of this chapter for recommendations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create two pairs of keys. One pair will have no password, and one
    will. To create them, I''m going to use the `ssh-keygen` utils from OpenSSH ([https://www.ssh.com/ssh/keygen/](https://www.ssh.com/ssh/keygen/)).
    In the folder where my scripts for this chapter are, I created an `rsa` subfolder.
    Within it, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Give the name `key` to the path (it will be saved in the current folder), and
    simply hit the *Enter* key when asked for the password. When done, do the same
    again, but this time use the name `keypwd` for the key, and give it a password.
    The one I chose is the classic `Password123`. When you are done, change back to
    the `ch9` folder, and run this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we defined a couple of custom functions to encode and
    decode tokens using private/public keys. As you can see in the signature of the `encode`
    function, we are using the `RS256` algorithm this time. We need to open the private
    key file by using the special `load_pem_private_key` function, which allows us
    to specify a content, password, and backend. `.pem` is the name of the format
    in which our keys have been created. If you take a look at those files, you will
    probably recognize them, since they are quite popular.
  prefs: []
  type: TYPE_NORMAL
- en: The logic is pretty straightforward, and I would encourage you to think about
    at least one use case where this technique might be more suitable than using a
    shared key.
  prefs: []
  type: TYPE_NORMAL
- en: Useful references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, you can find a list of useful references if you want to dig deeper in
    to the fascinating world of cryptography:'
  prefs: []
  type: TYPE_NORMAL
- en: Cryptography: [https://en.wikipedia.org/wiki/Cryptography](https://en.wikipedia.org/wiki/Cryptography)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON Web Tokens: [https://jwt.io](https://jwt.io)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash functions: [https://en.wikipedia.org/wiki/Cryptographic_hash_function](https://en.wikipedia.org/wiki/Cryptographic_hash_function)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HMAC: [https://en.wikipedia.org/wiki/HMAC](https://en.wikipedia.org/wiki/HMAC)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cryptography services (Python STD library): [https://docs.python.org/3.7/library/crypto.html](https://docs.python.org/3.7/library/crypto.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IANA JSON Web Token Claims Registry: [https://www.iana.org/assignments/jwt/jwt.xhtml](https://www.iana.org/assignments/jwt/jwt.xhtml)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PyJWT library: [https://pyjwt.readthedocs.io/](https://pyjwt.readthedocs.io/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cryptography library: [https://cryptography.io/](https://cryptography.io/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is way more on the web, and plenty of books you can also study, but I'd
    recommend that you start with the main concepts and then gradually dive into the
    specifics you want to understand more thoroughly.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this short chapter, we explored the world of cryptography in the Python standard
    library. We learned how to create a hash (or digest) for a message using different
    cryptographic functions. We also learned how to create tokens and deal with random
    data when it comes to the cryptography context.
  prefs: []
  type: TYPE_NORMAL
- en: We then took a small tour outside the standard library to learn about JSON Web
    Tokens, which are used intensively today in authentication and claims-related
    functionalities by modern systems and applications.
  prefs: []
  type: TYPE_NORMAL
- en: The most important thing is to understand that doing things manually can be
    very risky when it comes to cryptography, so it's always best to leave it to the
    professionals and simply use the tools we have available.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will be all about moving away from one line of software execution.
    We're going to learn how software works in the real world, explore concurrent
    execution, and learn about threads, processes, and the tools Python gives us to
    do *more than one thing at a time*, so to speak.
  prefs: []
  type: TYPE_NORMAL
