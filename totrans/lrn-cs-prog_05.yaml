- en: '*Chapter 5*: Object-Oriented Programming in C#'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered user-defined types and learned about classes,
    structures, and enumerations. In this chapter, we will learn about **object-oriented
    programming** (or **OOP** for short). A good understanding of OOP concepts is
    essential to write better programs using C#. OOP reduces code complexity, increases
    code reusability, and makes software easy to maintain and scale.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following concepts in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding OOP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SOLID principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will learn how to create classes and methods
    using OOP. Let's begin with an overview of OOP.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding OOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Object-oriented programming is a paradigm that allows us to write a program
    around objects. As discussed in the previous chapter, objects contain data and
    methods to act on that data. Each object has its own set of data and methods.
    If an object wants to access the data of another object, it has to access it via
    the methods defined in that object. An object can inherit the properties of another
    object using the concept of **inheritance**. Hence, we can say that object-oriented
    programming is organized around data and the operations that are permitted on
    the data.
  prefs: []
  type: TYPE_NORMAL
- en: C# is a general-purpose multi-paradigm programming language. OOP is only one
    of these paradigms. Other supported paradigms, such as generic and functional
    programming, will be discussed in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: When discussing object-oriented programming, it is important to understand the
    differences between classes and objects. As mentioned already, in the previous
    chapter, a class is a blueprint that defines data and how it is represented in
    memory as well as functionalities that operate on this data. On the other hand,
    an object is an instance of a class built and functioning according to the blueprint.
    It has a physical representation in memory, unlike a class that only exists in
    source code.
  prefs: []
  type: TYPE_NORMAL
- en: When you do object-oriented programming, you start with identifying the entities
    you need to operate on, how they relate to each other, and how they interact.
    This is a process called **data modeling**. The result of this is a set of classes
    that generalize the identified entities. These can vary from physical entities
    (people, objects, machines, and so on) to abstractions (an order, a to-do list,
    a connection string, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction, encapsulation, polymorphism, and inheritance are the core principles
    of object-oriented programming. We will explore them in detail in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Abstraction is the process of describing entities and processes in simple terms
    by removing non-essential characteristics. A physical or abstract entity may have
    many characteristics but for the purpose of some application or domain, not all
    of them are important. By abstracting entities into simple models (that make sense
    for the application domain), we can build simpler and more efficient programs.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider the example of an employee. An employee is a person. A person
    has a name; a birthday; body characteristics, such as height, weight, hair color,
    and eye color; relatives and friends; likes and hobbies (such as food, books,
    movies, and sports); an address; properties (such as a house or apartment and
    cars or bikes); one or more phone numbers and email addresses; and many other
    things that we could fill pages listing.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the kind of application we are building, some of these are relevant
    and some are not. For instance, if we build a payroll system, we are interested
    in an employee's name, birthday, address, phone, and email, as well as hiring
    date, department, role, salary, and so on. If we build a social media application,
    we are interested in a user's name, birthday, address, relatives, friends, interests,
    activities, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, different levels of abstraction are required—some more general, others
    more particular. For instance, if we build a graphical system that can draw shapes,
    we might need to model a generic shape with little functionalities, such as the
    ability to draw itself or transform (translate and rotate) itself. We can then
    have two-dimensional shapes and three-dimensional shapes, each with more specific
    properties and functionalities based on the characteristics of these shapes.
  prefs: []
  type: TYPE_NORMAL
- en: We can build lines, ellipses, and polygons as two-dimensional shapes. A line
    has properties such as a start point and an end point, but an ellipse has two
    foci, as well as an area and a perimeter. Three-dimensional objects, such as a
    cube, can drop shadows. Although we are still abstracting concepts, we have moved
    from more general to more particular abstractions. When these abstractions are
    based on each other, the typical way to implement them is through inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encapsulation is defined as binding data and code that manipulates it together
    in a single unit. Data is privately bound within a class without direct access
    from the outside of the class. All objects that need to read or modify the data
    of an object should do it through the public methods that a class provides. This
    characteristic is called **data hiding** and makes code less error-prone by defining
    a limited number of entry points to an object's data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `Employee` class here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'An employee has two properties modeled here: `name` and `salary`. These are
    implemented as `private` class fields, which makes them accessible only from within
    the `Employee` class. Both of these values are set in the constructor. The name
    is exposed for reading and writing using the property called `Name`. The `salary`
    variable is, however, only exposed for reading, with the read-only property called
    `Salary`. To change the salary, we must call the `GiveRaise()` method. Of course,
    this is just a possible implementation. We could have used auto-implemented properties
    instead of fields, or maybe different other methods to modify the salary. This
    class can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We have created an object of the `Employee` class and set the values to the
    private fields using the constructor. The `Employee` class does not allow direct
    access to its fields. To read their values, we use the public `get` accessor of
    the public properties. To change the salary, we use the `GiveRaise()` method.
    The output of this program is as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – The console output from the execution of the preceding snippet'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.1_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – The console output from the execution of the preceding snippet
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation allows us to hide the data inside a class from the outside world,
    which is why it is also known as data-hiding.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation is important because it reduces the dependencies between different
    components by defining minimal public interfaces for them. It also increases code
    reusability and security and makes code easier to unit test.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inheritance is a mechanism through which a class can inherit the properties
    and functionalities of another class. If we have a set of common functionalities
    and data shared among multiple classes, we can put them in one class known as
    a **parent** or **base** class. Other classes can inherit these functionalities
    and data of the parent class as well as extending or modifying them and adding
    additional functionalities and properties. A class that inherits from another
    class is known as a **child** or **derived** class. Inheritance, therefore, facilitates
    *code reusability*.
  prefs: []
  type: TYPE_NORMAL
- en: In C#, inheritance is only supported for reference types. Only types defined
    as classes can be derived from other types. Types that are defined as structures
    are value types and cannot be derived from other types. However, all types in
    C# are either value or reference types and are indirectly derived from the `System.Object`
    type. This relationship is implicit and does not require developers to do anything
    special.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three types of inheritance supported in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single inheritance**: When a class inherits from one parent class. The child
    class should not act as the parent class to any other class. Refer to the following
    diagram, where class B is inheriting for class A:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 5.2 – A class diagram showing class B inheriting from class A'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.2_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – A class diagram showing class B inheriting from class A
  prefs: []
  type: TYPE_NORMAL
- en: '**Multilevel inheritance**: This is actually an extension to the previous case,
    because the child is, on the other hand, a parent to another class. In the following
    diagram, class B is a child class to class A as well as the parent to class C:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 5.3 – A class diagram showing class A being the base class for class
    B, which in turn is the base for class C'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.3_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 – A class diagram showing class A being the base class for class
    B, which in turn is the base for class C
  prefs: []
  type: TYPE_NORMAL
- en: '**Hierarchical inheritance**: A class serves as the parent class to more than
    one class. Refer to the following diagram. Here, the classes B and C inherit from
    the same parent class, A:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 5.4 – A class diagram showing classes B and C inheriting from the
    base class A'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.4_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.4 – A class diagram showing classes B and C inheriting from the base
    class A
  prefs: []
  type: TYPE_NORMAL
- en: Unlike other programming languages (such as C++), C# does not support multiple
    inheritance. This means that a class cannot be derived from more than one class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand inheritance, let''s consider the following example: we are building
    a game that must represent objects such as terrain, obstacles, people, machinery,
    and so on. These are various types of objects with different properties. For instance,
    people and machines can move and battle, obstacles can be destroyed, terrain can
    be crossable or not, and so on. However, all of these game objects have some common
    properties: they all have a position in the game and they all can be drawn on
    a surface (which could be a screen, memory, and so on). We can represent a base
    class that provides these functionalities as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`GameUnit` is a class with a property called `Position`; the accessor `get`
    is public, but the accessor `set` is protected, which means it is only accessible
    from this class or its derived classes. The `Draw()` public method draws the unit
    on a surface at the current unit position. `GetImage()` is a virtual method that
    returns the representation on a unit (which, in our example, is a single character).
    In the base class, this simply returns a space, but in the derived classes, this
    will be implemented to return an actual character.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Position` and `Surface` classes seen here are implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'From the base class, we will now derive several other classes. To keep it simple,
    we will focus on terrain objects for the time being:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We have defined here a `Terrain` class, derived from `GameUnit`, which is itself
    a base class for all types of terrain. We don''t have many things in this class,
    but in a real application, there would be various functionalities. `Water` and
    `Hill` are two classes derived from `Terrain` that override the `GetImage()` class
    returning a different character to represent the terrain. We can use these as
    follows to build a game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this program is as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – The console output from the execution of the previous program'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.5_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.5 – The console output from the execution of the previous program
  prefs: []
  type: TYPE_NORMAL
- en: Virtual members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding example, we have seen a virtual method. This is a method that
    has an implementation in a base class but can be overridden in derived classes,
    which is helpful for changing implementation details. Methods are non-virtual
    by default. A virtual method in a base class is declared with the `virtual` keyword.
    An overridden implementation of a virtual method in a derived class is defined
    with the `override` keyword, instead of the `virtual` keyword. The method signature
    of the virtual and overridden methods must match.
  prefs: []
  type: TYPE_NORMAL
- en: Methods are not the only class members that can be virtual. The `virtual` keyword
    can be applied to properties, indexers, and events. However, the `virtual` modifier
    cannot be used together with `static`, `abstract`, `private`, or `override` modifiers.
  prefs: []
  type: TYPE_NORMAL
- en: A virtual member that is overridden in a derived class can be further overridden
    in a class derived from the derived class. This chain of virtual inheritance continues
    indefinitely unless explicitly stopped with the use of the `sealed` keyword, as
    described in a subsequent section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The classes shown earlier can be modified to use a virtual property, called
    `Image` in the following code, instead of the virtual method, `GetImage()`. In
    this case, they would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There are cases when you want a method to be overridden in derived classes without
    providing an implementation in the base class. Such virtual methods are called
    *abstract* and will be discussed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes and members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The examples we have seen so far have an inconvenience because, although the
    `GameUnit` and `Terrain` classes are just some base classes without an actual
    representation in the game, we can still instantiate them. This is unfortunate
    because we would want to be able to only create objects of `Water` and `Hill`.
    Also, the `GetImage()` virtual method or the `Image` virtual property must have
    an implementation in the base class, which does not make much sense. We would
    actually only want to have an implementation in classes representing physical
    objects. This can be achieved using abstract classes and members.
  prefs: []
  type: TYPE_NORMAL
- en: An abstract class is declared using the `abstract` keyword. An abstract class
    cannot be instantiated, which means we cannot create the object of an abstract
    class. If we try to create an instance of an abstract class, it will result in
    a compile-time error. An abstract class is supposed to be the base class for other
    classes that will implement the abstractions that a class defines.
  prefs: []
  type: TYPE_NORMAL
- en: An abstract class must include at least one abstract member, which can be a
    method, property, indexer, or event. Abstract members are also declared using
    the `abstract` keyword. A non-abstract class that derives from an abstract class
    must implement all of the inherited abstract members and property accessors.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can rewrite the game unit examples using abstract classes and members. This
    is shown in the following listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `GameUnit` class is declared `abstract`. It has an abstract
    property, `Image`, which no longer has an implementation. `Terrain` is derived
    from `GameUnit` but because it does not override the abstract property, it is
    itself an abstract class and must be declared using the `abstract` modifier. The
    `Water` and `Hill` classes are both overriding the `Image` property, and do so
    using the `override` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are a few features of an abstract class:'
  prefs: []
  type: TYPE_NORMAL
- en: An abstract class can have both abstract and non-abstract members.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a class contains an abstract member, then the class must be marked `abstract`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An abstract member cannot be private.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An abstract member cannot have an implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An abstract class must provide an implementation for all of the members of all
    of the interfaces it implements (if any).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Similarly, an abstract method or property has the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: An abstract method is implicitly a virtual method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Members declared abstract cannot be `static` or `virtual`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implementation in a derived class must specify the `override` keyword in
    the declaration of the member.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, we have seen how classes and members can be derived and overridden.
    However, it is possible to prevent this from happening. We will learn how to do
    so in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Sealed classes and members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we want to restrict a class from being inherited by another class, then
    we declare the class as `sealed`. If we try to inherit a sealed class, it will
    result in a compile-time error. We use the `sealed` keyword to create a sealed
    class. Refer to the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `Water` class here is declared `sealed`. An attempt to use it as a base
    class for another class will result in a compile-type error.
  prefs: []
  type: TYPE_NORMAL
- en: Not only can classes be declared as `sealed`, but overridden members can too.
    A class can stop the virtual inheritance of a member by using the `sealed` keyword
    in front of `override`. An attempt to override it again in a further derived class
    will result in a compiler error.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the `Water` class is not sealed, but its `Image`
    property is. Attempting to override it in the `Lake` derived class will produce
    a compiler error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have seen how to use sealed classes and members, let's see how to
    hide base class members.
  prefs: []
  type: TYPE_NORMAL
- en: Hiding base class members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In certain situations, you might want to hide an existing member of a base
    class with a member with the same name in the derived class, without *virtual
    invocation* (which is the invocation of virtual methods within the class hierarchy).
    This is possible by using the `new` keyword in front of the return type of the
    member in the derived class, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'A new member defined this way will be invoked when called through a reference
    to the derived type. However, if the member is invoked through a reference to
    the base type, the hidden base member will be called as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Unlike virtual methods, which are invoked at runtime based on the runtime type
    of the object used to invoke them, hidden methods are resolved at compile-time
    based on the compile-time type of the object used to invoke them.
  prefs: []
  type: TYPE_NORMAL
- en: 'A possible use for hiding members is shown in the following example, where
    we have a hierarchy of classes that need to support a cloning method. However,
    each class should return a new copy of itself and not a reference to the base
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'With these defined, we can write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that this works only when we invoke the `Clone()` method from an object
    of that class, and not through a reference to the base class. Because the invocation
    is resolved at compile time, if you have a reference to `Pet`, even if the runtime
    type of the object is `Dog`, only `Pet` will be cloned. This is exemplified in
    the following sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Member hiding is, in general, considered a code smell (that is, an indication
    of a deeper problem within the design and the code base) and should be avoided.
    The goals achieved through member hiding can usually be reached by better means.
    For instance, the cloning example shown here can be implemented by using a creational
    design pattern, typically the **Prototype** pattern, but possibly others such
    as the **Factory Method**.
  prefs: []
  type: TYPE_NORMAL
- en: So far in this chapter, we have seen how to create classes and hierarchies of
    classes. Another important concept in object-oriented programming is interfaces,
    which is the topic we will discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An interface contains a set of members that must be implemented by any class
    or struct that implements the interface. An interface defines a contract that
    is supported by all of the types that implement the interface. This also means
    that the clients using interfaces do not need to know anything about the actual
    implementation details, which promotes loose coupling, which helps with maintenance
    and testability.
  prefs: []
  type: TYPE_NORMAL
- en: Because neither multiple class inheritance nor inheritance for structures is
    supported in the language, interfaces provide a means to simulate them. A type,
    regardless of whether it is a reference type or a value type, can implement any
    number of interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, an interface *contains only declarations* of members but *not implementations*.
    Beginning with C# 8, interfaces can contain default methods; this is a subject
    that will be covered in detail in [*Chapter 15*](B12346_15_Final_JC_ePub.xhtml#_idTextAnchor271),
    *New Features of C# 8*. In C#, interfaces are declared using the `interface` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list contains important points to consider when using interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: An interface can contain only methods, properties, indexers, and events. They
    cannot contain fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a type implements an interface, then it must provide an implementation for
    all of the members of the interface. The method signature and return type of the
    method of an interface cannot be altered by the type that is implementing the
    interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When an interface defines properties or indexers, an implementation can provide
    extra accessors for them. For instance, if a property in an interface has only
    the `get` accessor, the implementation can also provide a `set` accessor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An interface cannot have constructors or operators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An interface cannot have static members.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interface members are implicitly defined as `public`. If you try to use
    an access modifier with a member of an interface, it will result in a compile-time
    error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An interface can be implemented by multiple types. A type can implement multiple
    interfaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a class is inheriting from another class and simultaneously implementing
    an interface, then the base class name must come before the name of the interface
    separated by a comma.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typically, an interface name starts with the letter `I`, such as `IEnumerable`,
    `IList<T>`, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To understand how interfaces work, we will consider the example with game units.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous implementations, we had a class called `Surface`, which was
    responsible for drawing the game objects. Our implementation was printing to the
    console but this could be anything—the game window, memory, a bitmap, and so on.
    To make it possible to easily change between these and not tie the `GameUnit`
    class to a particular implementation of surfaces, we can define an interface that
    will specify the functionalities that any implementation must provide. This interface
    will then be used by the game unit for rendering. Such an interface can be defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'It contains three member functions, all implicitly `public`. This interface
    will then be implemented by the `Surface` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The class must implement all of the members of the interface. However, it is
    possible to skip that. In that case, the class must be abstract and must declare
    abstract members to match the interface members that it does not implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, the `Surface` class implements all three methods
    of the `ISurface` interface. The methods are explicitly declared as `public`.
    Using any other access modifier would result in a compiler error because the members
    are implicitly public in the interface and the class cannot lower their visibility.
    The `GameUnit` class will change, so that the `Draw()` method will have an `ISurface`
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s further extend the example and consider another interface called `IMoveable`
    that defines a `MoveTo()` method that moves a game object to another position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This interface will be implemented by all of the game objects that can be moved,
    such as people, machines, and so on. A class called `ActionUnit` acts as a base
    class for all such objects and implements `IMoveable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`ActionUnit` is also derived from `GameUnit`, so the base class comes before
    the list of interfaces. However, since this class only acts as a base class for
    other classes, it does not implement the `Image` property and must, therefore,
    be abstract. A `Meeple` class, shown in the following listing, derives from `ActionUnit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use instances of the `Meeple` class to extend the game we built in a
    previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – The console output from the execution of the modified game'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.6_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.6 – The console output from the execution of the modified game
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned about inheritance, it is time to look at the last pillar
    of OOP, which is polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last core pillar of object-oriented programming is polymorphism. Polymorphism
    is a Greek word that stands for *multiple forms*. This is the ability to use one
    entity in multiple forms. There are two types of polymorphism:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Compile-time polymorphism*: When we have methods with the same name but different
    numbers or types of parameters, which is called method overloading.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Run-time polymorphism*: This has two different aspects:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On one hand, Objects of derived classes can be seamlessly used as objects of
    base classes in arrays or other types of collections, method parameters, and other
    places.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, Classes can define virtual methods that can be overridden
    in derived classes. At runtime, the **Common Language Runtime** (**CLR**) will
    invoke the implementation of the virtual member corresponding to the runtime type
    of the object. An object's declared type and its runtime type differ when objects
    of derived classes are used in place of objects of base classes.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism promotes code reuse, which can make it easier to read, test, and
    maintain the code. It also promotes separation of concerns, which is an important
    principle in object-oriented programming. Another benefit is that it helps to
    hide implementation details because it allows interacting with different classes
    through a common interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous sections, we have seen examples of both these aspects. We have
    seen how to declare virtual members and how to override them, as well as how to
    stop the virtual inheritance with the `sealed` keyword. We have also seen examples
    of objects of derived classes used in arrays of base classes. Here is, again,
    such an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Compile-time polymorphism is represented by *method and operator overloading*.
    We will explore these in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Method overloading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Method overloading allows us to declare two or more methods within the same
    class with the same name but different parameters. This can be either a different
    number of parameters or parameters of different types. The return type is not
    considered for overload resolution. If two methods differ only in the return type,
    then the compiler will issue an error. Also, the `ref`, `in`, and `out` parameter
    modifiers do not participate in overload resolution. That means that two methods
    cannot differ only in a parameter modifier, such as one method has a `ref` parameter
    and another one has the same parameter specified with `in` or `out` modifiers.
    On the other hand, a method with a parameter with no modifier can be overloaded
    by a method that has the same parameter specified as `ref`, `in`, or `out`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following example to understand method overloading. Considering
    the `IMoveable` interface shown earlier, we can modify it so that it contains
    two methods called `MoveTo()` with different parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ActionUnit` class provides implementations for both of these overloads.
    When the overloaded method is called, the compiler finds the best match based
    on the type and number of supplied arguments and invokes the appropriate overload.
    An example is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The process to identify the best match for a method call is called *overload
    resolution*. There are many rules that define how the best match is found and
    listing them all is beyond the scope of this book. In very simple terms, overload
    resolution is performed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a set of members with the specified name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Eliminate all of the members that are not accessible from the calling scope.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Eliminate all of the inapplicable members. An applicable member is one that
    has a parameter for every argument and the argument is implicitly convertible
    to the parameter's type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a member has a form with a variable number of arguments, then evaluate them
    and eliminate non-applicable forms.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the remaining set, apply the rules for finding the best match. A more specific
    parameter is better than less specific. This means, for instance, that a derived
    class, which is more specific, is better than a base class. Also, a non-generic
    parameter is more specific than a generic parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similar to method overloading but with slightly different syntax and semantics
    is operator overloading, which we will look at next.
  prefs: []
  type: TYPE_NORMAL
- en: Operator overloading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Operator overloading allows us to provide user-defined functionality to an operator
    with respect to a particular type. A type can provide a custom implementation
    for an overloadable operator when one or both of the operands are of that type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are a few important points to consider while implementing operator
    overloading:'
  prefs: []
  type: TYPE_NORMAL
- en: The `operator` keyword is used to declare an operator. Such methods must be
    `public` and `static`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The assignment operators cannot be overloaded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parameters of an overloaded operator method should not use the `ref`, `in`,
    or `out` modifiers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We cannot change the operator precedence via operator overloading.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We cannot change the number of operands required by an operator. However, an
    overloaded operator can ignore an operand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The C# language has unary, binary, and ternary operators. However, only operators
    of the first two categories can be overloaded. Let's begin by learning how binary
    operators can be overloaded.
  prefs: []
  type: TYPE_NORMAL
- en: Overloading a binary operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At least one of the arguments of a binary operator must be of type `T` or `T?`,
    where `T` is the type that defines the operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following type for which we want to overload operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a very simple implementation for complex numbers, with just two properties
    for the real and imaginary parts. We want to be able to do arithmetic operations
    such as addition and subtraction, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To do so, we must overload the `+` and `-` binary operators as follows (the
    parts of the `Complex` structure shown previously are omitted for simplicity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We might also want to be able to do object comparison. In this case, we need
    to overload the `==`, `!=`, `<`, `>`, `<=`, or `>=` operators or a combination
    of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following listing, you can see the implementation of the `==` and `!=`
    operators for the `Complex` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When overloading the comparison operators, you must implement them in pairs,
    as mentioned:'
  prefs: []
  type: TYPE_NORMAL
- en: If you overload `==` or `!=`, you must overload them both.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you overload `<` or `>`, you must overload them both.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you overload `=<` or `>=`, you must overload them both.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moreover, when you overload `==` and `!=`, you also need to override the `System.Object`
    virtual methods, `Equals()` and `GetHashCode()`.
  prefs: []
  type: TYPE_NORMAL
- en: Overloading a unary operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The single argument of a unary operator must be either `T` or `T?` where `T`
    is the type that defines the operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will exemplify again using the `Complex` type and the increment and decrement
    operators. These can be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In this implementation, the increment (`++`) operator and the decrement (`--`)
    operator alter only the real part of a complex number and return a new complex
    number. We can then write the following code to show how these operators can be
    used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important to note that when calling the increment or decrement operators,
    the operated object is assigned a new value. For reference types, that means a
    reference to a new object is assigned. As a result, the increment and decrement
    operators should not modify the original object and return a reference to it.
    Let''s understand the reason by implementing the `Complex` type as a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This implementation is wrong because it will affect all of the references to
    the modified object. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Initially, `c1` and `c2` are equal. We then increment the value of `c1` and
    because of the implementation of the `++` operator in the `Complex` class, both
    `c1` and `c2` will have the same value. The correct implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Although this is not a problem with value types, you should get into the habit
    of returning a new object from unary operators.
  prefs: []
  type: TYPE_NORMAL
- en: SOLID principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The principles we discussed in this chapter—abstraction, encapsulation, inheritance,
    and polymorphism– are the pillars of object-oriented programming. However, these
    are not the only principles that developers employ when doing object-oriented
    programming. There are many other principles but some that are worth mentioning
    at this point are the five known by the acronym **SOLID**. These were initially
    introduced by Robert C. Martin in 2000, in a paper called *Design Principles and
    Design Patterns*. The term SOLID was later coined by Michael Feathers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**S** stands for the **Single responsibility principle** that states that a
    module or a class should have a single responsibility, where responsibility is
    defined as a reason to change. When a class provides functionalities that may
    change at different times and for different reasons, it means those functionalities
    do not belong together and should be separated into different classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**O** stands for the **Open-close principle** that states that a module, class,
    or function should be opened for extensions but closed for modifications. That
    is, when functionalities need to change, those changes should not affect the existing
    implementation. Inheritance is the typical way to achieve this, as derived classes
    can either add more functionalities or specialize existing ones. Extension methods
    is another technique available in C#.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**L** stands for the **Liskov substitution principle** that states that if
    S is a sub-type of T, then objects of T may be substituted with objects of S without
    disrupting the functionality of the program. This principle is named after Barbara
    Liskov, who first introduced it. To understand the principle, let''s consider
    a system that handles shapes. We may have an ellipse class with methods to change
    its two foci. When implementing a circle, we might be tempted to specialize the
    ellipse class because, mathematically, the circle is a special ellipse with the
    two foci being equal. In this case, the circle has to set the two foci to the
    same value in both these two methods. That is something a client of these classes
    does not expect and therefore an ellipse may not be substituted for a circle.
    To avoid violating the principle, we would have to implement the circle without
    deriving from the ellipse. To make sure you follow this principle, you should
    define preconditions and post-conditions for all methods. The preconditions must
    hold true before the method is executed and post-conditions must hold true after
    its execution. When specializing a method, you can only replace its preconditions
    with weaker ones and post-conditions with stronger ones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I** stands for the **Interface segregation principle** and says that smaller,
    specific interfaces are to be preferred to larger and more general ones. The reason
    for this is that a client may only need to implement those functionalities that
    it needs and nothing more. By separating responsibilities, this principle facilitates
    composition and decoupling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**D** stands for the **Dependency inversion principle** and is the last in
    the list. This principle states that software entities should depend on abstractions
    and not on implementations. High-level modules should not depend on low-level
    modules; instead, they should both depend on abstractions. Moreover, abstractions
    should not depend on concrete implementations but the other way around. Dependency
    on implementations introduces tight coupling, making it hard to replace components.
    However, dependency on high-level abstractions decouples modules and facilitates
    flexibility and reusability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These five principles enable us to write code that is simpler and more understandable,
    which also makes it easier to maintain. At the same time, they make code more
    reusable and also easier to test.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we learned about the core concepts of object-oriented programming:
    abstraction, encapsulation, inheritance, and polymorphism. We learned about the
    language functionalities that enable them, such as inheritance, virtual members,
    abstract types and members, sealed types and members, interfaces, and method and
    operator overloading. At the end of this chapter, we briefly discussed other object-oriented
    principles known as SOLID.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about another programming paradigm in C#—generic
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: Test what you learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is object-oriented programming and what are its core principles?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits of encapsulation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is inheritance and what types of inheritance are supported in C#?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are virtual methods? What about overridden methods?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you prevent a virtual member from being overridden in a derived class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are abstract classes and what are their features?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an interface and what kinds of members can it contain?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What types of polymorphism exist?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an overloaded method? How do you overload operators?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the SOLID principles?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Design Principles and Design Patterns by Robert C. Martin*: [https://web.archive.org/web/20150906155800/http://www.objectmentor.com/resources/articles/Principles_and_Patterns.pdf](https://web.archive.org/web/20150906155800/http://www.objectmentor.com/resources/articles/Principles_and_Patterns.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
