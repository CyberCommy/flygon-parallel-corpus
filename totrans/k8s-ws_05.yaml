- en: 5\. Pods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces the concept of pods and teaches how to properly configure
    and deploy them. We will begin by creating a simple pod with your application
    container running in it. We will explain what the different aspects of pod configuration
    mean and decide which configuration to use based on your application or use case.
    You will be able to define resource allocation requirements and limits for pods.
    We will then move on to see how we can debug the pod, check the logs, and make
    changes to it when needed. Some more useful tools for managing faults in pods,
    such as liveness and readiness probes and restart policies, are also covered in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to use kubectl to interact with the
    Kubernetes API. In this chapter and the upcoming chapters, we will use that knowledge
    to interact with the API to create various types of Kubernetes objects.
  prefs: []
  type: TYPE_NORMAL
- en: In a Kubernetes system, many entities represent the state of the cluster and
    what the cluster's workload looks like. These entities are known as Kubernetes
    objects. Kubernetes objects describe various things, for example, what containers
    will be running in the cluster, what resources they will be using, how those containers
    will interact with each other, and how they will be exposed to the outer world.
  prefs: []
  type: TYPE_NORMAL
- en: A pod is the basic building block of Kubernetes, and it can be described as
    the basic unit of deployment. Just like we define a process as a program in execution,
    we can define a pod as a running process in the Kubernetes world. Pods are the
    smallest unit of replication in Kubernetes. A pod can have any number of containers
    running in it. A pod is basically a wrapper around containers running on a node.
    Using pods instead of individual containers has a few benefits. For example, containers
    in a pod have shared volumes, Linux namespaces, and cgroups. Each pod has a unique
    IP address and the port space is shared by all the containers in that pod. This
    means that different containers inside a pod can communicate with each other using
    their corresponding ports on localhost.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, we should use multiple containers in a pod only when we want them to
    be managed and located together in the Kubernetes cluster. For example, we may
    have a container running our application and another container that fetches logs
    from the application container and forwards them to some central storage. In this
    case, we would want both of our containers to stay together, to share the same
    IP so that they can communicate over localhost, and to share the same storage
    so that the second container can read the logs our application container is generating.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover what a pod is, how it works, and how to define
    its pod spec, which describes the state of a pod. We will go through different
    phases of the life cycle of a pod and learn how to control the pods using health
    checks or probes. Let's begin by learning how a pod is configured.
  prefs: []
  type: TYPE_NORMAL
- en: Pod Configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to be able to successfully configure a pod, we must first be able
    to read and understand a pod configuration file. Here is an example pod configuration
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can break down the configuration of a pod into four main components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`apiVersion`: Version of the Kubernetes API we are going to use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kind`: The kind of Kubernetes object we are trying to create, which is a `Pod`
    in this case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`metadata`: Metadata or information that uniquely identifies the object we''re creating.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spec`: Specification of our pod, such as container name, image name, volumes,
    and resource requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apiVersion`, `kind`, and `metadata` apply to all types of Kubernetes objects
    and are required fields. `spec` is also a required field; however, its layout
    is different for different types of objects.'
  prefs: []
  type: TYPE_NORMAL
- en: The following exercise demonstrates how to use such a pod configuration file
    to create a simple pod.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.01: Creating a Pod with a Single Container'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we aim to create our first simple pod that runs a single
    container. To complete this exercise, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `single-container-pod.yaml` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command in Terminal to create a pod with the preceding configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The output indicates that the pod has been created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify that the pod was created by getting the list of all the pods using this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have created our first pod, let''s look into it in more detail.
    To do that, we can describe the pod we just created using the following command
    in Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1: Describing first-pod'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_05_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.1: Describing first-pod'
  prefs: []
  type: TYPE_NORMAL
- en: The output shows various details about the pod we just created. In the following
    sections, we shall go through the highlighted sections of the preceding output
    to find out more about the pod that's running.
  prefs: []
  type: TYPE_NORMAL
- en: Name
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This field states the name of the pod, and it is also sometimes referred to
    as the pod ID. Pod names are unique in a particular namespace. A pod name can
    be a maximum of 253 characters long. The characters allowed in a pod name are
    numerals (0-9), lowercase letters (a-z), hyphens (-), and dots (.).
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the second line in the output shown in *Figure 5.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It is the same as the one we mentioned in our YAML configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Kubernetes supports namespaces to create multiple virtual clusters within the
    same physical cluster. We may need to use namespaces if we want to provide separate
    environments to our different teams working on the same cluster. Namespaces also
    help in scoping the object names. For example, you cannot have two pods with the
    same name within the same namespace. However, it''s possible to have two pods
    with the same name in two different namespaces. Now, consider the second line
    in the output shown in *Figure 5.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can either temporarily change the namespace of the request by passing the
    `--namespace` argument for a particular kubectl command, or we can update the
    kubectl config to change the namespace for all subsequent kubectl commands. To
    create a new namespace, we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: There are two ways to create pods in different namespaces – by using a CLI command,
    or by specifying the namespace in the pod configuration. The following exercises
    demonstrate how you can create pods in different namespaces to reap the benefits
    of namespaces that were mentioned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.02: Creating a Pod in a Different Namespace by Specifying the Namespace
    in the CLI'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will create a pod in a namespace other than `default`.
    We will do that using the same pod configuration from *Exercise 5.01*, *Creating
    a Pod with a Single Container*, by specifying the namespace in the command argument.
    Follow these steps to complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to view all the available namespaces in our Kubernetes
    cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following list of namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The output shows all the namespaces in our Kubernetes cluster. The `default`
    namespace is, as the word implies, the default namespace for all Kubernetes objects
    created without any namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to create the pod with the `single-container-pod.yaml`
    pod configuration but in a different namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you create a pod in a particular namespace, you can only view it by switching
    to that namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify that the pod was created in the `kube-public` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The output here shows that we have successfully created the pod in the `kube-public`
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: The next exercise demonstrates how to create a pod in different namespace based
    on a YAML file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.03: Creating a Pod in a Different Namespace by Specifying the Namespace
    in the Pod Configuration YAML file'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we shall add a line to the YAML configuration file to specify
    that all pods created using this file use a specified namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to view all the available namespaces in our Kubernetes
    cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following list of namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a file named `single-container-pod-with-namespace.yaml` with the
    following configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to create a pod with the `single-container-pod-with-namespace.yaml`
    pod configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that the pod was created in the `kube-public` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following list of pods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The output shows that the new pod we created occupies the `kube-public` namespace.
    Any other pods created using the `single-container-pod-with-namespace.yaml` pod
    configuration will occupy the same namespace.
  prefs: []
  type: TYPE_NORMAL
- en: In the following exercise, we shall change the default kubectl namespace so
    that all pods without a defined namespace take our newly defined namespace instead
    of `default`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.04: Changing the Namespace for All Subsequent kubectl Commands'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will change the namespace for all subsequent kubectl commands
    from `default` to `kube-public`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to view all the available namespaces in our Kubernetes
    cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following list of namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to change the namespace for all subsequent requests
    by modifying the current context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to list all the pods in the `kube-public` namespace
    without using the `namespace` argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following list of pods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The output shows that the preceding command lists all the pods that we have
    created in the `kube-public` namespace. We saw in *Exercise 5.01*, *Creating a
    Pod with a Single Container*, that the `kubectl get pods` command shows pods in
    the default namespace. But here, we get results from the `kube-public` namespace
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this step, we will undo the changes so that it doesn''t affect the upcoming
    exercises in this chapter. We will change the default namespace to `default` again
    to avoid any confusion:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we have seen how to change and reset the default namespace
    of the context.
  prefs: []
  type: TYPE_NORMAL
- en: Node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you have learned in earlier chapters, nodes are the various machines running
    in our cluster. This field reflects the node in the Kubernetes cluster where this
    pod was running. Knowing what node a pod is running on can help us with debugging
    issues with that pod. Observe the sixth line of the output shown in *Figure 5.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can list all the nodes in our Kubernetes cluster by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, there''s only one node in our cluster because we are using Minikube
    for these exercises:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If we have more than one node in our cluster, we can configure our pod to run
    on a particular node by adding the following `nodeName` field to the configuration,
    as seen in the sixth line in the previous spec.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In a production environment, `nodeName` is typically not used for assigning
    a certain pod to run on the desired node. In the next chapter, we will learn about
    `nodeSelector`, which is a better way to control which node the pod gets assigned
    to.
  prefs: []
  type: TYPE_NORMAL
- en: Status
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This field tells us the status of the pod so that we can take appropriate action,
    such as starting or stopping a pod as required. While this demonstration shows
    one of the ways to get the status of the pod, in actual practice, you would want
    to automate actions based on the pod status. Consider the tenth line of the output
    shown in *Figure 5.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This states that the current status of the pod is `Running`. This field reflects
    which phase of its life cycle a pod is in. We will talk about various phases of
    a pod's life cycle in the next section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, we saw that we can bundle various containers inside
    a pod. This field lists all the containers that we have created in this pod. Consider
    the output field from line 12 onwards in *Figure 5.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2: Containers field from the describe command'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_05_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.2: Containers field from the describe command'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have only one in this case. We can see that the name and the image of the
    container are the same as we specified in the YAML configuration. The following
    is a list of the other fields that we can set:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Image`: Name of the Docker image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Args`: The arguments to the entry point for the container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Command`: The command to run on the container once it starts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ports`: A list of ports to expose from the container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Env`: A list of environment variables to be set in the container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resources`: The resource requirements of the container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following exercise, we shall create a container using a simple command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.05: Using CLI Commands to Create a Pod Running a Container'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will create a pod that will run a container by running
    a command.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a file named `pod-with-container-command.yaml` with the
    following pod configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to create the pod using the configuration defined
    in the `pod-with-container-command.yaml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The YAML file we created in the previous step instructs the pod to start a
    container with an Ubuntu image and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This command should print a dot (`.`) character on a new line every 5 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the logs of this pod to verify that it''s doing what it''s expected
    to do. To check the logs of a pod, we can use the `kubectl logs` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3: Following logs for command-pod'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_05_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.3: Following logs for command-pod'
  prefs: []
  type: TYPE_NORMAL
- en: In the log, which keeps updating periodically, we see a dot (`.`) character
    printed on a new line every 5 seconds. Thus, we have successfully created the
    desired container.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `-f` flag is to follow the logs on the container. That is, the log keeps
    updating in real-time. If we skip that flag, we will see the logs without following
    them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, we shall run a container that opens up a port, which is
    something that you would have to do regularly to make the container accessible
    to the rest of your cluster or the internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.06: Creating a Pod Running a Container That Exposes a Port'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will create a pod that runs a container that will expose
    a port that we can access from outside the pod.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a file named `pod-with-exposed-port.yaml` with the following
    pod configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to create the pod using the `pod-with-exposed-port.yaml`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This pod should create a container and expose its port `80`. We have configured
    the pod to run a container with an `nginx` image, which is a popular web server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will forward port `80` from the pod to localhost:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This will expose port `80` from the pod to localhost port `80`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We will need to keep this command running in one terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can simply enter either `http://localhost` or `http://127.0.0.1` in
    the address bar of the browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Alternatively, we can run the following command and see the HTML source code
    of the default index page in the response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4: Getting the HTML source using curl'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_05_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.4: Getting the HTML source using curl'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s verify that the pod is actually receiving the request by checking
    the logs using the `kubectl logs` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5: Checking the logs for the nginx pod'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_05_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.5: Checking the logs for the nginx pod'
  prefs: []
  type: TYPE_NORMAL
- en: The log shows that our container that is running an `nginx` image is receiving
    our HTTP request to localhost and responding as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also define the minimum and maximum resource allocation for our containers.
    This is useful for managing the resources used by our deployments. This can be
    achieved using the following two fields in the YAML configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`limits`: Describes the maximum amount of resources allowed for this container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`requests`: Describes the minimum amount of resources required for this container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use these fields to define the minimum and maximum memory and CPU resources
    for our containers. The CPU resource is measured in CPU units. 1 CPU unit means
    that the container has access to 1 logical CPU core.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, we shall create a container with defined resource requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.07: Creating a Pod Running a Container with Resource Requirements'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will create a pod with a container that has resource requirements.
    First of all, let''s see how we can configure the container''s resource requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `pod-with-resource-requirements.yaml` with a pod configuration
    that specifies both `limits` and `requests` for memory and CPU resources, as shown
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In this YAML file, we define the minimum memory requirement for the container
    to be 64 MB and the maximum memory that the container can occupy to be 128 MB.
    If the container tries to allocate more than 128 MB of memory, it will be killed
    with a status of `OOMKilled`.
  prefs: []
  type: TYPE_NORMAL
- en: The minimum CPU requirement for CPU is 0.5 (which can also be understood as
    500 milli-CPUs and can be written as `500m` instead of `0.5`) and the container
    will only be allowed to use a maximum of 1 CPU unit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will create the pod that uses this YAML configuration with the `kubectl
    create` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s make sure the pod is created with the correct resource requirements.
    Check the pod definitions using the `describe` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6: Describing resource-requirements-pod'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_05_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.6: Describing resource-requirements-pod'
  prefs: []
  type: TYPE_NORMAL
- en: The highlighted fields in the output show that the pod has been assigned the
    `limits` and `requests` sections that we stated in the YAML file.
  prefs: []
  type: TYPE_NORMAL
- en: What happens if we define unrealistic resource requirements for our pod? Let's
    explore that in the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.08: Creating a Pod with Resource Requests That Can''t Be Met by
    Any of the Nodes'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will create a pod with large resource requests that are
    too big for the nodes in the cluster and see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `pod-with-huge-resource-requirements.yaml` with the following
    pod configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In this YAML file, we define the minimum requirement to be 64 GB of memory and
    500 CPU cores. It is unlikely that the machine that you are running this exercise
    on would meet those requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will create the pod that uses this YAML configuration with the `kubectl
    create` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see what''s going on with our pod. Get its status using the `kubectl
    get` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7: Getting the status of huge-resource-requirements-pod'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_05_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.7: Getting the status of huge-resource-requirements-pod'
  prefs: []
  type: TYPE_NORMAL
- en: We see that the pod has been in the `Pending` state for almost a minute. That's unusual!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s dig deeper and describe the pod using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8: Describing huge-resource-requirements-pod'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_05_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.8: Describing huge-resource-requirements-pod'
  prefs: []
  type: TYPE_NORMAL
- en: Let's focus on the last line of the output. We can clearly see that there's
    a warning stating that the Kubernetes controller couldn't find any nodes that
    satisfy the CPU and memory requirements of the pod. Hence, the pod scheduling
    has failed.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, pod scheduling works on the basis of resource requirements. A
    pod will only be scheduled on a node that satisfies all its resource requirements.
    If we do not specify a resource (memory or CPU) limit, there's no upper bound
    on the number of resources a pod can use.
  prefs: []
  type: TYPE_NORMAL
- en: This poses the risk of one bad pod consuming too much CPU or allocating too
    much memory that impacts the other pods running in the same namespace/cluster.
    Hence, it's a good idea to add resource requests and limits to the pod configuration
    in a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier in the chapter, a pod can run more than one container.
    In the following exercise, we will create a pod with more than one container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.09: Creating a Pod with Multiple Containers Running inside It'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will create a pod with multiple containers. For that,
    we can use the configuration that we used in the previous section, with the only
    difference being that the `containers` field will now contain more than one container
    spec. Follow these steps to complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `multiple-container-pod.yaml` with the following pod configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will create a pod that uses the preceding YAML configuration with
    the `kubectl create` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will describe the pod and see what containers it is running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9: Describing multi-container-pod'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_05_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.9: Describing multi-container-pod'
  prefs: []
  type: TYPE_NORMAL
- en: As can be seen from the preceding output, we have two containers running in
    a single pod. Now, we need to make sure we can access the logs from either container.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can specify the container name to get the logs for a particular container
    running in a pod, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, to see the logs for a second container that is printing out dots
    on a new line every 5 seconds, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10: The logs for second-container inside multi-container-pod'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_05_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.10: The logs for second-container inside multi-container-pod'
  prefs: []
  type: TYPE_NORMAL
- en: The output we see here is similar to *Exercise 5.05*, *Using CLI Commands to
    Create a Pod Running a Container*, as we have essentially used a similar container
    as we defined there.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we have created a pod with multiple containers and accessed the logs of
    the desired container.
  prefs: []
  type: TYPE_NORMAL
- en: Life Cycle of a Pod
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how to run a pod and how to configure it for our use cases,
    in this section, we will talk about the life cycle of a pod to understand how
    it works in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Phases of a Pod
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every pod has a pod status that tells us what stage of its life cycle a pod
    is in. We can see the pod status by running the `kubectl get` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: For our first pod, named `first-pod`, we see that the pod is in the `Running`
    state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what the different states that a pod can have in its life cycle
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Pending`: This means that the pod has been submitted to the cluster, but the
    controller hasn''t created all its containers yet. It may be downloading images
    or waiting for the pod to be scheduled on one of the cluster nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Running`: This state means that the pod has been assigned to one of the cluster
    nodes and at least one of the containers is either running or is in the process
    of starting up.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Succeeded`: This state means that the pod has run, and all of its containers
    have been terminated with success.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Failed`: This state means the pod has run and at least one of the containers
    has terminated with a non-zero exit code, that is, it has failed to execute its commands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Unknown`: This means that the state of the pod could not be found. This may
    be because of the inability of the controller to connect with the node that the
    pod was assigned to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `get pod` command cannot get evicted or deleted pods. To do that, you can
    use the `--show-all` flag, but it has been deprecated since Kubernetes v1.15.
  prefs: []
  type: TYPE_NORMAL
- en: Probes/Health Checks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A probe is a health check that can be configured to check the health of the
    containers running in a pod. A probe can be used to determine whether a container
    is running or ready to receive requests. A probe may return the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Success`: The container passed the health check.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Failure`: The container failed the health check.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Unknown`: The health check failed for unknown reasons.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of Probes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following types of probes are available for us to use.
  prefs: []
  type: TYPE_NORMAL
- en: Liveness Probe
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a health check that's used to determine whether a particular container
    is running or not. If a container fails the liveness probe, the controller will
    try to restart the pod on the same node according to the restart policy configured
    for the pod.
  prefs: []
  type: TYPE_NORMAL
- en: It's a good idea to specify a liveness probe when we want the container to be
    terminated and restarted when a particular check fails.
  prefs: []
  type: TYPE_NORMAL
- en: Readiness Probe
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a health check that's used to determine whether a particular container
    is ready to receive requests or not. How we define the readiness of a container
    depends largely on the application running inside the container.
  prefs: []
  type: TYPE_NORMAL
- en: For example, for a container serving a web application, readiness may mean that
    the container has loaded all static assets, established a connection with the
    database, started the webserver, and opened a specific port on the host to start
    serving requests. On the other hand, for a container serving some data, the readiness
    probe should succeed only when it has loaded all the data from disk and is ready
    to start serving the requests for that data.
  prefs: []
  type: TYPE_NORMAL
- en: If a container fails its readiness probe, the Kubernetes controller will ensure
    that the pod doesn't receive any requests. If a container specifies a readiness
    probe, its default state will be `Failure` until the readiness probe succeeds.
    The container will start receiving requests only after the readiness probe returns
    with the `Success` state. If no readiness probe is configured, the container will
    start receiving requests as soon as it starts.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration of Probes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a bunch of generic fields we can use to configure the probes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11: Table showing configuration fields for probes'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_05_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.11: Table showing configuration fields for probes'
  prefs: []
  type: TYPE_NORMAL
- en: Implementation of Probes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Probes (liveness or readiness) can be implemented by passing a command to the
    container, getting it to fetch some resources, or trying to connect to it, as
    we shall see in this section. We can use different implementations for liveness
    and readiness probes within the same container.
  prefs: []
  type: TYPE_NORMAL
- en: Command Probe
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the command implementation of a probe, the controller will get the container
    to execute the specified command in order to perform the probe on the container.
    For this implementation, we use the `command` field. This field specifies the
    command to execute in order to perform the probe on the container. It can either
    be a string or an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how liveness and readiness probe configuration
    can be used in the container spec:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: HTTP Request Probe
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this type of probe, the controller will send a GET HTTP request to the given
    address (host and port) to perform the probe on the container. It's possible to
    set the custom HTTP headers to be sent in the probe request.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can set the following fields to configure an HTTP request probe:'
  prefs: []
  type: TYPE_NORMAL
- en: '`host`: Hostname to which the request will be made. It defaults to the pod
    IP address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path`: Path to make the request to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`port`: Name or number of the port to make the request to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`httpHeaders`: Custom headers to be set in the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scheme`: Scheme to use while making the request. The default value is HTTP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s an example of an HTTP request probe for liveness and readiness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: TCP Socket Probe
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this implementation of a probe, the controller will try to establish a connection
    on the given host and the specified port number. We can use the following two
    fields for this probe:'
  prefs: []
  type: TYPE_NORMAL
- en: '`host`: Hostname to which the connection will be established. It defaults to
    the pod IP address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`port`: Name or number of the port to connect to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s an example of a TCP socket probe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Restart Policy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can specify `restartPolicy` in the pod specification to instruct the controller
    about the conditions required to restart the pod. The default value of `restartPolicy`
    is `Always`. It can take the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Always`: Always restart the pod when it terminates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnFailure`: Restart the pod only when it terminates with failure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Never`: Never restart the pod after it terminates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we want the pod to crash and restart when it has some issues or becomes unhealthy,
    we should set the restart policy to either `Always` or `OnFailure`.
  prefs: []
  type: TYPE_NORMAL
- en: In the following exercise, we shall create a liveness probe with the command
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.10: Creating a Pod Running a Container with a Liveness Probe and
    No Restart Policy'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will create a pod with a liveness probe and no restart
    policy. Not specifying a restart policy for a pod means that the default policy
    of `Always` will be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `liveness-probe.yaml` with the following pod configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'This pod configuration means that there will be a container created from an
    Ubuntu image and the following command will be run once it starts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command creates an empty file at path `/tmp/live`, sleeps for
    30 seconds, deletes the `/tmp/live` file, and then sleeps for 10 minutes before
    terminating with success.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have a liveness probe that executes the following command every 5
    seconds with an initial delay of 5 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to create the pod using `liveness-probe.yaml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'When the container starts, the liveness probe will succeed because the command
    will execute successfully. Now, let''s wait for at least 30 seconds and run the
    `describe` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12: Describing liveness-probe: first failure'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_05_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.12: Describing liveness-probe: first failure'
  prefs: []
  type: TYPE_NORMAL
- en: In the last line, which is highlighted, we can see that the liveness probe has
    failed for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s wait for a few more seconds until the probe has failed three times and
    run the same command again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13: Describing liveness-probe: after three failures'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_05_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.13: Describing liveness-probe: after three failures'
  prefs: []
  type: TYPE_NORMAL
- en: The last two highlighted lines in the output tell us that the liveness probe
    has failed three times. And now, the pod will be killed and restarted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will verify that the pod has been restarted at least once using the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: This output shows that the pod has been restarted upon failing the liveness
    probe.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now take a look at what happens if we set the restart policy to `Never`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.11: Creating a Pod Running a Container with a Liveness Probe and
    a Restart Policy'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will use the same pod configuration from the last exercise,
    the only difference being that the `restartPolicy` field will be set to `Never`.
    Follow these steps to complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `liveness-probe-with-restart-policy.yaml` with the following pod configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to create the pod using `liveness-probe.yaml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s wait for around one minute and run the `describe` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14: Describing liveness-probe-never-restart'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_05_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.14: Describing liveness-probe-never-restart'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, in the last two highlighted lines, the controller will only kill
    the container and will never attempt to restart it, respecting the restart policy
    specified in the pod specification.
  prefs: []
  type: TYPE_NORMAL
- en: In the following exercise, we shall take a look at the implementation of a readiness probe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.12: Creating a Pod Running a Container with a Readiness Probe'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will create a pod with a container that has a readiness
    probe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `readiness-probe.yaml` with the following pod configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding pod configuration specifies that there will be a container created
    from an Ubuntu image and the following command will be run once it starts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command sleeps for 30 seconds, creates an empty file at `/tmp/ready`,
    and then sleeps for 10 minutes before terminating with success.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have a readiness probe that executes the following command every 5
    seconds with an initial delay of 10 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to create the pod using `readiness-probe.yaml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: When the container starts, the default value of the readiness probe will be
    `Failure`. It will wait for 10 seconds before executing the probe for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the state of the pod:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the pod is not ready yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try to find more information about this pod using the `describe`
    command. If we wait for more than 10 seconds after the container starts, we will
    see that the readiness probe starts failing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15: Describing readiness-probe'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_05_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.15: Describing readiness-probe'
  prefs: []
  type: TYPE_NORMAL
- en: That output tells us that the readiness probe has failed once already. If we
    wait for a while and run that command again, we will see that the readiness probe
    keeps failing until 30 seconds have elapsed since the starting time of the container.
    After that, the readiness probe will start succeeding since a file will be created
    at `/tmp/ready`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the state of the pod again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the probe has succeeded, and the pod is now in the `Ready` state.
  prefs: []
  type: TYPE_NORMAL
- en: Best Practices While Using Probes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An incorrect use of probes will not help you achieve the intended purpose or
    may even break a pod. Follow these practices to make proper use of probes:'
  prefs: []
  type: TYPE_NORMAL
- en: For liveness probes, `initialDelaySeconds` should be significantly larger than
    the time it takes for the application to start up. Otherwise, the container is
    likely to get stuck in a restart loop where it keeps failing the liveness probe
    and hence keeps on getting restarted by the controller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For readiness probes, `initialDelaySeconds` could be small because we want to
    enable the traffic to the pod as soon as the container is ready, and polling the
    container more frequently while it's starting up doesn't cause any harm in most
    cases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For readiness probes, we should be careful with setting `failureThreshold` to
    make sure our readiness probe doesn't give up prematurely in case of temporary
    outages or issues with the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Activity 5.01: Deploying an Application in a Pod'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine you are working with a team of developers who have built an awesome
    application that they want you to deploy in a pod. The application has a process
    that starts up and takes approximately 20 seconds to load all the required assets.
    Once the application starts up, it's ready to start receiving requests. If, for
    some reason, the application crashes, you would want the pod to restart itself
    as well. They have given you the task of creating the pod using a configuration
    that will satisfy these needs for the application developers in the best way possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have provided a pre-made application image to emulate the behavior of the
    application mentioned above. You can get it by using this line in your pod spec:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, you would want to create this pod in a different namespace to keep
    it separate from the rest of the stuff that you created during the exercises.
    So, feel free to create a namespace and create the pod in that namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the high-level steps to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new namespace for your pod.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a pod configuration that's suitable for the application requirements.
    Ensure that you use an appropriate namespace, restart policy, readiness and liveness
    probes, and container image given by application developers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a pod using the configuration you've just created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the pod is running as per the requirements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at the following address: [https://packt.live/304PEoD](https://packt.live/304PEoD).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have explored various components of pod configuration and
    learned when to use what. We should now be able to create a pod and choose the
    right values of various fields in the pod configuration according to the needs
    of your application. This ability puts us in a position where we can use our strong
    understanding of this essential, basic building block and extend it to develop
    a full-fledged application that's deployed reliably.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss how we can add labels and arbitrary metadata
    to pods and use them to identify or search for pods. That will help us to organize
    our pods as well as choose a subset of them when required.
  prefs: []
  type: TYPE_NORMAL
