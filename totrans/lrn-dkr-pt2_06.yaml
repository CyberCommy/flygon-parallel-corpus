- en: Chapter 6. Running Services in a Container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've reached so far, brick by brick, laying a strong and stimulating foundation
    on the fast-evolving Docker technology. We talked about the important building
    blocks of the highly usable and reusable Docker images. Further on, you can read
    the easy-to-employ techniques and tips on how to store and share Docker images
    through a well-designed storage framework. As usual, images will have to go through
    a series of verifications, validations, and refinements constantly in order to
    make them more right and relevant for the aspiring development community. In this
    chapter, we are going to take our learning to the next level by describing the
    steps towards creating a small web server, run the same inside a container, and
    connect to the web server from the external world.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Container networking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container as a Service** (**CaaS**)—building, running, exposing, and connecting
    to container services'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing and retrieving container ports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding a container to a specific IP address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auto-generating the Docker host port
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Port binding using the `EXPOSE` and `-P` options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A brief overview of container networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like any computing node, the Docker containers need to be networked, in order
    to be found and accessible by other containers and clients. In a network, generally,
    any node is being identified through its IP address. Besides, the IP address is
    a unique mechanism for any client to reach out to the services offered by any
    server node. Docker internally uses Linux capabilities to provide network connectivity
    to containers. In this section, we are going to learn about the container's IP
    address assignment and the procedure to retrieve the container's IP address.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Docker engine seamlessly selects and assigns an IP address to a container
    with no intervention from the user, when it gets launched. Well, you might be
    puzzled on how Docker selects an IP address for a container, and this puzzle is
    answered in two parts, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: During the installation, Docker creates a virtual interface with the name `docker0`
    on the Docker host. It also selects a private IP address range, and assigns an
    address from the selected range to the `docker0` virtual interface. This selected
    IP address is always outside the range of the Docker host IP address in order
    to avoid an IP address conflict.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Later, when we spin up a container, the Docker engine selects an unused IP address
    from the IP address range selected for the `docker0` virtual interface. Then,
    the engine assigns this IP address to the freshly spun container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Docker, by default, selects the IP address `172.17.42.1/16`, or one of the
    IP addresses that is within the range `172.17.0.0` to `172.17.255.255`. Docker
    will select a different private IP address range if there is a direct conflict
    with the `172.17.x.x` addresses. Perhaps, the good old `ifconfig` (the command
    to display the details of the network interfaces) comes in handy here to find
    out the IP address assigned to the virtual interface. Let''s just run `ifconfig`
    with `docker0` as an argument, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The second line of the output will show the assigned IP address and its netmask:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Apparently, from the preceding text, `172.17.42.1` is the IP address assigned
    to the `docker0` virtual interface. The IP address `172.17.42.1` is one of the
    addresses in the private IP address range from `172.17.0.0` to `172.17.255.255`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s now imperative that we learn how to find the IP address assigned to a
    container. The container should be launched in an interactive mode using the `-i`
    option. Of course, we can easily find the IP by running the `ifconfig` command
    within the container, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ifconfig` command will display the details of all the interfaces in the
    Docker container, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Evidently, the preceding output of the `ifconfig` command shows that the Docker
    engine has virtualized two network interfaces for the container, which are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one is an `eth0` (Ethernet) interface for which the Docker engine
    assigned the IP address `172.17.0.12`. Obviously, this address also falls within
    the same IP address range of the `docker0` virtual interface. Besides, the address
    assigned to the `eth0` interface is used for intra-container communication and
    host-to-container communication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second interface is the `lo` (Loopback) interface for which the Docker engine
    assigned the loopback address `127.0.0.1`. The loopback interface is used for
    local communication within a container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy, isn't it? However, the retrieval of an IP address gets complicated when
    the container is launched in the detached mode, using the `-d` option in the `docker
    run` subcommand. The primary reason for this complication in the detached mode
    is that there is no shell prompt to run the `ifconfig` command. Fortunately, Docker
    provides a `docker inspect` subcommand, which is as handy as a Swiss army knife,
    and allow us to dive deep into the low-level details of the Docker container or
    image. The `docker inspect` subcommand generates the requested details in the
    JSON array format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a sample run of the `docker inspect` subcommand on the interactive
    container that we previously launched. The `4b0b567b6019` container ID is taken
    from the prompt of the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This command generates quite a lot of information about the container. Here,
    we show some excerpts of the container''s network configuration from the output
    of the `docker inspect` subcommand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the network configuration lists out the following details:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bridge**: This is the bridge interface to which the container is bound'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gatewa**y: This is the gateway address of the container, which is the address
    of the bridge interface as well'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IPAddres**s: This is the IP address assigned to the container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IPPrefixLen**: This is the IP prefix length, another way of representing
    the subnet mask'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PortMapping**: This is the port mapping field, which is now being deprecated,
    and its value is always null'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ports**: This is the ports field that will enumerate all the port binds,
    which is introduced later in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no doubt that the `docker inspect` subcommand is quite convenient for
    finding the minute details of a container or an image. However, it's a tiresome
    job to go through the intimidating details and to find the right information that
    we are keenly looking for. Perhaps, you can narrow it down to the right information,
    using the `grep` command. Or even better, the `docker inspect` subcommand, which
    helps you pick the right field from the JSON array using the `--format` option
    of the `docker inspect` subcommand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notably, in the following example, we use the `--format` option of the `docker
    inspect` subcommand to retrieve just the IP address of the container. The IP address
    is accessible through the `.NetworkSettings.IPAddress` field of the JSON array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Envisaging the Container as a Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We laid a good foundation of the fundamentals of the Docker technology. In this
    section, we are going to focus on crafting an image with the HTTP service, launch
    the HTTP service inside the container using the crafted image, and then, demonstrate
    the connectivity to the HTTP service running inside the container.
  prefs: []
  type: TYPE_NORMAL
- en: Building an HTTP server image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to craft a Docker image in order to install `Apache2`
    on top of the `Ubuntu 14.04` base image, and configure a `Apache HTTP Server`
    to run as an executable, using the `ENTRYPOINT` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html "Chapter 3. Building Images"), *Building Images*, we
    illustrated the concept of the Dockerfile to craft an `Apache2` image on top of
    the `Ubuntu 14.04` base image. Here, in this example, we are going to extend this
    Dockerfile by setting the `Apache` log path and setting `Apache2` as the default
    execution application, using the `ENTRYPOINT` instruction. The following is a
    detailed explanation of the content of `Dockerfile`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to build an image using `ubuntu:14.04` as the base image, using
    the `FROM` instruction, as shown in the `Dockerfile` snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Set authors' detail using MAINTAINER Instruction
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Using one `RUN` instruction, we will synchronize the `apt` repository source
    list, install the `apache2` package, and then clean the retrieved files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the Apache log directory path using the `ENV` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the final instruction is to launch the `apache2` server using the `ENTRYPOINT`
    instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding line, you might be surprised to see the `FOREGROUND` argument.
    This is one of the key differences between the traditional and the container paradigm.
    In the traditional paradigm, the server applications are usually launched in the
    background either as a service or a daemon because the host system is a general-purpose
    system. However, in the container paradigm, it is imperative to launch an application
    in the foreground because the images are crafted for a sole purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having prescribed the image building instruction in the `Dockerfile`, now let''s
    move to the next logical step of building the image using the `docker build` subcommand
    by naming the image as `apache2`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now do a quick verification of the images using the `docker images`
    subcommand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have seen in the previous chapters, the `docker images` command displays
    the details of all the images in the Docker host. However, in order to illustrate
    precisely the images created using the `docker build` subcommand, we highlight
    the details of `apache2:latest` (the target image) and `ubuntu:14.04` (the base
    image) from the complete image list, as shown in the following output snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Having built the HTTP server image, now let's move on to the next session to
    learn how to run the HTTP service.
  prefs: []
  type: TYPE_NORMAL
- en: Running the HTTP server Image as a Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we are going to launch a container using the Apache HTTP server
    image, we crafted in the previous section. Here, we launch the container in the
    detached mode (similar to a UNIX daemon process) using the `-d` option of the
    `docker run` subcommand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Having launched the container, let''s run the `docker logs` subcommand to see
    whether our Docker container generates any output on its `STDIN` (standard input)
    or `STDERR` (standard error):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have not fully configured the Apache HTTP server; you will find the following
    warning, as the output of the `docker logs` subcommand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding warning message, it is quite evident that the IP address
    assigned to this container is `172.17.0.13`.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the HTTP service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding section, from the warning message, we found out that the IP
    address of the container is `172.17.0.13`. On a fully configured HTTP server container,
    no such warning is available, so let''s still run the `docker inspect` subcommand
    to retrieve the IP address using the container ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Having found the IP address of the container as `172.17.0.13`, let''s quickly
    run a web request on this IP address from the shell prompt of the Docker host,
    using the `wget` command. Here, we choose to run the `wget` command with `-qO-`
    in order to run in the quiet mode and also display the retrieved HTML file on
    the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are showcasing just the first five lines of the retrieved HTML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Awesome, isn't it? We got our first service running in a container, and we are
    able to reach out to our service from our Docker host.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, on a plain vanilla Docker installation, the service offered by
    one container is accessible by any other container within the Docker host. You
    can go ahead, launch a new Ubuntu container in the interactive mode, install the
    `wget` package using `apt-get`, and run the same `wget -qO - 172.17.0.13` command,
    as we did in the Docker host. Of course, you will see the same output.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing container services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have successfully launched an HTTP service and accessed the service
    from the Docker host as well as another container within the same Docker host.
    Furthermore, as demonstrated in the *Build images from containers* section of
    [Chapter 2](ch02.html "Chapter 2. Handling Docker Containers"), *Handling Docker
    Containers*, the container is able to successfully install the `wget` package
    by making a connection to the publicly available apt repository over the Internet.
    Nonetheless, the outside world cannot access the service offered by a container
    by default. At the outset, this might seem like a limitation in the Docker technology.
    However, the fact of the matter is, the containers are isolated from the outside
    world by design.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker achieves network isolation for the containers by the IP address assignment
    criteria, as enumerated:'
  prefs: []
  type: TYPE_NORMAL
- en: Assign a private IP address to the container, which is not reachable from an
    external network.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign an IP address to the container outside the host's IP network.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Consequently, the Docker container is not reachable, even from the systems that
    are connected to the same IP network as the Docker host. This assignment scheme
    also provides protection from an IP address conflict that might otherwise arise.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you might wonder how to make the services run inside a container that is
    accessible to the outside world, in other words, exposing container services.
    Well, Docker bridges this connectivity gap in a classy manner by leveraging the
    Linux `iptables` functionality under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: At the frontend, Docker provides two different building blocks to bridge this
    connectivity gap for its users. One of the building blocks is to bind the container
    port using the `-p` (publish a container's port to the host interface) option
    of the `docker run` subcommand. Another alternative is to use the combination
    of the `EXPOSE` Dockerfile instruction and the `-P` (publish all exposed ports
    to the host interfaces) option of the `docker run` subcommand.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing container ports – the -p option
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Docker enables you to publish a service offered inside a container by binding
    the container''s port to the host interface. The `-p` option of the `docker run`
    subcommand enables you to bind a container port to a user-specified or auto-generated
    port of the Docker host. Thus, any communication destined for the IP address and
    the port of the Docker host would be forwarded to the port of the container. The
    `-p` option, actually, supports the following four formats of arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<hostPort>:<containerPort>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<containerPort>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<ip>:<hostPort>:<containerPort>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<ip>::<containerPort>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, `<ip>` is the IP address of the Docker host, `<hostPort>` is the Docker
    host port number, and `<containerPort>` is the port number of the container. Here,
    in this section, we present you with the `-p <hostPort>:<containerPort>` format
    and introduce other formats in the succeeding sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to understand the port binding process better, let''s reuse the `apache2`
    HTTP server image that we crafted previously, and spin up a container using a
    `-p` option of the `docker run` subcommand. The port `80` is the published port
    of the HTTP service, and as the default behavior, our `apache2` HTTP server is
    also available on port `80`. Here, in order to demonstrate this capability, we
    are going to bind port `80` of the container to port `80` of the Docker host,
    using the `-p <hostPort>:<containerPort>` option of the `docker run` subcommand,
    as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have successfully launched the container, we can connect to our
    HTTP server using any web browser from any external system (provided it has network
    connectivity) to reach our Docker host. So far, we have not added any web pages
    to our `apache2` HTTP server image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, when we connect from a web browser, we will get the following screen,
    which is nothing but the default page that comes along with the `Ubuntu Apache2`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Publishing container ports – the -p option](graphics/7937OT_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Network Address Translation for containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we saw how a `-p 80:80` option did the magic, didn't
    it? Well, in reality, under the hood, the Docker engine achieves this seamless
    connectivity by automatically configuring the **Network Address Translation**
    (**NAT**) rule in the Linux `iptables` configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the automatic configuration of the NAT rule in Linux `iptables`,
    let''s query the Docker hosts `iptables` for its NAT entries, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The ensuing text is an excerpt from the `iptables` NAT entry, which is automatically
    added by the Docker engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding excerpt, it is quite evident that the Docker engine has
    effectively added a `DNAT` rule. The following are the details of the `DNAT` rule:'
  prefs: []
  type: TYPE_NORMAL
- en: The `tcp` keyword signifies that this `DNAT` rule applies only to the TCP transport
    protocol.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first `0.0.0.0/0` address is a meta IP address of the source address. This
    address indicates that the connection can originate from any IP address.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second `0.0.0.0/0` address is a meta IP address of the destination address
    on the Docker host. This address indicates that the connection could be made to
    any valid IP address in the Docker host.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, `dpt:80 to:172.17.0.14:80` is the forwarding instruction used to forward
    any TCP activity on port `80` of the Docker host to the IP address `172.17.0.17`,
    the IP address of our container and port `80`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, any TCP packet that the Docker host receives on port `80` will be
    forwarded to port `80` of the container.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving the container port
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Docker engine provides at least three different options to retrieve the
    containers port binding details. Here, let''s first explore the options, and then,
    move on to dissect the retrieved information. The options are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `docker ps` subcommand always displays the port binding details of a container,
    as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `docker inspect` subcommand is another alternative; however, you have to
    skim through quite a lot of details. Run the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `docker inspect` subcommand displays the port binding related information
    in three JSON objects, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ExposedPorts` object enumerates all ports that are exposed through the
    `EXPOSE` instruction in `Dockerfile`, as well as the container ports that are
    mapped using the `-p` option in the `docker run` subcommand. Since we didn''t
    add the `EXPOSE` instruction in our `Dockerfile`, what we have is just the container
    port that was mapped using `-p80:80` as an argument to the `docker run` subcommand:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PortBindings` object is part of the `HostConfig` object, and this object
    lists out all the port binding done through the `-p` option in the `docker run`
    subcommand. This object will never list the ports exposed through the `EXPOSE`
    instruction in the `Dockerfile`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Ports` object of the `NetworkSettings` object has the same level of detail,
    as the preceding `PortBindings` object. However, this object encompasses all ports
    that are exposed through the `EXPOSE` instruction in `Dockerfile`, as well as
    the container ports that are mapped using the `-p` option in the `docker run`
    subcommand:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the specific port field can be filtered using the `--format` option
    of the `docker inspect` subcommand.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `docker port` subcommand enables you to retrieve the port binding on the
    Docker host by specifying the container''s port number:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Evidently, in all the preceding output excerpts, the information that stands
    out is the IP address `0.0.0.0` and the port number `80`. The IP address `0.0.0.0`
    is a meta address, which represents all the IP addresses configured on the Docker
    host. In effect, the containers port `80` is bound to all the valid IP addresses
    on the Docker host. Therefore, the HTTP service is accessible through any of the
    valid IP addresses configured on the Docker host.
  prefs: []
  type: TYPE_NORMAL
- en: Binding a container to a specific IP address
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Until now, with the method that we have learnt, the containers always get bound
    to all the IP addresses configured in the Docker host. However, you may want to
    offer different services on different IP addresses. In other words, a specific
    IP address and port would be configured to offer a particular service. We can
    achieve this in Docker using the `-p <ip>:<hostPort>:<containerPort>` option of
    the `docker run` subcommand, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the IP address must be a valid IP address on the Docker host. If the
    specified IP address is not a valid IP address on the Docker host, the container
    launch will fail with an error message, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's quickly review the port mapping as well as the NAT entry for the
    preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following text is an excerpt from the output of the `docker ps` subcommand
    that shows the details of this container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The following text is an excerpt from the output of the `iptables -n nat -L
    -n` command that shows the `DNAT` entry created for this container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: After reviewing both the output of the `docker run` subcommand and the `DNAT`
    entry of `iptables`, you will realize how elegantly the Docker engine has configured
    the service offered by the container on the IP address `198.51.100.73` and port
    `80` of the Docker host.
  prefs: []
  type: TYPE_NORMAL
- en: Auto-generating the Docker host port
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Docker containers are innately lightweight and due to their lightweight
    nature, you can run multiple containers with the same, or different services on
    a single Docker host. Particularly, auto scaling of the same service across several
    containers based on demand, is the need of IT infrastructure today. Here, in this
    section, you will be informed about the challenge in spinning up multiple containers
    with the same service, and also Docker's way of addressing this challenge.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, we launched a container using `apache2 http server`
    by binding it to port `80` of the Docker host. Now, if we attempt to launch one
    more container with the same port `80` binding, the container would fail to start
    with an error message, as you can see in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, in the preceding example, the container failed to start because the
    previous container is already mapped to `0.0.0.0` (all the IP addresses of the
    Docker host) and port `80`. In the TCP/IP communication model, the combination
    of the IP address, port, and the Transport Protocols (TCP, UDP, and so on) has
    to be unique.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could have overcome this issue by manually choosing the Docker host port
    number (for instance, `-p 81:80` or `-p 8081:80`). Though this is an excellent
    solution, it does not perform well to auto-scaling scenarios. Instead, if we give
    the control to Docker, it would auto-generate the port number on the Docker host.
    This port number generation is achieved by underspecifying the Docker host port
    number, using the `-p <containerPort>` option of the `docker run` subcommand,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Having successfully started the new container with the auto-generated port,
    let''s review the port mapping as well as the NAT entry for the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following text is an excerpt from the output of the `docker ps` subcommand
    that shows the details of this container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The following text is an excerpt from the output of the `iptables -n nat -L
    -n` command that shows the `DNAT` entry created for this container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: After reviewing both the output of the `docker run` subcommand and the `DNAT`
    entry of `iptables`, what stands out is the port number `49158`. The port number
    `49158` is niftily auto-generated by the Docker engine on the Docker host, with
    the help of the underlying operating system. Besides, the meta IP address `0.0.0.0`
    implies that the service offered by the container is accessible from outside,
    through any of the valid IP addresses configured on the Docker host.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have a use case where you want to auto-generate the port number. However,
    if you still want to restrict the service to a particular IP address of the Docker
    host, you can use the `-p <IP>::<containerPort>` option of the `docker run` subcommand,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding two scenarios, the Docker engine auto-generated the port number
    on the Docker host and exposed it to the outside world. The general norm for network
    communication is to expose any service through a predefined port number so that
    anybody can know the IP address, and the port number can easily access the offered
    service. Whereas, here, the port numbers are auto-generated and as a result, the
    outside world cannot directly reach the offered service. So, the primary purpose
    of this method of container creation is to achieve auto-scaling, and the container
    created in this fashion would be interfaced with a proxy or load balance service
    on a predefined port.
  prefs: []
  type: TYPE_NORMAL
- en: Port binding using EXPOSE and the -P option
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have discussed the four distinct methods to publish a service running
    inside a container to the outside world. In all these four methods, the port binding
    decision is taken during the container launch time, and the image has no information
    about the ports on which the service is being offered. It has worked well so far
    because the image is being built by us, and we are pretty much aware of the port
    in which the service is being offered. However, in the case of third-party images,
    the port usage inside a container has to be published unambiguously. Besides,
    if we build images for third-party consumption or even for our own use, it is
    a good practice to explicitly state the ports in which the container offers its
    service. Perhaps, the image builders could ship a readme document along with the
    image. However, it is even better to embed the port details in the image itself
    so that you can easily find the port details from the image both manually as well
    as through automated scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Docker technology allows us to embed the port information using the `EXPOSE`
    instruction in the `Dockerfile`, which we introduced in [Chapter 3](ch03.html
    "Chapter 3. Building Images"), *Building Images*. Here, let''s edit the `Dockerfile`
    we used to build the `apache2` HTTP server image earlier in this chapter, and
    add an `EXPOSE` instruction, as shown in the following code. The default port
    for the HTTP service is port `80`, hence port `80` is exposed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have added the `EXPOSE` instruction to our `Dockerfile`, let''s
    move to the next step of building the image using the `docker build` command.
    Here, let''s reuse the image name `apache2`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Having successfully built the image, let''s inspect the image to verify the
    effects of the `EXPOSE` instruction to the image. As we learnt earlier, we can
    resort to the `docker inspect` subcommand, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'On close review of the output generated by the preceding command, you will
    realize that Docker stores the exposed port information in the `ExposedPorts`
    field of the `Config` object. The following is an excerpt to show how the exposed
    port information is being displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can apply the format option to the `docker inspect` subcommand
    in order to narrow down the output to very specific information. In this case,
    the `ExposedPorts` field of the `Config` object is shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: To resume our discussion on the `EXPOSE` instruction, we can now spin up containers
    using an `apache2` image, that we just crafted. Yet, the `EXPOSE` instruction
    by itself cannot create port binding on the Docker host. In order to create port
    binding for the port declared using the `EXPOSE` instruction, the Docker engine
    provides a `-P` option in the `docker run` subcommand.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, a container is launched from the `apache2` image,
    which was rebuilt earlier. Here, the `-d` option is used to launch the container
    in the detached mode, and the `-P` option is used to create the port binding in
    the Docker host for all the ports declared, using the `EXPOSE` instruction in
    the `Dockerfile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have started the new container with the image that was created
    using the `EXPOSE` instruction, like the previous containers, let''s review the
    port mapping as well as the NAT entry for the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following text is an excerpt from the output of the `docker ps` subcommand
    that shows the details of this container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The following text is an excerpt from the output of the `iptables -t nat -L
    -n` command that shows the `DNAT` entry created for this container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `-P` option of the `docker run` subcommand does not take any additional
    arguments, such as an IP address or a port number; consequently, fine tuning of
    the port binding is not possible, such as the `-p` option of the `docker run`
    subcommand. You can always resort to the `-p` option of the `docker run` subcommand
    if fine tuning of the port binding is critical to you.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Containers do not deliver anything in an isolated or solo way substantially.
    They need to be systematically built and provided with a network interface along
    with a port number. This leads to a standardized exposition of containers to the
    outside world, facilitating other hosts or containers to find, bind, and leverage
    their unique capabilities on any network. Thus, network-accessibility is paramount
    for containers to get noticed and utilized in innumerable ways. This chapter is
    dedicated to showcasing how containers are being designed and deployed as a service,
    and how the aspect of container networking comes in handy by precisely and profusely
    empowering the peculiar world of container services as the days unfold. In the
    forthcoming chapters, we will deal and dwell at length on the various capabilities
    of Docker containers in software-intensive IT environments.
  prefs: []
  type: TYPE_NORMAL
