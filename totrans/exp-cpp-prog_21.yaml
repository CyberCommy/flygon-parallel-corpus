- en: The New C++17 Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using structured bindings to unpack bundled return values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limiting variable scopes to `if` and `switch` statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profiting from the new bracket initializer rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Letting the constructor automatically deduce the resulting template class type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplifying compile-time decisions with constexpr-if
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling header-only libraries with inline variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing handy helper functions with fold expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ got a lot of additions in C++11, C++14, and, most recently, C++17\. By now,
    it is a completely different language compared to what it was just a decade ago.
    The C++ standard does not only standardize the language, as it needs to be understood
    by the compilers, but also the C++ standard template library (STL).
  prefs: []
  type: TYPE_NORMAL
- en: This book explains how to put the STL to the best use with a broad range of
    examples. But at first, this chapter will concentrate on the most important new
    language features. Mastering them will greatly help you write readable, maintainable,
    and expressive code a lot.
  prefs: []
  type: TYPE_NORMAL
- en: We will see how to access individual members of pairs, tuples, and structures
    comfortably with structured bindings and how to limit variable scopes with the
    new `if` and `switch` variable initialization capabilities. The syntactical ambiguities,
    which were introduced by C++11 with the new bracket initialization syntax, which
    looks the same for initializer lists, were fixed by *new bracket initializer rules*.
    The exact *type* of template class instances can now be *deduced* from the actual
    constructor arguments, and if different specializations of a template class will
    result in completely different code, this is now easily expressible with constexpr-if.
    The handling of variadic parameter packs in template functions became much easier
    in many cases with the new *fold expressions*. At last, it became more comfortable
    to define static globally accessible objects in header-only libraries with the
    new ability to declare inline variables, which was only possible for functions
    before.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the examples in this chapter might be more interesting for implementers
    of libraries than for developers who implement applications. While we will have
    a look at such features for completeness reasons, it is not too critical to understand
    all the examples of this chapter immediately in order to understand the rest of
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: Using structured bindings to unpack bundled return values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C++17 comes with a new feature, which combines syntactic sugar and automatic
    type deduction: **structured bindings**. These help to assign values from pairs,
    tuples, and structs into individual variables. In other programming languages,
    this is also called **unpacking**.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Applying a structured binding in order to assign multiple variables from one
    bundled structure is always one step. Let''s first see how it was done before
    C++17\. Then, we can have a look at multiple examples that show how we can do
    it in C++17:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Accessing individual values of an `std::pair`: Imagine we have a mathematical
    function, `divide_remainder`, which accepts a *dividend* and a *divisor* parameter
    and returns the fraction of both as well as the remainder. It returns those values
    using an `std::pair` bundle:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following way of accessing the individual values of the resulting
    pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of doing it as shown in the preceding code snippet, we can now assign
    the individual values to individual variables with expressive names, which is
    much better to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Structured bindings also work with `std::tuple`: Let''s take the following
    example function, which gets us online stock information:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Assigning its result to individual variables looks just like in the example
    before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Structured bindings also work with custom structures: Let''s assume a structure
    like the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can access these members using structured bindings. We can even do
    that in a loop, assuming we have a whole vector of those:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Structured bindings are always applied with the same pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The list of variables `var1, var2, ...` must exactly match the number of variables
    contained by the expression being assigned from.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `<pair, tuple, struct, or array expression>` must be one of the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `std::pair`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `std::tuple`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `struct`. All members must be *non-static* and defined in the *same base class*.
    The first declared member is assigned to the first variable, the second member
    to the second variable, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An array of fixed size.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type can be `auto`, `const auto`, `const auto&`, and even `auto&&`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not only for the sake of *performance*, always make sure to minimize needless
    copies by using references when appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we write *too many* or *not enough* variables between the square brackets,
    the compiler will error out, telling us about our mistake:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This example obviously tries to stuff a tuple variable with three members into
    only two variables. The compiler immediately chokes on this and tells us about
    our mistake:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A lot of fundamental data structures from the STL are immediately accessible
    using structured bindings without us having to change anything. Consider, for
    example, a loop that prints all the items of an `std::map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This particular example works because when we iterate over an `std::map` container,
    we get the `std::pair<const key_type, value_type>` nodes on every iteration step.
    Exactly these nodes are unpacked using the structured bindings feature (`key_type`
    is the `species` string and `value_type` is the population count `size_t`) in
    order to access them individually in the loop body.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before C++17, it was possible to achieve a similar effect using `std::tie`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This example shows how to unpack the resulting pair into two variables. The
    `std::tie` is less powerful than structured bindings in the sense that we have
    to define all the variables we want to bind to *before*. On the other hand, this
    example shows a strength of `std::tie` that structured bindings do *not* have:
    the value `std::ignore` acts as a dummy variable. The fraction part of the result
    is assigned to it, which leads to that value being dropped because we do not need
    it in that example.'
  prefs: []
  type: TYPE_NORMAL
- en: When using structured bindings, we don't have `tie` dummy variables, so we have
    to bind all the values to named variables. Doing so and ignoring some of them
    is efficient, nevertheless, because the compiler can optimize the unused bindings
    out easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in the past, the `divide_remainder` function could have been implemented
    in the following way, using output parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Accessing it would have looked like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: A lot of people will still prefer this over returning complex structures like
    pairs, tuples, and structs, arguing that this way the code would be *faster*,
    due to avoided intermediate copies of those values. This is *not true* any longer
    for modern compilers, which optimize intermediate copies away.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the missing language features in C, returning complex structures
    via return value was considered slow for a long time because the object had to
    be initialized in the returning function and then copied into the variable that
    should contain the return value on the caller side. Modern compilers support **return
    value optimization** (RVO), which enables for omitting intermediate copies.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting variable scopes to if and switch statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is good style to limit the scope of variables as much as possible. Sometimes,
    however, one first needs to obtain some value, and only if it fits a certain condition,
    it can be processed further.
  prefs: []
  type: TYPE_NORMAL
- en: For this purpose, C++17 comes with `if` and `switch` statements with initializers.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we use the initializer syntax in both the supported contexts
    in order to see how they tidy up our code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `if` statements: Imagine we want to find a character in a character map
    using the `find` method of `std::map`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `switch` statements: This is how it would look to get a character from
    the input and, at the same time, check the value in a `switch` statement in order
    to control a computer game:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `if` and `switch` statements with initializers are basically just syntax
    sugar. The following two samples are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Before* C++17:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Since* C++17:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The same applies to `switch` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before C++17:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Since C++17:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This feature is very useful to keep the scope of a variable as short as necessary.
    Before C++17, this was only possible using extra braces around the code, as the
    pre-C++17 examples show. The short lifetimes reduce the number of variables in
    the scope, which keeps our code tidy and makes it easier to refactor.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another interesting use case is the limited scope of critical sections. Consider
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: At first, an `std::lock_guard` is created. This is a class that accepts a mutex
    argument as a constructor argument. It *locks* the mutex in its constructor, and
    when it runs out of scope, it *unlocks* it again in its destructor. This way,
    it is impossible to *forget* to unlock the mutex. Before C++17, a pair of extra
    braces was needed in order to determine the scope where it unlocks again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Yet another interesting use case is the scope of weak pointers. Consider the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This is another example where we would have a useless `shared_pointer` variable
    leaking into the current scope, although it has a potentially useless state outside
    the `if` conditional block or noisy extra brackets!
  prefs: []
  type: TYPE_NORMAL
- en: 'The `if` statements with initializers are especially useful when using *legacy*
    APIs with output parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`GetExitCodeProcess` is a Windows kernel API function. It returns the exit
    code for a given process handle but only if that handle is valid. After leaving
    this conditional block, the variable is useless, so we don''t need it in any scope
    any longer.'
  prefs: []
  type: TYPE_NORMAL
- en: Being able to initialize variables within `if` blocks is obviously very useful
    in a lot of situations and, especially, when dealing with legacy APIs that use
    output parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Keep your scopes tight using `if` and `switch` statement initializers. This
    makes your code more compact, easier to read, and in code refactoring sessions,
    it will be easier to move around.
  prefs: []
  type: TYPE_NORMAL
- en: Profiting from the new bracket initializer rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++11 came with the new brace initializer syntax `{}`. Its purpose was to allow
    for *aggregate* initialization, but also for usual constructor calling. Unfortunately,
    it was too easy to express the wrong thing when combining this syntax with the
    `auto` variable type. C++17 comes with an enhanced set of initializer rules. In
    this recipe, we will clarify how to correctly initialize variables with which
    syntax in C++17.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Variables are initialized in one step. Using the initializer syntax, there
    are two different situations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the brace initializer syntax *without* `auto` type deduction:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the brace initializer syntax *with* `auto` type deduction:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Without `auto` type deduction, there's not much to be surprised about in the
    brace `{}` operator, at least, when initializing regular types. When initializing
    containers such as `std::vector`, `std::list`, and so on, a brace initializer
    will match the `std::initializer_list` constructor of that container class. It
    does this in a *greedy* manner, which means that it is not possible to match non-aggregate
    constructors (non-aggregate constructors are usual constructors in contrast to
    the ones that accept an initializer list).
  prefs: []
  type: TYPE_NORMAL
- en: '`std::vector`, for example, provides a specific non-aggregate constructor,
    which fills arbitrarily many items with the same value: `std::vector<int> v (N,
    value)`. When writing `std::vector<int> v {N, value}`, the `initializer_list`
    constructor is chosen, which will initialize the vector with two items: `N` and
    `value`. This is a special pitfall one should know about.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One nice detail about the `{}` operator compared to constructor calling using
    normal `()` parentheses is that they do no implicit type conversions: `int x (1.2);`
    and `int x = 1.2;` will initialize `x` to value `1` by silently rounding down
    the floating point value and converting it to int. `int x {1.2};`, in contrast,
    will not compile because it wants to *exactly* match the constructor type.'
  prefs: []
  type: TYPE_NORMAL
- en: One can controversially argue about which initialization style is the best one.
  prefs: []
  type: TYPE_NORMAL
- en: Fans of the bracket initialization style say that using brackets makes it very
    explicit, that the variable is initialized with a constructor call, and that this
    code line is not reinitializing anything. Furthermore, using `{}` brackets will
    select the only matching constructor, while initializer lines using `()` parentheses
    try to match the closest constructor and even do type conversion in order to match.
  prefs: []
  type: TYPE_NORMAL
- en: The additional rule introduced in C++17 affects the initialization with `auto`
    type deduction--while C++11 would correctly make the type of the variable `auto
    x {123};` an `std::initializer_list<int>` with only one element, this is seldom
    what we would want. C++17 would make the same variable an `int`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rule of thumb:'
  prefs: []
  type: TYPE_NORMAL
- en: '`auto var_name {one_element};` deduces `var_name` to be of the same type as
    `one_element`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`auto var_name {element1, element2, ...};` is invalid and does not compile'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`auto var_name = {element1, element2, ...};` deduces to an `std::initializer_list<T>`
    with `T` being of the same type as all the elements in the list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++17 has made it harder to accidentally define an initializer list.
  prefs: []
  type: TYPE_NORMAL
- en: Trying this out with different compilers in C++11/C++14 mode will show that
    some compilers actually deduce `auto x {123};` to an `int`, while others deduce
    it to `std::initializer_list<int>`. Writing code like this can lead to problems
    regarding portability!
  prefs: []
  type: TYPE_NORMAL
- en: Letting the constructor automatically deduce the resulting template class type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A lot of classes in C++ are usually specialized on types, which could be easily
    deduced from the variable types the user puts in their constructor calls. Nevertheless,
    before C++17, this was not a standardized feature. C++17 lets the compiler *automatically*
    deduce template types from constructor calls.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A very handy use case for this is constructing `std::pair` and `std::tuple`
    instances. These can be specialized and instantiated and specialized in one step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s define an example class where automatic template type deduction would
    be of value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, this is just another template class. We previously had to write the following
    in order to instantiate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now just omit the template specialization part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Before C++17, this was only possible by implementing a *make function helper*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Using such helpers, it was possible to have a similar effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The STL already comes with a lot of helper functions such as that one: `std::make_shared`,
    `std::make_unique`, `std::make_tuple`, and so on. In C++17, these can now mostly
    be regarded as obsolete. Of course, they will be provided further for compatibility
    reasons.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What we just learned about was *implicit template type deduction*. In some
    cases, we cannot rely on implicit type deduction. Consider the following example
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This struct, `sum`, accepts an arbitrary number of parameters and adds them
    together using a fold expression (have a look at the fold expression recipe a
    little later in this chapter to get more details on fold expressions). The resulting
    sum is saved in the member variable `value`. Now the question is, what type is
    `T`? If we don''t want to specify it explicitly, it surely needs to depend on
    the types of the values provided in the constructor. If we provide string instances,
    it needs to be `std::string`. If we provide integers, it needs to be `int`. If
    we provide integers, floats, and doubles, the compiler needs to figure out which
    type fits all the values without information loss. In order to achieve that, we
    provide an *explicit deduction guide*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This deduction guide tells the compiler to use the `std::common_type_t` trait,
    which is able to find out which common type fits all the values. Let''s see how
    to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the first line we instantiate a `sum` object with constructor arguments of
    type `unsigned`, `double`, `int`, and `float`. The `std::common_type_t` returns
    `double` as the common type, so we get a `sum<double>` instance. In the second
    line, we provide an `std::string` instance and a C-style string. Following our
    deduction guide, the compiler constructs an instance of type `sum<std::string>`.
  prefs: []
  type: TYPE_NORMAL
- en: When running this code, it will print `10` as the numeric sum and `abcdef` as
    the string *sum*.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying compile time decisions with constexpr-if
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In templated code, it is often necessary to do certain things differently, depending
    on the type the template is specialized for. C++17 comes with constexpr-if expressions,
    which simplify the code in such situations *a lot*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll implement a little helper template class. It can deal
    with different template type specializations because it is able to select completely
    different code in some passages, depending on what type we specialize it for:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the part of the code that is generic. In our example, it is a simple
    class, which supports adding a type `U` value to the type `T` member value using
    an `add` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Imagine that type `T` is `std::vector<something>` and type `U` is just `int`.
    What shall it mean to add an integer to a whole vector? Let''s say it means that
    we add the integer to every item in the vector. This will be done in a loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The next and last step is to *combine* both worlds. If `T` is a vector of `U`
    items, do the *loop* variant. If it is not, just implement the *normal* addition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The class can now be put to use. Let''s see how nicely it works with completely
    different types, such as `int`, `float`, `std::vector<int>`, and `std::vector<string>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The new constexpr-if works exactly like usual if-else constructs. The difference
    is that the condition that it tests has to be evaluated at *compile time*. All
    runtime code that the compiler creates from our program will not contain any branch
    instructions from constexpr-if conditionals. One could also put it that it works
    in a similar manner to preprocessor `#if` and `#else` text substitution macros,
    but for those, the code would not even have to be syntactically well-formed. All
    the branches of a constexpr-if construct need to be *syntactically well-formed*,
    but the branches that are *not* taken do not need to be *semantically valid*.
  prefs: []
  type: TYPE_NORMAL
- en: In order to distinguish whether the code should add the value `x` to a vector
    or not, we use the type trait `std::is_same`. An expression `std::is_same<A, B>::value`
    evaluates to the Boolean value `true` if `A` and `B` are of the same type. The
    condition used in our recipe is `std::is_same<T, std::vector<U>>::value`, which
    evaluates to `true` if the user specialized the class on `T = std::vector<X>`
    and tries to call `add` with a parameter of type `U = X`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There can, of course, be multiple conditions in one constexpr-if-else block
    (note that `a` and `b` have to depend on template parameters and not only on compile-time
    constants):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: With C++17, a lot of meta programming situations are much easier to express
    and to read.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to relate how much constexpr-if constructs are an improvement to C++,
    we can have a look at how the same thing could have been implemented *before*
    C++17:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Without using constexpr-if, this class works for all different types we wished
    for, but it looks super complicated. How does it work?
  prefs: []
  type: TYPE_NORMAL
- en: The implementations alone of the *two different* `add` functions look simple.
    It's their return type declaration, which makes them look complicated, and which
    contains a trick--an expression such as `std::enable_if_t<condition, type>` evaluates
    to `type` if `condition` is `true`. Otherwise, the `std::enable_if_t` expression
    does not evaluate to anything. That would normally considered an error, but we
    will see why it is not.
  prefs: []
  type: TYPE_NORMAL
- en: For the second `add` function, the same condition is used in an *inverted* manner.
    This way, it can only be `true` at the same time for one of the two implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the compiler sees different template functions with the same name and
    has to choose one of them, an important principle comes into play: **SFINAE**,
    which stands for **Substitution Failure is not an Error**. In this case, this
    means that the compiler does not error out if the return value of one of those
    functions cannot be deduced from an erroneous template expression (which `std::enable_if`
    is, in case its condition evaluates to `false`). It will simply look further and
    try the *other* function implementation. That is the trick; that is how this works.'
  prefs: []
  type: TYPE_NORMAL
- en: What a hassle. It is nice to see that this became so much easier with C++17.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling header-only libraries with inline variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While it was always possible in C++ to declare individual functions *inline*,
    C++17 additionally allows us to declare *variables* inline. This makes it much
    easier to implement *header-only* libraries, which was previously only possible
    using workarounds.
  prefs: []
  type: TYPE_NORMAL
- en: How it's done...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we create an example class that could suit as a member of a
    typical header-only library. The target is to give it a static member and instantiate
    it in a globally available manner using the `inline` keyword, which would not
    be possible like this before C++17:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `process_monitor` class should both contain a static member and be globally
    accessible itself, which would produce double-defined symbols when included from
    multiple translation units:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now include this in multiple `.cpp` files in order to compile and link
    them, this would fail at the linker stage. In order to fix this, we add the `inline`
    keyword:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Voila, that's it!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ programs do often consist of multiple C++ source files (these do have `.cpp`
    or `.cc` suffices). These are individually compiled to modules/object files (which
    usually have .o suffices). Linking all the modules/object files together into
    a single executable or shared/static library is then the last step.
  prefs: []
  type: TYPE_NORMAL
- en: At the link stage, it is considered an error if the linker can find the definition
    of one specific symbol *multiple* times. Let's say, for example, we have a function
    with a signature such as `int foo();`. If two modules define the same function,
    which is the right one? The linker can't just roll the dice. Well, it could, but
    that's most likely not what any programmer would ever want to happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The traditional way to provide globally available functions is to *declare*
    them in the header files, which will be included by any C++ module that needs
    to call them. The definition of every of those functions will be then put *once*
    into separate module files. These are then linked together with the modules that
    desire to use these functions. This is also called the **One Definition Rule**
    (**ODR**). Check out the following illustration for better understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee850b95-1991-4682-a5d1-1c7290509001.png)'
  prefs: []
  type: TYPE_IMG
- en: However, if this were the only way, then it would not have been possible to
    provide header-only libraries. Header-only libraries are very handy because they
    only need to be included using `#include` into any C++ program file and then are
    immediately available. In order to use libraries that are not header-only, the
    programmer must also adapt the build scripts in order to have the linker link
    the library modules together with his own module files. Especially for libraries
    with only very short functions, this is unnecessarily uncomfortable.
  prefs: []
  type: TYPE_NORMAL
- en: For such cases, the `inline` keyword can be used to make an exception in order
    to allow *multiple* definitions of the same symbol in different modules. If the
    linker finds multiple symbols with the same signature, but they are declared inline,
    it will just choose the first one and trust that the other symbols have the same
    definition. That all equal inline symbols are defined completely equal is basically
    a *promise* from the programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding our recipe example, the linker will find the `process_monitor::standard_string`
    symbol in every module that includes `foo_lib.hpp`. Without the `inline` keyword,
    it would not know which one to choose, so it would abort and report an error.
    The same applies to the `global_process_monitor` symbol. Which one is the right
    one?
  prefs: []
  type: TYPE_NORMAL
- en: After declaring both the symbols `inline`, it will just accept the first occurrence
    of each symbol and *drop* all the others.
  prefs: []
  type: TYPE_NORMAL
- en: Before C++17, the only clean way would be to provide this symbol via an additional
    C++ module file, which would force our library users to include this file in the
    linking step.
  prefs: []
  type: TYPE_NORMAL
- en: The `inline` keyword traditionally also has *another* function. It tells the
    compiler that it can *eliminate* the function call by taking its implementation
    and directly putting it where it was called. This way, the calling code contains
    one function call less, which can often be considered faster. If the function
    is very short, the resulting assembly will also be shorter (assuming that the
    number of instructions that do the function call, saving and restoring the stack,
    and so on, is higher than the actual payload code). If the inlined function is
    very long, the binary size will grow and this might sometimes not even lead to
    faster code in the end.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the compiler will only use the `inline` keyword as a hint and might
    eliminate function calls by inlining them. But it can also inline some functions
    *without* the programmer having it declared inline.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One possible workaround before C++17 was providing a `static` function, which
    returns a reference to a `static` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This way, it is completely legal to include the header file in multiple modules
    but still getting access to exactly the same instance everywhere. However, the
    object is *not* constructed *immediately* at the start of program but only on
    the first call of this getter function. For some use cases, this is indeed a problem.
    Imagine that we want the constructor of the static, globally available object
    to do something important at *program start* (just as our reciple example library
    class), but due to the getter being called near the end of the program, it is
    too late.
  prefs: []
  type: TYPE_NORMAL
- en: Another workaround is to make the non-template class `foo` a template class,
    so it can profit from the same rules as templates.
  prefs: []
  type: TYPE_NORMAL
- en: Both strategies can be avoided in C++17.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing handy helper functions with fold expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since C++11, there are variadic template parameter packs, which enable implementing
    functions that accept arbitrarily many parameters. Sometimes, these parameters
    are all combined into one expression in order to derive the function result from
    that. This task became really easy with C++17, as it comes with fold expressions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s implement a function that takes arbitrarily many parameters and returns
    their sum:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At first, we define its signature:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we have a parameter pack `ts` now, and the function should expand all the
    parameters and sum them together using a fold expression. If we use any operator
    (`+`, in this example) together with `...` in order to apply it to all the values
    of a parameter pack, we need to surround the expression with parentheses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now call it this way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'It does not only work with `int` types; we can call it with any type that just
    implements the `+` operator, such as `std::string`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we just did was a simple recursive application of a binary operator (`+`)
    to its parameters. This is generally called *folding*. C++17 comes with **fold
    expressions**, which help expressing the same idea with less code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This kind of expression is called **unary fold**. C++17 supports folding parameter
    packs with the following binary operators: `+`, `-`, `*`, `/`, `%`, `^`, `&`,
    `|`, `=`, `<`, `>`, `<<`, `>>`, `+=`, `-=`, `*=`, `/=`, `%=`, `^=`, `&=`, `|=`,
    `<<=`, `>>=`, `==`, `!=`, `<=`, `>=`, `&&`, `||`, `,`, `.*`, `->*`.'
  prefs: []
  type: TYPE_NORMAL
- en: By the way, in our example code, it does not matter if we write `(ts + …)` or
    `(… + ts)`; both work. However, there is a difference that may be relevant in
    other cases--if the `…` dots are on the *right-hand* side of the operator, the
    fold is called a *right* fold. If they are on the *left-hand* side, it is a *left*
    fold.
  prefs: []
  type: TYPE_NORMAL
- en: In our `sum` example, a unary left fold expands to `1 + (2 + (3 + (4 + 5)))`,
    while a unary right fold will expand to `(((1 + 2) + 3) + 4) + 5`. Depending on
    the operator in use, this can make a difference. When adding numbers, it does
    not.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In case someone calls `sum()` with *no* arguments, the variadic parameter pack
    contains no values that could be folded. For most operators, this is an error
    (for some, it is not; we will see this in a minute). We then need to decide if
    this should stay an error or if an empty sum should result in a specific value.
    The obvious idea is that the sum of nothing is `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how it’s done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This way, `sum()` evaluates to `0`, and `sum(1, 2, 3)` evaluates to `(1 + (2
    + (3 + 0)))`. Such folds with an initial value are called **binary folds**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, it works if we write `(ts + ... + 0)`, or `(0 + ... + ts)`, but this
    makes the binary fold a binary *right* fold or a binary *left* fold again. Check
    out the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4c518bfa-0a12-435d-820f-0199ee897ce3.png)'
  prefs: []
  type: TYPE_IMG
- en: When using binary folds in order to implement the no-argument case, the notion
    of an *identity* element is often important--in this case, adding a `0` to any
    number changes nothing, which makes `0` an identity element. Because of this property,
    we can add a `0` to any fold expression with the operators `+` or `-`, which leads
    to the result `0` in case there are no parameters in the parameter pack. From
    a mathematical point of view, this is correct. From an implementation view, we
    need to define what is correct, depending on what we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same principle applies to multiplication. Here, the identity element is
    `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The result of `product(2, 3)` is `6`, and the result of `product()` without
    parameters is `1`.
  prefs: []
  type: TYPE_NORMAL
- en: The logical **and** (`&&`) and **or** (`||`) operators come with *built-in*
    identity elements. Folding an empty parameter pack with `&&` results in `true`,
    and folding an empty parameter pack with `||` results in `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Another operator that defaults to a certain expression when applied on empty
    parameter packs is the comma operator (`,`), which then defaults to `void()`.
  prefs: []
  type: TYPE_NORMAL
- en: In order to ignite some inspiration, let's have a look at some more little helpers
    that we can implement using this feature.
  prefs: []
  type: TYPE_NORMAL
- en: Match ranges against individual items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How about a function that tells whether some range contains *at least one*
    of the values we provide as variadic parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The helper function uses the `std::count` function from the STL. This function
    takes three parameters: the first two parameters are the *begin* and *end* iterators
    of some iterable range, and as the third parameter, it takes a *value* which will
    be compared to all the items of the range. The `std::count` method then returns
    the number of all the elements within the range that are equal to the third parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: In our fold expression, we always feed the *begin* and *end* iterators of the
    same parameter range into the `std::count` function. However, as the third parameter,
    each time we put one other parameter from the parameter pack into it. In the end,
    the function sums up all the results and returns it to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the `matches` helper function is quite versatile--it can be called
    on vectors or even on strings directly. It would also work on initializer lists,
    on instances of `std::list`, `std::array`, `std::set`, and so on!
  prefs: []
  type: TYPE_NORMAL
- en: Check if multiple insertions into a set are successful
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s write a helper that inserts an arbitrary number of variadic parameters
    into an `std::set` and returns if all the insertions are *successful*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'So, how does this work? The `insert` function of `std::set` has the following
    signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The documentation says that when we try to insert an item, the `insert` function
    will return an `iterator` and a `bool` variable in a pair. The `bool` value is
    `true` if the insertion is successful. If it is successful, the iterator points
    to the *new element* in the set. Otherwise, the iterator points to the *existing*
    item, which would *collide* with the item to be inserted.
  prefs: []
  type: TYPE_NORMAL
- en: Our helper function accesses the `.second` field after insertion, which is just
    the `bool` variable that reflects success or fail. If all the insertions lead
    to `true` in all the return pairs, then all the insertions were successful. The
    fold expression combines all the insertion results with the `&&` operator and
    returns the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that if we try to insert, for example, three elements, but the second
    element can already not be inserted, the `&& ...` fold will short-circuit and
    stop inserting all the other elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Check if all the parameters are within a certain range
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we can check if *one* variable is within some specific range, we can also
    do the same thing with *multiple* variables using fold expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The expression, `(min <= ts && ts <= max)`, does tell for every value of the
    parameter pack if it is between `min` and `max` (*including* `min` and `max`).
    We choose the `&&` operator to reduce all the Boolean results to a single one,
    which is only `true` if all the individual results are `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how it looks in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Interestingly, this function is very versatile because the only requirement
    it imposes on the types we use is that they are *comparable* with the `<=` operator.
    And this requirement is also fulfilled by `std::string`, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Pushing multiple items into a vector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s also possible to write a helper that does not reduce any results but
    processes multiple actions of the same kind. Like inserting items into an `std::vector`,
    which does not return any results (`std::vector::insert()` signalizes error by
    throwing exceptions):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Note that we use the comma (`,`) operator in order to expand the parameter pack
    into individual `vec.push_back(...)` calls without folding the actual result.
    This function also works nicely with an *empty* parameter pack because the comma
    operator has an implicit identity element, `void()`, which translates to *do nothing*.
  prefs: []
  type: TYPE_NORMAL
