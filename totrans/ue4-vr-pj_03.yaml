- en: Hello World - Your First VR Project
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你好世界 - 你的第一个VR项目
- en: It's time to start building! Back in [Chapter 1](8ad5a719-9b05-467c-ba9b-4467ce678145.xhtml),
    *Thinking in VR*, we learned what VR is and what it can do, and we learned a number
    of best practices for its design. Then, in [Chapter 2](24157dc8-09e6-4ff8-9ba2-3e0d0e4709b6.xhtml),
    *Setting up Your Development Environment*, we set up our development environment.
    Now we're ready to start building.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始构建了！在[第1章](8ad5a719-9b05-467c-ba9b-4467ce678145.xhtml)中，我们学习了什么是VR以及它能做什么，我们还学习了一些关于VR设计的最佳实践。然后，在[第2章](24157dc8-09e6-4ff8-9ba2-3e0d0e4709b6.xhtml)中，我们设置了开发环境。现在我们准备好开始构建了。
- en: In this chapter, we're going to build a VR project in Unreal from the ground
    up. We're going to take a different approach, though, from most tutorials. Rather
    than just give you a list of steps to follow, for each thing we do we're going
    to talk a bit about what's going on under the hood and why we're doing it this
    way. This is what's really important. If you understand a bit about how these
    systems work, you'll be much better equipped to understand what to do when you
    build your own projects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从头开始在虚幻中构建一个VR项目。然而，我们将采取与大多数教程不同的方法。我们不仅仅给你一系列要遵循的步骤，对于我们所做的每一件事，我们都会谈一谈在幕后发生了什么，以及为什么我们要以这种方式做。这才是真正重要的。如果你对这些系统的工作原理有一些了解，你在构建自己的项目时将更加有能力知道该做什么。
- en: As we build our first VR project, we're going to learn a bit about its structure,
    and we'll learn about the specific project settings that apply most to VR development.
    We'll also look at those settings and choices that specifically affect mobile
    VR, and show you what you need to know there. From here, we'll bring a detailed
    scene into our project and learn a bit about how to move assets safely between
    projects and how to manage a project's content. Finally, we'll set up the game
    mode and pawn blueprints we'll need to run a VR project.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建我们的第一个VR项目时，我们将了解一些关于其结构的知识，并了解适用于VR开发的特定项目设置。我们还将查看那些特别影响移动VR的设置和选择，并向您展示在这方面需要了解的内容。从这里开始，我们将在项目中引入一个详细的场景，并学习如何在项目之间安全地移动资产以及如何管理项目的内容。最后，我们将设置游戏模式和角色蓝图，以便运行VR项目。
- en: 'This chapter will cover the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Creating a project for VR from scratch
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从零开始创建一个VR项目
- en: Understanding important settings and choices you need to make when you start
    your project
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解在开始项目时需要做出的重要设置和选择
- en: Setting up a project for mobile VR
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为移动VR设置项目
- en: Moving content safely between projects and managing content within your project
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在项目之间安全地移动内容和管理项目内的内容
- en: Setting up the basic blueprints you'll need for VR development in Unreal
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在虚幻中设置你在VR开发中所需的基本蓝图
- en: Creating a new project
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新项目
- en: All right, let's start creating!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们开始创建！
- en: The first thing we need to do is create a new project. We created a few quick
    throwaway projects in the previous chapter just to make sure everything was working,
    but now we're ready to begin building for real.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建一个新项目。在上一章中，我们创建了一些快速的临时项目，只是为了确保一切正常工作，但现在我们准备好开始真正的构建了。
- en: Open your **Epic Games Launcher** if it isn't already open, head to the Library
    tab, and where you see your **Engine Versions**, hit Launch on your most current
    engine version. (You can do this from the Launch button on the left side of the
    launcher as well.)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的**Epic Games Launcher**还没有打开，请打开它，转到“库”选项卡，在“引擎版本”下找到你最新的引擎版本，点击“启动”。（你也可以从启动器左侧的启动按钮进行操作。）
- en: The Unreal Project Browser will appear. Select the New Project tab, and let's
    select the Blueprint tab and the Blank template to create an empty Blueprint project.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虚幻项目浏览器将出现。选择“新项目”选项卡，让我们选择“蓝图”选项卡和“空白”模板来创建一个空的蓝图项目。
- en: '**Templates** are very useful starting points for Unreal projects. They contain
    simple and useful working foundations of many game types, and much of the time
    when you''re starting a new project, you''ll want to use them. We''re beginning
    with a blank project here so you can see each element as it goes in. You''ll probably
    most commonly use the First Person, Third Person, and VR templates as starting
    points for most projects.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**模板**是虚幻引擎项目的非常有用的起点。它们包含了许多游戏类型的简单和有用的工作基础，当你开始一个新项目时，你通常会想要使用它们。我们从一个空白项目开始，这样你就可以看到每个元素的添加过程。对于大多数项目，你可能最常用的是第一人称、第三人称和VR模板作为起点。'
- en: 'We have a few more choices to make on this dialog, and we should understand
    what they mean:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个对话框上我们还有一些选择要做，并且我们应该了解它们的含义：
- en: '![](img/f5bc6ebe-5313-4412-9fff-3a203ab665bd.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f5bc6ebe-5313-4412-9fff-3a203ab665bd.png)'
- en: Setting your hardware target
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置硬件目标
- en: 'The Hardware Target selector gives you two options:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件目标选择器提供了两个选项：
- en: Desktop / Console
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桌面/主机
- en: Mobile / Tablet
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动/平板
- en: Ordinarily, you should choose the correct option for your target platform, but
    when developing for VR, it can be a good idea to select the Mobile / Tablet option
    even if you're developing for desktop, as that option will turn off a few rendering
    options that can be expensive in VR.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，你应该选择适合目标平台的正确选项，但是在开发VR时，即使你是为桌面开发，选择移动/平板选项也是一个好主意，因为该选项会关闭一些在VR中可能很昂贵的渲染选项。
- en: 'Specifically, choosing the mobile target rather than the desktop target will
    turn off the following rendering options:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 具体而言，选择移动目标而不是桌面目标将关闭以下渲染选项：
- en: Separate Translucency
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分离半透明度
- en: Bloom
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛光
- en: Ambient Occlusion
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境遮蔽
- en: Setting your graphics target
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置图形目标
- en: 'The next choice you need to make is your **Graphics Target**. Again, you have
    two choices here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做出的下一个选择是你的**图形目标**。同样，在这里你有两个选择：
- en: Maximum Quality
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最高质量
- en: Scalable 3D or 2D
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展的3D或2D
- en: Selecting Maximum Quality will turn on all of the default high-end rendering
    options Unreal Engine offers. As we've mentioned previously, however, in VR, meeting
    your target framerate is far more important than including detail in your scene.
    For VR development, it's always a good idea to select the Scalable option.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 选择最高质量将打开Unreal Engine提供的所有默认高端渲染选项。然而，如前所述，在VR中，达到目标帧率比在场景中包含细节更重要。对于VR开发，选择可扩展选项总是一个好主意。
- en: You're better off beginning with everything turned off and turning things on
    as you need them. If you start the other way, with everything turned on, it can
    be difficult to figure out what's killing your framerate and figure out what you
    need to turn off. It's a much better practice to start with your project running
    at a reasonable speed and keep it running quickly than to build something that
    runs poorly and hope that you're somehow going to get it running faster later
    on.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的做法是从关闭所有内容开始，根据需要逐渐打开它们。如果你从一开始就打开了所有内容，很难弄清楚是什么导致了帧率下降，并找出需要关闭的内容。最好的做法是从项目以合理的速度运行开始，并保持快速运行，而不是构建一个运行效果差的项目，并希望以后能够更快地运行。
- en: Settings summary
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置摘要
- en: 'For our project, we''re going to go with the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的项目，我们将选择以下内容：
- en: 'Project Template: Blueprint - Blank'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目模板：蓝图-空白
- en: 'Hardware Target: Mobile / Tablet'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件目标：移动设备/平板电脑
- en: 'Graphics Target: Scalable 2D or 3D'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形目标：可扩展的2D或3D
- en: No Starter Content
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有起始内容
- en: We can leave the Starter Content turned off for now, since we can easily add
    that stuff later when we need it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将Starter Content关闭，因为我们可以在需要时轻松添加这些内容。
- en: Choose where you'd like to save your project and hit Create Project to set it
    up.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 选择你想保存项目的位置，然后点击创建项目来设置它。
- en: Taking a quick look at your project's structure
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速查看项目的结构
- en: We've now created an empty project. Let's take a brief moment to take a look
    at what that actually means.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在创建了一个空项目。让我们花点时间来看看这实际上意味着什么。
- en: 'If you navigate Windows Explorer to the location where you saved your project,
    you''ll see that Unreal has created a file there with your project''s name and
    the `.uproject` extension, along with four directories:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在Windows资源管理器中导航到保存项目的位置，你会看到Unreal在那里创建了一个带有项目名称和`.uproject`扩展名的文件，以及四个目录：
- en: '**Config**: Configuration files such as `DefaultEngine.ini` and `DefaultGame.ini`
    live here and hold settings for your engine and project.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Config**：配置文件，如`DefaultEngine.ini`和`DefaultGame.ini`，存放在这里，保存了引擎和项目的设置。'
- en: '**Content**: This is where your project''s assets, such as models, textures,
    materials, and blueprints will live. This is the bulk of your project.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Content**：这是你的项目的资产所在的地方，如模型、纹理、材质和蓝图。这是你项目的主要部分。'
- en: '**Intermediate**: Temporary files created when your project''s assets are compiled
    go here. Everything in here is temporary and will be regenerated if you delete
    it.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Intermediate**：当编译项目资产时创建的临时文件存放在这里。这里的所有内容都是临时的，如果你删除它，它们将被重新生成。'
- en: '**Saved**: Log files, screenshots, and save games land in this directory.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Saved**：日志文件、截图和保存的游戏存档保存在这个目录中。'
- en: 'If you''ve generated a C++ project, you''ll see three additional directories:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你生成了一个C++项目，你会看到另外三个目录：
- en: '**Binaries**: Your project''s built executable and supporting files live here.
    When you build your project in Visual Studio, this is where the resulting executable
    is saved.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Binaries**：项目的构建可执行文件和支持文件存放在这里。当你在Visual Studio中构建项目时，生成的可执行文件就保存在这里。'
- en: '**Build**: Files related to building for specific targets, such as Windows
    64 or Android, live here. These include logs are generated as you build, and certain
    supporting resources such as application icons. You''ll rarely touch the contents
    of this directory.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Build**：与特定目标构建相关的文件，如Windows 64或Android，存放在这里。这些包括在构建过程中生成的日志，以及某些支持资源，如应用程序图标。你很少会接触到这个目录的内容。'
- en: '**Source**: Your C++ files and the C# scripts that govern building them live
    here.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Source**：C++文件和管理构建它们的C#脚本存放在这里。'
- en: The Content directory
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容目录
- en: For the most part, when you work with an Unreal project, you'll be working with
    the contents of the `Content` directory and the `Config` directory. Generally,
    you should do all your management of the Content directory from within Unreal
    Editor, since it can otherwise be easy to break references between objects. We'll
    talk about ways to do this shortly.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，当你使用Unreal项目时，你将使用`Content`目录和`Config`目录中的内容。通常情况下，你应该在Unreal Editor中管理Content目录的所有内容，因为否则很容易破坏对象之间的引用关系。我们将很快讨论如何做到这一点。
- en: The Config directory
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置目录
- en: We should, however, take a moment to look at the `Config` directory.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们应该花点时间来看一下`Config`目录。
- en: Inside this directory are the config files containing the settings for your
    project. All of your engine-related project settings, such as choices about rendering
    quality, are written to the `DefaultEngine.ini` file. When you chose your hardware
    and graphic targets in the Create Project dialog, you were actually just choosing
    which default options to write to that file. Similarly, when you change your project
    settings from the editor, those settings are also written to `DefaultEngine.ini`
    (or `DefaultGame.ini` for certain game-related settings.)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个目录中，包含了包含项目设置的配置文件。所有与引擎相关的项目设置，如渲染质量选择，都写入到`DefaultEngine.ini`文件中。当你在创建项目对话框中选择硬件和图形目标时，实际上只是选择将默认选项写入该文件。同样，当你从编辑器中更改项目设置时，这些设置也会写入`DefaultEngine.ini`（或`DefaultGame.ini`用于某些与游戏相关的设置）。
- en: 'Your `Config` directory will always contain the following two files:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`Config`目录将始终包含以下两个文件：
- en: '`DefaultEngine.ini`: This contains your rendering settings, startup map setting,
    physics settings, and other options that govern how the engine runs.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DefaultEngine.ini`：这个文件包含了你的渲染设置、启动地图设置、物理设置和其他控制引擎运行方式的选项。'
- en: '`DefaultGame.ini`: This, for the most part, contains information about your
    game and copyright information, but it also holds information about how your application
    will be packaged when you prepare it for release on different platforms'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DefaultGame.ini`：大部分包含有关游戏和版权信息的内容，但也包含了关于应用程序在不同平台上发布时如何打包的信息'
- en: When you make changes to your project settings from within the editor, you're
    mostly writing changes to these two files.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在编辑器中更改项目设置时，您主要是将更改写入这两个文件。
- en: 'Other `Config` files may be created depending on what settings you change as
    you build your project:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您在构建项目时更改的设置，可能会创建其他`Config`文件：
- en: '`DefaultInput.ini`: This contains input mappings and settings related to using
    input devices.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DefaultInput.ini`：这包含与使用输入设备相关的输入映射和设置。'
- en: '`DefaultEditor.ini`: This contains settings governing how your editor behaves.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DefaultEditor.ini`：这包含了控制编辑器行为的设置。'
- en: '`DefaultDeviceProfiles.ini`: This contains specific settings for the different
    platforms to which you might release your application.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DefaultDeviceProfiles.ini`：这包含了您可能发布应用程序的不同平台的特定设置。'
- en: You don't have to know about this to use the engine. It's perfectly fine to
    manage your settings entirely from within the editor, but this is another one
    of the great things about Unreal Engine - it doesn't scatter important information
    in weird places. If at some point you do need to figure out what you've set somewhere,
    you know where to look. It's going to be in one of these files.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必了解这些内容就可以使用引擎。完全可以在编辑器内部管理设置，但这也是虚幻引擎的另一个伟大之处之一-它不会将重要信息散布在奇怪的地方。如果您在某个时刻需要弄清楚您在哪里设置了什么，您知道该去哪里找。它将在这些文件中的一个中。
- en: If you're not seeing file extensions such as `.ini` in your Windows explorer,
    open your File Explorer Options control panel, and turn off Hide extensions for
    known file types. It's on by default in Windows, but it will hide useful information
    from you when you're developing.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在Windows资源管理器中看不到`.ini`等文件扩展名，请打开文件资源管理器选项控制面板，并关闭隐藏已知文件类型的扩展名。在Windows中，默认情况下是打开的，但在开发时会隐藏有用的信息。
- en: The Source directory
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源目录
- en: If you've created a C++ project, your project directory will also contain a
    `Source` sub directory. Your C++ source files live here.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您创建了一个C++项目，您的项目目录还将包含一个`Source`子目录。您的C++源文件存放在这里。
- en: The Project file
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目文件
- en: 'We should take a quick look at your project''s `.uproject` file as well. It''s
    actually really just a simple text file with a few bits of information about your
    project, but if you right-click it in Explorer, you''re given three useful options:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该快速查看一下项目的`.uproject`文件。实际上，它只是一个包含有关项目的一些信息的简单文本文件，但如果您在资源管理器中右键单击它，您将获得三个有用的选项：
- en: '**Launch Game**: This will just open up your project in Unreal Editor. Double-clicking
    the `.uproject` file will do this too.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启动游戏**：这只是在虚幻编辑器中打开您的项目。双击`.uproject`文件也可以做到这一点。'
- en: '**Generate Visual Studio project files**: This only applies if you''ve created
    a C++ project. You''ll generally only need to do this if you''ve cleared the Intermediates
    directory, which holds your VS project files, or if you''ve added new source code
    files from outside the editor.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成Visual Studio项目文件**：仅适用于创建了C++项目的情况。通常情况下，只有在清除了保存VS项目文件的Intermediates目录，或者从编辑器外部添加了新的源代码文件时，才需要执行此操作。'
- en: '**Switch Unreal Engine version**: This changes the engine version associated
    with your project. Generally, it''s safer and more advisable to copy and update
    your project in the launcher when going to a new engine version, but if you already
    know it''s safe to do, you can switch it here.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**切换虚幻引擎版本**：这会更改与您的项目关联的引擎版本。通常情况下，当您要切换到新的引擎版本时，最安全和最可取的方法是在启动器中复制并更新您的项目，但如果您已经知道可以安全执行此操作，您可以在此处切换。'
- en: A summary of an Unreal project structure
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个虚幻项目结构的概述
- en: Now that we've taken a quick look at the structure of an Unreal project, we
    should keep it in the back of our minds as we work.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经快速了解了虚幻项目的结构，我们应该在工作时将其牢记在心。
- en: 'Again, at its bare minimum, an Unreal project consists of the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，一个虚幻项目的最基本结构包括以下内容：
- en: 'The `Project` directory:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Project`目录：'
- en: The `Project` file
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Project`文件'
- en: The `Content` directory
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content`目录'
- en: The `Config` directory
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Config`目录'
- en: (C++ only) The `Source` directory
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （仅限C++）`Source`目录
- en: If you need to share a Blueprint-based Unreal project with someone, you only
    need to share the `.uproject` file, the `Content` directory, and the `Config`
    directory. All the rest are dynamically generated when the project runs.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要与他人共享基于蓝图的虚幻项目，您只需要共享`.uproject`文件、`Content`目录和`Config`目录。其余的内容都是在项目运行时动态生成的。
- en: Depending on what you do with your project, other directories may be created
    automatically.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您对项目的操作，可能会自动创建其他目录。
- en: That's really all we wanted to do here—just have a quick look around and see
    the lay of the land before we start adding a lot of content to our project. It
    can make your life easier later on to know where things are.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在这里想要做的一切-只是快速查看一下并了解一下我们开始向项目中添加大量内容之前的情况。知道东西在哪里可以在以后让您的生活更轻松。
- en: Setting your project's settings for VR
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目的VR设置
- en: Let's jump back into the editor and continue setting up our project. Before
    we do anything else, we have a few settings we should take a look at.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到编辑器中，继续设置我们的项目。在做其他任何事情之前，我们应该查看一下一些设置。
- en: 'All of these settings we''re about to discuss affect the way your scene is
    *rendered*:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将讨论的所有这些设置都会影响场景的*渲染*方式：
- en: '![](img/791f2913-9a29-4f8e-8203-371275ccbe1f.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/791f2913-9a29-4f8e-8203-371275ccbe1f.png)'
- en: Rendering is the process of taking the 3D geometry in your scene, looking at
    it through a virtual camera, and turning that geometry into an image that can
    be displayed on your screen or in your headset.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染是将场景中的3D几何图形通过虚拟摄像机观察并将该几何图形转换为可以在屏幕或头戴式显示器上显示的图像的过程。
- en: As we mentioned in [Chapter 1](8ad5a719-9b05-467c-ba9b-4467ce678145.xhtml),
    *Thinking in VR*, VR places much heavier demands on the rendering pipeline than
    traditional flat-screen rendering. Even the lowest-resolution headsets on the
    current market display quite a lot of pixels and have to update extremely quickly.
    As if this weren't challenging enough, we also have two eyes to think about, and
    the views they see aren't exactly the same. This means we're rendering two separate
    views. That's quite a lot to do and not a lot of time in which to do it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Because of this, it's important for a VR developer to understand a bit about
    the rendering options Unreal makes available. Good choices here can get you a
    long way toward your goal of having something that both looks great and runs fast.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Instanced Stereo
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember when we mentioned a moment ago that we needed to render two separate
    views simultaneously in VR? Back in the bad old days (before Unreal 4.11), this
    was literally true. The engine simply ran the entire rendering process twice –
    once for each eye. This was hugely wasteful, since the only real difference between
    the two views was a small shift in the location of the eye looking at it. The
    full cost of a second render pass was being spent to draw something almost identical
    to what had just been drawn.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '**Instanced Stereo** rendering improves on this by allowing the scene to be
    rendered in a single pass. The rendered view is then given to the video hardware
    along with the information it needs to adjust the view for each eye. It''s dramatically
    faster than running the entire pass twice, and you want to make sure you turn
    it on. Let''s do this now.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: If you create a project using the VR template, Instanced Stereo will already
    be turned on for you, but if you're creating a project from scratch, or taking
    an existing project and modifying it to work in VR, you need to remember to do
    this yourself.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'From the editor, open your Project Settings either by hitting the Settings
    button on the editor toolbar and selecting Project Settings..., or by selecting
    Edit | Project Settings:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a0b1bc3-be0e-43c8-9319-f31ab6767c03.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
- en: 'In Project Settings, find the Rendering item in the Engine section. In the
    Rendering page, find the Instanced Stereo option in the VR section and turn it
    on:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/30fdccdc-6501-45a2-917a-0040bbb33c75.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: You'll be asked to restart the engine after you do this. This is going to take
    a little while because your shaders are going to need to recompile.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Round Robin Occlusions
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because we don''t have a lot of time available to get our frame on to the headset,
    we don''t want to waste any of it drawing anything we don''t need to draw. The
    engine chooses which objects to draw through a process called **culling**. It
    uses four main methods to do this, in order, from the fastest and simplest to
    the most complex:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '**Distance** **culling** simply ignores any object beyond a certain distance
    from the camera. This is inexpensive.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View frustum** **culling** ignores objects that aren''t in the camera''s
    current view. This is more expensive than distance culling but still pretty cheap.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Precomputed visibility** allows designers to set up volumes to tell the engine
    explicitly what can be seen from certain locations and what can''t. For instance,
    if you know that a player inside a room can''t possibly see anything outside,
    you can use precomputed visibility volumes to tell the engine that it doesn''t
    even need to bother checking.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic Occlusion** tests in real-time to see whether an actor in the scene
    is blocking another actor. This is relatively expensive, so it''s done only with
    those objects that haven''t been culled by the cheaper methods.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For VR projects, Unreal offers an optimized dynamic occlusion culling method
    called **Round Robin Occlusion**, which only tests occlusion for one eye per frame,
    rather than both. This saves a considerable amount of time, especially in scenes
    with a lot of objects, and works well since the views from each eye are nearly
    identical. The system switches which eye it tests on each frame, which is where
    the name comes from.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s turn it on:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'In Project Settings | Engine | Rendering | VR, check Round Robin Occlusion
    Queries:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/aa9d6904-8586-4825-9704-8c851f1d736e.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
- en: Forward and deferred shading
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now need to make an important choice about the rendering method we want to
    use for our project.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Broadly, there are two ways of drawing a scene, and the difference between them
    mostly boils down to how the objects in the scene are lit. These two methods are
    called **forward** **shading** and **deferred shading**.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: You'll sometimes see these as **forward rendering** and **deferred rendering**,
    or you'll hear people talk about a **forward renderer** or a **deferred renderer**.
    Epic uses the terms interchangeably in its documentation, but they all refer to
    the same things. For our purposes here, we'll stick with the term **forward shading**,
    since that's what the option is called in the editor and it most accurately describes
    what's really different between the two approaches.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '**Shading** is the process of applying light to geometry. This includes highlights,
    surface reflections, shadows, and all the various things light does when it hits
    a material:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71263ea8-b98f-4419-b3f2-49c605cb6c39.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows the same mesh without shading applied, and then
    with shading applied. In the left-hand image, you can see the shape of the object
    and its base color (also commonly called **albedo**), but no shadows, reflections,
    or highlights. The right image has been shaded, so highlights, shadows, and reflections
    are visible.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: We're simplifying things a bit in the descriptions that follow, but, for our
    purposes, this is fine. You really don't need to know every detail of how a rendering
    pipeline works to make good decisions about how to use it. It's just important
    to understand enough to make the right choice for what you need to do.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '**Forward shading **was the original way of drawing 3D scenes through most
    of the history of real-time 3D rendering. In forward shading, each geometric object
    in the scene is shaded as it''s rendered, and each light in the scene is checked
    to see how it might affect it. If you have a lot of objects in your scene and
    a lot of lights, this can turn into a lot of operations. This is why most lighting
    tended to be baked into static lightmaps, and dynamic lights tended to be so rare
    in games in the 1990s and early 2000s. Each dynamic light dramatically added to
    the cost of the scene.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '**Deferred shading**, on the other hand, draws every object in the view, but
    instead of lighting and shading it right then, it writes out a series of images
    that contain information about the materials in the scene, the depth of each pixel,
    and other factors that would affect how the scene is lit. Shading is then performed
    only once, after all this information has been assembled. This is where the name
    comes from—the shading pass has been deferred until after the base pass is complete.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: This collection of buffers is called the **geometric buffer**, or **G-buffer**,
    and the process of building them is called the **base pass**. If you're using
    deferred shading in Unreal Engine (which is the default setting for a new project),
    you can see the contents of the G-buffer by selecting View Mode | Buffer Visualization
    | Overview.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshot:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5bb61418-d4cf-40de-b9e5-7eab637a3df9.png)![](img/cb218924-b241-4bb7-ab11-ecbf42a47927.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
- en: Since the lighting pass happens only once, this is much faster for scenes with
    a lot of dynamic lights, and also allows screen-space effects such as ambient
    occlusion to be handled efficiently. It doesn't, however, do as good a job as
    forward shading with objects that are partially transparent.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the right rendering method for your project
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, sounds like a no-brainer then, right? Deferred shading seems to offer a
    lot of advantages. For rendering outside of VR, this is mostly true, and by the
    late 2000s, deferred shading became the default for pretty much every game engine
    including Unreal.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: VR, however, is a different story. The problem with deferred shading is that
    because of the way it handles information, it's difficult to turn off individual
    aspects of the rendering process. For the most part, it's an all-or-nothing deal.
    This wasn't generally a problem on flat screens—developers were pretty much always
    going to want everything the deferred shader had to offer. Some of these processes,
    though, are just too expensive to run efficiently in VR, or they're calculated
    in screen-space and look bad when they don't match up between the two eyes. In
    VR, you're often going to want the freedom to turn them off.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: When you hear the term *screen-space* what this means is that instead of doing
    the calculations on the object in 3D space, the part of the scene containing the
    object is rendered to 2D (this process is called **rasterization**), and then
    the calculations are performed on the 2D image. This can create a problem in VR,
    because many screen-space calculations won't match between the eyes. You'll usually
    want to avoid using screen-space effects in VR.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: In Unreal 4.14, Epic added forward shading as an option specifically designed
    for VR projects. They also introduced a clustering system that reduced the cost
    of processing lights in the base pass, so it's not nearly as costly as it used
    to be. For most VR projects, it's a good idea to use forward shading.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: There are cases where you may still want to stick with deferred rendering in
    VR—if your scene needs to support a lot of movable lights, or if you know you'll
    need very complicated reflections—but you should seriously consider using forward
    shading for most VR projects.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: You'll almost always want to use forward shading for VR projects. It gives you
    much greater control over which parts of the rendering process you want to do,
    and which ones you want to skip; it handles transparency more easily, and supports
    better anti-aliasing options.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Let's turn it on for our project.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'From your Project Settings | Engine | Rendering, find the Forward Renderer
    section, and turn on Forward Shading. You''ll have to restart the editor after
    you do this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf3e21b6-01ec-4efe-b1ab-3bdf1c6bc093.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: When using forward shading, many expensive material features that would normally
    be included by default need to be turned on explicitly. This is a good thing in
    VR, as it gives you the freedom to use expensive features only where they'll be
    seen. We'll talk later on about doing this when we start creating and modifying
    materials for VR.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: While you can turn forward shading on or off later in your project's development,
    you'll generally want to make a choice and stick with it, as your project's lighting,
    materials, and reflections can differ greatly between the two methods. You don't
    want to put a lot of effort into developing your look, and then make a change
    like this late in development. You'll wind up redoing a lot of work.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Choosing your anti-aliasing method
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One major advantage of using forward shading is that **anti-aliasing** is much
    easier to achieve than it is when using deferred shading. Let's talk about what
    this means and why it matters to us in VR.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'When the renderer draws a scene onto a flat screen, whether it''s a monitor
    or a VR headset, that display actually consists of a grid of tiny squares, called
    **pixels** (short for **picture elements**), and the renderer has to decide what
    color each of them is going to be. This turns into a problem when an object in
    the 3D scene only partly fills a pixel in the 2D space to which it''s going to
    be drawn. The renderer then has to decide whether the pixel should be filled with
    the color of the object or the color of the background. There''s no in-between—it
    has to pick one or the other. What this means in practice is that objects can
    wind up appearing to have jagged edges, especially along diagonal lines that cross
    over a lot of pixel borders. We call this problem **aliasing**:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当渲染器将场景绘制到平面屏幕上（无论是显示器还是VR头显）时，该显示实际上由一组称为**像素**（照片元素）的小方块组成，渲染器必须决定每个像素的颜色。当3D场景中的对象只部分填充2D空间中的像素时，这就成为一个问题。然后，渲染器必须决定像素应该填充对象的颜色还是背景的颜色。没有中间状态-它必须选择其中之一。实际上，这意味着对象可能会出现锯齿状边缘，特别是沿着跨越许多像素边界的对角线。我们称之为**走样**问题：
- en: '![](img/0f71119d-7182-49fb-8f52-d19b572cdc83.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0f71119d-7182-49fb-8f52-d19b572cdc83.png)'
- en: A scene rendered with no anti-aliasing
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 没有抗锯齿渲染的场景
- en: Note the **jaggies** all around the windows in the scene rendered without anti-aliasing.
    These look bad here and will look worse in VR.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，没有抗锯齿渲染的场景中窗户周围的**锯齿**。它们在这里看起来很糟糕，在VR中看起来会更糟糕。
- en: 'The way we solve this is through a process unsurprisingly called **anti-aliasing**.
    Different anti-aliasing methods use a variety of techniques to figure out how
    to soften jagged edges by finding the right color for a pixel to appear to blend
    between the foreground and background colors. This has the effect of smoothing
    jagged edges and removing stair-steps from diagonal lines:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过一个不出所料被称为**抗锯齿**的过程来解决这个问题。不同的抗锯齿方法使用各种技术来找到像素的正确颜色，以使其在前景色和背景色之间呈现混合效果，从而软化锯齿边缘。这样可以平滑锯齿边缘并消除对角线上的阶梯状线条：
- en: '![](img/24a6989b-bc5b-4898-a6de-8bc3e9eedcd2.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/24a6989b-bc5b-4898-a6de-8bc3e9eedcd2.png)'
- en: A scene rendered using multisampling anti-aliasing (MSAA)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多重采样抗锯齿（MSAA）渲染的场景
- en: See how much smoother the windows look when this scene is rendered using multisampling
    anti-aliasing?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 看看使用多重采样抗锯齿渲染时窗户看起来更加平滑的效果？
- en: This is especially important in VR since headset resolutions are still fairly
    limited, so users can generally see the individual pixels. Aliasing that would
    be acceptable on a flat screen may look awful in VR as the user looks around the
    scene and jagged edges crawl and shimmer all over the place. You want to avoid
    this.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这在VR中尤为重要，因为头显的分辨率仍然相对有限，所以用户通常可以看到单个像素。在平面屏幕上可以接受的走样在VR中可能看起来很糟糕，因为用户在场景中观察时，锯齿状边缘会爬行和闪烁。您应该避免这种情况。
- en: 'Fortunately, Unreal Engine gives you three **anti-aliasing methods** to address
    this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，虚幻引擎提供了三种**抗锯齿方法**来解决这个问题：
- en: '**FXAA** stands for **Fast Approximate Anti-Aliasing**. It looks for edges
    in the scene and blends the colors at those edges, and it is smart enough to avoid
    processing areas that don''t have contrasting edges, so it looks great and runs
    pretty quickly. This should be your default choice if you''re using deferred shading
    in VR.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FXAA**代表**快速近似抗锯齿**。它寻找场景中的边缘并混合这些边缘的颜色，并且足够智能以避免处理没有对比较边缘的区域，因此看起来很棒并且运行速度相对较快。如果您在VR中使用延迟渲染，这应该是您的默认选择。'
- en: '**Temporal AA** (**TAA**) works by looking at the previous few frames to make
    decisions about how to anti-alias the current frame. This generally makes it a
    poor choice for VR as the user''s view tends to move quite a lot, and temporal
    AA can create "smearing" effects on fast movements. Even where smearing isn''t
    apparent, it can appear too blurry to be acceptable on a VR headset. Temporal
    AA tends to do a fantastic job on flat screens, but it isn''t a great choice for
    VR.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时域抗锯齿**（**TAA**）通过查看前几帧来决定如何对当前帧进行抗锯齿处理。这通常使其在VR中成为一个糟糕的选择，因为用户的视图往往会移动很多，时域抗锯齿可能会在快速移动时产生“模糊”效果。即使在没有模糊的情况下，它在VR头显上可能看起来太模糊而无法接受。时域抗锯齿通常在平面屏幕上表现出色，但对于VR来说并不是一个很好的选择。'
- en: '**MSAA** stands for **Multisampling Anti-Aliasing**. This method is only available
    when using forward shading, and will give you sharper, better results than FXAA.
    If you''re using forward shading in your project, and you almost always should
    be, this is the anti-aliasing method you should use.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MSAA**代表**多重采样抗锯齿**。此方法仅在使用正向渲染时可用，并且会比FXAA提供更清晰、更好的结果。如果您在项目中使用正向渲染（通常应该使用），这是您应该使用的抗锯齿方法。'
- en: 'Let''s take care of this in our project:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在项目中处理这个问题：
- en: 'From your Project Settings | Engine | Rendering, find the Default Settings
    section, and set the Anti-Aliasing Method to MSAA:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 从项目设置 | 引擎 | 渲染中，找到默认设置部分，并将抗锯齿方法设置为MSAA：
- en: '![](img/13b2165c-a4b6-4d12-989c-db835950042c.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13b2165c-a4b6-4d12-989c-db835950042c.png)'
- en: Most of the time, you won't need to change anything about how your anti-aliasing
    method works, but if you do, read on.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，您不需要改变抗锯齿方法的任何设置，但如果需要，继续阅读。
- en: Modifying MSAA settings
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改MSAA设置
- en: 'This bit is optional. Making adjustments to your anti-aliasing settings is
    an advanced topic, and for most projects you don''t need to do this. If you do
    wind up needing to adjust your MSAA settings, here''s a good way to do it:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分是可选的。调整抗锯齿设置是一个高级主题，对于大多数项目来说，您不需要这样做。如果您确实需要调整MSAA设置，以下是一个很好的方法：
- en: 'Select Window | Developer Tools | Device Profiles to open the Device Profiles
    window:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 选择窗口 | 开发者工具 | 设备配置文件以打开设备配置文件窗口：
- en: '![](img/cd0a435f-0528-4662-8151-5415bf79b47f.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cd0a435f-0528-4662-8151-5415bf79b47f.png)'
- en: From this panel, hit the CVars button in the Windows row.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 从此面板中，点击Windows行中的CVars按钮。
- en: 'From within the resulting dialog, open Console Variables | Rendering. From
    here, you can see all the rendering-related console variables you''re currently
    specifying. If you hit the + sign beside Rendering, you can type `msaa` in the
    search window that appears, and add a value for r.MSAACount. By default, this
    value is set to 4\. Reducing it to 3 or 2 will lower the quality of your anti-aliasing
    but speed it up a bit. Setting it to 1 turns it off. Setting it to 0 turns it
    off and falls back to temporal anti-aliasing:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e1cb2ef-f796-47d9-adba-088f353a2fbe.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
- en: If you've made changes here, hit Save as Default on your Device Profiles window
    to save these settings. They'll be written to a new config file in your project's
    `Configs` directory called `DefaultDeviceProfiles.ini`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Again, changing these values is an advanced topic. We don't advise that you
    modify these until you're comfortable that you understand what they do.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Starting in VR
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's also important to tell our project to start in VR when we run it. You do
    have the option, if you want to build a project that could be run both in VR and
    on a flat screen, to leave this turned off and use the `-vr` command line argument
    when you launch it. Our project is a VR-only project, though, so we want to turn
    this on.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Head to Project Settings | Project | Description | Settings, and set Start in VR
    to True**.**
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Turning off other stray settings you don't need
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In your Rendering | Default Settings, turn off Ambient Occlusion Static Fraction.
    Ambient occlusion is a method for creating those subtle shadows that appear where
    objects touch each other, but they're expensive to calculate and can look awful
    in VR because they're calculated in screen-space. We're not going to go into depth
    on this topic here. You already turned off ambient occlusion when you set your
    project to mobile, scalable 2D/3D, so this is just a stray setting you should
    clear.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Turning off default touch interface (Oculus Go/Samsung Gear)
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're developing for Oculus Go or Samsung gear, you need to turn off the
    default touch interface. Mobile apps ordinarily assume that you'll operate them
    by touching the screen, but of course this isn't going to happen inside your headset.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to Project Settings | Engine | Input, and from within the Mobile section,
    grab the drop-down beside Default Touch Interface and clear it:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/065232e8-8ad9-4ea0-8644-fd59ef932768.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: Configuring your project for Android (Oculus Go/Samsung Gear)
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now need to configure the project to use the Android SDK. We went through
    this process in the last chapter—we just need to set the same settings for this
    project. Here's a quick reminder of what we need to do.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'From Project Settings | Platforms | Android, find the APK Packaging section,
    and hit Configure Now. If you already accepted the SDK license in the previous
    chapter, that button will be disabled – you only have to accept it once:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6bec65a-a0ca-428c-a121-9df26a39efb0.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: 'Then set these settings (as we mentioned in the previous chapter, most guides
    will tell you to use SDK Version 19 as your minimum. This is OK for Samsung Gear,
    but use version 21 for Go):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Minumum SDK Version: 21'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Target SDK Version: 21'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enable FullScreen Immersive on KitKat and above devices: True'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Scroll down to the Advanced APKPackaging section and set this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Configure the AndroidManifest for deployment to Oculus Mobile to True.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying your SDK locations
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Select Project Settings | Platforms | Android SDK, and make sure your SDK locations
    are properly set. If you ran through the instructions in the previous chapter,
    they should be. If not, jump back there and set them up now.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Making sure Mobile HDR is turned off (Oculus Go/Samsung Gear)
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Check your Project Settings | Engine | Rendering | Mobile, and ensure that Mobile
    HDR is turned off.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Mobile Multi-View (Oculus Go/Samsung Gear)
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember back in the section on Instanced Stereo rendering when we discussed
    how wasteful it is to render the entire scene for each eye? The mobile headsets
    have a solution for this too, called **Mobile Multi-View**. Mobile Multi-View
    works pretty much the same way Instanced Stereo rendering does – by rendering
    the scene once for the left eye, and then shifting and adjusting the image for
    the right eye. We want to turn this on.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'In Project Settings | Engine | Rendering | VR, set Mobile Multi-View to true,
    and turn on Mobile Multi-View Direct as well. Oculus doesn''t recommend or support
    using Mobile Multi-View without the Direct option. Turn them both on:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f91aa20-f013-4f16-8334-4fe64eae3e67.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
- en: Monoscopic Far Field Rendering (Oculus Go / Samsung Gear)
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here's the thing about stereo depth perception – we can only see it up to a
    certain distance. Beyond that distance, there's no visible difference between
    a stereo image and a flat image. They look the same to us. We may as well use
    that to our advantage.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'If we set Project Settings | Engine | Rendering | VR | Monoscopic Far Field
    to true, the engine will render any object beyond a specified distance only once,
    which can save significant time on the right sorts of scenes:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/119a0269-3307-4722-ae95-ec1f7ea4e89e.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
- en: By default, the split between mono and stereo rendering happens at 7.5 meters,
    but this is set individually on each map. (The location of this split is called
    the **culling plane**.) This culling plane's distance from the camera is set individually
    for each map. To adjust it, open Window | World Settings, and look for the VR
    section on the settings panel that appears. Adjusting the Mono Culling Distance
    will shift the location of the culling plane.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: For certain objects in your scene, especially large objects, you may need to
    force them to render in mono, if their bounds extend close to the camera even
    though they only ever actually appear far away. In these instances, open the object's
    details and set Rendering | Render in Mono to true. (This option is hidden in
    the Rendering section's advanced options.)
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Project Settings cheat-sheet
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We just ran through a number of settings you should modify when setting up
    your project for VR along with a bit of background for each of them. Just to recap,
    here''s a cheat-sheet of what we changed:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'Project Settings | Engine | Rendering | VR | Instanced Stereo: True'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project Settings | Engine | Rendering | VR | Round Robin Occlusion Queries:
    True'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project Settings | Engine | Rendering | Forward Renderer | Forward Shading:
    True'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project Settings | Engine | Rendering | Default Settings | Anti-Aliasing Method: MSAA
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project Settings | Engine | Rendering | Default Settings | Ambient Occlusion
    Static Fraction: False'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project Settings | Project | Description | Settings | Start in VR: True'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is the mobile VR version:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Project Settings | Engine | Input | Mobile | Default Touch Interface: None'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project Settings | Platforms | Android | APK Packaging: Configure and set the
    settings mentioned
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project Settings | Platforms | Android SDK: Verify that your SDK locations
    are set.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project Settings | Engine | Rendering | Mobile | Mobile HDR: False
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project Settings | Engine | Rendering | VR | Mobile Multi-View: True'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project Settings | Engine | Rendering | VR | Mobile Multi-View Direct: True
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project Settings | Engine | Rendering | VR | Monoscopic Far Field: True
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Again, don't just follow these blindly. For most VR projects, these are the
    settings you're going to want, but that doesn't mean they'll apply to every project
    you ever do.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Decorating our project
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've set up our project's basic settings, let's add some environment
    art so we have something interesting to look at while we work.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Migrating content into a project
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From your **Epic Games Launcher**, open the Learn tab, and search for the `Sun
    Temple` example environment. Hit the Create Project button, and choose a location
    where you''d like to save it:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d20f1d4-3bf5-4fd5-b832-dbeee5f6a55e.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
- en: Let it download. Once the project has finished downloading, open it up. It should
    open up to the Sun Temple map. Now we're going to migrate this map into our existing
    project.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: We could just as easily have downloaded the Sun Temple project and then set
    it up to run in VR. We're doing it this way to give you an opportunity to learn
    about the Migrate... tool. When you need to get assets from one project to another,
    the Migrate tool is the best way to do it.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'In your content browser, select Content | Maps | Sun Temple. Right-click it
    and select Asset Actions | Migrate...:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a3d8ce6-095f-4ecc-a669-1ca60caad6de.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
- en: 'You''re now going to be presented with a list of everything that will be copied
    if you migrate this map. This is the power of the Migrate... tool and is why you
    should use it. When you migrate an asset to another project, Unreal checks for
    everything else that would be needed for that asset to work, and includes it in
    the list of assets to be copied. So, for example, if you''re migrating a mesh,
    the materials and textures used by that mesh will be found automatically and migrated
    too. In our case here, we''re migrating a map, so Unreal will bring everything
    the map relies on into the new project:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/586e8055-c901-4df5-9087-e28f5e09b09e.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
- en: Now you need to choose where you're going to put your migrated content. The
    destination for a migrate operation always has to be the `Content` directory of
    the target project. Navigate to that location and select it. (This is why we mentioned
    at the start of this chapter that it's important to understand the structure of
    an Unreal project directory. You will occasionally need to know where things live
    in it.)
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Once the migration is complete, let's close this project and re-open the project
    to which we just added this map.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: You should now see a Sun Temple map in a Maps directory in your Content browser.
    Let's open it up.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Unreal will probably need to compile lots of shaders if this is the first time
    you've opened this map. (This is one of the reasons why we set up a derived data
    cache in [Chapter 2](24157dc8-09e6-4ff8-9ba2-3e0d0e4709b6.xhtml), *Setting Up
    Your Development Environment*—once you've compiled your shaders, they'll be stored
    in this cache so you won't have to re-compile them when you open other projects.)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: There's a little bit of extra stuff that came across when we migrated this map.
    We're going to get rid of it now so we can focus on the new assets we're creating.
    While we're at it, we're going to take this opportunity to show you a few things
    about managing assets to the content browser that will be important to you as
    you continue developing.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up migrated content
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the Sun Temple map open, open Window | World Settings, and find GameMode
    Override. (We''re going to talk about Game Modes shortly.) Clear it by hitting
    the yellow Reset to Default arrow beside the property:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Any time you see a yellow Reset to Default arrow, hitting it will restore the
    property to its standard setting.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d9b7db8-d5e7-4d45-9c5f-4d45f4e19fd7.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
- en: Save the map.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Deleting assets safely
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now select the `Blueprints` folder inside your content browser. We're going
    to make our own blueprints in a moment, so we don't need these. Delete this folder,
    but pay attention to the confirmation dialog that appears.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'If you see a Force Delete button with a warning, this means the thing you''re
    trying to delete is still in use somewhere. You should almost never just delete
    something that''s still being referenced. (We say *almost* here because once you
    really know what the engine is doing, there are certain circumstances where you
    can push it around a bit, but don''t do this until you''re really sure you know
    what''s going on under the hood.) Instead, find out where the asset is still in
    use, and either change the reference to point to something else, or delete the
    object that''s referencing it, or leave it alone:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4317e44d-90d3-4db7-9b5e-6aed95be82d9.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
- en: 'If it''s safe to delete an object, the dialog will just display a Delete button.
    This means that getting rid of it won''t break anything else:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c99701ac-7519-45e1-a8c8-4da461772ed2.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
- en: In this case, a force delete warning would mean that you either hadn't cleared
    out the GameMode Override from the map's World Settings, or that you hadn't saved
    the map after you did. If you're looking at a simple Delete button, hit it to
    get rid of the folder and its contents.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Moving assets and fixing up redirectors
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's organize what remains. From within your content browser, create a
    new folder for your project. We can call this folder `HelloVR`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: It's a good idea always to create a folder for your project inside the content
    browser. This way, as you migrate more content into your project from other sources,
    or add assets from the marketplace, you'll never be confused about which assets
    belong to your project and which arrived from outside. Similarly, if you migrate
    assets somewhere else, they'll all appear together in the new project's content
    browser. Most developers don't do this. Everybody should. The first time you migrate
    in a plugin and have it dump assets all over existing folders in your contents,
    you'll see why. You can prevent a lot of mess by keeping your own project organized.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Since we've gotten rid of our `Blueprints` folder, we still have two other folders
    from our migrated content that are just sitting out at the content root. Let's
    move them inside our project folder.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Grab the `Maps` folder and drag it into your `HelloVR` folder. When asked whether
    you'd like to move or copy it, choose to move it. Now grab the `Assets` folder
    and do the same.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: But what's this? We've moved the folder but the folder in the old location hasn't
    gone away. Why? The reason for this is that Unreal has left behind a collection
    of **Redirectors**. You should know about these. Let's make them visible.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'From the Filters drop-down beside the search bar, select Filters | Other Filters
    | Show Redirectors:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da04931e-2050-4bb3-9af8-8e0189a29eea.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
- en: Now let's navigate inside that left-behind `Assets` folder, and jump into its
    `Blueprints` folder. There's a **Redirector** in there with the name of a BP_Godray
    blueprint that we moved to a new location. Double-click this redirector, and it
    will take you to the asset's new location. This is what redirectors do. When you
    move assets in Unreal, it's very likely that something else in your project is
    using the asset and pointing to it. Rather than force you to change every asset
    that refers to the thing you're moving right then, Unreal allows you to move it
    without changing the references, and when other objects try to find it in its
    old location, the redirector will just point them to the new location, and you
    can change the location the reference points to later. It's a good system and
    can save you a lot of hassle on a large project.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'You don''t want to leave redirectors lying around if you don''t need them,
    however. To clean up a redirector, right-click on it, and select Fix Up:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb6a39ad-6dd5-4367-92c4-9c4964c5733c.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
- en: What this is going to do is find every asset that's referring to this asset
    in its old location, and replace the references to point to the new location.
    Once this has been done, it deletes the redirector since it's no longer needed.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: This can also be done to every redirector in a folder at once. Let's do this
    next.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll make it easier to see our content browser''s folder structure.
    Hit the Sources Panel button beside your Filters drop-down to open your Sources
    panel:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/69157991-72a5-43fc-8122-8ec7ccff26fa.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
- en: 'This toggles a tree view of your project''s content directory, which can make
    getting around and moving assets much more convenient:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb0e25ef-327f-4471-b3c9-1edb3c6a78ac.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
- en: 'Now that we can see what we''re doing, let''s select the old `Assets` folder
    that contains all the redirectors, right-click it, and select Fix Up Redirectors
    in Folder:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dd042d5c-4931-42d9-823c-52c2bd1f7970.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
- en: Once the operation is complete, you can delete the old `Assets` folder, since
    it's now empty.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: A good way to verify that a folder is empty before you delete it is to right-click
    the folder in your content browser, select Show in Explorer, and from within Explorer,
    select the folder and hit *Alt* + *Enter* to bring up its properties. If it shows
    0 files, it's empty. If there's anything in it, you can dig in and find out what's
    there and whether it's anything you want to keep.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Our `Content` directory now should be pretty well-organized, with everything
    we're using consolidated under our `HelloVR` folder. If you get into the habit
    of keeping your `Content` directory clean while your project is small, you'll
    have a much easier time once it gets large.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Setting a default map
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've brought in our map and cleaned up the extra Blueprints that came
    with it, let's set up our project to load Sun Temple as its default map.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'Under Project Settings | Project | Maps & Modes | Default Maps, use the drop-down
    to set Sun Temple as your Editor Startup Map and your Game Default Map:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b96639e-8031-4e18-accc-c6d2a5672bef.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
- en: This way, when you start your editor or launch the game as a standalone executable,
    it will load directly into this map.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Testing our map on desktop
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at what we''ve got so far. If we''re working on desktop
    VR, we can launch the map in VR and look around. Select the drop-down to the right
    of the Play button on your editor toolbar. Select VR Preview (if VR Preview is
    dimmed, check to be sure that your VR headset is hooked up and its software is
    running):'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e95638a-0ff0-4373-b483-e589c60c9982.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
- en: Kinda nice in here, right?
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: We can't do much yet, and we're not at the right height relative to the floor,
    but it's running and we're ready to begin setting things up.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Testing our map on mobile (Oculus Go/Samsung Gear)
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we'd like to test the map on mobile, there are a few other things we need
    to do.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that we've already set up our project to run on mobile as described,
    let's check first that our mobile device is connected and can be seen.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'Important: If you update your Unreal Engine version, be sure you re-run the
    **CodeWorks for Android** installer at `<Engine Install Location>\Engine\Extras\AndroidWorks\Win64`.
    Building with newer Unreal code and out-of-date Android SDK code can create difficult-to-debug
    errors when you try to run in mobile VR. Remember to keep your CodeWorks up-to-date.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Windows PowerShell and navigate to the `platform-tools` directory in your
    Android SDK directory. By default, this will be `C:\NVPACK\android-sdk-windows\platform-tools`.
    From here, type `./adb devices`. You should see the serial number of your connected
    device here with the word `device` beside it. If this reads *unauthorized* instead,
    you need to accept the connection to your PC from within the headset. If this
    reads *offline*, you may need to restart your `adb` server. Type `./adb kill-server`,
    and then run `./adb devices` again:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b72805c4-0bca-407d-aca0-92289a726f27.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
- en: If you're working on mobile devices, there's no way around the reality that
    you're going to spend a lot of time in PowerShell talking to the device. Take
    the time to learn about ADB especially. When something goes wrong, you're going
    to use ADB to figure out what's happening. Learn more about it here: [https://developer.android.com/studio/command-line/adb](https://developer.android.com/studio/command-line/adb).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: If your `./adb` devices looks good, you should be ready to launch the project
    to the device.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: From your launch drop-down on the editor toolbar, select the Android entry that
    matches the serial number of your device.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: The launch process should begin. As we mentioned in the [Chapter 2](24157dc8-09e6-4ff8-9ba2-3e0d0e4709b6.xhtml),
    *Setting Up Your Development Environment*, expect it to take a while the first
    time you do this.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a game mode and player pawn
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've set up a basic scene and verified that it runs on the platform,
    let's get to work on building in some functionality.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Creating a VR pawn
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we're going to need to do is create a **pawn** to represent
    the player. Pawns are a type of actor that can be controlled by a player or by
    AI. In our case, we're going to create a pawn that our player can control.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Unreal Engine is an **object-oriented** system. This means that the engine is
    organized around discrete items called **objects**. An object consists of **properties**,
    which you can generally see by looking at the Details panel of an item you select
    in the map, and **functions**, which you can often see in the blueprint editor.
    Objects often **inherit** from one another, so a new class of object might be
    created using another class as its parent. This means that the new class would
    take on the attributes and behavior of its parent, but could then change these
    attributes and behaviors or add new ones. An actor, therefore, is a child of the
    object class that adds the capability to be placed in the world. A pawn is a type
    of actor that adds the ability to be controlled by a player or AI. When we create
    our own class using a pawn as a parent, we're setting up that class to take on
    everything a pawn can do, and then changing its behaviors or adding our own.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s navigate to our `Content/HelloVR/Assets/Blueprints` folder in the content
    browser, right-click on any empty space in the folder, and select Create Basic
    Asset | Blueprint Class:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/858848aa-7bc0-4fe4-97db-a6856ca98ff6.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
- en: 'In the dialog that follows, we''ll be asked to select our new blueprint''s
    parent class. Select Pawn:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4bb20538-4d6a-4874-91f4-81d56ace839f.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
- en: A new blueprint asset will be created in our `Blueprints` directory. Let's name
    it `BP_VRPawn`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: It's a good idea to get into the habit of following a **naming convention**
    when you name your assets. A naming convention is a set of rules you follow when
    thinking up a name for a new thing you're creating. By following rules when you
    name objects, you can make it much easier to see what an object is, or to remember
    what you called it. In this instance, we're using the `BP_ prefix` as a reminder
    that our pawn is a blueprint class. A particularly thorough and well-thought-out
    naming convention lives here: [https://github.com/Allar/ue4-style-guide](https://github.com/Allar/ue4-style-guide).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: In a moment, we're going to start modifying our pawn, but, first, we need to
    tell our map to use it.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Creating a game mode
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever Unreal loads up a map, the first thing it does is check to see what
    rules govern the behavior of the map. These rules can specify a number of things,
    but the one we care about right now is what sort of pawn is going to spawn from
    a `Player Start` object. This collection of rules lives in a class called the
    **Game Mode**.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a game mode. Right-click in empty space, create a Blueprint Class,
    and select Game Mode Base as its parent. We'll name it `BP_VRGameMode`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'Double-click our new game mode to open it up, and in its Details section, select
    the Classes | Default Pawn Class drop-down, and select the `BP_VRPawn` class we
    just created:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dcc1d54e-2e3d-446a-b123-1eed8b15b2d1.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
- en: For our purposes right now, this is all we need to do with our game mode. We're
    just using it to specify the pawn class we'd like to load. Compile it and save
    it.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Blueprint is a **compiled** language. Before the code you write can be run by
    the CPU, it needs to be translated into a language the CPU understands. There
    are two main ways this can happen. **Interpreted** languages are translated on-the-fly
    while they're running. This comes with a cost though, since the interpreter needs
    to be running alongside your code and trying to translate it while it runs. It's
    much faster to translate everything offline in a separate process so it's ready
    to go when the CPU needs to run it. This is how compiled languages handle things,
    and when you compile your blueprints, this is what you're doing.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: By default, when blueprints are compiled, they're compiled to a format that's
    then used by a virtual machine that hosts the blueprint code while your application
    is running. This system runs fast, but if you want to squeeze even more speed
    out of it, you have the option to convert them to native C++, which then allows
    them to be compiled to machine code. At this point, they can run as fast as code
    written directly in C++.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Assigning the game mode
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we need to tell our project to use this game mode as its default.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Project Settings, and under Project | Maps & Modes | Default Modes, set
    our Default GameMode to our newly-created game mode:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/902a3a02-d8b9-449c-b4ad-08e8b521d672.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
- en: Now any level that loads in our project will use this GameMode to decide what
    to spawn and what rules to follow when running the scene.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Overriding a GameMode for a specific map
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What if we wanted one of our maps to use a different GameMode? For instance,
    if we set up an entry menu scene, we might want to spawn a pawn designed to interact
    with the menus in place of our default player pawn. Fortunately, this is easy.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'If it isn''t already visible, select Window | World Settings to open up our
    World Settings tab. In World Settings, under Game Mode, set the GameMode Override
    to the new BP_VRGameMode we just created:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66c36f81-840c-4225-abba-4c17be89ae79.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
- en: We've just told the engine to use our new game mode when this map loads up,
    regardless of what GameMode was specified in the project settings.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four places where we can specify what game mode to use:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: You can set it in Project Settings | Maps & Modes | Default Modes | Default
    GameMode. A GameMode specified here will load by default anywhere in your project
    unless something else overrides it.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can set the GameMode Override in an individual map as we've done here. This
    will override the global default game mode from your project settings if it's
    set.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can specify a game mode using the *command-line argument* `?game=MyGameMode`
    when you launch your executable. This, in turn, will override your default game
    mode, and any override set in your map.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In your `DefaultEngine.ini`, you can specify specific game modes to load when
    maps with specific prefixes are loaded. This will override any other specification
    if it's set.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Placing a pawn directly in the world
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While it's generally preferable to use a game mode and a player start object
    to get your player pawn into the world, you don't have to do it this way, and
    you'll occasionally run across existing projects, such as the default VR Template
    project, that don't use a GameMode to set the player pawn.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: In these cases, instead of placing a player start object in your scene where
    you want the player to spawn, drag your pawn blueprint directly into the scene.
    If your scene has an existing player start, get rid of it.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that we said pawns could be controlled by players or AI? You need
    to put your pawn under player control since you don''t have a GameMode doing the
    job for you. Select the pawn you just placed in the level, and in its Details,
    find Pawn | Auto Possess Player, and set the value to Player 0\. This will put
    the pawn under the player''s control when it spawns into the world:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3bccef52-3c9b-4b50-a711-3201d9af0812.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
- en: In general, it's better practice to use a GameMode to specify the player pawn
    class, but you should know that this method exists, because you will see some
    projects use it.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the VR pawn
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've created a VR pawn and set up the game mode to use it, let's modify
    this pawn to set it up appropriately for use in VR. We're going to do this from
    scratch here. Quite often, you'll use the pawn class supplied with the VR template
    when you create a simple VR application, but we don't want you to use this as
    a crutch. It's much better to understand how a pawn is built for VR, so you can
    build it appropriately for what you need it to do.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we're going to do is open up our pawn.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Adding a camera
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the upper-left corner of the blueprint editor view, you should see a Components
    tab. Hit the green +Add Component button, and in the drop-down that appears, select
    Scene to create a Scene Component. Name it `Camera Root`:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b85f1d89-f8a6-42ec-9fd1-04c96caa1d83.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
- en: '**Components** are additional elements that can be added to blueprint objects.
    There''s a wide variety of components available to you, and they all do different
    jobs. Components are organized into a hierarchy, allowing you to attach components
    to other components. You can do quite a lot with this.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Now, create a new Camera component. If the Camera Root scene component was still
    selected when you did this, the Camera component will be created as a child of
    Camera Root. If it isn't, drag it on to Camera Root to set Camera Root as its
    parent.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: It's often a good idea to set a separate root component as we've done here.
    This gives you much more flexibility to change the structure of the actor later,
    or to change rotations or positions of components such as cameras without having
    to adjust the position of the object.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Adding motion controllers
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, select the `DefaultSceneRoot` component, and create a `Motion Controller`
    component. For this one, use the Search Components bar at the top of the Add Component
    menu and type `mot` to narrow the search to the motion-controller component. You
    can save yourself a lot of time by using this search bar. Name this new component
    `MotionController_L` and make sure it's a child of the `DefaultSceneRoot`, and
    not a child of the CameraRoot or the Camera.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'Select `DefaultSceneRoot` and do this again to create a second motion-controller
    component. Name this one `MotionController_R` and again make sure it''s a child
    of the `DefaultSceneRoot`, and not any other component:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c87daa50-4b12-4171-9445-371387149001.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
- en: Your component hierarchy should now look like the preceding screenshot.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on, we need to set a few properties on our motion-controller
    components. Select the `MotionController_R` component, and in its Details panel,
    find the Motion Controller | Motion Source entry. Set it to Right to allow the
    controller to be moved by the right-hand Oculus or Vive controller. While we''re
    at it, ensure that `MotionController_L` is still set to use Left as its motion
    source. It should be this by default:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12f5f1df-ffd0-4bf6-9097-c97bf016ac50.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
- en: 'Let''s also make both of these controllers visible so we can verify that they''re
    working. From each motion-controller component''s Details panel, select Visualization
    | Display Device Model. Turn this on, and verify that Display Model Source is
    still set to Default, which will simply display the model for the motion-controller
    hardware you''re using. We''ll replace our motion-controller display later on,
    but for now, we just want to see them so we can verify that we''ve set them up
    correctly:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a733241e-7736-4a47-ba93-d1621998bf12.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
- en: Setting our tracking origin.
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we need to tell our pawn how it should interpret the location of the headset
    in the tracked space. Look for the My Blueprint tab underneath your pawn''s Components
    tab, and if your EventGraph panel isn''t already visible in the main editing window,
    double-click Graphs | EventGraph in the My Blueprint tab to display it:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/33fb67b1-f07e-4d2d-8626-e4234c1fc9f2.png)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
- en: Once you're in your EventGraph, find the BeginPlay event, or right-click anywhere
    in the graph editor and type `beginplay` in the search dialog that appears to
    find or create a BeginPlay event. Drag an execution line from the BeginPlay event
    and right-click to create a new node. Find Input | Head Mounted Display | Set
    Tracking Origin, or begin typing in the search box to find it. Create a `Set Tracking
    Origin` node, and set its origin to Floor Level if you're using a room-scale VR
    system such as the HTC Vive or Oculus Rift with Touch controllers, or Eye Level if
    you're using a non-room-scale system such as the Oculus Go or older single-camera
    Oculus Rift.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting our Player Start location to the map.
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we need to adjust our Player Start position in the map. Find it in
    your World Outliner (you can use the search bar to find it quicker, and then select
    it and drag it down in the scene until its center intersects the floor (this is
    a bit of a hacky way to align our pawn, and we''ll do a better job of this later,
    but for now it will work):'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8ecafd1-d289-4fd7-8517-f7ebb7f8e834.png)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
- en: Testing in the headset.
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have the building blocks we're going to need to create VR experiences
    in Unreal. We have a project that's been properly set-up to run efficiently in
    VR, and a pawn that may not do much yet, but is ready to be used as a foundation
    for the things we really want to do.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Let's test it. Launch the map using VR preview, and verify that your view seems
    to be at the right height, and that you can see your motion controllers when you
    move your hands. Framerate should be acceptable as well.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Packaging a standalone build
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we distribute an Unreal application to other users, we generally don't
    give them the source files for the editor. Instead, we package the project into
    a stand-alone executable that can be run on the target platform.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a Windows standalone executable.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: 'Select File | Package Project | Windows | Windows (64-bit) to kick off a packaging
    process. You''ll be asked where to put it. Choose a location that makes sense.
    (Often, creating a `Packaged` directory inside your project directory can be reasonable.
    You can put your packaged build wherever you want.) When the build status dialog
    appears, hit Show Output Log so you can see what it''s doing:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5053a3c9-dbca-47d3-a898-74827501f3b7.png)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
- en: Expect this process to take a while.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: Once the process completes, close the editor and check the location where you
    told the system to build your executable. You should see a `WindowsNoEditor` folder
    inside it. Inside that, you should see an executable with your project's name.
    Launch the executable. If you set the Start in VR flag in your Project Settings,
    it should launch directly to your headset.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Congratulations! We covered a lot of ground. In this chapter. We went through
    the process of creating a starting VR project and set it up properly to run well
    on the target hardware. We learned how to decide what settings to use when setting
    up a new project for VR, and how to find our way around inside an Unreal project
    directory. We also learned about a number of important Unreal Engine features
    used in VR development:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Instanced Stereo
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Round Robin Occlusions
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forward Shading
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multisampling Anti-Aliasing (MSAA)
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Mobile] Mobile Multi-View'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Mobile] Monoscopic Far Field Rendering'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We learned how to migrate content from one project to another, and how to clean
    up our `Content` directory once it arrives.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set up a basic VR pawn and set up a game mode to instruct the map
    to load it. In working with the pawn, we learned about how we can use components
    to build complex objects out of simple parts, adding a camera and tracked motion
    controllers. Finally, we set up the first elements of our pawn's blueprint to
    set our tracking origin appropriately for our VR hardware, and tested our map.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to make it possible for the pawn we created
    in this chapter to move through the world. We'll use Blueprints to create a teleport
    movement scheme, and learn how to set up the environment to support it, and then
    we'll move on from there to implement a range of immersive movement schemes as
    well.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
