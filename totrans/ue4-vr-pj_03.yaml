- en: Hello World - Your First VR Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's time to start building! Back in [Chapter 1](8ad5a719-9b05-467c-ba9b-4467ce678145.xhtml),
    *Thinking in VR*, we learned what VR is and what it can do, and we learned a number
    of best practices for its design. Then, in [Chapter 2](24157dc8-09e6-4ff8-9ba2-3e0d0e4709b6.xhtml),
    *Setting up Your Development Environment*, we set up our development environment.
    Now we're ready to start building.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we're going to build a VR project in Unreal from the ground
    up. We're going to take a different approach, though, from most tutorials. Rather
    than just give you a list of steps to follow, for each thing we do we're going
    to talk a bit about what's going on under the hood and why we're doing it this
    way. This is what's really important. If you understand a bit about how these
    systems work, you'll be much better equipped to understand what to do when you
    build your own projects.
  prefs: []
  type: TYPE_NORMAL
- en: As we build our first VR project, we're going to learn a bit about its structure,
    and we'll learn about the specific project settings that apply most to VR development.
    We'll also look at those settings and choices that specifically affect mobile
    VR, and show you what you need to know there. From here, we'll bring a detailed
    scene into our project and learn a bit about how to move assets safely between
    projects and how to manage a project's content. Finally, we'll set up the game
    mode and pawn blueprints we'll need to run a VR project.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a project for VR from scratch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding important settings and choices you need to make when you start
    your project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a project for mobile VR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving content safely between projects and managing content within your project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the basic blueprints you'll need for VR development in Unreal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All right, let's start creating!
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we need to do is create a new project. We created a few quick
    throwaway projects in the previous chapter just to make sure everything was working,
    but now we're ready to begin building for real.
  prefs: []
  type: TYPE_NORMAL
- en: Open your **Epic Games Launcher** if it isn't already open, head to the Library
    tab, and where you see your **Engine Versions**, hit Launch on your most current
    engine version. (You can do this from the Launch button on the left side of the
    launcher as well.)
  prefs: []
  type: TYPE_NORMAL
- en: The Unreal Project Browser will appear. Select the New Project tab, and let's
    select the Blueprint tab and the Blank template to create an empty Blueprint project.
  prefs: []
  type: TYPE_NORMAL
- en: '**Templates** are very useful starting points for Unreal projects. They contain
    simple and useful working foundations of many game types, and much of the time
    when you''re starting a new project, you''ll want to use them. We''re beginning
    with a blank project here so you can see each element as it goes in. You''ll probably
    most commonly use the First Person, Third Person, and VR templates as starting
    points for most projects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a few more choices to make on this dialog, and we should understand
    what they mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f5bc6ebe-5313-4412-9fff-3a203ab665bd.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting your hardware target
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Hardware Target selector gives you two options:'
  prefs: []
  type: TYPE_NORMAL
- en: Desktop / Console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mobile / Tablet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ordinarily, you should choose the correct option for your target platform, but
    when developing for VR, it can be a good idea to select the Mobile / Tablet option
    even if you're developing for desktop, as that option will turn off a few rendering
    options that can be expensive in VR.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, choosing the mobile target rather than the desktop target will
    turn off the following rendering options:'
  prefs: []
  type: TYPE_NORMAL
- en: Separate Translucency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bloom
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ambient Occlusion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting your graphics target
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next choice you need to make is your **Graphics Target**. Again, you have
    two choices here:'
  prefs: []
  type: TYPE_NORMAL
- en: Maximum Quality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalable 3D or 2D
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting Maximum Quality will turn on all of the default high-end rendering
    options Unreal Engine offers. As we've mentioned previously, however, in VR, meeting
    your target framerate is far more important than including detail in your scene.
    For VR development, it's always a good idea to select the Scalable option.
  prefs: []
  type: TYPE_NORMAL
- en: You're better off beginning with everything turned off and turning things on
    as you need them. If you start the other way, with everything turned on, it can
    be difficult to figure out what's killing your framerate and figure out what you
    need to turn off. It's a much better practice to start with your project running
    at a reasonable speed and keep it running quickly than to build something that
    runs poorly and hope that you're somehow going to get it running faster later
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Settings summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For our project, we''re going to go with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Project Template: Blueprint - Blank'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hardware Target: Mobile / Tablet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Graphics Target: Scalable 2D or 3D'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No Starter Content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can leave the Starter Content turned off for now, since we can easily add
    that stuff later when we need it.
  prefs: []
  type: TYPE_NORMAL
- en: Choose where you'd like to save your project and hit Create Project to set it
    up.
  prefs: []
  type: TYPE_NORMAL
- en: Taking a quick look at your project's structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've now created an empty project. Let's take a brief moment to take a look
    at what that actually means.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you navigate Windows Explorer to the location where you saved your project,
    you''ll see that Unreal has created a file there with your project''s name and
    the `.uproject` extension, along with four directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Config**: Configuration files such as `DefaultEngine.ini` and `DefaultGame.ini`
    live here and hold settings for your engine and project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Content**: This is where your project''s assets, such as models, textures,
    materials, and blueprints will live. This is the bulk of your project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intermediate**: Temporary files created when your project''s assets are compiled
    go here. Everything in here is temporary and will be regenerated if you delete
    it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Saved**: Log files, screenshots, and save games land in this directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you''ve generated a C++ project, you''ll see three additional directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Binaries**: Your project''s built executable and supporting files live here.
    When you build your project in Visual Studio, this is where the resulting executable
    is saved.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build**: Files related to building for specific targets, such as Windows
    64 or Android, live here. These include logs are generated as you build, and certain
    supporting resources such as application icons. You''ll rarely touch the contents
    of this directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Source**: Your C++ files and the C# scripts that govern building them live
    here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Content directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the most part, when you work with an Unreal project, you'll be working with
    the contents of the `Content` directory and the `Config` directory. Generally,
    you should do all your management of the Content directory from within Unreal
    Editor, since it can otherwise be easy to break references between objects. We'll
    talk about ways to do this shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The Config directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We should, however, take a moment to look at the `Config` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this directory are the config files containing the settings for your
    project. All of your engine-related project settings, such as choices about rendering
    quality, are written to the `DefaultEngine.ini` file. When you chose your hardware
    and graphic targets in the Create Project dialog, you were actually just choosing
    which default options to write to that file. Similarly, when you change your project
    settings from the editor, those settings are also written to `DefaultEngine.ini`
    (or `DefaultGame.ini` for certain game-related settings.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `Config` directory will always contain the following two files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DefaultEngine.ini`: This contains your rendering settings, startup map setting,
    physics settings, and other options that govern how the engine runs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DefaultGame.ini`: This, for the most part, contains information about your
    game and copyright information, but it also holds information about how your application
    will be packaged when you prepare it for release on different platforms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you make changes to your project settings from within the editor, you're
    mostly writing changes to these two files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other `Config` files may be created depending on what settings you change as
    you build your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DefaultInput.ini`: This contains input mappings and settings related to using
    input devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DefaultEditor.ini`: This contains settings governing how your editor behaves.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DefaultDeviceProfiles.ini`: This contains specific settings for the different
    platforms to which you might release your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You don't have to know about this to use the engine. It's perfectly fine to
    manage your settings entirely from within the editor, but this is another one
    of the great things about Unreal Engine - it doesn't scatter important information
    in weird places. If at some point you do need to figure out what you've set somewhere,
    you know where to look. It's going to be in one of these files.
  prefs: []
  type: TYPE_NORMAL
- en: If you're not seeing file extensions such as `.ini` in your Windows explorer,
    open your File Explorer Options control panel, and turn off Hide extensions for
    known file types. It's on by default in Windows, but it will hide useful information
    from you when you're developing.
  prefs: []
  type: TYPE_NORMAL
- en: The Source directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've created a C++ project, your project directory will also contain a
    `Source` sub directory. Your C++ source files live here.
  prefs: []
  type: TYPE_NORMAL
- en: The Project file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We should take a quick look at your project''s `.uproject` file as well. It''s
    actually really just a simple text file with a few bits of information about your
    project, but if you right-click it in Explorer, you''re given three useful options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Launch Game**: This will just open up your project in Unreal Editor. Double-clicking
    the `.uproject` file will do this too.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generate Visual Studio project files**: This only applies if you''ve created
    a C++ project. You''ll generally only need to do this if you''ve cleared the Intermediates
    directory, which holds your VS project files, or if you''ve added new source code
    files from outside the editor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Switch Unreal Engine version**: This changes the engine version associated
    with your project. Generally, it''s safer and more advisable to copy and update
    your project in the launcher when going to a new engine version, but if you already
    know it''s safe to do, you can switch it here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A summary of an Unreal project structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've taken a quick look at the structure of an Unreal project, we
    should keep it in the back of our minds as we work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, at its bare minimum, an Unreal project consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Project` directory:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Project` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Content` directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Config` directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (C++ only) The `Source` directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need to share a Blueprint-based Unreal project with someone, you only
    need to share the `.uproject` file, the `Content` directory, and the `Config`
    directory. All the rest are dynamically generated when the project runs.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on what you do with your project, other directories may be created
    automatically.
  prefs: []
  type: TYPE_NORMAL
- en: That's really all we wanted to do here—just have a quick look around and see
    the lay of the land before we start adding a lot of content to our project. It
    can make your life easier later on to know where things are.
  prefs: []
  type: TYPE_NORMAL
- en: Setting your project's settings for VR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's jump back into the editor and continue setting up our project. Before
    we do anything else, we have a few settings we should take a look at.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of these settings we''re about to discuss affect the way your scene is
    *rendered*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/791f2913-9a29-4f8e-8203-371275ccbe1f.png)'
  prefs: []
  type: TYPE_IMG
- en: Rendering is the process of taking the 3D geometry in your scene, looking at
    it through a virtual camera, and turning that geometry into an image that can
    be displayed on your screen or in your headset.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned in [Chapter 1](8ad5a719-9b05-467c-ba9b-4467ce678145.xhtml),
    *Thinking in VR*, VR places much heavier demands on the rendering pipeline than
    traditional flat-screen rendering. Even the lowest-resolution headsets on the
    current market display quite a lot of pixels and have to update extremely quickly.
    As if this weren't challenging enough, we also have two eyes to think about, and
    the views they see aren't exactly the same. This means we're rendering two separate
    views. That's quite a lot to do and not a lot of time in which to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this, it's important for a VR developer to understand a bit about
    the rendering options Unreal makes available. Good choices here can get you a
    long way toward your goal of having something that both looks great and runs fast.
  prefs: []
  type: TYPE_NORMAL
- en: Instanced Stereo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember when we mentioned a moment ago that we needed to render two separate
    views simultaneously in VR? Back in the bad old days (before Unreal 4.11), this
    was literally true. The engine simply ran the entire rendering process twice –
    once for each eye. This was hugely wasteful, since the only real difference between
    the two views was a small shift in the location of the eye looking at it. The
    full cost of a second render pass was being spent to draw something almost identical
    to what had just been drawn.
  prefs: []
  type: TYPE_NORMAL
- en: '**Instanced Stereo** rendering improves on this by allowing the scene to be
    rendered in a single pass. The rendered view is then given to the video hardware
    along with the information it needs to adjust the view for each eye. It''s dramatically
    faster than running the entire pass twice, and you want to make sure you turn
    it on. Let''s do this now.'
  prefs: []
  type: TYPE_NORMAL
- en: If you create a project using the VR template, Instanced Stereo will already
    be turned on for you, but if you're creating a project from scratch, or taking
    an existing project and modifying it to work in VR, you need to remember to do
    this yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the editor, open your Project Settings either by hitting the Settings
    button on the editor toolbar and selecting Project Settings..., or by selecting
    Edit | Project Settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a0b1bc3-be0e-43c8-9319-f31ab6767c03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In Project Settings, find the Rendering item in the Engine section. In the
    Rendering page, find the Instanced Stereo option in the VR section and turn it
    on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/30fdccdc-6501-45a2-917a-0040bbb33c75.png)'
  prefs: []
  type: TYPE_IMG
- en: You'll be asked to restart the engine after you do this. This is going to take
    a little while because your shaders are going to need to recompile.
  prefs: []
  type: TYPE_NORMAL
- en: Round Robin Occlusions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because we don''t have a lot of time available to get our frame on to the headset,
    we don''t want to waste any of it drawing anything we don''t need to draw. The
    engine chooses which objects to draw through a process called **culling**. It
    uses four main methods to do this, in order, from the fastest and simplest to
    the most complex:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Distance** **culling** simply ignores any object beyond a certain distance
    from the camera. This is inexpensive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View frustum** **culling** ignores objects that aren''t in the camera''s
    current view. This is more expensive than distance culling but still pretty cheap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Precomputed visibility** allows designers to set up volumes to tell the engine
    explicitly what can be seen from certain locations and what can''t. For instance,
    if you know that a player inside a room can''t possibly see anything outside,
    you can use precomputed visibility volumes to tell the engine that it doesn''t
    even need to bother checking.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic Occlusion** tests in real-time to see whether an actor in the scene
    is blocking another actor. This is relatively expensive, so it''s done only with
    those objects that haven''t been culled by the cheaper methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For VR projects, Unreal offers an optimized dynamic occlusion culling method
    called **Round Robin Occlusion**, which only tests occlusion for one eye per frame,
    rather than both. This saves a considerable amount of time, especially in scenes
    with a lot of objects, and works well since the views from each eye are nearly
    identical. The system switches which eye it tests on each frame, which is where
    the name comes from.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s turn it on:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Project Settings | Engine | Rendering | VR, check Round Robin Occlusion
    Queries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/aa9d6904-8586-4825-9704-8c851f1d736e.png)'
  prefs: []
  type: TYPE_IMG
- en: Forward and deferred shading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now need to make an important choice about the rendering method we want to
    use for our project.
  prefs: []
  type: TYPE_NORMAL
- en: Broadly, there are two ways of drawing a scene, and the difference between them
    mostly boils down to how the objects in the scene are lit. These two methods are
    called **forward** **shading** and **deferred shading**.
  prefs: []
  type: TYPE_NORMAL
- en: You'll sometimes see these as **forward rendering** and **deferred rendering**,
    or you'll hear people talk about a **forward renderer** or a **deferred renderer**.
    Epic uses the terms interchangeably in its documentation, but they all refer to
    the same things. For our purposes here, we'll stick with the term **forward shading**,
    since that's what the option is called in the editor and it most accurately describes
    what's really different between the two approaches.
  prefs: []
  type: TYPE_NORMAL
- en: '**Shading** is the process of applying light to geometry. This includes highlights,
    surface reflections, shadows, and all the various things light does when it hits
    a material:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71263ea8-b98f-4419-b3f2-49c605cb6c39.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows the same mesh without shading applied, and then
    with shading applied. In the left-hand image, you can see the shape of the object
    and its base color (also commonly called **albedo**), but no shadows, reflections,
    or highlights. The right image has been shaded, so highlights, shadows, and reflections
    are visible.
  prefs: []
  type: TYPE_NORMAL
- en: We're simplifying things a bit in the descriptions that follow, but, for our
    purposes, this is fine. You really don't need to know every detail of how a rendering
    pipeline works to make good decisions about how to use it. It's just important
    to understand enough to make the right choice for what you need to do.
  prefs: []
  type: TYPE_NORMAL
- en: '**Forward shading **was the original way of drawing 3D scenes through most
    of the history of real-time 3D rendering. In forward shading, each geometric object
    in the scene is shaded as it''s rendered, and each light in the scene is checked
    to see how it might affect it. If you have a lot of objects in your scene and
    a lot of lights, this can turn into a lot of operations. This is why most lighting
    tended to be baked into static lightmaps, and dynamic lights tended to be so rare
    in games in the 1990s and early 2000s. Each dynamic light dramatically added to
    the cost of the scene.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Deferred shading**, on the other hand, draws every object in the view, but
    instead of lighting and shading it right then, it writes out a series of images
    that contain information about the materials in the scene, the depth of each pixel,
    and other factors that would affect how the scene is lit. Shading is then performed
    only once, after all this information has been assembled. This is where the name
    comes from—the shading pass has been deferred until after the base pass is complete.'
  prefs: []
  type: TYPE_NORMAL
- en: This collection of buffers is called the **geometric buffer**, or **G-buffer**,
    and the process of building them is called the **base pass**. If you're using
    deferred shading in Unreal Engine (which is the default setting for a new project),
    you can see the contents of the G-buffer by selecting View Mode | Buffer Visualization
    | Overview.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5bb61418-d4cf-40de-b9e5-7eab637a3df9.png)![](img/cb218924-b241-4bb7-ab11-ecbf42a47927.png)'
  prefs: []
  type: TYPE_IMG
- en: Since the lighting pass happens only once, this is much faster for scenes with
    a lot of dynamic lights, and also allows screen-space effects such as ambient
    occlusion to be handled efficiently. It doesn't, however, do as good a job as
    forward shading with objects that are partially transparent.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the right rendering method for your project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, sounds like a no-brainer then, right? Deferred shading seems to offer a
    lot of advantages. For rendering outside of VR, this is mostly true, and by the
    late 2000s, deferred shading became the default for pretty much every game engine
    including Unreal.
  prefs: []
  type: TYPE_NORMAL
- en: VR, however, is a different story. The problem with deferred shading is that
    because of the way it handles information, it's difficult to turn off individual
    aspects of the rendering process. For the most part, it's an all-or-nothing deal.
    This wasn't generally a problem on flat screens—developers were pretty much always
    going to want everything the deferred shader had to offer. Some of these processes,
    though, are just too expensive to run efficiently in VR, or they're calculated
    in screen-space and look bad when they don't match up between the two eyes. In
    VR, you're often going to want the freedom to turn them off.
  prefs: []
  type: TYPE_NORMAL
- en: When you hear the term *screen-space* what this means is that instead of doing
    the calculations on the object in 3D space, the part of the scene containing the
    object is rendered to 2D (this process is called **rasterization**), and then
    the calculations are performed on the 2D image. This can create a problem in VR,
    because many screen-space calculations won't match between the eyes. You'll usually
    want to avoid using screen-space effects in VR.
  prefs: []
  type: TYPE_NORMAL
- en: In Unreal 4.14, Epic added forward shading as an option specifically designed
    for VR projects. They also introduced a clustering system that reduced the cost
    of processing lights in the base pass, so it's not nearly as costly as it used
    to be. For most VR projects, it's a good idea to use forward shading.
  prefs: []
  type: TYPE_NORMAL
- en: There are cases where you may still want to stick with deferred rendering in
    VR—if your scene needs to support a lot of movable lights, or if you know you'll
    need very complicated reflections—but you should seriously consider using forward
    shading for most VR projects.
  prefs: []
  type: TYPE_NORMAL
- en: You'll almost always want to use forward shading for VR projects. It gives you
    much greater control over which parts of the rendering process you want to do,
    and which ones you want to skip; it handles transparency more easily, and supports
    better anti-aliasing options.
  prefs: []
  type: TYPE_NORMAL
- en: Let's turn it on for our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'From your Project Settings | Engine | Rendering, find the Forward Renderer
    section, and turn on Forward Shading. You''ll have to restart the editor after
    you do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf3e21b6-01ec-4efe-b1ab-3bdf1c6bc093.png)'
  prefs: []
  type: TYPE_IMG
- en: When using forward shading, many expensive material features that would normally
    be included by default need to be turned on explicitly. This is a good thing in
    VR, as it gives you the freedom to use expensive features only where they'll be
    seen. We'll talk later on about doing this when we start creating and modifying
    materials for VR.
  prefs: []
  type: TYPE_NORMAL
- en: While you can turn forward shading on or off later in your project's development,
    you'll generally want to make a choice and stick with it, as your project's lighting,
    materials, and reflections can differ greatly between the two methods. You don't
    want to put a lot of effort into developing your look, and then make a change
    like this late in development. You'll wind up redoing a lot of work.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing your anti-aliasing method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One major advantage of using forward shading is that **anti-aliasing** is much
    easier to achieve than it is when using deferred shading. Let's talk about what
    this means and why it matters to us in VR.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the renderer draws a scene onto a flat screen, whether it''s a monitor
    or a VR headset, that display actually consists of a grid of tiny squares, called
    **pixels** (short for **picture elements**), and the renderer has to decide what
    color each of them is going to be. This turns into a problem when an object in
    the 3D scene only partly fills a pixel in the 2D space to which it''s going to
    be drawn. The renderer then has to decide whether the pixel should be filled with
    the color of the object or the color of the background. There''s no in-between—it
    has to pick one or the other. What this means in practice is that objects can
    wind up appearing to have jagged edges, especially along diagonal lines that cross
    over a lot of pixel borders. We call this problem **aliasing**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0f71119d-7182-49fb-8f52-d19b572cdc83.png)'
  prefs: []
  type: TYPE_IMG
- en: A scene rendered with no anti-aliasing
  prefs: []
  type: TYPE_NORMAL
- en: Note the **jaggies** all around the windows in the scene rendered without anti-aliasing.
    These look bad here and will look worse in VR.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way we solve this is through a process unsurprisingly called **anti-aliasing**.
    Different anti-aliasing methods use a variety of techniques to figure out how
    to soften jagged edges by finding the right color for a pixel to appear to blend
    between the foreground and background colors. This has the effect of smoothing
    jagged edges and removing stair-steps from diagonal lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/24a6989b-bc5b-4898-a6de-8bc3e9eedcd2.png)'
  prefs: []
  type: TYPE_IMG
- en: A scene rendered using multisampling anti-aliasing (MSAA)
  prefs: []
  type: TYPE_NORMAL
- en: See how much smoother the windows look when this scene is rendered using multisampling
    anti-aliasing?
  prefs: []
  type: TYPE_NORMAL
- en: This is especially important in VR since headset resolutions are still fairly
    limited, so users can generally see the individual pixels. Aliasing that would
    be acceptable on a flat screen may look awful in VR as the user looks around the
    scene and jagged edges crawl and shimmer all over the place. You want to avoid
    this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, Unreal Engine gives you three **anti-aliasing methods** to address
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**FXAA** stands for **Fast Approximate Anti-Aliasing**. It looks for edges
    in the scene and blends the colors at those edges, and it is smart enough to avoid
    processing areas that don''t have contrasting edges, so it looks great and runs
    pretty quickly. This should be your default choice if you''re using deferred shading
    in VR.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Temporal AA** (**TAA**) works by looking at the previous few frames to make
    decisions about how to anti-alias the current frame. This generally makes it a
    poor choice for VR as the user''s view tends to move quite a lot, and temporal
    AA can create "smearing" effects on fast movements. Even where smearing isn''t
    apparent, it can appear too blurry to be acceptable on a VR headset. Temporal
    AA tends to do a fantastic job on flat screens, but it isn''t a great choice for
    VR.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MSAA** stands for **Multisampling Anti-Aliasing**. This method is only available
    when using forward shading, and will give you sharper, better results than FXAA.
    If you''re using forward shading in your project, and you almost always should
    be, this is the anti-aliasing method you should use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take care of this in our project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From your Project Settings | Engine | Rendering, find the Default Settings
    section, and set the Anti-Aliasing Method to MSAA:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13b2165c-a4b6-4d12-989c-db835950042c.png)'
  prefs: []
  type: TYPE_IMG
- en: Most of the time, you won't need to change anything about how your anti-aliasing
    method works, but if you do, read on.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying MSAA settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This bit is optional. Making adjustments to your anti-aliasing settings is
    an advanced topic, and for most projects you don''t need to do this. If you do
    wind up needing to adjust your MSAA settings, here''s a good way to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select Window | Developer Tools | Device Profiles to open the Device Profiles
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cd0a435f-0528-4662-8151-5415bf79b47f.png)'
  prefs: []
  type: TYPE_IMG
- en: From this panel, hit the CVars button in the Windows row.
  prefs: []
  type: TYPE_NORMAL
- en: 'From within the resulting dialog, open Console Variables | Rendering. From
    here, you can see all the rendering-related console variables you''re currently
    specifying. If you hit the + sign beside Rendering, you can type `msaa` in the
    search window that appears, and add a value for r.MSAACount. By default, this
    value is set to 4\. Reducing it to 3 or 2 will lower the quality of your anti-aliasing
    but speed it up a bit. Setting it to 1 turns it off. Setting it to 0 turns it
    off and falls back to temporal anti-aliasing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e1cb2ef-f796-47d9-adba-088f353a2fbe.png)'
  prefs: []
  type: TYPE_IMG
- en: If you've made changes here, hit Save as Default on your Device Profiles window
    to save these settings. They'll be written to a new config file in your project's
    `Configs` directory called `DefaultDeviceProfiles.ini`.
  prefs: []
  type: TYPE_NORMAL
- en: Again, changing these values is an advanced topic. We don't advise that you
    modify these until you're comfortable that you understand what they do.
  prefs: []
  type: TYPE_NORMAL
- en: Starting in VR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's also important to tell our project to start in VR when we run it. You do
    have the option, if you want to build a project that could be run both in VR and
    on a flat screen, to leave this turned off and use the `-vr` command line argument
    when you launch it. Our project is a VR-only project, though, so we want to turn
    this on.
  prefs: []
  type: TYPE_NORMAL
- en: Head to Project Settings | Project | Description | Settings, and set Start in VR
    to True**.**
  prefs: []
  type: TYPE_NORMAL
- en: Turning off other stray settings you don't need
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In your Rendering | Default Settings, turn off Ambient Occlusion Static Fraction.
    Ambient occlusion is a method for creating those subtle shadows that appear where
    objects touch each other, but they're expensive to calculate and can look awful
    in VR because they're calculated in screen-space. We're not going to go into depth
    on this topic here. You already turned off ambient occlusion when you set your
    project to mobile, scalable 2D/3D, so this is just a stray setting you should
    clear.
  prefs: []
  type: TYPE_NORMAL
- en: Turning off default touch interface (Oculus Go/Samsung Gear)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're developing for Oculus Go or Samsung gear, you need to turn off the
    default touch interface. Mobile apps ordinarily assume that you'll operate them
    by touching the screen, but of course this isn't going to happen inside your headset.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to Project Settings | Engine | Input, and from within the Mobile section,
    grab the drop-down beside Default Touch Interface and clear it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/065232e8-8ad9-4ea0-8644-fd59ef932768.png)'
  prefs: []
  type: TYPE_IMG
- en: Configuring your project for Android (Oculus Go/Samsung Gear)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now need to configure the project to use the Android SDK. We went through
    this process in the last chapter—we just need to set the same settings for this
    project. Here's a quick reminder of what we need to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'From Project Settings | Platforms | Android, find the APK Packaging section,
    and hit Configure Now. If you already accepted the SDK license in the previous
    chapter, that button will be disabled – you only have to accept it once:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6bec65a-a0ca-428c-a121-9df26a39efb0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then set these settings (as we mentioned in the previous chapter, most guides
    will tell you to use SDK Version 19 as your minimum. This is OK for Samsung Gear,
    but use version 21 for Go):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Minumum SDK Version: 21'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Target SDK Version: 21'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enable FullScreen Immersive on KitKat and above devices: True'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Scroll down to the Advanced APKPackaging section and set this:'
  prefs: []
  type: TYPE_NORMAL
- en: Configure the AndroidManifest for deployment to Oculus Mobile to True.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying your SDK locations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Select Project Settings | Platforms | Android SDK, and make sure your SDK locations
    are properly set. If you ran through the instructions in the previous chapter,
    they should be. If not, jump back there and set them up now.
  prefs: []
  type: TYPE_NORMAL
- en: Making sure Mobile HDR is turned off (Oculus Go/Samsung Gear)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Check your Project Settings | Engine | Rendering | Mobile, and ensure that Mobile
    HDR is turned off.
  prefs: []
  type: TYPE_NORMAL
- en: Mobile Multi-View (Oculus Go/Samsung Gear)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember back in the section on Instanced Stereo rendering when we discussed
    how wasteful it is to render the entire scene for each eye? The mobile headsets
    have a solution for this too, called **Mobile Multi-View**. Mobile Multi-View
    works pretty much the same way Instanced Stereo rendering does – by rendering
    the scene once for the left eye, and then shifting and adjusting the image for
    the right eye. We want to turn this on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Project Settings | Engine | Rendering | VR, set Mobile Multi-View to true,
    and turn on Mobile Multi-View Direct as well. Oculus doesn''t recommend or support
    using Mobile Multi-View without the Direct option. Turn them both on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f91aa20-f013-4f16-8334-4fe64eae3e67.png)'
  prefs: []
  type: TYPE_IMG
- en: Monoscopic Far Field Rendering (Oculus Go / Samsung Gear)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here's the thing about stereo depth perception – we can only see it up to a
    certain distance. Beyond that distance, there's no visible difference between
    a stereo image and a flat image. They look the same to us. We may as well use
    that to our advantage.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we set Project Settings | Engine | Rendering | VR | Monoscopic Far Field
    to true, the engine will render any object beyond a specified distance only once,
    which can save significant time on the right sorts of scenes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/119a0269-3307-4722-ae95-ec1f7ea4e89e.png)'
  prefs: []
  type: TYPE_IMG
- en: By default, the split between mono and stereo rendering happens at 7.5 meters,
    but this is set individually on each map. (The location of this split is called
    the **culling plane**.) This culling plane's distance from the camera is set individually
    for each map. To adjust it, open Window | World Settings, and look for the VR
    section on the settings panel that appears. Adjusting the Mono Culling Distance
    will shift the location of the culling plane.
  prefs: []
  type: TYPE_NORMAL
- en: For certain objects in your scene, especially large objects, you may need to
    force them to render in mono, if their bounds extend close to the camera even
    though they only ever actually appear far away. In these instances, open the object's
    details and set Rendering | Render in Mono to true. (This option is hidden in
    the Rendering section's advanced options.)
  prefs: []
  type: TYPE_NORMAL
- en: Project Settings cheat-sheet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We just ran through a number of settings you should modify when setting up
    your project for VR along with a bit of background for each of them. Just to recap,
    here''s a cheat-sheet of what we changed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Project Settings | Engine | Rendering | VR | Instanced Stereo: True'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project Settings | Engine | Rendering | VR | Round Robin Occlusion Queries:
    True'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project Settings | Engine | Rendering | Forward Renderer | Forward Shading:
    True'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project Settings | Engine | Rendering | Default Settings | Anti-Aliasing Method: MSAA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project Settings | Engine | Rendering | Default Settings | Ambient Occlusion
    Static Fraction: False'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project Settings | Project | Description | Settings | Start in VR: True'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is the mobile VR version:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Project Settings | Engine | Input | Mobile | Default Touch Interface: None'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project Settings | Platforms | Android | APK Packaging: Configure and set the
    settings mentioned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project Settings | Platforms | Android SDK: Verify that your SDK locations
    are set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project Settings | Engine | Rendering | Mobile | Mobile HDR: False
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project Settings | Engine | Rendering | VR | Mobile Multi-View: True'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project Settings | Engine | Rendering | VR | Mobile Multi-View Direct: True
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project Settings | Engine | Rendering | VR | Monoscopic Far Field: True
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Again, don't just follow these blindly. For most VR projects, these are the
    settings you're going to want, but that doesn't mean they'll apply to every project
    you ever do.
  prefs: []
  type: TYPE_NORMAL
- en: Decorating our project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've set up our project's basic settings, let's add some environment
    art so we have something interesting to look at while we work.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating content into a project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From your **Epic Games Launcher**, open the Learn tab, and search for the `Sun
    Temple` example environment. Hit the Create Project button, and choose a location
    where you''d like to save it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d20f1d4-3bf5-4fd5-b832-dbeee5f6a55e.png)'
  prefs: []
  type: TYPE_IMG
- en: Let it download. Once the project has finished downloading, open it up. It should
    open up to the Sun Temple map. Now we're going to migrate this map into our existing
    project.
  prefs: []
  type: TYPE_NORMAL
- en: We could just as easily have downloaded the Sun Temple project and then set
    it up to run in VR. We're doing it this way to give you an opportunity to learn
    about the Migrate... tool. When you need to get assets from one project to another,
    the Migrate tool is the best way to do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your content browser, select Content | Maps | Sun Temple. Right-click it
    and select Asset Actions | Migrate...:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a3d8ce6-095f-4ecc-a669-1ca60caad6de.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You''re now going to be presented with a list of everything that will be copied
    if you migrate this map. This is the power of the Migrate... tool and is why you
    should use it. When you migrate an asset to another project, Unreal checks for
    everything else that would be needed for that asset to work, and includes it in
    the list of assets to be copied. So, for example, if you''re migrating a mesh,
    the materials and textures used by that mesh will be found automatically and migrated
    too. In our case here, we''re migrating a map, so Unreal will bring everything
    the map relies on into the new project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/586e8055-c901-4df5-9087-e28f5e09b09e.png)'
  prefs: []
  type: TYPE_IMG
- en: Now you need to choose where you're going to put your migrated content. The
    destination for a migrate operation always has to be the `Content` directory of
    the target project. Navigate to that location and select it. (This is why we mentioned
    at the start of this chapter that it's important to understand the structure of
    an Unreal project directory. You will occasionally need to know where things live
    in it.)
  prefs: []
  type: TYPE_NORMAL
- en: Once the migration is complete, let's close this project and re-open the project
    to which we just added this map.
  prefs: []
  type: TYPE_NORMAL
- en: You should now see a Sun Temple map in a Maps directory in your Content browser.
    Let's open it up.
  prefs: []
  type: TYPE_NORMAL
- en: Unreal will probably need to compile lots of shaders if this is the first time
    you've opened this map. (This is one of the reasons why we set up a derived data
    cache in [Chapter 2](24157dc8-09e6-4ff8-9ba2-3e0d0e4709b6.xhtml), *Setting Up
    Your Development Environment*—once you've compiled your shaders, they'll be stored
    in this cache so you won't have to re-compile them when you open other projects.)
  prefs: []
  type: TYPE_NORMAL
- en: There's a little bit of extra stuff that came across when we migrated this map.
    We're going to get rid of it now so we can focus on the new assets we're creating.
    While we're at it, we're going to take this opportunity to show you a few things
    about managing assets to the content browser that will be important to you as
    you continue developing.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up migrated content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the Sun Temple map open, open Window | World Settings, and find GameMode
    Override. (We''re going to talk about Game Modes shortly.) Clear it by hitting
    the yellow Reset to Default arrow beside the property:'
  prefs: []
  type: TYPE_NORMAL
- en: Any time you see a yellow Reset to Default arrow, hitting it will restore the
    property to its standard setting.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d9b7db8-d5e7-4d45-9c5f-4d45f4e19fd7.png)'
  prefs: []
  type: TYPE_IMG
- en: Save the map.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting assets safely
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now select the `Blueprints` folder inside your content browser. We're going
    to make our own blueprints in a moment, so we don't need these. Delete this folder,
    but pay attention to the confirmation dialog that appears.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you see a Force Delete button with a warning, this means the thing you''re
    trying to delete is still in use somewhere. You should almost never just delete
    something that''s still being referenced. (We say *almost* here because once you
    really know what the engine is doing, there are certain circumstances where you
    can push it around a bit, but don''t do this until you''re really sure you know
    what''s going on under the hood.) Instead, find out where the asset is still in
    use, and either change the reference to point to something else, or delete the
    object that''s referencing it, or leave it alone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4317e44d-90d3-4db7-9b5e-6aed95be82d9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If it''s safe to delete an object, the dialog will just display a Delete button.
    This means that getting rid of it won''t break anything else:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c99701ac-7519-45e1-a8c8-4da461772ed2.png)'
  prefs: []
  type: TYPE_IMG
- en: In this case, a force delete warning would mean that you either hadn't cleared
    out the GameMode Override from the map's World Settings, or that you hadn't saved
    the map after you did. If you're looking at a simple Delete button, hit it to
    get rid of the folder and its contents.
  prefs: []
  type: TYPE_NORMAL
- en: Moving assets and fixing up redirectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's organize what remains. From within your content browser, create a
    new folder for your project. We can call this folder `HelloVR`.
  prefs: []
  type: TYPE_NORMAL
- en: It's a good idea always to create a folder for your project inside the content
    browser. This way, as you migrate more content into your project from other sources,
    or add assets from the marketplace, you'll never be confused about which assets
    belong to your project and which arrived from outside. Similarly, if you migrate
    assets somewhere else, they'll all appear together in the new project's content
    browser. Most developers don't do this. Everybody should. The first time you migrate
    in a plugin and have it dump assets all over existing folders in your contents,
    you'll see why. You can prevent a lot of mess by keeping your own project organized.
  prefs: []
  type: TYPE_NORMAL
- en: Since we've gotten rid of our `Blueprints` folder, we still have two other folders
    from our migrated content that are just sitting out at the content root. Let's
    move them inside our project folder.
  prefs: []
  type: TYPE_NORMAL
- en: Grab the `Maps` folder and drag it into your `HelloVR` folder. When asked whether
    you'd like to move or copy it, choose to move it. Now grab the `Assets` folder
    and do the same.
  prefs: []
  type: TYPE_NORMAL
- en: But what's this? We've moved the folder but the folder in the old location hasn't
    gone away. Why? The reason for this is that Unreal has left behind a collection
    of **Redirectors**. You should know about these. Let's make them visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the Filters drop-down beside the search bar, select Filters | Other Filters
    | Show Redirectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da04931e-2050-4bb3-9af8-8e0189a29eea.png)'
  prefs: []
  type: TYPE_IMG
- en: Now let's navigate inside that left-behind `Assets` folder, and jump into its
    `Blueprints` folder. There's a **Redirector** in there with the name of a BP_Godray
    blueprint that we moved to a new location. Double-click this redirector, and it
    will take you to the asset's new location. This is what redirectors do. When you
    move assets in Unreal, it's very likely that something else in your project is
    using the asset and pointing to it. Rather than force you to change every asset
    that refers to the thing you're moving right then, Unreal allows you to move it
    without changing the references, and when other objects try to find it in its
    old location, the redirector will just point them to the new location, and you
    can change the location the reference points to later. It's a good system and
    can save you a lot of hassle on a large project.
  prefs: []
  type: TYPE_NORMAL
- en: 'You don''t want to leave redirectors lying around if you don''t need them,
    however. To clean up a redirector, right-click on it, and select Fix Up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb6a39ad-6dd5-4367-92c4-9c4964c5733c.png)'
  prefs: []
  type: TYPE_IMG
- en: What this is going to do is find every asset that's referring to this asset
    in its old location, and replace the references to point to the new location.
    Once this has been done, it deletes the redirector since it's no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: This can also be done to every redirector in a folder at once. Let's do this
    next.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll make it easier to see our content browser''s folder structure.
    Hit the Sources Panel button beside your Filters drop-down to open your Sources
    panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/69157991-72a5-43fc-8122-8ec7ccff26fa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This toggles a tree view of your project''s content directory, which can make
    getting around and moving assets much more convenient:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb0e25ef-327f-4471-b3c9-1edb3c6a78ac.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we can see what we''re doing, let''s select the old `Assets` folder
    that contains all the redirectors, right-click it, and select Fix Up Redirectors
    in Folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dd042d5c-4931-42d9-823c-52c2bd1f7970.png)'
  prefs: []
  type: TYPE_IMG
- en: Once the operation is complete, you can delete the old `Assets` folder, since
    it's now empty.
  prefs: []
  type: TYPE_NORMAL
- en: A good way to verify that a folder is empty before you delete it is to right-click
    the folder in your content browser, select Show in Explorer, and from within Explorer,
    select the folder and hit *Alt* + *Enter* to bring up its properties. If it shows
    0 files, it's empty. If there's anything in it, you can dig in and find out what's
    there and whether it's anything you want to keep.
  prefs: []
  type: TYPE_NORMAL
- en: Our `Content` directory now should be pretty well-organized, with everything
    we're using consolidated under our `HelloVR` folder. If you get into the habit
    of keeping your `Content` directory clean while your project is small, you'll
    have a much easier time once it gets large.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a default map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've brought in our map and cleaned up the extra Blueprints that came
    with it, let's set up our project to load Sun Temple as its default map.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under Project Settings | Project | Maps & Modes | Default Maps, use the drop-down
    to set Sun Temple as your Editor Startup Map and your Game Default Map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b96639e-8031-4e18-accc-c6d2a5672bef.png)'
  prefs: []
  type: TYPE_IMG
- en: This way, when you start your editor or launch the game as a standalone executable,
    it will load directly into this map.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our map on desktop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at what we''ve got so far. If we''re working on desktop
    VR, we can launch the map in VR and look around. Select the drop-down to the right
    of the Play button on your editor toolbar. Select VR Preview (if VR Preview is
    dimmed, check to be sure that your VR headset is hooked up and its software is
    running):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e95638a-0ff0-4373-b483-e589c60c9982.png)'
  prefs: []
  type: TYPE_IMG
- en: Kinda nice in here, right?
  prefs: []
  type: TYPE_NORMAL
- en: We can't do much yet, and we're not at the right height relative to the floor,
    but it's running and we're ready to begin setting things up.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our map on mobile (Oculus Go/Samsung Gear)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we'd like to test the map on mobile, there are a few other things we need
    to do.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that we've already set up our project to run on mobile as described,
    let's check first that our mobile device is connected and can be seen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important: If you update your Unreal Engine version, be sure you re-run the
    **CodeWorks for Android** installer at `<Engine Install Location>\Engine\Extras\AndroidWorks\Win64`.
    Building with newer Unreal code and out-of-date Android SDK code can create difficult-to-debug
    errors when you try to run in mobile VR. Remember to keep your CodeWorks up-to-date.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Windows PowerShell and navigate to the `platform-tools` directory in your
    Android SDK directory. By default, this will be `C:\NVPACK\android-sdk-windows\platform-tools`.
    From here, type `./adb devices`. You should see the serial number of your connected
    device here with the word `device` beside it. If this reads *unauthorized* instead,
    you need to accept the connection to your PC from within the headset. If this
    reads *offline*, you may need to restart your `adb` server. Type `./adb kill-server`,
    and then run `./adb devices` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b72805c4-0bca-407d-aca0-92289a726f27.png)'
  prefs: []
  type: TYPE_IMG
- en: If you're working on mobile devices, there's no way around the reality that
    you're going to spend a lot of time in PowerShell talking to the device. Take
    the time to learn about ADB especially. When something goes wrong, you're going
    to use ADB to figure out what's happening. Learn more about it here: [https://developer.android.com/studio/command-line/adb](https://developer.android.com/studio/command-line/adb).
  prefs: []
  type: TYPE_NORMAL
- en: If your `./adb` devices looks good, you should be ready to launch the project
    to the device.
  prefs: []
  type: TYPE_NORMAL
- en: From your launch drop-down on the editor toolbar, select the Android entry that
    matches the serial number of your device.
  prefs: []
  type: TYPE_NORMAL
- en: The launch process should begin. As we mentioned in the [Chapter 2](24157dc8-09e6-4ff8-9ba2-3e0d0e4709b6.xhtml),
    *Setting Up Your Development Environment*, expect it to take a while the first
    time you do this.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a game mode and player pawn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've set up a basic scene and verified that it runs on the platform,
    let's get to work on building in some functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a VR pawn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we're going to need to do is create a **pawn** to represent
    the player. Pawns are a type of actor that can be controlled by a player or by
    AI. In our case, we're going to create a pawn that our player can control.
  prefs: []
  type: TYPE_NORMAL
- en: Unreal Engine is an **object-oriented** system. This means that the engine is
    organized around discrete items called **objects**. An object consists of **properties**,
    which you can generally see by looking at the Details panel of an item you select
    in the map, and **functions**, which you can often see in the blueprint editor.
    Objects often **inherit** from one another, so a new class of object might be
    created using another class as its parent. This means that the new class would
    take on the attributes and behavior of its parent, but could then change these
    attributes and behaviors or add new ones. An actor, therefore, is a child of the
    object class that adds the capability to be placed in the world. A pawn is a type
    of actor that adds the ability to be controlled by a player or AI. When we create
    our own class using a pawn as a parent, we're setting up that class to take on
    everything a pawn can do, and then changing its behaviors or adding our own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s navigate to our `Content/HelloVR/Assets/Blueprints` folder in the content
    browser, right-click on any empty space in the folder, and select Create Basic
    Asset | Blueprint Class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/858848aa-7bc0-4fe4-97db-a6856ca98ff6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the dialog that follows, we''ll be asked to select our new blueprint''s
    parent class. Select Pawn:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4bb20538-4d6a-4874-91f4-81d56ace839f.png)'
  prefs: []
  type: TYPE_IMG
- en: A new blueprint asset will be created in our `Blueprints` directory. Let's name
    it `BP_VRPawn`.
  prefs: []
  type: TYPE_NORMAL
- en: It's a good idea to get into the habit of following a **naming convention**
    when you name your assets. A naming convention is a set of rules you follow when
    thinking up a name for a new thing you're creating. By following rules when you
    name objects, you can make it much easier to see what an object is, or to remember
    what you called it. In this instance, we're using the `BP_ prefix` as a reminder
    that our pawn is a blueprint class. A particularly thorough and well-thought-out
    naming convention lives here: [https://github.com/Allar/ue4-style-guide](https://github.com/Allar/ue4-style-guide).
  prefs: []
  type: TYPE_NORMAL
- en: In a moment, we're going to start modifying our pawn, but, first, we need to
    tell our map to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a game mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever Unreal loads up a map, the first thing it does is check to see what
    rules govern the behavior of the map. These rules can specify a number of things,
    but the one we care about right now is what sort of pawn is going to spawn from
    a `Player Start` object. This collection of rules lives in a class called the
    **Game Mode**.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a game mode. Right-click in empty space, create a Blueprint Class,
    and select Game Mode Base as its parent. We'll name it `BP_VRGameMode`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Double-click our new game mode to open it up, and in its Details section, select
    the Classes | Default Pawn Class drop-down, and select the `BP_VRPawn` class we
    just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dcc1d54e-2e3d-446a-b123-1eed8b15b2d1.png)'
  prefs: []
  type: TYPE_IMG
- en: For our purposes right now, this is all we need to do with our game mode. We're
    just using it to specify the pawn class we'd like to load. Compile it and save
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Blueprint is a **compiled** language. Before the code you write can be run by
    the CPU, it needs to be translated into a language the CPU understands. There
    are two main ways this can happen. **Interpreted** languages are translated on-the-fly
    while they're running. This comes with a cost though, since the interpreter needs
    to be running alongside your code and trying to translate it while it runs. It's
    much faster to translate everything offline in a separate process so it's ready
    to go when the CPU needs to run it. This is how compiled languages handle things,
    and when you compile your blueprints, this is what you're doing.
  prefs: []
  type: TYPE_NORMAL
- en: By default, when blueprints are compiled, they're compiled to a format that's
    then used by a virtual machine that hosts the blueprint code while your application
    is running. This system runs fast, but if you want to squeeze even more speed
    out of it, you have the option to convert them to native C++, which then allows
    them to be compiled to machine code. At this point, they can run as fast as code
    written directly in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning the game mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we need to tell our project to use this game mode as its default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Project Settings, and under Project | Maps & Modes | Default Modes, set
    our Default GameMode to our newly-created game mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/902a3a02-d8b9-449c-b4ad-08e8b521d672.png)'
  prefs: []
  type: TYPE_IMG
- en: Now any level that loads in our project will use this GameMode to decide what
    to spawn and what rules to follow when running the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding a GameMode for a specific map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What if we wanted one of our maps to use a different GameMode? For instance,
    if we set up an entry menu scene, we might want to spawn a pawn designed to interact
    with the menus in place of our default player pawn. Fortunately, this is easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'If it isn''t already visible, select Window | World Settings to open up our
    World Settings tab. In World Settings, under Game Mode, set the GameMode Override
    to the new BP_VRGameMode we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66c36f81-840c-4225-abba-4c17be89ae79.png)'
  prefs: []
  type: TYPE_IMG
- en: We've just told the engine to use our new game mode when this map loads up,
    regardless of what GameMode was specified in the project settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four places where we can specify what game mode to use:'
  prefs: []
  type: TYPE_NORMAL
- en: You can set it in Project Settings | Maps & Modes | Default Modes | Default
    GameMode. A GameMode specified here will load by default anywhere in your project
    unless something else overrides it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can set the GameMode Override in an individual map as we've done here. This
    will override the global default game mode from your project settings if it's
    set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can specify a game mode using the *command-line argument* `?game=MyGameMode`
    when you launch your executable. This, in turn, will override your default game
    mode, and any override set in your map.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In your `DefaultEngine.ini`, you can specify specific game modes to load when
    maps with specific prefixes are loaded. This will override any other specification
    if it's set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Placing a pawn directly in the world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While it's generally preferable to use a game mode and a player start object
    to get your player pawn into the world, you don't have to do it this way, and
    you'll occasionally run across existing projects, such as the default VR Template
    project, that don't use a GameMode to set the player pawn.
  prefs: []
  type: TYPE_NORMAL
- en: In these cases, instead of placing a player start object in your scene where
    you want the player to spawn, drag your pawn blueprint directly into the scene.
    If your scene has an existing player start, get rid of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that we said pawns could be controlled by players or AI? You need
    to put your pawn under player control since you don''t have a GameMode doing the
    job for you. Select the pawn you just placed in the level, and in its Details,
    find Pawn | Auto Possess Player, and set the value to Player 0\. This will put
    the pawn under the player''s control when it spawns into the world:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3bccef52-3c9b-4b50-a711-3201d9af0812.png)'
  prefs: []
  type: TYPE_IMG
- en: In general, it's better practice to use a GameMode to specify the player pawn
    class, but you should know that this method exists, because you will see some
    projects use it.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the VR pawn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've created a VR pawn and set up the game mode to use it, let's modify
    this pawn to set it up appropriately for use in VR. We're going to do this from
    scratch here. Quite often, you'll use the pawn class supplied with the VR template
    when you create a simple VR application, but we don't want you to use this as
    a crutch. It's much better to understand how a pawn is built for VR, so you can
    build it appropriately for what you need it to do.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we're going to do is open up our pawn.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the upper-left corner of the blueprint editor view, you should see a Components
    tab. Hit the green +Add Component button, and in the drop-down that appears, select
    Scene to create a Scene Component. Name it `Camera Root`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b85f1d89-f8a6-42ec-9fd1-04c96caa1d83.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Components** are additional elements that can be added to blueprint objects.
    There''s a wide variety of components available to you, and they all do different
    jobs. Components are organized into a hierarchy, allowing you to attach components
    to other components. You can do quite a lot with this.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, create a new Camera component. If the Camera Root scene component was still
    selected when you did this, the Camera component will be created as a child of
    Camera Root. If it isn't, drag it on to Camera Root to set Camera Root as its
    parent.
  prefs: []
  type: TYPE_NORMAL
- en: It's often a good idea to set a separate root component as we've done here.
    This gives you much more flexibility to change the structure of the actor later,
    or to change rotations or positions of components such as cameras without having
    to adjust the position of the object.
  prefs: []
  type: TYPE_NORMAL
- en: Adding motion controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, select the `DefaultSceneRoot` component, and create a `Motion Controller`
    component. For this one, use the Search Components bar at the top of the Add Component
    menu and type `mot` to narrow the search to the motion-controller component. You
    can save yourself a lot of time by using this search bar. Name this new component
    `MotionController_L` and make sure it's a child of the `DefaultSceneRoot`, and
    not a child of the CameraRoot or the Camera.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select `DefaultSceneRoot` and do this again to create a second motion-controller
    component. Name this one `MotionController_R` and again make sure it''s a child
    of the `DefaultSceneRoot`, and not any other component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c87daa50-4b12-4171-9445-371387149001.png)'
  prefs: []
  type: TYPE_IMG
- en: Your component hierarchy should now look like the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on, we need to set a few properties on our motion-controller
    components. Select the `MotionController_R` component, and in its Details panel,
    find the Motion Controller | Motion Source entry. Set it to Right to allow the
    controller to be moved by the right-hand Oculus or Vive controller. While we''re
    at it, ensure that `MotionController_L` is still set to use Left as its motion
    source. It should be this by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12f5f1df-ffd0-4bf6-9097-c97bf016ac50.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s also make both of these controllers visible so we can verify that they''re
    working. From each motion-controller component''s Details panel, select Visualization
    | Display Device Model. Turn this on, and verify that Display Model Source is
    still set to Default, which will simply display the model for the motion-controller
    hardware you''re using. We''ll replace our motion-controller display later on,
    but for now, we just want to see them so we can verify that we''ve set them up
    correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a733241e-7736-4a47-ba93-d1621998bf12.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting our tracking origin.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we need to tell our pawn how it should interpret the location of the headset
    in the tracked space. Look for the My Blueprint tab underneath your pawn''s Components
    tab, and if your EventGraph panel isn''t already visible in the main editing window,
    double-click Graphs | EventGraph in the My Blueprint tab to display it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/33fb67b1-f07e-4d2d-8626-e4234c1fc9f2.png)'
  prefs: []
  type: TYPE_IMG
- en: Once you're in your EventGraph, find the BeginPlay event, or right-click anywhere
    in the graph editor and type `beginplay` in the search dialog that appears to
    find or create a BeginPlay event. Drag an execution line from the BeginPlay event
    and right-click to create a new node. Find Input | Head Mounted Display | Set
    Tracking Origin, or begin typing in the search box to find it. Create a `Set Tracking
    Origin` node, and set its origin to Floor Level if you're using a room-scale VR
    system such as the HTC Vive or Oculus Rift with Touch controllers, or Eye Level if
    you're using a non-room-scale system such as the Oculus Go or older single-camera
    Oculus Rift.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting our Player Start location to the map.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we need to adjust our Player Start position in the map. Find it in
    your World Outliner (you can use the search bar to find it quicker, and then select
    it and drag it down in the scene until its center intersects the floor (this is
    a bit of a hacky way to align our pawn, and we''ll do a better job of this later,
    but for now it will work):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8ecafd1-d289-4fd7-8517-f7ebb7f8e834.png)'
  prefs: []
  type: TYPE_IMG
- en: Testing in the headset.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have the building blocks we're going to need to create VR experiences
    in Unreal. We have a project that's been properly set-up to run efficiently in
    VR, and a pawn that may not do much yet, but is ready to be used as a foundation
    for the things we really want to do.
  prefs: []
  type: TYPE_NORMAL
- en: Let's test it. Launch the map using VR preview, and verify that your view seems
    to be at the right height, and that you can see your motion controllers when you
    move your hands. Framerate should be acceptable as well.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging a standalone build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we distribute an Unreal application to other users, we generally don't
    give them the source files for the editor. Instead, we package the project into
    a stand-alone executable that can be run on the target platform.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a Windows standalone executable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select File | Package Project | Windows | Windows (64-bit) to kick off a packaging
    process. You''ll be asked where to put it. Choose a location that makes sense.
    (Often, creating a `Packaged` directory inside your project directory can be reasonable.
    You can put your packaged build wherever you want.) When the build status dialog
    appears, hit Show Output Log so you can see what it''s doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5053a3c9-dbca-47d3-a898-74827501f3b7.png)'
  prefs: []
  type: TYPE_IMG
- en: Expect this process to take a while.
  prefs: []
  type: TYPE_NORMAL
- en: Once the process completes, close the editor and check the location where you
    told the system to build your executable. You should see a `WindowsNoEditor` folder
    inside it. Inside that, you should see an executable with your project's name.
    Launch the executable. If you set the Start in VR flag in your Project Settings,
    it should launch directly to your headset.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Congratulations! We covered a lot of ground. In this chapter. We went through
    the process of creating a starting VR project and set it up properly to run well
    on the target hardware. We learned how to decide what settings to use when setting
    up a new project for VR, and how to find our way around inside an Unreal project
    directory. We also learned about a number of important Unreal Engine features
    used in VR development:'
  prefs: []
  type: TYPE_NORMAL
- en: Instanced Stereo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Round Robin Occlusions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forward Shading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multisampling Anti-Aliasing (MSAA)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Mobile] Mobile Multi-View'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Mobile] Monoscopic Far Field Rendering'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We learned how to migrate content from one project to another, and how to clean
    up our `Content` directory once it arrives.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set up a basic VR pawn and set up a game mode to instruct the map
    to load it. In working with the pawn, we learned about how we can use components
    to build complex objects out of simple parts, adding a camera and tracked motion
    controllers. Finally, we set up the first elements of our pawn's blueprint to
    set our tracking origin appropriately for our VR hardware, and tested our map.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to make it possible for the pawn we created
    in this chapter to move through the world. We'll use Blueprints to create a teleport
    movement scheme, and learn how to set up the environment to support it, and then
    we'll move on from there to implement a range of immersive movement schemes as
    well.
  prefs: []
  type: TYPE_NORMAL
