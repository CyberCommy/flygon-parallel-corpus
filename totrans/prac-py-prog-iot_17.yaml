- en: Tying It All Together - An IoT Christmas Tree
  prefs: []
  type: TYPE_NORMAL
- en: Welcome to our final chapter! We will round out this book by pulling together
    various topics and ideas from earlier chapters to build a multifaceted IoT program.
    Specifically, we will be building an internet-controllable Christmas tree, an
    *IoTree,* if you don't mind the pun!
  prefs: []
  type: TYPE_NORMAL
- en: Our approach in this chapter will be to reuse two circuits from previous chapters
    to create Christmas tree lighting (using an APA102 LED strip) and a rocking mechanism
    to make the tree shake (we will use a servo) and jingle (well, it'll jingle as
    it shakes if you decorate the tree with bells!). We will then revisit and adapt
    our learning about RESTful APIs and MQTT to create two ways in which we can control
    the lighting and servo over a network or the internet. We will then revisit dweet.io
    and **If-This-Then-That** (**IFTTT**)and build IFTTT Applets to control the tree
    via email and your voice using Google Assistant!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what we will cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the IoT Christmas tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the IoTree circuit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring, running, and using the Tree API service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring, running, and using the Tree MQTT service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating the IoTree with dweet.io
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating with email and Google Assistant via IFTTT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ideas and suggestions to extend your IoTree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To perform the exercises in this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi 4 Model B
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raspbian OS Buster (with desktop and recommended software)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimum Python version 3.5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These requirements are what the code examples in this book are based on. It's
    reasonable to expect that the code examples should work without modification on
    a Raspberry Pi 3 Model B or a different version of Raspbian OS as long as your
    Python version is 3.5 or higher.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the section titled *Integration with Google Assistant*, at a minimum,
    you will need the following prerequisites:'
  prefs: []
  type: TYPE_NORMAL
- en: A Google account (if you have a Gmail email account, that's all you need)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Android phone or the *Google Assistant* app for iOS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will find this chapter's source code in the `chapter14` folder in the GitHub
    repository available here: [https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT](https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT).
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to execute the following commands in a terminal to set up a virtual
    environment and install the Python libraries required for the code in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following dependencies are installed from `requirements.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**PiGPIO**: The PiGPIO GPIO library ([https://pypi.org/project/pigpio](https://pypi.org/project/pigpio))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flask-RESTful**: A Flask extension for creating RESTful API services ([https://pypi.org/project/Flask-RESTful](https://pypi.org/project/Flask-RESTful))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Paho MQTT** **client**: [https://pypi.org/project/paho-mqtt](https://pypi.org/project/paho-mqtt)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pillow**: **Python Imaging Library** (**PIL**) ([https://pypi.org/project/Pillow](https://pypi.org/project/Pillow))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Luma LED Matrix library**: [https://pypi.org/project/luma.led_matrix](https://pypi.org/project/luma.led_matrix)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Requests**: A high-level Python library for making HTTP requests ([https://pypi.org/project/requests](https://pypi.org/project/requests))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PyPubSub**: In-process messaging and events ([https://pypi.org/project/PyPubSub](https://pypi.org/project/PyPubSub))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The electronic components we will need for this chapter''s exercises are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 1 x MG90S hobby servo (or equivalent 3-wire, 5-volt hobby servo)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x APA102 RGB LED strip
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x logic level shifter module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External power supply (at a minimum a 3.3 V/5 V breadboard-mountable power supply)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A video showing this tree in action is available at [https://youtu.be/15Xfuf_99Io](https://youtu.be/15Xfuf_99Io). Please
    note that this tree uses RGB LEDs and an alternating blinking animation for the
    lights. We'll be using an APA102 LED strip in this chapter that is capable of
    creating more animation effects. The demo tree can also play a tune, which we
    will not cover in this chapter (although you'll easily be able to add that feature
    if you wish by adopting the RTTTL example from [Chapter 8](d37dafc4-afc7-460c-b200-c2b6e19d0083.xhtml), *Lights,
    Indicators, and Displaying Information*).
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the IoT Christmas tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we commence our chapter by building circuits and looking at code, let''s
    take a moment to understand what our IoTree will do and how we will be building
    it. The tree pictured in *Figure 14.1* is representative of what you could create
    after completing this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2af4c674-ab83-40e1-9837-9b9aae3983d3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.1 – IoTree example
  prefs: []
  type: TYPE_NORMAL
- en: Now, I'll need to let you know up front that we're only covering the electronics
    and programming of the IoTree. You'll need to apply your initiative and bring
    your maker skills to the table to build the tree and bring it to life. I suggest
    using a small table-top Christmas tree since part of our build involves a servo
    to *shake* the tree. Our hobby-grade servo is powerful enough to shake a small
    tree; however, it's unlikely that it could shake a full-size Christmas tree (you'll
    need to research and get a more powerful servo if you aspire to upgrade our build
    to a larger tree – and please send me a picture if you do!).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our base-level tree will comprise the following electronic components:'
  prefs: []
  type: TYPE_NORMAL
- en: An APA102 LED light strip for the tree lights (we covered the APA102 LED strip
    in [Chapter 8](d37dafc4-afc7-460c-b200-c2b6e19d0083.xhtml), *Lights, Indicators,
    and Displaying Information*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A servo to make the tree *shake* and *jingle –* for this, you will need some
    bell ornaments on the tree that will *jingle* when the tree shakes (we covered
    servos in [Chapter 10](8b0b4483-ccde-4a92-896b-039eb94d911a.xhtml), *Movement
    with Servos, Motors, and Steppers*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Programmatically and structurally, our tree program will be drawing on the
    following concepts we''ve learned about:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The dweet.io service**: First covered in [Chapter 2](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml),
    *Getting Started with Python and IoT*, and revisited in [Chapter 13](861a1e79-2f40-4a60-bb40-82101ee42e63.xhtml), *IoT
    Visualization and Automation Platforms*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RESTful API with Flask-RESTful**: From [Chapter 3](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml),
    *Networking with RESTful APIs and Web Sockets Using Flask*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message Queue Telemetry Transport (MQTT)**: Covered in [Chapter 4](6947b564-6182-4ec9-998a-37f636c0bce6.xhtml),
    *Networking with MQTT, Python, and the Mosquitto MQTT Broker*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A thread and Publisher-Subscriber (PubSub) approach to IoT programs**: Covered
    in [Chapter 12](b2a583d8-ea6d-4e0e-9018-26997fbdda4e.xhtml), *Advanced IoT Programming
    Concepts – Threads, AsyncIO, and Event Loops*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The IFTTT IoT platform**: Covered in [Chapter 13](861a1e79-2f40-4a60-bb40-82101ee42e63.xhtml),* IoT
    Visualization and Automation Platforms*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we proceed through this chapter, we are going to assume you have an understanding
    of the concepts from each of the aforementioned chapters, and that you have performed
    the exercises presented in each chapter, including building the circuits and understanding
    the circuit and code-level concepts that make the circuits work.
  prefs: []
  type: TYPE_NORMAL
- en: Our first task will be to build the circuit needed for our IoTree, which we
    will do next.
  prefs: []
  type: TYPE_NORMAL
- en: Building the IoTree circuit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s time to get building! Please construct the circuit illustrated in *Figure
    14.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9ee79d65-a7e4-46a2-9fbd-6d89308d52be.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.2 – IoTree circuit schematic diagram
  prefs: []
  type: TYPE_NORMAL
- en: 'This circuit hopefully looks familiar. It''s a combination of two circuits
    that we have seen before:'
  prefs: []
  type: TYPE_NORMAL
- en: The APA102 (with a logic level shifter) circuit from *Figure 8.4*, in [Chapter
    8](d37dafc4-afc7-460c-b200-c2b6e19d0083.xhtml), *Lights, Indicators, and Displaying
    Information*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The servo circuit from *Figure 10.2, *in [Chapter 10](8b0b4483-ccde-4a92-896b-039eb94d911a.xhtml),
    *Movement with Servos, Motors, and Steppers*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please consult these respective chapters if you need step-by-step instructions
    on building this circuit on your breadboard.
  prefs: []
  type: TYPE_NORMAL
- en: Please remember that you will need to use an external power supply to power
    your APA102 and servo, as they will draw too much current to use the 5-volt pin
    on your Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: When you have completed your circuit build, next let's briefly discuss three
    programs that can be used to control this circuit.
  prefs: []
  type: TYPE_NORMAL
- en: Three IoTree service programs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three separate programs to accompany our IoTree, each taking a slightly
    different approach to work with our lights and servo. The programs are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Tree API service **(found in the `chapter14/tree_api_service` folder):
    This program provides a RESTful API created with Flask-RESTful to control the
    lights and servo. It also includes a basic HTML and JavaScript web app that uses
    the API. We will discuss the Tree API service further in the section titled *Configuring,
    running, and using the Tree API service*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Tree MQTT service **(found in the `chapter14/tree_mqtt_service` folder):
    This program will allow us to control the lights and servo by publishing MQTT
    messages. We will discuss the Tree MQTT service further in the section titled
    *Configuring, running, and using the Tree MQTT service*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The dweet integration service **(found in the `chapter14/dweet_integration_service` folder):
    This program receives dweets and republishes them as MQTT messages. We can use
    this program together with the *Tree MQTT service* program to control our lights
    and servo using dweet.io, which thus provides us with an easy way to integrate
    our IoTree with a service such as IFTTT. We will discuss the dweet integration
    service more in the section titled *Integrating the IoTree with dweet.io*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have briefly discussed the programs that make up this chapter's
    examples, let's configure and run our Tree API service and use it to make the
    lights and servo work.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring, running, and using the Tree API service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Tree API service program provides a RESTful API service for controlling
    our IoTree''s APA102 LED strip and servo. You can find the Tree API service program
    in the `chapter14/tree_api_service` folder. It contains the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`README.md`: The full API documentation with examples for the Tree API service
    program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main.py`: This is the program''s main entry point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`config.py`: Program configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apa102.py`: A Python class that integrates with the APA102 LED strip. The
    core of this code is very similar to the APA102 Python code we explored back in [Chapter
    8](d37dafc4-afc7-460c-b200-c2b6e19d0083.xhtml), *Lights, Indicators, and Displaying
    Information***,** only now it is structured as a Python class, uses a thread to
    run light animations, plus has a few other small additions, such as code to make
    the LEDs blink.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apa102_api.py`: Flask-RESTful resource classes that provide the APA102 API.
    It draws upon the Flask-RESTful code and examples from [Chapter 3](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml),
    *Networking with RESTful APIs and Web Sockets Using Flask*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`servo.py`: A Python class for controlling the servo. It draws upon the servo
    code we covered back in [Chapter 10](8b0b4483-ccde-4a92-896b-039eb94d911a.xhtml),
    *Movement with Servos, Motors, and Steppers*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`servo_api.py`: Flask-RESTful resource classes that provide the servo API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`templates`: This folder contains the example web app''s `index.html` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static`: This folder contains the static JavaScript libraries and an image
    used by the web app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A diagram depicting the Tree API service program architecture is shown in *Figure
    14.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2ad54f4a-949b-4ead-a32f-55220cd18170.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.3 – Tree API service architecture block diagram
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the high-level operation of the Tree API service for the API request
    shown by the dotted line in the preceding diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An external client makes a POST request to the `/lights/colors` endpoint at
    #1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The request is handled by the Flask framework/server at #2. (The Flask and
    Flask-RESTful setup can be found in `main.py`.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `/lights/*` endpoint is routed to the appropriate Flask-RESTful resource
    at #3 (APA102 – that is, the *light* – resources are defined in `apa102_api.py`). The
    endpoint setup and resource registration with Flask-RESTful are found in `main.py`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At #4, the appropriate resource is invoked (in this example, it will be `ColorControl.post()`),
    which then parses and validates the query string parameters (that is, `colors=red%20blue&pattern=yes`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, at #5, `ColorControl.post()` then calls the appropriate methods in
    an instance of APA102 (defined in `apa102.py`, and set up in `main.py`) that directly
    interfaces with and updates the physical APA102 LED strip with the repeating pattern
    of red and blue.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have an understanding of how our Tree API service works, before
    we can run our Tree API service, first we need to check its configuration. We'll
    do that next.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Tree API service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Tree API service configuration is found in the `chapter14/tree_api_service/config.py` file.
    There are many configuration options in this file, and they mostly relate to the
    configuration of the APA102 (discussed in [Chapter 8](d37dafc4-afc7-460c-b200-c2b6e19d0083.xhtml),
    *Lights, Indicators, and Displaying Information*) and the servo (discussed in [Chapter
    10,](8b0b4483-ccde-4a92-896b-039eb94d911a.xhtml) *Movement with Servos, Motors,
    and Steppers*). You will find this file and the configuration options well commented.
  prefs: []
  type: TYPE_NORMAL
- en: The default configuration will be adequate for running an example locally on
    your Raspberry Pi; however, the one configuration parameter you should check is
    `APA102_NUM_LEDS = 60`. If your APA102 LED strip contains a different number of
    LEDs, please update this configuration appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Let's run the Tree API service program and create some light (and movement)!
  prefs: []
  type: TYPE_NORMAL
- en: Running the Tree API service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s now time to run the Tree API service program and send it RESTful API
    requests to make it work. Here are the steps to run and test our Tree API service:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change into the `chapter14/tree_api_service` folder and start the `main.py`
    script, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, open a second terminal and run the following `curl` command to set the
    repeating light pattern sequence to `red, blue, black`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Also in *Terminal 2*, run this next command to start making the lights animate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Other animation modes you can use for the `mode` parameter, in addition to `left`,
    include `right`, `blink`, `rainbow`, and `stop`. The `speed` parameter takes a
    value between `1` and `10`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To clear or reset the LED strip, run the following command, again in *Terminal
    2*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the servo sweep (that is, to make the tree *shake),* run the following
    command in *Terminal 2*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The servo should sweep back and forth a number of times. If you want to make
    the servo sweep more times or need to increase its range of movement, then you
    can adjust the `SERVO_SWEEP_COUNT` and `SERVO_SWEEP_DEGREES` configuration parameters in
    the `chapter14/tree_api_service/config.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: If you find your LEDs dimming, flickering, or otherwise behaving erratically
    when you make the servo move, or your servo twitches as you change the APA102
    LEDs, chances are that your external power supply cannot deliver enough current
    to run both the LEDs and servo simultaneously. As in interim measure, if you don't
    have another power supply, try reducing the number of LEDs (`APA102_NUM_LEDS`
    in `config.py`) and/or reducing the LED contrast (`APA102_DEFAULT_CONTRAST`, also
    in `config.py`). This will lower the current requirements of the LED strip.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s run the web app and control our IoTree from a web browser by
    opening a web browser on your Raspberry Pi desktop and navigating to the URL `http://localhost:5000`.
    You should see a web page similar to the one pictured here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/a29059b1-831e-42cb-ae1f-fce5a7279e80.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.4 – Example IoTree web app
  prefs: []
  type: TYPE_NORMAL
- en: 'Try the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on colors in the color bar and watch that color get pushed to the APA102
    LED strip.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click the Pattern Fill button to fill the APA102 LED strip with the selected
    colors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click Left to start an animation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JavaScript behind this web app (found in `chapter14/tree_api_service/templates/index.html`)
    is simply calling our IoTree API similar to what we have already done using `curl`,
    only it's doing it using jQuery. jQuery and JavaScript are beyond the scope of
    this book; however, they are briefly touched on in [Chapter 3](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml),
    *Networking with RESTful APIs and Web Sockets Using Flask.*
  prefs: []
  type: TYPE_NORMAL
- en: You will find the full set of API documentation for the IoTree with `curl` examples
    in the `chapter14/tree_api_service/README.md` file.
  prefs: []
  type: TYPE_NORMAL
- en: Our RESTful API implementation provides the basic API endpoints that we need
    for this chapter; however, I am more than confident that you will be able to expand
    and adapt this example for your own projects or add new functionality to your
    IoTree. I'll provide suggestions on how you can expand your IoTree based on what
    you have learned in this book toward the end of the chapter in the section titled *Ideas
    and suggestions to extend your IoTree*.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have run and seen how to control our IoTree's lights and servo with
    a RESTful API, next we will look at an alternative service implementation that
    will allow us to control our IoTree using MQTT.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring, running, and using the Tree MQTT service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Tree MQTT service program provides an MQTT interface for controlling our
    tree''s APA102 LED strip and servo by publishing MQTT messages to MQTT topics. You
    can find the Tree MQTT service program in the `chapter14/tree_mqtt_service` folder,
    and it contains the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`README.md`: A full list of MQTT topics and message formats for controlling
    your IoTree.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main.py`: This is the program''s main entry point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`config.py`: Program configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apa102.py`: This is an exact copy of the `chapter14/tree_api_service/apa102.py`. file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`servo.py`: This is an exact copy of the `chapter14/tree_api_service/servo.py` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mqtt_listener_client.py`: This is a class that connects to an MQTT broker
    and subscribes to a topic that will receive messages to control the APA102 and
    servo. When MQTT messages are received, they are turned into a PubSub message
    and published using the `PyPubSub` library, which we discussed in [Chapter 12](b2a583d8-ea6d-4e0e-9018-26997fbdda4e.xhtml),
    *Advanced IoT Programming Concepts - Threads, AsyncIO, and Event Loops*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apa102_controller.py`: This code receives PubSub messages sent by `mqtt_listener_client.py` and
    updates the APA102 LED strip as appropriate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`servo_controller.py`: This code receives PubSub messages sent by `mqtt_listener_client.py` and
    controls the servo.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A diagram depicting the Tree MQTT service program architecture is shown in *Figure
    14.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0cdf056b-bfbe-4b53-96f9-a8882011c8ba.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.5 – Tree MQTT service architecture block diagram
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the high-level operation of the Tree MQTT service for the MQTT publication depicted
    by the dotted line in the preceding diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A `red blue` message is published on to the `tree/lights/pattern` topic at
    #1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The message is received by the Paho-MQTT client at #2. The topic and message
    is parsed in the `on_message()` method in `mqtt_listener_client.py` and mapped
    into a local PubSub topic *pattern* using the `MQTT_TO_PUBSUB_TOPIC_MAPPINGS` mapping
    dictionary found in `config.py`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The mapped message and parsed data are dispatched using the `PyPubSub` library
    at #3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `PyPubSub` subscription in `apa102_controller.py` receives the *pattern*
    topic and its payload data at #4'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`apa102_controller.py` handles the message and data at #5 and calls the appropriate
    methods on an APA102 instance (defined in `apa102.py`) that directly interfaces
    and updates the physical APA102 LED strip with the repeating pattern of red and
    blue.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In case you are wondering, the decision to use `PyPubSub` and re-dispatch MQTT
    messages in `mqtt_listener_client.py` was a design decision based on my personal
    preferences to decouple MQTT-related code and hardware control-related code, with
    the goal of making the application easier to read and maintain. An alternative
    – and equally valid – approach could have been to use `apa102.py` and `servo.py` within `mqtt_listener_client.py`
    in direct response to the MQTT messages received.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an understanding of how our Tree MQTT service works, before
    we can run our Tree MQTT service, first we need to check its configuration. We'll
    do that next.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Tree MQTT service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Tree MQTT service configuration is found in the `chapter14/tree_mqtt_service/config.py` file.
    Similar to the Tree API service, they mostly relate to the configuration of the
    APA102 and the servo. You will also find this file and its configuration options
    well commented.
  prefs: []
  type: TYPE_NORMAL
- en: The default configuration will be adequate for running an example locally on
    your Raspberry Pi; however, just as we did for the Tree API service configuration,
    please check and update the `APA102_NUM_LEDS = 60` parameter as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: If you also needed to change any of the `APA102_DEFAULT_CONTRAST`, `SERVO_SWEEP_COUNT`,
    or `SERVO_SWEEP_DEGREES` parameters while running the Tree API example, please
    also update these values now for the MQTT example.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have made any necessary changes to the configuration, we will proceed
    and run our Tree MQTT service program and publish MQTT messages to make our IoTree
    work.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Tree MQTT service program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s now time to run the Tree MQTT service program and publish MQTT messages
    that will control our IoTree. Here are the steps to run and test our Tree MQTT
    service:'
  prefs: []
  type: TYPE_NORMAL
- en: We must have the Mosquitto MQTT broker service installed and running on our
    Raspberry Pi, plus the Mosquitto MQTT clients tools. Please refer to [Chapter
    4](6947b564-6182-4ec9-998a-37f636c0bce6.xhtml), *Networking with MQTT, Python,
    and the Mosquitto MQTT Broker, *if you need to check your installation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change into the `chapter14/tree_mqtt_service` folder and start the `main.py` script,
    as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, open a second terminal and send an MQTT message using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The LED strip will light up with the repeating color pattern – red, blue, black
    (black means that the LED is off).
  prefs: []
  type: TYPE_NORMAL
- en: Try experimenting with the `--retain` or `-r` retained message option to `mosquirro_pub`.
    If you publish a retained message, it gets re-delivered to your Tree MQTT services
    when it connects to the MQTT broker and subscribes to the `tree/#` topic. This
    provides a way for your IoTree to restore its last state in between restarts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the following command in *Terminal 2* to make the LED strip animate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To clear or reset the LED strip, run the following command, again in *Terminal
    2*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this example (and also the next one in *step 6*), we don't have any message
    content; however, we still need to pass an empty message with the `-m ""` option
    (or, alternatively, `-n`); otherwise, `mosquitto_pub` will abort.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, try the following to sweep the servo:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The servo will sweep back and forth according to the values set for `SERVO_SWEEP_COUNT` or `SERVO_SWEEP_DEGREES` in
    `chapter14/tree_mqtt_service/config.py`.
  prefs: []
  type: TYPE_NORMAL
- en: You will find the full set of MQTT topics and message formats that are recognized
    by the Tree MQTT service, complete with `mosquitto_pub` examples, in the `chapter14/tree_mqtt_service/README.md` file.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to our RESTful API example, our MQTT example provides the minimum functionality
    that we need for this chapter but does provide a basic framework that you can
    expand on for your own future projects, or if you extend your IoTree's features.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have run and seen how to control our IoTree's lights and servo with
    MQTT, let's look at an integration service that we can use to couple our Tree
    MQTT service with dweet.io.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the IoTree with dweet.io
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The d*weet integration service*, found in the `chatper14/dweet_integration_service`
    folder, is a Python-based integration service that receives dweets and re-publishes
    them as messages to MQTT topics. This service provides us with a simple approach
    to integrate a service such as IFTTT with our Tree MQTT service program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dweet integration service is made up of the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`main.py`: The main program entry point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`config.py`: The configuration parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`thing_name.txt`: Where your thing name is saved. This file will be created
    when you first start the program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dweet_listener.py`: The core program code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The core of our dweet service is found in the `dweet_listener.py` file. If you
    inspect this file, you will notice that it is almost identical to the `dweet_led.py` file covered
    in both [Chapter 2](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml), *Getting Started
    with Python and IoT*, and *[Chapter 13](861a1e79-2f40-4a60-bb40-82101ee42e63.xhtml),
    IoT Visualization and Automation Platforms* (except it's now wrapped as a Python
    class).
  prefs: []
  type: TYPE_NORMAL
- en: 'The core difference is found in the `process_dweet()` method, shown at line
    (1) in the following code, where instead of directly controlling a LED, we instead
    intercept the dweet and then re-publish it to MQTT topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `publish_mqtt()` method, shown at line (2) in the preceding code and at
    line (3) in the following code, then turns our parsed command string into an MQTT
    topic based on the `ACTION_TOPIC_MAPPINGS` setting found in `chapter14/dweet_mqtt_service/config.py`
    and publishes the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Notice, at line (5), that we are using a Paho-MQTT `publish.single()` convenience
    method, rather that than the fully fledged MQTT client approach we used in [Chapter
    4](6947b564-6182-4ec9-998a-37f636c0bce6.xhtml), *Networking with MQTT, Python,
    and the Mosquitto MQTT Broker* (and that was also used in the Tree MQTT service
    program).
  prefs: []
  type: TYPE_NORMAL
- en: At the moment, I just want to point out line (4), where we set the `retain`
    variable (also notice its use in `publish.single()`). We will discuss this message
    retention more in the following section when we discuss the service configuration
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'A diagram depicting the Tree service program architecture is shown in *Figure
    14.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/53f844ed-a48c-4006-a903-92e84dff021f.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.6 – dweet integration service architecture block diagram
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the high-level operation of the dweet integration service for the request
    shown by the blue dotted line in the preceding diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A dweet is created at #1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`dweet_listener.py` receives the dweet at #2 and parses the data contained
    in the `command` parameter. The action contained within the commend is mapped
    into an MQTT topic using the `ACTION_TOPIC_MAPPINGS` mapping dictionary found
    in `config.py`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A message is published to the MQTT broker to the mapped MQTT topic at #3. The
    message''s *retained* flag is set according to the `TOPIC_RETAIN_MESSAGE` mapping
    dictionary found in `config.py`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the publication of the MQTT message, if your Tree MQTT service is running
    and connected to the same MQTT broker, it will receive the MQTT message and update
    your IoTree accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an understanding of how our dweet integration service works,
    before we can run our dweet integration service, first we need to check its configuration.
    We'll do that next.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Tree MQTT service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The dweet integration service configuration is found in the `chapter14/dweet_integration_service/config.py` file. 
    There are a number of configuration options relating to how the service works,
    and the defaults will be adequate for running this service locally on your Raspberry
    Pi where you also have your Mosquitto MQTT broker running. The configuration parameters
    are well commented in this file; however, I will make mention of the `ACTION_TOPIC_MAPPINGS`
    and `TOPIC_RETAIN_MESSAGE` parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The dweet integration service maps *dweeted commands* into *MQTT topics*. It's
    the `ACTION_TOPIC_MAPPINGS` configuration parameter that determines how commands
    are mapped into MQTT topics. We'll discuss this idea of *commands* in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: The MQTT topics mapped and used by the dweet integration service must match
    those used by a Tree MQTT service. The default configurations for each service
    use the same topics.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `TOPIC_RETAIN_MESSAGE` configuration shown in the following code determines
    which MQTT topics will have their message''s *retained* flag set. It''s this configuration
    (`True` or `False`) that is used to set the `retained` parameter on `single.publish()`,
    as we pointed out in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have discussed the configuration file, let's start our dweet integration
    service and send it dweets that will control our IoTree.
  prefs: []
  type: TYPE_NORMAL
- en: Running the dweet integration service program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our dweet integration service works by receiving dweets in a predefined format
    and turns them into MQTT topics and messages as per the configuration parameters
    we discussed in the previous section. We''ll discuss this dweet format shortly
    as we run and test the dweet integration service. Here are the steps we need to
    follow:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, make sure you have the *Tree MQTT service* program from the previous
    section running in a terminal. It is the Tree MQTT service that will receive and
    process the MQTT messages published by the dweet integration service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, navigate to the `chapter14/dweet_integration_service` folder in a new
    terminal and start the `main.py` program, as shown (remember your thing name will
    be different):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy and paste the following URLs into a web browser to control your IoTree.
    Use the thing name shown in your output in place of the `<thing_name>` text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`https://dweet.io/dweet/for/<thing_name>?command=pattern%20red%20blue%20black`'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`https://dweet.io/dweet/for/<thing_name>?command=animation%20left`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`https://dweet.io/dweet/for/<thing_name>?command=speed%2010`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`https://dweet.io/dweet/for/<thing_name>?command=clear`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`https://dweet.io/dweet/for/<thing_name>?command=sweep`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It may take a few moments between calling one of these URLs and it being received
    by your dweet integration service.
  prefs: []
  type: TYPE_NORMAL
- en: As you will see in the `command` parameter in the preceding URLs, the format
    of our dweets is `<action> <data1> <data2> <dataN>`.
  prefs: []
  type: TYPE_NORMAL
- en: You will find the full set of dweet command strings recognized by the default
    configuration in `config.py`, complete with example URLs, in the `chapter14/dweet_integration_service/README.md` file.
  prefs: []
  type: TYPE_NORMAL
- en: Well done! We've just created a simple integration service using dweet.io and
    MQTT and learned a simple and non-invasive approach that allows us to control
    our tree over the internet that did not require you to make any network or firewall
    configurations.
  prefs: []
  type: TYPE_NORMAL
- en: When designing an IoT project and considering how data is moved around the internet
    and networks, it's common to find that you need to design and build some form
    of integration to bridge systems that are built on different transport mechanisms.
    Our example in this section illustrates a scenario where we bridge an MQTT service
    (our IoTree MQTT service) with a polling-based RESTful API service (dweet.io).
    While every integration has its own requirements, hopefully this example has provided
    you with a rough roadmap and approach that you can adapt and build upon in the
    future when you encounter these scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our dweet integration service running and have tested that
    it's working, let's see how we can use it together with the IFTTT platform.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with email and Google Assistant via IFTTT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now comes the really fun part – let's make our tree controllable over the internet.
    As a spoiler, I'm not going to hold your hand through this integration because
    the core concepts on using dweet.io and IFTTT together were explained in detail
    in [Chapter 13](861a1e79-2f40-4a60-bb40-82101ee42e63.xhtml), *IoT Visualization
    and Automation Platforms.* In particular, we learned how to integrate our Raspberry
    Pi with IFTTT and email to control a LED.
  prefs: []
  type: TYPE_NORMAL
- en: What I will do, however, is give you screenshots of my IFTTT configuration so
    that you can verify what you set up. Plus, as a bonus, I'll also give you a tip
    and screenshot on how to integrate with Google Assistant so that you can voice-control
    your IoTree!
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, IFTTT has a Google Assistant service that can take arbitrary
    spoken text (in IFTTT lingo, an *ingredient).* I did check out Alexa integration
    but unfortunately, the Alexa IFTTT service could not take arbitrary input and
    so was not compatible with our example.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will look at a few pointers on how to integrate our IoTree with email.
  prefs: []
  type: TYPE_NORMAL
- en: Integration with email
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The process for integrating with email or Twitter is the same as what we covered
    in [Chapter 13](861a1e79-2f40-4a60-bb40-82101ee42e63.xhtml)*, IoT Visualization
    and Automation Platforms*, with the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Rather than using `LED` as the hashtag (the **Complete Trigger Fields Page**
    step in IFTTT), use `TREE`. This way, your email subject can be something such
    as `#TREE pattern red blue` or `#TREE animation blink`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When configuring the That webhook service, you need to use the dweet URL printed
    on the terminal previously when you ran the dweet integration service. An example
    from my configuration is shown in the following figure. Remember the *thing name*
    in your URL will be different:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/5e11ac9b-937c-47a4-8a18-90f29e95f3c5.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.7 – Webhook configuration
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have completed setting up your IFTTT Applet, try emailing `trigger@applet.ifttt.com`
    with the following subject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`#TREE pattern red blue black`'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#TREE animation left`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A few moments after emailing or tweeting the `#TREE pattern red blue black` command,
    your tree's lights will change to these colors in a repeating pattern. Similarly,
    a few moments after emailing or tweeting `#TREE animation left`, your tree lights
    will start animating.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, you will need to have both the Tree MQTT service and dweet integration
    service running in terminals for this example to work. It may also take a few
    moments after sending an email or posting a tweet before your IoTree changes.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have been able to control your IoTree with email, next we'll look at
    the steps necessary to add voice control using Google Assistant.
  prefs: []
  type: TYPE_NORMAL
- en: Integration with Google Assistant
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's make our IoTree voice-controllable using Google Assistant.
  prefs: []
  type: TYPE_NORMAL
- en: '*Google Assistant* comes in many other forms, including Google Home, Google
    Nest, and Google Mini. These products will also work with the IFTTT Google Assistant
    integration and your IoTree as long as they are signed in to the same Google Account
    you use with IFTTT.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create our integration, we need to link your Google account with the IFTTT
    Google Assistant service and call a dweet.io URL when it receives commands. Here
    are the high-level steps to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to your IFTTT account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Applet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the This part of the Applet, use Google Assistant Service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you will be asked to connect and allow IFTTT to use your Google account.
    Follow the on-screen instructions to connect IFTTT and your Google account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now it''s time to select the Google Assistant trigger. Choose Say a phrase
    with a text ingredient. A sample trigger configuration is shown in *Figure 14.8*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/5df6808b-bafd-4740-9c73-09ba7a5e7273.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.8 – Google Assistant trigger example
  prefs: []
  type: TYPE_NORMAL
- en: It's the $ sign in Tree $ shown in the preceding screenshot that gets turned
    into an IFTTT ingredient that we will use with our webhook service (which we'll
    see in a later step).
  prefs: []
  type: TYPE_NORMAL
- en: 'With this trigger configuration, you can say commands such as the following
    to control your IoTree:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Tree pattern red blue black"'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '"Set tree animation blink"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"Tree clear"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's time to configure the That part of the IFTTT Applet. Search for and select
    WebHook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuration of the webhook service is the same as the process we covered previously
    under the *Integration with email *heading in *step 2*, and as shown in *Figure
    14.7.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continue and complete the creation of your IFTTT Applet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ask your Google Assistant the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '"Tree pattern red blue black"'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '"Tree animation blink"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"Tree clear"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"Tree sweep" (or "tree jingle")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Or any other command documented in the `chapter14/dweet_integration_service/README.md` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember, it may take a moment after Google Assistant acknowledges your request
    for your IoTree to start changing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a screenshot of my Google Assistant dialog on my iPhone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/67a87536-2224-4688-9c18-4d3ef28ecff6.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.9 – Google Assistant dialog to control the IoTree
  prefs: []
  type: TYPE_NORMAL
- en: If the integration is working, Google Assistant will respond with "*Ok, Updating
    Tree*"(or whatever text you used at *step 5*), and moments later, your IoTree
    will respond.
  prefs: []
  type: TYPE_NORMAL
- en: The important thing to remember is that we must speak commands exactly as they
    are interpreted by the dweet integration service – for example, as they would
    appear in the command parameter to a dweet URL, such as `https://dweet.io/dweet/for/<thing_name>?command=pattern
    red blue black`.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to prefix them with the word "Tree" (or "Set Tree"). This text is what
    triggers your IFTTT Applet. Just speaking a command alone will not trigger your
    Applet.
  prefs: []
  type: TYPE_NORMAL
- en: If you use an Android phone or the Google Assistant app for iOS, you will be
    able to see how your spoken words are turned into textual commands, which can
    help you troubleshoot commands that are not working or are misunderstood.
  prefs: []
  type: TYPE_NORMAL
- en: You've just learned how to create three IFTTT integrations to control your IoTree
    using email and your voice, and you can easily adapt the same basic ideas and
    processes to control and automate other electronic circuits we've seen in this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, as we discussed in [Chapter 13](861a1e79-2f40-4a60-bb40-82101ee42e63.xhtml),
    *IoT Visualization and Automation Platforms*, IFTTT provides many *triggers* and
    *actions* that you can combine to build automation workflow *Applets.* Between
    this chapter and the previous one, you have now created several Applets, so I
    have every confidence that you'll be able to explore the IFTTT ecosystem and create
    all sorts of interesting Applets that work together with your Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Before we conclude this chapter (and the book!), I want to leave you with a
    few ideas and experiments you can conduct to further expand your IoTree's capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Ideas and suggestions to extend your IoTree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code and electronics we have used throughout this chapter have given us
    a foundation that we can build upon. This might be to extend your IoTree, or as
    the basis for other IoT projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few suggestions you can try:'
  prefs: []
  type: TYPE_NORMAL
- en: Add and integrate a PIR sensor that plays an RTTTL tune whenever anyone walks
    past your IoTree. After all, what electronic Christmas gadget is complete unless
    it drives everyone crazy by playing tunes over and over and over and over...
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add and integrate an RGB LED to the top of the tree (maybe inside a transparent
    star), or use RGB LEDs in place of – or together with – the APA102 LED strip.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build multiple IoTrees. If you use MQTT, they'll synchronize!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to build a WebSocket integration and an accompanying web app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current dweet Google Assistant integration requires you to speak commands
    exactly. Can you create an upgrade that is a little *fuzzier* – that is, that
    can parse spoken text and work out what command is spoken?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We used dweet.io (together with MQTT) in our IFTTT examples, so we did not have
    to worry about firewall configurations. You might want to investigate opening
    up a firewall port at your place or investigate services such as LocalTunnels
    ([https://localtunnel.github.io/www](https://localtunnel.github.io/www)) or ngrok
    ([https://ngrok.com](https://ngrok.com)). These approaches will allow you to use
    IFTTT webhooks to directly communicate with your IoTree's RESTful API. However,
    do remember that our RESTful API examples are not secured – they are not using
    HTTPS and there is no authentication mechanism such as a username and password
    to restrict access to the APIs, so you might want to also research how to secure
    a Flask-based API and perform these upgrades first.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obviously, these are just a few of my suggestions. We've covered many circuits
    during our journey, so use your imagination and see what you come up with – and
    have fun!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations! We have now reached the end of the chapter and the end of the
    book!
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we ran through the electronics and tested programs that control
    those electronics that create the basis of an IoT Christmas tree. We've seen a
    RESTful API that can control our IoTree's lights and servo, as well as a comparable
    MQTT implementation. We also looked at a dweet.io-to-MQTT integration service,
    which we coupled with IFTTT to provide a mechanism to control out IoTree using
    email and Google Assistant.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout our journey in this book, we have covered many concepts and technologies,
    including a variety of networking techniques, electronic and interfacing fundamentals,
    and a range of practical examples using sensors and actuators with your Raspberry
    Pi. We have also looked at automation and visualization platforms and finished
    off, in this chapter, with one example of tying our learnings together.
  prefs: []
  type: TYPE_NORMAL
- en: I had a couple of core intentions in mind when I wrote this book. One of my
    intentions was to share and explain the reasons behind *how* we connect sensors
    and actuators to a Raspberry Pi, and *why* we accompany them with additional components
    such as resistors to create voltage dividers. My second core intention was to provide
    you with a variety of networking techniques and options that are applicable to
    IoT projects.
  prefs: []
  type: TYPE_NORMAL
- en: I believe that the software and hardware fundamentals, together with practical
    examples you have learned throughout our journey, will provide you with many skills
    and insights to not only help you design and build your own complex IoT projects
    but to also understand, at a fundamental level, how existing IoT projects work
    at a software, networking and electronics level.
  prefs: []
  type: TYPE_NORMAL
- en: It is my sincere hope that you have enjoyed this book, learned a lot, and picked
    up many practical tips along the way! All the best on your IoT journey, and I
    hope you create some amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    of this chapter''s material. You will find the answers in the *Assessments* section
    of the *Appendix*:'
  prefs: []
  type: TYPE_NORMAL
- en: Why, in our MQTT service example, did we use `PyPubSub` to re-dispatch MQTT
    messages?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is using the Google Assistant app on a phone (or tablet) useful during development
    when integrating with or debugging an IFTTT Google Assistant Applet?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You are working on an existing weather monitoring project that uses MQTT as
    its network transport layer to connect many distributed devices. You have been
    asked to integrate the application with an IFTTT service. How do you do this?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You want to build multiple IoTrees and have them all work together in unison.
    What are two approaches you can take to achieve this outcome?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why did we use the free [dweet.io](http://dweet.io) service in this chapter?
    Would you use this approach in a commercial IoT project?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want to test a RESTful API service from the command line. What command-line
    tool can we use?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What feature of MQTT can you use to have IoTrees initialize automatically when
    their Raspberry Pis are powered on or rebooted?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further to *Question 7*, what are some of the considerations you will need to
    make regarding the Mosquitto MQTT broker setup and deployments to achieve this
    outcome?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
