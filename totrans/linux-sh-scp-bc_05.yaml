- en: Chapter 5. Creating Interactive Scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter shows how to read the keyboard in order to create interactive scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered in this chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use the `read` built-in command to query the keyboard.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The different ways to use `read`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of traps (interrupts).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reader will learn how to create interactive scripts.
  prefs: []
  type: TYPE_NORMAL
- en: The scripts we have looked at up to this point have run without much user interaction.
    The `read` command is used to create scripts that can query the keyboard. The
    code can then take action based on the input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 - Script 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the output when run on my system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chapter 5 - Script 1](img/B07040_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is a good one to run on your system. Try several different strings, numbers,
    and so on. Notice how the returned string contains whitespace, special characters,
    and so on. You don't have to quote anything, and if you do those will be returned
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the `read` command to put a simple pause into your script.
    This will allow you to see the output before it scrolls off the screen. It can
    also be used when debugging which will be shown in [Chapter 9](ch09.html "Chapter 9. Debugging
    Scripts"), *Debugging Scripts*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following script shows how to create a pause when the output gets to the
    last line of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 - Script 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the output when run on my system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chapter 5 - Script 2](img/B07040_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: I pressed *Enter* twice, and then *Q* and *Enter* on the last one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try something a bit more interesting. This next script shows how to
    fill an array with values taken from the keyboard:'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 - Script 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chapter 5 - Script 3](img/B07040_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since this script does not require any parameters I decided to add a `Usage`
    statement. This will display if the user runs it with `--help` and is a common
    feature in many system scripts and programs.
  prefs: []
  type: TYPE_NORMAL
- en: The only thing new in this script is the `read` command. The `loop` and `array`
    variables were discussed in an earlier chapter. Note again that, with the `read`
    command what you type is what you get.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's create a complete interactive script. But first we need to check the
    size of the current terminal. If it is too small, the output of your script may
    become garbled and the user may not know why or how to fix it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following script contains a subroutine that checks the size of the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 - Script 4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Run this on your system with different-sized terminals to check the result.
    As you can see from the code, it's okay if the terminal is larger than needed;
    it just can't be too small.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A word about terminal sizes: When using the `tput` cursor movement commands
    remember that it is row then column. However, most modern GUIs go by column then
    row. This is unfortunate as it is very easy to get them mixed up.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at a full interactive script:'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 - Script 5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is some example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chapter 5 - Script 5](img/B07040_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There is a lot of new information here, so let's take a look. First the subroutines
    are defined, and you can see we included the `checktermsize` subroutine from the
    preceding *Script 4*.
  prefs: []
  type: TYPE_NORMAL
- en: The `init` routine sets up the cursor placement array. It's good programming
    practice to put initial values in a subroutine, particularly if it is going to
    be called again.
  prefs: []
  type: TYPE_NORMAL
- en: The `drawscreen` routine displays the initial form. Note that I could have used
    the values in the `srow` and `scol` array here, however, I didn't want the script
    to look too cluttered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look very carefully at the `getdata` routine because this is where the fun
    begins:'
  prefs: []
  type: TYPE_NORMAL
- en: First the array subscript `x` and control var `rc1` are set to `0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the loop the cursor is placed at the first position (`Name:`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The keyboard is queried and the user's input goes into the array at sub `x`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x` is incremented and we go to the next field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `x` is equal to the size of the array we leave the loop. Keep in mind that
    we start counting at `0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `showdata` routine displays the array data and then we are done.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that if the script is run with the `--help` option the `Usage` message
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: This is just a small example of an interactive script to show the basic concepts.
    In a later chapter we will go into this in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `read` command can be used in a number of different ways. Here are a few
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `-n` option means to wait for that number of characters and then continue,
    it does not wait for an *Enter* press.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example it will wait for 1 char and then go. This can be useful in
    utility scripts and games:'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 - Script 6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chapter 5 - Script 6](img/B07040_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The comments in the script should make this one pretty self explanatory. The
    `read` command has a few more options, one of which will be shown in the next
    script.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to query the keyboard is by using what is called a trap. This is
    a subroutine that is accessed when a special key sequence is pressed, such as
    *Ctrl* + *C*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of using a trap:'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 - Script 7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output on my system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chapter 5 - Script 7](img/B07040_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Try running this one on your system. Press some keys and see the response. Press
    *Ctrl* + *C* a few times as well. When done press *Q*.
  prefs: []
  type: TYPE_NORMAL
- en: That `read` statement needs some further explanation. Using `read` with the
    `-t` option (timeout) means to wait that many seconds for a character. If one
    is not input in the allotted time it will return a code with a value greater than
    128\. As we have seen before, the `-n 1` option tells `read` to wait for 1 character.
    So this means we are waiting 1 second for 1 character. This is another way `read`
    can be used to create a game or other interactive script.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using a trap is a good way to catch an accidental press of *Ctrl* + *C* which
    could cause data to be lost. One word of caution however, if you do decide to
    catch *Ctrl* + *C* make sure your script has some other way to exit. In the simple
    script above the user must type a *Q* to exit.
  prefs: []
  type: TYPE_NORMAL
- en: If you get yourself into a situation where you can't exit a script you can use
    the `kill` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if I had needed to stop `script7` the directions would be follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the terminal where `script7` was running you will see it has stopped with
    the word `Killed` in it.
  prefs: []
  type: TYPE_NORMAL
- en: Note, be sure to kill the right process!
  prefs: []
  type: TYPE_NORMAL
- en: In the example above, PID `29880` is my text editor session where I am writing
    `script7`. Killing that would not be a good idea :).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for some fun! The next script allows you to draw crude pictures on the
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 - Script 8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This was fun to write and a bit more fun to play with than I expected it to
    be.
  prefs: []
  type: TYPE_NORMAL
- en: One thing we haven't covered yet is the `case` statement. This is similar to
    an `if...then...else` but makes the code easier to read. Basically, the value
    that was input to the `read` statement is checked for a match in each `case` clause.
    If it matches, that stanza is executed and then control goes to the line after
    the `esac` statement. It also does this if there is no match.
  prefs: []
  type: TYPE_NORMAL
- en: Try this script, and remember to make the terminal 25x80 (or 80x25 if that is
    how your GUI works).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is just one example of what can be done with this script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chapter 5 - Script 8](img/B07040_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Well okay I guess this shows that I am not much of an artist. I will stick to
    programming and writing books.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we showed how to use the `read` built-in command to query the
    keyboard. We explained some of the different options to read and also covered
    the use of traps. A simple drawing game was also included.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will show how to automate a script so that it can run unattended.
    We will explain how `cron` can be used to run the script at a specific time. The
    archival programs `zip` and `tar` will also be covered as they are very useful
    when creating automated back up scripts.
  prefs: []
  type: TYPE_NORMAL
