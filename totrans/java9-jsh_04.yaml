- en: Chapter 4. Encapsulation of Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn the different members of a class in Java 9 and
    how they are reflected in members of the instances generated from a class. We
    will work with instance fields, class fields, setters, getters, instance methods,
    and class methods. We will:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand the members that compose a class in Java 9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declare immutable fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work with setters and getters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand access modifiers in Java 9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combine setters, getters, and a related field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transform values with setters and getters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use static fields and static methods to create values shared by all the instances
    of a class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding members composing a class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been working with a very simple `Rectangle` class. We created
    many instances of this class in JShell and we understood how the garbage collection
    works. Now, it is time to dive deeper into the different members that compose
    a class in Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list enumerates the most common element types that we can include
    in a class definition in Java 9\. Each member includes its equivalent in other
    programming languages to make it easy to translate our experience with other object-oriented
    languages into Java 9\. We have already worked with a few of these members:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Constructors**: A class might define one or more constructors. They are equivalent
    to initializers in other programming languages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class variables or class fields**: These variables are common to all the
    instances of the class, that is, their value is the same for all the instances.
    In Java 9, it is possible to access class variables from the class and from its
    instances. We don''t need to create a specific instance to access a class variable.
    Class variables are also known as static variables because they use the `static`
    modifier in their declarations. Class variables are equivalent to class attributes,
    class properties, and type properties in other programming languages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class methods**: These methods can be invoked with the class name. In Java
    9, it is possible to access class methods from the class and from its instances.
    We don''t need to create a specific instance to access a class method. Class methods
    are also known as static methods because they use the `static` modifier in their
    declarations. Class methods are equivalent to class functions and type methods
    in other programming languages. Class methods operate on a class as a whole, and
    have access to class variables, class constants, and other class methods, but
    they don''t have access to any instance members, such as instance fields or methods,
    because they operate at the class level with no instances at all. Class methods
    are useful when we want to include methods related to a class and we don''t want
    to generate an instance to call them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Constants**: When we declare class variables or class fields with the `final`
    modifier, we define constants whose value cannot be changed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fields, member variables, instance variables, or instance fields**: We worked
    with these in the previous examples. Each instance of the class has its own distinct
    copies of the instance fields, with their own values. Instance fields are equivalent
    to attributes and instance properties in other programming languages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Methods or instance methods**: These methods require an instance to be invoked
    and they can access the fields for the specific instance. Instance methods are
    equivalent to instance functions in other programming languages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nested classes**: These classes are defined within another class. Static
    nested classes use the `static` modifier. Nested classes that do not use the `static`
    modifier are also known as **inner classes**. Nested classes are also known as
    nested types in other programming languages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring immutable fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pokemon Go is a location-based augmented-reality game in which players use the
    mobile device's GPS capability to locate, capture, train, and make virtual creatures
    fight. This game had great success and popularized location-based and augmented-reality
    gaming. After its great success, imagine that we have to develop a Web Service
    that will be consumed by a similar game that makes virtual creatures battle.
  prefs: []
  type: TYPE_NORMAL
- en: We have to move to the world of virtual creatures. We will definitely have a
    `VirtualCreature` base class. Each specific type of virtual creature with unique
    characteristics that can participate in battles will be a subclass of `VirtualCreature`.
  prefs: []
  type: TYPE_NORMAL
- en: All the virtual creatures will have a name and they will be born in a specific
    year. The age is going to be extremely important for their performance in battles.
    Thus, our base class will have the `name` and `birthYear` fields that all the
    subclasses will inherit.
  prefs: []
  type: TYPE_NORMAL
- en: When we design classes, we want to make sure that all the necessary data is
    available to the methods that will operate on this data. For this reason, we encapsulate
    data. However, we just want relevant information to be visible to the users of
    our classes that will create instances, change the values of accessible fields,
    and call the available methods. We want to hide or protect some data that is just
    needed for internal use, that is, for our methods. We don't want to make accidental
    changes to sensitive data.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, when we create a new instance of any virtual creature, we can
    use both its name and birth year as two parameters for the constructor. The constructor
    initializes the values of two properties: `name` and `birthYear`. The following
    lines show a sample code that declares the `VirtualCreature` class. The code file
    for the sample is included in the `java_9_oop_chapter_04_01` folder, in the `example04_01.java`
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The next lines create two instances that initialize the values of the two fields
    and then use the `System.out.printf` method to display their values in JShell.
    The code file for the sample is included in the `java_9_oop_chapter_04_01` folder,
    in the `example04_01.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the results of the declaration of the class
    and the execution of the previous lines in JShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Declaring immutable fields](img/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We don't want a user of our `VirtualCreature` class to be able to change the
    name for a virtual creature after an instance is initialized because the name
    is not supposed to change. Well, some people change their names but this never
    happens with virtual creatures. There is a simple way to achieve this goal in
    our previously declared class. We can add the `final` keyword before the type
    (`String`) to define an immutable `name` field of type `String`. We can also add
    the `final` keyword before the type (`int`) when we define the `birthYear` field
    because the birth year will never change after we initialize a virtual creature
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines show the new code that declares the `VirtualCreature` class
    with two immutable instance fields: `name` and `birthYear`. Note that the constructor
    code doesn''t need to be changed, and it is possible to initialize the two immutable
    instance fields with the same code. The code file for the sample is included in
    the `java_9_oop_chapter_04_01` folder, in the `example04_02.java` file.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Immutable instance fields are also known as non-mutating instance fields.
  prefs: []
  type: TYPE_NORMAL
- en: The next lines create an instance that initializes the values of the two immutable
    instance fields and then use the `System.out.printf` method to display their values
    in JShell. The code file for the sample is included in the `java_9_oop_chapter_04_01`
    folder, in the `example04_02.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The next two lines of code try to assign a new value to the `name` and `birthYear`
    immutable instance fields. The code file for the sample is included in the `java_9_oop_chapter_04_01`
    folder, in the `example04_03.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The two lines will fail to do so because Java doesn''t allow us to assign a
    value to a field declared with the `final` modifier that transforms it into an
    immutable field. The next screenshot shows the errors displayed in JShell after
    each line that tries to set a new value to the immutable fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Declaring immutable fields](img/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we use the `final` keyword to declare an instance field, we can initialize
    the field but it becomes immutable, that is, a constant, after its initialization.
  prefs: []
  type: TYPE_NORMAL
- en: Working with setters and getters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been working with fields to encapsulate data in our instances.
    We could access the fields without any kind of restrictions as member variables
    for an instance. However, as it happens sometimes in real-world situations, restrictions
    are necessary to avoid serious problems. Sometimes, we want to restrict access
    or transform specific fields into read-only fields. We can combine the access
    restrictions to an underlying field with methods known as setters and getters.
  prefs: []
  type: TYPE_NORMAL
- en: '**Setters** are methods that allow us to control how values are set; that is,
    these methods are used to change the values of related fields. **Getters** allow
    us to control the values that we return when we want to retrieve the value for
    a related field. Getters don''t change the values of related fields.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While some frameworks such as JavaBeans force you to work with setters and getters
    for each related field to be accessible, in other cases, setters and getters won't
    be necessary. In the next examples we will work with mutable objects. In the next
    chapter, [Chapter 5](part0052_split_000.html#1HIT81-bc1530b4c4784270ae8a31a7038f8341
    "Chapter 5. Mutable and Immutable Classes"), *Mutable and Immutable Classes*,
    we will work with both mutable and immutable objects. When working with immutable
    objects, getters and setters are useless.
  prefs: []
  type: TYPE_NORMAL
- en: As previously explained, we don't want a user of our `VirtualCreature` class
    to be able to change the birth year for a virtual creature after an instance is
    initialized because the virtual creature won't be born again at a different date.
    In fact, we want to calculate and make the age for the virtual creature available
    to users. Because we only take into account the birth year, we will calculate
    an approximated age. We keep the example simple to keep the focus on the getters
    and setters.
  prefs: []
  type: TYPE_NORMAL
- en: We can define a getter method called `getAge` without defining a setter method.
    This way, it is possible to retrieve the age for the virtual creature, but we
    cannot change it because there isn't a setter method. The getter method returns
    the result of calculating the age for the virtual creature age based on the current
    year and the value of the `birthYear` immutable instance field.
  prefs: []
  type: TYPE_NORMAL
- en: The following lines show the new version of the `VirtualCreature` class with
    the new `getAge` method. Notice that it is necessary to import `java.time.Year`
    to use the `Year` class that was introduced in Java 8\. The code for the `getAge`
    method is highlighted in the next lines. The method calls `Year.now().getValue`
    to retrieve the year component for the current date and returns the difference
    between the current year and the value of the `birthYear` field. The code file
    for the sample is included in the `java_9_oop_chapter_04_01` folder, in the `example04_04.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The next lines create an instance that initializes the values of the two immutable
    instance fields and then use the `System.out.printf` method to display the value
    returned by the `getAge` method in JShell. Enter the lines after the code that
    creates the new version of the `VirtualCreature` class. The code file for the
    sample is included in the `java_9_oop_chapter_04_01` folder, in the `example04_04.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The next screenshot shows the results of executing the previous lines in JShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with setters and getters](img/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: After a few meetings with experts in virtual creatures, we realize that some
    of them go to a planet to evolve and are born again from an egg after evolving.
    Because the evolution happens in a different planet, the birth year for the virtual
    creature changes to have an equivalent birth year in the Earth. Thus, it is necessary
    to allow the user to customize either the age or the birth year for a virtual
    creature. We will add a setter method with code that calculates the birth year
    based on the specified age and assigns this value to the `birthYear` field. First,
    we must remove the `final` keyword when we declare the `birthYear` field because
    we want it to become a mutable field.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is another way of working with the evolution of a virtual creature. We
    can create another instance that represents the evolved virtual creature. We will
    use this immutable approach in the next chapter, [Chapter 5](part0052_split_000.html#1HIT81-bc1530b4c4784270ae8a31a7038f8341
    "Chapter 5. Mutable and Immutable Classes"), *Mutable and Immutable Classes*.
    In this case, we will work with a mutable object. After we understand all the
    possibilities, we can decide the best option based on our specific needs.
  prefs: []
  type: TYPE_NORMAL
- en: The following lines show the new version of the `VirtualCreature` class with
    the new `setAge` method. The code for the `setAge` method is highlighted in the
    next lines. The method receives the new age we want for the virtual creature in
    the `age` parameter. The code calls `Year.now().getValue` to retrieve the year
    component for the current date and assigns the difference between the current
    year and the value received in `age`. This way, the `birthYear` field will save
    the year in which the virtual creature was born based on the received `age` value.
    The code file for the sample is included in the `java_9_oop_chapter_04_01` folder,
    in the `example04_05.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The next lines create two instances of the new version of the `VirtualCreature`
    class, call the `setAge` method with the desired age for the virtual creature,
    and then use the `System.out.printf` method to display the value returned by the
    `getAge` method and the `birthYear` field in JShell. Enter the lines after the
    code that creates the new version of the `VirtualCreature` class. The code file
    for the sample is included in the `java_9_oop_chapter_04_01` folder, in the `example04_05.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result of calling the `setAge` method with a new age value, the method
    changes the value of the `birthYear` field. Based on the current year value, the
    results of running the code will be different. The next screenshot shows the results
    of executing the previous lines in JShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with setters and getters](img/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Both the getter and setter methods use the same code to retrieve the current
    year. We can add a new method that retrieves the current year and call it from
    both the `getAge` and `setAge` methods. In this case, it is just a line of code,
    but the new method provides us with an example of how we can add methods that
    will be consumed in our class and help other methods to do their job. Later, we
    will learn how to avoid these methods being called from an instance because they
    are intended for internal use only.
  prefs: []
  type: TYPE_NORMAL
- en: The following lines show the new version of the `SuperHero` class with the new
    `getCurrentYear` method. The new code for the `getAge` and `setAge` methods calls
    the new `getCurrentYear` method instead of repeating code that was intended to
    retrieve the current year. The code file for the sample is included in the `java_9_oop_chapter_04_01`
    folder, in the `example04_06.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The next lines create two instances of the `VirtualCreature` class, call the
    `setAge` method with the desired age for the virtual creature, and then use the
    `System.out.printf` method to display the value returned by the `getAge` method
    and the `birthYear` field in JShell. Enter the lines after the code that creates
    the new version of the `VirtualCreature` class. The code file for the sample is
    included in the `java_9_oop_chapter_04_01` folder, in the `example04_06.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The next screenshot shows the results of executing the previous lines in JShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with setters and getters](img/00049.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Exploring access modifiers in Java 9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previously declared `VirtualCreature` class exposes all of its members (fields
    and methods) without any kind of restriction because we declared them without
    using any access modifier. Thus, the user of our class can access any of the fields
    and call any of the declared methods after the user creates an instance of the
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Java 9 allows us to control access to members of a call by using access level
    modifiers. Different keywords allow us to control which code has access to a specific
    member of a class. So far, we could access fields and methods within a class definition
    and outside of a class declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use any of the following access modifiers instead of `public` to restrict
    access to any field:'
  prefs: []
  type: TYPE_NORMAL
- en: '`protected`: Java doesn''t allow users to access the member outside of the
    class definition. Only the code within the class or its derived classes can access
    the field. Any subclass of a class that declares a member with the `protected`
    access modifier will be able to access the member.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private`: Java doesn''t allow users to access the field outside of the class
    definition. Only the code within the class can access the field. Its derived classes
    cannot access the field. Thus, any subclass of a class that declares a member
    with the `private` access modifier won''t be able to access the member.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following line shows how we can change the declaration of the `birthYear`
    instance field to a `protected` field. We just need to add the `protected` keyword
    to the field declaration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Whenever we use the `protected` access modifier in a field declaration, we restrict
    access to this field to the code written within the class definition and within
    subclasses. Java 9 generates a real shield for the fields marked as `protected`
    and there is no way to access them outside of the explained boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: The following line shows how we can change the declaration of the `birthYear`
    protected instance field to a `private` field. We replace the `protected` access
    modifier with `private`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Whenever we use the `private` access modifier in a field declaration, we restrict
    access to this field to the code written within the class definition and within
    subclasses. Java generates a real shield for the fields marked as `private` and
    there is no way to access them outside of the class definition. The restriction
    also applies to subclasses, and therefore, only the code written within the class
    can access attributes marked as private.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can apply the previously explained access modifiers for any type member,
    including class variables, class methods, constants, fields, methods, and nested
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: Combining setters, getters, and fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we want to have more control over the values that are set to related
    fields and retrieved from them, and we can take advantage of getters and setters
    to do so. We can combine a getter, a setter, a related field that stores a computed
    value, and the access protection mechanisms to prevent the user from making changes
    to the related field. This way, we will force the user to always use the getters
    and setters.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual creatures love any kind of hat. The hat for a virtual creature can change
    over time. We have to make sure that the hat's name is in capital letters, that
    is, an uppercased `String`. We will define a `setHat` method that always generates
    an uppercased `String` from the received `String` and stores it in a private `hat`
    field.
  prefs: []
  type: TYPE_NORMAL
- en: We will provide a `getHat` method to retrieve the value stored in the private
    `hat` field. The following lines show a new version of the `VirtualCreature` class
    that adds a `hat` private instance field and the `getHat` and `setHat` methods.
    We use the previously learned access modifiers for the different members of the
    class. The code file for the sample is included in the `java_9_oop_chapter_04_01`
    folder, in the `example04_07.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you work with specific early versions of JDK, when you enter the previous
    code in JShell, you might see the following warning message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: JShell doesn't allow us to use access modifiers in top-level declarations, such
    as a class declaration. However, we specify the access modifier because we want
    to code as if we were writing the class declaration outside of JShell. JShell
    simply ignores the `public` access modifier for the class and some versions of
    the JDK that incuded JShell made the REPL display the previously shown warning
    message. If you see these messages, you should upgrade the installed JDK to the
    newest version that doesn't display the warning messages anymore.
  prefs: []
  type: TYPE_NORMAL
- en: We declared both the `birthyear` and `hat` instance fields as `private`. We
    declared the `getCurrentYear` method as `protected`. When a user creates an instance
    of the `VirtualCreature` class, the user won't be able to access any of these
    `private` members. This way, the `private` members will be hidden for those who
    create instances of the `VirtualCreature` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We declared `name` as a `public` immutable instance field. We declared the
    following methods as `public`: `getAge`, `setAge`, `getHat`, and `setHat`. When
    a user creates an instance of the `VirtualCreature` class, he will be able to
    access all of these `public` members.'
  prefs: []
  type: TYPE_NORMAL
- en: The constructor added a new argument that provides an initial value for the
    new `hat` field. The code in the constructor calls the `setHat` method with the
    received `hat` argument as a parameter to make sure that an uppercase `String`
    is generated from the received `String` and the resulting `String` is assigned
    to the `hat` field.
  prefs: []
  type: TYPE_NORMAL
- en: The next lines create two instances of the `VirtualCreature` class, use the
    `printf` method to display the value returned by the `getHat` method, call the
    `setHat` method with the desired new hat for the virtual creature, and then use
    the `System.out.printf` method to display the value returned by the `getHat` method
    again. Enter the lines after the code that creates the new version of the `VirtualCreature`
    class. The code file for the sample is included in the `java_9_oop_chapter_04_01`
    folder, in the `example04_07.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The next screenshot shows the results of executing the previous lines in JShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Combining setters, getters, and fields](img/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can combine the getter and setter methods, along with access protection mechanisms
    and a related field that acts as an underlying field, to have absolute control
    over how values are set to and retrieved from the underlying field in mutable
    objects. However, we must make sure that the initialization must also use the
    setter method, as we did when we set the initial value received in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: The next lines will try to access a private field and a private method for the
    instances of the `VirtualCreature` class we have created. Both lines will fail
    to compile because we cannot access private members in an instance. The first
    line tries to access the `hat` instance field and the second line tries to call
    the `getCurrentYear` instance method. The code file for the sample is included
    in the `java_9_oop_chapter_04_01` folder, in the `example04_08.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The next screenshot shows the error messages generated in JShell when we try
    to execute the previous lines.
  prefs: []
  type: TYPE_NORMAL
- en: '![Combining setters, getters, and fields](img/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Transforming values with setters and getters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can define a setter method that transforms a received value to a valid value
    for a related field. The getter method would just need to return the value of
    the related field. The user will only be able to work with the setter and getter
    methods and our related field will always have a valid value. This way, we can
    make sure that whenever we require the value, we will retrieve a valid value.
  prefs: []
  type: TYPE_NORMAL
- en: Each virtual creature has a visibility level that determines how easy it is
    for anybody to visualize the virtual creature's body. We will add a private `visibilityLevel`
    field, a `setVisibility` method, and a `getVisibility` method. We will change
    the constructor code to call the `setVisiblity` method to set an initial value
    for the `visibilityLevel` field.
  prefs: []
  type: TYPE_NORMAL
- en: We want to make sure that the visibility level is a number from `0` to `100`
    (inclusive). Thus, we will code the setter method to transform the values lower
    than `0` to `0` and values higher than `100` to `100`. The `setVisibility` method
    saves either the transformed or the original value that is in a valid range in
    the related private `visibilityLevel` field.
  prefs: []
  type: TYPE_NORMAL
- en: The edited lines and the new lines are highlighted. The code file for the sample
    is included in the `java_9_oop_chapter_04_01` folder, in the `example04_09.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The next lines create an instance of `VirtualCreature` that specifies `150`
    as the value for the `visibilityLevel` argument. Then, the next line uses the
    `System.out.printf` method to display the value returned by the `getVisibilityLevel`
    method in JShell. Then, we call `setVisibilityLevel` and `getVisibilityLevel`
    three times, to set values to `visibilityLevel,` and then check the values that
    were finally set. Enter the lines after the code that creates the new version
    of the `VirtualCreature` class. The code file for the sample is included in the
    `java_9_oop_chapter_04_01` folder, in the `example04_09.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The constructor calls the `setVisibilityLevel` method to set the initial value
    for the `visibilityLevel` related private field, and therefore, the method makes
    sure that the value is in the valid range. The code specified `150` but the maximum
    value is `100`, and therefore, the `setVisibilityLevel` assigned `100` to the
    `visibilityLevel` related private field.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we called the `setVisibilityLevel` with `-6` as an argument, we printed
    the value returned by `getVisibilityLevel` and the result was `0`. After we specified
    `320`, the actual printed value was `100`. Finally, after we specified `25`, the
    actual printed value was `25`. The next screenshot shows the results of executing
    the previous lines in JShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Transforming values with setters and getters](img/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using static fields to provide class-level values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, all the members of a class share the same attribute, and we don''t
    need to have a specific value for each instance. For example, virtual creature
    types have the following profile values:'
  prefs: []
  type: TYPE_NORMAL
- en: Attack power
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defense power
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special attack power
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special defense power
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Average speed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Catch rate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Growth rate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A first approach we might think useful for this situation is to define the
    following class constants to store the values that are shared by all the instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ATTACK_POWER`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DEFENSE_POWER`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SPECIAL_ATTACK_POWER`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SPECIAL_DEFENSE_POWER`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AVERAGE_SPEED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CATCH_RATE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GROWTH_RATE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note the usage of uppercase and words separated by underscores (`_`) for class
    constant names. This is a naming convention in Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: The following lines show a new version of the `VirtualCreature` class that defines
    the seven previously listed class constants with the `public` access modifier.
    Notice that the combination of the `final` and `static` keywords makes them class
    constants. The code file for the sample is included in the `java_9_oop_chapter_04_01`
    folder, in the `example04_10.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The code initializes each class constant in the same line that declares them.
    The following lines print the value of the previously declared `SPECIAL_ATTACK_POWER`
    and `SPECIAL_DEFENSE_POWER` class constants. Notice that we didn't create any
    instance of the `VirtualCreature` class and that we specified the class constant
    name after the class name and a dot (`.`). The code file for the sample is included
    in the `java_9_oop_chapter_04_01` folder, in the `example04_10.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Java 9 allows us to access a class constant from an instance, and therefore,
    we can use either the class name or an instance to access a class constant. The
    following line creates an instance of the new version of the `VirtualCreature`
    class named `golbat` and prints the value of the `GROWTH_RATE` class constant,
    accessed from this new instance. The code file for the sample is included in the
    `java_9_oop_chapter_04_01` folder, in the `example04_10.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The next screenshot shows the results of executing the previous lines in JShell.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using static fields to provide class-level values](img/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using static methods to provide overridable class-level values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Class constants have a great limitation: we cannot provide new values to them
    in future subclasses of the `VirtualCreature` class that represent specific types
    of virtual creatures. It makes sense, because they are constants. These subclasses
    need to set a different value for `ATTACK_POWER` or `AVERAGE_SPEED`. Instead of
    working with class constants, we can create the following class methods that return
    the average values for each profile value. We will be able to make these methods
    return a different value in subclasses of the `VirtualCreature` class.'
  prefs: []
  type: TYPE_NORMAL
- en: '`getAttackPower`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getDefensePower`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getSpecialAttackPower`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getSpecialDefensePower`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getAverageSpeed`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getCatchRate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getGrowthRate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following lines show a new version of the `VirtualCreature` class that defines
    the seven previously listed class methods with the `public` access modifier. Notice
    that the usage of the `static` keyword in the method declarations makes them class
    methods. The code file for the sample is included in the `java_9_oop_chapter_04_01`
    folder, in the `example04_11.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The following lines print the value returned by the previously declared `getSpecialAttackPower`
    and `getSpecialDefensePower` class methods. Notice that we didn't create any instance
    of the `VirtualCreature` class and that we specified the class method name after
    the class name and a dot (`.`). The code file for the sample is included in the
    `java_9_oop_chapter_04_01` folder, in the `example04_11.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As happened with class constants, Java 9 allows us to access a class method
    from an instance, and therefore, we can use either the class name or an instance
    to access a class method. The following line creates an instance of the new version
    of the `VirtualCreature` class named `vulpix` and prints the value returned by
    the `getGrowthRate` class method, accessed from this new instance. The code file
    for the sample is included in the `java_9_oop_chapter_04_01` folder, in the `example04_11.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The next screenshot shows the results of executing the previous lines in JShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using static methods to provide overridable class-level values](img/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We use the `static` keyword followed by a method declaration to define:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An instance method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A class method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A class constant.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We use the `final` static keywords followed by an initialized variable declaration
    to define a:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Class constant.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Class variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instance constant.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A class constant:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Has its own and independent value for each instance of the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Has the same value for all the instances of the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Has the same value for all the instances of a class, unless it is accessed through
    the class name followed by a dot (`.`) and the constant name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An instance field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Has its own and independent value for each instance of the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Has the same value for all the instances of the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Has the same value for all the instances of a class, unless it is accessed through
    the class name followed by a dot (`.`) and the instance field name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In Java 9, `public`, `protected`, and `private` are:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Three different classes defined in `java.lang`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Three equivalent access modifiers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Three different access modifiers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the different members that can compose a
    class declaration in Java 9\. We worked with instance fields, instance methods,
    class constants, and class methods. We worked with getters and setters, and we
    took advantage of access modifiers to hide data that we didn't want the users
    of our classes to be able to access.
  prefs: []
  type: TYPE_NORMAL
- en: We worked with virtual creatures. First, we declared a simple class and then
    we made it evolve with additional features. We tested how everything worked in
    JShell.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned about data encapsulation, you are ready to work with
    mutable and immutable versions of classes in Java 9, which is what we are going
    to discuss in the next chapter.
  prefs: []
  type: TYPE_NORMAL
