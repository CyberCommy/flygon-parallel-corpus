- en: Working with NG Bootstrap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Bootstrap is one of the most popular CSS frameworks around—and Angular is one
    of the most popular web application frameworks around. NG Bootstrap is a collection
    of widgets (that is, components) that are built from Bootstrap 4 CSS. They are
    tailor-made to be used as Angular components, and are intended to be a complete
    replacement of Bootstrap components, which are powered by JavaScript. A few examples
    of JavaScript-powered Bootstrap components include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Carousel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collapse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Popovers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tooltips
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we're going to continue our exploration of components, but
    will focus on ng-bootstrap, which is a third-party Angular component library,
    as opposed to being a part of the Angular code base. This chapter, and [Chapter
    9](1a222c0e-7130-4ac2-959d-ae9d6cc1ca7d.xhtml), *Working with Angular Material*,
    are relatively short chapters, but I wanted to include them in this book for the
    same reason I mentioned for having included [Chapter 5](7a55c9e9-7f80-41bc-9678-eb191fdc4c2d.xhtml), *Flex-Layout
    – Angular's Responsive Layout Engine*—and that is to give you choices. In the
    context of this chapter, that means having choices of ready-made components that
    you can leverage for your Angular applications.
  prefs: []
  type: TYPE_NORMAL
- en: ng-bootstrap doesn't have an official acronym, but for the purposes of convenience,
    in this chapter, I'm going to give it one. We'll be referring to NG Bootstrap
    as NGB—which, as it turns out, is also a fun thing to type on the keyboard (since
    the letters are so closely placed together). Try it.
  prefs: []
  type: TYPE_NORMAL
- en: 'As in all the other chapters in this book, I will not consume page upon page
    to simply regurgitate NGB''s official documentation, which is freely available
    online, just to make the book seem formidable. I''d rather give you a 300-to 400-page
    book filled with hand-selected goodness that keeps you reading, rather than a
    500-600-page book that can be used as a sleep narcotic, for your hard-earned money.
    That being said, NGB''s official online documentation can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://ng-bootstrap.github.io](https://ng-bootstrap.github.io).'
  prefs: []
  type: TYPE_NORMAL
- en: One last thing I wanted to mention really quickly is that this chapter and the
    following one ([Chapter 8](784689d5-c12c-4a1d-b2a4-dfcdbe7e6d38.xhtml), *Working
    with NG Bootstrap*) will be a lot more visual than the other chapters in the book.
    This is because we're now getting into the actual meat of our example application,
    and we're going to start building things out visually.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the housekeeping matters now out of the way, here''s what we''re going
    to be covering together in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Integrating NGB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NGB widgets (specifically, collapse, modal, and carousel)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design rules of thumb that we should think about to help avoid overuse of widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating NGB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NGB's purpose in life is to be a complete replacement for Bootstrap's components
    that require JavaScript (such as the components listed at the beginning of the
    chapter). In fact, on the very first page of the *Getting Started* section on
    their official website, they go further and say that you shouldn't be using any
    JavaScript-based components at all—or even their dependencies, such as jQuery or
    Popper.js. This can be found at: [https://ng-bootstrap.github.io/#/getting-started](https://ng-bootstrap.github.io/#/getting-started).
  prefs: []
  type: TYPE_NORMAL
- en: Installing NBG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First things first: before we take a look at a caveat that we need to be aware
    of when using NGB, let''s add it to our project—and I''ll also show you how to
    fix the conflicting libraries that you may encounter (by showing you my `package.json`
    file).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing NGB is straightforward using `npm`. But, like other modules, we
    also need to import it and list it in our root module (that is, `app.module.ts`).
    Here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Run `npm install`: `npm install --save @ng-bootstrap/ng-bootstrap`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import NGB into our root module: `import {NgbModule} from '@ng-bootstrap/ng-bootstrap';`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: List `NgbModule` in the imports array (as a parameter to the root module's `@NgModule`
    decorator) like this: `NgbModule.forRoot()`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you create an Angular module that uses NGB, you'll have to import NGB into
    it as well. The syntax for importing NGB into other modules is the exact same
    as the one just outlined for importing it into our root module, but the syntax
    for listing the NGB module as a parameter to the module's `@NgModule` decorator
    is slightly different. It's just listed in the imports array as `NgbModule`, as
    opposed to `NgbModule.forRoot()`, as we have to list it in our root module.
  prefs: []
  type: TYPE_NORMAL
- en: So, how are we going to take a look at a few of their components without unintentionally
    messing up the NGB portions of our example application? There's only one way—we're
    going to make sure that we do not directly or indirectly load jQuery or Popper.js
    into our example application, by not using the Bootstrap components (make sure
    you understand that Bootstrap and NGB are two different libraries).
  prefs: []
  type: TYPE_NORMAL
- en: Let me clarify something real quick. We have jQuery and Popper.js installed
    in our example application, and you can verify this by taking a look at our `package.json`
    file. In it, you will see entries for jQuery and Popper.js listed in the dependencies
    section. We are not going to be uninstalling these libraries. They are harmless
    to our use of NGB as long as we don't load them by also using Bootstrap. To put
    it another way, NGB components and Bootstrap components should not coexist in
    our Angular applications. We can use one or the other without issue—but never
    both. Does that make sense? OK, good.
  prefs: []
  type: TYPE_NORMAL
- en: If you try to remove jQuery and/or Popper.js from the project, you will likely
    get several compile warnings whenever you run the project. While warnings may
    not prevent the project from running, always try to strive for clean builds.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chore of ensuring you get a clean build can sometimes be a pain in the
    neck, because you need to pay attention to the versions of your libraries. The
    code listing that follows is my `package.json` file. I consistently get a clean
    install compilation when I run `npm install` and then `npm start`. If you''re
    not getting a clean compilation, you may want to compare your `package.json` against
    mine, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can take a look at the list of available Angular modules, and their latest
    version numbers, that you can install with `npm` at: [https://www.npmjs.com/~angular](https://www.npmjs.com/~angular).
  prefs: []
  type: TYPE_NORMAL
- en: Why use NGB?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the restrictions of not being able to have JavaScript-based components,
    nor directly using JavaScript libraries such as jQuery or Popper.js, you may be
    asking, *why use NGB at all*?
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s a good question. Here''s the short answer, in point form:'
  prefs: []
  type: TYPE_NORMAL
- en: Angular does not depend on jQuery. It uses its own implementation of jQuery,
    called jQLite, which is a subset of jQuery.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We don't lose out on being able to use any Bootstrap components that are powered
    by JavaScript (such as modal or carousel) because they are re-done for Angular
    in NGB. Again, NGB's sole purpose in life is to completely replace any JavaScript-powered
    Bootstrap components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A rule of thumb when building Angular applications is to try to only use Angular-specific
    components; that is to say, components that are specifically made for Angular—such
    as NGB widgets and components from Angular Material. This, of course, includes
    creating your own custom Angular components. Though you can work around this by
    jerry-rigging non-Angular-specific components, it's not recommended. Angular is
    full featured, and as we've learned, it's also extremely extensible. It would
    be very difficult to think of a use case where sticking to Angular-specific components,
    modules, directives, pipes, services, and so on would prevent you from doing what
    you needed to do.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NGB is a solid Angular-centric component library and works well when you don't
    try to create workarounds that are discouraged.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating our playground for NGB (and Angular Material, and more)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are only two dependencies for NGB (Angular and Bootstrap CSS), and luckily
    our, example application already has these two things in place—one by default
    (since our example application is an Angular application), and the other from
    our having installed Bootstrap during [Chapter 3](6694dd13-5500-4563-9688-74a21a06a9a9.xhtml),
    *Bootstrap – Grid Layout and Components*. However, we are going to add something
    to our example application so that we can experiment with using NGB components—a
    playground view.
  prefs: []
  type: TYPE_NORMAL
- en: A long-standing traditional thing I do when building web applications of any
    technology stack, and not just for Angular applications, is to add a page as a
    place where I can experiment with stuff within the context of the application
    that I'm building at the time. I refer to that as a playground. In our case, our playground
    will be a component whose template will act as our experimental canvas as we explore
    a few NGB components. We're also going to hook it up to our menu so that we can
    access it easily.
  prefs: []
  type: TYPE_NORMAL
- en: We'll hang on to our playground view throughout the rest of the book, only deleting
    it in [Chapter 15](f81ae891-b2dc-4620-bb4a-ad099c96e8a0.xhtml), *Deploying Angular
    Applications*, where we'll learn how to deploy our application and won't want
    our playground to go along for the ride.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's do that now. It has been a while since we've added components to our
    example application that we created in [Chapter 4](66c21daa-b131-470d-a21b-0fbed56c3ec9.xhtml),
    *Routing*, and so I wanted to take this opportunity to enumerate the steps to
    do this (within their own sections that follow) using the addition of the playground
    as the example. Note that this is the manual way of adding a component to our
    project—unlike using the CLI to add it for us, as we did a few chapters ago.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a playground directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we need to do is to create a directory that will hold the files
    we'll need for our playground component. Each of our components has its own directory,
    and are all subdirectories the `app` directory—which is itself a subdirectory
    of the `src` directory within the project root directory.
  prefs: []
  type: TYPE_NORMAL
- en: Since we're adding a new component, we'll follow our convention and create a
    directory for it. In your IDE, right-click the `app` directory, select `New Folder`*,*
    and enter `playground` as the name*—*which follows our convention that we've used
    so far. Once that is done, we'll have a place to insert the files that will collectively
    make up our component.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the playground component class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now need to create our playground component class. In your IDE, right-click
    the newly created `playground` directory and select `New File` and enter `playground.component.ts` as
    the name. The `playground.component.ts` file our `component` class. Enter the
    following code in this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'By looking at our playground `Component` class file, you''ll notice a few things:'
  prefs: []
  type: TYPE_NORMAL
- en: We're importing `OnInit`, in addition to the component from the `@angular/core`
    module. This is because we're giving ourselves a place to set up some variables
    if we need to—such as for passing in any child components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've included a constructor for our class. Whether we use it or not, it provides
    us with a mechanism to tap into our component's life cycle to trigger some code
    if we wanted to. We won't use this right now, but I wanted to show you that our
    `components` function as traditional object-oriented classes, and thus have a
    constructor that we can leverage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've set up our component to use external files for its template and its style,
    as opposed to having them inline. So, the next piece of business is to create
    these two files (see the following two sections).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a single property (that is, `pageTitle`) declared in our class as a
    string, and we've assigned the name of our view to it. Our template in the following
    section displays this property using the one-way binding syntax.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the playground template file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now need to create the template file for our playground component, which
    will be our component''s visual interface. In your IDE, right-click the `playground` directory,
    select `New File`, and enter `playground.component.html`. The `playground.component.html`file
    is required because we''ve passed it into our component decorator as one of the
    parameters. Enter the following code in this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: There's not much in this file yet—but this is where we'll be adding the NGB
    components so that we can experiment with them. Experimenting, of course, is the
    very best way to learn any technology that may be new to you. The only thing our
    template does for now is to display our page name—by binding to our class's `pageTitle`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the playground CSS file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final file we need to create for our playground component is that which
    will house its styles. In your IDE, right-click the `playground` directory, select `New
    File`, and enter `playground.component.css` as the name. The `playground.component.css`file
    is also required because we''ve passed it into our component decorator as one
    of the parameters. Enter the following code in this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is self-explanatory. We don't have any styles in this file
    yet—but it's good to create at least one CSS file for every component that you
    create.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the playground menu item
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OK. So, after from following the directions in the preceding sections, you should
    now have a playground component that you can use as a sandbox for experimenting
    with almost anything you want. In our immediate case, we'll be using it for experimenting
    with NGB widgets (that is, components), but we'll also be using this sandbox during
    [Chapter 9](1a222c0e-7130-4ac2-959d-ae9d6cc1ca7d.xhtml), *Working with Angular
    Material*.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on to inserting the first NGB widget, we'll be taking a look
    at. It's a good idea to create a temporary menu link for our playground view so
    that we can get to it easily from within our application. Let's do this now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your IDE, open your `app.component.html` file. This is the main, or starting,
    a template that is loaded for your Angular application during the bootstrapping
    process. It is also where we created our menu in [Chapter 4](66c21daa-b131-470d-a21b-0fbed56c3ec9.xhtml),
    *Routing*. In this file, insert the following code after the listings menu item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: All this small HTML code snippet does is to add a `playground` navigation link
    in our menu, and instruct Angular's routing system to load the playground component
    (and thus the playground template, and then recursively load any child components)
    when it is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: OK, good—we're now all set up and ready to take a look at our first NGB widget.
  prefs: []
  type: TYPE_NORMAL
- en: NGB widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As previously mentioned, NGB widgets are third-party Angular components that
    are designed to replace the JavaScript-driven Bootstrap CSS components. NGB has
    many widgets available, but we're only going to be looking at three of them in
    the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the entire list of NGB widgets, along with their documentation,
    at: [https://ng-bootstrap.github.io/#/components/](https://ng-bootstrap.github.io/#/components/).
  prefs: []
  type: TYPE_NORMAL
- en: Collapse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The collapse component is a useful thing to use to preserve screen real estate.
    Our use case for the use of this component will be for toggling instructions to
    be either displayed or hidden. The state of the component would initially be collapsed
    when its parent component's template is rendered, but the user would be able to
    toggle the instructions to be shown and re-collapse them as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at a quick example in the code that we can try out in our
    playground which toggles the display of a section of the page on and off—in our
    case, this content will be hypothetical instructions (for now).
  prefs: []
  type: TYPE_NORMAL
- en: We need to modify three files to make this work. The use of other NGB components
    (and even the Angular Material components that we'll be looking at in the next
    chapter) work similarly, so I'll take the time to explain things after each code
    listing because this is the very first third-party component that we're looking
    at together. When looking at similar components later on, any explanations will
    given if they differ substantially from these ones.
  prefs: []
  type: TYPE_NORMAL
- en: Our parent component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, as well as [Chapter 8](784689d5-c12c-4a1d-b2a4-dfcdbe7e6d38.xhtml),
    *Working with NG Bootstrap*, our parent component will always be our playground
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify your playground component template (which is  `playground.component.html`
    file) so that it looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The only new thing we've added that is of any importance to our playground template
    is  `<ngb-collapse></ngb-collapse>`, which is our custom directive that will instruct
    Angular to insert our child component's template there. `ngb-collapse` is the
    selector in our component class's metadata (that is, the object we passed to the
    component decorator). Let's take a look at that file next.
  prefs: []
  type: TYPE_NORMAL
- en: Our NGB collapse component class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've named our component class (which leverages NGB's `collapse` component)
    *`NgbCollapseComponent`—*but where does this code live? Well, we need to create
    a new directory and two new files within that directory just like we did when
    we created our playground component. Yes—we created three files for our playground
    component, but we'll be skipping the CSS file for `NgbCollapseComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a directory called `ngb-collapse`. Within that new directory,
    create a file named `ngb-collapse.component.ts` and add the following code in
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we've not defined a `styleUrls` array, which is why we don't
    require a file for it (which we would have named something like `ngb-collapse.component.css`
    if we wanted this component to have styling). For the purposes of experimenting
    with the NBG collapse component, we only care about creating a component class
    file and its template file.
  prefs: []
  type: TYPE_NORMAL
- en: The other thing of interest to us in our component class file is the `isCollapsed`
    property. We can, of course, name it whatever we want, but the important thing
    is that it is declared and is initially set to `true`. We're going to use this
    property by binding its value to the `ngbCollapse` attribute within our template
    file. Doing so will cause a part of our component template to be either collapsed
    (hidden) or expanded (displayed). Note that I emphasized that our targeted content
    within our component will either be hidden or displayed, as opposed to being either
    added to or removed from the DOM. If our content is hidden (that is, non-visible),
    it is still in the DOM. This is because the NGB collapse widget does not function
    as a structural directive. It achieves its hide/show functionality via attribute
    binding.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now take a look at the third file, the component template for our
  prefs: []
  type: TYPE_NORMAL
- en: '`NgbCollapseComponent` class.'
  prefs: []
  type: TYPE_NORMAL
- en: Our NGB collapse component template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create another file within the `ngb-collapse` directory, name it `ngb-collapse.component.ts`,
    and add the following code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at this code together. The first thing of interest to us is the
    binding of the `click` event to the expression, which basically toggles our `isCollapsed`
    variable, defined in our component class, between `true` and `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The text for our toggle button is always set to one of two values. When the
    instructions are displayed, the button text reads Hide Instructions. When the
    instructions are hidden, the button text reads Show Instructions. This is, of
    course, the behavior we want, but at first glance, you may assume that it takes
    an `if .. else` construct to make it all work. Surprisingly, thanks to Angular''s
    interpolation template syntax, it only takes a tiny amount of code to alter the
    button''s text depending on the value of our `isCollapsed` variable. Let''s take
    a moment to see the tiny code snippet responsible for determining what the button
    text should be, and how it renders it for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In [Chapter 7](cd8509d5-4bce-4056-8156-557186df18cd.xhtml), *Templates, Directives,
    and Pipes*, we took a look at all the symbols that we can use in our template
    syntax—such as interpolation, two-way binding, and so on. The symbol that works
    its magic for us, in this case, is the interpolation symbol (that is, the set
    of double curly braces). The reason I call it magical is that not only does it
    serve as a string interpolation, but it is also smart enough to handle expressions
    and even function calls. So, we're not restricted to just having a variable name
    being treated as a simple string interpolation.
  prefs: []
  type: TYPE_NORMAL
- en: To determine what our button text should be, we use JavaScript's ternary operator
    syntax to render (or interpolate) the text to one of two values, Show or Hide,
    based on the value of our `isCollapsed` variable. Of course, whatever the Boolean
    value is, the *Instructions* text will always be rendered, resulting in the button
    text being either Show Instructions, or Hide Instructions. This is all done succinctly,
    and inline. Pretty cool, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: Importations and declarations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you try and run the project at this point, you'll get a few errors. This
    is because we haven't set up our imports and declarations in our `app.module.ts`
    file for this component yet. Let's do this now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this import line after the import line we added for our playground component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: And add `NgbCollapseComponent` to the declarations array.
  prefs: []
  type: TYPE_NORMAL
- en: With the preceding import and addition of our component class to the declarations
    array in the `app.module.ts` file, our project should build and run just fine.
  prefs: []
  type: TYPE_NORMAL
- en: Good job. Let's now move on to our modal component.
  prefs: []
  type: TYPE_NORMAL
- en: Modal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modal dialog windows have been around since the early days of the Windows OS
    on desktops (pre-internet), and have become popular for websites as well—this
    is especially true since jQuery came onto the scene. Modal windows are used for
    interacting with the user—typically, to get information from them. Moreover, they
    help the designers focus the users' attention to where it should be by dimming
    the background for contrast, as well as disabling any interaction anywhere outside
    the modal area. One of our use cases for the use of a modal window will be for
    displaying the login form.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at a quick example in the code that we can try out in our
    playground, to display a modal window. Since the integration of NGB widgets all
    follow the same pattern, I won't cover it in as much detail as the collapse NGB
    widget, but I'll point the important areas.
  prefs: []
  type: TYPE_NORMAL
- en: Our components all start off the same way. We need to create a folder for our
    component (let's name it `ngb-modal`) and we need to create our two files—one
    for our component class, and the other for our component template. Let's name
    them `ngb-modal.component.ts` and `ngb-modal.component.html`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: In the sections that follow are the two code listings for our NGB modal component,
    followed by the necessary imports and declarations—just like we did for our collapse
    component.
  prefs: []
  type: TYPE_NORMAL
- en: Our NGB modal component class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our component class, we first import the necessary classes from the appropriate
    modules, and we then decorate our class with the `@Component` decorator, so we
    can link it to a template and set up our selector (that is, our custom HTML tag
    that we'll add to our playground template).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we add a constructor so we can inject the `NgbModal` service (note: we''ll
    be covering dependency injection in [Chapter 12](9610f27b-03db-4258-8a68-24eb3901117b.xhtml),
    *Integrating Backend Data Services*).'
  prefs: []
  type: TYPE_NORMAL
- en: Our class has a variable named `closeResult`, which is populated with a string
    (by the private method named `getDismissReason`), describing how the modal dialog
    is dismissed by the user.
  prefs: []
  type: TYPE_NORMAL
- en: We also have an `open` method that is responsible for causing the modal dialog
    to render. As we'll see in the code listing in the next section (on our component
    template), the `open` method is triggered by a button click from within our playground.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll notice that the open method takes a parameter (named `content` in this
    example). Our component''s template wraps the content that is to be displayed
    in our modal dialog within its `ng-template` tags, and as you''ll see, these tags
    have the `#content` template variable associated with them. If you remember from
    [Chapter 7](cd8509d5-4bce-4056-8156-557186df18cd.xhtml), *Templates, Directives,
    and Pipes*, the hash symbol (that is, `#`) in template syntax is used to denote
    a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Let's now take a look at our component template, `ngb-modal.component.html`*.*
  prefs: []
  type: TYPE_NORMAL
- en: Our NGB modal component template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our component template is not only responsible for supplying our view with the
    content to be displayed in the modal dialog, but will also supply us with the
    visual element that our users will use (in this case, a button) to trigger the
    modal dialog.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following HTML code is our component template, which we will use later
    for our login form (note: we will be covering forms in [Chapter 10](5f27121b-6fb2-4429-aa6e-394aec2152ac.xhtml),
    *Working with Forms*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our component class and our component template, we have to
    tell our application's root module about them—and we'll do just that in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Importations and declarations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just as with our collapse component, if you try and run the project at this
    point, you'll get a few errors—and for the same reasons—since we've not set up
    our imports and declarations in our `app.module.ts` file for this component. You
    know the drill.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this import line after the import line we had added for our playground
    and collapse components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: And add `NgbModalComponent` to the declarations array.
  prefs: []
  type: TYPE_NORMAL
- en: I know you're getting the hang of this. Let's get some more practice with this
    by integrating one more NGB widget to our playground view—and as a bonus, we'll
    take a sneak preview of Angular's `HttpClient` module. We'll be using the `HttpClient`
    module to fetch the images for our carousel, and we'll also be using the `HttpClient`
    module to call our APIs in [Chapter 11](437face8-d59c-42f3-a49a-af43f2892f7a.xhtml), *Dependency
    Injection and Services*.
  prefs: []
  type: TYPE_NORMAL
- en: So let's stretch our legs and arms, fill up our cups with coffee, and move on
    to one of the more interesting components (and what will be the start of the show
    in our example application), the NGB carousel.
  prefs: []
  type: TYPE_NORMAL
- en: Carousel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The carousel component is most notably known as the tool (that is, the widget
    or component) to use for displaying a series of images in a predesignated order—much
    like flipping through a photo album. Our use case will be precisely that: giving
    the user the ability to flip through photos of the property.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at a quick example in the code that we can try out in our
    playground to display three images. We'll start with the component class, and
    then move on to the component template. These code listings are straight out of
    the carousel example on the NGB website, found at: [https://ng-bootstrap.github.io/#/components/carousel/examples](https://ng-bootstrap.github.io/#/components/carousel/examples).
  prefs: []
  type: TYPE_NORMAL
- en: 'I leave the wiring up of the class, using the `import` statement and so on,
    to you as an exercise. Hint: it''s exactly the same process that we previously
    covered when adding the collapse and modal components to our playground (in their
    respective *Importations and declarations* sections). However, I will make mention
    of a few things after each code listing.'
  prefs: []
  type: TYPE_NORMAL
- en: Our NGB carousel component class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will implement the `ngb-carousel` component class. The
    following is the updated component class. We will analyze the code in a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: There are a few things going on in our component class, `ngb-carousel.component.ts`.
    We're importing the `HttpClient` class from Angular's `http` module, and we're
    also importing the `map` class from the `rxjs/operators` module. The `HttpClient` class,
    which we'll be looking at more closely in [Chapter 11](437face8-d59c-42f3-a49a-af43f2892f7a.xhtml),
    *Dependency Injection and Services*, is used to fetch a JSON list of image objects
    from [https://picsum.photos](https://picsum.photos), a free service that serves
    up images as placeholders, providing, as their site says, The Lorem Ipsum for
    photos. The `map` class is used to randomly map three of the many image objects
    that are returned from the`GET` request of `HttpClient` to our string array variable,
    named `images`.
  prefs: []
  type: TYPE_NORMAL
- en: The fetching of the image objects from the API happens when our component is
    initialized because the `GET` request happens within the `ngOnInit()` component's
    life cycle hook.
  prefs: []
  type: TYPE_NORMAL
- en: Our NGB carousel component template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will implement our `ngb-carousel` component template file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This template is straightforward. Everything about it is hardcoded, except for
    the `src` property of the `img` HTML elements. Using square brackets around the
    HTML `img src` attribute is an example of property binding (as we learned in [Chapter
    7](cd8509d5-4bce-4056-8156-557186df18cd.xhtml), *Templates, Directives, and Pipes*).
    In this case, the number of images in the carousel was known to be three. In practice,
    and as we will do in our example application, the template would normally make
    use of the `*ngFor` structural directive to iterate through an array of items
    of variable lengths.
  prefs: []
  type: TYPE_NORMAL
- en: Having gone through a few examples of integrating NGB widgets into our playground,
    we can now implement them in our application for real.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing NGB into our example application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding section, *NGBwidgets*, we covered few components that are available
    in NGB. Of course, you know by now why I would never cover any more than a small
    number of the available components—right? If you said, *yes Aki, I know why. If
    you covered all the components, you'd basically just be duplicating documentation
    that is readily available elsewhere*, you'd be correct! Covering 3 out of 16 is
    plenty—it's almost 19% (which is practically the same as duplicating one out of
    every five pages of documentation!).
  prefs: []
  type: TYPE_NORMAL
- en: But there's also another reason. We're only going to implement two of the three
    NGB components that we covered—namely, the modal component and the carousel component—and
    so there is no need to cover too much more than those. OK, let's continue by putting
    our new found knowledge to practical use.
  prefs: []
  type: TYPE_NORMAL
- en: We learned about implementing the modal, carousel, and collapse components in
    earlier sections. We created selectors for each of the components. For the modal
    component, we created a selector named `ngb-test-modal`; for the carousel component,
    we created a selector named `ngb-test-carousel`; and last, but not least, for
    the collapse component, we created a selector named  `ngb-collapse`. We now need
    to use these selectors in the `playground.component.html` file so that the widgets
    will be visible in the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the updated code of the playground component template file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We added the directives using the selectors for each of the components. Run
    the app using the `ng serve` command in the command line and we should see the
    output, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/34434c9b-57ad-4f17-bec9-3f8fe7d366db.png)'
  prefs: []
  type: TYPE_IMG
- en: Our application has the widgets integrated, but surely we can do a much better
    job with the design. In the next few sections, we will learn about some of the
    design principles and best practices that we will be implementing in the chapters
    to come.
  prefs: []
  type: TYPE_NORMAL
- en: UX design rules of thumb
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are rules of thumb for just about everything, and web design isn't any
    different. There are do's and don'ts in web design—and since we're now really
    starting to dive into our templates, it's a good time to review some of these
    design tenets.
  prefs: []
  type: TYPE_NORMAL
- en: There are probably several dozen design principals, but I'm not an expert on
    , **user experience** (**UX**), and thus you'd be better served to pick up a good
    book that is focused on UX and GUI/interface design (I know that there are titles
    from Packt that you can look into). However, since we are building an application,
    and our application is made up of several components, It would be remiss if I
    didn't cover the fundamental three design principals.
  prefs: []
  type: TYPE_NORMAL
- en: Not only will we cover them in the following three short sections, but we will
    be adhering to them as we build our example application's templates. The reason
    we have things such as UX design principals essentially comes down to one thing—we
    want to have happy users!
  prefs: []
  type: TYPE_NORMAL
- en: Keep it clean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'UX rule of thumb #1: Keep it clean.'
  prefs: []
  type: TYPE_NORMAL
- en: Nothing gives users a headache faster than an overly busy (that is, cluttered)
    user interface. You may have heard of the expression *less is more*—and this expression
    certainly applies to UX design.
  prefs: []
  type: TYPE_NORMAL
- en: 'People feel like they have no time to do anything—and if doing something makes
    them feel like they are wasting their precious resource (that is, time), they
    become unhappy faster than you can count to 10\. How does this relate to this
    first UX design principal? If there is a lot to look at on your page, they don''t
    know where to start looking—and if they can''t make sense of what they''re looking
    at in short order, then you guessed it: they become unhappy.'
  prefs: []
  type: TYPE_NORMAL
- en: Clutter is almost never a good thing. Think of your bedroom or kitchen. Are
    you happier when it's tidy and everything has a place and purpose, and you can
    easily and quickly find what you're looking for? Or are you happier when you waste
    5 minutes looking for that spatula to cook your breakfast that you barely have
    time to eat? The answer, I hope, is obvious. Visitors to websites think the same
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Keep it functional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'UX rule of thumb #2: Keep it functional.'
  prefs: []
  type: TYPE_NORMAL
- en: This UX rule of thumb is related to the first one, in that it is the same as
    saying that nearly everything on our view should have a function. The days of
    having a million bells and other objects on the screen that are nothing but eye
    candy are over. Do you remember the way websites looked in the late 1990s? Flash
    was all the rage. Web pages looked like snow globes, or had large animated buttons
    that pulsated, and read Click Here Now**.** These are no longer tolerated. Chances
    are excellent that if you have any such things on your web page, your visitor
    is going to leave your website as fast as they possibly can. If there is something
    on the screen, it had better have a purpose.
  prefs: []
  type: TYPE_NORMAL
- en: If you'd like to see an extreme example of a website that pays attention to
    the first and second (and the upcoming third) UX design principals, just take
    a look at Google's home page, at: [https://www.google.com/](https://www.google.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Keep it obvious
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'UX rule of thumb #3: Keep it obvious.'
  prefs: []
  type: TYPE_NORMAL
- en: Nothing frustrates users more than forcing them to use a large portion of their
    brain power, time, and detective skills just to find out what they need to do
    next, or how to do a specific task they'd like to perform in a web application.
  prefs: []
  type: TYPE_NORMAL
- en: Users of your web application are users for a reason, and that is that they
    need a tool to get something done. Whether the task that they want to get done
    is for pleasure or for work, it doesn't matter. Whatever it is they'd like to
    get done, they don't want to spend any more time than what is reasonable. If they
    need to spend too much time figuring things out, guess what? Yes! They become
    unhappy!
  prefs: []
  type: TYPE_NORMAL
- en: This third UX design principle is perhaps the most difficult one to adhere to,
    but it is our responsibility as application builders to give it the attention
    it deserves.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored NG Bootstrap—the first of the two third-party component
    libraries that are freely available to us for use in our Angular applications.
    We'll be exploring the second one, Angular Material, in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We took a look at how to install NGB, and then we created a playground within
    our application so we can have a place to play (that is, experiment) with these
    third-party components—including temporarily wiring the playground up to our menu
    via routing for easy navigational access to our playground. While we could have
    created a separate project altogether for playing around with components before
    integrating them into our application for their intended purposes, it is usually
    more convenient to create a playground within our existing infrastructure. Of
    course, when the comes for us to deploy our application, we can easily remove
    the playground and the menu option with its accompanying route.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our playground all set up, we then dove in and took a look at how to integrate
    three of NGB''s widgets: collapse, modal, and carousel.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to wrap the chapter up, since we''re in the component and layout part
    of the book (as opposed to the backend data integration and services part of the
    book), it was a good time to cover a few design principle as well. So, we briefly
    covered three of the top tenants of good design: keeping it clean, functional,
    and obvious. We''ll be adhering to these design principle as best we can throughout
    the remainder of the book.'
  prefs: []
  type: TYPE_NORMAL
- en: Now then, keep your component hat firmly on your head, turn the page, and let's
    take a look at the gorgeously designed components that the Angular team cooked
    up for our use. Leveraging the Angular Material components in the right proportions
    and places will help boost our example application's usability and aesthetics.
    And fortunately, Angular Material plays nicely with Bootstrap, so there's no problem
    with having both libraries in the same Angular project.
  prefs: []
  type: TYPE_NORMAL
