- en: Firebase Security and Rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw how we can incorporate access management in
    an application to secure it from unauthorized access, which is essentially the
    application level security. However, what if we don't have our database secured?
    Well, in that case, data can be misused by unauthorized users or even authorized
    users, such as database administrators, which leads to business loss or sometimes
    legal actions.
  prefs: []
  type: TYPE_NORMAL
- en: Data security is always a major concern, especially when it is hosted on Cloud
    Server. We have to protect our data against the compromises of integrity, availability,
    and confidentiality. It doesn't matter whether you are using RDBMS, such as MySQL
    or MSSQL, or NoSQL, such as MongoDB or Firebase Realtime Database; all these databases
    have to be secured by restricting access to the data. In this chapter, we will
    briefly look at the common database security risks and the checklist to prevent
    such threats. We will also see the security part of Firebase Realtime Database
    and the Firebase Realtime Database Rules language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a list of the topics we will discuss in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of common Database Security Risks and Preventive measures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of Firebase Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of Firebase Realtime Database Rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structure and Definition of Firebase Realtime Database Rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Data Indexing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database Backups and Restore
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with Security Risks and Prevention of the threats.
  prefs: []
  type: TYPE_NORMAL
- en: Security risks and prevention
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The databases are at the heart of any organization since they contain customers''
    data and confidential business data and hence they are targeted by hackers very
    often. There are some common threats identified over the last few years and they
    include these:'
  prefs: []
  type: TYPE_NORMAL
- en: Unauthorized or unintended activity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Malware Infections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physical damage to database servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data corruption due to invalid data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance Degradation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To prevent such risks, there are many protocols or security standards that
    need to be followed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Access Control**: It includes Authentication and Authorization. All the database
    systems provide access control mechanisms such as authentication with username
    and password for authentication. At the same time, in some of the databases, it
    is not mandatory to set it and hence sometimes people don''t enable it, leaving
    the database insecure. Similarly, in all databases, authorization mechanisms such
    as role-based security is provided to restrict the users to certain data or database.
    However, people sometimes give root or admin access to all the users, leaving
    the data open to all the users.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Auditing**: Auditing involves monitoring of database activities performed
    by all users for enhanced security and protection of data. Many of the database
    platforms include inbuilt auditing capabilities, which allow you to trace the
    data creation, deletion, or modification activities and database usage to detect
    any suspicious activities at an early stage.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Backups**: Backups are meant to recover data from an earlier time and to
    recover data in case of data deletion or data corruption. Depending on the requirement,
    the backup process can be automated or manual. Ideally, it should be automated
    so that regular backups can be taken. While it is worth to have at least a few
    backups, the data storage space can be significant, depending on the size of your
    data/backup. To reduce the size of backups, backup files should be compressed
    before persisting them.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Data Integrity Controls**: Data Integrity refers to the consistency and accuracy
    of the data stored in the database. Data validation is prerequisite for data integrity.
    Many Relational Databases (RDBMS) enforce data integrity through constraints like
    a Primary key and Foreign Key constraints. In case of NoSQL, data validation at
    the database level, and also at the application level, is required for data integrity.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Application level security**: Application level security is also required
    to prevent any inappropriate data from being saved on the database. Generally,
    developers have validations at form level and also at the business, to ensure
    that they save valid data in the database.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Encryption**: It is very important to encrypt personal data such as SSN or
    financial data such as Credit card information to prevent its misuse. Usually,
    SSL encryption is used to encrypt the connection between client and server, which
    is essentially network level security, to prevent any malicious attacker from
    reading this information.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's check how secure our data is in Firebase.
  prefs: []
  type: TYPE_NORMAL
- en: How secure is your Firebase?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Firebase is on cloud storage, so obviously, people think whether it is secure
    enough. However, there's nothing to worry, as Firebase provides a secured architecture
    and a set of tools to manage the security of your app. Firebase is hosted on SSL
    (Secure Sockets Layer), which typically encrypts the connection between client
    and server and hence prevents any data theft or manipulation at the network layer.
    Firebase comes with an expression-based rule language that allows you to manage
    data security by just doing configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Firebase security is all about the configuration over convention so that your
    application's security-related logic is separate from your business logic. In
    this way, it makes your application loosely coupled.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn about Firebase Realtime Database security and
    rules.
  prefs: []
  type: TYPE_NORMAL
- en: Realtime Database Rules Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Firebase Database Rules allow you to manage the read and write access permissions
    to your database. They also help you define how your data will be validated, such
    as whether it has valid datatype and format. If your rules allow, only then will
    read and write requests be completed. By default, your rules are set to allow
    only authenticated users with full read and write access to your database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firebase Database Rules have a JavaScript-like syntax and come in four types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `.read` | It determines whether data is allowed to be read by users and when.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `.write` | It determines whether data is allowed to be written by users and
    when. |'
  prefs: []
  type: TYPE_TB
- en: '| `.validate` | It validates whether a value is correctly formatted, has child
    attributes, and its data type. |'
  prefs: []
  type: TYPE_TB
- en: '| `.indexOn` | It determines whether an index exists on a child to support
    faster querying and ordering. |'
  prefs: []
  type: TYPE_TB
- en: 'You can access and set your rules from the Database || Rulestab in your Firebase
    Console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/cf48ed62-4bce-4f33-aa03-750add6b25ea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are three steps to Firebase Realtime Database security:'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication of users
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Authorization of users - control access to data
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Validation of user inputs
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'User authentication is the first step to secure your application from unauthenticated
    access. Identifying the user in the first step automatically implies the restriction
    on data they can access and manipulate. In the applications where we use backend
    technologies such as Java, Microsoft.Net, or any other platform, we write authentication
    logic to restrict the access to our application. However, since Firebase is widely
    used with client-side only applications, we will not have the luxury of backend
    tools. Luckily, Firebase platform provides an Authentication mechanism—Firebase
    Authentication—which has built-in support for common authentication mechanisms
    such as form-based authentication with username and password, Google and Facebook
    login, and many more. In [Chapter 3](dede285d-2924-4fcf-a208-57337e4b853f.xhtml),
    *Authentication with Firebase*, and [Chapter 5](5697f854-7bc1-4ffb-86a2-8304d0fc73e7.xhtml), *User
    Profile and Access Management*, we have already seen how we can implement the
    Firebase Authentication. The following rule specifies that to access the database,
    a user must be authenticated. It also specifies that once a user is authenticated,
    it can access all the data available in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once the user is authenticated, they can access the database. However, you
    need some control over who can access what. Everybody should not be allowed to
    read/write all the data present in your database. This is where Authorization
    comes into the picture. Firebase Database Rules allow you to control access for
    each user. Firebase security rules are node based and are managed by a single
    JSON object that you can edit on your Realtime Database console or using the Firebase
    CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding rules determine that all the users will be able to read the users'
    data but nobody will be able to write to it. Also, note that it is mandatory to
    have `rules` as the first node in your security JSON object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of a rule that specifies data private to a user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, you might have a question like we have nested data structure, how will
    the rules apply to that data. To answer that question, one of the points to remember
    here is that the `.read` and `.write` rules **cascade **meaning; granting a read
    or write access to a *parent node* always grants that read/write access to *all
    child nodes*.
  prefs: []
  type: TYPE_NORMAL
- en: The rules at parent node have higher priority and hence they will override the
    rules defined at its child level.
  prefs: []
  type: TYPE_NORMAL
- en: Firebase rules also provide some built-in variables and functions that allow
    you to access Firebase authentication information, refer to other paths, and more.
    We will check this in detail in the coming sections of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Data validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As seen in the introduction section, we need to validate our data before saving
    it in the database to maintain data integrity and correctness. Firebase rules
    provide `.validate` expressions such as `.read` and `.write` to implement validation
    logic such as length of the field should be only this many characters or it must
    be of string data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding validation rule for email field determines that the value of email
    field must be String and its length should be less than 30 characters.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that **validation rules do not cascade**, so in order
    for the write to be allowed, all relevant validation rules must evaluate to true.
  prefs: []
  type: TYPE_NORMAL
- en: Now since we have a basic understanding of Firebase rules, let's deep dive into
    rules configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Rule definition and structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Firebase rules provide predefined variables that can be used inside a rule
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Definition / Usage |'
  prefs: []
  type: TYPE_TB
- en: '| `auth` | It represents information of the authenticated user. It will be
    null for an unauthenticated user. It is an object that contains uid, token, and
    provider fields and corresponding values. |'
  prefs: []
  type: TYPE_TB
- en: '| `$ variables` | It represents wildcard path to refer to the dynamically generated
    keys and represent IDs. |'
  prefs: []
  type: TYPE_TB
- en: '| `root` | It represents data snapshot at the root path in the Firebase database
    before applying the given database operation. |'
  prefs: []
  type: TYPE_TB
- en: '| `data` | It represents the Data Snapshot before applying the given database
    operation. For example, in case of the update or write, the root represents the
    original data snapshot without the changes in the update or write. |'
  prefs: []
  type: TYPE_TB
- en: '| `newData` | It represents the Data Snapshot before applying the given database
    operation. However, it includes both the existing data as well as the new data,
    which includes data manipulated by the given data operation. |'
  prefs: []
  type: TYPE_TB
- en: '| `now` | It represents current time in milliseconds—the number of *seconds* that
    have elapsed *since* January 1, *1970* (midnight UTC). |'
  prefs: []
  type: TYPE_TB
- en: In the following section, we'll look at how we can use these predefined variables
    in our rules.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in the Authorization section, we need to see how rules will apply
    to the nested data. A rule of thumb is that we need to structure rules based on
    the structure of the data in the database.
  prefs: []
  type: TYPE_NORMAL
- en: We will extend our HelpDesk application developed in [chapter 5](5697f854-7bc1-4ffb-86a2-8304d0fc73e7.xhtml), *User
    Profile and Access Management*, of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a data structure as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that to have data to be secured at the user level, to show
    only the tickets relevant to the logged in user, we are storing them under userId,
    such as `FlQefqueU2USLElL4vc5MoNUnu03` and `KEEyErkmP3YE1BagxSci0hF0g8H2`, and
    to show all the tickets to admin, we are storing them under `all`. However, this
    is not the ideal solution, since it has two issues: data is redundant, and to
    update any data, we will have to update it at two places. Luckily, we can handle
    this kind of security directly in the database with Rules.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will change our data, and we will remove the `all` node from data. We will
    also add one variable under `$userId` to identify whether a user is an admin or
    not. So it will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Our rules will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: These rules essentially impose restrictions that if the user is Admin, that
    is, `isAdmin` is true, then they can read and write all the data. However, other
    users will only be able to read/write their own data.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have also used predefined variable data, which represents the `DataSnapshot`
    before applying a `write` operation. Similarly, we can use the `root`variable
    to refer to the root path and `newData`to refer to the data snapshot that will
    exist after a write operation.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you have observed, we have used `.child`, which is essentially used
    to refer to any child path/attribute. In our rule, we are checking that under
    `$uid`, the value of `isAdmin` is true, since we want to give access to all data
    to an admin. Similarly, we can use any data as a condition in our rules.
  prefs: []
  type: TYPE_NORMAL
- en: Also, an important thing to note here is that once we have defined `.read` and
    `.write` rules at parent level `tickets`, we are not checking the `isAdmin` condition
    under `$uid`, because **rules do cascade**, so once you have granted read/write
    permissions to admins, you don't need to repeat those conditions at the `$uid`
    level. At the same time, it is important to note that it is mandatory to have
    a rule defined at a parent location. If we don't define them at the parent location,
    your data operation will fail completely even though the child path is accessible.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the following rule, we can see that though we have access permissions
    at ticket level, we won''t be able to access data since we haven''t defined rules
    at `$uid` level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Query-based rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As seen in the preceding example, rules can''t be used as filters. However,
    at times, we need to give access to only subsets of data based on some conditions
    or query parameters. For example, let''s say that we need to return only the first
    100 records out of 1000 records from the query result set. We can achieve this
    through the use of the **query.** expressions to give read and write access to
    your result set based on the query parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding will give access to the first 100 records that are ordered by
    key by default. If you want to specify `orderByChild`, you can also do that, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Ensure that when you read the data, you specify `orderByChild`, otherwise your
    read will fail.
  prefs: []
  type: TYPE_NORMAL
- en: Data indexing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Firebase allows you to write queries using child keys. To improve your query
    performance, you can define an index on those keys using the `.indexOn` rule.
    We assume that you already knew how the index works as almost all database systems
    support index.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take an example to understand this better. Let''s say that in our HelpDesk
    system, we often order tickets by department key, and we are using `orderbyChild()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, if we are using `orderByValue()`, we can have the following rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Backups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first section of this chapter, we saw how important it is to manage the
    backups of the data. Though you can take and maintain your data backups manually,
    there are chances that you miss out something and lose the backups. Fortunately,
    Firebase provides an automatic backup service that can be set up to take automatic
    backups of your data and rules daily. Note that this service is only available
    to Blaze plan users and will be chargeable as per Standard rates. You can check
    various subscription plans available at [https://firebase.google.com/pricing/](https://firebase.google.com/pricing/).
  prefs: []
  type: TYPE_NORMAL
- en: Setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can set up database backups from the Backups tab of the Realtime Database
    of Firebase section. The setup wizard will guide you through the steps to configure
    automatic backups. Your Database backup activity will happen at a specific hour
    each day without affecting the load and ensures the highest availability for all
    backup customers.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, you can also take a manual backup whenever you want to get a point
    in time snapshot of your data and rules.
  prefs: []
  type: TYPE_NORMAL
- en: Your backups will be stored in Google Cloud Storage, which is an object storage
    service provided by Google Cloud Platform. Essentially, Google Cloud Storage provides
    buckets that are like directories on computer filesystem, in which your backups
    will be stored. So, once the setup is done, a bucket will be created with permissions
    where your Firebase can write the data. We will see Google Cloud Storage and Firebase
    Cloud Storage in detail in [Chapter 8](ae32df4d-9428-4826-9ab1-339321a97500.xhtml)*,
    Firebase Cloud Storage.*
  prefs: []
  type: TYPE_NORMAL
- en: The backup service automatically compresses the backup files using Gzip compression
    that reduces the overall backup size and ultimately reduces cost and also minimizes
    data transfer time. The compressed file size varies based on the data in your
    database, but in general, it reduces the overall file size to 1/3 of the original
    decompressed file size. You can enable and disable Gzip compression based on your
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: To save further cost, you can also you can enable a 30-day lifecycle policy
    on your bucket to delete older backups; for example, backups older than 30 days
    automatically get deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your Gzipped JSON files can be decompressed by executing the following command-line
    command using the `gunzip` binary, which is available by default on OS-X and most
    Linux distributions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The filenames will be generated based on the following naming conventions.
    It will have a timestamp (ISO 8601 Standard):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If you have Gzip compression enabled, the name will be appended by a `.gz` suffix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Once you have taken a backup, you would want to restore it at some point in
    time. Let's check how we can restore the data from a backup.
  prefs: []
  type: TYPE_NORMAL
- en: Restoring from backups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To restore the data from backup, first download the backup file from Google
    Cloud Storage and decompress it as per the preceding command. Once you have the
    JSON file, you can import data in either of the two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Under the database section of Firebase console, you will find an Import JSONbutton
    that will allow you to upload the file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use a CURL command: `curl 'https://<DATABASE_NAME>.firebaseio.com/.json?auth=<SECRET>&print=silent'
    -x PUT -d @<DATABASE_NAME>.json`. Note that you need to replace `DATABASE_NAME`
    and `SECRET`, respectively, with your own values. You can get the secret from
    the database settings page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explains the common security threats to data, especially when it
    resides on cloud, and how we can secure our data. It also explains that Firebase
    is secure and we shouldn't worry much about the security of data as far as we
    manage the security properly at our end by defining proper rules in database and
    control access to the data to the authorized users.
  prefs: []
  type: TYPE_NORMAL
- en: Firebase is hosted on Secure Server Layer, which manages the security at the
    transport layer. It also gives you a powerful yet simple Rule engine that can
    be configured to secure your data and, at the same time, give the benefit of separation
    of concern—separates security logic from application logic.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned in detail about security rules and how we can define them using
    simple JavaScript-like syntax.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore Firebase Cloud Messaging and Cloud Functions.
  prefs: []
  type: TYPE_NORMAL
