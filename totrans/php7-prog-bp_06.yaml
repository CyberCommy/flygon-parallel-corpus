- en: Chapter 6.  Building a Chat Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will build a real-time chat application using**WebSocket**.
    You will learn how to use the **Ratchet** framework to build standalone WebSocket
    and HTTP servers with PHP and how to connect to WebSocket servers in a JavaScript
    client application. We will also discuss how you can implement authentication
    for WebSocket applications and how to deploy them in a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: The WebSocket protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll be working extensively with WebSockets. To fully understand
    the workings of the chat application that we're going to build, let's first have
    a look at how WebSockets work.
  prefs: []
  type: TYPE_NORMAL
- en: The WebSockets protocol is specified in **RFC 6455** and uses HTTP as the underlying
    transport protocol. In contrast to the traditional request/reply paradigm, in
    which the client sends a request to the server, who then replies with a response
    message, WebSocket connections can be kept open for a long time, and both server
    and client can send and receive messages (or *data frames*) on the WebSocket.
  prefs: []
  type: TYPE_NORMAL
- en: 'WebSocket connections are always initiated by the client (so, typically, a
    user''s browser). The following listing shows an example request that a browser
    might send to a server supporting WebSockets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Just like regular HTTP requests, the request contains a request method (`GET`)
    and a path (`/chat`). The `Upgrade` and `Connection` headers tell the server that
    the client would like to *upgrade* the regular HTTP connection into a WebSocket
    connection.
  prefs: []
  type: TYPE_NORMAL
- en: The `Sec-WebSocket-Key` header contains a random, base64-encoded string that
    uniquely identifies this single WebSocket connection. The `Sec-WebSocket-Protocol`
    header can be used to specify a subprotocol that the client would like to use.
    Subprotocols can be used to further define what the communication between the
    server and the client should look like and are often application-specific (in
    our case, the `chat` protocol).
  prefs: []
  type: TYPE_NORMAL
- en: 'When the server accepts the upgrade request, it will respond with a `101 Switching
    Protocols` response, as shown in the following listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `Sec-WebSocket-Accept` header contains a hash of the `Sec-WebSocket-Key`
    from the request (the exact hashing is specified in RFC 6455). The `Sec-WebSocket-Protocol`
    header in the response confirms that the server understands the protocol that
    the client specified in its request.
  prefs: []
  type: TYPE_NORMAL
- en: After this handshake is completed, the connection will stay open and both server
    and client can send and receive messages from the socket.
  prefs: []
  type: TYPE_NORMAL
- en: First steps with Ratchet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how to install and use the Ratchet framework.
    It's important to note that Ratchet applications work differently than regular
    PHP applications that are deployed in a web server and work on a per-request basis.
    This will require you to adopt a new way of thinking of how PHP applications are
    run and deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Architectural considerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Implementing a WebSocket server with PHP is not trivial. Traditionally, PHP''s
    architecture revolves around the classical request/reply paradigm: the web server
    receives a request, passes it to the PHP interpreter (which is typically built
    into the web server or managed by a process manager such as PHP-FPM), which processes
    the request and returns a response to the web server who in turn responds to the
    client. The lifetime of data in a PHP script is limited to a single request (a
    principle that is called **Shared Nothing**).'
  prefs: []
  type: TYPE_NORMAL
- en: This works well for classical web applications; especially the Shared Nothing
    principle as it is one of the reasons that PHP applications usually scale very
    well. However, for WebSocket support, we need a different paradigm. Client connections
    need to stay open for a very long time (hours, potentially days) and servers need
    to react to client messages at any time during the connection lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: One library that implements this new paradigm is the `Ratchet` library that
    we'll be working with in this chapter. In contrast to regular PHP runtimes that
    live within a web server, Ratchet will start its own web server that can serve
    long-running WebSocket connections. As you'll be dealing with PHP processes with
    extremely long run times (a server process may run for days, weeks, or months),
    you will need to pay special attention to things such as memory consumption.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ratchet can be easily installed using**Composer**. It requires PHP in at least
    version 5.3.9 and also works well with PHP 7\. Start by initializing a new project
    with the `composer init` command on a command line in your project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add Ratchet as a dependency to your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, configure Composer''s autoloader by adding the following section to the
    generated `composer.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As usual, PSR-4 autoloading means that the Composer class loader will look for
    classes of the `Packt\Chp6\Example` namespace within the `src/` folder of your
    project directory. A (hypothetical) `Packt\Chp6\Example\Foo\Bar` class would need
    to be defined in the file `src/Foo/Bar.php` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'As Ratchet implements its own web server, you will not need a dedicated web
    server such as **Apache** or **Nginx** (for now). Start by creating a file called `server.php`,
    in which you initialize and run the Ratchet web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then start your web server (it will listen on the port that you have
    specified as the second parameter of the `Ratchet\App` constructor) using the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you do not have a PHP 7 installation ready on your machine, you can get
    started quickly with**Docker**, using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Both of these commands will start a long-running PHP process that can directly
    handle HTTP requests on your command line. In a later section, you will learn
    how to deploy your application to production servers. Of course, this server does
    not really do much, yet. However, you can still test it using a CLI command or
    your browser, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started](graphics/image_06_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Testing the example application with HTTPie
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue by adding some business logic to our server. WebSocket applications
    served by Ratchet need to be PHP classes that implement `Ratchet\MessageComponentInterface`.
    This interface defines the following four methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onOpen(\Ratchet\ConnectionInterface $c)` will be called whenever a new client
    connects to the WebSocket server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onClose(\Ratchet\ConnectionInterface $c)` will be called when a client disconnects
    from the server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onMessage(\Ratchet\ConnectionInterface $sender, $msg)` will be called when
    a client sends a message to the server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onError(\Ratchet\ConnectionInterface $c, \Exception $e)` will be called when
    an exception occurred at some point while handling a message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start with a simple example: a WebSocket service that clients can send
    messages to, and it will respond to the same client with the same message, but
    reversed. Let''s call this class `Packt\Chp6\Example\ReverseEchoComponent`; the
    code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that although we do not need all of the methods specified by the `MessageComponentInterface`,
    we need to implement all of them nonetheless in order to satisfy the interface.
    For example, if you do not need anything special to happen when a client connects
    or disconnects, implement the `onOpen` and `onClose` methods, but just leave them
    empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to better understand what''s happening in this application, add some
    simple debug messages to the `onOpen` and `onClose` methods, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, implement the `onMessage` method. The `$msg` parameter will contain the
    message that was sent by the client as string, and you can use the `ConnectionInterface`
    class'' `send()` method to send messages back to the client, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might be inclined to use PHP 7's new type hinting feature to hint the `$msg`
    parameter as `string`. This does not work in this case, because it would change
    the method's interface that is prescribed by the `Ratchet\MessageComponentInterface`
    and cause a fatal error.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then register your WebSocket application at the `Ratchet\App` instance
    in your `server.php` file using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Testing WebSocket applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To test WebSocket applications, I can recommend the **wscat **tool. It is a
    command-line tool written in JavaScript (and thus requires Node.js to be running
    on your machine) and can be installed using `npm`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'With the WebSocket server listening at port `8080`, you can use `wscat` to
    open a new WebSocket connection using the following CLI command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This will open a command-line prompt in which you can enter messages that are
    sent to the WebSocket server. Messages received from the server will also be displayed.
    See the following screenshot for an example output of both the WebSocket server
    and wscat:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing WebSocket applications](graphics/image_06_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Testing WebSocket applications using wscat
  prefs: []
  type: TYPE_NORMAL
- en: Playing with the event loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding example, you have only sent messages to clients after having
    received a message from the same client. This is the traditional request/reply
    communication pattern that works well in most scenarios. However, it is important
    to understand that when using WebSockets, you are not forced to follow this pattern,
    but can send messages to connected clients at any time you like.
  prefs: []
  type: TYPE_NORMAL
- en: In order to gain a better understanding of the possibilities you have in a Ratchet
    application, let's have a look at the architecture of Ratchet. Ratchet is built
    on ReactPHP; an event-driven framework for network applications. The central component
    of a React application is the **event loop**. Each event that is triggered in
    the application (for example, when a new user connects or sends a message to the
    server) is stored in a queue, and the event loop processes all events stored in
    this queue.
  prefs: []
  type: TYPE_NORMAL
- en: ReactPHP offers different implementations of event loops. Some of these require
    additional PHP extensions such as `libevent` or `ev` to be installed (and typically,
    the event loops based on `libevent`, `ev`, or similar extensions offer the best
    performance). Usually, applications like Ratchet will automatically choose which
    event loop implementation to use so that you do not need to concern yourself with
    the inner workings of ReactPHP if you do not want to.
  prefs: []
  type: TYPE_NORMAL
- en: By default, a Ratchet application creates its own event loop; however, you can
    also inject your own event loop into the `Ratchet\App` class that you've created
    yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'All ReactPHP event loops must implement the interface `React\EventLoop\LoopInterface`.
    You can use the class `React\EventLoop\Factory` to automatically create an implementation
    of this interface that is supported by your environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then pass this `$loop` variable into your Ratchet application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Having direct access to the event loop allows you to implement some interesting
    features. For example, you can use the event loop''s `addPeriodicTimer` function
    to register a callback that will be executed by the event loop in a periodic interval.
    Let''s use this feature in a short example by building a new WebSocket component
    called `Packt\Chp6\Example\PingComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `$users` property will help us to keep track of connected
    users. Each time a new client connects, we can use the `onOpen` event to store
    the connection in the `$users` property, and use the `onClose` event to remove
    the connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As our WebSocket component now knows the connected users, we can use the event
    loop to register a timer that periodically broadcasts messages to all connected
    users. This can be easily done in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The function passed to `addPeriodicTimer` will be called every five seconds
    and will send a message with an incrementing counter to each connected user. Modify
    your `server.php` file to add this new component to your Ratchet application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You can again test this WebSocket handler using wscat, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Playing with the event loop](graphics/image_06_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Periodic messages cast by a periodic event loop timer
  prefs: []
  type: TYPE_NORMAL
- en: This is a good example of a scenario in which a WebSocket client receives updates
    from a server without having explicitly requested them. This offers efficient
    ways to push new data to connected clients in near real-time, without the need
    to repeatedly poll for information.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the chat application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After this short introduction in the development with WebSockets, let us now
    begin implementing the actual chat application. The chat application will consist
    of the server-side application built in PHP with Ratchet, and an HTML and JavaScript-based
    client that will run in the user's browser.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping the project server-side
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned in the previous section, applications based on ReactPHP will achieve
    the best performance when used with an event-loop extension such as `libevent`
    or `ev`. Unfortunately, the `libevent` extension is not compatible with PHP 7,
    yet. Luckily, ReactPHP also works with the `ev` extension, whose latest version
    already supports PHP 7\. Just like in the previous chapter, we''ll be working
    with Docker in order to have a clean software stack to work on. Start by creating
    a *Dockerfile* for your application container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You will then be able to build an image from this file and start the container
    using the following CLI command from within your project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note that this command will not actually work as long as there is no `server.php`
    file in your project directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as in the previous example, we will be using Composer as well for dependency
    management and for autoloading. Create a new folder for your project and create
    a `composer.json` file with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Continue by installing all required packages by running `composer install`
    in your project directory and create a provisional `server.php` file with the
    following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You have already used the `Ratchet\App` constructor in the introductory example.
    A few words concerning this class'' constructor parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter, `$httpHost` is the HTTP hostname at which your application
    will be available. This value will be used as the allowed origin host. This means
    that when your server is listening on `localhost`, only JavaScript running on
    the `localhost` domain will be allowed to connect to your WebSocket server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `$port` parameter is specified at which port your WebSocket server will
    listen on. Port `8080` will suffice for now; in a later section, you will learn
    how you can safely configure your application to be available on the HTTP standard
    port `80`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `$address` parameter describes the IP address the WebSocket server will
    listen on. This parameter's default value is `'127.0.0.1'`, which would allow
    clients running on the same machine to connect to your WebSocket server. This
    won't work when you are running your application in a Docker container. The string
    `'0.0.0.0'` will instruct the application to listen on all available IP addresses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth parameter, `$loop`, allows you to inject a custom event loop into
    the Ratchet application. If you do not pass this parameter, Ratchet will construct
    its own event loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You should now be able to start your application container using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As your application is now one single, long-running PHP process, changes to
    your PHP code base will not become effective until you restart the server. Keep
    in mind that you stop the server using *Ctrl* + *C* and restart it using the same
    command (or using the `docker restart chat-app` command) when making changes to
    your application's PHP code.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping the HTML user interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The user interface for our chat application will be based on HTML, CSS, and
    JavaScript. For managing frontend dependencies, we will be using **Bower** in
    this example. You can install Bower using `npm` with the following command (as
    root or with `sudo`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Continue by creating a new directory `public/` in which you can place all your
    frontend files. In this directory, place a file `bower.json` with the following
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating the `bower.json` file, you can install the declared dependencies
    (in this case, the **Twitter Bootstrap** framework) using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This will download the Bootstrap framework and all its dependencies (actually,
    only the jQuery library) into the directory `bower_components/`, from which you
    will be able to include them in your HTML frontend files later.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s also useful to have a web server up and running that can serve your HTML
    frontend files. This is especially important when your WebSocket application is
    restricted to a `localhost` origin, which will only allow requests from JavaScript
    served from the `localhost` domain (which does not include local files opened
    in a browser). One quick and easy way is to use the `nginx` Docker image. Be sure
    to run the following command from within your `public/` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: After that, you will be able to open `http://localhost` in your browser and
    view the static files from your `public/` directory. If you place an empty `index.html`
    in that directory, Nginx will use that page as an index page that will not need
    to be explicitly requested by its path (meaning that `http://localhost` will serve
    the contents of the file `index.html` to the user).
  prefs: []
  type: TYPE_NORMAL
- en: Building a simple chat application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can now start implementing the actual chat application. As already shown
    in the previous examples, you need to implement `Ratchet\MessageComponentInterface`
    for this. Start by creating a `Packt\Chp6\Chat\ChatComponent` class and implementing
    all methods that are required by the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing that the chat application needs to do is to keep track of connected
    users. For this, you will need to maintain a collection of all open connections,
    add new connections when a new user connects, and remove them when a user disconnects.
    For this, initialize an instance of the `SplObjectStorage` class in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then attach new connections to this storage in the `onOpen` event and
    remove them in the `onClose` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Each connected user can now send messages to the server. For each received
    message, the component''s `onMessage` method will be called. To implement a real
    chat application, each received message needs to be relayed to the other users-conveniently,
    you already have a list of all connected users in your `$this->users` collection
    to whom you can then send the received message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then register your chat component at the Ratchet application in your
    `server.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: After restarting your application, test the chat functionality by opening two
    WebSocket connections with wscat in two separate terminals. Each message that
    you send in one connection should pop up in the other.
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a simple chat application](graphics/image_06_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Testing the rudimentary chat application using two wscat connections
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have an (admittedly, still rudimentary) chat server running, we
    can start building the HTML frontend for the chat application. For the beginning,
    a static HTML file will be completely sufficient for this. Begin by creating an
    empty `index.html` file in your `public/` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this file, we are already including the frontend libraries that we'll use
    for this example; the Bootstrap framework (with one JavaScript and one CSS file)
    and the jQuery library (with one other JavaScript file).
  prefs: []
  type: TYPE_NORMAL
- en: 'As you will be writing a fair amount of JavaScript for this application, it
    is also useful to add another instance of a `js/app.js` file in which you can
    place your own JavaScript code to the `<head>` section of the HTML page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then continue by building a minimalist chat window in the `<body>`
    section of your `index.html` file. All you need to get started is an input field
    for writing messages, a button for sending them, and an area for displaying other
    user''s messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The HTML file contains an input field (`id="message"`) in which a user can
    enter new chat messages, a button (`id="submit"`) to submit the message, and a
    (currently still empty) section (`id="messages"`) in which the messages received
    from other users can be displayed. The following screenshot shows how this page
    will be displayed in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a simple chat application](graphics/image_06_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Of course, all of this will not be any good without the appropriate JavaScript
    to actually make the chat work. In JavaScript, you can open a WebSocket connection
    by using the `WebSocket` class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**On browser support** WebSockets are supported in all modern browsers and
    have been for quite some time. You may run into issues where you need to support
    older Internet Explorer versions (9 and below), which do not support WebSockets.
    In this case, you can use the `web-socket-js` library, which internally uses a
    fallback using Flash, which is also well supported by Ratchet.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will be placing all our JavaScript code in the file `js/app.js`
    in the `public/` directory. You can open a new WebSocket connection by instantiating
    the `WebSocket` class with the WebSocket server''s URL as the first parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like the server-side component, the client-side WebSocket offers several
    events that you can listen on. Conveniently, these events are named similarly
    to the methods used by Ratchet, `onopen`, `onclose`, and `onmessage`, all of which
    you can (and should) implement in your own code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Receiving messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each client connection will have a corresponding `ConnectionInterface` instance
    in the Ratchet server application. When you call a connection's `send()` method
    on the server, this will trigger the `onmessage` event on the client side.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each time a new message is received; this message should be displayed in the
    chat window. For this, you can implement a new JavaScript method `appendMessage`
    that will display a new message in the previously created message container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are using a simple jQuery construct to create a new HTML
    element and populate it with the current date and time and the actual message
    text received. Be aware that a single message currently only consists of the raw
    message text and does not yet contain any kind of meta data, such as an author
    or other information. We'll get to that later.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While creating HTML elements with jQuery is sufficient in this case, you might
    want to consider using a dedicated templating engine such as **Mustache** or **Handlebars**
    in a real-world scenario. Since this is not a JavaScript book, we will be sticking
    to the basics here.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then call the `appendMessage` method when a message is received:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The event's data property contains the entire received message as a string and
    you can use it as you see fit. Currently, our chat application is only equipped
    to handle plain text chat messages; whenever you need to transport more or structured
    data, using JSON encoding is probably a good option.
  prefs: []
  type: TYPE_NORMAL
- en: Sending messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To send messages, you can (unsurprisingly) use the connection''s `send()` method.
    Since you already have the respective user input fields in your HTML file, all
    it needs now to get the first version of our chat working is a little more jQuery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As soon as the HTML page is loaded completely, we begin listening on the submit
    button's `click` event. When the button is clicked, the message from the input
    field is sent to the server using the connection's `send()` method. Each time
    a message is sent, Ratchet will call the `onMessage` event in the server-side
    component, allowing the server to react to that message and to dispatch it to
    other connected users.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, a user will want to see messages that they sent themselves in the chat
    window, too. That is why we are calling the `appendMessage` that was implemented
    previously, which will insert the sent message into the message container, just
    as if it was received from a remote user.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When both containers (web server and WebSocket application) are running, you
    can now test the first version of your chat by opening the URL `http://localhost`
    in your browser (better yet, open the page twice in two different windows so that
    you can actually use the application to chat with yourself).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows an example of the result that you should get
    when testing the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the application](graphics/image_06_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Testing the first version of the chat application with two browser windows
  prefs: []
  type: TYPE_NORMAL
- en: Keeping the connection from timing out
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you keep the test site open for more than a few minutes, you might notice
    that eventually the WebSocket connection will be closed. This is because most
    browsers will close a WebSocket connection when no messages were sent or received
    in a certain time frame (usually five minutes). As you are working with long-running
    connections, you will also need to consider connectivity issues-what if one of
    your users uses a mobile connection and temporarily disconnects while using your
    application?
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to mitigate this is to implement a simple re-connect mechanism-whenever
    the connection is closed, wait a few seconds and then try again. For this, you
    can start a timeout in the `onclose` event in which you open a new connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This way, each time the connection is closed (due to a timeout, network connectivity
    problems, or any other reason); the application will try to re-establish the connection
    after a grace time of five seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to proactively prevent disconnects, you can also periodically send
    messages through the connection in order to keep the connection alive. This can
    be done by registering an interval function that periodically (in intervals smaller
    than the timeout) sends messages to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few caveats to consider here: first of all, you should only start
    sending keep-alive messages after the connection was actually established (that
    is why we are registering the interval in the `onopen` event), and you should
    also stop sending keep-alives when the connection was closed (which can still
    happen, for example, when the network is not available), which is why the interval
    needs to be cleared in the `onclose` event.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, you probably do not want keep-alive messages to be broadcast to
    the other connected clients; this means that these messages also need a special
    handling in the server-side component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Deployment options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you have already noticed, Ratchet applications are not deployed like your
    typical PHP application, but in fact run their own HTTP server that can directly
    answer HTTP requests. Also, most applications will not *only* serve WebSocket
    connections, but also need to process regular HTTP requests, too.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section is meant to give you an overview on how to deploy a Ratchet application
    in a production environment. For the remaining sections of this chapter, we will
    continue using the Docker-based development setup (without load balancing and
    fancy process managers) for the sake of simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will open an entire set of new problems to solve. One of them is scalability:
    by default, PHP runs single-threaded, so even when using the asynchronous event
    loop offered by `libev`, your application will never scale beyond a single CPU.
    While you could consider using the `pthreads` extension to enable threading in
    PHP (and to enter a whole new world of pain), it is usually easier to simply start
    the Ratchet application multiple times, have it listen on different ports, and
    use a load-balancer such as Nginx to distribute HTTP requests and WebSocket connections
    among them.'
  prefs: []
  type: TYPE_NORMAL
- en: For processing regular (non-WebSocket) HTTP requests, you can still use a regular
    PHP process manager such as PHP-FPM or Apache's PHP module. You can then configure
    Nginx to dispatch those regular requests to FPM and all WebSocket requests to
    one of your running Ratchet applications.
  prefs: []
  type: TYPE_NORMAL
- en: '![Deployment options](graphics/B05285_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Deploying and load-balancing Ratchet applications using an Nginx load balancer
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, you first need to make the port that your application listens
    on so that it can be configured separately for each running process. As the application
    is started through the command line, the easiest way to make the port configurable
    per-process is a command-line parameter. You can use the `getopt` function to
    easily parse command-line parameters. While you''re at it, you can also make the
    listen address configurable. Insert the following code into your `server.php`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you need to make sure your server actually automatically starts a sufficient
    number of processes. In a Linux environment, the **Supervisor** tool is usually
    a good choice for this. On Ubuntu or Debian Linux systems, you can install it
    from the system''s package repositories using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then place a configuration file in `/etc/supervisor/conf.d/` with the
    following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This will configure Supervisor to start four instances of the chat application
    on system boot. They will listen at the ports `8000` to `8003` and will automatically
    be restarted by Supervisor when they unexpectedly terminate-remember: a PHP fatal
    error may be relatively harmless in a FPM-managed environment, but in a standalone
    PHP process, a single fatal error will bring down your entire application for
    all users until someone restarts the process. For this reason, it''s good to have
    a service like Supervisor that automatically restarts crashed processes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, install an Nginx web server to serve as a load balancer for the four
    running chat applications. On Ubuntu or Debian, install Nginx as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'After having installed Nginx, place a configuration file `chat.conf` in the
    directory `/etc/nginx/sites-enabled/` with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This configuration will configure all four application processes as *upstream*
    servers for the Nginx load balancer. All HTTP requests starting with the `/chat/`
    path will be forwarded to one of the Ratchet applications running on the server.
    The `proxy_http_version` and `proxy_set_header` directives are necessary to allow
    Nginx to correctly forward the WebSocket handshake between server and client.
  prefs: []
  type: TYPE_NORMAL
- en: Bridging Ratchet and PSR-7 applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sooner or later, your chat application will also need to respond to regular
    HTTP requests (for example, this will become necessary as soon as you want to
    add an authentication layer with a login form and authentication processing).
  prefs: []
  type: TYPE_NORMAL
- en: As explained in the previous section, a common setup for WebSocket applications
    in PHP is to have a Ratchet application handle all WebSocket connections, and
    to direct all regular HTTP requests to a regular PHP-FPM setup. However, as a
    Ratchet application in fact also ships its own HTTP server, you can also respond
    to regular HTTP requests directly from your Ratchet application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as you have used the `Ratchet\MessageComponentInterface` to implement
    WebSocket applications, you can use the `Ratchet\HttpServerInterface` to implement
    a regular HTTP server. As an example, consider the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the methods defined by the `HttpServerInterface` are similar
    to the `MessageCompomentInterface`. The only difference is the `$request` parameter
    that is now additionally passed into the `onOpen` method. This class is an instance
    of the `Guzzle\Http\Message\RequestInterface` (which, unfortunately, does not
    implement the PSR-7 `RequestInterface`) from which you can get the basic HTTP
    request properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now use the `onOpen` method to send a regular HTTP in response to a
    received HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, you'll have to send the entire HTTP response (including response
    headers!) in the `onOpen` method. This is a bit tedious, and we'll find a better
    way for that later, but it will suffice for the moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, register your HTTP server in your `server.php` the same way that you
    would register a new WebSocket server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Especially note the third parameter `[''*'']` here: this parameter will allow
    any request origin (not just `localhost`) for this route, as most browsers and
    command-line clients will not even send an origin header for regular HTTP requests.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After restarting your application, you can test the new HTTP route using any
    regular HTTP client, either on the command line or using your browser. As shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bridging Ratchet and PSR-7 applications](graphics/image_06_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Testing a Ratchet HTTP server using cURL
  prefs: []
  type: TYPE_NORMAL
- en: Building an HTTP response including headers by hand is a very tedious task-especially
    if at some point, your application contains multiple HTTP endpoints. For this
    reason, it would be nice to have a framework that handles all this stuff for you.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, you've already worked with the  **Slim** framework,
    which you can also integrate quite nicely with Ratchet. Unfortunately, Ratchet
    is not (yet) PSR-7 compliant, so you'll have to do some legwork to convert Ratchet's
    request interfaces to PSR-7 instances and pipe PSR-7 responses back into the `ConnectionInterface`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by installing the Slim framework into your application using Composer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The goal of the remainder of this section will be to build a new implementation
    of the `HttpServerInterface` that takes a Slim application as a dependency and
    forwards all incoming requests to the Slim application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by defining the class `Packt\Chp6\Http\SlimAdapterServer` that implements
    the `HttpServerInterface` and accepts a `Slim\App` as a dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing that you''ll need to do is to map the `$request` parameter
    that Ratchet passes into the `onOpen` event to a PSR-7 request object (which you
    can then pass into the Slim application for processing). The Slim framework ships
    its own implementation of this interface: the class `Slim\Http\Request`. Start
    by adding the following code to your `onOpen` method, which maps the request URI
    to an instance of the `Slim\Http\Uri` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This will map the Guzzle request's URI object in a Slim URI object. These are
    largely compatible, allowing you to simply copy most of the properties into the
    `Slim\Http\Uri` class' constructor. Only the `$guzzleUri->getQuery()` return value
    needs to be forced into a string by concatenating it with an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continue by building the HTTP request header object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'After having built both the request URI and headers, you can create an instance
    of the `SlimRequest` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then use this request object to invoke the Slim application that you''ve
    passed as a dependency into the `SlimAdapterServer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The `$this->app->process()` function will actually execute the Slim application.
    It works similar to the `$app->run()` method that you've worked with in the previous
    chapter, but directly accepts a PSR-7 request object and returns a PSR-7 response
    object for further processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final challenge is now to use the `$slimResponse` object and return all
    data contained in it back to the client. Let''s start by sending the HTTP headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The `$statusLine` contains the first line of the HTTP response (usually, something
    like `HTTP/1.1 200 OK` or `HTTP/1.1 404 Not Found`). The nested `foreach` loops
    are used to collect all response headers from the PSR-7 response object and concatenate
    them into a string that can be used in an HTTP response (each header gets its
    own line, separated by both a **Carriage Return** (**CR**) and **Line Feed** (**LF**)
    newline). The double `\r\n` finally terminates the header and marks the beginning
    of the response body, which you''ll output next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In your `server.php` file, you can now instantiate a new Slim application,
    pass it into a new `SlimAdapterServer` class, and register this server at the
    Ratchet application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Integrating the Slim framework into your Ratchet application allows you to serve
    both WebSocket requests and regular HTTP requests with the same application. Serving
    HTTP requests from one continuously running PHP process presents interesting new
    opportunities, although you'll have to use these with care. You will need to worry
    about things like memory consumption (PHP does have a **Garbage Collector**, but
    if you do not pay attention, you may still create a memory leak that will cause
    your PHP process to run into the memory limit and crash and burn), but building
    applications like these may be an interesting alternative when you have high-performance
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing your application via the web server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our development setup, we're currently running two containers, the application
    container itself, listening on port `8080` and an Nginx server listening on port
    `80` that serves static files such as the `index.html` and various CSS and JavaScript
    files. Exposing two different ports for static files and the application itself
    is often not recommendable in a production setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of this, we will now configure our web server container to serve a
    static file, when it''s present (such as the `index.html` or CSS and JavaScript
    files), and to delegate the HTTP request to the application container when no
    actual file with the given name exists. For this, start by creating an Nginx configuration
    file that you can place anywhere in your project directory-for example, `etc/nginx.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This configuration will cause Nginx to look for files in the `/var/www` directory
    (when using Docker to start the Nginx web server, you can simply mount your local
    directory into the container's `/var/www` directory). There, it will first look
    for a direct filename match, then for an `index.html` inside a directory, and
    as a last option, pass the request to an upstream HTTP server.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This configuration is also suitable for a production setup as described in the
    *Deployment options *section. When you have multiple instances of your application
    running, you will need to reference a dedicated upstream configuration with multiple
    upstream applications in your `proxy_pass` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating the configuration file, you can re-create your Nginx container
    as follows (pay special attention to the `--link` flag of the `docker run` command):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Adding authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Currently, our application is missing one crucial feature: anyone can post
    messages in the chat, and there is also no way to determine which user sent which
    message. Because of this, in the next step, we will add an authentication layer
    to our chat application. For this, we''ll need a login form and some kind of authentication
    handler.'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we will use a typical session-based authentication. After successfully
    authenticating the username and password, the system will create a new session
    for the user and store the (random and non-guessable) session ID in a cookie on
    the user's browser. On subsequent requests, the authentication layer can use the
    session ID from the cookie to look up the currently authenticated user.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the login form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by implementing a simple class for managing sessions. This class
    will be named `Packt\Chp6\Authentication\SessionProvider`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This session handler is built extremely simple: it simply stores which user
    (by name) is using which session ID; new sessions can be registered using the
    `registerSession` method. As all HTTP requests will be served by the same PHP
    process, you do not even need to persist these sessions in a database, but can
    simply keep them in-memory (however, you will need database-backed session storage
    as soon as you have multiple processes running in a load-balanced environment,
    as you cannot simply share memory between different PHP processes).'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**On really random random numbers**'
  prefs: []
  type: TYPE_NORMAL
- en: In order to generate a cryptographically secure session ID, we're using the
    `random_bytes` function which was added in PHP 7 and is now the suggested way
    to obtain cryptographically secure random data (do not use functions such as `rand`
    or `mt_rand` for this, ever).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following steps, we''ll implement a few additional routes into our newly
    integrated Slim application:'
  prefs: []
  type: TYPE_NORMAL
- en: The `GET /` route will serve the actual chat HTML site. Up until now, this was
    a static HTML page that was served directly by the web server. Using authentication,
    we will be needing a bit more login on this site (for example, redirecting a user
    to the login page when they are not logged in), which is why we're moving the
    index page into the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `GET /login` route will serve a login form in which users can authenticate
    with a username and password. Provided credentials will be submitted to the...
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`POST /authenticate` route. This route will verify credentials provided by
    a user and start a new session (using the previously-built `SessionProvider` class)
    when a user was successfully authenticated. After a successful authentication,
    the `/authenticate` route will redirect the user back to the `/` route.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s start by registering these three routes in the Ratchet application and
    connecting them to the previously created Slim adapter in the `server.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Continue by implementing the `/` route. Remember, this route is supposed to
    simply serve the `index.html` file that you have already created previously, but
    only if a valid user session exists. For this, you will have to check if there
    is an HTTP cookie with a session ID provided within the HTTP request and then
    verify that there is a valid user session with this ID. For this, add the following
    code to your `server.php` (also, remove the previously created `GET /hello` route,
    if still present). As shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This route serves the file `templates/index.html` to your users. Currently,
    this file should be located in the `public/` directory in your setup. Create the
    `templates/` directory in your project folder and move the `index.html` there
    from the `public/` directory. This way, the file will not be served by the Nginx
    web server anymore, and all requests to `/` will be directly forwarded to the
    Ratchet application (which will then either deliver the index view or redirect
    the user to the login page).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next step, you can implement the `/login` route. No special logic is
    required for this route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, for this route to actually work, you will need to create the `templates/login.html`
    file. Start by creating a simple HTML document for this new template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'This loads all required JavaScript libraries and CSS files required for the
    login form to work. In the `<body>` section, you can then add the actual login
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Pay special attention to the `<form>` tag: the form''s action parameter is
    the `/authenticate` route; this means that all values that are entered into the
    form will be passed into the (still to-be-written) `/authenticate` route handler
    where you will be able to verify the entered credentials and create a new user
    session.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After saving this template file and restarting the application, you can test
    the new login form by simply requesting the `/` URL, either in your browser or
    using a command-line tool such as **HTTPie** or **curl**. As you do not have a
    login session yet, you should be redirected to the login form at once. As shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the login form](graphics/image_06_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Unauthenticated users are now redirected to the login form
  prefs: []
  type: TYPE_NORMAL
- en: 'The one thing that''s missing now is the actual `/authenticate` route. For
    this, add the following code in your `server.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the actual user authentication is still extremely rudimentary in
    this example-we're only checking one hardcoded user/password combination. In a
    production setup, you can implement any kind of user authentication in this place
    (which will typically consist of looking up a user in a database collection and
    comparing the submitted password's hash with the user's stored password hash).
  prefs: []
  type: TYPE_NORMAL
- en: Checking the authorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, all that's left is to extend the chat application itself to only allow
    authorized users to connect. Luckily, WebSocket connections start as regular HTTP
    connections (before being upgraded to a WebSocket connection). This means that
    the browser will transfer all cookies in a `Cookie` HTTP header which you can
    then access in your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to keep the authorization concern separated from the actual chat business
    logic, we will implement everything authorization-related in a special decorator
    class that also implements the `Ratchet\MessageComponentInterface` interface and
    wraps the actual chat application. We will call this class `Packt\Chp6\Authentication\AuthenticationComponent`.
    Start by implementing this class with a constructor that accepts both a `MessageComponentInterface`
    and a `SessionProvider` as dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Continue by implementing the methods that are defined by the `MessageComponentInterface`.
    to begin, implement all these methods to simply delegate to the respective method
    on the `$wrapped` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now add an authentication check to the following new `onOpen` method.
    In here, you can check if a cookie with a session ID is set, use the `SessionProvider`
    to check if the session ID is valid, and only accept the connection (meaning:
    delegate to the wrapped component) when a valid session exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: If no session ID is found or if the given session ID is not valid, the connection
    will be closed immediately. Otherwise, the session ID will be used to look up
    the associated user from the `SessionProvider` and added as a new property to
    the connection object. In the wrapped component, you can then simply access `$conn->user`
    again to get a reference to the currently authenticated user.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting users and messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can now assert that only authenticated users can send and receive messages
    in the chat. However, the messages themselves are not yet associated with any
    specific user, so you'll still not know which user actually sent a message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Up until now, we have worked with simple plain-text messages. As each message
    will now need to contain more information than the pure message text, we''ll switch
    to JSON encoded messages. Each chat message will contain an `msg` property that
    is sent from the client to the server, and the server will add an `author` property
    filled with the username of the currently authenticated username. This can be
    done in the `onMessage` method of the `ChatComponent` that you''ve built earlier,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we're first JSON-decoding the message received from the client.
    Then, we'll add an `"author"` property to the message, filled with the username
    of the authenticated user (remember, the `$from->user` property is set in the
    `AuthenticationComponent` that you built in the previous section). The message
    is then re-encoded and sent to all connected users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, our JavaScript frontend must also support these new JSON encoded
    messages. Start by changing the `appendMessage` function in your `app.js` JavaScript
    file to accept messages in the form of structured objects, instead of simple strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The `appendMessage` function is used by both the WebSocket connection''s `onmessage`
    event and your submit button listener. The `onmessage` event needs to be modified
    to first JSON-decode incoming messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, the submit button listener needs to send JSON-encoded data to the WebSocket
    server, and also pass structured data into the modified `appendMessage` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned about the basic principles of WebSocket applications
    and how to build them using the Ratchet framework. In contrast to most PHP applications,
    Ratchet apps are deployed as single, long-running PHP processes that do not require
    process managers such as FPM or web servers. This requires a quite different deployment,
    which we have also looked into in this chapter, both for development and for high-scale
    production environments.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to simply serving WebSockets using Ratchet, we have also looked
    at how you can integrate Ratchet applications with other frameworks (for example,
    the Slim framework that you have already worked with in [Chapter 5](ch05.html
    "Chapter 5.  Creating a RESTful Web Service"), *Creating a RESTful Web Service*)
    using the PSR-7 standard.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 7](ch07.html "Chapter 7. Building an Asynchronous Microservice Architecture"),
    *Building an Asynchronous Microservice Architecture*, you will learn about yet
    another communication protocol that you can use to integrate applications. While
    WebSockets are still built on HTTP, the next chapter will feature the **ZeroMQ**
    protocol-which is completely different from HTTP and brings along a whole new
    set of challenges to be solved.
  prefs: []
  type: TYPE_NORMAL
