- en: Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before diving deep into the best practices to be followed while dealing with
    React and Firebase, let's recap what we have seen so far in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapters, we saw Firebase account Setup, Firebase integration
    with ReactJs, Login Authentication With Firebase Auth Providers, Auth State management
    in React Component, Securing Data based on Role and Profile, Firebase integration
    with React-Redux, Firebase Cloud Messaging, Firebase Cloud Functions, and Using
    Firebase Admin SDK API with React Components, and I hope you have also enjoyed
    this journey. Now we know from where can we start and how to write the code, but
    the most important stuff is how can we write standard coding by following best
    practices.
  prefs: []
  type: TYPE_NORMAL
- en: So when we create an application with React and Firebase, we need to ensure
    that the structure of your data in Firebase Database and passing the data into
    the react components is the most important part of the application.
  prefs: []
  type: TYPE_NORMAL
- en: In the development field, each developer has an individual opinion for following
    best practices, but I'm sharing with you what I have observed and experienced
    so far; you might have a different opinion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a list of topics that we''ll cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Best practices with Firebase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices with React and Redux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices with Firebase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Firebase, we all know that data is stored in JSON tree format, which is synchronized
    in realtime to every connected device. So while building cross-platform applications
    (web, iOS, and Android) with Firebase, we can share one instance to all your apps
    to receive the latest updates with new data from Realtime Database. So when we
    add the data into the JSON tree, it becomes the node in the existing JSON Structure
    with an associated key, so we always need to plan how data will be saved to build
    a properly structured database.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Firebase, we have four methods available to write a data into the Firebase
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `set( )` | Write or replace data to a defined path, like `messages/tickets/<uid>`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `update( )` | Update to specific children of node without replacing the other
    child nodes. We can also use the update method to update the data into multiple
    locations. |'
  prefs: []
  type: TYPE_TB
- en: '| `push( )` | To add a list of data in the database, we can use the `push()`
    method; it generates a unique ID every time when it calls, such as `helpdesk/tickets/<unique-user-id>/<unique-ticket-id>`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `transaction( )` | We can use this method when we are working with complex
    data that can be corrupted by concurrent updates such as incremental counters.
    |'
  prefs: []
  type: TYPE_TB
- en: 'Now, let''s take a look at how data is structured in our helpdesk  application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s take an example of the preceding data structure and use the `set()`
    method to store the data with autoincrementing integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now if you see the preceding data structure, new tickets will be stored as `/tickets/1`.
    This will work if only a single user were adding tickets, but in our application,
    many users can add tickets at the same time. If two employees write to `/tickets/2`
    simultaneously, then one of the tickets will be deleted by the other. So this
    will not be recommended practices and always recommend to use the `push()` method
    to generate a unique ID (refer to the preceding data structure) when you are working
    with list of data.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid nesting data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Firebase Realtime Database, when you fetch the data from the JSON tree, we
    will also get all the child nodes of that specific node, because when we add the
    data into the JSON tree, it becomes the node in the existing JSON structure with
    an associated key. Firebase Realtime Database allows nesting data up to 32 levels
    deep, so when we give the access to someone to read or write access at a specific
    node, then we are also giving access of all the child nodes of under that node.
    Therefore, always the best practice is to keep our data structure as flat as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me show you why nested data is bad; refer to the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: With this nested data structure, it's very difficult to iterate over the data.
    Even a simple operation like listing the names of products requires that the entire
    products tree, including all product list and types, be downloaded to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Flattern data structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Flattern structure, data was split into different paths; it could be easy
    to download only the required nodes, as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we had some lightly nested data (for example, details
    for each products are themselves objects with children), but we've also organized
    our data logically by how it will be iterated and read later. We have stored duplicate
    data to defining the relationship between objects; this is necessary to maintain
    the two-way, many-to-many, or one-to-many relationships for redundancy. It allows
    us to quickly and efficiently fetch mobiles, even when the list of products or
    products types scales into the millions, or when Firebase Rulesa and Security
    will prevent access to some of the records.
  prefs: []
  type: TYPE_NORMAL
- en: It's now possible to iterate the list of products by only downloading a few
    bytes per product, quickly fetching metadata for displaying products in a UI.
  prefs: []
  type: TYPE_NORMAL
- en: After seeing the preceding flattern structure, if you are thinking that it is
    really okay to look up each record individually in Firebase, then yes it is, because
    Firebase internally uses web sockets and client libraries for incoming and outgoing
    requests for optimization. Even if we get tens of thousand records, this approach
    is still okay and perfectly reasonable.
  prefs: []
  type: TYPE_NORMAL
- en: Always create the data structure that can scale in future when the app user
    grows.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Firebase documentation has already mentioned and cleared this topic to avoid
    using arrays in Firebase Database, but I want to highlight some of the use cases
    where you can use the Arrays for storing the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the following points; if all the following are true, we can use Array
    to store the data in Firebase:'
  prefs: []
  type: TYPE_NORMAL
- en: If one client can write the data at a time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For removing the keys, instead of using `.remove()`, we can save the array and
    splice it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to take care when referring to anything by array index (a mutable key)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Date object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we talk about sorting and filtering the data in Firebase with `created_date`,
    ensure that you have added the `created_date` key in every object that you have
    created along with date timestamp, such as `ref.set(new Date().toString())` and
    `ref.set(new Date().getTime())`, because Firebase has not supported JavaScript
    date object type `(ref.set(new Date());)`.
  prefs: []
  type: TYPE_NORMAL
- en: Custom claims
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Firebase Admin SDK provides the ability to add custom attributes in profile
    object; with the help of this, we can give user different access control, including
    role-based controls in the react-firebase app, so they are not designed to store
    additional data (such as profile and other custom data). We know that this looks
    like a very convenient way to do so, but it is strongly not recommended, as these
    claims are stored in the ID token and that impacts the performance issues, because
    all authenticated requests always contain a Firebase ID token corresponding to
    the signed in user.
  prefs: []
  type: TYPE_NORMAL
- en: Custom claims are only for storing the data for controlling user access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom claims are limited in size, so passing a custom claims greater than 1000
    bytes will throw an error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the user session
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Manage the session for the user and give the prompt to reauthenticate, because
    every time when the user logged in, user credentials are sent to the Firebase
    Authentication backend and exchanged for a Firebase ID token (a JWT) and refresh
    token.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the common scenarios where we need to manage the session of the user:'
  prefs: []
  type: TYPE_NORMAL
- en: User is deleted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User is disabled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Email address and password changed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Firebase Admin SDK also gives the ability to revoke the specific user session
    using the `revokeRefreshToken()` method. It revokes active refresh tokens of a
    given user. If we reset the password, Firebase Authentication backend automatically
    revokes the user token.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following rule must be configured when any data requires authentication
    to access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Enabling offline capabilities in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we create Realtime Application with Firebase, we also need to monitor the
    connection when clients connect and disconnect with database.  Firebase provides
    a simple solution, which you can use to write to the database when a client disconnects
    from the Firebase Database servers. We can perform all operations such as writing,
    setting, updating, and removing can be performed upon a disconnection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to this example `onDiscconnect()` method of Firebase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also attach the callback function to ensure that the `onDisconnect()`
    method is attached properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To cancel the `onDisconnect()` method, we can call `.cancel()` method `onDisconnectRef.cancel();`.
  prefs: []
  type: TYPE_NORMAL
- en: For detecting the connection state, Firebase Realtime Database provides special
    location ` /.info/connected`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is updated every time app connection state changes; it returns the boolean
    value to check whether the client connection state is connected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Optimize database performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few things where we also need to focus, such as Firebase Realtime
    Database performance in your app, to see how we can optimize your Realtime Database
    performance using different Realtime Database monitoring tools.
  prefs: []
  type: TYPE_NORMAL
- en: Monitor Realtime Database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can collect the data of our Realtime Database''s performance through a few
    different tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '**High-level overview:** We can use the Firebase profiler tool for a list of
    unindexed queries and a realtime overview of read/write operations. For using
    the profiler tool, ensure that you have installed Firebase CLI and run the following
    command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Billed usage estimate:** FIrebase usage metrics provide you your billed usage
    and high-level performance metrics in Firebase Console.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Detailed drilldown:** Stackdriver Monitoring tool provides you with a more
    granular look at how your database is performing over time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more details about profiling, visit [https://firebase.google.com/docs/database/usage/profile](https://firebase.google.com/docs/database/usage/profile)
  prefs: []
  type: TYPE_NORMAL
- en: Improve performance by metric
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you''ve gathered data, explore the following best practices and strategies
    based on the performance area you want to improve:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Metric** | **Description** | **Best practices** |'
  prefs: []
  type: TYPE_TB
- en: '| Load/Utilization | Optimize how much of your database''s capacity is in use
    processing requests at any given time (reflected in **Load** or **io/database_load**
    metrics). | Optimize your data structure ([https://firebase.google.com/docs/database/usage/optimize#data-structure](https://firebase.google.com/docs/database/usage/optimize#data-structure))
    Shared data across databases ([https://firebase.google.com/docs/database/usage/optimize#shard-data](https://firebase.google.com/docs/database/usage/optimize#shard-data))'
  prefs: []
  type: TYPE_NORMAL
- en: Improve listener efficiency ([https://firebase.google.com/docs/database/usage/optimize#efficient-listeners](https://firebase.google.com/docs/database/usage/optimize#efficient-listeners))
  prefs: []
  type: TYPE_NORMAL
- en: Limit downloads with query-based rules *(*[https://firebase.google.com/docs/database/usage/optimize#query-rules](https://firebase.google.com/docs/database/usage/optimize#query-rules))
  prefs: []
  type: TYPE_NORMAL
- en: Optimize connections ([https://firebase.google.com/docs/database/usage/optimize#open-connections](https://firebase.google.com/docs/database/usage/optimize#open-connections))
    |
  prefs: []
  type: TYPE_NORMAL
- en: '| Active connections | Balance the number of simultaneous and active connections
    to your database to stay under the 100,000-connection limit. | Shard data across
    databases ([https://firebase.google.com/docs/database/usage/optimize#shard-data](https://firebase.google.com/docs/database/usage/optimize#shard-data))
    Reduce new connections ([https://firebase.google.com/docs/database/usage/optimize#open-connections](https://firebase.google.com/docs/database/usage/optimize#open-connections))
    |'
  prefs: []
  type: TYPE_TB
- en: '| Outgoing bandwidth | If the downloads from your database seem higher than
    you want them to be, you can improve the efficiency of your read operations and
    reduce encryption overhead. | Optimize connections ([https://firebase.google.com/docs/database/usage/optimize#open-connections](https://firebase.google.com/docs/database/usage/optimize#open-connections))
    Optimize your data structure ([https://firebase.google.com/docs/database/usage/optimize#data-structure](https://firebase.google.com/docs/database/usage/optimize#data-structure))'
  prefs: []
  type: TYPE_NORMAL
- en: Limit downloads with query-based rules ([https://firebase.google.com/docs/database/usage/optimize#query-rules](https://firebase.google.com/docs/database/usage/optimize#query-rules))
  prefs: []
  type: TYPE_NORMAL
- en: Reuse SSL sessions ([https://firebase.google.com/docs/database/usage/optimize#ssl-sessions](https://firebase.google.com/docs/database/usage/optimize#ssl-sessions))
  prefs: []
  type: TYPE_NORMAL
- en: Improve listener efficiency ([https://firebase.google.com/docs/database/usage/optimize#efficient-listeners](https://firebase.google.com/docs/database/usage/optimize#efficient-listeners))
  prefs: []
  type: TYPE_NORMAL
- en: Restrict access to data ([https://firebase.google.com/docs/database/usage/optimize#secure-data](https://firebase.google.com/docs/database/usage/optimize#secure-data))
    |
  prefs: []
  type: TYPE_NORMAL
- en: '| Storage | Ensure that you''re not storing unused data, or balance your stored
    data across other databases, and/or Firebase products to remain under quota. |
    Clean up unused data ([https://firebase.google.com/docs/database/usage/optimize#cleanup-storage](https://firebase.google.com/docs/database/usage/optimize#cleanup-storage))
    Optimize your data structure ([https://firebase.google.com/docs/database/usage/optimize#data-structure](https://firebase.google.com/docs/database/usage/optimize#data-structure))'
  prefs: []
  type: TYPE_NORMAL
- en: Shard data across databases ([https://firebase.google.com/docs/database/usage/optimize#shard-data](https://firebase.google.com/docs/database/usage/optimize#shard-data))
  prefs: []
  type: TYPE_NORMAL
- en: Use Firebase Storage ([https://firebase.google.com/docs/storage](https://firebase.google.com/docs/storage))
    |
  prefs: []
  type: TYPE_NORMAL
- en: Source: [https://firebase.google.com/docs/database/usage/optimize](https://firebase.google.com/docs/database/usage/optimize)
  prefs: []
  type: TYPE_NORMAL
- en: We can create multiple Realtime Database instances if we're using Blaze pricing
    plan; then, we can create multiple database instances in the same Firebase project.
  prefs: []
  type: TYPE_NORMAL
- en: 'To edit and deploy rules from the Firebase CLI, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Ensure that you consistently edit and deploy rules from the same place.
  prefs: []
  type: TYPE_NORMAL
- en: Connect your app to multiple database instances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use the database reference to access data stored in secondary database instances.
    You can get the reference for a specific database instance by URL or app. If we
    don''t specify a URL in the `.database()` method, then we''ll get the reference
    for the app''s default database instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: To see the list of Firebase Sample Projects, visit [https://firebase.google.com/docs/samples/](https://firebase.google.com/docs/samples/).
  prefs: []
  type: TYPE_NORMAL
- en: To see the list of Firebase Libraries, refer to [https://firebase.google.com/docs/libraries/](https://firebase.google.com/docs/libraries/).
  prefs: []
  type: TYPE_NORMAL
- en: You can also subscribe to the [https://www.youtube.com/channel/UCP4bf6IHJJQehibu6ai__cg](https://www.youtube.com/channel/UCP4bf6IHJJQehibu6ai__cg) channel
    to get updated.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices with React and Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever we have components with dynamic functionality, data comes into the
    picture; the same way, in React, we have to deal with dynamic data, which seems
    easy but not every time.
  prefs: []
  type: TYPE_NORMAL
- en: Sounds confusing!
  prefs: []
  type: TYPE_NORMAL
- en: It is easy but sometimes tough because, in React components, it’s easy to pass
    properties with many ways for building rendering tree from it, but there is not
    much clarity to update the view.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding chapters, this statement is clearly shown, so if you are still
    not clear, refer to those.
  prefs: []
  type: TYPE_NORMAL
- en: Use of Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we know, in SPAs (single page applications), when we have to contract with
    state and time, it will be difficult to handgrip state over time. Here, Redux
    helps a lot, how? This is because, in a JavaScript application, Redux is handling
    two states: one is Data state and another is UI state, and it’s a standard option
    for SPAs (single page applications). Moreover, bear in mind that Redux can be
    used with Angular or Jquery or React JavaScript libraries or frameworks.'
  prefs: []
  type: TYPE_NORMAL
- en: Difference between Redux and Flux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Redux is a tool, whereas Flux is just a pattern that you can’t use, like plug
    and play or download it. I’m not denying that Redux has some influence from the
    Flux pattern, but as we can’t say, it 100% looks like Flux.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go ahead to refer to a few differences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Redux follows three guiding principles, as shown, which will also cover the
    difference between Redux and Flux:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single store approach:** We saw in the earlier diagrams that Store is pretending
    as an "intermediary" for all kind of state modifications within application and
    Redux. It is controlling direct communication between two components through the
    Store, a single point of communication. Here, the difference between Redux and
    Flux is that Flux has multiple store approaches and Redux has a single store approach.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Read-Only State:** In React applications, components cannot change state
    directly, but they have to dispatch change to Store through "actions". Here, Store
    is an object, and it has four methods, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: store.dispatch(action)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: store.subscribe(listener)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: store.getState()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: replaceReducer(nextReducer)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reducer Functions to change the State:** Reducer function will handle dispatching
    actions to change the state as Redux tool doesn’t allow direct communication between
    two components; so it will not only change the state but also, the dispatch action
    will be described for state change. Reducers here can be considered as pure-function.
    Here are a few characteristics to write reducer functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No outside database or network calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns value based on its parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arguments are "immutable"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same argument returns the same value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducer functions are called pure-functions as they are purely doing nothing
    except returning a value based on their set parameters; it doesn’t have any other
    consequences. They are recommended to have a flat state. In Flux or Redux architecture,
    it’s always tough to deal with nested resources, which are from APIs' return,
    so it’s been recommended to have a flat state in your component, such as normalize.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hint for pros: **`const data = normalize(response, arrayOf(schema.user)) 
    state = _.merge(state, data.entities)`'
  prefs: []
  type: TYPE_NORMAL
- en: Immutable React State
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In flat state, we have the benefit of dealing with nested resource and in the
    Immutable object, we have the benefit of a declared state that cannot be modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other benefit of the Immutable object is that with their reference level
    equality checks, we can have fabulous improved rendering performance. In Immutable,
    we have an example of `shouldComponentUpdate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In JavaScript, use of Immutability Deep freeze node will help you to freeze
    a node before mutation, and then it will verify results. The following example
    shows the same logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'I hope that the preceding examples would have made things clear about immutable
    JS''s use and benefits. It is also having a non-complicated way, but its use is
    very low:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: From my point of view, it’s very a fast and beautiful feature to be used.
  prefs: []
  type: TYPE_NORMAL
- en: React Routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have to use routing in client-side applications, and, for ReactJS also, we
    need one or the other routing library, so I recommend that you use react-router-dom
    instead of react-router.
  prefs: []
  type: TYPE_NORMAL
- en: '**Advantages:**'
  prefs: []
  type: TYPE_NORMAL
- en: Views declaration in standardized structure help us to instantly understand
    what are our app views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using react-router-dom, we can easily handle the nested views and their progressive
    resolution of views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using browsing history feature user can navigate backward/forward and restore
    the state of view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic Route matching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSS transitions on views when navigating
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standardized app structure and behavior, useful when working in a team
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note: React router doesn’t provide any way to handle data-fetching. We need
    to use async-props or other React data fetching mechanism.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s been seen that very few developers who are dealing with webpack know about
    code splitting of your application code in several files of JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This split of code is necessary because each code is not useful to each user,
    and it’s not necessary to load that chunk of code in each page, which will be
    a burden for the browser, so to avoid such a situation, we should split our application
    into several chunks.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you will have a question like if we will have more chunks of code, we will
    have to have more HTTP requests and that will also affect performance, but with
    the help of HTTP/2multiplexed, your problem will be resolved. You can also combine
    your chunked code with chunk hashing, which will also optimize your browser cache
    ratio whenever you change your code.
  prefs: []
  type: TYPE_NORMAL
- en: JSX components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSX is nothing, but, in simple words, it is just an extension of JavaScript
    syntax. Also, if you observe the syntax or structure of JSX, you will find that
    it's similar to XML coding. JSX is doing preprocessor footstep, which adds XML
    syntax to JavaScript. Though you can certainly use React without JSX, JSX makes
    react a lot more neat and elegant. Similar to XML, JSX tags are having tag name,
    attributes, and children and, in that, if an attribute value is enclosed in quotes,
    that value becomes a string.
  prefs: []
  type: TYPE_NORMAL
- en: JSX works similar to XML, with balanced opening and closing tags, and it helps
    make large trees at ease to read than “function calls” or “object literals”.
  prefs: []
  type: TYPE_NORMAL
- en: '**Advantages of using JSX in React**:'
  prefs: []
  type: TYPE_NORMAL
- en: JSX is very simple to understand and think about than JavaScript functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Markup of JSX is more acquainted to designer and the rest of your team
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your markup becomes more semantic, structured and more meaningful
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How is it easy to visualize?
  prefs: []
  type: TYPE_NORMAL
- en: As I said, the structure/syntax is easy to visualize/notice, which is intended
    to be more clear and readable in the JSX format as compared to JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Semantics / structured syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our applications, we can see how JSX syntax is easy to understand and visualize;
    behind this, there is a big reason of having semantic syntax structure. JSX, with
    pleasure, converts your JavaScript code into more semantic and meaningful structured
    markup. This consents you the benefit of declaring your component structure and
    information pour using an HTML-like syntax, knowing that it will transform into
    simple JavaScript functions. React outlines all the HTML elements you would expect
    in the React.DOM namespace. The good part is that it also allows you to use your
    own written, custom components within the markup.
  prefs: []
  type: TYPE_NORMAL
- en: Use of PropType in React component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a React component, we can pass the properties from higher-level component,
    so knowledge of properties is a must, as it will give you more flexibility to
    extend your component and saves your time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You can also validate your properties the way we can validate properties of
    Immutable JS with react immutable proptypes.
  prefs: []
  type: TYPE_NORMAL
- en: Benefit of higher-order components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Higher-order components are nothing but extended versions of your original
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The main benefit of using them is that we can use it in multiple situations,
    for example, authentication or login validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The other benefit is that with higher-order components, you can fetch data separately
    and set your logic to have your views in a simple way.
  prefs: []
  type: TYPE_NORMAL
- en: Redux Architecture benefits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Compared to other frameworks, it has more plus points:'
  prefs: []
  type: TYPE_NORMAL
- en: It might not have any other way effects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we know, binding is not needed because components can’t interact directly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: States are managed globally, so less possibility of mismanagement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sometimes, for middleware, it would be difficult to manage other way effects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the mentioned points, it's very clear that the Redux architecture is very
    powerful, and it has reusability as well.
  prefs: []
  type: TYPE_NORMAL
- en: We can also use build React-Firebase application with the **ReactFire** library,
    with a few lines of JavaScript. We can integrate Firebase data into React apps
    via ReactFireMixin.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this last and final chapter of this book, we covered the best practices to
    be followed when working with React and Firebase. We also saw how we can monitor
    application performance with the use of different tools to reduce the number of
    bugs. We also talked about the importance of the structure of your data in Firebase
    Realtime database and discussed the dynamic data passing to React components.
    We also looked at other key factors, such as JSX, React Routing, and React PropTypes,
    which are the topmost usable elements in React App. We also learned that Redux
    helps a lot in maintaining the state of your **Single Page Applications** (**SPAs**).
  prefs: []
  type: TYPE_NORMAL
