- en: Security and Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Making forms secure from **Cross-Site Request Forgery** (**CSRF**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making requests secure with **Content Security Policy** (**CSP**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using django-admin-honeypot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing password validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Downloading authorized files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a dynamic watermark to images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authenticating with Auth0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching the method return value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Memcached to cache Django views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Redis to cache Django views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software will never last if it inappropriately exposes sensitive information,
    makes the user suffer through interminable wait times, or requires extensive amounts
    of hardware. It is our responsibility as developers to make sure that applications
    are secure and performant. In this chapter, we will examine just some of the many
    ways we can keep our users (and yourself) safe while operating within Django applications.
    Then, we'll cover a few options for caching that can reduce processing and get
    data to users at a lower expense in terms of money and time.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To work with the code in this chapter, you will need the latest stable version
    of Python, a MySQL or PostgreSQL database, and a Django project with a virtual
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find all the code for this chapter in the `ch07` directory of this
    book''s GitHub repository at: [https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition](https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition).'
  prefs: []
  type: TYPE_NORMAL
- en: Making forms secure from Cross-Site Request Forgery (CSRF)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Without the proper precautions, malicious sites could potentially invoke requests
    against your website, which would result in undesired changes being made to your
    server. For example, they could affect a user's authentication or alter content
    without the user's consent. Django comes bundled with a system for preventing
    CSRF attacks such as these, and we'll review that in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Start with the `ideas` app that we created in the *Creating an app with CRUDL
    functions* recipe in [Chapter 3](ac26c6a6-3fd1-4b28-8b01-5b3cda40f4f9.xhtml)*,
    Forms and Views*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To enable CSRF prevention in Django, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure that `CsrfViewMiddleware` is included in your project settings, as
    shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure the form view is rendered using the request context. For example,
    in the existing `ideas` app, we have this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the template for the form, make sure it uses the `POST` method and includes
    the `{% csrf_token %}` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you use `django-crispy-forms` for the form layout, the CSRF token will be
    included by default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django uses a hidden field approach to prevent CSRF attacks. A token is generated
    on the server, based on a combination of request-specific and randomized information.
    Through `CsrfViewMiddleware`, this token is automatically made available via the
    request context.
  prefs: []
  type: TYPE_NORMAL
- en: 'While it is not recommended to disable this middleware, it is possible to mark
    individual views to get the same behavior by applying the `@csrf_protect` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can exclude individual views from CSRF checks, even when the
    middleware is enabled, by using the `@csrf_exempt` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The built-in `{% csrf_token %}` tag generates the hidden input field that provides
    the token, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It is considered invalid to include the token for forms that submit requests
    using the `GET`, `HEAD`, `OPTIONS`, or `TRACE` methods, as any requests using
    those methods should not cause side effects in the first place. In most cases,
    web forms that require CSRF protection will be `POST` forms.
  prefs: []
  type: TYPE_NORMAL
- en: When a protected form using an unsafe method is submitted without the required
    token, Django's built-in form validation will recognize this and reject the request
    outright. Only those submissions containing a token with a valid value will be
    allowed to proceed. As a result, external sites will be unable to make changes
    to your server since they won't be able to know and include the currently valid
    token value.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many cases, it is desirable to enhance a form so that it can be submitted
    over Ajax. These also need to be protected using CSRF tokens, and while it is
    possible to inject the token as extra data in each request, using such an approach
    requires developers to remember to do so for each and every `POST` request. The
    alternative of using a CSRF token header exists and it makes things more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the token value needs to be retrieved, and how we do this depends on
    the value of the `CSRF_USE_SESSIONS` setting. When it is `True`, the token is
    stored in the session rather than a cookie, so we must use the `{% csrf_token
    %}` tag to include it in the DOM. Then, we can read that element to retrieve the
    data in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `CSRF_USE_SESSIONS` setting is in the default `False` state, the preferred
    source of the token value is the `csrftoken` cookie. While it is possible to roll
    your own cookie manipulation methods, there are many utilities available that
    simplify this process. For example, we can extract the token easily by name using
    the **js-cookie** API, available at [https://github.com/js-cookie/js-cookie](https://github.com/js-cookie/js-cookie),
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the token has been extracted, it needs to be set as the CSRF token header
    value for `XmlHttpRequest`. Although this might be done separately for each request,
    doing so has the same drawbacks as adding the data to the request parameters for
    each request. Instead, we might use jQuery and its ability to attach data to all
    requests automatically before they are sent, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating an app with CRUDL functions* recipe in [Chapter 3](ac26c6a6-3fd1-4b28-8b01-5b3cda40f4f9.xhtml)*,
    Forms and Views*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Implementing password validation* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Downloading authorized files* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Authenticating with Auth0* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making requests secure with Content Security Policy (CSP)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dynamic multi-user websites usually allow users to add all kinds of data from
    a wide variety of media types: images, videos, audios, HTML, JavaScript snippets,
    and so on. This opens up the potential of users adding malicious code to the website
    that could steal cookies or other personal information, call unwanted Ajax requests
    in the background, or do other harm. Modern browsers support an extra layer of
    security that whitelists the sources of your media resources. It is called CSP
    and in this recipe, we will show you how to use it within a Django website.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with an existing Django project; for example, the one containing
    the `ideas` app from [Chapter 3](ac26c6a6-3fd1-4b28-8b01-5b3cda40f4f9.xhtml)*,
    Forms and Views*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To protect your project with CSP, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `django-csp` into your virtual environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the settings, add `CSPMiddleware`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same settings file, add the `django-csp` settings for whitelisting the
    sources of included media that you trust, for example, the CDN for jQuery and
    Bootstrap (you''ll find a detailed explanation of this in the *How it works...*
    section):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have any inline scripts or styles anywhere in the templates, whitelist
    them using a cryptographic `nonce`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CSP directives can be added to the meta tags in the head section or the response
    headers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `meta` tag syntax looks like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Our chosen `django-csp` module uses **response headers** to create the list
    sources that you want to be loaded into the website. You can check the headers
    in the Network section of the browser''s inspector, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'CSP allows you to define resource types and allowed sources next to each other.
    The main directives that you can use are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`default-src` is used as a fallback for all unset sources and is controlled
    in the Django settings by `CSP_DEFAULT_SRC`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`script-src` is used for `<script>` tags and is controlled in the Django settings
    by `CSP_DEFAULT_SRC`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`style-src` is used for the `<style>` and `<link rel="stylesheet">` tags and
    CSS `@import` statements, and is controlled by the `CSP_STYLE_SRC` setting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`img-src` is used for the `<img>` tags and is controlled by the `CSP_IMG_SRC`
    setting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`frame-src` is used for the `<frame>` and `<iframe>` tags and is controlled
    by the `CSP_FRAME_SRC` setting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`media-src` is used for the `<audio>` , `<video>`, and `<track>` tags and is
    controlled by the `CSP_MEDIA_SRC` setting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`font-src` is used for the web fonts and is controlled by the `CSP_FONT_SRC`
    setting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`connect-src` is used for the resources loaded by JavaScript and is controlled
    by the `CSP_CONNECT_SRC` setting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A full list of resource types and analogical settings can be found at [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy ](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy)and [https://django-csp.readthedocs.io/en/latest/configuration.html](https://django-csp.readthedocs.io/en/latest/configuration.html),
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The values for each directive can be one or more from the following list (the
    single quotes matter):'
  prefs: []
  type: TYPE_NORMAL
- en: '`*`: Allow all sources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''none''`: Disallow all sources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''self''`: Allow sources from the same domain'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A protocol; for instance, `https:` or `data:`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A domain; for instance, `example.com` or `*.example.com`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A website URL, for instance, `https://example.com`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''unsafe-inline''`: Allow inline `<script>` or `<style>` tags'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''unsafe-eval''`: Allow script execution with the `eval()` function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''nonce-<b64-value>''`: Allow specific tags by cryptographic nonces'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''sha256-...''`: Allow resources by their source hashes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is no general bulletproof way to configure `django-csp`. It''s always
    a process of trial and error. However, here are our guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by adding the CSP for an existing working project. Premature restrictions
    will only make it more difficult to develop the website.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check all the scripts, styles, fonts, and other static files that have been
    hardcoded into the templates and whitelist them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Allow all sources for images, media, and frames if you allow media to be embedded
    into blog posts or other dynamic content, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If you use inline scripts or styles, add `nonce="{{ request.csp_nonce }}"` to
    them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Avoid `'unsafe-inline'` and `'unsafe-eval'` CSP values unless the only way to
    enter HTML into the website is by hardcoding it in the templates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Browse through the website and search for any content that is not loading correctly.
    If you see a message like the following in the developer console, it means that
    the content was restricted by CSP:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Refused to execute inline script because it violates the following Content
    Security Policy directive: "script-src ''self'' https://stackpath.bootstrapcdn.com/
    https://code.jquery.com/ https://cdnjs.cloudflare.com/". Either the ''unsafe-inline''
    keyword, a hash (''sha256-P1v4zceJ/oPr/yp20lBqDnqynDQhHf76lljlXUxt7NI=''), or
    a nonce (''nonce-...'') is required to enable inline execution.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Errors like these usually occur because some third-party tools such as django-cms,
    Django Debug Toolbar, and Google Analytics are trying to include a resource through
    JavaScript. You can whitelist those resources with source hashes like the one
    we saw in the error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''sha256-P1v4zceJ/oPr/yp20lBqDnqynDQhHf76lljlXUxt7NI=''`.'
  prefs: []
  type: TYPE_NORMAL
- en: If you develop modern **Progressive Web Apps** (**PWAs**), consider checking
    the directives for the manifest and web workers controlled by the `CSP_MANIFEST_SRC`
    and `CSP_WORKER_SRC` settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Making forms secure from Cross Site Request Forgery (CSRF)* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using django-admin-honeypot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you keep the default administration path for your Django website, you make
    it possible for hackers to perform brute-force attacks and try to log in with
    different passwords from their lists. There is an app called django-admin-honeypot
    that allows you to fake the login screen and detect those brute-force attacks.
    In this recipe, we'll learn how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can start with any Django project that we want to secure. For example, you
    can extend the project from the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to set up django-admin-honeypot:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the module in your virtual environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Add `"admin_honeypot"` to `INSTALLED_APPS` in your settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the URL rules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you go to the default administration URL, `http://127.0.0.1:8000/en/admin/`,
    you will see the login screen, but whatever you enter will be described as an
    invalid password:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7fc7521b-9438-4ccd-9e5c-6b7efa6b23fc.png)'
  prefs: []
  type: TYPE_IMG
- en: The real site's administration is now under `http://127.0.0.1:8000/en/management/`,
    where you can see the tracked logins from the honeypot.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the time of writing, django-admin-honeypot is not perfectly functioning
    with Django 3.0 – the administration interface escapes the HTML where it should
    render it safely. Until django-admin-honeypot is updated and a new release is
    available, we can fix it by making some changes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an app called `admin_honeypot_fix` with the `admin.py` file that contains
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same app, create an `apps.py` file with the new app configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace `"admin_honeypot"` with the new app configuration in `INSTALLED_APPS`
    in the settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The login attempts at the honeypot will now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c76c52b-0f5c-4272-ab40-01ca4603d480.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Implementing password validation* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Authenticating with Auth0* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing password validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Among the items at the top of the list of software security failures is the
    choice of insecure passwords by users. In this recipe, we will learn how to enforce
    minimum password requirements through both built-in and custom password validators
    so that users are guided toward setting up more secure authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the project's settings file and locate the `AUTH_PASSWORD_VALIDATORS` setting.
    Also, create a new `auth_extra` app containing a `password_validation.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to set up stronger password validation for your project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s customize the settings for the validators that are included with Django
    by adding some options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `MaximumLengthValidator` class to the `password_validation.py` file
    in the new `auth_extra` app, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same file, create the `SpecialCharacterInclusionValidator` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the new validators to the settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Django contains a set of default password validators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UserAttributeSimilarityValidator` ensures that any password that''s chosen
    is not too similar to certain attributes of the user. By default, the similarity
    ratio is set to `0.7` and the attributes that are checked are the username, first
    and last name, and email address. If any of these attributes contains multiple
    words, each word is checked independently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MinimumLengthValidator` checks that the password that''s entered is at least
    the minimum number of characters in length. By default, passwords must be eight
    or more characters long.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CommonPasswordValidator` refers to a file containing a list of passwords that
    are often used, and hence are insecure. The list Django uses by default contains
    1,000 such passwords.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NumericPasswordValidator` verifies that the password that''s entered is not
    made up entirely of numbers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you use the `startproject` management command to create a new project,
    these are added with their default options as the initial set of validators. In
    this recipe, we've shown how these options can be adjusted for our project needs,
    increasing the minimum length of passwords to 12 characters.
  prefs: []
  type: TYPE_NORMAL
- en: For `UserAttributeSimilarityValidator`, we have also reduced `max_similarity`
    to `0.5`, which means that passwords must differ more greatly from user attributes
    than the default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at `password_validation.py`, we have defined two new validators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MaximumLengthValidator` is very similar to the built-in one for minimum length,
    ensuring that the password is no longer than the default of 24 characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SpecialCharacterInclusionValidator` checks that one or more special characters
    – defined as the `$`, `%`, `:`, `#`, and `!` symbols by default – are found within
    the given password'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each validator class has two required methods:'
  prefs: []
  type: TYPE_NORMAL
- en: The `validate()` method performs the actual checks against the `password` argument.
    Optionally, a second `user` argument will be passed when a user has been authenticated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We must also provide a `get_help_text()` method, which returns a string describing
    the validation requirements for the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we add the new validators to the settings in order to override the
    defaults to allow up to a 32-character maximum length for the password, and to
    be able to add the symbols `{`, `}`, `^`, and `&` to the default special character
    list.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The validators that are provided in `AUTH_PASSWORD_VALIDATORS` are executed
    automatically for the `createsuperuser` and `changepassword` management commands,
    as well as the built-in forms that are used to change or reset passwords. There
    will be times where you will want to use the same validation for custom password
    management code, though. Django provides functions for that level of integration
    and you can check the details in the contributed Django `auth` app in the `django.contrib.auth.password_validation`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Downloading authorized files* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Authenticating with Auth0* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Downloading authorized files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you may only need to allow specific people to download intellectual
    property from your website. For example, music, videos, literature, or other artistic
    works should only be accessible to paid members. In this recipe, you will learn
    how to restrict image downloads only to authenticated users using the contributed
    Django auth app.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with the `ideas` app that we created in [Chapter 3](ac26c6a6-3fd1-4b28-8b01-5b3cda40f4f9.xhtml),
    *Forms and Views*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Execute these steps one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the view that will require authentication to download a file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the download view to the URL configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Set up the login view in our project URL configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a template for the login form, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the template of idea details, add a link to the download:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You should restrict users from bypassing Django and downloading restricted
    files directly. To do so, on an Apache web server, you can put a `.htaccess` file
    in the `media/ideas` directory by using the following content if you are running Apache
    2.4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: When using `django-imagekit`, as shown in the examples throughout this book,
    the generated image versions will be stored and served from the `media/CACHE`
    directory, so our `.htaccess` configuration won't affect it.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `download_idea_picture` view streams the original uploaded picture from
    a specific idea. The `Content-Disposition` header that is set to `attachment`
    makes the file downloadable instead of being immediately shown in the browser.
    The filename for the file is also set in this header, and will be something similar
    to `gamified-donation-platform.jpg`. If the picture for an idea is unavailable,
    a 404 page will be shown with a very simple message: Picture unavailable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@login_required` decorator will redirect the visitor to the login page
    if they try to access the downloadable file without being logged in. The login
    screen will look like this by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/273c8926-f6a8-4087-b876-ae6bd05c0981.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Uploading images* recipe from [Chapter 3](ac26c6a6-3fd1-4b28-8b01-5b3cda40f4f9.xhtml),
    *Forms and Views*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a form layout with custom templates* recipe from [Chapter 3](ac26c6a6-3fd1-4b28-8b01-5b3cda40f4f9.xhtml),
    *Forms and Views*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a form layout with django-crispy-forms* recipe from [Chapter 3](ac26c6a6-3fd1-4b28-8b01-5b3cda40f4f9.xhtml),
    *Forms and Views*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Arranging the base.html template* recipe from [Chapter 4](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml),
    *Templates and JavaScript*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Implementing password validation* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Adding a dynamic watermark to images* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a dynamic watermark to images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, it is desirable to allow users to see images, but keep them from
    being redistributed due to intellectual property and artistic rights. In this
    recipe, we will learn how to apply a watermark to images that are displayed on
    your site.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with the `core` and `ideas` apps that we created in the *Creating
    an app with CRUDL functions *recipe in [Chapter 3](ac26c6a6-3fd1-4b28-8b01-5b3cda40f4f9.xhtml),
    *Forms and Views*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to apply a watermark to the displayed idea images:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you haven''t done so already, install `django-imagekit` into your virtual
    environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Put `"imagekit"` into `INSTALLED_APPS` in the settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `core` app, create a file called `processors.py` with a `WatermarkOverlay`
    class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Idea` model, add the `watermarked_picture_large` specification next
    to the `picture` field, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Using a graphical program of your choice, create a semi-transparent PNG image
    with white text or a logo on a transparent background. Make it 800 x 400 px in
    size. Save the image as `site_static/site/img/watermark.png`. Here''s what it
    might look like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e5d2c032-4ad3-426e-9fa5-a932de9e6183.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the `collectstatic` management command afterward:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the idea detail template and add the watermarked image there, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we navigate to the idea detail page, we should see the large image masked
    by our watermark, similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/527e60a3-66e9-45f5-87bd-f521ce8fc34f.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's examine how this was done. In the detail template, the `src` attribute
    for the `<img>` tag uses the idea's image specification, that is, `watermarked_picture_large`,
    to create a modified image that is then saved under the `media/CACHE/` directory
    and served from there.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `django-imagekit` specifications use processors to modify images. Two processors
    are used there:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ResizeToFill` resizes the image to 800 × 400 px'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our custom processor, `WatermarkOverlay`, applies the semi-transparent overlay
    to it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`django-imagekit` processors must have a `process()` method that takes the
    image from the previous processors and returns a new modified image. In our case,
    we compose the result from the original and the semi-transparent overlay.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Downloading authorized files* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authenticating with Auth0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the number of services people interact with daily increases, so does the
    number of usernames and passwords that they need to remember. Beyond just that,
    each additional place where user information is stored is another place that it
    could be stolen from, in the event of a security breach. To help mitigate this,
    services such as **Auth0** allow you to centralize authentication services on
    a single, secure platform.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to its support for username and password credentials, Auth0 has
    the ability to authenticate users via social platforms such as Google, Facebook,
    or Twitter. You could use passwordless login via single-time codes sent by SMS
    or email, and there is even enterprise-level support for different services. In
    this recipe, you'll learn how to connect an Auth0 application to Django and how
    to integrate it to handle user authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you haven't done so yet, create an Auth0 application at [https://auth0.com/](https://auth0.com/)​
    and configure it by following the instructions there. Two social connections are
    provided in the free plan, so we will activate Google and Twitter to log in with
    them. You can also try other services. Note that some of them require you to register
    an app and get API keys and secrets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to install `python-social-auth` and some other dependencies in
    the project. Include these dependencies in your `pip` requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`social-auth-app-django` is a Django-specific package of the `python-social-auth`
    project that allows you to authenticate to your website using one of many social
    connections.'
  prefs: []
  type: TYPE_NORMAL
- en: Install those dependencies with `pip` into your virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To connect Auth0 to your Django project, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the social authentication app to `INSTALLED_APPS` in the settings file,
    like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add the Auth0 settings required by the `social_django` app, which will
    be similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that you define `AUTH0_DOMAIN`, `AUTH0_KEY`, and `AUTH0_SECRET` in
    your secrets or environment variables. The values for those variables can be found
    in the settings of your Auth0 app that you created in *Step 1* of this recipe's *Getting
    ready* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create a backend for the Auth0 connection, as shown in the following
    example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the new backend to your `AUTHENTICATION_BACKENDS` setting, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We want the social authentication user to be accessible from any template.
    Therefore, we''ll create a context processor for it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to register it in the settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create views for the index page, dashboard, and logout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the index template, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a dashboard template accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the URL rules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add the login URL settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you point a browser to the index page of your project, you will see a link
    inviting you to log in. When you click on it, you will be redirected to the Auth0
    authentication system, whose screen will look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6999e777-9040-41a5-93e8-b93bd128971a.png)'
  prefs: []
  type: TYPE_IMG
- en: This much is enabled out of the box by `python-social-auth`, an `Auth0` backend,
    by configuring its associated `SOCIAL_AUTH_*` settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a successful login has been completed, the Auth0 backend receives the
    data from the response and processes it. The associated data is attached to the
    user object associated with the request. In the dashboard view, which is reached
    as a result of authentication proceeding to `LOGIN_REDIRECT_URL`, user details
    are extracted and added to the template context. `dashboard.html` is then rendered.
    The result may look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0da83ec6-d5be-411f-9d3b-865f1de66ba7.png)'
  prefs: []
  type: TYPE_IMG
- en: The logout button presented on the dashboard will proceed to log the user back
    out when pressed.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Implementing password validation* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Downloading authorized files* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching the method return value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you call a model method with heavy calculations or database queries multiple
    times in the request-response cycle, the performance of the view might become
    very slow. In this recipe, you will learn about a pattern that you can use to
    cache the return value of a method for later repetitive use. Note that we are
    not using the Django cache framework here, only what Python provides us by default.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Choose an app with a model that has a time-consuming method that will be used
    repetitively in the same request-response cycle.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a pattern that you can use to cache a method return value of a model
    for repetitive use in views, forms, or templates, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, let''s create a `get_thumbnail_url()` method for the `ViralVideo`
    model. You will explore this in more detail later in the *Using database query
    expressions* recipe in [Chapter 10](dc084cae-d894-487f-8071-08c63c80f852.xhtml)*,
    Bells and Whistles*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this generic example, the method checks whether the `_expensive_value_cached`
    attribute exists for the model instance. If it doesn't exist, time-consuming calculations
    are performed and the result is assigned to this new attribute. At the end of
    the method, the cached value is returned. Of course, if you have several weighty
    methods, you will need to use different attribute names to save each calculated
    value.
  prefs: []
  type: TYPE_NORMAL
- en: You can now use something such as `{{ object.some_expensive_function }}` in
    the header and footer of a template, and the time-consuming calculations will
    be done just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a template, you can also use the function in both the `{% if %}` condition
    and the output of the value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'In the other example, we checked the thumbnail of a YouTube video by parsing
    the URL of the video''s embed code, getting its ID, and then composing the URL
    of the thumbnail image. By doing this, you can use it in a template, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The approach we have just described only works if the method is called without
    arguments so that the result will always be the same. But what if the input varies?
    Since Python 3.2, there is a decorator we can use to provide basic **Least Recently
    Used** (**LRU**) caching of method calls based on a hash of the arguments (at
    least those that are hashable).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s look at a contrived and trivial example with a function
    that takes in two values and returns the result of some expensive logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'If we had such a function and wanted to provide a cache to store the results
    of some commonly used input variations, we could do so easily with the `@lru_cache`
    decorator from the `functools` package, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have provided a caching mechanism that will store up to 100 results
    under the keys that we hashed from the input. The `typed` option was added in
    Python 3.3 and, by specifying `True`, we have made it so that a call that has `a=1`
    and `b=2` will be stored separately from one with `a=1.0` and `b=2.0`. Depending
    on how the logic operates and what the return value is, such variation may or
    may not be appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about the `@lru_cache` decorator in the `functools` documentation
    at [https://docs.python.org/3/library/functools.html#functools.lru_cache](https://docs.python.org/3/library/functools.html#functools.lru_cache).
  prefs: []
  type: TYPE_NORMAL
- en: 'We could also use this decorator for the examples earlier in this recipe to
    simplify the code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 4](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*, Templates and JavaScript*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using Memcached to cache Django views* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using Redis to cache Django views* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Memcached to cache Django views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django allows us to speed up the request-response cycle by caching the most
    expensive parts, such as database queries or template rendering. The fastest and
    most reliable caching natively supported by Django is the memory-based cache server
    **Memcached**. In this recipe, you will learn how to use Memcached to cache a
    view for the `viral_videos` app. We'll explore this further in the *Using database
    query expressions* recipe in [Chapter 10](dc084cae-d894-487f-8071-08c63c80f852.xhtml)*,
    Bells and Whistles*.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several things we need to do in order to prepare caching for our
    Django project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s install the `memcached` service. For example, the simplest way to do
    that on macOS is to use Homebrew:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can start, stop, or restart the Memcached service with these commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: On other operating systems, you can install Memcached using apt-get, yum, or
    other default package management utilities. Another option is to compile it from
    the source, as mentioned at [https://memcached.org/downloads](https://memcached.org/downloads).
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Memcached Python bindings in your virtual environment, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To integrate caching for your specific views, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set `CACHES` in the project settings, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that you have `CACHE_LOCATION` set to `"localhost:11211"` in your
    secrets or environment variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the views of the `viral_videos` app, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: If you follow the Redis setup in the next recipe, you'll see that there is no
    change whatsoever in the `views.py` file. This shows us that we can change the
    underlying caching mechanism at will without ever needing to modify the code that
    uses it.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you will see later in the *Using database query expressions* recipe in [Chapter
    10](dc084cae-d894-487f-8071-08c63c80f852.xhtml), *Bells and Whistles*, the detail
    view of the viral video shows the number of impressions by authenticated and anonymous
    users. If you access a viral video (such as at `http://127.0.0.1:8000/en/videos/1/`)
    and refresh the page a few times with caching enabled, you will notice that the
    number of impressions changes only once a minute. This is because each response
    is cached for 60 seconds for every user. We set caching for the view using the
    `@cache_page` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: Memcached is a key-value store and it uses the full URL by default to generate
    the key for each cached page. When two visitors access the same page simultaneously,
    the first visitor's request would receive the page generated by the Python code,
    and the second one would get the same HTML code but from the Memcached server.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, to ensure that each visitor gets treated separately, even if
    they access the same URL, we are using the `@vary_on_cookie` decorator. This decorator
    checks the uniqueness of the `Cookie` header in the HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about Django's cache framework from the official documentation
    at [https://docs.djangoproject.com/en/3.0/topics/cache/](https://docs.djangoproject.com/en/3.0/topics/cache/).
    Similarly, you can find out more about Memcached at [https://memcached.org/](https://memcached.org/).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Caching the method return value* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using Redis to cache Django views* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using database query expressions* recipe in [Chapter 10](dc084cae-d894-487f-8071-08c63c80f852.xhtml)*,
    Bells and Whistles*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Redis to cache Django views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although Memcached is well established in the market as a caching mechanism,
    and well supported by Django, Redis is an alternate system that provides all the
    functionality of Memcached and more. Here, we'll revisit the process from the
    *Using Memcached to cache Django views* recipe and learn how to do the same using
    Redis instead.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several things we need to do in order to prepare caching for our
    Django project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s install the Redis service. For example, the simplest way to do that
    on macOS is to use Homebrew:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can start, stop, or restart the Redis service with these commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: On other operating systems, you can install Redis using apt-get, yum, or other
    default package management utilities. Another option is to compile it from the
    source, as mentioned at [https://redis.io/download](https://redis.io/download).
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the Redis cache backend for Django and its dependencies in your virtual
    environment, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To integrate caching for your specific views, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set `CACHES` in the project settings, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that you have `CACHE_LOCATION` set to `"localhost:6379"` in your secrets
    or environment variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the views of the `viral_videos` app, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: If you followed the Memcached setup from the previous recipe, you will see that
    there is no change whatsoever in the `views.py` here. This shows you that we can
    change the underlying caching mechanism at will without ever needing to modify
    the code that uses it.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like with Memcached, we set caching for the view using the `@cache_page` decorator.
    So, each response is cached for 60 seconds for every user. A viral video detail
    view (such as the one at `http://127.0.0.1:8000/en/videos/1/`) shows the number
    of impressions by authenticated and anonymous users. With caching enabled, if
    you refresh the page a few times, you will notice that the number of impressions
    changes only once a minute.
  prefs: []
  type: TYPE_NORMAL
- en: Just like Memcached, Redis is a key-value store, and when used for caching,
    it generates the key for each cached page based on the full URL. When two visitors
    access the same page simultaneously, the first visitor's request would receive
    the page generated by the Python code, and the second one would get the same HTML
    code but from the Redis server.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, to ensure that each visitor gets treated separately, even if
    they access the same URL, we are using the `@vary_on_cookie` decorator. This decorator
    checks the uniqueness of the `Cookie` header in the HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about Django's cache framework from the official documentation
    at [https://docs.djangoproject.com/en/3.0/topics/cache/](https://docs.djangoproject.com/en/3.0/topics/cache/).
    Similarly, you can find out more about Memcached at [https://redis.io/](https://redis.io/).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Redis is able to handle caching in the same manner as Memcached, there
    is a multitude of additional options for the caching algorithm built right into
    the system. In addition to caching, Redis can also be used as a database or message
    store. It supports a variety of data structures, transactions, pub/sub, and automatic
    failover, among other things.
  prefs: []
  type: TYPE_NORMAL
- en: 'Through the django-redis-cache backend, Redis can also be configured as the
    session backend with almost no effort, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Caching the method return value* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using Memcached to cache Django views* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using database query expressions* recipe in [Chapter 10](dc084cae-d894-487f-8071-08c63c80f852.xhtml)*,
    Bells and Whistles*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
