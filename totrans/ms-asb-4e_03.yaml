- en: '*Chapter 2*: Migrating from Earlier Ansible Versions'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As **Ansible** has grown over the years, certain headaches have presented themselves
    to the team that develops and manages the Ansible code base. In many ways, these
    headaches have been the price of Ansible's own growth and success, and have resulted
    in a need to structure the code a little differently. Indeed, anyone with a little
    prior experience of Ansible from versions before 2.10 will have noticed that our
    example code presented in this book looks a little different, along with a new
    term, **Collections**.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explain these changes in detail, along with how they
    came about. We will then take you through some practical examples so you can see
    how these changes work in the real world, before finally teaching you how to migrate
    any existing or legacy playbooks you might have to Ansible 4.3 and beyond.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, in this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Changes in Ansible 4.3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upgrading from earlier Ansible installations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Ansible from scratch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are Ansible Collections?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing additional modules with `ansible-galaxy`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to port legacy playbooks to Ansible 4.3 (a primer)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow the examples presented in this chapter, you will need a Linux machine
    running **Ansible 4.3** or newer. Almost any flavor of Linux should do. For those
    interested in specifics, all the code presented in this chapter was tested on
    **Ubuntu Server 20.04 LTS** unless stated otherwise, and on **Ansible 4.3**. The
    example code that accompanies this chapter can be downloaded from GitHub at this
    URL: [https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter02](https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter02).
    We will make use of a module that we develop in [*Chapter 10*](B17462_10_Final_JC_ePub.xhtml#_idTextAnchor183),
    *Extending Ansible*, to show you how to build your own collection, so it is worthwhile
    making sure you have a copy of the accompanying code for this book.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to view the Code in Action: [https://bit.ly/3DYi0Co](https://bit.ly/3DYi0Co)'
  prefs: []
  type: TYPE_NORMAL
- en: Changes in Ansible 4.3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we touched on this topic in [*Chapter 1*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015),
    *The* *System Architecture and Design of Ansible*, it is important that we look
    in greater depth at these changes to help you fully understand how Ansible 4.3
    differs from prior releases. This will help you greatly in writing good playbooks
    and maintaining and upgrading your Ansible infrastructure – it is an essential
    step to mastery of Ansible 4.3!
  prefs: []
  type: TYPE_NORMAL
- en: First off, a little history. As we discussed in the preceding chapter, Ansible
    possesses a number of strengths in its design that have led to its rapid growth
    and uptake. Many of these strengths, such as its agentless design and easy-to-read
    YAML code, remain the same. Indeed, if you read the change logs for Ansible releases
    since 2.9, you will observe that there have been few changes of note to the core
    Ansible functionality since that release—rather, all the development effort has
    gone into another area.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible's modules were undoubtedly one of its greatest strengths, and the fact
    that anyone, from individual contributors to hardware vendors and cloud providers,
    could submit their own modules meant that by the time of the 2.9 release, Ansible
    contained literally thousands of modules for every conceivable purpose.
  prefs: []
  type: TYPE_NORMAL
- en: This in itself became something of a headache for those managing the project.
    Let's say that a module had a bug in it that needed to be fixed, or someone added
    a great new feature to an existing one that was likely to be popular. The Ansible
    release itself contained all the modules—in short, they were tightly coupled to
    the release of Ansible itself. This meant that in order for a new module to get
    released, a whole new version of Ansible had to be released to the community.
  prefs: []
  type: TYPE_NORMAL
- en: Combine that with issues and pull requests from hundreds of module developers,
    and those managing the core Ansible code base had a real headache on their hands.
    It was clear that while these modules were a massive part of Ansible's success,
    they were also responsible for causing issues in release cycles and management
    of the code base. What was needed was a way to decouple the modules (or at least
    the bulk of them) from the releases of the Ansible engine—the core Ansible runtimes
    that we ran in [*Chapter 1*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015),
    *The* *System Architecture and Design of Ansible*, of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, **Ansible Content Collections** (or just Collections for short) were born.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Content Collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While we will look in greater depth at these shortly, the important concept
    of note is that Collections are a package format for Ansible content, which for
    the sake of this discussion means all those thousands of modules. By distributing
    modules, especially those coded and maintained by third parties, using Collections,
    the Ansible team has effectively removed the coupling between the releases of
    the core Ansible product and the modules that make it so valuable to so many.
  prefs: []
  type: TYPE_NORMAL
- en: This of course leads to another nuance—when you installed, say, **Ansible 2.9.1**,
    you were installing a given version of the Ansible binaries and other core code,
    and all the modules that were submitted and approved for inclusion at that time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when we talk about installing Ansible 4.3, what we actually mean is this:'
  prefs: []
  type: TYPE_NORMAL
- en: Ansible 4.3.0 is now a package that contains (at the time of writing) 85 Collections
    of modules, plugins, and other important functionality that will get as many people
    as possible started on their Ansible journey before they need to install further
    Collections. It is, in short, a *getting started* pack of Collections.
  prefs: []
  type: TYPE_NORMAL
- en: What is important here is that Ansible 4.3.0 does *not* contain any actual automation
    runtimes. If you were to install Ansible 4.3.0 in isolation, you would not actually
    be able to run Ansible! Fortunately, doing this is not possible, and Ansible 4.3.0
    has a dependency on a package currently called **ansible-core**. This package
    contains the Ansible language runtimes, and a small number of the core plugins
    and modules, such as `ansible.builtin.debug`, which we used frequently in the
    examples in [*Chapter 1*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015), *The*
    *System Architecture and Design of Ansible*.
  prefs: []
  type: TYPE_NORMAL
- en: Each release of the Ansible package will have dependencies on specific versions
    of ansible-core, such that it will always pair itself up with the right automation
    engine. For example, Ansible 4.3.0 depends upon ansible-core >= 2.11 and < 2.12.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible has switched to semantic versioning for the Ansible package itself,
    starting with the 3.0.0 release. For anyone who hasn''t come across semantic versioning
    yet, it can be explained quite simply as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible 4.3.0: This is the first semantic versioned release of a new Ansible
    package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ansible 4.0.1: This (and all releases where the rightmost digit changes) will
    contain only backward-compatible bug fixes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ansible 4.1.0: This (and all releases where the middle digit changes) will
    contain backward-compatible new features, and possibly also bug fixes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ansible 5.0.0: This will contain changes that break backward compatibility
    and is known as a major release.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ansible-core package is not adopting semantic versioning, so it is anticipated
    that Ansible 5.0.0 will have a dependency on ansible-core >= 2.12\. Note that
    this release of ansible-core, not being under semantic versioning, could contain
    changes that break backward compatibility, and so it is important on our journey
    to mastery to be aware of these nuances in how Ansible is now versioned.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Finally, note that the ansible-core package was renamed from ansible-base in
    the 2.11 release, so if you see references to ansible-base please know it is simply
    the old name for the ansible-core package.
  prefs: []
  type: TYPE_NORMAL
- en: All these changes have been planned and executed over a significant period of
    time. While their implementation has been designed to make the journey for existing
    Ansible users as smooth as possible, there are implications that need to be addressed,
    starting with how you actually install and upgrade Ansible, and we will look at
    exactly that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading from earlier Ansible installations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The splitting of Ansible into two packages, one of which is dependent on the
    other, has created some headaches for package maintainers. Whereas packages were
    readily available for CentOS and RHEL, there are no current packages of Ansible
    4.3.0 or ansible-core 2.11.1\. A quick look inside the EPEL packages directory
    for CentOS/RHEL 8 shows that the latest RPM available for Ansible is version 2.9.18\.
    The official Ansible installation guide goes further:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Since Ansible 2.10 for RHEL is not available at this time, continue to use
    Ansible 2.9*.'
  prefs: []
  type: TYPE_NORMAL
- en: This will change in due course as package maintainers work out the pros and
    cons of the various upgrade paths and packaging technologies, but at the time
    of writing, there is a very clear expectation on your upgrade path if you want
    to get started with Ansible 4.3.0 now, and the easiest way to get your hands on
    this latest and greatest release is to install it using the Python packaging technology,
    **pip**. However, it is not so much an upgrade we're performing, as an uninstallation
    followed by a re-installation.
  prefs: []
  type: TYPE_NORMAL
- en: Uninstalling Ansible 3.0 or older
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The radical changes in Ansible package structure mean that if you have Ansible
    3.0 or earlier (including any of the 2.x releases) installed on your control node,
    sadly you cannot just upgrade your Ansible installation. Rather, you need to remove
    your existing Ansible installation before you install the later version.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: As with removing any software, you should make sure you take a backup of your
    important files, especially central Ansible configuration files and inventories,
    in case they get removed during the removal process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method for removing your package will depend upon your installation. For
    example, if you have Ansible 2.9.18 installed on CentOS 8 through an RPM, you
    can remove it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, on Ubuntu you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you installed Ansible using `pip` previously, you can remove it with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In short, it doesn't matter how you installed Ansible 3.0 (or earlier) on your
    control node. Even if you installed it with `pip`, and you are going to install
    the new version with pip, you must first uninstall the old version before doing
    anything else.
  prefs: []
  type: TYPE_NORMAL
- en: When newer Ansible versions become available, it is advisable to check the documentation
    to see whether an uninstall is still required as part of the upgrade. For example,
    it was necessary to uninstall Ansible 3.0 before installing Ansible 4.3, partly
    due to the renaming of the ansible-base package to ansible-core.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have removed your earlier version of Ansible, you are now ready to
    proceed with installing the new version on your control node, which we will cover
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Ansible from scratch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As discussed in the preceding section, Ansible 4.3 is largely packaged and
    distributed using a Python package manager called **pip**. This is likely to change
    in due course, but at the time of writing, the key installation method you will
    need to use is to install via pip. Now, it''s fair to say that most modern Linux
    distributions already come with Python and pip pre-installed. If for any reason
    you get stuck and need to install it, the process is well documented on the official
    website here: [https://pip.pypa.io/en/stable/installing/](https://pip.pypa.io/en/stable/installing/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have pip installed, the process of installing Ansible is as simple
    as running this command, and the beauty is, the command is the same on all operating
    systems (though note that on some operating systems, your `pip` command might
    be called `pip3` to differentiate between the Python 2.7 and Python 3 releases
    that may coexist):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There are, of course, a few variations on this command. For example, the command
    as we have given it will install the latest version of Ansible available for all
    users on the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to test or stick to a specific version (perhaps for testing or
    qualification purposes), you could force pip to install a specific version with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This second command will ensure that Ansible 4.3.0 is installed for all users
    on your system, regardless of which is the latest release. We can go further too;
    to install Ansible but only for your user account, you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'One particularly handy trick is that when you start working with pip, you can
    use Python virtual environments to sandbox specific versions of Python modules.
    For example, you could create one virtual environment for Ansible 2.9 as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the virtual environment in a suitable directory using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will create a new virtual environment in the directory where you run the
    command, with the environment (and directory containing it) being called `ansible-2.9`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activate the virtual environment as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you are ready to install Ansible 2.9\. To install the latest version of
    Ansible 2.9, we will need to tell `pip` to install a version greater than (or
    equal to) 2.9, but less than 2.10, otherwise it would simply install Ansible 4.3:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you check your Ansible version, you should find that you are running
    the latest minor version of 2.9:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The downside to using virtual environments is that you need to remember to
    run the `source` command from *step 2* every time you log into your Ansible control
    machine. However, the upside is that you could repeat the preceding process with
    Ansible 4.3 in a separate virtual environment as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The great thing about this is that you can now switch between the two versions
    of Ansible at will, simply by issuing the appropriate source command for the appropriate
    environment and then running Ansible in the usual way. This could be especially
    useful if you are in the process of migrating code from Ansible 2.9 to 4.3, or
    have some legacy code that won't yet work and you still need it before you have
    time to make the required changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, if you want to upgrade your new installation of Ansible, you simply
    need to issue the appropriate `pip` command depending on your install method.
    For example, if you installed Ansible for all users, you would issue the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you had installed it only for your user account, the command would be similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if you are working in a virtual environment, you must remember to activate
    the environment first. Once this is done, you can upgrade in the same way as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the preceding example will upgrade whatever is installed in the Ansible
    2.9 environment to the very latest version, which right now is 4.0\. Also, a point
    to be noted is that, as discussed in the preceding section, *Upgrading from earlier
    Ansible installations*, this will break the install. To upgrade to the latest
    minor version, remember that you can specify version criteria just as we did when
    installing Ansible in this environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can of course apply the version constraints to any of the other examples
    too. Their use is not limited in any way to a virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, by now you should have a pretty good idea of how to install Ansible
    4.3, either from scratch, or to upgrade from an earlier installation. With this
    done, it's time we took a look at **Ansible Collections** as they are the driver
    behind all these changes.
  prefs: []
  type: TYPE_NORMAL
- en: What are Ansible Collections?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible Collections represent a major departure from the traditional monolithic
    approach to Ansible releases, where over 3,600 modules were being released along
    with the Ansible executables at one point. This, as you can imagine, was making
    Ansible releases unmanageable, and also meant that end users had to wait for an
    entirely new release of Ansible to receive a feature update or bug fix to a single
    module—obviously a very inefficient approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, Ansible Collections were born, and their premise is quite simple: they
    are a mechanism for building, distributing, and consuming multiple different types
    of Ansible content. When you first migrate from Ansible 2.9 or earlier, your experience
    with Ansible Collections will come in the form of modules. As we discussed earlier
    in this chapter, what we call Ansible 4.3 is actually a package comprising around
    85 collections…it does not contain the Ansible executables at all! Each of these
    collections contains a number of different modules, some maintained by the community,
    some maintained by specific vendors. Ansible 4.3 depends upon ansible-core 2.11.x,
    and this package contains the Ansible executables and the core `ansible.builtin`
    modules only (such as `debug`, `file`, and `copy`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look in more detail at the anatomy of a collection so that we
    can understand more fully how they work. Each collection has a name comprising
    two parts: the namespace and the collection name.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `ansible.builtin` collection has a namespace of `ansible` and
    a collection name of `builtin`. Similarly, in [*Chapter 1*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015),
    *The* *System Architecture and Design of Ansible*, we installed a collection called
    `amazon.aws`. Here, `amazon` is the namespace and `aws` is the collection name.
    All namespaces must be unique, but collection names can be the same within a namespace
    (thus you could theoretically have `ansible.builtin` and `amazon.builtin`).
  prefs: []
  type: TYPE_NORMAL
- en: Although you can work with collections in a number of ways, including simply
    building and installing them locally all from your own machine, or directly from
    a Git repository, the central home for collections is **Ansible Galaxy**, and
    it is here that you will find all the collections included with the Ansible 4.3
    package, along with many more. The Ansible Galaxy website is accessible at [https://galaxy.ansible.com](https://galaxy.ansible.com)
    and there is a command-line tool (which we saw in [*Chapter 1*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015),
    *The* *System Architecture and Design of Ansible*) called `ansible-galaxy` that
    can be used to interact with this website (for example, to install collections).
    We will use this tool quite extensively throughout the rest of this chapter, so
    you will get a chance to get better acquainted with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can freely create your own account on Ansible Galaxy by logging in with
    your GitHub credentials, and when you do, your namespace is automatically created
    to be the same as your GitHub username. You can learn more about Ansible Galaxy
    namespaces here: [https://galaxy.ansible.com/docs/contributing/namespaces.html](https://galaxy.ansible.com/docs/contributing/namespaces.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an understanding of how Ansible Collection names are created,
    let's take a deeper look at how Collections are put together and how they work.
  prefs: []
  type: TYPE_NORMAL
- en: The anatomy of an Ansible collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easiest way to understand how a collection works under the hood is to build
    a simple one for ourselves, so let's get started on that. As with all aspects
    of Ansible, the developers have produced a system in collections that is powerful
    yet easy to work with, and if you already have prior experience of working with
    Ansible roles you will find collections work in a similar way. If you haven't,
    however, don't worry; we'll teach you all you need to know here.
  prefs: []
  type: TYPE_NORMAL
- en: 'A collection comprises a series of directories, each with a special name and
    each intended to hold a specific type of content. Any of these directories can
    be empty; you don''t have to include all types of content in a collection. In
    fact, there is only one mandatory file in a collection! Ansible even provides
    a tool to help you build an empty collection to get started with. Let''s use this
    now to create a new empty collection to learn with by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this, you should see that it creates a directory tree as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You can see from the preceding directory tree that this command created a top-level
    directory using our `masterybook` namespace, and then a subdirectory with the
    collection name of `demo`. It then created two files and three directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of these is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`README.md`: This is the README file for the collection and should provide
    helpful information to anyone who is looking at the module code for the first
    time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docs`: This directory is used to store general documentation for the collection.
    All documentation should be in Markdown format and should not be placed in any
    subfolders. Modules and plugins should still have their documentation embedded
    using Python docstrings, which we will learn more about in [*Chapter 10*](B17462_10_Final_JC_ePub.xhtml#_idTextAnchor183),
    *Extending Ansible*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`galaxy.yml`: This is the only mandatory file in the collection structure and
    contains all the information necessary to build the collection, including version
    information, author details, license information, and so on. The file created
    by the command run previously is a complete template with comments to explain
    each parameter, so you should find it easy to go through it and complete it to
    your requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`plugins`: This directory should contain all the Ansible plugins that you develop.
    Modules should also be included in separate modules/subdirectories, which you
    will need to create under the plugins folder. We will learn about creating plugins
    and modules for Ansible in [*Chapter 10*](B17462_10_Final_JC_ePub.xhtml#_idTextAnchor183),
    *Extending Ansible*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`roles`: Before Ansible 3.0, Ansible Galaxy existed only to distribute roles:
    reusable sets of Ansible code that can readily be distributed and used elsewhere
    to solve common automation challenges. We will learn all about roles in [*Chapter
    8*](B17462_08_Final_JC_ePub.xhtml#_idTextAnchor156), *Composing Reusable Ansible
    Content with Roles*, so don''t worry for now if you haven''t come across them
    yet. Roles can still be distributed using Ansible Galaxy but can also be included
    in collections, which in time will probably become the norm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition to this, collections can also contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tests`: This directory is used to store files related to testing Ansible Collections
    prior to release, and to be included in the top-level Ansible package, collections
    must pass the Ansible test process. You don''t need to do this to use your own
    collection internally, but if you want it included in the main Ansible package
    you will have to complete this part of the development process. More details are
    available here: [https://docs.ansible.com/ansible/latest/dev_guide/developing_collections.html#testing-collections](https://docs.ansible.com/ansible/latest/dev_guide/developing_collections.html#testing-collections).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`meta/runtime.yml`: This file and directory is used to specify important metadata
    about the collection, such as the version of the ansible-core package required,
    and various namespace routing and redirection stanzas to assist with the migration
    from Ansible 2.9 and earlier (where there were no namespaces) to Ansible 4.3 and
    beyond.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`playbooks`: This directory will be supported in future versions of Ansible
    to include playbooks with the collection, though the official documentation on
    this is not complete at the time of writing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that you''ve created and understood the collection directory structure,
    let''s add our own module to it. When we''ve done this, we''ll package it up and
    then install it on our system and use it in a playbook: a complete end-to-end
    test of how collections work. We''ll borrow the module code for this from [*Chapter
    10*](B17462_10_Final_JC_ePub.xhtml#_idTextAnchor183), *Extending Ansible*, so
    don''t worry about understanding this code in depth at this stage as it is fully
    explained there. The full code listing is several pages long so we won''t repeat
    it in the book here. Download the code accompanying this book or refer to the
    code listings in [*Chapter 10*](B17462_10_Final_JC_ePub.xhtml#_idTextAnchor183),
    *Extending Ansible*, to obtain the `remote_copy.py` module code. It is included
    in the `Chapter10/example08/library` directory of the example code accompanying
    this book.'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `modules/` subdirectory inside the `plugins/` directory, and add the
    `remote_copy.py` code there.
  prefs: []
  type: TYPE_NORMAL
- en: When you have reviewed the information in `galaxy.yml`, feel free to add your
    own name and other details in there, and you're done! That's all there is to creating
    your first collection. It really is beautifully simple, a set of files in a well-ordered
    directory structure.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Collections are expected to follow semantic versioning, as discussed
    earlier in this chapter, so be sure to adopt this when you create and build your
    own modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your completed module directory structure should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When all the files are in place, it''s time to build your collection. This
    is very simple, and is done by changing up to the same collection top-level directory
    (the one where `galaxy.yml` resides) and running this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This creates a tarball containing your collection files, which you can now use
    as you wish! You could publish this straight away to Ansible Galaxy, but first,
    let's test it locally to see if it works.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Ansible stores collections locally in your home directory, under
    `~/.ansible/collections`. However, as we are testing a collection we just built,
    let's alter the behavior of Ansible slightly and install it in a local directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'To try this out, create a new empty directory for a simple test playbook to
    reside in, and then create a directory called `collections` for us to install
    our newly created collection in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, Ansible won''t know to look in this directory for collections,
    so we must override its default configuration to tell it to look in here. Within
    your directory, create a new `ansible.cfg` file (this file is always read if present
    and overrides the settings in any central configuration file, for example, `/etc/ansible/ansible.cfg`).
    This file should contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This configuration directive tells Ansible to look in the collections subdirectory
    within our current directory before checking the default locations on the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you''re ready to install the collection we built earlier. Assuming you
    built this in your home directory, the command to do this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If you explore your local `collections` directory, you should find it now contains
    the collection you created earlier, plus a couple of extra files created during
    the build process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s create a simple playbook to make use of our module. As a spoiler
    to [*Chapter 10*](B17462_10_Final_JC_ePub.xhtml#_idTextAnchor183), *Extending
    Ansible*, this module performs a simple file copy on the system Ansible is controlling,
    so let''s create a test file in a publicly writeable directory such as `/tmp`,
    and put our module to work creating a copy. Consider the following playbook code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We have two tasks in our playbook here. One uses the file module from the `ansible.builtin`
    collection to create an empty file for our module to copy. The second task uses
    our new module, referencing it with the fully qualified collection name, to copy
    the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run this playbook code in the normal manner. For example, to run it
    against your local machine, run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the comma after the `localhost` inventory item. This tells Ansible we
    are listing inventory hosts on the command line rather than having to create a
    local inventory file—a handy little shortcut when you''re testing code! If all
    goes according to plan, your playbook run should look as shown in *Figure 2.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – The output from running our example playbook against our demo
    collection'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_02_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – The output from running our example playbook against our demo collection
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations, you have just created, built, and run your first Ansible collection!
    Collections are often more complex than this, of course, and may contain many
    modules, plugins, and even roles and other artifacts, as outlined earlier. However,
    to get started, this is all you need to know.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your final step when you are happy with your collection may very well be to
    publish it to Ansible Galaxy. Assuming you have already logged in to Ansible Galaxy
    and created your namespace, you simply need to navigate to your profile preferences
    page and click the **Show API Key** button, as shown in *Figure 2.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Obtaining your API key from Ansible Galaxy'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_02_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2 – Obtaining your API key from Ansible Galaxy
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then feed this API key into the `ansible-galaxy` command-line tool
    to publish your collection. For example, to publish our collection from this chapter,
    you could run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: That concludes our look at collections and how they are built and used. As we
    mentioned, there are several ways to install collections, and indeed, Ansible
    modules are now distributed across a variety of collections. In the next section,
    we will take a look at ways to locate the module you require, and how to install
    and reference collections from within your automation code.
  prefs: []
  type: TYPE_NORMAL
- en: Installing additional modules with ansible-galaxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the time when you work with collections, you won't be building them
    yourself. There are already 780 available on Ansible Galaxy at the time of writing
    and, there will probably be many more by the time you read this book. Nonetheless,
    it is the author's personal belief that we all learn better when we can get our
    hands dirty, and thus, developing our own, albeit simple, collection was a great
    way for us to look at how they are put together and how they are referenced.
  prefs: []
  type: TYPE_NORMAL
- en: However, let's focus now on finding and then working with pre-existing collections
    on Ansible, as this is where your focus is likely to be most of the time. As we
    have already mentioned, the Ansible 4.3 package includes a set of collections
    for you to begin your automation journey with, along with the `ansible.builtin`
    collection included with the ansible-core package.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to see which collections got installed when you installed Ansible
    4.3 on your system, simply run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return a list of all the installed collections in the format `<namespace>.<collection>`,
    along with their version numbers. Remember that collections are now independent
    of the Ansible version you install, so you can upgrade them without upgrading
    your entire Ansible installation. We will look at this shortly. The full list
    of collections installed as part of Ansible can also be found here: [https://docs.ansible.com/ansible/latest/collections/index.html](https://docs.ansible.com/ansible/latest/collections/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you come to need a module for a specific purpose, it is worth noting that
    collections are normally named to give you clues about what they contain. For
    example, suppose you want to perform some cloud provisioning in Amazon Web Services
    with Ansible; a quick glance at the collections index reveals two likely candidates:
    the `amazon.aws` collection and the `community.aws` one. Similarly, if you want
    to automate the functionality of a Cisco IOS switch, the `cisco.ios` collection
    looks like a good place to start. You can explore the modules present in each
    collection on the Ansible documentation website, or explore the modules in a collection
    by making use of the `ansible-doc` command. For example, to list all the modules
    contained in the `cisco.ios` collection, you could run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `community.*` packages aim to provide the same functionality that was present
    in Ansible 2.9, naturally with newer versions of modules and plugins, thus helping
    you to port playbooks from earlier Ansible versions without too much pain.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if you can't find what you need in the Ansible 4.3 package, you can
    simply head over to the Ansible Galaxy website to find many more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have established which collections you are going to need for your
    playbook development, it''s time to install them. We have already seen in the
    previous section that we can install a collection directly from a local file on
    disk. In [*Chapter 1*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015), *The*
    *System Architecture and Design of Ansible*, we ran the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This installed the latest version of the `amazon.aws` collection directly from
    Ansible Galaxy. The eagle-eyed among you might be thinking, "hold on, `amazon.aws`
    is already included as part of the Ansible 4.3 package." Indeed, it is. However,
    the decoupled nature of Ansible and its collections means we are free to install
    and upgrade collection versions without having to upgrade Ansible. Indeed, when
    we ran the preceding command, it installed the latest version of `amazon.aws`
    inside the users local collections path (`~/.ansible/collections`) as this is
    the default. Note that this is different to the behavior observed when we tested
    our own collection earlier in this chapter, as we specifically created an Ansible
    configuration file specifying a different collections path.
  prefs: []
  type: TYPE_NORMAL
- en: 'We find out what happened by running another collection list using the `ansible-galaxy`
    command, only this time we will only filter on the `amazon.aws` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Listing multiple versions of an installed collection'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_02_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.3 – Listing multiple versions of an installed collection
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see that the `1.3.0` version of this collection was installed alongside
    our Ansible installation itself, but that the later `1.4.0` version is installed
    in my home directory's `.ansible/collections` folder, the latter taking precedence
    when a playbook references it and is run from my user account. Note that playbooks
    run from other user accounts on this system would only see the version `1.3.0`
    collection as this is installed system wide, and they would not normally be referencing
    the folder in my home directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you might expect, you can specify the version of a collection you want when
    you install it. If I had wanted to install the latest development version of the
    `amazon.aws` collection, I could have installed it locally using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `--force` option is required as `ansible-galaxy` won't overwrite a release
    version of a collection with a development version unless you force it to—a sensible
    safety precaution!
  prefs: []
  type: TYPE_NORMAL
- en: 'As well as installing collections from local files and from Ansible Galaxy,
    you can also install them directly from a Git repository. For example, to install
    the latest commit on the `stable` branch of a hypothetical GitHub repository,
    you could run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: There are many possible permutations here, including accessing private Git repositories
    and even local ones.
  prefs: []
  type: TYPE_NORMAL
- en: All of these are perfectly valid ways to install collections. However, imagine
    you require ten different collections for your playbook to run successfully. The
    last thing you want to do is to have to run ten different `ansible-galaxy` commands
    every time you deploy the automation code somewhere new! Plus, this could very
    easily get out of hand, with different collection versions on different hosts.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, Ansible has your back here too, and the `requirements.yml` file
    (which was present in earlier versions of Ansible and used to install roles from
    Ansible Galaxy before collections became a reality) can be used to specify a set
    of collections to install.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, consider the following `requirements.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This file describes a requirement for two collections. The namespace for both
    is `geerlingguy`, and the collections are called `k8s` and `php_roles`. The `k8s`
    collection will have the latest stable version installed, whereas only version
    `1.0.0` of the `php_roles` collection will be installed regardless of the latest
    release version.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install all the requirements specified in `requirements.yml`, simply run
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the command should look something like *Figure 2.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Installing collections using a requirements.yml file'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_02_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.4 – Installing collections using a requirements.yml file
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from this output, both collections that we specified in the `requirements.yml`
    file have been installed at the appropriate versions. This is a very simple and
    powerful way to capture the collection requirements for your playbooks, and to
    have them all installed in one go, while retaining the correct versions where
    this is required.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, you should have a robust understanding of the big changes in
    Ansible 4.3, especially collections, how to find the right ones for your automation
    needs, and how to install them (and even how to create your own if you need to!).
    In the final part of this chapter, we will provide a brief primer on how to port
    your playbooks to Ansible 4.3 from version 2.9 and earlier.
  prefs: []
  type: TYPE_NORMAL
- en: How to port legacy playbooks to Ansible 4.3 (a primer)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No two Ansible playbooks (or roles or templates for that matter) are alike,
    and they vary in complexity from the simple to the intricate and complex. However,
    they are all important to their authors and users, and with all the major changes
    that were made in the transition from Ansible 2.9 through to 4.0, this book would
    not be complete without a primer on how to port your code to the newer Ansible
    versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get too deep into this subject, let''s look at an example. In the
    first ever edition of this book, written in 2015 about Ansible version 1.9, an
    example appeared that renders a **Jinja2** template using a small Ansible playbook.
    We will still learn about an updated version of this code in [*Chapter 6*](B17462_06_Final_JC_ePub.xhtml#_idTextAnchor123),
    *Unlocking the Power of Jinja2 Templates*, of this book, but for now let''s look
    at the original code. The template, called `demo.j2`, looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The playbook that renders this template looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the exact same code that appeared in the first edition of this book,
    and as it was written for Ansible 1.9 and so much has changed in the transition
    to 4.3, you could be forgiven for thinking that this code would never run on Ansible
    4.3\. However, let''s do exactly that. We''ll run this code with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from this command, run on Ansible 4.3 with ansible-core 2.11.1,
    looks like *Figure 2.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Running an example playbook from the first edition of this book
    on Ansible 4.3'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_02_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.5 – Running an example playbook from the first edition of this book
    on Ansible 4.3
  prefs: []
  type: TYPE_NORMAL
- en: 'You would be forgiven for asking. why does this work, and why all the detail
    about collections when code that was first written for Ansible 1.9 still works
    in 4.3 without modification? Ansible 4.3 was coded specifically to provide users
    with the least painful path possible, and it is even stated in the porting guide
    for Ansible 2.10:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Your playbooks should continue to work without any changes*.'
  prefs: []
  type: TYPE_NORMAL
- en: This will hold true as long as the module names remain unique. However, there
    is nothing to stop module name clashes any more—they only need to be unique within
    their own collection now. So, for example, we used the `pause` module in the preceding
    playbook, which has a **fully qualified collection name** (**FQCN**) of `ansible.builtin.pause`
    in Ansible 4.3\. The preceding code worked because there was no other module called
    `pause` within our collections. However, consider the `masterybook.demo` collection
    we created earlier in this chapter. There is nothing to stop us from creating
    our own module called `pause` in here that does something completely different.
    How would Ansible know which module to choose?
  prefs: []
  type: TYPE_NORMAL
- en: The answer comes from inside Ansible itself, which has been coded to search
    all of the collections that form part of the Ansible 4.3 package; thus, a reference
    to `pause` resolves to `ansible.builtin.pause`. It will never resolve to `masterybook.demo.pause`
    (assuming we created that module) and so we would need to use the FQCN if we wanted
    to use our hypothetical module in a task.
  prefs: []
  type: TYPE_NORMAL
- en: The recommendation from Ansible on this topic is to always use the FQCNs in
    your code to make sure that you never receive unexpected results from a module
    name clash. However, what if you wanted to avoid a lot of typing in a set of tasks?
    For example, typing `masterybook.demo.remote_copy` is a lot of typing if you have
    to do it repetitively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer comes in the form of a new `collections:` key defined at the play
    level in your playbook. When we tested our newly built collection earlier in this
    chapter, we used the FCQN to reference it. However, that same playbook could have
    been written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note the presence of the `collections:` key up at the play level. This in essence
    creates an ordered *search path* for references that are not specified by FQCNs.
    Thus, we have instructed our play to search the `masterybook.demo` namespace for
    modules, roles, and plugins before searching the included namespaces, such as
    `ansible.builtin`. Indeed, you can change the module reference on the `ensure
    foo` task from `ansible.builtin.file` to `file`, and the play will still work
    as intended. The collections directive does not overwrite these internal namespace
    search paths, it simply prepends namespaces to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of note though, is that when you start working with roles (which we will cover
    later in this book), the collections search path specified in the play does not
    get inherited by the roles, so they will all need to have this defined manually.
    You can define the collections search paths for a role by creating a `meta/main.yml`
    file within your role, which could contain, for example, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In addition, it is important to mention that these collection search paths do
    not affect items such as lookups, filters or tests that you might include in your
    collection. For example, if we included a lookup in our collection, it would need
    to be referenced using the FQCN regardless of whether the `collections` key appears
    in the play or role. Finally, note that you must always install your collections
    as demonstrated earlier in this chapter. Including the `collections` keyword in
    your code does not cause Ansible to automatically install or download the collections;
    it is simply a search path for them.
  prefs: []
  type: TYPE_NORMAL
- en: On balance, you will probably find it easier to work with FQCNs throughout your
    code, but the important lesson from this part of the section is that while it
    is best practice to use FQCNs throughout your code, it is by no means mandatory
    at this time, and if you are upgrading to Ansible 4.3, you don't have to go through
    every single playbook you ever wrote and update all the references to modules,
    plugins, and so on. You can do this over time, but it is advisable to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if we review all the changes that have happened in Ansible since
    even the 2.7 release, which the third edition of this book was based on, there
    are many. However, they will only affect certain playbooks as they relate to the
    specific behavior of certain play aspects, or to the way some modules work. Indeed,
    some modules get deprecated and removed as newer releases of Ansible are produced,
    and new ones get added.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever you are looking to upgrade your Ansible installation, it is advisable
    to review the porting guides that are produced by Ansible for each release since
    2.0\. They can be found here: [https://docs.ansible.com/ansible/devel/porting_guides/porting_guides.html](https://docs.ansible.com/ansible/devel/porting_guides/porting_guides.html).'
  prefs: []
  type: TYPE_NORMAL
- en: As for the example we started this chapter off with, you may very well find
    that your code needs no modifications at all. However, it is always best to plan
    your upgrade rather than simply hope for the best, only to hit some unexpected
    behavior that breaks your automation code.
  prefs: []
  type: TYPE_NORMAL
- en: It is hoped that this section on playbook porting has shown you how to handle
    the introduction of collections in your playbooks, and given you some pointers
    about where to look for guidance when you upgrade Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the last release of this book, there have been many changes to Ansible,
    but the most notable (which is expected to impact everyone reading this book)
    is the introduction of collections to manage modules, roles, plugins, and more,
    and decoupling them from the core release of Ansible. Probably the most noticeable
    change to Ansible code is in the introduction of FQCNs and the need to install
    collections if they are not part of the Ansible 4.3 package.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned about the reasons for the introduction of collections
    in Ansible, and how they impact everything from your playbook code to the way
    you install, maintain, and upgrade Ansible itself. You learned that collections
    are easy to build from scratch, and even how to build your own, before looking
    at ways to install and manage collections for your playbook. Finally, you learned
    the fundamentals of porting your Ansible code from earlier releases.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to secure secret data while working
    with Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Collections can contain:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Roles
  prefs: []
  type: TYPE_NORMAL
- en: b) Modules
  prefs: []
  type: TYPE_NORMAL
- en: c) Plugins
  prefs: []
  type: TYPE_NORMAL
- en: d) All of the above
  prefs: []
  type: TYPE_NORMAL
- en: Collections mean that Ansible Module versioning is independent of the version
    of the Ansible engine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) True
  prefs: []
  type: TYPE_NORMAL
- en: b) False
  prefs: []
  type: TYPE_NORMAL
- en: 'The Ansible 4.3 package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) includes the Ansible automation engine.
  prefs: []
  type: TYPE_NORMAL
- en: b) has a dependency on the Ansible automation engine.
  prefs: []
  type: TYPE_NORMAL
- en: c) bears no relation to the Ansible automation engine.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to upgrade directly from Ansible 2.9 to Ansible 4.3.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) True
  prefs: []
  type: TYPE_NORMAL
- en: b) False
  prefs: []
  type: TYPE_NORMAL
- en: In Ansible 4.3, module names are guaranteed to be unique between different namespaces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) True
  prefs: []
  type: TYPE_NORMAL
- en: b) False
  prefs: []
  type: TYPE_NORMAL
- en: To ensure that you always access the correct module you intend, you should start
    using which of the following now in your tasks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Fully Qualified Domain Names
  prefs: []
  type: TYPE_NORMAL
- en: b) Short form module names
  prefs: []
  type: TYPE_NORMAL
- en: c) Fully Qualified Collection Names
  prefs: []
  type: TYPE_NORMAL
- en: d) None of the above
  prefs: []
  type: TYPE_NORMAL
- en: Which file can be used to list all the required Collections from Ansible Galaxy,
    ensuring they can easily be installed when needed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) `site.yml`
  prefs: []
  type: TYPE_NORMAL
- en: b) `ansible.cfg`
  prefs: []
  type: TYPE_NORMAL
- en: c) `collections.yml`
  prefs: []
  type: TYPE_NORMAL
- en: d) `requirements.yml`
  prefs: []
  type: TYPE_NORMAL
- en: 'When you create an account on Ansible Galaxy for the purposes of contributing
    your own Collections, your namespace is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) randomly generated.
  prefs: []
  type: TYPE_NORMAL
- en: b) chosen by you.
  prefs: []
  type: TYPE_NORMAL
- en: c) automatically generated based on your GitHub user ID.
  prefs: []
  type: TYPE_NORMAL
- en: Collections are stored in which common file format?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) `.tar.gz`
  prefs: []
  type: TYPE_NORMAL
- en: b) `.zip`
  prefs: []
  type: TYPE_NORMAL
- en: c) `.rar`
  prefs: []
  type: TYPE_NORMAL
- en: d) `.rpm`
  prefs: []
  type: TYPE_NORMAL
- en: How could you list all the Collections installed with your Ansible package?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) `ansible --list-collections`
  prefs: []
  type: TYPE_NORMAL
- en: b) `ansible-doc -l`
  prefs: []
  type: TYPE_NORMAL
- en: c) `ansible-galaxy --list-collections`
  prefs: []
  type: TYPE_NORMAL
- en: d) `ansible-galaxy collections list`
  prefs: []
  type: TYPE_NORMAL
