- en: Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ allows you to create your own types. These custom types can have operators
    and can be converted to other types; indeed, they can be used like built-in types
    with the behavior that you define. This facility uses a language feature called
    classes. The advantage of being able to define your own types is that you can
    encapsulate data in objects of your chosen type, and use the type to manage the
    lifetime of that data. You can also define the actions that can be performed on
    that data. In other words, you are able to define custom types that have state
    and behavior, which is the basis of object-orientated programming.
  prefs: []
  type: TYPE_NORMAL
- en: Writing classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you use built-in types, the data is directly available to whatever code
    has access to that data. C++ provides a mechanism (`const`) to prevent write access,
    but any code can use `const_cast` to cast away `const`-ness. Your data could be
    complex, such as a pointer to a file mapped into memory with the intention that
    your code will change a few bytes and then write the file back to disk. Such raw
    pointers are dangerous because other code with access to the pointer could change
    part of the buffer that should not be changed. What is needed is a mechanism to
    encapsulate the data into a type that knows what bytes to change, and only allow
    that type to access the data. This is the basic idea behind classes.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already seen one mechanism in C++ to encapsulate data: `struct`. A
    structure allows you to declare data members that are built-in types, pointers,
    or references. When you create a variable from that `struct`, you are creating
    an **instance** of the structure, also known as an **object**. You can create
    variables that are references to this object or pointers that point to the object.
    You can even pass the object by value to a function where the compiler will make
    a copy of the object (it will call the *copy constructor* for the `struct`). We
    have seen that with a `struct` any code that has access to an instance (even through
    a pointer or reference) can access the members of the object (although this can
    be changed). Used like this, aÂ `struct` can be thought of as **aggregate** types
    containing the state.'
  prefs: []
  type: TYPE_NORMAL
- en: The members of an instance of a `struct` can be initialized by accessing them
    directly with the dot operator or using the `->` operator through a pointer to
    the object. We have also seen that you can initialize an instance of a `struct`
    with an initializer list (in braces). This is quite restrictive because the initializer
    list has to match the data members in the `struct`. In [Chapter 4](63ba5350-63d3-4dff-9ba2-b330f041d670.xhtml),
    *Working with Memory, Arrays, and Pointers*, you saw that you can have a pointer
    as a member of a `struct`, but you have to explicitly take appropriate action
    to release the memory pointed to by the pointer; if you don't, then this could
    result in a memory leak.
  prefs: []
  type: TYPE_NORMAL
- en: A `struct` is one of the class types that you can use in C++; the other two
    are `union` and `class`. Custom types defined as `struct` or `class` can have
    behaviors as well as state, and C++ allows you to define some special functions
    to control how instances are created and destroyed, copied, and converted. Furthermore,
    you can define operators on a `struct` or `class` type so that you can use the
    operators on instances in a similar way to using the operators on built-in types.
    There is a difference between `struct` and `class` which we will address later,
    but in general the rest of the chapter will be about classes and when a `class`
    is mentioned you can usually assume the same applies to a `struct` as well.
  prefs: []
  type: TYPE_NORMAL
- en: Defining classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A class is defined in a statement, and it will define its members in a block
    with multiple statements enclosed by braces `{}`. As it's a statement, you have
    to place a semicolon after the last brace. A class can be defined in a header
    file (as are many of the **C++ Standard Library** classes), but you have to take
    steps to ensure that such files are included only once in a source file. [Chapter
    1](318b7b93-7e5a-437b-95b3-9b6178ece82c.xhtml), *Starting with C++*, describes
    how to do this with `#pragma once`, conditional compilation, and precompiled header
    files. There are, however, some rules about specific items in a class that must
    be defined in a source file, which will be covered later.
  prefs: []
  type: TYPE_NORMAL
- en: If you peruse the C++ Standard Library, you will see that classes contain member
    functions and, in an attempt to put all the code for a class into a single header
    file, this makes the code difficult to read and difficult to understand. This
    may be justifiable for a library file maintained by a legion of expert C++ programmers,
    but for your own projects readability should be a key design goal. For this reason,
    a C++ class can be declared in a C++ header file, including its member functions,
    and the actual implementation of the functions can be placed in a source file.
    This makes the header files easier to maintain and more reusable.
  prefs: []
  type: TYPE_NORMAL
- en: Defining class behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A class can define functions that can only be called through an instance of
    the class; such a function is often called a **method**. An object will have state;
    this is provided by the data members defined by the class and initialized when
    the object is created. The methods on an object define the behavior of the object,
    usually acting upon the state of the object. When you design a class, you should
    think of the methods in this way: they describe the object doing something.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This class has two data members, `x` and `y`, which represent the direction
    of a two-dimensional vector resolved in the Cartesian x and y directions. The
    `public` keyword means that any members defined after this specifier are accessible
    by code defined outside of the class. By default, all the members of a class are
    `private` unless you indicate otherwise. Such access specifiers will be covered
    in more depth in the next chapter, but `private` means that the member can only
    be accessed by other members of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the difference between a `struct` and a `class`: by default, members
    of a `struct` are `public` and by default, members of a `class` are `private`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This class has a method called `get_magnituide` that will return the length
    of the Cartesian vector. This function acts upon the two data members of the class
    and returns a value. This is a type of **accessor** method; it gives access to
    the state of the object. Such a method is typical on a `class`, but there is no
    requirement that methods return values. Like functions, a method can also take
    parameters. The `get_magnituide` method can be called like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here a `cartesian_vector` object is created on the stack and list initializer
    syntax is used to initialize it to a value representing a vector of `(3,4)`. The
    length of this vector is 5, which is the value returned by calling `get_magnitude`
    on the object.
  prefs: []
  type: TYPE_NORMAL
- en: Using the this pointer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The methods in a class have a special calling convention, which in Visual C++
    is called `__thiscall`. The reason is that every method in a class has a hidden
    parameter called `this`, which is a pointer of the class type to the current instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `get_magnitude` method returns the length of the `cartesian_vector`
    object. The members of the object are accessed through the `->` operator. As shown
    previously, the members of the class can be accessed without the `this` pointer,
    but it does make it explicit that the items are members of the `class`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could define a method on the `cartesian_vector` type that allows you to
    change its state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The parameters of the `reset` method have the same names as the data members
    of the class; however, since we use the `this` pointer the compiler knows that
    this is not ambiguous.
  prefs: []
  type: TYPE_NORMAL
- en: You can dereference the `this` pointer with the `*` operator to get access to
    the object. This is useful when a member function must return a reference to the
    current object (as some operators will, as we will see later) and you can do this
    by returning `*this`. A method in a class can also pass the `this` pointer to
    an external function, which means that it is passing the current object by reference
    through a typed pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Using the scope resolution operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can define a method inline in the `class` statement, but you can also separate
    the declaration and implementation, so the method is declared in the `class` statement
    but it is defined elsewhere. When defining a method out of the `class` statement,
    you need to provide the method with the name of the type using the scope resolution
    operator. For example, using the previous `cartesian_vector` example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The method is defined outside the class definition; it is, however, still the
    class method, so it has a `this` pointer that can be used to access the object's
    members. Typically, the class will be declared in a header file with prototypes
    for the methods and the actual methods will be implemented in a separate source
    file. In this case, using the `this` pointer to access the class members (methods
    and data members) make it obvious, when you take a cursory look at a source file,
    that the functions are methods of a class.
  prefs: []
  type: TYPE_NORMAL
- en: Defining class state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your class can have built-in types as data members, or custom types. These data
    members can be declared in the class (and created when an instance of the class
    is constructed), or they can be pointers to objects created in the free store
    or references to objects created elsewhere. Bear in mind that if you have a pointer
    to an item created in the free store, you need to know whose responsibility it
    is to deallocate the memory that the pointer points to. If you have a reference
    (or pointer) to an object created on a stack frame somewhere, you need to make
    sure that the objects of your class do not live longer than that stack frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you declare data members as `public` it means that external code can read
    and write to the data members. You can decide that you would prefer to only give
    read-only access, in which case you can make the members `private` and provide
    read access through accessors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When you make the data members `private` it means that you cannot use the initializer
    list syntax to initialize an object, but we will address this later. You may decide
    to use an accessor to give write access to a data member and use this to check
    the value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is for a type where the range of values must be between (but not including)
    -`100` and `100`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can create objects on the stack or in the free store. Using the previous
    example, this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is **direct initialization** of the object and assumes that the data members
    of `cartesian_vector` are `public`. The `vec` object is created on the stack and
    initialized with an initializer list. In the second line, an object is created
    in the free store and initialized with an initializer list. The object on the
    free store must be freed at some point and this is carried out by deleting the
    pointer. The `new` operator will allocate enough memory in the free store for
    the data members of the class and for any of the infrastructure the class needs
    (as described in the next chapter).
  prefs: []
  type: TYPE_NORMAL
- en: 'A new feature of C++11 is to allow direct initialization to provide default
    values in the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that if you create an instance of `point` without any other initialization
    values, it will be initialized so that `x` and `y` are both zero. If the data
    member is a built-in array, then you can provide direct initialization with an
    initialization list in the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The C++ Standard Library containers can be initialized with an initialize list,
    so, in this class for `tire_pressures`, instead of declaring the type to be `double[4]`
    we could use `vector<double>` or `array<double,4>`, and initialize it in the same
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Construction of objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C++ allows you to define special methods to perform the initialization of the
    object. These are called **constructors**. In C++11, you will get three such functions
    generated for you by default, but you can provide your own versions if you wish.
    These three constructors, along with three other related functions, are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Default constructor:**Â This is called to create an object with the *default*
    value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Copy constructor:**Â This is used to create a new object based on the value
    of an existing object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Move constructor:**Â This is used to create a new object using the data moved
    from an existing object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Destructor:**Â This is called to clean up the resources used by an object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Copy assignment:**Â This copies the data from one existing object into another
    existing object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Move assignment:**Â This moves the data from one existing object into another
    existing object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The compiler-created versions of these functions will be implicitly `public`;
    however, you may decide to prevent copying or assigning by defining your own versions,
    and making them `private`, or you can delete them using the `=delete` syntax.
    You can also provide your own constructors that will take any parameters you decide
    you need to initialize a new object.
  prefs: []
  type: TYPE_NORMAL
- en: A constructor is a member function that has the same name as the type, but does
    not return a value, so you cannot return a value if the construction fails, which
    potentially means that the caller will receive a partially constructed object.
    The only way to handle this situation is to throw an exception (explained in [Chapter
    10](5a2f36d4-7d0b-4f2d-ae7c-f9e51f5d7dc4.xhtml), *Diagnostics andÂ Debugging*).
  prefs: []
  type: TYPE_NORMAL
- en: Defining constructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The default constructor is used when an object is created without a value and
    hence the object will have to be initialized with a default value. The `point`
    declared previously could be implemented like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This explicitly initializes the items to a value of zero. If you want to create
    an instance with the default values, you do not include parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important to be aware of this syntax because it is easy to write the
    following by mistake:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This will compile because the compiler will think you are providing a function
    prototype as a forward declaration. However, you''ll get an error when you attempt
    to use the symbol `p` as a variable. You can also call the default constructor
    using initialize list syntax with empty braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Although it does not matter in this case, where the data members are built-in
    types, initializing data members in the body of the constructor like this involves
    a call to the assignment operator of the member type. A more efficient way is
    to use direct initialization with a **member list**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a constructor that takes two parameters, which illustrates
    a member list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The identifiers outside the parentheses are the names of class members, and
    the items inside the parentheses are expressions used to initialize that member
    (in this case, a constructor parameter). This example uses `x` and `y` for the
    parameter names. You don''t have to do this; this is only given here as an illustration
    that the compiler will distinguish between the parameters and data members. You
    can also use braced initializer syntax in the member list of a constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You call this constructor when you create an object like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also create an array of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This creates four `point` objects, which can be accessed by indexing the `arr`
    array. Note that when you create an array of objects the *default* constructor
    is called on the items; there is no way to call any other constructor, and so
    you have to initialize each one separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also provide default values for constructor parameters. In the following
    code, the `car` class has values for the four tires (the first two are the front
    tires) and for the spare tire. There is one constructor that has mandatory values
    that will be used for the front and back tires, and an optional value for the
    spare. If a value is not provided for the spare tire pressure, then a default
    value will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This constructor can be called with either two values or three values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Delegating constructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A constructor may call another constructor using the same member list syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, the constructor that takes one value delegates to the constructor that
    takes three parameters (in this case using the default value for the spare).
  prefs: []
  type: TYPE_NORMAL
- en: Copy constructor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A copy constructor is used when you pass an object by value (or return by value)
    or if you explicitly construct an object based on another object. The last two
    lines of the following both create a `point` object from another `point` object,
    and in both cases the copy constructor is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The last line looks like it involves the assignment operator, but it actually
    calls the copy constructor. The copy constructor could be implemented like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The initialization accesses the `private` data members on another object (`rhs`).
    This is acceptable because the constructor parameter is the same type as the object
    being created. The copy operation may not be as simple as this. For example, if
    the class contains a data member that is a pointer, you will most likely want
    to copy the data that the pointer points to, and this will involve creating a
    new memory buffer in the new object.
  prefs: []
  type: TYPE_NORMAL
- en: Converting between types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can also perform conversions. In math, you can define a vector that represents
    direction, so that the line drawn between two points is a vector. In our code
    we have already defined a `point` class and a `cartesian_vector` class. You could
    decide to have a constructor that creates a vector between the origin and a point,
    in which case you are converting a `point` object to a `cartesian_vector` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a problem here, which we will address in a moment. The conversions
    can be called like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Making friends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The problem with the code above is that the `cartesian_vector` class accesses
    `private` members of the `point` class. Since we have written both classes, we
    are happy to bend the rules, and so we make the `cartesian_vector` class a `friend`
    of the `point` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Since the `cartesian_vector` class is declared after the `point` class, we have
    to provide a forward declaration that essentially tells the compiler that the
    name `cartesian_vector` is about to be used and it will be declared elsewhere.
    The important line starts with `friend`. This indicates that the code for the
    entire class, `cartesian_vector`, can have access to the private members (data
    and methods) of the `point` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also declare `friend` functions. For example, you could declare an
    operator such that a `point` object can be inserted into the `cout` object, so
    it can be printed to the console. You cannot change the `ostream` class, but you
    can define a global method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This function accesses the `private` members of `point` so you have to make
    the function a `friend` of the `point` class with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Such `friend` declarations have to be declared in the `point` class, but it
    is irrelevant whether it is put in the `public` or `private` section.
  prefs: []
  type: TYPE_NORMAL
- en: Marking constructors as explicit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In some cases, you do not want to allow the implicit conversion between one
    type that is passed as a parameter of the constructor of another type. To do this,
    you need to mark the constructor with the `explicit` specifier. This now means
    that the only way to call the constructor is using the parentheses syntax: *explicitly*
    calling the constructor. In the following code, you cannot implicitly convert
    a `double` to an object of `mytype`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you have to *explicitly* call the constructor if you want to create an
    object with a `double` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Destructing objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When an object is destroyed, a special method called the destructor is called.
    This method has the name of the class prefixed with a `~` symbol and it does not
    return a value.
  prefs: []
  type: TYPE_NORMAL
- en: If the object is an automatic variable, on the stack, then it will be destroyed
    when the variable goes out of scope. When an object is passed by value, a copy
    is made on the called function's stack and the object will be destroyed when the
    called function completes. Furthermore, it does not matter how the function completes,
    whether an explicit call to `return` or reaching the final brace, or if an exception
    is thrown; in all of these cases, the destructor is called. If there are multiple
    objects in a function, the destructors are called in the reverse order to the
    construction of the objects in the same scope. If you create an array of objects,
    then the default constructor is called for each object in the array on the statement
    that declares the array, and all the objects will be destroyed--and the destructor
    on each one is called, when the array goes out of scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples, for a class `mytype`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'An interesting action occurs when you return an object. The following annotation
    is what you would expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, the process is more streamlined. In a debug build, the compiler will
    see that the temporary object created on the return of the `get_object` function
    is the object that will be used as the variable `tt`, and so there is no extra
    copy on the return value of the `get_object` function. The function actually looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: However, the compiler is able to optimize the code further. In a release build
    (with optimizations enabled), the temporary will not be created and the object
    `tt` in the calling function will be the actual object `t` created in `get_object`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An object will be destroyed when you explicitly delete a pointer to an object
    allocated on the free store. In this case, the call to the destructor is deterministic:
    it is called when your code calls `delete`. Again, with the same class `mytype`,
    this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: There will be times when you want to use the deterministic aspect of deleting
    an object (with the possible danger of forgetting to call `delete`) and there
    will be times when you prefer to have the reassurance that an object is to be
    destroyed at an appropriate time (with the potential that it may be much later
    in time).
  prefs: []
  type: TYPE_NORMAL
- en: If a data member in a class is a custom type with a destructor, then when the
    containing object is destroyed the destructors on the contained objects are called
    too. Nonetheless, note that this is only if the *object* is a class member. If
    a class member is a pointer to an object in the free store, then you have to explicitly
    delete the pointer in the containing object's destructor. However, you need to
    know where the object the pointer points to is because if it is not in the free
    store, or if the object is used by other objects, calling `delete` will cause
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The assignment operator is called when an *already created* object is assigned
    to the value of another one. By default, you will get a copy assignment operator
    that will copy all the data members. This is not necessarily what you want, particularly
    if the object has a data member that is a pointer, in which case your intention
    is more likely to do a deep copy and copy the data pointed to rather than the
    value of the pointer (in the latter case,Â *two* objects will point to the same
    data).
  prefs: []
  type: TYPE_NORMAL
- en: If you define a copy constructor, you will still get the default copy assignment
    operator; however, it makes sense that if you regard it important to write your
    own copy constructor, you should also provide a custom copy assignment operator.
    (Similarly, if you define a copy assignment operator, you will get the default
    copy constructor unless you define it.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The copy assignment operator is typically a `public` member of the class and
    it takes a `const` reference to the object that will be used to provide the values
    for the assignment. The semantics of the assignment operator are that you can
    chain them, so, for example, this code calls the assignment operator on two of
    the objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The last two lines do the same thing, but clearly the first is more readable.
    To enable these semantics, the assignment operator must return a reference to
    the object that has been assigned. So, the class `buffer` will have the following
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Although the copy constructor and copy assignment methods appear to do similar
    things, there is a key difference. A copy constructor creates a new object that
    did not exist before the call. The calling code is aware that if the construction
    fails, then an exception will be raised. With assignment, both objects already
    exist, so you are copying the value from one object to another. This should be
    treated as an atomic action and all the copy should be performed; it is not acceptable
    for the assignment to fail halfway through, resulting in an object that is a bit
    of both objects. Furthermore, in construction, an object only exists after the
    construction is successful, so a copy construction cannot happen on an object
    itself, but it is perfectly legal (if pointless) for code to assign an object
    to itself. The copy assignment needs to check for this situation and take appropriate
    action.
  prefs: []
  type: TYPE_NORMAL
- en: There are various strategies to do this, and a common one is called the copy-and-swap
    idiom because it uses the Standard Library `swap` function that is marked as `noexcept`,
    and will not throw an exception. The idiom involves creating a temporary copy
    of the object on the right-hand side of the assignment and then swapping its data
    members with the data members of the object on the left-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: Move semantics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++11 provides move semantics through a move constructor and a move assignment
    operator, which are called when a temporary object is used either to create another
    object or to be assigned to an existing object. In both cases, because the temporary
    object will not live beyond the statement, the contents of the temporary can be
    moved to the other object, leaving the temporary object in an invalid state. The
    compiler will create these functions for you through the default action of moving
    the data from the temporary to the newly created (or the assigned to) object.
  prefs: []
  type: TYPE_NORMAL
- en: You can write your own versions, and to indicate move semantics these have a
    parameter that is an rvalue reference (`&&`).
  prefs: []
  type: TYPE_NORMAL
- en: If you want the compiler to provide you with a default version of any of these
    methods, you can provide the prototype in the class declaration suffixed with
    `=default`. In most cases, this is self-documenting rather than being a requirement,
    but if you are writing a POD class you must use the default versions of these
    functions, otherwise `is_pod` will not return `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to use only move and never to use copy (for example, a file handle
    class), then you can *delete* the copy functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This class has a pointer data member and allows move semantics, in which case
    the move constructor will be called with a reference to a temporary object. Since
    the object is temporary, it will not survive after the move constructor call.
    This means that the new object can *move* the state of the temporary object into
    itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The move constructor assigns the temporary object's pointer to `nullptr`, so
    that any destructor defined for the class does not attempt to delete the pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring static members
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can declare a member of a class--a data member or a method--`static`. This
    is similar in some ways to how you use the `static` keyword on automatic variables
    and functions declared at file scope, but there are some important, and different,
    properties to this keyword when used on a class member.
  prefs: []
  type: TYPE_NORMAL
- en: Defining static members
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you use `static` on a class member it means that the item is associated
    with the class and not with a specific instance. In the case, of data members,
    this means that there is one data item shared by all instances of the class. Likewise,
    a `static` method is not attached to an object, it is not `__thiscall` and has
    no `this` pointer.
  prefs: []
  type: TYPE_NORMAL
- en: A `static` method is part of the namespace of a class, so it can create objects
    for the class and have access to their `private` members. A `static` method has
    the `__cdecl` calling convention by default, but you can declare it as `__stdcall`
    if you wish. This means that, you can write a method within the class that can
    be used to initialize C-like pointers, which are used by many libraries. Note
    that the `static` function cannot call nonstatic methods on the class because
    a nonstatic method will need a `this` pointer, but a nonstatic method can call
    a `static` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'A nonstatic method is called through an object, either using the dot operator
    (for a class instance) or the `->` operator for an object pointer. A `static`
    method does not need an associated object, but it can be called through one. This
    gives two ways to call a `static` method, through an object or through the `class`
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the class defines a `static` method called `f` and a nonstatic method
    called `g`. The nonstatic method `g` can call the `static` method, but the `static`
    method `f` cannot call the nonstatic method. Since the `static` method `f` is
    `public`, code outside the `class` can call it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Although the `static` function can be called through an object, you do not have
    to create any objects at all to call it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Static data members need a bit more work because when you use `static` it indicates
    that the data member is not part of an object, and usually data members are allocated
    when an object is created. You have to define `static` data members outside of
    the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The data member is defined outside of the class at file scope. It is named using
    the `class` name, but note that it also has to be defined using the type. In this
    case the data member is initialized with a value; if you do not do this, then
    on the first use of the variable it will have the default value of the type (in
    this case, zero). If you choose to declare the class in a header file (which is
    common), the definition of the `static` data members must be in a source file.
  prefs: []
  type: TYPE_NORMAL
- en: You can also declare a variable in a method that is `static`. In this case,
    the value is maintained across method calls, in all objects, so it has the same
    effect as a `static class` member, but you do not have the issue of defining the
    variable outside of the class.
  prefs: []
  type: TYPE_NORMAL
- en: Using static and global objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `static` variable in a global function will be created at some point before
    the function is first called. Similarly, a `static` object that is a member of
    a class will be initialized at some point before it is first accessed.
  prefs: []
  type: TYPE_NORMAL
- en: Static and global objects are constructed before the `main` function is called,
    and destroyed after the `main` function finishes. The order of this initialization
    has some issues. The C++ standard says that the initialization of `static` and
    global objects defined in a source file will occur before any function or object
    defined in that source file is used, and if there are several global objects in
    a source file, they will be initialized in the order that they are *defined*.
    The issue is if you have several source files with `static` objects in each. There
    is no guarantee on the order in which these objects will be initialized. It becomes
    a problem if one `static` object depends on another `static` object because you
    cannot guarantee that the dependent object will be created after the object it
    depends upon.
  prefs: []
  type: TYPE_NORMAL
- en: Named constructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is one application for `public static` methods. The idea is that since
    the `static` method is a member of the `class` it means that it has access to
    the `private` members of an instance of the `class`, so such a method can create
    an object, perform some additional initialization, and then return the object
    to the caller. This is a **factory method**. The `point` class used so far has
    been constructed using Cartesian points, but we could also create a point based
    on polar co-ordinates, where the `(x, y)` Cartesian co-ordinates can be calculated
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Here `r` is the length of the vector to the point and `theta` is the angle
    of this vector counter-clockwise to the x axis. The `point` class already has
    a constructor that takes two `double` values, so we cannot use this to pass polar
    co-ordinates; instead, we can use a `static` method as a *named constructor*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The method can be called like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The object `p11` is the `point` with the Cartesian co-ordinates of (1,1). In
    this example the `polar` method calls a `public` constructor, but it has access
    to private members, so the same method could be written (less efficiently) as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Nested classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can define a class within a class. If the nested class is declared as `public`,
    then you can create objects in the container class and return them to external
    code. Typically, however, you will want to declare a class that is used by the
    class and should be `private`. The following declares a `public` nested class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the name of the nested class is prefixed with the name of the containing
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing const objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have seen many examples so far of using `const`, and perhaps the most frequent
    is when it is applied to a reference as a function parameter to indicate to the
    compiler that the function only has read-only access to the object. Such a `const`
    reference is used so that objects are passed by reference to avoid the overhead
    of the copying that would occur if the object were passed by value. Methods on
    a `class` can access the object data members and, potentially, can change them,
    so if you pass an object through a `const` reference the compiler will only allow
    the reference to call methods that do not change the object. The `point` class
    defined earlier had two accessors to access the data in the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If you define a function that takes a `const` reference to this and you attempt
    to call these accessors, you will get an error from the compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The error from the compiler is a bit obscure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This message is the compiler complaining that the object is `const`, it is
    immutable, and it does not know whether these methods will preserve the state
    of the object. The solution is simple--add the `const` keyword to methods that
    do not change the object state, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This effectively means that the `this` pointer is `const`. The `const` keyword
    is part of the function prototype, so the method can be overloaded on this. You
    can have one method that is called when it is called on a `const` object and another
    called on a non-const object. This enables you to implement a copy-on-write pattern
    where, for example, a `const` method would return read-only access to the data
    and the non-const method would return a *copy* of the data that is writeable.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, a method marked with `const` must not alter the data members, not
    even temporarily. So, such a method can only call `const` methods. There may be
    rare cases when a data member is designed to be changed through a `const` object;
    in this case the declaration of the member is marked with the `mutable` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Using objects with pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Objects can be created on the free store and accessed through a typed pointer.
    This gives more flexibility because it is efficient to pass pointers to functions,
    and you can explicitly determine the lifetime of the object because an object
    is created with the call to `new` and destroyed by the call to `delete`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting pointers to object members
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you need to get access to the address of a class data member through an
    instance (assuming the data member is `public`), you simply use the `&` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In this case `struct` is used to declare `point` so that the members are `public`
    by default. The second line uses an initialization list to construct a `point`
    object with two values, and then the final line gets a pointer to one of the data
    members. Of course, the pointer cannot be used after the object has been destroyed.
    Data members are allocated in memory (in this case on the stack), so the address
    operator merely gets a pointer to that memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Function pointers are a different case. There will only be one copy of the
    method in memory, regardless of how many instances of the `class` are created,
    but because methods are called using the `__thiscall` calling convention (with
    a hidden `this` parameter) you have to have a function pointer that can be initialized
    with a pointer to an object to provide the `this` pointer. Consider this `class`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We can define a function pointer to the `get_magnitude` method like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line declares a function pointer. This is similar to the C function
    pointer declarations except that there is an inclusion of the `class` name in
    the pointer type. This is needed so that the compiler knows that it has to provide
    a `this` pointer in any call through this pointer. The second line obtains a pointer
    to the method. Notice that no object is involved. You are not getting a function
    pointer to a method on an object; you are getting a pointer to a method on a `class`
    that must be called through an object. To call the method through this pointer,
    you need to use the pointer to the member operator `.*` on an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line creates an object and the second line calls the method. The
    pointer to the member operator says that the function pointer on the *right* is
    called with the object on the *left*. The address of the object on the left is
    used for the `this` pointer when the method is called. As this is a method, we
    need to provide a parameter list, which in this case is empty (if you have parameters,
    they would be in the pair of parentheses on the right of this statement). If you
    have an object pointer, then the syntax is similar, but you use the `->*` pointer
    to the member operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Operator overloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of behaviors of a type is the operations you can apply to it. C++ allows
    you to overload the C++ operators as part of a class so that it''s clear that
    the operator is acting upon the type. This means that for a unary operator the
    member method should have no parameters and for a binary operator you need only
    one parameter, since the current object will be on the left of the operator, and
    hence the method parameter is the item on the right. The following table summarizes
    how to implement unary and binary operators, and four exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** | **Name** | **Member method** | **Non-member function** |'
  prefs: []
  type: TYPE_TB
- en: '| +a/-a | Prefix unary | operator() | operator(a) |'
  prefs: []
  type: TYPE_TB
- en: '| a, b | Binary | operator(b) | operator(a,b) |'
  prefs: []
  type: TYPE_TB
- en: '| a+/a- | Postfix unary | operator(0) | operator(a,0) |'
  prefs: []
  type: TYPE_TB
- en: '| a=b | Assignment | operator=(b) |  |'
  prefs: []
  type: TYPE_TB
- en: '| a(b) | Function call | operator()(b) |  |'
  prefs: []
  type: TYPE_TB
- en: '| a[b] | Indexing | operator[](b) |  |'
  prefs: []
  type: TYPE_TB
- en: '| a-> | Pointer access | operator->() |  |'
  prefs: []
  type: TYPE_TB
- en: Here the â  symbol is used to indicate any of the acceptable unary or binary
    operators except for the four operators mentioned in the table.
  prefs: []
  type: TYPE_NORMAL
- en: There are no strict rules over what an operator should return, but it helps
    if an operator on a custom type behaves like operators on a built-in type. There
    also has to be some consistency. If you implement the `+` operator to add two
    objects together, then the same plus action should be used for the `+=` operator.
    Also, you could argue that the plus action will also determine what the minus
    action should be like, and hence the `-` and `-=` operators. Similarly, if you
    want to define the `<` operator, then you should define `<=. >`, `>=`, `==`, and
    `!=` too.
  prefs: []
  type: TYPE_NORMAL
- en: The Standard Library's algorithms (for example, `sort`) will only expect the
    `<` operator to be defined on a custom type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The table shows that you can implement almost all the operators as either a
    member of the custom type class or as a global function (with the exception of
    the four listed that have to be member methods). In general, it is best to implement
    the operator as part of the class because it maintains encapsulation: the member
    function has access to the non-public members of the class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a unary operator is the unary negative operator. This usually
    does not alter an object but returns a new object that is the *negative* of the
    object. For our `point class`, this means making both co-ordinates negative, which
    is equivalent to a mirror of the Cartesian point in a line *y = -x*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The operator is declared as `const` because it''s clear the operator does not
    change the object and hence it''s safe to be called on a `const` object. The operator
    can be called like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: To understand why we have implemented the operator like this, review what the
    unary operator would do when applied to a built-in type. The second statement
    here, `int i, j=0; i = -j;`, will only alter `i` and will not alter `j`, so the
    member `operator-` should not affect the value of the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The binary negative operator has a different meaning. First, it has two operands,
    and, second, in this example, the result is a different type to the operands because
    the result is a vector that indicates a direction by taking one point away from
    another. Assuming that the `cartesian_vector` is already defined with a constructor
    that has two parameters, then we can write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The increment and decrement operators have a special syntax because they are
    unary operators that can be prefixed or postfixed, and they alter the object they
    are applied to. The major difference between the two operators is that the postfixed
    operator returns the value of the object *before* the increment/decrement action,
    so a temporary has to be created. For this reason, the prefix operator almost
    always has better performance than the postfix operator. In a class definition,
    to distinguish between the two, the prefix operator has no parameters and the
    postfix operator has a dummy parameter (in the preceding table, 0 is given). For
    a class `mytype`, this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The actual increment code is implemented by the prefix operator, and this logic
    is used by the postfix operator through an explicit call to the method.
  prefs: []
  type: TYPE_NORMAL
- en: Defining function classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A functor is a class that implements the `()` operator. This means that you
    can call an object using the same syntax as a function. Consider this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This code can be called like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'This code shows that the functor object not only provides some behavior (in
    this case, performing an action on the parameter) but it also can have a state.
    The preceding two lines are called through the `operator()` method on an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Look at the syntax. The functor object is called as if it is a function declared
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Imagine that you want to pass a pointer to a function--perhaps you are want
    the function''s behavior to be altered by external code. To be able to use either
    a functor or a method pointer, you need to overload your function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The first takes a reference to a functor object. The second has a C-type function
    pointer (to which you can pass a pointer to `multiply_by_3`) and is quite unreadable.
    In both cases the `fn` parameter is called in the same way in the implementation
    code, but you need to declare two functions because they are different types.
    Now, consider the magic of function templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This is generic code; the `Fn` type can be a C function pointer or a functor
    `class`, and the compiler will generate the appropriate code.
  prefs: []
  type: TYPE_NORMAL
- en: This code can be called by either passing a function pointer to a global function,
    which will have the `__cdecl` calling convention, or a functor object where the
    `operator()` operator will be called, which has a `__thiscall` calling convention.
  prefs: []
  type: TYPE_NORMAL
- en: This is a mere implementation detail, but it does mean that you can write a
    generic function that can take either a C-like function pointer or a functor object
    as a parameter. The C++ Standard Library uses this magic, which means that the
    algorithms it provides can be called either with a *global function* or a *functor*,
    or a *lambda expression*.
  prefs: []
  type: TYPE_NORMAL
- en: The Standard Library algorithms use three type of functional classes, generators,
    and unary and binary functions; that is, functions with zero, one or two parameters.
    In addition, the Standard Library calls a function object (unary or binary) that
    returns a `bool`Â **predicate**. The documentation will tell you if a predicate,
    unary, or binary function is needed. Older versions of the Standard Library needed
    to know the types of the return value and parameters (if any) of the function
    object to work, and, for this reason, functor classes had to be based upon the
    standard classes,Â `unary_function` and `binary_function` (through inheritance,
    explained in the next chapter). In C++11, this requirement has been removed, so
    there is no requirement to use these classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, you will want to use a binary functor when a unary functor is
    required. For example, the Standard Library defines the `greater` class that,
    when used as a function object, takes two parameters and a `bool` to determine
    whether the first parameter is greater than the second one, using the `operator>`
    defined by the type of both parameters. This will be used for functions that need
    a binary functor, and hence the function will compare two values; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'This takes two collections and compares corresponding items using the functor
    passed as the last parameter. It can be called like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The `greater` functor class is defined in the `<functional>` header and compares
    two numbers using the `operator>` defined for the type. What if you wanted to
    compare the items in a container with a fixed value; that is, when the `operator()(double,
    double)` method on the functor is called, one parameter always has a fixed value?
    One option is to define a stateful functor class (as shown previously) so that
    the fixed value is a member of the functor object. Another way to do this is to
    fill another `vector` with the fixed value and continue to compare two `vector`s
    (this can get quite expensive for large `vector`s).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way is to reuse the functor class, but to *bind* a value to one of
    its parameters. A version of the `compare_vals` function can be written like this,
    to take just one `vector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is written to call the functor parameter on just one value because
    it is assumed that the functor object contains the other value to compare. This
    is carried out by binding the functor class to the parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The `bind` function is variadic. The first parameter is the functor object and
    it is followed by the parameters that will be passed to the `operator()` method
    of the functor. The `compare_vals` function is passed a **binder** object that
    binds the functor to values. In the `compare_vals` function, the call to the functor
    in `compare(d[i])` is actually a call to the `operator()` method of the binder
    object, and this method forwards the parameter `d[i]` and the bound value to the
    `operator()` method of the functor.
  prefs: []
  type: TYPE_NORMAL
- en: In the call to `bind`, if an actual value is provided (here, `2.0`), then that
    value is passed to the functor at that position in the call to the functor (here,
    `2,0` is passed to the second parameter). If a symbol preceded by an underscore
    is used, then it is a **placeholder**. There are 20 such symbols (`_1` to `_20`)
    defined in the `std::placeholders` namespace. The placeholder means "use the value
    passed in this position to the binder object `operator()` method call to the functor
    call `operator()` method indicated by the placeholder." Thus, the placeholder
    in this call means "pass the first parameter from invoking the binder and pass
    it to the first parameter of the `greater` functor `operator()`."
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous code compares each item in the `vector` with `2.0` and will keep
    a count of those that are greater than `2.0`. You could invoke it this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The parameter list is swapped, and this means that `2.0` is compared with each
    item in the `vector` and the function will keep a count of how many times `2.0`
    is greater than the item.
  prefs: []
  type: TYPE_NORMAL
- en: The `bind` function, and placeholders, are new to C++11\. In prior versions
    you could use the `bind1st` and `bind2nd` functions to bind a value to either
    the first or second parameter of the functor.
  prefs: []
  type: TYPE_NORMAL
- en: Defining conversion operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already seen that a constructor can be used to convert from another
    type to your custom type if your custom type has a constructor that takes the
    type you are converting. You can also perform the conversion in the other direction:
    converting the object into another type. To do this, you provide an operator without
    a return type with the name of the type to convert to. In this case, you need
    a space between the `operator` keyword and the name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'This code can convert an `int` or a `string` to `mytype`; in the latter case,
    only through an explicit mention of the constructor. The last line allows you
    to convert an object back to an `int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: You can make such conversion operators `explicit` so that they will be called
    only when an explicit cast is used. In many cases, you will want to leave off
    this keyword because implicit conversions are useful when you want to wrap a resource
    in a class and use the destructor to do automatic resource management for you.
  prefs: []
  type: TYPE_NORMAL
- en: Another example of using a conversion operator is returning values from a stateful
    functor. The idea here is that the `operator()` will perform some action and the
    result is maintained by the functor. The issue is how do you obtain this state
    of the functor, especially when they are often created as temporary objects? A
    conversion operator can provide this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, when you calculate an average, you do it in two stages: the first
    stage is to accumulate the values and then the second stage is to calculate the
    average by dividing it by the number of items. The following functor class does
    this with the division performed as part of the conversion to a `double`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be called like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The `for_each` function calls the functor for every item in the `vector`, and
    the `operator()` simply sums the items passed to it and maintains a count. The
    interesting part is that after the `for_each` function has iterated over all of
    the items in the `vector` it returns the functor, and so there is an implicit
    conversion to a `double`, which calls the conversion operator that calculates
    the average.
  prefs: []
  type: TYPE_NORMAL
- en: Managing resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already seen one sort of resource that requires careful management:
    memory. You allocate memory with `new`, and when you have finished with the memory
    you must deallocate the memory with `delete`. A failure to deallocate the memory
    will cause a memory leak. Memory is, perhaps, the most fundamental of system resources,
    but most operating systems have many others: file handles, handles to graphic
    objects, synchronization objects, threads, and processes. Sometimes possession
    of such a resource is exclusive and will prevent other code from accessing the
    resource accessed through the resource. Thus, it is important that such resources
    are freed at some point, and, usually, that they are freed in a timely manner.'
  prefs: []
  type: TYPE_NORMAL
- en: Classes help here with a mechanism called **Resource Acquisition Is Initialization**
    (RAII) invented by Bjarne Stroustrup, the author of C++. Put simply, the resource
    is allocated in the constructor of an object and freed in the destructor, so it
    means that the lifetime of the resource is the lifetime of the object. Typically,
    such wrapper objects are allocated on the stack, and this means that you are guaranteed
    that the resource will be freed when the object goes out of scope *regardless
    of how this happens*.
  prefs: []
  type: TYPE_NORMAL
- en: So, if objects are declared in the code block for a looping statement (`while`,
    `for`), then at the end of each loop the destructor for each will be called (in
    reverse order of creation) and the object will be created again when the loop
    is repeated. This occurs whether the loop is repeated because the end of the code
    block has been reached or if the loop is repeated through a call to `continue`.
    Another way to leave a code block is through a call to `break`, a `goto`, or if
    the code calls `return` to leave the function. If the code raises an exception
    (see [Chapter 10](5a2f36d4-7d0b-4f2d-ae7c-f9e51f5d7dc4.xhtml), *Diagnostics andÂ Debugging*),
    the destructor will be called as the object goes out of scope, so if the code
    is guarded by a `try` block, the destructor of objects declared in the block will
    be called before the `catch` clause is called. If there is no guard block, then
    the destructor will be called before the function stack is destroyed and the exception
    propagated.
  prefs: []
  type: TYPE_NORMAL
- en: Writing wrapper classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several issues that you must address when writing a class to wrap
    a resource. The constructor will be used, either to obtain the resource using
    some library function (usually accessed through some kind of opaque handle) or
    will take the resource as a parameter. This resource is stored as a data member
    so other methods on the class can use it. The resource will be released in the
    destructor using whatever function your library provides to do this. This is the
    bare minimum. In addition, you have to think how the object will be used. Often
    such wrapper classes are most convenient if you can use instances as if they are
    the resource handle. This means that you maintain the same style of programming
    to access the resource, but you just don't have to worry too much about releasing
    the resource.
  prefs: []
  type: TYPE_NORMAL
- en: You should think about whether you want to be able convert between your wrapper
    class and the resource handle. If you do allow this, it means that you may have
    to think about cloning the resource, so that you do not have two copies of the
    handle--one that is managed by the class and the other copy that could be released
    by external code. You also need to think about whether you want to allow the object
    to be copied or assigned, and if so, then you will need to appropriately implement
    the copy constructor, a move constructor, and the copy and move assignment operators.
  prefs: []
  type: TYPE_NORMAL
- en: Using smart pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++ Standard Library provides several classes to wrap resources accessed
    through pointers. To prevent memory leaks, you have to ensure that memory allocated
    on the free store is freed at some point. The idea of a smart pointer is that
    you treat an instance as if it is the pointer, so you use the `*` operator to
    dereference to get access to the object it points to or use the `->` operator
    to access a member of the wrapped object. The smart pointer class will manage
    the lifetime of the pointer it wraps and will release the resource appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Standard Library has three smart pointer classes: `unique_ptr`, `shared_ptr`,
    and `weak_ptr`. Each handles how the resource is released in a different way,
    and how or whether you can copy a pointer.'
  prefs: []
  type: TYPE_NORMAL
- en: Managing exclusive ownership
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `unique_ptr` class is constructed with a pointer to the object it will maintain.
    This class provides the operator `*` to give access to the object, dereferencing
    the wrapped pointer. It also provides the `->` operator, so that if the pointer
    is for a class, you can access the members through the wrapped pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following allocates an object on the free store and manually maintains
    its lifetime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, you get a pointer to the memory on the free store allocated for
    an `int`. To access the memory--either to write to it or read from it--you dereference
    the pointer with the `*` operator. When you are finished with the pointer, you
    must call `delete` to deallocate the memory and return it to the free store. Now
    consider the same code, but with a smart pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The two main differences are that the smart pointer object is constructed explicitly
    by calling the constructor that takes a pointer of the type that is used as the
    template parameter. This pattern reinforces the idea that the resource should
    only be managed by the smart pointer.
  prefs: []
  type: TYPE_NORMAL
- en: The second change is that the memory is deallocated by calling the `release`
    method on the smart pointer object to take ownership of the wrapped pointer, so
    that we can delete the pointer explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Think of the `release` method releasing the pointer from the ownership of the
    smart pointer. After this call, the smart pointer no longer wraps the resource.
    The `unique_ptr` class also has a method `get` that will give access to the wrapped
    pointer, but the smart pointer object will still retain ownership;Â *do not delete
    the pointer obtained this way*!
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that a `unique_ptr` object wraps a pointer, and just the pointer. This
    means that the object is the same size in memory as the pointer it wraps. So far,
    the smart pointer has added very little, so let''s look at another way to deallocate
    the resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'This is *deterministic* releasing of the resource, and means that the resource
    is released just when you want it to happen, which is similar to the situation
    with the pointer. The code here is not releasing the resource itself; it is allowing
    the smart pointer to do it, using a **deleter**. The default deleter for `unique_ptr`
    is a functor class called `default_delete`, which calls the `delete` operator
    on the wrapped pointer. If you intend to use deterministic destruction, `reset`
    is the preferred method. You can provide your own deleter by passing the type
    of a custom functor class as the second parameter to the `unique_ptr` template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'In your code, you will specify that you want the custom deleter, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: You may need to carry out an additional clean up before deleting the pointer,
    or the pointer could be a obtained by a mechanism other than `new`, so you can
    use a custom deleter to ensure that the appropriate releasing function is called.
    Note that the deleter is part of the smart pointer class, so if you have two different
    smart pointers using two different deleter this way, the smart pointer types are
    different even if they wrap the same type of resource.
  prefs: []
  type: TYPE_NORMAL
- en: When you use a custom deleter, the size of a `unique_ptr` object may be larger
    than the pointer wrapped. If the deleter is a functor object, each smart pointer
    object will need memory for this, but if you use a lambda expression, no more
    extra space will be required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you are most likely to allow the smart pointer to manage the resource
    lifetime for you, and to do this you simply allow the smart pointer object to
    go out of scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the pointer created is a single object, it means that you can call the
    `new` operator on an appropriate constructor to pass in initialization parameters.
    The constructor of `unique_ptr` is passed a pointer to an already constructed
    object, and the class manages the lifetime of the object after that. Although
    a `unique_ptr` object can be created directly by calling its constructor, you
    cannot call the copy constructor, so you cannot use initialization syntax during
    construction. Instead, the Standard Library provides a function called `make_unique`.
    This has several overloads, and for this reason it is the preferred way to create
    smart pointers based on this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will call the default constructor on the wrapped type (`int`), but
    you can provide parameters that will be passed to the appropriate constructor
    of the type. For example, for a `struct` that has a constructor with two parameters,
    the following may be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The `make_unique` function calls the constructor that assigns the members with
    non-default values. The `->` operator returns a pointer and the compiler will
    access the object members through this pointer.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a specialization of `unique_ptr` and `make_unique` for arrays.
    The default deleter for this version of `unique_ptr` will call `delete[]` on the
    pointer, and thus it will delete every object in the array (and call each object's
    destructor). The class implements an indexer operator (`[]`) so you can access
    each item in the array. However, note that there are no range checks, so, like
    a built-in array variable, you can access beyond the end of the array. There are
    no dereferencing operators (`*` or `->`), so a `unique_ptr` object based on an
    array can only be accessed with array syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `make_unique` function has an overload that allows you to pass the size
    of the array to create, but you have to initialize each object individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: This creates an array with four `point` objects initially set to the default
    value, and the following lines initialize the second point to a value of `(10.0,
    -10.0)`. It is almost always better to use `vector` or `array` than `unique_ptr`
    to manage arrays of objects.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier versions of the C++ Standard Library had a smart pointer class called
    `auto_ptr`. This was a first attempt, and worked in most cases, but also had some
    limitations; for example, `auto_ptr` objects could not be stored in Standard Library
    containers. C++11 introduces rvalue references and other language features such
    as move semantics, and, through these, `unique_ptr` objects can be stored in containers.
    The `auto_ptr` class is still available through the `<new>` header, but only so
    that older code can still compile.
  prefs: []
  type: TYPE_NORMAL
- en: The important point about the `unique_ptr` class is that it ensures that there
    is a single copy of the pointer. This is important because the class destructor
    will release the resource, so if you *could* copy a `unique_ptr` object it would
    mean more than one destructor will attempt to release the resource. Objects of
    `unique_ptr` have *exclusive ownership*; an instance always owns what it points
    to.
  prefs: []
  type: TYPE_NORMAL
- en: You cannot copy assign `unique_ptr` smart pointers (the copy assignment operator
    and copy constructor are deleted), but you can *move* them by transferring ownership
    of the resource from the source pointer to the destination pointer. So, a function
    can return a `unique_ptr` because the ownership is transferred through move semantics
    to the variable being assigned to the value of the function. If the smart pointer
    is put into a container, there is another move.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing ownership
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are occasions when you will need to share a pointer: you may create several
    objects and pass a pointer to a single object to each of them so they can call
    this object. Ordinarily, when an object has a pointer to another object, that
    pointer represents a resource that should be destroyed during the destruction
    of the containing object. If a pointer is shared, it means that when one of the
    objects deletes the pointer, the pointers in all of the other objects will be
    invalid (this is called a **dangling pointer** because it no longer points to
    an object). You need a mechanism where several objects can hold a pointer that
    will remain valid until *all* the objects using that pointer have indicated they
    will no longer need to use it.'
  prefs: []
  type: TYPE_NORMAL
- en: C++11 provides this facility with the `shared_ptr` class. This class maintains
    a **reference count** on the resource, and each copy of the `shared_ptr` for that
    resource will increment the reference count. When one instance of `shared_ptr`
    for that resource is destroyed, it will decrement the reference count. The reference
    count is shared, so it means that a non-zero value signifies that at least one
    `shared_ptr` exists accessing the resource. When the last `shared_ptr` object
    decrements the reference count to zero, it is safe to release the resource. This
    means that the reference count must be managed in an atomic way to handle multithreaded
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Since the reference count is shared, it means that each `shared_ptr` object
    holds a pointer to a shared buffer called the **control block**, and this means
    it holds the raw pointer and a pointer to the control block, and so each `shared_ptr`
    object will hold more data than a `unique_ptr`. The control block is used for
    more than just the reference count.
  prefs: []
  type: TYPE_NORMAL
- en: A `shared_ptr` object can be created to use a custom deleter (passed as a constructor
    parameter), and the deleter is stored in the control block. This is important
    because it means that the custom deleter is not part of the type of the smart
    pointer, so several `shared_ptr` objects wrapping the same resource type but using
    different deleters are still the same type and can be put in a container for that
    type.
  prefs: []
  type: TYPE_NORMAL
- en: You can create a `shared_ptr` object from another `shared_ptr` object, and this
    will initialize the new object with the raw pointer and the pointer to the control
    block, *and* increment the reference count.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Here, the first shared pointer is created using a raw pointer. This is not the
    recommended way to use `shared_ptr`. The second shared pointer is created using
    the first smart pointer, so now there are two shared pointers to the same resource
    (`p` is assigned to `nullptr` to prevent its further use). After this, either
    `sp1` or `sp2` can be used to access the *same* resource. At the end of this code,
    one shared pointer is reset to `nullptr`; this means that `sp1` no longer has
    a reference count on the resource, and you cannot use it to access the resource.
    However, you can still use `sp2` to access the resource until it goes out of scope,
    or you call `reset`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this code, the smart pointers were created from a separate raw pointer.
    Since the shared pointers now have taken over the lifetime management of the resource
    it is important to no longer use the raw pointer, and in this case it is assigned
    to `nullptr`. It is better to avoid the use of raw pointers, and the Standard
    Library enables this with a function called `make_shared`, which can be used like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The function will create the specified object using a call to `new`, and since
    it takes a variable number of parameters, you can use it to call any constructor
    on the wrapped class.
  prefs: []
  type: TYPE_NORMAL
- en: You can create a `shared_ptr` object from a `unique_ptr` object, which means
    that the pointer is *moved* to the new object and the reference counting control
    block created. Since the resource will now be shared, it means that there is no
    longer exclusive ownership on the resource, so the pointer in the `unique_ptr`
    object will be made a `nullptr`. This means that you can have a factory function
    that returns a pointer to an object wrapped in a `unique_ptr` object, and the
    calling code can determine if it will use a `unique_ptr` object to get exclusive
    access to the resource or a `shared_ptr` object to share it.
  prefs: []
  type: TYPE_NORMAL
- en: There is little point in using `shared_ptr` for arrays of objects; there are
    much better ways to store collections of objects (`vector` or `array`). In any
    case, there is an indexing operator (`[]`) and the default deleter calls `delete`,
    not `delete[]`.
  prefs: []
  type: TYPE_NORMAL
- en: Handling dangling pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Earlier in this book we made the point that, when you delete a resource, you
    should set the pointer to `nullptr` and you should check a pointer before using
    it to see if it is `nullptr`. This is so that you do not call a pointer to memory
    for an object that has been deleted: a dangling pointer.'
  prefs: []
  type: TYPE_NORMAL
- en: There are situations when a dangling pointer can occur by design. For example,
    a *parent* object may create *child* objects that have a **back pointer** to the
    parent so that the child has access to the parent. (An example of this is a window
    that creates child controls; it is often useful for the child controls to have
    access to the parent window.) The problem with using a shared pointer in this
    situation is that the parent will have a reference count on each child control
    and each child control has a reference count on the parent, and this creates a
    circular dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Another example is if you have a container of observer objects with the intention
    of being able to inform each of these observer objects when an event occurs by
    calling a method on each one. Maintaining this list can be complicated, particularly
    if an observer object can be deleted, and hence you have to provide a means to
    remove the object from the container (where there will be a `shared_ptr` reference
    count) before you can completely delete the object. It becomes easier if your
    code can simply add a pointer to the object to the container in a way that does
    not maintain a reference count, but allows you to check when the pointer is used
    if the pointer is dangling or points to an existing object.
  prefs: []
  type: TYPE_NORMAL
- en: Such a pointer is called a **weak pointer** and the C++11 Standard Library provides
    a class called `weak_ptr`. You cannot use a `weak_ptr` object directly and there
    is no dereference operator. Instead, you create a `weak_ptr` object from a `shared_ptr`
    object and, when you want to access the resource, you create a `shared_ptr` object
    from the `weak_ptr` object. This means that a `weak_ptr` object has the same raw
    pointer, and access to the same control block as the `shared_ptr` object, but
    it does not take part in reference counting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once created, the `weak_ptr` object will enable you to test whether the wrapper
    pointer is to an existing resource or to a resource that has been destroyed. There
    are two ways to do this: either call the member function `expired` or attempt
    to create a `shared_ptr` from the `weak_ptr`. If you are maintaining a collection
    of `weak_ptr` objects, you may decide to periodically iterate through the collection,
    call `expired` on each one, and if the method returns `true`, remove that object
    from the collection. Since the `weak_ptr` object has access to the control block
    created by the original `shared_ptr` object, it can test to see if the reference
    count is zero.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second way to test to see if a `weak_ptr` object is dangling is to create
    a `shared_ptr` object from it. There are two options. You can create the `shared_ptr`
    object by passing the weak pointer to its constructor and if the pointer has expired,
    the constructor will throw a `bad_weak_ptr` exception. The other way is to call
    the `lock` method on the weak pointer and if the weak pointer has expired, then
    the `shared_ptr` object will be assigned to `nullptr` and you can test for this.
    These three ways are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Since a weak pointer does not alter the reference count on a resource it means
    that you can use it for a back pointer to break the cyclic dependency (although,
    often it makes sense to use a raw pointer instead because a child object cannot
    exist without its parent object).
  prefs: []
  type: TYPE_NORMAL
- en: Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Classes can be templated, which means that you can write generic code and the
    compiler will generate a class with the types that your code uses. The parameters
    can be types, constant integer values, or variadic versions (zero or more parameters,
    as provided by the code using the class). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a very simple array class that defines the basic iterator functions
    and the indexing operator, so that you can call it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'If you choose to define a function out of the `class` declaration, then you
    need to give the template and its parameters as part of the `class` name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also have default values for template parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'If you think you should have a specific implementation for a template parameter,
    then you can provide the code for that version as a specialization of the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that, with a specialization, you do not get any code from the fully templated
    class; you have to implement all the methods you want to provide, and, as illustrated
    here, methods that are relevant to the specialization but not available on the
    fully templated class. This example is a **partial specialization**, meaning that
    it is specialized on just one parameter (`T`, the type of the data). This class
    will be used for declared variables of the type `simple_array<n, char>`, where
    `n` is an integer. You are free to have a fully specialized template, which, in
    this case, will be a specialization for a fixed size and a specified type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: It is probably not useful in this case, but the idea is that there will be special
    code for variables that need 256 chars.
  prefs: []
  type: TYPE_NORMAL
- en: Using classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Resource Acquisition Is Initialization** technique is useful for managing
    resources provided by other libraries, such as the C Runtime Library or the Windows
    SDK. It simplifies your code because you do not have to think about where a resource
    handle will go out of scope and provide clean-up code at every point. If the clean-up
    code is complicated, it is typical in C code to see it put at the end of a function
    and every exit point in the function will have a `goto` jump to that code. This
    results in messy code. In this example, we will wrap the C files functions with
    a class, so that the lifetime of the file handle is maintained automatically.
  prefs: []
  type: TYPE_NORMAL
- en: The C runtime `_findfirst` and `_findnext` functions allow you to search for
    a file or directory that matches a pattern (including wildcard symbols). The `_findfirst`
    function returns an `intptr_t`, which is relevant to just that search and this
    is passed to the `_findnext` function to get subsequent values. This `intptr_t`
    is an opaque pointer to resources that the C Runtime maintains for the search,
    and so when you are finished with the search you must call `_findclose` to clean
    up any resources associated with it. To prevent memory leaks, it is important
    to call `_findclose`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the `Beginning_C++` folder, create a folder called `Chapter_06`. In Visual
    C++, create a new C++ source file, save it to the `Chapter_06` folder, and call
    it `search.cpp`. The application will use the Standard Library console and strings,
    and it will use the C Runtime file functions, so add these lines to the top of
    the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The application will be called with a file search pattern and it will use the
    C functions to search for files, so you will need a `main` function that has parameters.
    Add the following to the bottom of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing is to create a wrapper class for the search handle that will
    manage this resource. Above the usage function, add a class called `search_handle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: This class has a separate function to release the handle. This is so that a
    user of this class can release the wrapper resource as soon as possible. If the
    object is used in code that could throw an exception, the `close` method won't
    be called directly, but the destructor will be called instead. The wrapper object
    can be created with a `intptr_t` value. If this value is -1, then the handle is
    invalid, so the close method will only call `_findclose` if the handle does not
    have this value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want objects of this class to have exclusive ownership of the handle, so
    delete the copy constructor and copy assignment by putting the following in the
    public part of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'If an object is moved, then any handle in the existing object must be released,
    so add the following after the lines you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The wrapper class will be allocated by a call to `_findfirst` and will be passed
    to a call to `_findnext`, so the wrapper class needs two operators: one to convert
    to an `intptr_t`, so objects of this class can be used wherever an `intptr_t`
    is needed, and the other so that object can be used when a `bool` is needed. Add
    these to the `public` part of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The conversion to `bool` allows you to write code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: If you have a conversion operator that returns a pointer, then the compiler
    will call this in preference to the conversion to `bool`.
  prefs: []
  type: TYPE_NORMAL
- en: You should be able to compile this code (remember to use the `/EHsc` switch)
    to confirm that there are no typos.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, write a wrapper class to perform the search. Below the `search_handle`
    class, add a `file_search` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'This class is created with the search criteria, and we have the option of passing
    a C or C++ string. The class has a `search_handle` data member, and, since the
    default destructor will call the destructor of member objects, we do not need
    to provide a destructor ourselves. However, we will add a `close` method so that
    a user can explicitly release resources. Furthermore, so that users of the class
    can determine the search path, we need an accessor. At the bottom of the class,
    add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'We do not want instances of the `file_search` object to be copied because that
    would mean two copies of the search handle. You could delete the copy constructor
    and assignment operator, but there is no need. Try this: in the `main` function,
    add this test code (it does not matter where):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the code. You''ll get an error and an explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Without a copy constructor, the compiler will generate one (this is the second
    line). The first line is a bit odd because it is saying that you are trying to
    call a deleted method that the compiler has generated! In fact, the error is saying
    that the generated copy constructor is attempting to copy the `handle` data member
    and the `search_handle` copy constructor that has been deleted. Thus you are protected
    against copying `file_search` objects without adding any other code. Delete the
    test lines you just added.
  prefs: []
  type: TYPE_NORMAL
- en: Next add the following lines to the bottom of the `main` function. This will
    create a `file_search` object and print out information to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you need to add code to perform the search. The pattern used here will
    be a method that has an out parameter and returns a `bool`. If a call to the method
    succeeds, then the file found will be returned in the out parameter and the method
    will return `true`. If the call fails, then the out parameter is left untouched
    and the method returns `false`. In the `public` section of the `file_search` class,
    add this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: If this is the first call to this method, then `handle` will be invalid and
    so `_findfirst` is called. This will fill a `_finddata_t` structure with the results
    of the search and return an `intptr_t` value. The `search_handle` object data
    member is assigned to this value returned from this function, and if `_findfirst`
    returns `-1`, the method returns `false`. If the call is successful, then the
    out parameter (a reference to a `string`) is initialized using a C string pointer
    in the `_finddata_t` structure.
  prefs: []
  type: TYPE_NORMAL
- en: If there are more files that match the pattern, then you can call the `next`
    function repeatedly, and on these subsequent calls the `_findnext` function is
    called to get the next file. In this case the `search_handle` object is passed
    to the function and there is an implicit conversion to `intptr_t` through the
    class's conversion operator. If the `_findnext` function returns `-1`, it means
    there are no more files in the search.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of the `main` function, add the following lines to perform the
    search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can compile the code and run it with a search criterion. Bear in mind
    that this is constrained by the facilities of the `_findfirst`/`_findnext` functions,
    so the searches you can do will be quite simple. Try running this at the command
    line with a parameter to search for the subfolders in the `Beginning_C++` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: This will give a list of the subfolders starting with `Ch`. Since there is no
    reason for `search_handle` to be a separate class, move the entire class to the
    `private` section of the `search_handle`, above the declaration of the `handle`
    data member. Compile and run the code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With classes, C++ provides a powerful and flexible mechanism to encapsulate
    data and methods to provide behavior that acts on the data. You can template this
    code so that you can write generic code and get the compiler to generate code
    for the types that you require. In the example, you have seen how classes are
    the basis of object orientation. A class encapsulates data, so that the caller
    only needs to know about the expected behavior (in this example, getting the next
    result in a search), without needing to know the details of how the class does
    this. In the next chapter, we will investigate further features of classes; in
    particular, code reuse through inheritance.
  prefs: []
  type: TYPE_NORMAL
