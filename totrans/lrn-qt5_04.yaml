- en: Style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s generally a good idea to aim for function before form in the development
    process, but the UI is the part of the application our users interact with and
    is a key ingredient of a successful solution. In this chapter, we will introduce
    a CSS-like style resource and build on the responsive design principles we introduced
    in the last chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We will create custom QML components and modules to maximize code reuse. We
    will integrate Font Awesome into our solution to provide us with a suite of scalable
    icons and help give our UI a modern graphical look. We will tidy up the navigation
    bar, introduce the concept of commands, and build the framework for a dynamic,
    context-sensitive command bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Custom style resource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Font Awesome
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigation bar styling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Style resource
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First off, let’s create a new resource file to contain the non-QML visual elements
    we will need. In the `cm-ui` project, Add New... > Qt > Qt Resource File:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98aae715-a183-4b20-a955-8370098aad56.png)'
  prefs: []
  type: TYPE_IMG
- en: Name the file `assets.qrc` and place it in `cm/cm-ui`. Your new file will automatically
    open in the Resource Editor, which I don’t find to be a particularly helpful editor,
    so close it. You will see that the `assets.qrc` file has been added to the Resources
    section of the `cm-ui` project. Right-click on it and select Add New… > Qt > QML
    File. Call the file `Style.qml` and save it to `cm/cm-ui/assets`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `assets.qrc` file in the Plain Text Editor in the same way we did
    for the views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, edit `Style.qml` and we’ll add a single style property to use for the
    background color of our views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: What we are doing here in C++ terms is creating a singleton class with a public
    member variable of type const color called `colourBackground` with an initialized
    value of a hex RGB code for (very) light grey.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to perform a little bit of a manual fudge to wire this up. We need
    to create a Module Definition file named `qmldir` (with no file extension) in
    the same folder as `Style.qml` (`cm/cm-ui/assets`). There is no built-in template
    for this type of file, so we need to create it ourselves. File Explorer in older
    versions of Windows used to make this a painful exercise as it always insisted
    on a file extension. A console command was required to forcibly rename the file.
    Windows 10 will happily create the file without an extension. In the Unix world,
    files without an extension are more common.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `qmldir` file created, edit `assets.qrc` and insert a new entry for
    it right next to `Style.qml` inside the `/assets` prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Double-click on the newly added `qmldir` file and enter the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We have already seen modules when we **import QtQuick 2.9**. This makes version
    2.9 of the QtQuick module available for use in our views. In our `qmldir` file,
    we are defining a new module of our own called `assets` and telling Qt that there
    is a **Style** object within version 1.0 of that module, for which the implementation
    is in our `Style.qml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our new style module created and wired up, let’s now put that modern off-white
    color to use. Start with the first child view we see, `SplashView`, and add the
    following to get access to our new module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You’ll note that we’re presented with an angry red underline, suggesting that
    all is not well. Hover over the line with the mouse pointer, and a tooltip will
    tell us that we need to add the import path to our new `qmldir` definition file.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of ways to do this. The first option is to go to the Projects
    mode and select the current kit’s Build settings and then Debug mode. At the bottom
    in the Build Environment section, click on Details. Here, you can see a list of
    all the environment variables for the current kit and configuration. Add a new
    variable called QML2_IMPORT_PATH and set its value to the `cm-ui` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15b22f72-580d-476a-bc12-0b56ead7901c.png)'
  prefs: []
  type: TYPE_IMG
- en: This adds the project working directory of the `cm-ui` project (`/projects/qt/cm/cm-ui`)
    to the QML Import Path. Note that our module name must reflect the relative path
    to the `qmldir` file from this import path.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this approach is that this environment variable is tied to
    the `cm.pro.user` file. If you share the project with other developers, they will
    have their own `cm.pro.user` files, and they will have to remember to add this
    variable too. Furthermore, it's tied to an absolute path and if you copy the project
    code to another machine, it may not be at that location.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second, and preferred, option is to add the following line to `main.cpp`
    immediately after instantiating **QQmlApplicationEngine**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'So why `qrc:/` and not the absolute path to our `qmldir` file? You''ll remember
    that we added our `views.qrc` resource bundle to a `RESOURCES` variable in `cm-ui.pro`. 
    What this does is it takes all the files from `views.qrc` and compiles them into
    the application binary in a kind of virtual filesystem, where the prefixes act
    as virtual folders.  The root of this virtual filesystem is referenced as `qrc:/`
    and by using this in the import path, we are essentially asking Qt to look inside
    all of our bundled resource files for any modules. Head over to `cm-ui.pro` and
    ensure that our new `assets.qrc` has also been added to `RESOURCES`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This can be a bit confusing, so to reiterate, we have added the following folder
    to search for new modules, either using the QML2_IMPORT_PATH environment variable
    to search our `cm-ui` project folder on our local physical filesystem, or the
    `addImportPath()` method to search the root of our virtual resource filesystem
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, our `qmldir` file that defines our new module is in a folder
    called `assets` a level below that, that is, either `<Qt Projects>/cm/cm-ui/assets` in
    the physical filesystem or `qrc:/assets` in the virtual.
  prefs: []
  type: TYPE_NORMAL
- en: This gives us the module name `assets`. If our folder structure was deeper,
    like stuff/badgers/assets, then our module would need to be called `stuff.badgers.assets`,
    as that is the path relative to our defined import path. Similarly, if we wanted
    to add another module for our existing views, we would create a `qmldir` file
    in `cm-ui/views` and call the module `views`.
  prefs: []
  type: TYPE_NORMAL
- en: If you see that Qt Creator is still a bit confused and the red line still persists,
    ensure that `cm-ui.pro` contains the `QML_IMPORT_PATH += $$PWD` line.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all this in place, we can now use our new module. Including the module
    means we can now access our singleton `Style` object and read properties from
    it. Replace the `color` property of our `SplashView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Repeat this to set the background color for all of our views except `MasterView`.
    Remember to `include ui.assets 1.0` in each view too.
  prefs: []
  type: TYPE_NORMAL
- en: When you build and run the application, you may wonder why we’ve gone through
    all of that rigmarole when the views look exactly the same as they did before.
    Well, let’s say that we’ve just had a meeting with the guys from marketing where
    they told us that yellowy orange is not a good fit for the brand any more, and
    we need to change all the views to be a clean off-white color. We would previously
    have had to go into every view and change the color from `#f4c842` to `#efefef`.
    Now, there are only seven of them, so it’s not a big deal, but imagine if we had
    to change all the colors for all the components in 50 complex views; that would
    be a very painful exercise.
  prefs: []
  type: TYPE_NORMAL
- en: However, go to `Style.qml` and change the `colourBackground` property from `#f4c842`
    to `#efefef`. Build and run the application and bask in the glory of our rebranded
    app! By setting up our shared style component early, we can add the properties
    as we go and then restyling our app later becomes much easier. We can add properties
    of all types here, not just colors, so we’ll be adding sizes, fonts, and other
    things as we progress further through our development.
  prefs: []
  type: TYPE_NORMAL
- en: Font Awesome
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With our styling framework in place, let’s review what our navigation bar looks
    like and figure out what we want to achieve:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ff42490-1ab9-4573-88bc-ac1e8e9af10c.png)'
  prefs: []
  type: TYPE_IMG
- en: The buttons we want to display on our navigation bar are Dashboard View (the
    Home view), New Client View, and Find Client View, along with a toggle button
    at the top to expand and collapse the bar.
  prefs: []
  type: TYPE_NORMAL
- en: A common UI design pattern is to represent simple commands with icons. Further
    information about the command can be obtained by a variety of means; for example,
    when you hover over the button, information can be displayed in a tooltip or a
    status bar at the bottom of the screen. Our approach will be to have a collapsible
    bar. The default state of the bar will be collapsed and will display an icon representing
    each command. In expanded state, the bar will display both the icon and a textual
    description of the command. The user will be able to toggle the states with an
    additional button. This is a pattern particularly prevalent in mobile application
    development, where you want to consume as little screen space as possible by default.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few options for displaying the icons for our buttons. Older desktop
    applications would more than likely use image files of some description. This
    gives you full artistic control over how your icons look, but carries several
    drawbacks. Image files tend to be comparatively large in size, and they are a
    fixed size. If you need to draw them at a different size, then they can look bad,
    particularly if they are scaled up or if the aspect ratio changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scalable Vector Graphics** (**SVG**) are much smaller files and scale very
    well. They are more difficult to create and can be a bit more limited artistically,
    but they can be very useful for the purpose of icons. However, from experience,
    they can be quite tricky to work with in Qt/QML.'
  prefs: []
  type: TYPE_NORMAL
- en: The third option that gives you the small file size and scalability benefits
    of SVG but are much easier to work with are symbol font files. This is a very
    common solution in web development, and this is the approach we will take.
  prefs: []
  type: TYPE_NORMAL
- en: There are numerous symbol fonts available but perhaps the most popular for development
    is **Font Awesome**. It provides a wide range of terrific symbols and has a very
    helpful website; check out: [http://fontawesome.io/](http://fontawesome.io/).
  prefs: []
  type: TYPE_NORMAL
- en: Check any licensing applicable for fonts you choose to use, especially if you
    are using them commercially.
  prefs: []
  type: TYPE_NORMAL
- en: Download the kit and open up the archive file. The file we are interested in
    is `fonts`/`fontawesome-webfont.ttf`. Copy this file into our project folder in
    `cm/cm-ui/assets`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `cm-ui` project, edit `assets.qrc` and add the font to our resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Remember that our alias doesn’t have to be the same as the original filename,
    and we’ve taken the opportunity to shorten it a bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, edit `Style.qml` and we''ll wire the font up to our custom style for
    easy use. We first need the font to be loaded and made available for use, which
    we achieve using a `FontLoader` component. Add the following inside the root **Item**
    element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `source` property, we use the `/assets` prefix (or virtual folder) we
    defined in our `assets.qrc` file along with the `fontawesome.ttf` alias. Now,
    we have loaded the font but as it stands, we won’t be able to reference it from
    outside of `Style.qml`. This is because only properties at root component level
    are accessible outside of the file. Child components are deemed effectively private.
    The way we get around this is by creating a `property alias` for the element we
    want to expose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This creates a publicly available property called `fontAwesome`, which when
    called, simply redirects the caller to the `name` property of the internal `fontAwesomeLoader`
    element.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the wiring done, let’s find the icons we want to use. Back on the Font
    Awesome website, navigate to the Icons page. Here, you can see all the available
    icons. Clicking on one will display further information about it, and it is from
    here that we can get the key piece of information we need in order to display
    it, and that is the unicode character. I’ll select the following icons for our
    menu, but feel free to choose whichever icons you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Icon** | **Unicode character** |'
  prefs: []
  type: TYPE_TB
- en: '| Toggle Menu | bars | f0c9 |'
  prefs: []
  type: TYPE_TB
- en: '| Dashboard | home | f015 |'
  prefs: []
  type: TYPE_TB
- en: '| New Client | user-plus | f234 |'
  prefs: []
  type: TYPE_TB
- en: '| Find Client | search | f002 |'
  prefs: []
  type: TYPE_TB
- en: 'Now, let’s replace the `Button` components on our `MasterView` with a `Text`
    component for each of our icons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You will also need to add the **assets 1.0** import if you haven’t already:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0f8f95a5-e2a7-4511-986b-f772c7d125d3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we’ll add the descriptive text for the client commands. Wrap each of
    the `Text` components in a `Row` and add a further `Text` component for the description,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Row` component will lay out its children horizontally—first the icon and
    then the descriptive text. Repeat this for the other commands. Add the descriptions
    Dashboard and Find Client for the other buttons and simply an empty string for
    the toggle command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/877075bc-0bc9-4813-8ba1-dd98326e65dd.png)'
  prefs: []
  type: TYPE_IMG
- en: Before we get too carried away making further changes, we’ll take a breath,
    do some refactoring, and look at introducing components.
  prefs: []
  type: TYPE_NORMAL
- en: Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The QML, what we’ve just written, is functional enough, but it's already becoming
    difficult to maintain. Our `MasterView` is getting a little long and difficult
    to read. When we come to change how our command buttons look, for example, aligning
    the icon and text, we will have to change it in four places. If we want to add
    a fifth button, we have to copy, paste, and edit a whole bunch of QML to do so.
    This is where reusable components come into play.
  prefs: []
  type: TYPE_NORMAL
- en: Components are exactly the same as the views we have already created—just snippets
    of QML. The difference is purely semantic. Throughout this book, views represent
    screens that lay out content while components are the content.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to create a new component is when you have already written the
    QML that you want to form the basis for your component, which we have done. Right-click
    on any of the `Row` elements we added for our commands and select **Refactoring
    > Move Component into Separate File**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Name the new component `NavigationButton` and save it to a new folder—`cm/cm-ui/components`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4b37e410-961d-4855-b235-5b6102bea245.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Row element will be moved to our new file and in `MasterView`, you will
    be left with an empty `NavigationButton` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, it comes with a big red squiggly, and our app will no longer
    run.  While the refactoring step has happily created a new `NavigationButton.qml`
    file for us, it''s not actually included in our project anywhere, so Qt doesn''t
    know where it is. It’s easy enough to resolve though, and we just need to set
    up our resources bundle as we did with our views and assets:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `Qt Resource File` called `components.qrc` in the `cm/cm-ui` folder
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an empty `qmldir` file in `cm/cm-ui/components` as we did for our assets
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit `components.qrc` to include both of our new files within a `/components`
    prefix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit `qmldir` to set up our module and add our `NavigationButton` component
    to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Ensure that `components.qrc` has been added to the `RESOURCES` variable in `cm-ui.pro`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `MasterView`, include our new components module to get access to our new
    component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, getting our module to be fully recognized and banishing the red squigglies
    may only be accomplished by restarting Qt Creator, as that forces the reload of
    all the QML modules.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a reusable component that hides away the implementation details,
    reduces code duplication, and makes it much easier to add new commands and maintain
    the old ones. However, there are a few changes we need to make to it before we
    can leverage it for our other commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, our `NavigationButton` has hard-coded icon and description text
    values that will be the same whenever we use the component. We need to expose
    both the text properties so that we can set them to be different for each of our
    commands. As we saw, we can achieve this using property aliases, but we need to
    add unique identifiers to our `Text` elements for that to work. Let’s set the
    default values to be something generic and also implement advice from earlier
    in the book to have an `Item` component as the root element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that our component is configurable with properties, we can replace our
    commands in `MasterView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This is much more concise and manageable than all of the duplicated QML we
    had earlier. Now, if you run the application, you’ll see that while we’ve taken
    a couple of steps forward, and that we’ve also taken one step back:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2cc949e0-1300-4208-b473-ab860a09c420.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, all of our components are drawn on top of each other. The root
    cause of this is the issue we’ve touched on previously regarding sizing. We have
    a visual component with a root `Item` element, and we haven’t explicitly defined
    its size. Another thing we are neglecting is our custom style. Let’s fix those
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Styling the navigation bar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Starting with the easy part, let’s first move our hard-coded colors and icon
    pixel size from `NavigationButton` into `Style.qml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to think about how we want to size the elements of our button.
    We have an icon which we want to be square, so the width and height will be the
    same. Next, to that, we have a text description that will be the same height as
    the icon but will be wider:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a0d5ede-e554-4bff-8009-5485a5757630.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The width of the entire component is the width of the icon plus the width of
    the description. The height of the entire component is the same as both the height
    of the icon and description; however, it gives us more flexibility to make the
    height the same as whichever is the larger of the two. That way, if we ever decide
    to make one item larger than the other, we know that the component will be large
    enough to contain them both. Let’s pick starter sizes of 80 x 80 for the icon
    and 80 x 240 for the description and define the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: There are a couple of things to note here. Properties can be bound directly
    to other properties, which reduces the amount of duplication and makes the whole
    setup much more dynamic. We know that we want our icon to be square, so by binding
    the height to be the same as the width, if we want to change the total size of
    the icon, we just need to update the width, and the height will automatically
    update. QML also has strong integration with a JavaScript engine, so we can use
    the `Math.max()` function to help us figure out which is the larger height.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing we would like the navigation buttons to do is to provide some
    kind of visual cue when the user hovers the mouse over a button to indicate that
    it is an interactive element. To do that, we need each button to have its own
    background rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `NavigationButton`, wrap the `Row` element in a new `Rectangle` and
    plug the sizes into our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Run again, and you’ll see a slight improvement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ea8081d-d28b-40e7-9335-9a31e0c02f7c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We’re getting part of the description cut off because our navigation bar is
    hard-coded to be 100 pixels wide. We need to change this and also implement the
    toggle expanded/collapsed functionality. We have already calculated the sizes
    we need, so let’s prepare by adding a couple of new properties to `Style.qml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The collapsed state will be just wide enough for the icon, while the expanded
    state will contain the entire button, including description.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s encapsulate our navigation bar in a new component. There won’t be
    any reuse benefits in this case as there will only ever be one, but it helps keep
    our QML organized and makes `MasterView` more concise and easy to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can right-click on the `Rectangle` component in `MasterView` and refactor
    our navigation bar into a new QML file, as we did for our `NavigationButton`.
    However, let’s do it manually so that you are comfortable with both approaches.
    Right-click on `components.qrc` and select Add New… > Qt > QML File. Add `NavigationBar.qml`
    to `cm/cm-ui/components`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c4e1ac6-4818-49d8-8118-07d9ecf603b6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Edit `components.qrc` and move our new `NavigationBar` into the `/components`
    prefix section with an alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the component to our components module by editing `qmldir`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Cut the `Rectangle` and its child elements from `MasterView` and paste it into
    `NavigationBar.qml` inside the root `Item` element. Update the `QtQuick` module
    import to version 2.9 if it has been initialized to some older version. Add an
    import for our assets module to gain access to our Style object. Move the Rectangle''s
    `anchors` and `width` properties to the root `Item` and set the `Rectangle` to
    fill its parent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Back in `MasterView`, you can now add the new `NavigationBar` component in
    where the `Rectangle` used to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Although you get the dreaded red squigglies again, you will actually be able
    to run the application and verify that the refactoring hasn’t broken anything.
  prefs: []
  type: TYPE_NORMAL
- en: 'The anchoring of our new `NavigationBar` component is fine, but the `width`
    is a little more complicated—how do we know whether it should be `Style.widthNavigationBarCollapsed`
    or `Style.heightNavigationBarExpanded`? We’ll control this with a publicly accessible
    Boolean property that indicates whether the bar is collapsed or not. We can then
    use the value of this property to decide which width we want using the conditional
    `?` operator syntax. Set the property to be true initially, so the bar will render
    in its collapsed state by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'With that in place, replace the hard-coded `width` of 100, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, update the `color` property of `Rectangle` to `Style.colourNavigationBarBackground`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9041acb-28ab-4c99-99bb-b7c7b247be84.png)'
  prefs: []
  type: TYPE_IMG
- en: We’re getting there now, but one key thing we’ve missed along the way is that
    clicking on the buttons now doesn’t actually do anything anymore. Let’s fix that
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Clicking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Early on in this book, we looked at a component called `MouseArea`. This was
    soon superseded by our use of `Button` components, which provide the clicking
    functionality for us. However, now that we are rolling our own form of buttons,
    we need to implement the clicking functionality ourselves. Much like the `Button`
    components, our `NavigationButton` shouldn’t really do anything when they are
    clicked on, other than informing their parent that the event has occurred. Components
    should be as generic and ignorant about context as possible so that you can use
    them in multiple places. What we need to do is add a `MouseArea` component and
    simply pass on the `onClicked` event via a custom signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `NavigationButton`, we first add the signal that we want to emit whenever
    the component has been clicked on. Add this just after the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Try and give the signals quite specific names, even if they are a little long.
    If you simply call everything `clicked()`, then things can get a little confusing
    and sometimes you may find yourself referencing a different signal to the one
    you intended.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll add another property to support some mouse hover magic we’ll implement.
    This will be a `color` type, and we’ll default it to be the regular background
    color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this color in conjunction with the `states` property of `Rectangle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Think of each state in the array as a named configuration. The default configuration
    has no name ("") and consists of the properties we have already set within the
    `Rectangle` element. The “hover” state applies changes to the properties specified
    in the `PropertyChanges` element, that is, it will change the `color` property
    of the element with ID `background` to be whatever the value of `hoverColour`
    is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, inside the `Rectangle` but below the `Row`, add our `MouseArea`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We use the `anchors` property to fill the whole button background area, including
    icon and description. Next, we’ll jazz things up a bit by changing the mouse cursor
    to a pointing hand when it enters the button area and enabling hovering with the
    `hoverEnabled` flag. When enabled, the **entered** and **exited** signals are
    emitted when the cursor enters and exits the area, and we can use the corresponding
    slots to change the appearance of our background `Rectangle` by switching between
    the hover state we’ve just implemented and the default (""). Finally, we respond
    to the `clicked()` signal of `MouseArea` with the `onClicked()` slot and simply
    emit our own signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now react to the `navigationButtonClicked()` signal in our `NavigationBar`
    component and add some hover colors while we’re at it. Implement the toggle button
    first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We implement the `<MyCapitalisedSignalName>` convention to create a slot for
    our signal and when it fires, we simply toggle the value of `isCollapsed` between
    `true` and `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now run the application. Click on the Toggle button to expand and collapse
    the navigation bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/180bd707-01e0-487d-a7c1-3e63e5c47372.png)'
  prefs: []
  type: TYPE_IMG
- en: Note how because of our use of `anchors`, the child views dynamically resize
    themselves to accommodate the navigation bar. You will also see the pointing hand
    cursor and a flash of color when you hover over the button, which helps the user
    understand that it is an interactive element and visualizes the boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: For the remaining navigation buttons, what we want to do in reaction to the
    clicked event is to emit the `goDashboardView()`, `goCreateClientView()`, and
    `goFindClientView()` signals on the `NavigationCoordinator`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `onNavigationButtonClicked` slots to the other buttons and drill down
    through the `masterController` object to get to the signals we want to call. Add
    some fancy colors of your choice too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You can now click on the buttons to navigate to the different child views.
  prefs: []
  type: TYPE_NORMAL
- en: A few last little tweaks to finish the navigation bar are to align the content
    of our buttons a little better and resize a few things.
  prefs: []
  type: TYPE_NORMAL
- en: 'The description text should align vertically with the center of the icon rather
    than the top, and our icons should be centered rather than pinned up against the
    edge of the window. The first issue is easy to solve, because we’ve already been
    consistent and explicit with our sizings. Simply add the following property to
    both the `Text` components in `NavigationButton`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Both the `Text` elements were sized to take up the full height of the button,
    so we simply need to align the text vertically within that space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fixing the alignment of the icons is just the same, but this time in the horizontal
    axis. Add the following to the `Text` component of the icon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'As for the sizings, our description text is a little small and there is a lot
    of empty space after the text. Add a new property to our `Style` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the new property in the description `Text` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Next, reduce the `widthNavigationButtonDescription` property in `Style` to 160.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the app and we’re nearly there. The sizing and alignment is much better
    now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d011ffc4-fc00-4900-9347-f7f6ae385647.png)'
  prefs: []
  type: TYPE_IMG
- en: However, one thing you may not note is that when the bar is collapsed and only
    the icon is displayed, the `MouseArea` is still the full width of the button including
    the description. Try moving the mouse where the description would be, and you
    can see the pointing hand cursor appear. You can even click on the components
    and the transition happens. What we need to do to fix this is rather than the
    root `Item` element in `NavigationButton` being a fixed width (`Style.widthNavigationButton`),
    we need to make it dynamic and set it to `parent.width` instead. In order for
    that to work, we then need to walk up the QML hierarchy and ensure that its parent
    has a width too. Its parent is the `Column` element in `NavigationBar`. Set the
    `width` property of `Column` to be `parent.width` too.
  prefs: []
  type: TYPE_NORMAL
- en: With those changes in place, the navigation bar now behaves as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next thing on our to-do list is to implement a context-sensitive command
    bar. While our navigation bar is a constant presence with the same buttons regardless
    of what the user is doing, the command bar will come and go and will contain different
    buttons depending on the context. For example, if the user is adding or editing
    a client, we will need a Save button to commit any changes to the database. However,
    if we are searching for a client, then saving makes no sense and a Findbutton
    is more relevant. While the techniques for creating our command bar are broadly
    similar to the navigation bar, the additional flexibility required poses more
    of a challenge.
  prefs: []
  type: TYPE_NORMAL
- en: To help us overcome these obstacles, we will implement commands. An additional
    benefit of this approach is that we get to move the logic out of the UI layer
    and into the business logic layer. I like the UI to be as dumb and as generic
    as possible. This makes your application more flexible, and bugs in C++ code are
    easier to identify and resolve than those in QML.
  prefs: []
  type: TYPE_NORMAL
- en: A command object will encapsulate an icon, descriptive text, a function to determine
    whether the button is enabled or not, and finally, an `executed()` signal that
    will be emitted when the related button is pressed. Each button in our command
    bar will then be bound to a command object.
  prefs: []
  type: TYPE_NORMAL
- en: Each of our child view may have a list of commands and an associated command
    bar. For the views that do, we will present the list of commands to the UI via
    a command controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create two new `C++` classes in the `cm-lib` project, both of which should
    inherit from QObject:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Command** in a new folder `cm-lib/source/framework`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Command Controller** in the existing folder `cm-lib/source/controllers`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`command.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`command.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The QObject, namespaces, and dll export code should be familiar by now. We represent
    the icon character and description values we want to display on the UI buttons
    as strings. We hide the member variables away in the private implementation and
    provide `accessor` methods for them. We could have represented the `canExecute`
    member as a simple `bool` member that calling code could set to `true` or `false`
    as required; however, a much more elegant solution is to pass in a method that
    calculates the value for us on the fly. By default, we set it to a lambda that
    returns `true`, which means that the button will be enabled. We provide a `canExecuteChanged()`
    signal to go along with this, which we can fire whenever we want the UI to reassess
    whether the button is enabled or not. The last element is the `executed()` signal
    that will be fired by the UI when the corresponding button is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: '`command-controller.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '`command-controller.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Here, we introduce a new type—`QQmlListProperty`. It is essentially a wrapper
    that enables QML to interact with a list of custom objects. Remember that we need
    to fully qualify the templated type in the `Q_PROPERTY` statements. The private
    member that actually holds the data is a QList, and we have implemented an `accessor`
    method that takes the QList and converts it into a `QQmlListProperty` of the same
    templated type.
  prefs: []
  type: TYPE_NORMAL
- en: As per the documentation for `QQmlListProperty`, this method of object construction
    should not be used in production code, but we’ll use it to keep things simple.
  prefs: []
  type: TYPE_NORMAL
- en: We have created a single command list for our `CreateClientView`. We’ll add
    command lists for other views later. Again, we’ll keep things simple for now;
    we just create a single command to save a newly created client. When creating
    the command, we parent it to the command coordinator so that we don’t have to
    worry about memory management. We assign it a floppy disk icon (unicode f0c7)
    and the Save label. We leave the `canExecute` function as the default for now
    so it will always be enabled. Next, we connect the `executed()` signal of the command
    to the `onCreateClientSaveExecuted()` slot of the `CommandController`. With the
    wiring done, we then add the command to the list.
  prefs: []
  type: TYPE_NORMAL
- en: The intention is that we present the user with a command button bound to a `Command`
    object. When the user presses the button, we will fire the `executed()` signal
    from the UI. The connection we’ve set up will cause the slot on the command controller
    to be called, and we will execute our business logic. For now, we’ll simply print
    out a line to the console when the button is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s register both of our new types in `main.cpp` (remember the `#includes`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to add the `CommandCoordinator` property to `MasterController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add an `accessor` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Finally, in `master-controller.cpp`, instantiate the object in the private implementation
    and implement the `accessor` method in exactly the same way as we did for `NavigationController`.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a (very short!) list of commands ready for our `CreateClientView`
    to consume.
  prefs: []
  type: TYPE_NORMAL
- en: Command bar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s begin by adding some more properties to Style for our command components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create two new QML components in our UI project: `CommandBar.qml` and
    `CommandButton.qml` in `cm-ui/components`. Update `components.qrc` and move the
    new components into the `/components` prefix with aliases. Edit `qmldir` and append
    the new components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'For our button design, we want to lay out the description below the icon. The
    icon should be positioned slightly above centre. The component should be square,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1bf95587-1026-463f-91b3-cfb511bdf1c2.png)'
  prefs: []
  type: TYPE_IMG
- en: '`CommandButton.qml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This is largely similar to our `NavigationButton` component. We pass in a `Command`
    object, which is where we will obtain the icon character and description to display
    in the **Text** elements as well as the signal to emit when the button is pressed,
    so long as the command can execute.
  prefs: []
  type: TYPE_NORMAL
- en: We use an alternative to the **Row/Column** based layout and use anchors to
    position our icon and description instead. We center the icon in the parent `Rectangle`
    and then apply a vertical offset to move it up and allow space for the description.
    We anchor the top of the description to the bottom of the icon.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than propagating a signal when the button is pressed, we emit the `executed()`
    signal of the `Command` object, first verifying that the command can execute.
    We also use this flag to selectively color our text elements, using a paler grey
    font if the command is disabled.
  prefs: []
  type: TYPE_NORMAL
- en: We implement some more hover functionality with our `MouseArea`, but rather
    than exposing a property to pass in the hover color, we simply take the default
    and darken it a few shades using the built-in `Qt.darker()` method. We also only
    apply the state change in the `onEntered()` slot of the `MouseArea` if the command
    can be executed.
  prefs: []
  type: TYPE_NORMAL
- en: '`CommandBar.qml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Again, this is largely the same as `NavigationBar`, but with a dynamic list
    of commands rather than hard-coded QML buttons. We introduce another new component—the
    `Repeater`. Given a list of objects via the `model` property, `Repeater` will
    instantiate a QML component defined in the `delegate` property for each item in
    the list. The object from the list is made available via the built-in `modelData`
    variable. Using this mechanism, we can automatically generate a `CommandButton`
    element for each command we have in a given list. We use another property alias
    so that the caller can set the command list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s put this to use in `CreateClientView`. First, `import components 1.0`,
    and then add the following inside the root `Item` and after the `Rectangle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We drill down through our property hierarchy to get the command list for the
    create client view and pass that list to the command bar which takes care of the
    rest. Don’t worry if the `CommandBar` has red squiggles, Qt Creator just needs
    to catch up with our blistering pace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the app and navigate to Create Client View:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/093cca1f-f222-4039-a734-70488a159adc.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on the button, and you will see the message output to the console. Adding
    new commands is as simple as appending a new `Command` object to the QList inside
    `CommandController`—no UI changes needed! The command bar will automatically create
    a new button for every command it finds in the list. Also note that this command
    bar is only present on the `CreateClientView`, so it is context sensitive. We
    can easily add command bars to other views by simply adding extra lists and properties
    to the `CommandController`, as we will later.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we gave the navigation bar a much needed overhaul. We added
    our first few components and leveraged our new custom style object, with Font
    Awesome providing some lovely scalable graphics for us. We also introduced commands
    and have the framework in place to be able to add context-sensitive command buttons
    to our views.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](d1169ccb-4e46-49f4-b41b-2aaf896337ad.xhtml), *Data*, we’ll get
    stuck into the business logic layer and flesh out our first data models.
  prefs: []
  type: TYPE_NORMAL
