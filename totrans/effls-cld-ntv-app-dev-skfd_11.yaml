- en: '[*Chapter 8*](B17385_08_Final_PD_ePub.xhtml#_idTextAnchor099): Deploying a
    Spring Boot Application to the Google Kubernetes Engine Using Skaffold'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned how to deploy a **Spring Boot** application
    to a local **Kubernetes** cluster using **Google**'s **Cloud Code** plugin for
    **IntelliJ**. This chapter focuses on deploying the same Spring Boot application
    to the remote **Google Kubernetes Engine** (**GKE**), a managed Kubernetes service
    provided by the **Google Cloud Platform** (**GCP**). We will introduce you to
    Google's recently launched serverless Kubernetes offering, **GKE Autopilot**.
    You will also get to know **Google Cloud SDK** and **Cloud Shell**, and use them
    to connect and manage a remote Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with the Google Cloud Platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Google Cloud SDK and Cloud Shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the Google Kubernetes Engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing GKE Autopilot clusters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a Spring Boot application to the GKE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a solid understanding of the essential
    services provided by the GCP to deploy a Spring Boot application to Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You''ll need the following to be installed on your system to follow the examples
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse ([https://www.eclipse.org/downloads/](https://www.eclipse.org/downloads/))
    or IntelliJ IDE ([https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git ([https://git-scm.com/downloads](https://git-scm.com/downloads))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google Cloud SDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GCP account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot 2.5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenJDK 16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code examples present in the chapter can also be found on GitHub at [https://github.com/PacktPublishing/Effortless-Cloud-Native-App-Development-Using-Skaffold](https://github.com/PacktPublishing/Effortless-Cloud-Native-App-Development-Using-Skaffold).
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with the Google Cloud Platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today, many organizations take advantage of services provided by different cloud
    providers such as **Amazon** **Web** **Services** (**AWS**), Google's GCP, **Microsoft**
    **Azure**, **IBM** **Cloud**, or **Oracle** **Cloud**. The advantage of using
    these cloud vendors is that you don't have to manage infrastructure yourself,
    and you typically pay per hour for the use of these servers. Also, most of the
    time, if the organizations are unaware of or fail to address the computing power
    needed for their applications, it might result in the overprovision of computing
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: If you're managing the infrastructure yourself, you have to keep an army of
    people to take care of upkeep activities such as patching an operating system,
    upgrading the software, and upgrading the hardware. These cloud vendors help us
    solve business problems by providing these services for us. Also, you get built-in
    maintenance for the products that these cloud vendors support, whether it is databases
    or managed services such as Kubernetes. If you have already used any of these
    cloud vendors, you might find that all of these vendors provide similar services
    or products. Still, the implementation and how they work are different.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you can see the services provided by GCP and their AWS and Azure
    equivalents in the link [https://cloud.google.com/free/docs/aws-azure-gcp-service-comparison](https://cloud.google.com/free/docs/aws-azure-gcp-service-comparison).
  prefs: []
  type: TYPE_NORMAL
- en: Now we know that there are advantages of using these cloud vendors for different
    use cases, let's talk about one such cloud vendor – Google Cloud Platform.
  prefs: []
  type: TYPE_NORMAL
- en: Google Cloud Platform, often abbreviated to GCP, provides you with a collection
    of services such as on-demand virtual machines (through **Google Compute Engine**),
    object storage for storing files (through **Google Cloud Storage**), and managed
    Kubernetes (through Google Kubernetes Engine), to name a few.
  prefs: []
  type: TYPE_NORMAL
- en: Before you can begin utilizing Google's Cloud services, you are first required
    to sign up for an account. If you already have a Google account such as a **Gmail**
    account, then you can use that to log in, but you are still required to sign up
    separately for the Cloud account. You can skip this step if you are already signed
    up on the Google Cloud Platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, navigate to [https://cloud.google.com](https://cloud.google.com). Next,
    you will be asked to go through a typical Google sign-in process. If you don''t
    have a Google account yet, follow the sign-up process to create one. The following
    screenshot is the Google Cloud sign-in page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Getting started with Google Cloud'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.1_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – Getting started with Google Cloud
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the screenshot carefully, it says **New customers get $300 in
    free credits to spend on Google Cloud. All customers get free usage of 20+ products**.
    This means you can use free tier products without paying anything, and you will
    also get credit worth $300 for 90 days to explore or evaluate different services
    provided by GCP. For example, you can use Compute Engine, Cloud Storage, and **BigQuery**
    free of charge within specified monthly usage limits.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can either click on **Get started for free** or **Sign In**. You must provide
    your billing information if you sign up for the first time, and this redirects
    you to your Cloud **Console**. Also, a new project is automatically created for
    you. A project is a sort of workspace for your work. All the resources in a single
    project are isolated from those in all the other projects. You can control access
    to this project and only grant access to specific individuals or service accounts.
    The following screenshot is the view of your Google Cloud Console dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Google Cloud Console dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.2_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.2 – Google Cloud Console dashboard
  prefs: []
  type: TYPE_NORMAL
- en: 'On the left side of the Console page, you can view different services offered
    by GCP:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Google Cloud services view'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.3_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.3 – Google Cloud services view
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, the focus will be on the GKE services API provided by GCP.
    But before we discuss these, we need to install some tools to use those services.
    Let's talk about those tools in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Google Cloud SDK and Cloud Shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have access to the GCP Console now, and you can pretty much do anything
    using the Console. But a better approach for a developer is to use Cloud SDK,
    which is a collection of tools that allow faster local development by using emulators
    or tools like **kubectl**, **Skaffold**, and **minikube**. Not only that, but
    you can manage your resources, authenticate with remote Kubernetes clusters, and
    enable or disable GCP services from your local workstation. Another option is
    to use Cloud Shell from your browser, and we will be exploring both options in
    this chapter. Cloud SDK gives you tools and a library for interacting with its
    product and services. You can install and remove components as per your needs
    when using Cloud SDK.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with Cloud SDK. You can navigate to [https://cloud.google.com/sdk/](https://cloud.google.com/sdk/)
    and click on the **Get Started** button. This will redirect you to the installation
    guide. A minimum prerequisite for Cloud SDK is to have Python. Supported versions
    are Python 3 (3.5 to 3.8 preferred) and Python 2 (2.7.9 or higher). For example,
    modern versions of macOS include the appropriate version of Python required for
    Cloud SDK. However, if you'd like to install Python 3 with Cloud SDK, you can
    choose the macOS 64-bit with bundled Python installation offering.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading Cloud SDK on Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cloud SDK requires Python to be installed, so first verify the Python version
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To download the Linux 64-bit archive file from your command line, run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For the 32-bit archive file, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Downloading Cloud SDK on macOS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To download Cloud SDK on macOS, you have the following options to choose from:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Download options for macOS'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.4_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.4 – Download options for macOS
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are not sure about your machine''s hardware, then run the `uname –m`
    command. Based upon your machine, you will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now select the appropriate package and download it from the URL given in the
    **Package** column in the table available at [https://cloud.google.com/sdk/docs/install#mac](https://cloud.google.com/sdk/docs/install#mac).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Cloud SDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After downloading the package, you need to extract the archive to a location
    of your choice on your filesystem. The following is the content of the `google-cloud-sdk`
    extracted archive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After extracting the archive, you can proceed with the installation by running
    the `install.sh` script available in the root directory of your extract. You might
    see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following screen, you can see the list of installed and not installed
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – List of Google Cloud SDK components'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.5_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.5 – List of Google Cloud SDK components
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the following Cloud SDK commands to install or remove components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Make sure you source your bash profile after this using the `source .zshrc`
    command. From the installation, you can see that only three components, `. bq`,
    `core`, and `gsutil`, are installed by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to run `gcloud init` to initialize the SDK using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you will be redirected to a browser window and will be asked
    to log in to your Google account for authentication and granting access to Cloud
    SDK for your Cloud resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'On clicking the **Allow** button, it will make sure that next time you can
    interact with the GCP API as yourself. After granting access, you will see the
    following screen confirming the authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Google Cloud SDK authentication completed'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.6_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.6 – Google Cloud SDK authentication completed
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you have authenticated yourself and are ready to work with Cloud SDK. You
    may see the following on the command line after completing the authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: From the command line output, it is clear we have selected the project and confirmed
    the Compute Engine region. Now, we have successfully installed Cloud SDK. In the
    next section, we will learn about Cloud Shell.
  prefs: []
  type: TYPE_NORMAL
- en: Using Cloud Shell
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Cloud Shell is a browser-based terminal/CLI and editor. It comes pre-installed
    with tools like Skaffold, minikube, and Docker, to name a few. It can be activated
    by clicking the following icon, available at the top right-hand side of the Cloud
    Console browser window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 – Activating Cloud Shell'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.7_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.7 – Activating Cloud Shell
  prefs: []
  type: TYPE_NORMAL
- en: 'You will be redirected to the following screen after activation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – Cloud Shell editor'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.8_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.8 – Cloud Shell editor
  prefs: []
  type: TYPE_NORMAL
- en: 'You can set your project ID by using the `gcloud config set project projectid`
    command, or just start playing around with `gcloud` commands. The following are
    some of the highlighted features that Cloud Shell provides:'
  prefs: []
  type: TYPE_NORMAL
- en: Cloud Shell is entirely browser-based, and you can access it from anywhere.
    The only requirement is internet connectivity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud Shell gives you a 5 GB persistent storage mounted to your `$HOME` directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud Shell comes with an online code editor. You can use it to build, test,
    and debug your applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud Shell also comes with a Git client installed so that you can clone and
    push changes to your repository from the code editor or command line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud Shell comes with a web preview in which you can view your local changes
    in a web app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have installed and configured Google Cloud SDK for our use. We have also
    looked at Cloud Shell and the features it provides. Now let's create a Kubernetes
    cluster where we can deploy our Spring Boot application.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Google Kubernetes Engine cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We would need to set up a Kubernetes cluster on GCP to deploy our containerized
    Spring Boot application. GCP can provide a hosted and managed deployment of Kubernetes.
    We can create a Kubernetes cluster on GCP using the following two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Kubernetes cluster using Google Cloud SDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Kubernetes cluster using Google Console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's discuss each of these in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Kubernetes cluster using Google Cloud SDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can create a Kubernetes cluster for running containers using the following
    gcloud SDK command. This will create a Kubernetes cluster with default settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/Figure_8.9_B17385.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 – GKE cluster up and running
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully created a Kubernetes cluster using Cloud SDK. Next, we
    will try to create the cluster using Google Console.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Kubernetes cluster using Google Console
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a Kubernetes cluster using the Console, you should first use the
    left-hand side navigation bar and choose **Kubernetes Engine**. In the presented
    option, select **Clusters**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10 – Getting started with Google Kubernetes Engine cluster creation'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.10_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.10 – Getting started with Google Kubernetes Engine cluster creation
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, you will see the following screen on the next page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11 – Creating a Google Kubernetes Engine cluster'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.11_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.11 – Creating a Google Kubernetes Engine cluster
  prefs: []
  type: TYPE_NORMAL
- en: You can choose to create the cluster by clicking on the **CREATE** button on
    the popup, or by clicking **+CREATE** at the top of the page. Both will give you
    the following options to choose from, as explained in *Figure 8.12:*
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12 – Google Kubernetes Engine cluster modes'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.12_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.12 – Google Kubernetes Engine cluster modes
  prefs: []
  type: TYPE_NORMAL
- en: You can choose to create a **Standard** Kubernetes cluster or a completely hands-off
    experience with **Autopilot** mode. In this section, we will discuss the Standard
    cluster. We will cover the Autopilot separately in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: In the Standard cluster mode, you have the flexibility to choose the number
    of nodes for your cluster and to tweak the configurations or setup as per your
    needs. The following is a walkthrough of creating a Kubernetes cluster. Since
    we are going with default configurations, you must click **Next** to accept the
    default options.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13 – Google Kubernetes Engine cluster creation'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.13_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.13 – Google Kubernetes Engine cluster creation
  prefs: []
  type: TYPE_NORMAL
- en: Finally, click on the **Create** button at the bottom of the page and voila,
    your Kubernetes cluster will be up and running in a few minutes!
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the default configurations for your cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14 – Google Kubernetes Engine cluster configuration view'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.14_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.14 – Google Kubernetes Engine cluster configuration view
  prefs: []
  type: TYPE_NORMAL
- en: 'Your Kubernetes cluster is now up and running. In the following screenshot,
    we can see that we have a three-node cluster with six vCPUs and 12 GB of total
    memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.15 – Google Kubernetes Engine cluster up and running'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.15_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.15 – Google Kubernetes Engine cluster up and running
  prefs: []
  type: TYPE_NORMAL
- en: 'You can view more details about your cluster nodes, storage, and view logs
    by clicking on the cluster name **cluster-1**. The following are the details of
    the cluster nodes we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.16 – Google Kubernetes Engine cluster view'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.16_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.16 – Google Kubernetes Engine cluster view
  prefs: []
  type: TYPE_NORMAL
- en: You can see that overall cluster status and node health is OK. The cluster nodes
    are created using Compute Engine GCP, and offering to have machine type as **e2-medium**.
    You can verify this by viewing the Compute Engine resources on the left-hand side
    navigation bar. We have the same three nodes shown here, and the GKE cluster uses
    these that we have just created.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.17 – Google Kubernetes Engine cluster VM instances'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.17_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.17 – Google Kubernetes Engine cluster VM instances
  prefs: []
  type: TYPE_NORMAL
- en: We have learned how to create a Kubernetes Standard cluster using Google Console.
    In the next section, we will learn about the Autopilot cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Google Kubernetes Engine Autopilot cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On February 24th, 2021, Google announced the general availability of their fully
    managed Kubernetes services, GKE Autopilot. It is a completely managed and serverless
    Kubernetes as a service offering. No other cloud provider currently offers this
    level of automation when managing the Kubernetes cluster on the cloud. Most cloud
    providers leave some cluster management for you, be it managing the control planes
    (**API server**, **etcd**, **scheduler**, and so on), worker nodes, or creating
    everything from scratch as per your needs.
  prefs: []
  type: TYPE_NORMAL
- en: GKE Autopilot, as the name suggests, is an entirely hands-off experience, and
    in most cases you only have to specify a cluster name and region, set the network
    if you want to, and that's it. You can focus on deploying your workloads and let
    Google fully manage your Kubernetes cluster. Google is offering 99.9% uptime for
    Autopilot pods in multiple zones. Even if you manage this yourself, you will not
    beat the number that Google is offering. On top of this, GKE Autopilot is cost-effective
    as you don't pay for **Virtual Machines** (**VMs**), and you are only billed per
    second for resources (for example, vCPU, memory, and disk space consumed by your
    pods).
  prefs: []
  type: TYPE_NORMAL
- en: 'So what''s the difference between a GKE Standard cluster like the one we created
    in the previous section and a GKE Autopilot cluster? The answer is as follows:
    with the Standard cluster, you manage only the nodes, as the GKE manages the control
    plane, and with GKE Autopilot, you don''t manage anything (not even your worker
    nodes).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This raises a question: is it a good or a bad thing that I cannot control my
    nodes? Now, this is debatable, but most organizations today are not handling traffic
    or loads like amazon.com, google.com, or netflix.com. It may be an oversimplification,
    but to be honest, even if you think you have specific needs or you need a specialized
    cluster, more often than not, you end up wasting a lot of time and resources in
    securing and managing your cluster. If you have a team of SRE that can match the
    level of experience or knowledge of Google SRE, you can do whatever you like with
    your cluster. But most organizations today don''t have such expertise and don''t
    know what they are doing. That''s why it is better to rely on fully managed Kubernetes
    services such as GKE Autopilot – it is battle-tested and hardened based on the
    best practices learned from Google SRE.'
  prefs: []
  type: TYPE_NORMAL
- en: We have talked enough about GKE Autopilot features and the complete abstraction
    it provides over how we manage the Kubernetes cluster. However, keeping these
    abstractions in mind, there are some restrictions as well. For example, you cannot
    run privileged mode for containers in the Autopilot mode. For a complete list
    of limitations, read the official documentation at [https://cloud.google.com/kubernetes-engine/docs/concepts/autopilot-overview#limits](https://cloud.google.com/kubernetes-engine/docs/concepts/autopilot-overview#limits).
  prefs: []
  type: TYPE_NORMAL
- en: We have gained enough knowledge about GKE Autopilot so far, and now it's time
    to create our cluster. So, let's begin!
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Autopilot cluster
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After clicking on the **Configure** button, as explained in *Figure 8.13*,
    you will be redirected to the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.18 – Creating a GKE Autopilot cluster'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.18_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.18 – Creating a GKE Autopilot cluster
  prefs: []
  type: TYPE_NORMAL
- en: Autopilot clusters have features such as node management, networking, security,
    and telemetry already built-in with Google-recommended best practices. GKE Autopilot
    makes sure that your cluster is optimized and production-ready.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, you have very few options to change here. You can change the
    **Name** of the cluster, pick another **Region**, or choose the **Networking**
    (that is, public or private). Under **NETWORKING OPTIONS**, you can change things
    like network, subnetwork, pod IP address range and cluster services IP address
    range, and so on, as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.19 – GKE Autopilot cluster configurations'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.19_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.19 – GKE Autopilot cluster configurations
  prefs: []
  type: TYPE_NORMAL
- en: Under **ADVANCED OPTIONS**, you can enable a maintenance window and also allow
    maintenance exclusion for a specific time range (as seen in *Figure 8.19*). In
    this window, your GKE cluster will go for an automated maintenance window and
    will not be available for your use. You should choose a maintenance window as
    per your needs.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.20 – Configuring a GKE Autopilot cluster maintenance window'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.20_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.20 – Configuring a GKE Autopilot cluster maintenance window
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, we will go with default values and click on the **CREATE** button
    at the bottom of the page to create the cluster. It may take a few minutes to
    create your cluster. In the following screenshot, you can see the Autopilot cluster
    is up and running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.21 – GKE Autopilot cluster up and running'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.21_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.21 – GKE Autopilot cluster up and running
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see that the number of nodes is not mentioned, as it is managed
    by GKE.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can try connecting to this cluster. To do so, click on the three dots
    at the top right of your screen and click on **Connect**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.22 – Connecting to a GKE Autopilot cluster'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.22_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.22 – Connecting to a GKE Autopilot cluster
  prefs: []
  type: TYPE_NORMAL
- en: 'After clicking on **Connect**, the following popup should appear. You can copy
    the command mentioned here into your CLI or Cloud Shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.23 – Commands for connecting to a GKE Autopilot cluster'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.23_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.23 – Commands for connecting to a GKE Autopilot cluster
  prefs: []
  type: TYPE_NORMAL
- en: 'Then you can verify the cluster details by using the following `kubectl get
    nodes` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/Figure_8.24_B17385.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.24 – kubectl command output
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also create GKE cluster in autopilot mode using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/Figure_8.25_B17385.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.25 – GKE cluster in autopilot
  prefs: []
  type: TYPE_NORMAL
- en: We can further verify this on Google Cloud Console as well. You can see that
    we now have two clusters. The first is created using Cloud Console and the second
    using the command line with gcloud.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.26 – GKE Autopilot and Standard mode cluster'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.26_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.26 – GKE Autopilot clusters
  prefs: []
  type: TYPE_NORMAL
- en: We have gone through the different ways of creating the Kubernetes cluster on
    GCP. Now, let's deploy a working Spring Boot application to the GKE using Skaffold.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a Spring Boot application to the GKE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Spring Boot application that we will use in this section is the same as
    in the previous chapter (the application we named *Breathe – View Real-Time Air
    Quality Data*). We are already familiar with the application, so we will directly
    jump to the deployment to the GKE. We will be using `gke-autopilot-cluster1` we
    created in the previous section for deployment. We will do the deployment using
    the following two approaches using Skaffold:'
  prefs: []
  type: TYPE_NORMAL
- en: Deploying from local to a remote GKE cluster using Skaffold
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying from Cloud Shell to a GKE cluster using Skaffold
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying from local to a remote GKE cluster using Skaffold
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, you will learn how you can deploy the Spring Boot application
    to a remote Kubernetes cluster with the help of Skaffold. Let''s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we used **Dockerfile** to containerize our Spring Boot
    application. However, in this chapter, we will be using the `Jib-Maven` plugin
    to containerize the application. We already know how to use the jib-maven plugin
    from previous chapters, so we will skip explaining this again here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The only change is that we will be using the **Google Container Registry**
    (**GCR**) for storing the image pushed by Jib. GCR is a secure private registry
    for your images. Before that, we would need to make sure that GCR access is enabled
    for your account. You can allow access by using the following `gcloud` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Or you can navigate to [https://cloud.google.com/container-registry/docs/quickstart](https://cloud.google.com/container-registry/docs/quickstart)
    and enable the Container Registry API by clicking on the **Enable the API** button.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.27 – Enabling Google Container Registry API'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.27_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.27 – Enabling Google Container Registry API
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will be asked to choose a project and then click on **Continue**.
    That's it!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.28 – Register your application for Container Registry API'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.28_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.28 – Register your application for Container Registry API
  prefs: []
  type: TYPE_NORMAL
- en: You can make the images under your container registry available for public access
    as well. Users of your images can pull the images without any authentication if
    they are public. In the following screenshot, you can see an option, **Enable
    Vulnerability Scanning**, for images pushed to your container registry. If you
    want, you can allow it to scan your container images for vulnerabilities.![Figure
    8.29 – GCR settings
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_8.29_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.29 – GCR settings
  prefs: []
  type: TYPE_NORMAL
- en: The next piece of the puzzle is to create Kubernetes manifests such as **Deployment**
    and **Service**. In the previous chapter, we created them using the **Dekorate**
    tool ([https://github.com/dekorateio/dekorate](https://github.com/dekorateio/dekorate)).
    We will be using the same Kubernetes manifest generation process here as well.
    The generated Kubernetes manifests are available under the `target/classes/META-INF/dekorate/kubernetes.yml`
    path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we will run the `skaffold init --XXenableJibInit` command, which will
    create a `skaffold.yaml` configuration file for us. You can see that Skaffold
    added the Kubernetes manifest''s path in the generated `deploy` section of the
    `skaffold.yaml` file and will use `jib` for image building:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We have the same main class as explained in the previous chapter, which uses
    the `@KubernetesApplication` `(serviceType = ServiceType.LoadBalancer)` annotation
    provided by the Dekorate tool to declare the service type as `LoadBalancer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: At the time of compilation, Dekorate will generate the following Kubernetes
    manifests. I have also kept them in the k8s directory in the source code, as sometimes
    we have to manually add or remove things from Kubernetes manifests. The Deployment
    and Service Kubernetes manifests can also be found on GitHub at [https://github.com/PacktPublishing/Effortless-Cloud-Native-App-Development-Using-Skaffold/blob/main/Chapter07/k8s/kubernetes.yml](https://github.com/PacktPublishing/Effortless-Cloud-Native-App-Development-Using-Skaffold/blob/main/Chapter07/k8s/kubernetes.yml).
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we need to make sure that you are authenticated to use Google Cloud
    services using the `gcloud auth list` command. You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If you are not authenticated, you can also use the `gcloud auth login` command.
  prefs: []
  type: TYPE_NORMAL
- en: If it is not already set, set your GCP project using the `gcloud config set
    project <PROJECT_ID>` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure that the Kubernetes context is set to remote Google Kubernetes cluster.
    Use the following command to verify that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready for deployment. Let's run the `skaffold run --default-repo=gcr.io/<PROJECT_ID>`
    command.  This will build the container image of the application. Push it to the
    remote GCR.![Figure 8.30 – Image pushed to Google Container Registry
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_8.30_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.30 – Image pushed to Google Container Registry
  prefs: []
  type: TYPE_NORMAL
- en: 'The pushed image details can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.31 – Google Container Registry image view'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.31_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.31 – Google Container Registry image view
  prefs: []
  type: TYPE_NORMAL
- en: Finally, deploy it to a remote Google Kubernetes cluster. It takes some time
    to stabilize the deployment when you run it for the first time, but subsequent
    runs are much faster.![Figure 8.32 – Skaffold run output
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_8.32_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.32 – Skaffold run output
  prefs: []
  type: TYPE_NORMAL
- en: We can also view the Deployment status on Google Cloud Console. Go to **Kubernetes
    Engine**, then click on the **Workloads** tab on the left-hand side navigation
    bar to view the deployment status. The Deployment status is **OK**.![Figure 8.33
    – Deployment status
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_8.33_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.33 – Deployment status
  prefs: []
  type: TYPE_NORMAL
- en: You can view further **Deployment** details by clicking on the application's
    name.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.34 – Deployment details'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.34_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.34 – Deployment details
  prefs: []
  type: TYPE_NORMAL
- en: Everything looks great so far. Now we just need the IP address of the service
    so that we can access our application. On the same Deployment details page at
    the bottom, we have details about our service.![Figure 8.35 – Exposed services
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_8.35_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.35 – Exposed services
  prefs: []
  type: TYPE_NORMAL
- en: Let's hit the URL and verify if we get the desired output or not. We can view
    the real-time air quality data for Delhi:![Figure 8.36 – Spring Boot application
    response
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_8.36_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.36 – Spring Boot application response
  prefs: []
  type: TYPE_NORMAL
- en: We can verify the health of the application using actuator `/health/liveness`
    and `/health/readiness` endpoints. We have used these endpoints as liveness and
    readiness probes for pods deployed to the Kubernetes cluster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.37 – Spring Boot application actuator probes'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.37_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.37 – Spring Boot application actuator probes
  prefs: []
  type: TYPE_NORMAL
- en: With these steps, we have completed the deployment of our Spring Boot application
    to a remote Google Kubernetes cluster from a local workstation using Skaffold.
    In the next section, we will learn about deploying the application from a browser-based
    Cloud Shell environment to the GKE.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying from Cloud Shell to a GKE cluster using Skaffold
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, the focus will be on deploying the Spring Boot application
    to the GKE using the browser-based Cloud Shell tool. Let's begin!
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to activate the Cloud Shell environment. This can be done
    by clicking on the **Activate Cloud Shell** icon in the top-right corner of Google
    Cloud Console.![Figure 8.38 – Cloud Shell editor
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_8.38_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.38 – Cloud Shell editor
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, you are asked to set your Cloud `PROJECT_ID`
    with the `gcloud config set project [PROJECT_ID]` command. You can use this if
    you know your `PROJECT_ID` or use commands like `gcloud projects list`. After
    this, Cloud Shell would ask for permission to authorize your request by making
    a call to the GCP API. You don't have to provide credentials for each request
    after this authorization.![Figure 8.39 – Authorizing Cloud Shell
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_8.39_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.39 – Authorizing Cloud Shell
  prefs: []
  type: TYPE_NORMAL
- en: We need the source code of the application in the Cloud Shell environment. Cloud
    Shell comes with a Git client installed, so we can run the `git clone` [https://github.com/PacktPublishing/Effortless-Cloud-Native-App-Development-using-Skaffold.git](https://github.com/PacktPublishing/Effortless-Cloud-Native-App-Development-using-Skaffold.git)
    command and clone our GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.40 – Cloning the GitHub repository'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.40_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.40 – Cloning the GitHub repository
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you need to compile the project so that you can generate Kubernetes manifests.
    Run the `./mvnw clean compile` command to build your project. Your build will
    fail and you will get an error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason for this failure is that `JAVA_HOME` is set to Java 11 in the Cloud
    Shell environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We have specified in `pomx.ml` to use Java 16\. This problem can be solved by
    downloading Java 16 and setting the `JAVA_HOME` environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We have the right tool to solve this problem, **SDKMAN**, that can be accessed
    from [https://sdkman.io/](https://sdkman.io/). It allows you to work in parallel
    with multiple versions of **Java JDK**s. Check out the supported JDKs ([https://sdkman.io/jdks](https://sdkman.io/jdks))
    and SDKs ([https://sdkman.io/sdks](https://sdkman.io/sdks)). With the new six
    months release cycle, we get a new JDK every six months. As developers, we love
    to try and explore these features by manually downloading and changing `JAVA_HOME`
    if we need to switch to a different JDK. This whole process is manual, and with
    `SDKMAN`, we just have run a single command to download a JDK of your choice,
    and after downloading, it will even update `JAVA_HOME` to the latest downloaded
    JDK. Cool, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: Let's try to install JDK16 with SDKMAN. Note that you don't have to install
    SDKMAN in your Cloud Shell provisioned VM instance as it comes pre-installed.
    Now enter `sdk` in your CLI, and it will show you the supported commands:![Figure
    8.41 – SDKMAN commands help
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_8.41_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.41 – SDKMAN commands help
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn about different supported JDKs, run the `sdk list java` command. In
    the following screenshot, you won''t be able to see all of the supported JDK vendors,
    but you get the idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.42 – SDKMAN supported JDKs'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.42_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.42 – SDKMAN supported JDKs
  prefs: []
  type: TYPE_NORMAL
- en: To download a vendor-specific JDK, run the `sdk install java Identifier` command.
    In our case, the actual command will be `sdk install java 16-open`, since we have
    decided to use the OpenJDK build of Java 16\.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.43 – Installing JDK16'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.43_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.43 – Installing JDK16
  prefs: []
  type: TYPE_NORMAL
- en: 'You might also want to run the following command to change the JDK in your
    active shell session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Let's compile the project again by running the `./mvnw clean compile` command.
    In the following output, you can see that the build is successful:![Figure 8.44
    – Maven build success
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_8.44_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.44 – Maven build success
  prefs: []
  type: TYPE_NORMAL
- en: We are ready to run the command to deploy the Spring Boot application to the
    remote GKE cluster from Cloud Shell. Before that, make sure that your Kubernetes
    context is set to the remote cluster. If you are not sure, then verify it by running
    the `kubectl config current-context` command. If it is not set, then set it using
    the `gcloud container clusters get-credentials gke-autopilot-cluster1 --region
    us-east1` command, which will add the entry in the `kubeconfig` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the last step, we just have to run the `skaffold run --default-repo=gcr.io/<PROJECT_ID>`
    command. The deployment is stabilized, and the final output is going to be the
    same as seen in *step 13* in the previous section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.45 – Skaffold run output'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.45_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.45 – Skaffold run output
  prefs: []
  type: TYPE_NORMAL
- en: 'This completes the deployment of the Spring Boot application to the remote
    GKE cluster using the browser-based Cloud Shell environment. We have learned how
    we can leverage the browser-based preconfigured Cloud Shell environment for development
    purposes. If you want to play around with and try things, then this is an excellent
    feature provided by Google. However, I am not sure if you should be using it for
    your production use cases. The Google Compute Engine VM instances that are provisioned
    with Cloud Shell are provided on a per-user, per-session basis. Your VM instances
    will persist if your session is active; otherwise, they will get discarded. For
    information about the working of Cloud Shell, please go through the official documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://cloud.google.com/shell/docs/how-cloud-shell-works](https://cloud.google.com/shell/docs/how-cloud-shell-works)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started by discussing the features and advantages of using
    cloud vendors. Then, we introduced you to the GCP. First, we covered a detailed
    walkthrough of how you can get onboard to the Cloud Platform. Next, we covered
    Google Cloud SDK, which allows you to perform various tasks such as installing
    components, creating Kubernetes clusters, and enabling different services such
    as Google Container Registry and more.
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed the browser-based Cloud Shell editor, which is powered by
    Google Compute Engine VM instances. You can use this as a temporary sandbox environment
    to test various services supported by GCP. Then, we looked at two different ways
    of creating a Kubernetes cluster using Cloud SDK and Cloud Console. After that,
    we introduced you to the serverless Kubernetes offering, GKE Autopilot, and covered
    its features and advantages over standard Kubernetes clusters. Finally, we successfully
    deployed a Spring Boot application to the GKE Autopilot cluster using Skaffold
    from local and then Google Cloud Shell in the last section.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you have gained practical knowledge of GCP's managed Kubernetes
    service, as well as tools like Cloud SDK and Cloud Shell. You have also learned
    how you can use Skaffold to deploy a Spring Boot application to a remote Kubernetes
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about creating a CI/CD pipeline using GitHub
    actions and Skaffold.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Learn more about GKE autopilot: [https://cloud.google.com/blog/products/containers-kubernetes/introducing-gke-autopilot](https://cloud.google.com/blog/products/containers-kubernetes/introducing-gke-autopilot)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Learn more about Google Cloud Platform: [https://cloud.google.com/docs](https://cloud.google.com/docs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Google Cloud Platform for Architects: [https://www.packtpub.com/product/google-cloud-platform-for-architects/9781788834308](https://www.packtpub.com/product/google-cloud-platform-for-architects/9781788834308)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
