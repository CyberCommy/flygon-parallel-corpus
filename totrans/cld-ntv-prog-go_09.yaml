- en: Continuous Delivery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous three chapters, you learned about modern container technologies
    and cloud environments, how to create container images from your application (or,
    more precisely, the MyEvents application), and how to deploy them into these environments.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to adopt **continuous integration** (**CI**)
    and **continuous delivery** (**CD**) for anjhalocvhurty your application. CI describes
    a practice in which you continuously build and verify your software project (ideally,
    on each and every change made to your software). CD extends this approach by also
    continually deploying your application in very short release cycles (in this case,
    of course, into a cloud environment).
  prefs: []
  type: TYPE_NORMAL
- en: Both of these approaches require a high degree of automation to work reliably,
    both concerning your application's build and deployment processes. In previous
    chapters, we have already looked at how you can use container technologies to
    deploy your application. Since technologies such as Docker and Kubernetes are
    easily automated, they usually integrate very well with CD.
  prefs: []
  type: TYPE_NORMAL
- en: In the course of this chapter, you will learn how to set up your project for
    adopting CI and CD (for example, by setting up proper version control and dependency
    management). We will also introduce a few popular tools that you can use to trigger
    new builds and releases automatically whenever your application's code changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing a Go project in version control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using dependency vendoring for reproducible builds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Travis CI and/or GitLab to automatically build your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatically deploying your application to a Kubernetes cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up your project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before actually implementing continuous delivery for our project, let's start
    by making some preparations. Later, these will make it easier for the tools that
    we will use to easily build and deploy your application in an automated way.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up version control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before automatically building your application, you will need a place to store
    your application's source code. This is typically the job of a **version control
    system** (**VCS**). Often, the tools that enable you to do continuous delivery
    are tightly integrated with version control systems, for example, by triggering
    a new build and deployment of your application whenever the source code is changed.
  prefs: []
  type: TYPE_NORMAL
- en: If you did not do this already on your own, your first step should now be to
    put your existing code base into a VCS. In this example, we will be working with
    the current de facto standard VCS, Git. Although there are many other version
    control systems, Git is the most widely adopted; you will find many providers
    and tools that offer you Git repositories as a managed service or for self-hosting.
    Also, many (if not most) CD tools are integrated with Git.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the remainder of this chapter, we will assume that you are familiar with
    the basic workings of Git. If you wish to read up on how to work with Git, we
    recommend the book *Git: Mastering Version Control* by *Ferdinando Santacroce
    et al.*, also published by Packt.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also assume that you have two remote Git repositories available where
    you can push your Go application source code and the frontend application source
    code. For the first continuous delivery tool that we will be working with, we
    will assume that your repositories are hosted at GitHub at the following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`git+ssh://git@github.com/<user>/myevents.git`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git+ssh://git@github.com/<user>/myevents-frontend.git`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, the actual repository URLs will vary according to your username.
    In the following examples, we will use `<user>` consistently as a placeholder
    for your GitHub username, so remember to replace it with your actual username
    whenever necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can start by setting up a local Git repository to track changes to your
    source code on your local machine. To initialize a new Git repository, run the
    following command in your Go project''s root directory (typically, `todo.com/myevents`
    in your GOPATH directory):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will set up a new Git repository, but not add any files to version control,
    yet. Before actually adding any files to your repository, configure a `.gitignore`
    file that prevents Git from adding your compiled files to version control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After having created the `.gitignore` file, run the following commands to add
    your current code base to the version control system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, configure your remote repository using the `git remote` command and push
    your source code using `git push`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Having a working source code repository is the first step to building a continuous
    integration/delivery pipeline. In the following steps, we will configure CI/CD
    tools to build and deploy your application whenever you push new code into the
    master branch of your remote Git repository.
  prefs: []
  type: TYPE_NORMAL
- en: Use the same Git commands to create a new Git repository for your frontend application,
    and to push it to a remote repository on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Vendoring your dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we have simply installed Go libraries that we needed for the MyEvents
    application (such as the `gopkg.in/mgo.v2` or the `github.com/gorilla/mux` packages)
    using the `go get` command. Although this works reasonably well for development,
    installing dependencies using `go get` has one significant disadvantage, that
    is, each time you run `go get` on a package that has not yet been downloaded,
    it will get the most recent version of that library (technically, the latest *master*
    branch of the respective source code repository). This can have nasty consequences;
    imagine that you have cloned your repository at one point in time and installed
    all dependencies using `go get ./...`. A week later, you repeat these steps, but
    may now wind up with completely different versions of your dependencies (libraries
    that are actively maintained and developed may get dozens of new commits to its
    master branch each day). This is especially critical if one of these changes changed
    the libraries' API, which may result in your code not compiling anymore from one
    day to the next.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this issue, Go 1.6 introduced the concept of **vendoring**. Using vendoring
    allows you to copy libraries that your project requires into a `vendor/` directory
    within your package (so, in our case, `todo.com/myevents/vendor/` will contain
    directories such as `todo.com/myevents/vendor/github.com/gorilla/mux/`). When
    running `go build` to compile a package, libraries from the `vendor/` directory
    will be favored over libraries in your GOPATH. You can then simply put the `vendor/`
    directory into version control alongside your application code and have reproducible
    builds when cloning your source code repository.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, manually copying libraries into your package's `vendor/` directory
    quickly becomes tedious. Typically, this work is being done by **dependency managers**.
    Currently, there are multiple dependency managers for Go, the most popular being
    **Godep** and **Glide**. These are both community projects; an official dependency
    manager, simply called **dep**, is currently in development and already considered
    safe for production use, but was, at the time of writing this book, still designated
    as an experiment.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information on dep at [https://github.com/golang/dep](https://github.com/golang/dep).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we will populate our application''s `vendor/` directory using
    Glide. First of all, install Glide by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This will place a glide executable in your `$GOPATH/bin` directory. If you
    want to use glide globally, you can copy it from there into your path as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Glide works similar to package managers that you might know from other programming
    languages (for example, npm for Node.js or Compose for PHP). It operates by reading
    a `glide.yaml` file from your package directory. In this file, you declare all
    dependencies that your application has and can optionally provide specific versions
    of these libraries that Glide should install for you. To create a `glide.yaml`
    file from an existing application, run the `glide init .` command in your package
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: While initializing your project, Glide will inspect the libraries used by your
    application and try to automatically optimize your dependency declaration. For
    example, if Glide finds a library that provides stable versions (usually, Git
    tags), it will prompt you whether you would prefer using the latest of these stable
    versions instead of the (potentially more unstable) master branch of a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'When running `glide init`, it will produce an output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d741911d-8bef-4db2-bcc7-34bad737e478.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `glide init` command will create a `glide.yaml` file in your application''s
    root directory in which all required dependencies are declared. For the MyEvents
    application, this file should look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `glide.yaml` file declares which dependencies your project requires. After
    creating this file, you can run the `glide update` command to actually resolve
    the declared dependencies and download them into your `vendor/` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the preceding screenshot, `glide update` will not only download
    the dependencies declared in your `glide.yaml` file into the `vendor/` directory,
    but also their dependencies. In the end, Glide will recursively download the entire
    dependency tree of your application and place it in the `vendor/` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bff51f22-c24e-4569-8fd8-5f46b49ee7eb.png)'
  prefs: []
  type: TYPE_IMG
- en: For each package it downloaded, Glide will write the exact version into a new
    file, `glide.lock` (you can take a look at this file by opening it, but it is
    really not meant to be edited manually). The `glide.lock` file allows you to reconstruct
    this exact set of dependencies with their exact versions at any later moment in
    time by running `glide install`. You can verify this behavior by deleting your
    `vendor/` directory and then running `glide install`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having a `vendor/` directory and the Glide configuration files leaves you with
    the following two options:'
  prefs: []
  type: TYPE_NORMAL
- en: You can place your entire `vendor/` directory into version control alongside
    your actual application files. The upside of this is that now anyone can clone
    your repository (anyone, in this case, includes CI/CD tools that want to build
    and deploy your code) and have all dependencies in their exact required versions
    readily available. This way, building your application from scratch is literally
    nothing more than a `git clone` or `go build` command. On the downside, your source
    code repository grows larger and may take more disk space to store and more time
    to clone.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, you can just place the `glide.yaml` and `glide.lock` files into
    version control and exclude the `vendor/` directory from version control by adding
    it to the `.gitignore` file. On the upside, this makes your repository smaller
    and faster to clone. However, after cloning your repository, users will now need
    to explicitly run `glide install` to download the dependencies specified in your
    `glide.lock` file from the internet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Both of these options work reasonably well, so ultimately this is a matter
    of personal taste. Since repository size and disk space are rarely a consideration
    these days, and because it makes the build process significantly easier, my personal
    preference is to put my entire `vendor/` directory into version control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This takes care of our backend services, but there is also still the frontend
    application that we need to consider. Since we have been using npm to install
    our dependencies in [Chapter 5](82bdbb64-f1d4-42fb-9532-ecd5feca2ba7.xhtml), *Building
    a Frontend with React*, most of the work has been already done for us. Interestingly,
    the exact same argument about whether to put dependencies into version control
    or not (in this case, the `node_modules/` directory instead of `vendor/`) also
    applies to npm. Also, yes, just as with Go''s `vendor/` directory, I prefer to
    put my entire `node_modules/` directory in version control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Explicitly declaring your project's dependencies (including the used versions)
    is a big step to ensure reproducible builds. Depending on whether you chose to
    include your dependencies into version control or not, users have either the entire
    application source code (including dependencies) readily available directly after
    cloning the source code repository or can at least easily reconstruct it by running
    `glide install` or `npm install`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our project put in version control and have explicitly declared
    dependencies, we can take a look at some of the most popular CI/CD tools that
    you can use to continuously build and deploy your application.
  prefs: []
  type: TYPE_NORMAL
- en: Using Travis CI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Travis CI** is a hosted service for continuous integration. It is very tightly
    coupled to GitHub (which is why you will need a Git repository on GitHub to actually
    use Travis CI). It is free to use for open source projects, which, together with
    its good GitHub integration, makes it the go-to choice for many popular projects.
    For building private GitHub projects, there is a paid usage model.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration of your Travis build is done by a `.travis.yml` file that
    needs to be present at the root level of your repository. Basically, this file
    can look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `language` property describes which programming language your project is
    written in. Depending on whichever language you provide here, you will have different
    tools available in your build environment. The `go` property describes for which
    versions of Go your application should be built. Testing your code for multiple
    versions of Go is especially important for libraries that might be used by a multitude
    of users in potentially very different environments. The `env` property contains
    environment variables that should be passed into the built environment. Note that
    we have used the `CGO_ENABLED` environment variable before in [Chapter 6](af835c34-a409-4898-9a55-74fc9d05b46b.xhtml),
    *Deploying Your Application in Containers*, to instruct the Go compiler to produce
    statically linked binaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `install` property describes the steps necessary to set up your application''s
    dependencies. If left out entirely, Travis will automatically run `go get ./...`
    to download the latest versions of all our dependencies (which is exactly what
    we do not want). The `install: true` property actually instructs Travis not to
    do anything to set up our dependencies, which is exactly the way to go if your
    dependencies have been already included in your source code repository.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you decided not to include your `vendor/` directory in version control,
    the install step needs to contain instructions for Travis to download Glide and
    then use it to install your project''s dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `script` property then contains the commands that Travis should run to
    actually build your project. The most obvious step to build your application is,
    of course, the `go build` command. Of course, you can add additional steps here.
    For example, you could use the `go vet` command to check your source code for
    common errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `$(go list ./... | grep -v vendor)` command is a special hack used to instruct
    `go vet` not to analyze the `vendor/` source code in your package directory. Otherwise,
    `go vet` would probably complain about a lot of issues in your project's dependencies
    that you would not want to (or even can not) fix, anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating the `.travis.yml` file, add it to version control and push it
    into the remote repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have a *.travis.yml* file in your repository, you can enable the
    Travis build for this repository. For this, sign in to Travis CI on [https://travis-ci.org](https://travis-ci.org)
    (or [https://travis-ci.com](https://travis-ci.com) if you are planning to use
    the paid tier) using your GitHub credentials. After signing in, you will find
    a list of your publicly available GitHub repositories, alongside a switch that
    allows you to enable Travis builds for each repository (just as in the following
    screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/16b2df49-adb2-4bc2-9640-7f1178f4f7d8.png)'
  prefs: []
  type: TYPE_IMG
- en: Go ahead and enable both the `myevents` and `myevents-frontend` repositories
    (it's not that bad if there's no `.travis.yml` file in one of these repositories,
    yet).
  prefs: []
  type: TYPE_NORMAL
- en: After enabling your project in the Travis user interface, the next Git push
    into your repository will automatically trigger a build on Travis. You can test
    this, for example, by making a small change to your code or by just adding a new
    empty text file somewhere and pushing it to GitHub. In the Travis user interface,
    you will note a new build popping up for your project quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The build will run for a while (it may take a while from the build being scheduled
    to the actual execution). After that, you will see whether the build was completed
    successfully or whether errors occurred (you will also receive a notification
    via email in the latter case), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88e50e75-5a21-4d8c-905d-1f5e5d6d0187.png)'
  prefs: []
  type: TYPE_IMG
- en: If you have specified multiple Go versions to test against, you will note multiple
    build jobs for each commit (just like in the preceding screenshot). Click on any
    one of them to receive a detailed build output. This is especially useful if your
    build should fail for any reason (which is entirely possible when you push code
    that does not pass `go vet` or does not even compile).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4724ad2c-300e-4671-af09-0060ff769771.png)'
  prefs: []
  type: TYPE_IMG
- en: In general, Travis integrates with GitHub really well. In the GitHub UI, you
    will also see the current build status of each commit and can also use Travis
    to verify pull requests before they are being merged into the master branch.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have used Travis to verify that the code in the repository does not
    contain any errors and compiles (which is typically the goal of continuous integration).
    However, we have not yet configured any actual deployment of your application.
    This is what we'll be doing in the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within a Travis build, you can use Docker to build and run container images.
    To enable Docker support, add the following properties to the top of your `.travis.yml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Since we do not actually want to build Docker images for multiple different
    versions of Go, it is also completely alright to remove the Go versions 1.6 to
    1.8 from the Travis file.
  prefs: []
  type: TYPE_NORMAL
- en: 'As our project actually consists of two deployment artifacts (event service
    and booking service), there is another optimization that we can make: we can use
    a build matrix to build both of these services in parallel. For this, add an `env`
    property to your `.travis.yml` file and adjust the `script` property, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: With this configuration, Travis will start two build jobs for each change in
    your code repository, each of those building one of the two services contained
    in that repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, you can add a `docker image build` command to the `script` property
    to build a container image from the compiled service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command builds a Docker image named either `myevents/eventservice`
    or `myevents/bookingservice` (dependent on the current value of `$SERVICE`). The
    Docker image is built with the current branch (or Git tag) name as the tag. This
    means that a new push to the *master* branch will result in a `myevents/eventservice:master` image being
    built. When a Git tag named *v1.2.3* is pushed, a `myevents/eventservice:v1.2.3`
    image will be created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, you will need to push the new Docker image to a registry. For this,
    add a new property, `after_success`, to your `.travis.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The commands specified in `after_success` will be run after all commands in
    `scripts` have successfully been completed. In this case, we are checking the
    content of the `$TRAVIS_TAG` environment variable; as a consequence, only Docker
    images built for Git tags will actually be pushed to the remote registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using a different Docker Image Registry than the Docker Hub, remember
    to specify the registry''s URL in the `docker login` command. For example, when
    using `quay.io` as registry, the command should look as follows: `docker login
    -u="${DOCKER_USERNAME}" -p"${DOCKER_PASSWORD}" quay.io`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this command to work, you will need to have the environment variables `$DOCKER_USERNAME`
    and `$DOCKER_PASSWORD` defined. In theory, you could define these in the `env`
    section of your `.travis.yml` file. However, for sensitive data such as passwords,
    it would be a massively stupid idea to define them in a publicly available file
    for everyone to see. Instead, you should use the Travis user interface to configure
    these variables for your build. For this, go to the Settings page of your project,
    which you will find when clicking on the More options button on your project overview
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66335f96-033a-4f38-bb3c-71714e5d2844.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the project settings, you will find a section labeled Environment Variables.
    Configure your Docker Registry credentials here by specifying the `DOCKER_USERNAME`
    and `DOCKER_PASSWORD` variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2472861-3242-4f9d-9a2d-a8fa53dafc32.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Alternatively, you can add secret variables to your `.travis.yml` file by encrypting
    them before placing them in version control. For this, you will need the Travis
    command-line client CLI. Travis CLI is a Ruby tool that you can install via the
    Ruby package manager, `gem`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, you can use the Travis CLI to encrypt a variable and automatically
    add it to your `.travis.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This will add a new variable to your `.travis.yml` file that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Both adding your secret variables via the Travis UI and encrypting and adding
    them to your `.travis.yml` file are valid approaches for handling sensitive data
    in Travis builds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the new build configuration in `.travis.yml` and push it to GitHub. To
    build and publish a new Docker image, you can now push a new `git` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: At this point, Travis CI will pull your code, compile all your Go binaries,
    and publish two Docker images for the two backend services to the Docker registry
    configured in your build configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will still need to add a similar build configuration for the frontend application.
    Actually, the steps for building the Docker image are exactly identical; however,
    instead of `go build`, we will need to run the Webpack module bundler. The following
    is a `.travis.yml` file that should cover the entire frontend build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Deploying to Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using GitHub and Travis, we have now automated the entire workflow from changing
    the application's source code over building new binaries to creating new Docker
    images and pushing them to a container registry. That is great, but we are still
    missing one crucial step, that is, getting the new container images to run in
    your production environment.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapters, you have already worked with Kubernetes and deployed
    your containerized applications into a Minikube environment. For this section,
    we will assume that you already have a publicly accessible Kubernetes environment
    up and running (for example, using a `kops`-provisioned cluster in AWS or the
    Azure Container Service).
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, Travis CI will need to access your Kubernetes cluster. For this,
    you can create a **service account** in your Kubernetes cluster. This Service
    Account will then receive an API token that you can configure as a secret environment
    variable in your Travis build. To create a service account, run the following
    command on your local machine (assuming that you have `kubectl` set up to communicate
    with your Kubernetes cluster):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will create a new service account named `travis-ci` and
    a new secret object that contains that account''s API token. To determine the
    secret, now run the `kubectl describe serviceaccount travis-ci` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the token secret name (in this case, `travis-ci-token-mtxrh`) to access
    the actual API token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You will need both the `ca.crt` and the `token` properties. Both of these values
    are BASE64-encoded, so you will need to pipe both values through `base64 --decode`
    to access the actual values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Together with the API server's URL, these two values can be used to authenticate
    against a Kubernetes cluster from Travis CI (or other CI/CD tools).
  prefs: []
  type: TYPE_NORMAL
- en: 'To actually configure the Kubernetes deployment in your Travis CI build, start
    by setting up `kubectl` in your builds by adding the following commands to your
    `install` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: For these steps to work, you will need to have the environment variables `$KUBE_CA_CERT`
    and `$KUBE_TOKEN` configured as secret environment variables in your Travis CI
    settings with the values that you took from the preceding `kubectl get secret`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'After having `kubectl` configured, you can now add an additional step to the
    `after_success` command of both your projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `kubectl set image` command will change the container image that should
    be used for a given Deployment object (in this case, assuming that you have deployments
    named `eventservice` and `bookingservice`). The Kubernetes deployment controller
    will then proceed to create new Pods with the new container image and shut down
    the Pods running the old image.
  prefs: []
  type: TYPE_NORMAL
- en: Using GitLab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitHub and Travis are excellent tools for building and deploying open source
    projects (and also private projects if you do not mind paying for their services).
    However, in some cases, you might want to host your source code management and
    CI/CD systems in your own environment instead of relying on an external service
    provider.
  prefs: []
  type: TYPE_NORMAL
- en: This is where GitLab comes into play. GitLab is a software that offers a service
    similar to GitHub and Travis combined (meaning source code management and CI)
    that you can host on your own infrastructure. In the following section, we will
    show you how to set up your own GitLab instance and build a build and deployment
    pipeline similar to the one built in the preceding section using GitLab and its
    CI features.
  prefs: []
  type: TYPE_NORMAL
- en: GitLab offers both an open source **Community Edition** (**CE**) and a paid-for
    **Enterprise Edition** (**EE**) that offers some additional features. For our
    purposes, the CE will do just fine.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up GitLab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can set up your own GitLab instance easily using the Docker images provided
    by the vendor. To start a GitLab CE server, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note the `GITLAB_OMNIBUS_CONFIG` environment variable that is passed into the
    container. This variable can be used to inject configuration code (written in
    Ruby) into the container; in this case, it is used to configure the GitLab instance's
    public HTTP address. When starting GitLab on your local machine, it is usually
    easiest to use your machine's public IP address for this (on Linux or macOS, use
    the `ifconfig` command to find it).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are setting up GitLab on a server for production usage (as opposed to
    on your local machine for experimentation), you might want to create two data
    volumes for configuration and repository data that you can then use in your container.
    This will allow you to easily upgrade your GitLab installation to a newer version
    later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: After creating the volumes, use the `-v gitlab-config:/etc/gitlab` and `-v gitlab-data:/var/opt/gitlab`
    flags in your `docker container run` command to actually use these volumes for
    your Gitlab instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The GitLab server running in the newly created container will probably take
    a few minutes to start up entirely. After that, you can access your GitLab instance
    at `http://localhost`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c04abec5-6eee-4d39-b32c-cb97723094e1.png)'
  prefs: []
  type: TYPE_IMG
- en: When opening GitLab for the first time in your browser, you will be prompted
    to set a new password for the initial user. After setting the password, you can
    sign in with the username `root` and the password that you set previously. If
    you are setting up a production instance of GitLab, your next step would now be
    to set up a new user that you can sign in as instead of root. For demo purposes,
    it is also alright to continue working as root.
  prefs: []
  type: TYPE_NORMAL
- en: 'After logging in for the first time, you will see a Start page on which you
    can create new groups and a new project. A GitLab project is (usually) always
    associated with a Git source code repository. In order to set up a CI/CD pipeline
    for the MyEvents application, proceed to create two new projects called `myevents`
    and `myevents-frontend`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07777c0a-aa0a-4247-9772-06718a2f6731.png)'
  prefs: []
  type: TYPE_IMG
- en: In order to push code into your new GitLab instance, you will need to provide
    an SSH public key for authentication. For this, click on your user icon in the
    upper-right corner, select Settings, and then the SSH Keys tab. Paste your SSH
    public key into the input field and save it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add your new GitLab repositories as remotes to your existing MyEvents
    repositories and push your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Proceed similarly for the frontend application. After this, you will be able
    to find your files in the GitLab web UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/92b3c8ba-ce38-4039-9d42-6c2ae24deb6c.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting up GitLab CI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to use GitLab''s CI feature, you will need to set up one additional
    component: the GitLab CI Runner. While GitLab itself is responsible for managing
    your application''s source code and deciding when to trigger a new CI build, the
    CI Runner is the component that is responsible for actually executing these jobs.
    Separating the actual GitLab container from the CI Runner allows you to distribute
    your CI infrastructure and have, for example, multiple runners on separate machines.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The GitLab CI Runner can also be set up using a Docker image. To set up the
    CI Runner, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'After starting the GitLab CI Runner, you will need to register it at the main
    GitLab instance. For this, you will need the runners registration token. You can
    find this token in the Admin Area of the GitLab UI. Access the Admin Area via
    the wrench icon in the upper-right corner, then select Runners. You will find
    the runners registration token in the first text paragraph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f25a2ddd-5d9c-476b-ae80-db15d56b0664.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To register your runner, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This command registers the previously started GitLab CI Runner at the main GitLab
    instance. The `--url` flag configures the URL that the main GitLab instance is
    reachable at (usually, this can be `http://gitlab` when your runner is on the
    same container network as your main Gitlab instance; alternatively, you can use
    your host machine's public IP address here, which in my case is `http://192.168.2.125/`).
    Next, copy and paste the registration token for the `--registration-token` flag.
    The `--executor` flag configures the GitLab CI Runner to run each build job in
    its own isolated Docker container. The `--docker-image` flag configures the Docker
    image that should be used as a build environment by default. The `--docker-volumes`
    flag ensures that you can use the Docker Engine from within your builds (this
    is especially important since we will be building our own Docker images within
    these builds).
  prefs: []
  type: TYPE_NORMAL
- en: Mounting the `/var/run/docker.sock` socket into your Gitlab Runner exposes the
    Docker engine that is running on your host to the users of your CI system. This
    might pose a security risk if you do not trust these users. Alternatively, you
    can set up a new Docker engine that itself runs in a container (called Docker-in-Docker).
    Refer to the GitLab documentation at [https://docs.gitlab.com/ce/ci/docker/using_docker_build.html#use-docker-in-docker-executor](https://docs.gitlab.com/ce/ci/docker/using_docker_build.html#use-docker-in-docker-executor)
    for detailed setup instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `docker exec` command should produce an output similar to the one in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e7c0c49-fc88-4de9-ae55-15cdf43c3c10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After the runner has been successfully registered, you should be able to find
    it in the GitLab administration UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/59e6a201-ec4f-4f53-ba09-fef9f12f571c.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that you have a working CI Runner, you can start configuring your actual
    CI jobs. Similarly to Travis CI, GitLab CI jobs are configured via a configuration
    file that is placed within the source code repository. Similarly to the already
    known `.travis.yml`, this file is named `.gitlab-ci.yml`. Although they are similarly
    named, their format is a little bit different.
  prefs: []
  type: TYPE_NORMAL
- en: Each GitLab CI configuration consists of multiple Stages (by default, build,
    test, and deploy, although this is completely customizable). Each stage can consist
    of an arbitrary number of Jobs. All stages together form a Pipeline. Each job
    of a pipeline is run in its own isolated Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the MyEvents backend services. Place a new file, `.gitlab-ci.yml`*, *in
    the root directory of your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: So, what does this code snippet actually do? First, it instructs the GitLab
    CI Runner to start this build within a Docker container based on the `golang:1.9.2`
    image. This ensures that you have access to the latest Go SDK in your build environment.
    The three commands in the `before_script` section take care of setting up a `$GOPATH`,
    and the one command in the `script` section is the actual compilation step.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this build configuration assumes that your project has all its dependencies
    vendored in version control. If you have just a `glide.yaml` file in your project,
    you will also need to set up Glide and run `glide install` before actually running
    `go build`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the artifacts property defines that the `eventservice` executable that
    was created by Go `build` should be archived as a build artifact. This will allow
    users to download this build artifact later. Also, the artifact will be available
    in later jobs of the same pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the `.gitlab-ci.yml` file to your source code repository and push
    it to the GitLab server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'When you have pushed the configuration file, head to your project page in the
    GitLab web UI and go to the Pipelines tab. You will find an overview of all build
    pipelines that were started for your project, and also their success:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/33e32a1a-00f5-495b-9f43-8f986ea74847.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Right now, our pipeline consists of only one stage (`build`) with one job (`build:eventservice`).
    You can see this in the Stages column of the `Pipelines` overview. To inspect
    the exact output of the `build:eventservice` job, click on the pipeline status
    icon and then on the `build:eventservice` job:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c40d302-b4a0-4296-9cec-2e86e028362f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we can extend our `.gitlab-ci.yml` configuration file to also include
    the build for the booking service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'When you push your code again, you will note that the next Pipeline started
    for your project consists of two jobs that run in parallel (more or less, depending
    on the configuration of the GitLab CI Runner and its current workload):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a64c80c-9044-4845-86c9-aaee701680d0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we can add two jobs that build the actual Docker images. These jobs need
    to be executed after the already configured build steps, because we will need
    the compiled Go binaries to create the Docker images. Owing to this, we cannot
    configure the docker build steps to run in the build stage (all jobs within one
    stage are executed in parallel—at least, potentially—and cannot be dependent on
    each other). For this reason, we will start by reconfiguring the build stages
    for our project. This is also done on a per-project basis in the `.gitlab-ci.yml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can use these new stages in our actual build jobs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `dependencies` property declares that this step requires the `build:eventservice`
    job to complete first. It also makes the build artifacts of that job available
    within this job. The `script` consists of just the `docker container build` command
    (`$CI_COMMIT_REF_NAME`) that contains the name of the current Git branch or tag.
    The `only` property ensures that the Docker image is only built when a new Git
    tag is pushed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a corresponding build job for building the booking service container image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the modified `.gitlab-ci.yml` file to version control, and also, create
    a new Git tag to test the new build pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Pipeline overview, you will now find four build jobs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/40656dbf-18bd-45c8-8bd6-88f06b83c95c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After building the Docker images, we can now add a fifth build step for publishing
    the created registries into a Docker registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to our preceding Travis CI build, this build job relies on the environment
    variables `$DOCKER_USERNAME` and `$DOCKER_PASSWORD`. Luckily, GitLab CI offers
    a similar feature to Travis CI''s secret environment variables. For this, open
    the project''s Settings tab in the GitLab web UI, then select the CI/CD Pipelines
    tab and search for the Secret Variables section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/392d38cf-4057-4fdd-a622-4eb0882d6e35.png)'
  prefs: []
  type: TYPE_IMG
- en: Use this feature to configure the credentials for the container registry of
    your choice (remember to adjust the `docker login` command in the preceding build
    job accordingly if you are using a registry other than Docker Hub).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s add the final build step for actually deploying our application
    into a Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This build step uses the `alpine:3.5` base image (a minimalist Linux distribution
    with a very small image size), in which we first download and then configure the
    `kubectl` binary. These steps are similar to our Travis CI deployment, which we
    configured in the preceding section, and require the environment variables `$KUBE_CA_CERT`
    and `$KUBE_TOKEN` to be configured as secret variables in the GitLab UI.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, in this example, we are using a Kubernetes Service Account named
    `gitlab-ci` (previously, we created an account named `travis-ci`). So, for this
    example to work, you will need to create an additional service account using the
    commands that have already been used in the preceding section.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, our GitLab-based build and deployment pipeline is complete.
    Take another look at the Pipelines view in the GitLab UI to have a last look at
    our pipeline in all its glory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/910c4c84-ff01-46bf-90e0-c10a53ca8d9d.png)'
  prefs: []
  type: TYPE_IMG
- en: GitLab's pipeline feature is a nearly perfect solution for implementing complex
    build and deployment pipelines. While other CI/CD tools constrain you into a single
    build job with one environment, GitLab pipelines allow you to use an isolated
    environment for each step of your build, and to even run these in parallel if
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to easily automate your application's build
    and deployment workflow. Having an automated deployment workflow is especially
    important in microservice architectures where you have many different components
    that are deployed often. Without automation, deploying complex distributed application
    would become increasingly tedious and would eat away your productivity.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the deployment problem of our application is solved (in short, containers
    + continuous delivery), we can direct our attention to other matters. That our
    application is running where we deployed it does not mean that it is actually
    doing what it is supposed to do. This is why we need to monitor applications that
    are run in production environments. Monitoring enables you to track your application's
    behavior at runtime and note errors quickly, which is why the focus of the next
    chapter will be on monitoring your application.
  prefs: []
  type: TYPE_NORMAL
