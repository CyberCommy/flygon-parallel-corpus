- en: Building an E-Commerce Store – Browsing Products
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 9](part0156.html#4KONO0-985bf4ae118d4f62b18ae64204cb251c), *Using
    Vue-Router Dynamic Routes to Load Data*, we loaded our product data into the Vuex
    store and created a product detail page where a user could view the product and
    its variations. When viewing the product detail page, a user could change the
    variation from the drop-down and the price and other details would update.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a home page listing page with specific products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a category page with a reusable component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an ordering mechanism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create filters dynamically and allow the user to filter the products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing the products
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we create any filtering, curated lists, ordering components, and functionality,
    we need to create a basic product list – showing all the products first, and then
    we can create a paginated component that we can then reuse throughout the app.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new route
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us add a new route to our `routes` array. For now, we''ll work on the `HomePage`
    component, which will have the `/` route. Make sure you add it to the top of the
    `routes` array, so it doesn''t get overridden by any of the other components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the `HomePage` component, create a new `computed` property and gather
    all the products from the `store`. Ensure the products have loaded before displaying
    anything in the template. Populate the `HomePage` component with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Looping through products
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When looking at a category listing for any shop, the data displayed tends to
    have a recurring theme. It normally consists of an image, title, price, and manufacturer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add an ordered list to your template – as the products are going to have an
    order to them, it makes semantic sense to place them in an ordered list. Within
    the `<ol>`, add a `v-for` looping through the products and displaying a title
    for each one, as shown here. It''s also good practice to ensure the `product`
    variable exists before proceeding with displaying it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When viewing the page in your browser, you may notice that the product list
    is very long. Loading images for every one of these products would be a huge load
    on the user's computer, along with overwhelming the user with that many products
    on display. Before we add more information, such as price and images, to our template,
    we'll look at paginating the products, allowing the data to be accessed in more
    manageable chunks.
  prefs: []
  type: TYPE_NORMAL
- en: Creating pagination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating pagination, initially, seems quite simple – as you only need to return
    a fixed number of products. However, if we wish to make our pagination interactive
    and reactive to the product list – it needs to be a bit more advanced. We need
    to build our pagination to be able to handle different lengths of products – in
    the case where our product list has been filtered into fewer products.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The arithmetic behind creating a pagination component and displaying the correct
    products relies on four main variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Items per page**: This is usually set by the user; however, we''ll use a
    fixed number of 12, to begin with'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Total items**: This is the total number of products to display'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Number of pages**: This can be calculated by dividing the number of products
    by the items per page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Current page number**: This, combined with the others, will allow us to return
    exactly which products we need'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From these numbers, we can calculate everything needed for our pagination. This
    includes what products to display, whether to show next/previous links and, if
    desired, a component to skip to different links.
  prefs: []
  type: TYPE_NORMAL
- en: Before we proceed, we are going to convert our `products` object into an array.
    This allows us to use the split method on it, which will allow us to return a
    specific list of products. It also means we can easily count the total number
    of items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update your `products` computed function to return an `array` instead of an
    `object`. This is done by using the `map()` function – which is an ES2015 replacement
    for a simple `for` loop. This function now returns an array containing the product
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new function in the computed object titled `pagination`. This function
    will return an object with various figures about our pagination, for example,
    the total number of pages. This will allow us to create a product list and update
    the navigation components. We need to only return the object if our `products`
    variable has data. The function is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to keep track of two variables – items `perPage` and the `currentPage`.
    Create a `data` function on your `HomePage` component and store these two variables.
    We''ll give the user the ability to update the `perPage` variable later on. The
    highlighted code portion shows our `data` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You may be wondering when to use local data on a component and when to store
    the information in the Vuex store. This all depends on where you are going to
    be using the data and what is going to manipulating it. As a general rule, if
    only one component uses the data and manipulate it, then use the local `data()`
    function. However, if more than one component is going to be interacting with
    the variable, save it in the central store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to the `pagination()` computed function, store a variable with the length
    of the `products` array. With this as a variable, we can now calculate the total
    pages. To do this, we are going to do the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*total number of products / items per page*'
  prefs: []
  type: TYPE_NORMAL
- en: Once we have this result, we need to round it up to the nearest integer. This
    is because if there is any hangover, we need to create a new page for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you were showing 12 items per page and you had 14 products,
    that would yield a result of 1.1666 pages – which is not a valid page number.
    Rounding this up ensures we have two pages to display our products. To do this,
    use the `Math.ceil()` JavaScript function. We can also add the total number of
    products to our output. Check the following code for using the `Math.ceil()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The next calculation we need to do is work out what the current range of products
    for the current page is. This is a little more complicated, as not only do we
    need to work out what we need from the page number, but the array slicing is based
    on the item index – which means the first item is `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To work out where to take our slice from, we can use the following calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*(current page number * items per page) – items per page*'
  prefs: []
  type: TYPE_NORMAL
- en: The final subtraction may seem odd, but it means on page `1`, the result is
    `0`. This allows us to work out at which index we need to slice the `products`
    array.
  prefs: []
  type: TYPE_NORMAL
- en: As another example, if we were on page three, the result would be 24, which
    is where the third page would start. The end of the slice is then this result
    *plus* the number of items per page. The advantage of this means we can update
    the items per page and all of our calculations will update.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an object inside the `pagination` result with these two results – this
    will allow us to access them later easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Displaying a paginated list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our pagination properties calculated, we are now able to manipulate our
    `products` array using the start and end points. Rather than use a hardcoded value,
    or use another computed function, we are going to use a method to truncate the
    product list. This has the advantage of being able to pass on any list of products
    while also meaning Vue does not cache the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new method object inside your component with a new method of `paginate`.
    This should accept a parameter that will be the array of `products` for us to
    slice. Within the function, we can use the two variables we calculated previously
    to return the right number of products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the template to use this method when looping through the products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We can now view this in our browser and note it returns the first 12 products
    from our object. Updating the `currentPage` variable within the `data` object
    to two or three will reveal different lists of products, depending on the number.
  prefs: []
  type: TYPE_NORMAL
- en: To continue our semantic approach to listing our products, we should update
    the start position of our ordered list when not on page one. This can be done
    using the HTML attribute of `start` – this allows you to specify with which number
    you should start an ordered list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `pagination.range.from` variable to set the starting point of our ordered
    list – remembering to add `1` as on the first page it will be `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When incrementing the page numbers in the code now, you will notice the ordered
    list starts at the appropriate place for each page.
  prefs: []
  type: TYPE_NORMAL
- en: Creating paginating buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Updating the page number via the code isn't user-friendly – so we should add
    some pages to increment and decrement the page number variable. To do this, we'll
    create a function that changes the `currentPage` variable to its value. This allows
    us to use it for both the Next page and Previous page buttons, plus a numbered
    page list if desired.
  prefs: []
  type: TYPE_NORMAL
- en: Begin by creating two buttons within your `pagination` container. We want to
    disable these buttons if we are at the extremities of the navigations – for example,
    you don't want to be able to go below `1` when going back, and past the maximum
    number of pages when going forward. We can do this by setting the `disabled` attribute
    on the button – like we did on the product detail page and comparing the current
    page against these limits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `disabled` attribute and, on the Previous page, the button checks if
    the current page is one. On the Next page button, compare it to the `totalPages`
    value of our `pagination` method. The code for implementing the previously mentioned
    attributes is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Set the `currentPage` variable back to `1` and load the home page up in the
    browser. You should notice the Previous page button is disabled. If you change
    the `currentPage` variable, you will notice the buttons become active and inactive
    as desired.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to create a click method for the buttons to update the `currentPage`.
    Create a new function titled `toPage()`. This should accept a single variable
    – this will directly update the `currentPage` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the click handlers to the buttons, passing through `currentPage + 1` for
    the Next page button, and `currentPage - 1` for the Previous page button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now navigate back and forth through the products. As a nice addition
    to the user interface, we could give an indication of the page number and how
    many pages remain, using the variables available to us by using the code mentioned
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Updating the URL on navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another improvement to the user experience would be to update the URL on page
    navigation – this would allow the user to share the URL, bookmark it, and return
    to it later. When paginating, the pages are a *temporary* state and should not
    be the main endpoint of a URL. Instead, we can take advantage of the query parameters
    with Vue router.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `toPage` method to add the parameter to the URL on page change.
    This can be achieved using `$router.push`, however, we need to be careful not
    to remove any existing parameters that may be in use for filtering in the future.
    This can be achieved by combining the current query object from the route with
    a new one containing the `page` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: While navigating from page to page, you will notice the URL obtaining a new
    parameter of `?page=` equal to the current page name. However, pressing refresh
    will not yield the correct page results but, instead, page one again. This is
    because we need to pass the current `page` query parameter to the `currentPage`
    variable on our `HomePage` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be done using the `created()` function – updating the variables –
    ensuring we''ve checked for its existence first. The `created` function is part
    of the Vue life cycle and was covered in [Chapter 4](part0076.html#28FAO0-985bf4ae118d4f62b18ae64204cb251c),
    *Getting a List of Files Using the Dropbox API*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We need to ensure the `currentPage` variable is an integer, to help us with
    any arithmetic we need to do later on as a `string` is not a fan of calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Creating pagination links
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When viewing paginated products, it's often good practice to have a truncated
    list of page numbers, allowing the user to jump several pages. We already have
    the mechanism for navigating between pages – this can extend that.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a simple entry point, we can create a link to every page by looping through
    until we reach the `totalPages` value. Vue allows us to do this without any JavaScript.
    Create a `nav` element at the bottom of the component with a list inside. Using
    a `v-for`, and create a variable of `page` for *every item* in the `totalPages`
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This will create a button for every page – for example, if there are 24 pages
    in total, this will create 24 links. This is not the desired effect, as we want
    a few pages before and after the current page. An example of this would be, if
    the current page is 15, the page links should be 12, 13, 14, 15, 16, 17 and 18\.
    This means there are fewer links and it is less overwhelming for the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, create a new variable in the `data` object, which will note
    how many pages to show either side of the selected page – a good value to start
    with is three:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a new computed function titled `pageLinks`. This function will
    need to take the current page and work out what page numbers are three less and
    three more than that. From there, we need to check that the lower range is not
    less than one, and the upper is not more than the total number of pages. Check
    that the products array has items before proceeding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step is to create an array and a `for` loop that loops from the lower
    range to the higher range. This will create an array containing, at most, seven
    numbers with the page range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now replace the `pagination.totalPages` variable in our navigation component
    with the new `pageLinks` variable and the correct number of links will be created,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Viewing this in the browser, however, will render some odd behavior. Although
    the correct number of links will be generated, clicking on them or using the next/previous
    buttons will cause the buttons to remain the same – even if you navigate out of
    the range of the buttons. This is because the computed value is cached. We can
    combat this in two ways – either move the function into the `method` object or,
    alternatively, add a `watch` function to watch the route and update the current
    page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Opting for the second option means we can ensure no other results and outputs
    get cached and are updated accordingly. Add a `watch` object to your component
    and update the `currentPage` variable to that of the page query variable. Ensure
    it exists, otherwise default to one. The `watch` method is as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This ensures all the computed variables update when a different page is navigated
    to. Open your `HomePage` component and ensure all your pagination components work
    accordingly and update the list.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the items per page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last user interface addition we need to create is allowing the user to
    update the number of products per page. To initially set this up, we can create
    a `<select>` box with a `v-model` attribute that updates the value directly. This
    works as expected and updates the product list accordingly, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The issue with this is if the user is on a page higher than is possible once
    the value has changed. For example, if there are 30 products with 12 products
    per page, this would create three pages. If the user navigates to page three and
    then selects 24 products per page, there would only be two pages needed and page
    three would be empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be resolved, once again, with a watch function. When the `perPage`
    variable updates, we can check if the current page is higher than the `totalPages`
    variable. If it is, we can redirect it to the last page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Creating the ListProducts component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we proceed with creating the filtering and ordering, we need to extract
    our product listing logic and template it into our component – allowing us to
    easily reuse it. This component should accept a prop of `products`, which it should
    be able to list and paginate.
  prefs: []
  type: TYPE_NORMAL
- en: Open up the `ListProducts.js` file and copy the code from the `HomePage.js`
    file into the component. Move the data object and copy the `pagination` and `pageLinks`
    computed functions. Move the watch and methods objects, as well as the `created()`
    function, from the `HomePage` to the `ListProducts` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `HomePage` template to use the `<list-products>` components with
    a `products` prop, passing in the `products` computed value. In comparison, the
    `HomePage` component should now be significantly smaller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the `ListProducts` component, we need to add a props object, to let
    the component know what to expect. This component is now significant. There are
    a few more things we need to add to this component to make it more versatile.
    They include:'
  prefs: []
  type: TYPE_NORMAL
- en: Showing the next/previous links if there is more than one page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing the "products per page" component if there are more than 12 products,
    and only showing each step if there are more products than in the preceding step
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only showing the `pageLinks` component if it's more than our `pageLinksCount`
    variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of these additions have been added to the following component code as follows.
    We have also removed the unnecessary `products` computed value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You can verify your conditional rendering tags are working by temporarily truncating
    the products array in the `HomePage` template – don''t forget to remove it once
    you''re done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Creating a curated list for the home page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our product listing component in place, we can proceed with making a curated
    list of products for our home page, and add more information to the product listing.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are going to hardcode an array of product handles on our
    home page component that we want to display. If this were in development, you
    would expect this list to be controlled via a content management system or similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `data` function on your `HomePage` component, that which includes
    an array titled `selectedProducts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Populate the array with several `handles` from the product list. Try and get
    about six, but if you go over 12, remember it will paginate with our component.
    Add your selected handles to the `selectedProducts` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'With our selected handles, we can now filter the product list to only include
    a list of products included in our `selectedProducts` array. The initial instinct
    might be to use the JavaScript `filter()` function on the products array combined
    with `includes()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The issue with this is that, although it appears to work, it does not respect
    the ordering of the selected products. The filter function simply removes any
    items that do not match and leaves the remaining products in the order they are
    loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, our products are saved in a key/value pair with the handle as the
    key. Using this, we can utilize the products object and return an array using
    a `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an empty array, `output`, within the computed function. Looping through
    the `selectedProducts` array, find each required product and add to the `output`
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This creates the same product list but, this time, in the correct order. Try
    re-ordering, adding, and deleting items to ensure your list reacts accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Showing more information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can now work on showing more product information in our `ListProduct` component.
    As mentioned near the beginning of the chapter, we should display:'
  prefs: []
  type: TYPE_NORMAL
- en: Image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Title
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Price
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manufacturer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''re already displaying the title, and the image and manufacturer can easily
    be pulled out from the product information. Don''t forget to always retrieve the
    first image from the `images` array. Open up the `ListProducts.js` file and update
    the product to display this information – making sure you check whether the image
    exists before displaying it. The manufacturer title is listed under the `vendor`
    object in the product data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The price is going to be a little more complicated to work out. This is because
    each variation on the product can have a different price, however, these are often
    the same. If there are different prices we should display the cheapest one with
    a *from* prepended.
  prefs: []
  type: TYPE_NORMAL
- en: We need to create a function that loops through the variations and works out
    the cheapest price and, if there is a price range, add the word *from*. To achieve
    this, we are going to loop through the variations and build up an array of unique
    prices – if the price does not already exist in the array. Once complete, we can
    check the length – if there is more than one price, we can add the prefix, if
    not, it means all variations are the same price.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new method on the `ListProducts` component called `productPrice`.
    This accepts one parameter, which will be the variations. Inside, create an empty
    array, `prices`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Loop through the variations and append the price to the `prices` array if it
    does not exist already. Create a `for` loop that uses the `includes()` function
    to check if the price exists in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: With our array of prices, we can now extract the lowest number and check whether
    there is more than one item.
  prefs: []
  type: TYPE_NORMAL
- en: 'To extract the lowest number from an array, we can use the JavaScript `Math.min()`
    function. Use the `.length` property to check the length of the array. Lastly,
    return the `price` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Add your `productPrice` method to your template, remembering to pass `product.variationProducts`
    into it. The last thing we need to add to our template is a link to the product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Ideally, the product links should use a named route and not a hardcoded link,
    in case the route changes. Add a name to the product route and update the `to`
    attribute to use the name instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the template to now use the route name, with the `params` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Creating categories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A shop is not really a usable shop if it does not have categories to navigate
    by. Fortunately, each of our products has a `type` key that indicates a category
    for it to be shown in. We can now create a category page that lists products from
    that particular category.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a category list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can display the products in a particular category, we first need
    to generate a list of available categories. To help with the performance of our
    app, we will also store the handles of the products in each category. The categories
    structure will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Creating the category list like this means we readily have available the list
    of products within the category while being able to loop through the categories
    and output the `title` and `handle` to create a list of links to categories. As
    we already have this information, we will create the category list once we've
    retrieved the product list.
  prefs: []
  type: TYPE_NORMAL
- en: Open up `app.js` and navigate to the `created()` method on the `Vue` instance.
    Rather than creating a second `$store.commit` underneath the `products` storing
    method, we are going to utilize a different functionality of Vuex – `actions`.
  prefs: []
  type: TYPE_NORMAL
- en: Actions allow you to create functions in the store itself. Actions are unable
    to mutate the state directly – that is still down to mutations, but it allows
    you to group several mutations together, which in this instance, suits us perfectly.
    Actions are also perfect if you want to run an asynchronous operation before mutating
    the state – for example with a `setTimeout` JavaScript function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to your `Vuex.Store` instance and, after the mutations, add a new
    object of `actions`. Inside, create a new function titled `initializeShop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'With action parameters, the first parameter is the store itself, which we need
    to use in order to utilize the mutations. There are two ways of doing this, the
    first is to use a single variable and access its properties within the function.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'However, with ES2015, we are able to use argument destructuring and utilize
    the properties we need. For this action, we only need the `commit` function, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted the state from the store as well, we could add it to the curly
    brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this "exploded" method of accessing the properties makes our code cleaner
    and less repetitive. Remove the `state` property and add a second parameter after
    the curly brackets labeled `products`. This will be our formatted product''s data.
    Pass that variable directly to the product''s `commit` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Using actions is as simple as using `mutations`, except instead of using `$store.commit`,
    you use `$store.dispatch`. Update your `created` method – not forgetting to change
    the function name too, and check your app still works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to create a mutation for our categories. As we may want to
    update our categories independently of our products – we should create a second
    function within the `mutations`. It should also be this function that loops through
    the products and creates the list of categories.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, make a new property in the state object titled `categories`. This should
    be an object by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a new mutation called `categories`. Along with the state, this
    should take a second parameter. To be consistent, title it `payload` – as this
    is what Vuex refers to it as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Now for the functionality. This mutation needs to loop through the products.
    For every product, it needs to isolate the `type`. Once it has the title and slug,
    it needs to check if an entry exists with that slug; if it does, append the product
    handle to the `products` array, if not – it needs to create a new array and details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an empty `categories` object and loop through the payload, setting a
    variable for both the product and type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to check if an entry exists with the key of the current `type.handle`.
    If it does not, we need to create a new entry with it. The entry needs to have
    the title, handle, and an empty products array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we need to append the current product handle onto the products array
    of the entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'You can view the `categories` output by adding  `console.log` to the end of
    the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the mutation to the `initializeShop` action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Viewing the app in the browser, you will be faced with a JavaScript error. This
    is because some products do not contain a "type" for us to use to categorize them.
    Even with the JavaScript error resolved, there are still a lot of categories that
    get listed out.
  prefs: []
  type: TYPE_NORMAL
- en: To help with the number of categories, and to group the uncategorized products,
    we should make an "Miscellaneous" category. This will collate all the categories
    with two or fewer products and group the products into their own group.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an "miscellaneous" category
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first issue we need to negate is the nameless category. When looping through
    our products, if no type is found, we should insert a category, so everything
    is categorized.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new object in the `categories` method that contains the title and handle
    for a new category. For the handle and variable call it other. Make the title
    a bit more user-friendly by calling it <q class="calibre31">Miscellaneous</q>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'When looping through products, we can then check to see whether the `type`
    key exists, if not, create an `other` category and append to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Viewing the app now will reveal all the categories in the JavaScript console
    – allowing you to see the magnitude of how many categories there are.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s combine any categories with two or fewer products into the "other" category
    – not forgetting to remove the category afterward. After the product loop, loop
    through the categories, checking the count of the products available. If fewer
    than three, add them to the "other" category:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then delete the category we''ve just stolen the products from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'And with that, we have a much more manageable list of categories. One more
    improvement we can make is to ensure the categories are in alphabetical order.
    This helps users find their desired category much quicker. In JavaScript, arrays
    can be sorted a lot more easily than objects, so once again, we need to loop through
    an array of the object keys and sort them. Create a new object and add the categories
    as they are sorted to it. Afterward, store this on the `state` object so we have
    the categories available to us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: With that, we can now add a list of categories to our `HomePage` template. For
    this, we'll create named `router-view` components – allowing us to put things
    in the sidebar of the shop on selected pages.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the categories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our categories stored, we can now proceed with creating our `ListCategories`
    component. We want to display our category navigation in a sidebar on the home
    page, and also on a shop category page. As we want to show it in several places,
    we have a couple of options as to how we display it.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the component in the template as we have with the `<list-products>` component.
    The issue with this is that if we want to display our list in a sidebar and our
    sidebar needs to be consistent across the site, we would have to copy and paste
    a lot of HTML between views.
  prefs: []
  type: TYPE_NORMAL
- en: A better approach would be to use named routes and set the template once in
    our `index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the app template to contain a `<main>` and an `<aside>` element. Within
    these, create a `router-view`, leaving the one inside `main` unnamed, while giving
    the one inside the `aside` element a name of `sidebar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Within our routes object, we can now add different components to different
    named views. On the `Home` route, change the `component` key to `components`,
    and add an object - specifying each component and its view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The default indicates that the component will go into the unnamed `router-view`.
    This allows us to still use the singular `component` key if required. For the
    component to be correctly loaded into the sidebar view, we need to alter how the
    `ListCategories` component is initialized. Instead of using `Vue.component`, initialize
    it as you would a `view` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We can now proceed with making the template for the category list. As our categories
    are saved in the store, loading and displaying them should be familiar by now.
    It is advised you load the categories from the state into a computed function
    - for cleaner template code and easier adaptation should you need to manipulate
    it in any way.
  prefs: []
  type: TYPE_NORMAL
- en: Before we create the template, we need to create a route for the category. Referring
    back to our plan in [Chapter 9](part0156.html#4KONO0-985bf4ae118d4f62b18ae64204cb251c), *Using
    Vue-Router Dynamic Routes to Load Data*, we can see the route is going to be `/category/:slug`
    – add this route with a `name` and enable props, as we'll utilize them for the
    `slug`. Ensure you have made the `CategoryPage` file and initialized the component.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Back to our `ListCategories` component; loop through the stored categories
    and create a link for each one. Show the product count in brackets after each
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: With the links to our categories now showing on the home page, we can head on
    to make a category page.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying products in a category
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clicking one of the category links (that is, `/#/category/grips`) will navigate
    to a blank page – thanks to our route. We need to create a template and set up
    the category page to show the products. As a starting base, create the `CategoryPage`
    component in a similar vein to the product page.
  prefs: []
  type: TYPE_NORMAL
- en: Create a template with an empty container and the `PageNotFound` component inside.
    Create a data variable titled `categoryNotFound`, and ensure the `PageNotFound`
    component displays if this is set to `true`. Create a `props` object, which allows
    the `slug` property to be passed and, lastly, create a `category` computed function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CategoryPage` component should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `category` computed function, load the correct category from the
    store based on the slug. If it is not on the list, mark the `categoryNotFound`
    variable to true - similar to what we did in the `ProductPage` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'With our category loaded, we can output the title in the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: We can now proceed with displaying the products on our category page. To do
    this, we can use the code from the `HomePage` component as we have exactly the
    same scenario – an array of product handles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `computed` function that takes the current category products and
    processes them as we did on the home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'We don''t need to check whether the products exist in this function as we are
    checking whether the category exists, and that would only return true if the data
    had been loaded. Add the component to the HTML and pass in the `products` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: With that, we have our category products listed out for each category.
  prefs: []
  type: TYPE_NORMAL
- en: Code optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our `CategoryPage` component complete, we can see a lot of similarities
    between that and the home page – the only difference being the home page has a
    fixed product array. To save repetition, we can combine these two components –
    meaning we only have to ever update one if we need to.
  prefs: []
  type: TYPE_NORMAL
- en: We can address the fixed array issue by displaying it when we identify that
    we are on the home page. The way of doing that is to check if the slug prop has
    a value. If not, we can assume we are on the home page.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, update the `Home` route to point to the `CategoryPage` component and
    enable props. When using named views, you have to enable props for each of the
    views. Update the props value to be an object with each of the named views, enabling
    the props for each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a new variable in the `data` function of the `CategoryPage`, titled
    `categoryHome`. This is going to be an object that follows the same structure
    as the category objects, containing a `products` array, title, and handle. Although
    the handle won''t be used, it is good practice to follow conventions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to do is check whether the slug exists. If not, assign
    our new object to the category variable within the computed function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Head to the home page and verify your new component is working. If it is, you
    can delete `HomePage.js` and remove it from `index.html`. Update the category
    route to also include the category list in the sidebar and use the `props` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Ordering products in a category
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With our category pages displaying the right products, it''s time to add some
    ordering options within our `ListProducts` component. When viewing a shop online,
    you can normally order the products by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Title: Ascending (A - Z)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Title: Descending (Z - A)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Price: Ascending ($1 - $999)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Price: Descending ($999 - $1)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, once we have the mechanism in place, you can add any ordering criteria
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start off by creating a select box in your `ListProducts` component with each
    of the preceding values. Add an extra first one of Sort products by...:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to create a variable for the select box to update in the `data`
    function. Add a new key titled `ordering` and add a value to each option, so interpreting
    the value is easier. Construct the value by using the field and order, separated
    by a hyphen. For example, `Title - ascending (`A - Z`)` would become `title-asc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'And the updated `data` function becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: To update the order of the products we now need to manipulate the product list.
    This needs to be done before the list gets split for pagination - as the user
    would expect the whole list to be sorted, not just the current page.
  prefs: []
  type: TYPE_NORMAL
- en: Store the product price
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we proceed, there is an issue we need to address. To sort by price, the
    price needs to ideally be available on the product itself, not calculated specifically
    for the template, which it currently is. To combat this, we are going to calculate
    the price before the products get added to the store. This means it will be available
    as a property on the product itself, rather than being dynamically created.
  prefs: []
  type: TYPE_NORMAL
- en: The details we need to know are the cheapest price and whether the product has
    many prices within its variations. The latter means we know whether we need to
    display the `"From:"` when listing the products out. We will create two new properties
    for each product: `price` and `hasManyPrices`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the `products` mutation in the store and create a new object and
    a loop of the products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the code from the `productPrice` method on the `ListProducts` component
    and place it within the loop. Update the second `for` loop so it loops through `product.variationProducts`.
    Once this `for` loop has completed, we can add the new properties to the product.
    Lastly, update the state with the new products object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now update the `productPrice` method on the `ListProducts` component.
    Update the function so it accepts the product, instead of variations. Remove the
    `for` loop from the function, and update the variables so they use the `price`
    and `hasManyPrices` properties of the product instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the template so the product is passed to the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Wiring up the ordering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With our price readily available, we can proceed with wiring up the ordering.
    Create a new `computed` function titled `orderProducts` that returns `this.products`.
    We want to ensure we are always sorting from the source and not ordering something
    that has previously been ordered. Call this new function from within the `paginate`
    function and remove the parameter from this method and from the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'To determine how we need to sort the products, we can use the `this.ordering`
    value. If it exists, we can split the string on the hyphen, meaning we have an
    array containing the field and order type. If it does not exist, we need to simply
    return the existing product array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Sort the `products` array based on the value of the first item of the ordering
    array. If it is a string, we will use `localCompare`, which ignores cases when
    comparing. Otherwise, we will simply subtract one value from the other – this
    is what the `sort` function expects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we need to check if the second item in the `orders` array is `asc`
    or `desc`. By default, the current sort function will return the items sorted
    in an `ascending` order, so if the value is `desc`, we can reverse the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Head to your browser and check out the ordering of products!
  prefs: []
  type: TYPE_NORMAL
- en: Creating Vuex getters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last step to making our category page just like any other shop is the introduction
    of filtering. Filtering allows you to find products that have particular sizes,
    colors, tags, or manufacturers. Our filtering options are going to be built from
    the products on the page. For example, if none of the products have an XL size
    or a blue color, there is no point showing that as a filter.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, we are going to need to pass the products of the current category
    to the filtering component as well. However, the products get processed on the
    `CategoryPage` component. Instead of repeating this processing, we can move the
    functionality to a Vuex store `getter`. Getters allow you to retrieve data from
    the store and manipulate it like you would in a function on a component. Because
    it is a central place, however, it means several components can benefit from the
    processing.
  prefs: []
  type: TYPE_NORMAL
- en: Getters are the Vuex equivalent of computed functions. They are declared as
    functions but called as variables. However, they can be manipulated to accept
    parameters by returning a function inside them.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to move both the `category` and `products` functions from the `CategoryPage`
    component into the getter. The `getter` function will then return an object with
    the category and products.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new object in your store titled `getters`. Inside, create a new function
    called `categoryProducts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Getters themselves receive two parameters, the state as the first, and any other
    getters as the second. To pass a parameter to a getter, you have to return a function
    inside of the getter that receives the parameter. Fortunately, in ES2015, this
    can be achieved with the double arrow (`=>`) syntax. As we are not going to be
    using any other getters in this function, we do not need to call the second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we are abstracting all of the logic out, pass in the `slug` variable as
    the parameter of the second function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'As we are transferring the logic for selecting and retrieving the categories
    and products into the store, it makes sense to store the `HomePage` category content
    in the `state` itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Move category-selecting logic from the `category` computed function in the `CategoryPage`
    component into the getter. Update the `slug` and `categoryHome` variables to use
    the content from the relevant places:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'With a category assigned, we can now load the products based on the handles
    stored in the category. Move the code from the `products` computed function into
    the getter. Combine the variable assignments together and remove the store product
    retrieval variable, as we have the state readily available. Ensure the code that
    checks to see whether the category exists is still in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we can add a new `productDetails` array on the `category` with the
    fleshed-out product data. Return the `category` at the end of the function. If
    the `slug` variable input exists as a category, we will get all of the data back.
    If not, it will return `false` – from which we can display our `PageNotFound`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `CategoryPage` component, we can remove the `products()` computed function
    and update the `category()` function. To call a `getter` function, you refer to
    `this.$store.getters`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, we are still having to check whether the categories exist before
    proceeding. This is so we can tell that there is no category with the name, rather
    than an unloaded one.
  prefs: []
  type: TYPE_NORMAL
- en: To make this neater, we can extract this check into another getter and utilize
    it in both our other getter and the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new getter titled `categoriesExist`, and return the contents of the
    `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `categoryProducts` getter to accept getters in the arguments of
    the first function and to use this new getter to indicate its output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: In our `CategoryPage` component, we can now call on the new getter with `this.$store.getters.categoriesExist()`.
    To save having `this.$store.getters` repeated twice in this function, we can map
    the getters to be locally accessed. This allows us to call `this.categoriesExist()` as
    a more readable function name.
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of the `computed` object, add a new function titled `...Vuex.mapGetters()`.
    This function accepts an array or an object as a parameter and the three dots
    at the beginning ensure the contents are expanded to be merged with the `computed`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pass in an array containing the names of the two getters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'This now means we have `this.categoriesExist` and `this.categoryProducts` at
    our disposal. Update the category function to use these new functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the template to reflect the changes in the computed data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Building the filtering component based on products
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned, all our filters are going to be created from the products in the
    current category. This means if there are no products made by *IceToolz*, it won't
    appear as an available filter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, open the `ProductFiltering.js` component file. Our product filtering
    is going to go in our sidebar, so change the component definition from `Vue.component`
    to an object. We still want our categories to display after the filtering, so
    add the `ListCategories` component as a declared component within `ProductFiltering`.
    Add a template key and include the `<list-categories>` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the category route to include the `ProductFiltering` component in the
    sidebar instead of `ListCategories`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: You should now have the `Home` route, which includes the `CategoryPage` and `ListCategories`
    components, and the `Category` route, which includes the `ProductFiltering` component
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the `CategoryPage` component, copy the props and computed objects - as
    we are going to be utilizing a lot of the existing code. Rename the `category`
    computed function to `filters`. Remove both the return and the `componentNotFound`
    if statement. Your component should now look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: We now need to construct our filters, based on the products in the category.
    We will be doing this by looping through the products, collecting information
    from preselected values, and displaying them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `data` object that contains a key of `topics`. This will be an object
    containing child objects with a, now familiar, pattern of `''handle'': {}` for
    each of the properties we want to filter on.'
  prefs: []
  type: TYPE_NORMAL
- en: Each child object will contain a `handle`, which is the value of the product
    of which to filter (for example, vendor), a `title`, which is the user-friendly
    version of the key, and an array of values, which will be populated.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start off with two, `vendor` and `tags`; however, more will be dynamically
    added as we process the products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: We will now begin looping through the products. Along with the values, we are
    going to keep track of how many products have the same value, allowing us to indicate
    to the user how many products will be revealed.
  prefs: []
  type: TYPE_NORMAL
- en: Loop through the `products` on the category within the `filters` method and,
    to begin with, find the `vendor` of each product. For every one encountered, check
    whether it exists within the `values` array.
  prefs: []
  type: TYPE_NORMAL
- en: If it does not, add a new object with the `name`, `handle`, and a `count`, which
    is an array of product handles. We store an array of handles so that we can verify
    that the product has already been seen. If we were keeping a raw numerical count,
    we could encounter a scenario where the filters get triggered twice, doubling
    the count. By checking whether the product handle exists already, we can check
    it's only been seen once.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a filter of that name does exist, add the handle to the array after checking
    it does not exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'This utilizes the previously-used object-expanding ellipsis (`...`), which
    saves us from having to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Although, feel free to use this if you are more comfortable with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Duplicate the code to work with `tags`, however as `tags` are an array themselves,
    we need to loop through each tag and add accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Our code is already getting repetitive and complex, let's simplify it by creating
    a method to handle the repetitive code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `methods` object with a function of `addTopic`. This will take two
    parameters: the object to append to and the singular item. For example, its usage
    would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the function and abstract out the logic from inside the `hasOwnProperty`
    if declaration. Name the two parameters `category` and `item`, and update the
    code accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `filters` computed function to use the new `addTopic` method. Remove
    the variable declarations at the top of the function, as they are being passed
    directly into the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of this function, return `this.topics`. Although we could reference
    `topics` directly in the template, we need to ensure the `filters` computed property
    gets triggered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Before we proceed to create our dynamic filters based on the various types,
    let's display the current filters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to how the `topics` object is set up, we can loop through each of the child
    objects and then through the `values` of each one. We are going to make our filters
    out of checkboxes, with the value of the input being the handle of each of the
    filters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: In order to keep track of what is checked, we can use a `v-model` attribute.
    If there are checkboxes with the same `v-model`, Vue creates an array with each
    item.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add an array of `checked` to each of the `topic` objects in the data object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add a `v-model` attribute to each checkbox, referencing this array on
    the `filter` object along with a click binder, referencing an `updateFilters`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an empty method for now - we''ll configure it later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Dynamically creating filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our fixed filters created and being watched, we can take the opportunity
    to create dynamic filters. These filters will observe the `variationTypes` on
    the products (for example, color, and size) and list out the options – again with
    the count of each one.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, we need to first loop through the `variationTypes` on the
    products. Before adding anything, we need to check to see if that variation type
    exists on the `topics` object, if not – we need to add a skeleton object. This
    expands the variation (which contains the `title` and `handle`) and also includes
    empty `checked` and `value` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'With our empty object created, we can now loop through the `variationProducts`
    on the product object. For each one, we can access the variant with the handle
    of the current variation. From there, we can use our `addTopic` method to include
    the value (for example, Blue or XL) within the filters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: We do need to update our `addTopic` method, however. This is because the dynamic
    properties have a `value`, instead of a title.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add an `if` statement to your `addTopic` method to check whether a `value`
    exists, if it does – set it to the `title`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Viewing the app in the browser should reveal your dynamically-added filters,
    along with the original ones we had added.
  prefs: []
  type: TYPE_NORMAL
- en: Resetting filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When navigating between categories you will notice that, currently, the filters
    do not reset. This is because we are not clearing the filters between each navigation,
    and the arrays are persisting. This is not ideal, as it means they get longer
    as you navigate around and do not apply to the products listed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remedy this, we can create a method that returns our default topic object
    and, when the slug updates, call the method to reset the `topics` object.  Move
    the `topics` object to a new method titled `defaultTopics`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the `data` function, change the value of topics to be `this.defaultTopics()`
    to call the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, add a watch function to reset the topics key when the `slug` gets updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Updating the URL on checkbox filter change
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our filtering component, when interacted with, is going to update the URL query
    parameters. This allows the user to see the filters in effect, bookmark them,
    and share the URL if needed. We already used query parameters for our pagination,
    and it makes sense to put the user back on page one when filtering – as there
    may only be one page.
  prefs: []
  type: TYPE_NORMAL
- en: To construct our query parameters of filters, we need to loop through each filter
    type and add a new parameter for each one that has items in the `checked` array.
    We can then call a `router.push()` to update the URL and, in turn, change the
    products displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an empty object in your `updateFilters` method. Loop through the topics
    and populate the `filters` object with the items checked. Set the `query` parameters
    in the router to the `filters` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Checking and unchecking the filters on the right should update the URL with
    the items checked.
  prefs: []
  type: TYPE_NORMAL
- en: Preselecting filters on page load
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When loading a category with filters already in the URL, we need to ensure
    the checkboxes are checked on the right-hand side. This can be done by looping
    through the existing query parameters and adding any matching keys and arrays
    to the topics parameter. As the `query` can either be an array or a string, we
    need to ensure the checked property is an array no matter what. We also need to
    ensure the query key is, indeed, a filter and not a page parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: On page load, the filters in the URL will be checked.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering the products
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our filters are now being created and appended to dynamically, and activating
    a filter updates the query parameter in the URL. We can now proceed with showing
    and hiding products based on the URL parameters. We are going to be doing this
    by filtering the products before being passed into the `ListProducts` component.
    This ensures the pagination works correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we are filtering, open up `ListProducts.js` and add a `:key` attribute to
    each list item, with the value of the `handle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Open up the `CategoryPage` view and create a method within the `methods` object
    titled `filtering()` and add a  `return true` to begin with. The method should
    accept two parameters, a `product` and `query` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Next, within the `category` computed function, we need to filter the products
    if there is a query parameter. However, we need to be careful that we don't trigger
    the filters if the page number is present – as that is also a query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new variable called `filters`, which is a copy of the query object
    from the route. Next, if the page parameter is present, `delete` it from our new
    object. From there, we can check whether the query object has any other contents
    and if so, run the native JavaScript `filter()` function on our product array
    – passing in the product and new query/filters object to our method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Refresh your app to ensure the products still show.
  prefs: []
  type: TYPE_NORMAL
- en: To filter products, there is quite a complex process involved. We want to check
    whether an attribute is in the query parameters; if it is, we set a placeholder
    value of `false`. If the attribute on the product matches that of the query parameter,
    we set the placeholder to `true`. We then repeat this for each of the query parameters.
    Once complete, we then only show products that have all of the criteria.
  prefs: []
  type: TYPE_NORMAL
- en: The way we are going to construct this allows products to be `OR` within the
    categories, but `AND` with different sections. For example, if the user were to
    pick many colors (red and green) and one tag (accessories), it will show all products
    that are red or green accessories.
  prefs: []
  type: TYPE_NORMAL
- en: Our filtering is created with the tags, vendor, and then dynamic filters. As
    two of the properties are fixed, we will have to check these first. The dynamic
    filters will be verified by reconstructing the way they were built.
  prefs: []
  type: TYPE_NORMAL
- en: Create a `hasProperty` object, which will be our placeholder object for keeping
    track of the query parameters the product has. We'll begin with the `vendor` –
    as this is the simplest property.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by looping through the query attributes – in case there is more than
    one (for example, red and green). Next, we need to confirm that the  `vendor`
    exists in the `query` – if it does, we then set a vendor attribute in the `hasProperty`
    object to `false`. We then check whether the vendor handle is the same as the
    query attribute. If this matches, we change our `hasProperty.vendor` property
    to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: This will update the `hasProperty` object with whether the vendor matches the
    selected filter. We can row replicate the functionality with the `tags` – remembering
    that tags on a product are an object we need to filter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dynamic properties constructed by the filters will also need to be checked.
    This is done by checking the variant object on each `variationProduct`, and updating
    the `hasProperty` object if it matches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we need to check each of the properties of the `hasProperty` object.
    If all the values are set to `true`, we can set the display of the product to
    `true` – meaning it will show. If one of them is `false`, the product will not
    show as it does not match all of the criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: We now have a successful filtering product list. View your app in the browser
    and update the filters – noting how products show and hide with each click. Note
    how even when you press refresh, only the filtered products display.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created a category listing page, allowing the user the view
    all the products in a category. This list is able to be paginated, along with
    the order changing. We also created a filtering component, allowing the user to
    narrow down the results.
  prefs: []
  type: TYPE_NORMAL
- en: With our products now browseable, filterable, and viewable, we can proceed on
    to making a Cart and Checkout page.
  prefs: []
  type: TYPE_NORMAL
