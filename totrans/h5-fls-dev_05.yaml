- en: Chapter 5. Code Once, Release Everywhere
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I am sure you may have noticed by now that although all the modern browsers
    support many aspects of the specified HTML5 feature set, in many cases, developers
    have to write their code in specific ways to enable proper cross-browser support
    for their projects. Not only is this a time consuming task that requires a lot
    of redundancy and conditioning, but it requires developers to stay caught up on
    the cutting edge of the current browser support of the HTML5 specification; not
    only for every browser targeted, but every update for each browser as well. With
    the popularity of HTML5 development growing at an extremely fast rate, many developers
    have created libraries and frameworks to aid in targeting all platforms with a
    single instance of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the CreateJS Toolkit, a Flash developer's best friend for HTML5
    development as well as its internal libraries, EaselJS, SoundJS, PreloadJS, and
    TweenJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Modernizr to detect clients' browser features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking deeper into CSS3 media queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Covering all your bases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the biggest differences in the development paradigm between Flash and
    HTML5 is the expectation a developer has from the user who will be viewing the
    end product. Typically, a Flash developer will preset the publish settings for
    the project, when starting a project to the Flash Player that will best support
    the feature set to be built into the application. Of course, this means that the
    user's Flash Player installed on their computer must be up-to-date in order to
    fill the prerequisite version. When developing any HTML-based web project, this
    issue is exponentially greater because the developer loses control over how a
    user is exactly able to view their content. Although some browsers are more common
    than others, there is a massive range of Internet Browser software available today,
    not only for desktops and mobiles, but for devices such as televisions as well.
    Unfortunately, each of these browsers is not built to the exact same specification
    and if you ignore testing your project in each and every one of them, you cannot
    guarantee that your content will be displayed and will act as you had created
    it to.
  prefs: []
  type: TYPE_NORMAL
- en: With the release of Microsoft's Internet Explorer Version 10, long gone are
    the days of web developers complaining about developing web pages for Internet
    Explorer Version 6\. However, a new set of issues have been born with the advent
    of HTML5\. Web pages and web-based applications are now gaining accessibility
    to many of the features you have become accustomed to with native desktop applications.
    New system integration, such as file accessibility, peripheral support, as well
    as hardware acceleration have required that modern web browsers implement support
    for these features to enable proper support for users viewing this new HTML5 content.
  prefs: []
  type: TYPE_NORMAL
- en: So which browser is the best? Well, from the developer's perspective, as nice
    as it is to have a favorite, this really doesn't matter if you want everyone to
    view your content. Understanding the differences and how they have changed, and
    will change, will keep your HTML5 skill set up-to-date and ahead of the curve.
    As mentioned before, if you are using any of the popular and modern web browsers
    available today, most of your bases will be covered. At the time of writing this
    book, upcoming features such as **WebRTC**, which we will cover later in this
    book, are only supported in browsers such as Google Chrome.
  prefs: []
  type: TYPE_NORMAL
- en: CreateJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since this book is written specifically for Flash developers extending their
    skill set with HTML5, the first library we cover to aid in JavaScript development
    has to be CreateJS. CreateJS is a collection of open source, modular JavaScript
    libraries that can work separately to enable a more seamless transition from ActionScript
    3 to JavaScript. CreateJS has been specifically created to easily allow web developers
    to create, embed, and manipulate media assets into their HTML5 projects with relative
    ease. This point is especially true if you come from a Flash development background.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The latest versions of all of the elements within CreateJS as well as the full
    documentation can be found at [http://www.createjs.com](http://www.createjs.com).
  prefs: []
  type: TYPE_NORMAL
- en: CreateJS focuses on the asset integration and manipulation end of things to
    enable you, the developer, to spend more time making sure your project is pixel
    perfect. There have been some great examples of some amazing projects in the recent
    past that have made use of this library, producing some stunning HTML5 experiences,
    such as [http://www.findyourwaytooz.com](http://www.findyourwaytooz.com), [http://www.atari.com/arcade](http://www.atari.com/arcade),
    and [http://shinobicorp.com/retro-soccer](http://shinobicorp.com/retro-soccer).
  prefs: []
  type: TYPE_NORMAL
- en: Although we could go into great detail about each of the exciting features within
    the CreateJS package, we would probably end up filling half this book. Therefore,
    to make sure you can at least get your feet wet and understand what CreateJS has
    to offer, let's review each of the elements within the package and how they can
    be utilized in your HTML5 projects.
  prefs: []
  type: TYPE_NORMAL
- en: EaselJS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: EaselJS is a JavaScript library which aims at mimicking the Flash Display List
    syntax within ActionScript 3 into JavaScript. It does this by using the HTML5
    Canvas element like a stage within Flash. As a newcomer to HTML5 and JavaScript
    syntax, EaselJS may be a library that will not only allow you to continue creating
    applications in a similar manner as what you have been developing up to this point
    but also allow you to easily port your preexisting Flash applications to HTML5
    with relative ease.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most up-to-date EaselJS documentation can easily be found at [http://www.createjs.com/Docs/EaselJS](http://www.createjs.com/Docs/EaselJS).
  prefs: []
  type: TYPE_NORMAL
- en: EaselJS can be used to handle all your graphical elements such as bitmaps, vectors,
    and sprite sheets for your HTML5 project. One of the best use cases of EaselJS
    is porting an existing ActionScript 3 class into JavaScript. Since EaselJS is
    set up to emulate the display list in Flash, once our ActionScript 3 class has
    been converted, we can begin to use it in our JavaScript project almost the same
    way we did in our Flash project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every project using EaselJS, or any other CreateJS library, needs to import
    the library source into their HTML5 project. Once you have acquired the necessary
    JavaScript source files from the CreateJS website, set up your HTML document as
    demonstrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding example, the EaselJS library is imported into
    our document within the `<script>` tag. We have also added an empty Canvas element
    to the body of our document. Since EaselJS uses the HTML5 Canvas element in replacement
    of the Stage in Flash, this will be a requirement in this example and all projects
    using this library.
  prefs: []
  type: TYPE_NORMAL
- en: 'To kick things off in our example, we will start by reviewing a basic ActionScript
    3 class, which could be used in any Flash project. This class is a simple demonstration
    to apply a bitmap graphic to the position of the mouse over the stage and update
    the graphic''s position as the mouse moves. This example encompasses not only
    the use of external graphic references but mouse- and time-based events as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: All of this should look very familiar provided you have spent any time working
    with ActionScript 3 classes, so let's jump right into the conversion process.
    As we have seen in the examples throughout the book so far, when creating classes
    in JavaScript, there are some immediate differences in syntax, layout, and usage
    from ActionScript 3\. First and foremost are the package declaration as well as
    the import statements. Packages do not exist in JavaScript; therefore, that code
    can be removed. The code directory and the file structure you have grown accustomed
    to can still be utilized; however, there will be no reference needed in code to
    distinguish what code is in what package. Import statements can also be completely
    removed as they are not used in JavaScript as well. Instead, any further external
    code required within the project should be imported within a `<script>` tag element
    inside the HTML document.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we intend to keep all of our classes as separate files within the project
    source structure, we can replace the typical package syntax in ActionScript 3
    classes with the following self-executing anonymous function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When our class source code is placed within this function, it will automatically
    be executed when it has been loaded, allowing us to utilize this class from the
    rest of our project''s code. After the strict typing on functions and variables
    has been removed, as well as the public and private variables converted into JavaScript
    syntax, our class will look something as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Notice the final line appended within the self-executing anonymous function,
    `window.MouseLine = MouseLine;`
  prefs: []
  type: TYPE_NORMAL
- en: 'This final addition to the class allows us to instantiate a new `MouseLine`
    object from our application base and utilize the functionality within the class.
    But before we can start using this class, we need to import it into our project
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'With our class saved as `MouseLine.js`, we can now import it into our HTML
    document as usual by using the `<script>` tag in the head of our HTML5 document.
    For this example, we will also open another `<script>` tag within the document
    *head*, where we will place our custom JavaScript code that utilizes our new class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we start constructing the `stage` for our EaselJS
    project. We begin by creating two global variables, one for our `stage` element
    and the other for our mouse graphic element. Following the global variables is
    our `init()` function, which will be called on page load. The next step within
    our `init` function is to set up the Canvas element we applied to the body of
    this HTML document. We use the `new.createjs.Stage('canvas-element')` syntax to
    tell EaselJS that our Canvas with the ID of `exampleCanvas` is our intended stage.
  prefs: []
  type: TYPE_NORMAL
- en: With EaselJS applied into our project and referencing our Canvas element, the
    next step is to apply a ticker to allow us to emulate the `onEnterFrame` event
    in ActionScript 3\. Since we intend for the graphic in our `MouseGraphic` class
    to follow our mouse when on the Canvas, we will need to constantly check the position
    of the mouse to translate those values into the x and y position values of the
    graphic. As mentioned, in ActionScript 3, one would traditionally use an `onEnterFrame`
    event; however, without the concept of MovieClips and frames in JavaScript, the
    setup uses a `Ticker` object from EaselJS instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Still within our `init()` function we have just created, we can now apply the
    following code to set up our `Ticker` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Not only have we created a new event listener for our `Ticker` object with
    the preceding lines of code, but we are also setting the intended frames per second
    of our Canvas rendering by utilizing one of the many internal CreateJS object
    methods. However, with our event listener created, we need a function to be called
    every time a new frame has been rendered. When using the `Ticker` object in CreateJS,
    we can simply append a `tick()` function in the same scope as the `Ticker` object,
    which will be called upon every interval:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Within this tick function, we also add the call to our global variable reference
    to our Stage object created in our `init()` function. This, as you may assume,
    is the call that actually tells the `stage` object to update itself by rendering
    the next interval in the stage progression. Therefore, any of the code one would
    typically append inside of an `onEnterFrame` event in ActionScript 3 would be
    placed before calling the `stage.update()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our basic EaselJS structure in place, our example should now look something
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to import our custom class and read the mouse position property
    at each interval of the `Ticker` object in order to reposition the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This simple example is only the tip of the iceberg when it comes to using EaselJS,
    but it shows off the core of how the flow of using the Canvas element as a stage
    can be done. EaselJS is really the core of the CreateJS bundle, as when it is
    utilized with any or all of the other libraries within the bundle, everything
    comes to life. Let's continue with the list of libraries within CreateJS by looking
    into the next library, TweenJS.
  prefs: []
  type: TYPE_NORMAL
- en: TweenJS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For a Flash developer, the concept of tweening an object should be nothing
    new. However, dealing with object animations in ActionScript 3 is far easier than
    using CSS3 animations or writing your own tweening engine. This is where TweenJS
    comes into play. TweenJS ([http://www.createjs.com/#!/TweenJS](http://www.createjs.com/#!/TweenJS))
    uses the common tweening syntax used in ActionScript and libraries such as TweenMax
    ([http://www.greensock.com/tweenmax](http://www.greensock.com/tweenmax)) to allow
    you to easily create HTML5-ready animations by allowing TweenJS to do all the
    object property manipulation over a specific period of time. Although TweenJS
    is a very simple library, the time it may be able to save you while developing
    a new project or converting your preexisting Flash project can be priceless. As
    with all the CreateJS package elements, TweenJS works extremely well with the
    EaseJS library, as we can demonstrate in the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding example code, tweening elements within the stage
    created by EaselJS is extremely straightforward and familiar to any Flash developer.
    As with all the elements within CreateJS, TweenJS can be used with or without
    the remainder of the CreateJS suite. Therefore, if you are in need of a simple
    but powerful tweening engine to save massive amounts of time and overhead while
    animating elements in your HTML5 projects, TweenJS is definitely worth a look.
  prefs: []
  type: TYPE_NORMAL
- en: PreloadJS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as in Flash applications, preloading your assets within your HTML5 projects
    can be a critical step to ensure your content is being delivered in the proper
    manner to your end users. PreloadJS ([http://www.createjs.com/#!/PreloadJS](http://www.createjs.com/#!/PreloadJS))
    allows for easy set up of multiple assets preloading with real-time progress feedback
    and queue support. As we saw with the EaselJS example, CreateJS has set up its
    own asset management system which easily integrates into the PreloadJS API ([http://www.createjs.com/Docs/PreloadJS/modules/PreloadJS.html](http://www.createjs.com/Docs/PreloadJS/modules/PreloadJS.html)).
    Consider the following simplified example, which loads external audio and image
    assets from the Web.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As we have seen in the previous examples in this book, waiting for all of the
    document and its assets to load prior to interacting with them is a critical step
    almost every JavaScript application will utilize. However, when your assets are
    being downloaded during a page load, there is no easy way to monitor the download
    or completion process. Although our typical `onload` calls will still wait until
    our assets are ready to be used, in many applications, the use of a progress bar
    can greatly enhance the end user experience during longer application load times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reviewing the preceding example again, you can see that we have added event
    listeners for each file when it is loaded as well as when all assets have completed
    loading. Combining the numerical value of how many assets are to be loaded with
    the number of assets that have been loaded, we can easily find the current preload
    completion percentage. To avoid a long code example, I have supplemented the use
    of some preload user interfaces by just using the developer console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![PreloadJS](img/3325OT_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: SoundJS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the time of writing this book, dealing with audio and audio interaction
    support on all the modern HTML5 compatible browsers is unfortunately still pretty
    difficult. The current level of HTML5 audio support can be extremely varying from
    browser to browser and even more so on most mobile platforms. Properly conditioning
    your audio interactions and manipulations to work on every device and browser
    can almost seem like an impossible task. Thankfully, SoundJS is here to help and
    solve many of the common issues that arise with HTML5 audio development. SoundJS
    allows you to easily query the client''s browser capabilities to ensure you are
    delivering audio with the proper features and plugins that the user''s device
    supports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: CreateJS Toolkit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the greatest aspects of CreateJS is the CreateJS Toolkit created by *Grant
    Skinner* ([http://www.gskinner.com](http://www.gskinner.com)) and Adobe. This
    Toolkit is an Adobe Flash Professional plugin that enables you to easily create
    CreateJS-ready animations and elements from within the Flash Professional environment,
    something every Flash developer is already used to.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can get the latest news and documentation for the CreateJS Toolkit at [http://www.adobe.com/devnet/createjs.html](http://www.adobe.com/devnet/createjs.html).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Toolkit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To begin, you will need to head over to the Adobe CreateJS Toolkit page on
    the Adobe website ([http://www.adobe.com/devnet/createjs.html](http://www.adobe.com/devnet/createjs.html))
    to download the latest version of the plugin to install on your machine. One of
    the easiest ways to find this page is by clicking on the link that may already
    be displayed when opening Flash CS6:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the Toolkit](img/3325OT_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once you have downloaded the extension, be sure to have quit any running instances
    of Flash CS6 and open the downloaded file within the Adobe Extension Manager CS6
    application to install it into your machine's Creative Suite setup. Read over
    and accept the terms and conditions to finish the installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the installation is finished, you should be able to see the CreateJS Toolkit
    extension listed under the Flash extensions, and that''s it, we are ready to start
    using the Toolkit back again inside Flash:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the Toolkit](img/3325OT_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With the extension installed and Flash reopened, start a new ActionScript 3
    project and open the CreateJS Toolkit window by selecting it from the **Window**
    dropdown. The resulting Toolkit window will look similar to the following image.
    From this window, you will be able to configure and publish your current project
    within Flash Professional with the CreateJS Toolkit rather than the traditional
    export to the SWF setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the Toolkit](img/3325OT_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Before we dig into publishing content, it is worth looking into the configuration
    settings within the Toolkit window. Click on the **Edit Settings** button within
    the Toolkit window to open the **Publish Settings** window of the CreateJS Toolkit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the Toolkit](img/3325OT_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The configuration settings for publishing your content from within your Flash
    project is relatively straightforward. The default **Output** value will be in
    the same directory where the FLA file your project is saved within and asset paths
    are set up. The final values within the **Options** section are again pretty straight
    forward apart from the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Compact Shapes**: This value compacts the code into a minimal version for
    drawing API class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiframe bounds**: This value calculates `boundsRect` for assets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing your assets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once your assets are all ready within your library and timelines, you can click
    on the **Publish** button within the Toolkit window. The result will be the typical
    application output but rather than being compiled into a SWF, the result is set
    up completely within HTML5:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Publishing your assets](img/3325OT_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The best part of this CreateJS Toolkit compiler is the ability to easily grab
    a piece of the exported source code and use it in a specific part of your application.
    This process dramatically improves the ability for designers and developers to
    easily work on HTML5 content and assets and update preexisting media with ease.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the CreateJS Toolkit output
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we finish up with the toolkit, it''s worth reviewing some of the code
    that has been exported from its compiler. Let''s check out what it has created
    for our space game example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, by all the examples and libraries above, CreateJS is a big collection
    of JavaScript functionality packaged into a couple of very well-maintained open
    source JavaScript libraries. As mentioned before, there is far more to get into
    than we have time to cover in this book, so be sure to head over to the CreateJS
    website ([http://www.createjs.com](http://www.createjs.com)) and read the documentation
    of the latest build.
  prefs: []
  type: TYPE_NORMAL
- en: Modernizr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An important feature we saw within the CreateJS bundle was the ability to easily
    check whether the client's web browser supports the intended HTML5 functionality
    to be used on your web page. However, only CreateJS has the ability to check for
    functionality compatibility for the features it uses within the libraries. If
    you are in need of digging deeper into checking whether your users have the appropriate
    functionality in their web browsers, the Modernizr project is definitely worth
    a look. Modernizr allows you to easily check for every feature within the HTML5
    feature set with only a couple of lines of code and an external JavaScript file
    that is only a couple of kilobytes.
  prefs: []
  type: TYPE_NORMAL
- en: Using Modernizr
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start, you will need to head over to [http://modernizr.com](http://modernizr.com)
    and download the latest version of the library. As with many JavaScript libraries,
    you will have the option of downloading the production or the development version
    of the code in order to conserve file size and bandwidth:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Modernizr](img/3325OT_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For ease of example and the sake of learning, we will download the development
    version of the code, which will include the entire Modernizer library. Once the
    JavaScript file has been downloaded, it can be included into your HTML document
    as you would include any JavaScript reference.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are still having issues finding Modernizr setup, head over to the official
    installation documentation present at [http://modernizr.com/docs/#installing](http://
    http://modernizr.com/docs/#installing).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Polyfills
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The concept of a Polyfill in web development is pretty straightforward once
    you deal with it in an actual project. Fortunately, even if you are coming from
    a 100 percent Flash development background, you may have had an experience with
    this concept before. When embedding Flash content within an HTML page, even with
    the automated publish setting within Flash Professional, the resulting code will
    have created an HTML object element with references to the compiled SWF file.
    However if you look closely, or disable Flash in your web browser, you will notice
    there will still be a warning displayed alerting you to the fact that you need
    to download the Flash player as well as a link to the Flash player download page.
    This content is only displayed while the Flash content cannot be displayed and
    is an example of a Polyfill in its simplest form.
  prefs: []
  type: TYPE_NORMAL
- en: Using Polyfills in HTML5 may be a necessity in order to reach the intended audience
    on specific browsers and platforms. However, using Polyfills should not always
    be necessary. If you are trying to deliver the best experience possible, it may
    not be worth attempting to target browsers like IE7 with your cutting-edge HTML5
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Modernizr.load()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `load` method within Moderizr may be one of the most powerful, yet easy-to-use
    utilities within the library. In a nutshell, the `load` method allows you to selectively
    choose which scripts and data should be loaded based on a simple condition that
    the user has the ability to utilize a specific piece of the HTML5 feature set.
    Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This simple example shows how we can easily select which JavaScript file to
    load depending on whether the user has the ability to use the geolocation functionality
    within their browser. If the client has the ability to use geolocation API within
    their browser, the `geo.js` file will be loaded and the script will continue on.
    If the user is unable to use geolocation, the `nope` value is used and the `geo-polyfill.js`
    file will be loaded instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see by this demo, Modernizr is a simple library with one main goal:
    to ease the mess of dealing with multiple browsers and platforms attempting to
    view your HTML5 content, and it does it very well.'
  prefs: []
  type: TYPE_NORMAL
- en: What Modernizr can detect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Thanks to the contribution by many JavaScript developers around the world,
    Modernizr boasts the fact that it is able to detect and create a Polyfill for
    every HTML5 feature currently specified. With so many features to be listed, I
    will leave the researching on the Modernizr API documentation to you and give
    you this following code example to demonstrate some further use of this great
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the example above, the implementation of Modernizr is extremely
    straightforward. Conditions are easy to recognize as their naming conventions
    almost directly match the feature set which can be tested. To get a better understanding
    of the ever-growing API that Modernizr offers, head over to the official project
    documentation at [http://modernizr.com/docs](http://modernizr.com/docs).
  prefs: []
  type: TYPE_NORMAL
- en: CSS media queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although we have already touched on CSS3 media queries in the previous chapters,
    it is worth stopping to make note of them in this chapter as well. If the active
    viewport was to change size while dealing with setting up your content to be viewable
    on all devices and to have a responsive layout and display set up, CSS3 media
    queries can easily allow you to avoid manipulating any of your site content and
    only manipulate the styles appended to them. This concept is great not only for
    implementing it on all your desktop and mobile projects but can be utilized for
    much more. Consider the following list of some of the properties that can be queried
    directly from within your CSS source:'
  prefs: []
  type: TYPE_NORMAL
- en: '**All**: This property allows *all* the devices to listen to this property'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Braille**: This property is used for braille-tactile feedback devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Embossed**: This property is used for paged braille printers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handheld**: This property is used for handheld devices (smartphones and tablets
    do *not* listen to this!)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Print**: This property is used for paged material and for documents viewed
    on screen in print preview mode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Projection**: This property is used for projected presentations, for example,
    projectors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Screen**: This property is used primarily for color computer screens and
    smartphones'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Speech**: This property is used for speech synthesizers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**tty**: This property is used for media using a fixed-pitch character grid
    such as teletypes, terminals, or portable devices with limited display capabilities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tv**: This property is used for television-type devices such as low resolution,
    color, limited-scroll-ability screens with available audio'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Properly utilized media queries can easily allow you to target a broad range
    of devices by allowing your content to respond to the specific size, platform
    and setup of the browser viewing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered some of the options available to you when converting
    or porting your existing Flash applications to HTML5 as well as methods to enable
    users to properly view their content on any device. We dug into each of the great
    libraries that make up CreateJS, from emulating the Flash Display List in JavaScript,
    to animating elements with the traditional ActionScript 3 tweening syntax. We
    checked out how useful the CreateJS Toolkit is to anyone with any prior knowledge
    of the Adobe Flash Professional IDE, and how assets can be compiled directly from
    the stage and library ready for use in web documents. We also learned about unifying
    your development experience by using libraries such as Modernizr. By querying
    browser feature support, you can easily decide whether an alternate display method
    or shim is necessary to enable the user to have a proper experience.
  prefs: []
  type: TYPE_NORMAL
