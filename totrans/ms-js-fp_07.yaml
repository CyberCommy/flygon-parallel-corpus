- en: Transforming Functions - Currying and Partial Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml), *Producing Functions
    - Higher-Order Functions*, we saw several ways of manipulating functions, to get
    new versions with some change in their functionality. In this chapter, we will
    go into a particular kind of transformation, a sort of *factory* method, that
    lets you produce new versions of any given function, with some fixed arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be considering the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Currying*, a classic FP theoretical function that transforms a function with
    many parameters into a sequence of unary functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Partial application*, another time-honored FP transformation, which produces
    new versions of functions by fixing some of their arguments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Something I'll call *partial currying*, that can be seen as a mixture of the
    two previous transformations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To be fair, we'll also see that some of these techniques can be emulated, with
    possibly greater clarity, by simple arrow functions. However, since you are quite
    liable to find currying and partial application in all sorts of texts and web
    pages on FP, it is quite important that you are aware of their meaning and usage,
    even if you opt for a simpler way out.
  prefs: []
  type: TYPE_NORMAL
- en: A bit of theory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The concepts that we are going to use in this chapter are in some ways very
    similar and in other ways quite different. It''s common to find some confusion
    as to their real meanings and there are plenty of web pages which misuse terms.
    You could even say that all the transformations in this chapter are roughly equivalent
    since they let you transform a function into another one that fixes some parameters,
    leaving others free and eventually leading to the same result. OK, I agree, this
    isn''t very clear! So, let''s start by clearing the air, and providing some short
    definitions, which we will expand later. (If you feel that your eyes are glazing
    over, please just skip this section and come to it later!) Yes, you may find the
    following descriptions a bit perplexing, but bear with us: we''ll be getting into
    more detail just in a bit!'
  prefs: []
  type: TYPE_NORMAL
- en: '*Currying* is the process of transforming an *m*-ary function (that is, a function
    of arity *m*) into a sequence of *m* unary functions, each of which receives one
    argument of the original function, from left to right. (The first function receives
    the first argument of the original function, the second function receives the
    second argument, and so on.) Upon being called with an argument, each function
    produces the next one in the sequence, and the last one does the actual calculations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Partial application* is the idea of providing *n* arguments to a *m*-ary function,
    being *n* less than or equal to *m*, to transform it into a function with (*m-n*)
    parameters. Each time you provide some arguments, a new function is produced,
    with smaller arity. When you provide the last arguments, the actual calculations
    are performed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Partial currying* is a mixture of both preceding ideas: you provide *n* arguments
    (from left to right) to a *m*-ary function and you produce a new function of arity
    (*m-n*). When this new function receives some other arguments, also from left
    to right, it will produce yet another function. When the last parameters are provided,
    the function produces the correct calculations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we are going to see the three transformations, what they require,
    and ways of implementing them. With respect to this, we will go into more than
    one way of coding each higher-order function and that will give us several insights
    about interesting ways of JS coding, that you might find interesting for other
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Currying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already mentioned currying back in the *Arrow functions* section of [Chapter
    1](395f5897-0ecc-4841-86ed-21521e148beb.xhtml), *Becoming Functional - Several
    Questions*, and in the *One argument or many?* section of [Chapter 3](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml),
    *Starting Out with Functions - A Core Concept*, but let's be more thorough here.
    Currying is a device that enables you to only work with single variable functions,
    even if you need a multiple variable one.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of converting a multi-variable function into a series of single-variable
    functions (or, more rigorously, reducing operators with several operands, to a
    sequence of applications of a single operand operator) had been worked on by Moses
    Schönfinkel, and there have been some authors who suggest, not necessarily tongue
    in cheek, that currying would be more correctly named *Schönfinkeling*!
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with many parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The idea of currying, by itself, is simple. If you need a function with, say,
    three parameters, instead of writing (with arrow functions) something like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can have a sequence of functions, each with a single parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you might want to consider them to be nested functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In terms of usage, there''s an important difference in how you''d use each
    function. While you would call the first in usual fashion, such as `make3(1,2,4)`,
    that wouldn''t work with the second definition. Let''s work out why: `make3curried()`
    is an *unary* (single parameter), so we should write `make3curried(1)`... but
    what does this return? According to the definition above, this also returns an
    unary function -- and *that* function also returns a unary function! So, the correct
    call to get the same result as with the ternary function would be `make3curried(1)(2)(4)`!
    See Figure 7.1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/47ca4163-c4a1-44eb-90ff-76d77804c6d7.jpg)Figure 7.1\. The difference
    between a common function, and a curried equivalent.'
  prefs: []
  type: TYPE_NORMAL
- en: Study this carefully --we have the first function, and when we apply an argument
    to it, we get a second function. Applying an argument to it produces a third function
    and a final application produces the desired result. This can be seen as a needless
    exercise in theoretical computing, but it actually brings some advantages, because
    you can then always work with unary functions, even if you need functions with
    more parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Since there is a currying transformation, there also exists an uncurrying one!
    In our case, we would write `make3uncurried = (a,b,c) => make3curried(a)(b)(c)`
    to revert the currying process and make usable, once again, to provide all parameters
    at a sitting.
  prefs: []
  type: TYPE_NORMAL
- en: In some languages, such as Haskell, functions are only allowed to take a single
    parameter -- but then again, the syntax of the language allows you to invoke functions
    as if multiple parameters were permitted. For our example, in Haskell, writing
    `make3curried 1 2 4` would have produced the result 124, without anybody even
    needing to be aware that it involved *three* function calls, each with one of
    our arguments. Since you don't write parentheses around parameters, and you don't
    separate them with commas, you cannot tell that you are not providing a triplet
    of values instead of three singular ones.
  prefs: []
  type: TYPE_NORMAL
- en: Currying is basic in Scala or Haskell, which are fully functional languages,
    but JavaScript has enough features to allow us to define and use currying in our
    work. It won't be as easy--since, after all, it's not built-in -- but we'll be
    able to manage.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to review the basic concepts, the key differences between our original
    `make3()` and `make3curried()` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`make3()` is a ternary function, but `make3curried()` is unary'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`make3()` returns a string; `make3curried()` returns another function -- which,
    itself, returns a *second* function, which returns yet a *third* function, which
    finally does return a string!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can produce a string by writing something like `make3(1,2,4)`, which returns
    124, but you'll have to write `make3curried(1)(2)(4)` to get the same result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Why would you go to all this bother? Let''s just see a simple example, and
    down below we will be seeing more examples. Suppose you had a function that calculated
    the VAT (*Value Added Tax*) for an amount:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you had to apply a single, constant rate, you could then curry the `addVAT()`
    function, to produce a more specialized version, that always applied your given
    rate. For example, if your national rate was 6%, you could then have something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line defines a curried version of our VAT-calculating function. Given
    a tax rate, `addVATcurried()` returns a new function, that when given an amount
    of money, finally adds the original tax rate to it. So, if the national tax rate
    were 6%, then `addNationalVAT()` would be a function that added 6% to any amount
    given to it. For example, if we were to calculate `addNationalVAT(1500)`, as in
    the preceding code, the result would be 1590: $1500, plus a 6% tax.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you would be probably justified to say that this currying thing
    is a bit too much just to add a 6% tax, but the simplification is what counts.
    Let''s see one more example. In your application, you may want to include some
    logging, with a function such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'However, with this approach, every time you wanted to display a normal log
    message, you would write `myLog`(`"NORMAL"`, "some normal text"), and for warnings,
    you''d write `myLog`(`"WARNING"`, "some warning") -- but you could simplify this
    a bit with currying, by fixing the first parameter of `myLog()` as follows, with
    a `curry()` function that we''ll see later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: What do you gain? Now you can just write `myNormalLog("some normal text")` or
    `myWarningLog("some warning")`, because you have curried `myLog()` and then fixed
    its argument -- this makes for simpler, easier to read code!
  prefs: []
  type: TYPE_NORMAL
- en: 'By the way, if you prefer, you could have also achieved the same result in
    a single step, with the original uncurried `myLog()` function, by currying it
    case by case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Currying by hand
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we want to implement currying just for a special case, there''s no need
    to do anything complex, because we can manage with simple arrow functions: we
    saw that for both `make3curried()` and `addVATcurried()`, so there''s no need
    to revisit that idea.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, let''s look into some ways of doing that automatically, so we will
    be able to produce an equivalent curried version of any function, even without
    knowing its arity beforehand. Going further, we might want to code a more intelligent
    version of a function, that could work differently depending on the number of
    received arguments. For example, we could have a `sum(x,y)` function that behaved
    like in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can achieve that behavior by hand. Our function would be something like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s recap what we did here. Our curried-by-hand function has this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: If we call it with two arguments, it adds them, and returns the sum; this provides
    our first use case, as in `sum(3,5)==8`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If only one argument is provided, it returns a new function. This new function
    expects a single argument, and will return the sum of that argument and the original
    one: this behavior is what we expected in the other two use cases, such as `add2(3)==5`
    or `sum(2)(7)==9`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, if no arguments are provided, it returns itself. This means that we
    would be able to write `sum()(1)(2)` if we desire. (No, I cannot think of a reason
    for wanting to write that...)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, if we want, we can incorporate currying in the definition itself of a function.
    However, you'll have to agree that having to deal with all the special cases in
    each function, can easily become troublesome, as well as error-prone. So, let's
    try to work out some more generic ways of accomplishing the same result, without
    any kind of particular coding.
  prefs: []
  type: TYPE_NORMAL
- en: Currying with bind()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can find a solution to currying by using the `.bind()` method. This allows
    us to fixate one argument (or more, if need be; we won't be needing that here,
    but later on, we will use it) and provide a function with that fixed argument.
    Of course, many libraries (such as Lodash, Underscore, Ramda, and more) provide
    this functionality, but we want to see how to implement that by ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Read more on `.bind()` at [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind)
    -- it will be useful since we'll take advantage of this method more times in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our implementation is quite short but will require some explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Start by noticing that `curry()` always returns a new function, which depends
    on the function `fn` given as its parameter. If the function has no (more) parameters
    left (when `fn.length===0`) because all parameters have already been fixed, we
    can simply evaluate it by doing `fn()`. Otherwise, the result of currying the
    function will be a new function, that receives a single argument, and produces
    itself a newly curried function, with another fixed argument. Let''s see this
    in action, with a detailed example, using the `make3()` function we saw at the
    beginning of this chapter once again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The explanation of this code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first function, `f1()`, has not received any arguments yet. Its result is
    a function of a single parameter, that will itself produce a curried version of
    `make3()`, with its first argument fixed to whatever it's given.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling `f1(6)` produces a new unary function, `f2()`, that will by itself produce
    a curried version of `make3()` -- but with its first argument set to `6`, so actually
    the new function will end fixing the second parameter of `make3()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, calling `f2(5)` produces yet a third unary function, `f3()`, that
    will produce a version of `make3()`, but fixing its third argument, since the
    first two had already been fixed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, when we calculate `f3(8)`, this fixes the last parameter of `make3()`
    to `8`, and since there are no more arguments left, the thrice-bound `make3()`
    function is called and the result `"658"` is produced.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you wanted to curry the function by hand, you could use JavaScript''s `.bind()`
    method. The sequence would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In each step, we provide a further parameter. (The `null` value is required,
    to provide context. If it were a method attached to an object, we would provide
    that object as the first parameter to `.bind()`. Since that's not the case, `null`
    is expected.) This is equivalent to what our code does, with the exception that
    the last time, `curryByBind()` does the actual calculation, instead of making
    you do it, as in `step3()`.
  prefs: []
  type: TYPE_NORMAL
- en: Testing this transformation is rather simple -- because there are not many possible
    ways of currying!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: What else could you test? Maybe functions with just one parameter could be added,
    but there's no more to try.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to curry a function with a variable number of parameters, then
    using `fn.length` wouldn''t work; it only has a value for functions with a fixed
    number of parameters. We can solve this simply, by providing the desired number
    of arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The new `curryByBind2()` function works as before, but instead of depending
    on `fn.length`, it works with the `len` parameter, which defaults to `fn.length`,
    for standard functions with a constant number of parameters. Notice that when
    `len` isn't 0, the returned function calls `curry2()` with `len-1` as its last
    argument -- this makes sense, because if one argument has just been fixed, then
    there is one fewer parameter left to fix.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, the `sum()` function can work with any number of parameters,
    and JavaScript informs us that `sum.length` is zero. However, when currying the
    function, if we set `len` to `5`, currying will be done as if `sum()` was a five-parameter
    function -- and the last line in the code listed above, shows that this is really
    the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, testing is rather simple, given that we have no variants to try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We tested setting the arity of the curried function to 1, as a border case,
    but there are no more possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Currying with eval()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There''s another interesting way of currying a function, by creating a new
    one by means of `eval()`... yes, that unsafe, dangerous, `eval()`! (Remember what
    we said earlier: this is for learning purposes, but you''ll be better off by avoiding
    the potential security headaches that `eval()` can bring!) We will also be using
    the `range()` function that we wrote in the *Working with ranges* section of [Chapter
    5](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml), *Programming Declaratively - A
    Better Style*.'
  prefs: []
  type: TYPE_NORMAL
- en: Languages such as LISP have always had the possibility of generating and executing
    LISP code. JavaScript shares that functionality, but it's not often used -- mainly
    because of the dangers it may entail! However, in our case, since we want to generate
    new functions, it seems logical to take advantage of this neglected capability
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is simple: in the *A bit of theory* section, earlier in this chapter,
    we saw that we could easily curry a function by using arrow functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s apply a couple of changes to the second version, to rewrite it in a
    way that will help us, as you''ll see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The needed code to generate this equivalent version is the following. We will
    be using the `range()` function we wrote back in the *Working with ranges* section
    of [Chapter 5](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml), *Programming Declaratively
    - A Better Style*, to avoid needing to write an explicit loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This is quite a chunk of code to digest and, in fact, it should rather be coded
    in several separate lines to make it more understandable. Let''s follow it, with
    the `make3()` function as input:'
  prefs: []
  type: TYPE_NORMAL
- en: The `range()` function produces an array with values `[0,1,2]`. If we don't
    provide a `len` argument, `make3.length` (that is, 3) will be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use `.map()` to generate a new array with values `["x0","x1","x2"]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We `join()` the values in that array to produce `x0=>x1=>x2`, which will be
    the beginning of the code that we will `eval()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We then add an arrow, the name of the function, and an opening parenthesis,
    to make the middle part of our newly generated code: `=> make3(`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We use `range()`, `map()`, and `join()` again, but this time to generate a
    list of arguments: `x0,x1,x2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We finally add a closing parenthesis, and after applying `eval()`, we get the
    curried version of `make3()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s only one problem: if the original function didn''t have a name, the
    transformation wouldn''t work. (For more about that, check the *About Lambdas
    and functions* section of [Chapter 3](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml),
    *Starting Out with Functions - A Core Concept*.) We could work around the function
    name problem by including the actual code of the function to be curried:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The only change is that instead of including the original function name, we
    substitute its actual code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The produced function is surprising, having a full function followed by its
    parameters -- but that''s actually valid JavaScript! All the following produce
    the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When you want to call a function, you write it, and follow with its arguments
    within parentheses -- so that's all we are doing, even if it looks weird!
  prefs: []
  type: TYPE_NORMAL
- en: Partial application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second transformation that we will be considering lets you fix some of the
    parameters of the function, creating a new function that will receive the rest
    of them. Let's make this clear with a nonsense example. Imagine you have a function
    with five parameters. You might want to fix the second and fifth parameters, and
    partial application would then produce a new version of the function that fixed
    those two parameters but left open the other three for new calls. If you called
    the resulting function with the three required arguments, it would produce the
    correct answer, by using the original two fixed parameters plus the newly provided
    three.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea of specifying only some of the parameters in function application,
    producing a function of the remaining parameters is called *projection*: you are
    said to be *projecting* the function onto the remaining arguments. We will not
    use this term, but we wanted to cite it, just in case you happen to find it somewhere
    else.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider an example, using the `fetch()` API, which is widely considered
    to be the modern way to go for Ajax calls. You might want to fetch several resources,
    always specifying the same parameters for the call (for example, request headers)
    and only changing the URL to search. So, by using partial application, you could
    create a new `myFetch()` function that would always provide fixed parameters.
    Let's assume we have a `partial()` function that implements this kind of application
    and see how we'd use that.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read more on `fetch()` at [https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch),
    According to [http://caniuse.com/#search=fetch](http://caniuse.com/#search=fetch)
    you can use it in most browsers, except for (oh, surprise!) Internet Explorer...
    but you can go around this limitation with a polyfill, such as the one found at
    [https://github.com/github/fetch](https://github.com/github/fetch):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If the request parameters had been the first argument for `fetch()`, currying
    would have worked. (We'll have more to say about the order of parameters later.)
    With partial application, you can replace any arguments, no matter which, so in
    this case `myFetch()` ends up as a unary function. This new function will get
    data from any URL you wish, always passing the same set of parameters for the
    `GET` operation.
  prefs: []
  type: TYPE_NORMAL
- en: Partial application with arrow functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Trying to do partial application by hand, as we did with currying, is too complicated,
    because, for a function with five parameters, you would have to write code that
    would allow the user to provide any of the 32 possible combinations of fixed and
    unfixed parameters (32 being equal to 2 raised to the fifth power) and even if
    you can simplify the problem, it will still remain hard to write and maintain.
    See Figure 7.2:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1ef644da-2b9b-4a02-97d5-b1f111675bec.jpg)Figure 7.2\. Partial application
    may let you first provide some parameters, and then provide the rest, to finally
    get the result.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Doing partial application with arrow functions, however, is much simpler. With
    the example we were mentioning above, we would have something like the following
    code. In this case, we will assume we want to fix the second parameter to 22,
    and the fifth parameter to 1960:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Doing partial application in this way is quite simple, though we may want to
    find a more general solution. You can fix any number of parameters, and all you
    do is create a new function out the previous one but fixing some more parameters.
    For instance, you might now want to also fix the last parameter of the new `fix2and5()`
    function to 9; nothing easier!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You might also have written `nonsense(a, 22, c, 9, 1960)`, if you wished to,
    but the fact remains that fixing parameters by using arrow functions is simple.
    Let's now consider, as we said, a more general solution.
  prefs: []
  type: TYPE_NORMAL
- en: Partial application with eval()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we want to be able to do partial application fixing any combination of parameters,
    we must have a way to specify which arguments are to be left free and which will
    be fixed from that point on. Some libraries, such as Underscore or LoDash, use
    a special object, `_`, to signify an omitted parameter. In this fashion, still
    using the same `nonsense()` function, we would write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We could do the same sort of thing, by having a global variable that would represent
    a pending, not yet fixed argument, but let's make it simpler, and just write `undefined`
    to represent a missing parameter.
  prefs: []
  type: TYPE_NORMAL
- en: When checking for undefined, remember to always use the `===` operator; with
    `==`, it happens that `null==undefined`, and you don't want that. See [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/undefined](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/undefined)
    for more on this.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to write a function that will partially apply some arguments and leave
    the rest open for the future. We want to write code similar to the following and
    produce a new function in the same fashion as we earlier did with arrow functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can go back to using `eval()` and work out something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down this function step by step. Once again, we are using our
    `range()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rangeArgs` is an array with numbers from zero up to (but not including) the
    number of parameters in the input function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`leftList` is a string, representing the list of not applied variables. In
    our example, it would be `"X0,X2,X3"`, since we did provide values for the second
    and fifth arguments. This string will be used to generate the left part of the
    arrow function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rightList` is a string, representing the list of the parameters for the call
    to the provided function. In our case, it would be `"X0,''Z'',X2,X3,1960"`. We
    will use this string to generate the right part of the arrow function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After having generated both lists, the remaining part of the code consists of
    just producing the appropriate string and giving it to `eval()` to get back a
    function.
  prefs: []
  type: TYPE_NORMAL
- en: If we were doing partial application on a function with a variable number of
    arguments, we could have substituted `args.length` for `fn.length`, or provided
    an extra (optional) parameter with the number to use, as we did in the currying
    section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, I deliberately expressed this function in this long way, to make
    it more clear. (We already saw somewhat similar, though shorter, code, when we
    did currying using `eval()`.) However, be aware that you might also find a shorter,
    more intense and obscure version... and that's the kind of code that gives FP
    a bad name!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Let's finish this section by writing some tests. What are some things we should
    consider?
  prefs: []
  type: TYPE_NORMAL
- en: When we do partial application, the arity of the produced function should decrease
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The original function should be called when arguments in correct order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We could write something like the following, allowing for fixing arguments
    in different places. Instead of using a spy or mock, we can directly work with
    the `nonsense()` function we had because it''s quite efficient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We wrote a partial application higher-order function, but it's not as flexible
    as we would like. For instance, we can fix a few arguments in the first instance,
    but then we have to provide all the rest of the arguments in the next call. It
    would be better if, after calling `partialByEval()`, we got a new function, and
    if we didn't provide all needed arguments, we would get yet another function,
    and another, and so on, until all parameters had been provided -- somewhat along
    the lines of what happens with currying. So, let's change the way of doing partial
    application, and consider another solution.
  prefs: []
  type: TYPE_NORMAL
- en: Partial application with closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s examine yet another way of doing partial application, which will behave
    in a fashion somewhat reminiscent of the `curry()` functions we wrote earlier
    in this chapter, and solve the deficiency we mentioned at the end of the previous
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Wow, a longish bit of code! The key is the inner function `partialize()`. Given
    a list of parameters (`args1`), it produces a function that receives a second
    list of parameters (`args2`):'
  prefs: []
  type: TYPE_NORMAL
- en: First, it replaces all possible undefined values in `args1` with values from
    `args2`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, if any parameters are left in `args2`, it also appends them to those of
    `args1`, producing `allParams`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, if that list of arguments does not include any more undefined values,
    and it is sufficiently long, it calls the original function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, it partializes itself, to wait for more parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example will make it more clear. Let''s go back to our trusty `make3()`
    function and we construct a partial version of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we write a second function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'What happens? The original list of parameters (`[undefined, 4]`) gets merged
    with the new list (a single element, in this case, `[7]`), producing a function
    that now receives `7` and `4` as its first two arguments. However, this isn''t
    yet ready, because the original function requires three arguments. If we now were
    to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Then the current list of arguments would be merged with the new argument, producing
    `[7,4,9]`. Since the list is now complete, the original function will be evaluated,
    producing `749` as the final result.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are important similarities between the structure of this code, and the
    other higher-order function we earlier wrote in the *Currying with* `bind()` section:'
  prefs: []
  type: TYPE_NORMAL
- en: If all the arguments have been provided, the original function is called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If some arguments are still required (when currying, it's just a matter of counting
    arguments; when doing partial application, you must also consider the possibility
    of having some undefined parameters) the higher-order function calls itself to
    produce a new version of the function, that will *wait* for the missing arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s finish by writing some tests that will show the enhancements in our
    new way of doing partial application. Basically, all the tests we did earlier
    would work, but we must also try out applying arguments in sequence, so we should
    get the final result after two or more steps of applications. However, since we
    can now call our intermediate functions with any number of parameters, we cannot
    test arities: for all functions, `function.length===0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The code is longer than before, but the tests themselves are easy to understand.
    The next-to-last test should remind you of currying, by the way!
  prefs: []
  type: TYPE_NORMAL
- en: Partial currying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last transformation we will see is a sort of mixture of currying and partial
    application. If you google around, in some places you find it called *currying*,
    and in others, *partial application*, but as it happens, it fits neither... so
    I'm sitting on the fence and calling it *partial currying*!
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea of this is, given a function, to fix its first few arguments, and
    produce a new function that will receive the rest of them. However, if that new
    function is given fewer arguments, it will fix whatever it was given and produce
    a newer function, to receive the rest of them, until all the arguments are given
    and the final result can be calculated. See Figure 7.3:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ecea9d60-7d5b-473c-ad50-6312384c1036.jpg)Figure 7.3\. "Partial currying"
    is a mixture of currying and partial application. You may provide arguments from
    the left, in any quantity, until all have been provided, and then the result is
    calculated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To see an example, let''s go back to the `nonsense()` function we have been
    using in previous sections. Assume we already have a `partialCurry()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The original function had an arity 5\. When we *partial curry* that function,
    and give it arguments 9 and 22, it becomes a ternary function, because out of
    the original five parameters, two have become fixed. If we take that ternary function
    and give it a single argument (60), the result is yet another function: in this
    case, a binary one, because now we have fixed the first three of the original
    five parameters. The final call, providing the last two arguments, then does the
    job of actually calculating the desired result.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some points in common with currying and partial application, but
    also some differences:'
  prefs: []
  type: TYPE_NORMAL
- en: The original function is transformed into a series of functions, each of which
    produces the next one, until the last in the series actually carries out its calculations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You always provide parameters starting from the first one (the leftmost one),
    as in currying, but you can provide more than one, as in partial application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When currying a function, all the intermediate functions are unary, but with
    partial currying that needs not be so. However, if on each instance we were to
    provide a single argument, then the result would require as many steps as plain
    currying.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, we have our definition -- let's now see how we can implement our new higher-order
    function; we'll probably be reusing a few concepts from the previous sections
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Partial currying with bind()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to what we did with currying, there''s a simple way to do partial currying.
    We will take advantage of the fact that `.bind()` can actually fix many arguments
    at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare the code to the previous `curryByBind()` function and you''ll see the
    very small differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The mechanism is exactly the same. The only difference is that in our new function,
    we can bind many arguments at the same time, while in `curryByBind()` we always
    bind just one. We can revisit our earlier example -- and the only difference is
    that we can get the final result in fewer steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'By the way, and just to be aware of the existing possibilities, you can fix
    some parameters when currying:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Testing this function is easy and the examples we provided are a very good
    starting point. Note, however, that since we allow fixing any number of arguments,
    we cannot test the arity of the intermediate functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s consider functions with a variable number of parameters. As before,
    we''ll have to provide an extra value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We can try this out in a simple way, revisiting our currying example from some
    pages earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The new `pcSum5()` function first collected two arguments (1,5) and produced
    a new function that expected three more. One single parameter was given (3) and
    a third function was created, to wait for the last two. When those two (7,4) were
    provided, the original function was called, to calculate the result (20).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also add some tests for this alternate way of doing partial currying:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Trying out different arities is better than sticking to just one, so we did
    that for variety.
  prefs: []
  type: TYPE_NORMAL
- en: Partial currying with closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with partial application, there''s a solution that works with closures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: If you compare `partialCurryByClosure()` and `partialByClosure()`, the main
    difference is that with partial currying, since we are always providing arguments
    from the left, and there is no way to skip some, you concatenate whatever arguments
    you had with the new ones, and check whether you got enough. If the new list of
    arguments has reached the expected arity of the original function, you can call
    it, and get the final result. In other cases, you just use `curryize()` to get
    a new intermediate function, that will wait for more arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'As earlier, if you have to deal with functions with a varying number of parameters,
    you can provide an extra argument to the partial currying function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The results are exactly the same as in the previous section, *Partial currying
    by bind*, so it's not worth repeating them. You could also easily change the tests
    we wrote to use `partialCurryByClosure()` instead of `partialCurryByBind()` and
    they would work.
  prefs: []
  type: TYPE_NORMAL
- en: Final thoughts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s finish this chapter with two more philosophical considerations regarding
    currying and partial application, which may cause a bit of a discussion:'
  prefs: []
  type: TYPE_NORMAL
- en: First, that many libraries are just wrong as to the order of their parameters,
    making them harder to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, that I don't usually even use the higher-order functions in this chapter,
    going for simpler JS code!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's not probably what you were expecting by this time, so let's go over those
    two points in more detail, so you'll see it's not a matter of *do as I say, not
    as I do* or *as the libraries do*!
  prefs: []
  type: TYPE_NORMAL
- en: Parameter order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There''s a problem that''s common to not only functions such as Underscore''s
    or LoDash''s `_.map(list, mappingFunction)` or `_.reduce(list, reducingFunction,
    initialValue)`, but also to some that we have produced in this book, as the result
    of `demethodize()`, for example. (See the *Demethodizing: turning methods into
    functions* section of [Chapter 6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml),
    *Producing Functions - Higher-Order Functions*, to review that higher-order function.)
    The problem is that the *order* of their parameters doesn''t really help with
    currying.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When currying a function, you will probably want to store intermediate results.
    When we do something like in the code below, we assume that you are going to reuse
    the curried function with the fixed argument and that means that the first argument
    to the original function is the least likely to change. Let''s now consider a
    specific case. Answer this question: what''s more likely -- that you''ll use `map()`
    to apply the same function to several different arrays, or that you''ll apply
    several different functions to the same array? With validations or transformations,
    the former is more likely... but that''s not what we get!'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write a simple function to flip the parameters for a binary function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Note that even if the original `fn()` function could receive more or fewer arguments,
    after applying `flipTwo()` to it, the arity of the resulting function will be
    fixed to 2\. We will be taking advantage of this fact in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, you could then write code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The most common case of use is that you'll want to apply the function to several
    different lists, and neither the library functions nor our own *demethodized*
    ones provide for that. However, by using `flipTwo()`, we can work in the fashion
    we would prefer.
  prefs: []
  type: TYPE_NORMAL
- en: In this particular case, we might have solved our problem by using partial application
    instead of currying, because with that we could fix the second argument to `map()`
    without any further bother. However, flipping arguments to produce new functions
    that have a different order of parameters is also an often-used technique, and
    I thought it important that you should be aware of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For situations such as with `.reduce()`, which usually receives three arguments
    (the list, the function, and the initial value), we may opt for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: I used partial currying, to simplify the expression for `sumAll()`. The alternative
    would have been using common currying, and then I would have defined `sumAll =
    myReduce(sum)(0)`.
  prefs: []
  type: TYPE_NORMAL
- en: If you want, you can also go for more esoteric parameter rearranging functions,
    but you usually won't need more than these two. For really complex situations,
    you may rather opt for using arrow functions (as we did when defining `flipTwo()`
    and `flip3()`) and make it clear what kind of reordering you need.
  prefs: []
  type: TYPE_NORMAL
- en: Being functional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we are nearing the end of this chapter, a confession is in order:
    I do not always use currying and partial application as shown above! Don''t misunderstand
    me, I *do* apply those techniques -- but sometimes it makes for longer, less clear,
    not necessarily better code. Let me show you what I''m talking about.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If I''m writing my own function, and then I want to curry it in order to fix
    the first parameter, currying (or partial application, or partial currying) doesn''t
    really make a difference, in comparison to arrow functions. I''d have to write
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Currying the function, and giving it a first parameter, all in the same line,
    may be considered not so clear; the alternative calls for an added variable and
    one more line of code. Later, the future call isn''t so good, either; however,
    partial currying makes it simpler: `myPartiallyCurriedFunction(second_argument,
    third_argument)`. In any case, when I compare the final code with the usage of
    arrow functions, I think the other solutions aren''t really better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Where I do think that currying and partial application is quite good is in
    my small library of demethodized, pre-curried, basic higher-order functions. I
    have my own set of functions such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some points to note about the code:'
  prefs: []
  type: TYPE_NORMAL
- en: I have these functions in a separate module, and I only export the `myXXX()`
    named ones.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other functions are private, and I use the leading underscore to remind
    me of that.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I use the `my...` prefix to remember that these are *my* functions and not the
    normal JavaScript ones. Some people would rather keep the standard names such
    as `map()` or `filter()`, but I prefer distinct names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since most of the JavaScript methods have a variable arity, I had to specify
    it when currying.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I always provide the third argument (initial value for reducing) to `.reduce()`,
    so the arity I chose for that function is three.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When currying the flipped functions, you don't need to specify the number of
    parameters, because flipping already does that for you.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the end, it all comes down to a personal decision; experiment with the techniques
    that we saw in this chapter and see which ones you prefer!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '7.1\. **Sum as you will**. The following exercise will help you understand
    some of the concepts we dealt with above, even if you solve it without using any
    of the functions we saw in the chapter. Write a `sumMany()` function that lets
    you sum an indeterminate quantity of numbers, in the following fashion. Note that
    when the function is called with no arguments, the sum is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '7.2\. **Working stylishly**. Write an `applyStyle()` function that will let
    you apply basic styling to strings, in the following way. Use either currying
    or partial application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '7.3\. **Currying by prototype**. Modify `Function.prototype` to provide a `.curry()`
    method, that will work like the `curry()` function we saw in the text. Completing
    the code below should produce the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 7.4\. **Uncurrying the curried**. Write a function `unCurry(fn,arity)` that
    receives as arguments a (curried) function and its expected arity, and returns
    an uncurried version of `fn()`; that is, a function that will receive *n* arguments
    and produce a result. (Providing the expected arity is needed because you have
    no way of determining it on your own.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have considered a new way of producing functions, by fixing
    the arguments to an existing function in several different ways: currying, a theoretical
    way; partial application, with more flexibility; and partial currying, which combines
    good aspects from both previous methods. Using these transformations, you can
    simplify your coding, because you can generate more specialized versions of general
    functions, without any hassle.'
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml), *Connecting Functions
    - Pipelining and Composition*, we will turn back to some concepts we saw in the
    chapter on pure functions, and we will be considering ways of ensuring that functions
    cannot become *impure by accident*, by seeking for ways to make their arguments
    immutable, making them impossible to mutate.
  prefs: []
  type: TYPE_NORMAL
