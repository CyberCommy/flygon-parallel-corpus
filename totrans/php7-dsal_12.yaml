- en: PHP Built-In Support for Data Structures and Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PHP is a language with an enriched library of predefined functions, along with
    super support from the community. Whether it is an algorithm or data structure,
    PHP already has solid built-in support for developers. In this chapter, we will
    explore some of the built-in functions and features that we can use in our data
    structure and algorithm implementations. Let's now explore those features in PHP.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in PHP features for data structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PHP has a rich collection of built-in data structures in Standard PHP Library
    SPL. After the release of PHP 7, it is believed that SPL data structure implementation
    is not very "performant" as compared to the old PHP version. So, we will discuss
    a new PECL extension just designed for data structures. We also have a very strong
    support for PHP array, which can be used as a set, vector, map, hash table, stack,
    queue, collection, dictionary, and so on. SPL is fairly new compared to the array
    and still managed to capture the limelight with the diverse implementation of
    core data structures as a built-in feature. Since PHP 5.0, SPL is shipped with
    core PHP so that no extra extension or build is required. We have already explored
    the dynamic nature of PHP array in [Chapter 2](text00045.html) , *Understanding
    PHP Arrays* . In this chapter, we will name few of the other useful functions
    available to PHP to operate on data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Using PHP array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'PHP array has a wider set of predefined functions that make PHP array one of
    the most used features of PHP. We will not discuss all the available PHP array
    functions. We will discuss few of the functions that can be very useful for us
    in our data structure operations. Here are the PHP array functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**array_pop** : This pops the last element of the array similar to stack pop
    operation. The array is passed as reference to the function. It only takes one
    argument, that is, the name of the array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**array_push** : This pushes one or more elements at the end of the array,
    just like a stack push operation. We have seen that we can push one element at
    a time using push. In PHP array, we can push multiple values at the end of the
    current array. The array is passed as a reference in the function as shown:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**current** : Each array has an internal pointer to identify where it is at
    the moment. Initially, it starts from the first element of the array. The current
    function returns the current pointer of the array and returns the value of the
    element in the current position. If we consider the array to be a list, these
    internal pointer functionalities will be required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**prev** : The `prev` function moves the internal pointer one step backward.
    The PHP array can work as a doubly linked list, and `prev` is used to go the previous
    pointer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**next** : The `next` function moves the internal pointer to the next element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**end** : The `end` function moves the internal array pointer to the end of
    the array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**reset** : The `reset` function moves the internal array to the beginning
    of the array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**array_search** : This is a very useful function for searching an element
    in the array. If the element is found in the array, it returns the corresponding
    index where it was found. If nothing is found, it will return false. If multiple
    elements are there with the same search key, it will return the first occurrence
    index. We have to be careful as this function might also return 0 if the element
    is found in the first index. So, we have to check the boolean false with strict
    type checking during comparison. The `array_search` function takes two mandatory
    arguments, needle, and haystack. Needle is the element we are looking for, and
    haystack is the array where we are looking for the element. For example, if we
    are looking for a word in a dictionary, then we can consider the search word such
    as "needle" and "dictionary" as the haystack. There is an optional third parameter
    that enables strict type checking for the element. So, if it is set true, it searches
    the element not only by value, but also by type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If we had != inside the `if` condition check, then it would have shown `Not
    found` in the result.
  prefs: []
  type: TYPE_NORMAL
- en: '**array_sum** : This is another handy PHP built-in function to get the sum
    of a given array. It will return a single numeric value, which is the sum of all
    elements in the array. It can be an integer or float.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**array_map** : This is a very useful function if we want to change the elements
    of the array with a certain type of properties. For example, we want to make all
    text of the array to be in upper case or lower case. Instead of running a loop,
    we can use this function to do that. The `array_map` function takes two arguments.
    The first one is the callable function, and the second one is the array itself.
    The function returns the modified array, as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can write it simply like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code applies an `array_map` function to capitalize each word
    in a given array. Both codes will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**array_rand** : If we need to pick one or more items randomly from a given
    array, this function can be very useful. The default value is 1 for the number
    of items to return, but we can always increase it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**array_shift** : This function shifts an element from the beginning of the
    array, which is very much similar to our dequeue operation in a queue data structure.
    The removed element is returned from the function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will show the output `bangladesh` in the command line. The `$countries`
    array will have only `nepal` and `bhutan` in it.
  prefs: []
  type: TYPE_NORMAL
- en: '**array_unshift** : This function adds one or more items at the beginning of
    the array and unshift existing items.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**shuffle** : If we need to shuffle an array for any reason, we can use this
    function. This function can be very handy to randomize the whole array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**array_intersect** : This function takes two or more arrays as arguments and
    returns the common items from the first array and finds out the existence in other
    arrays. This function also preserves the keys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**array_diff** : This function calculates the difference between an array and
    other given arrays. Like the `array_intersect` function, this function also takes
    multiple arrays as arguments, where the first argument is the base array and,
    others are compared for differentiating with it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many useful array functions in PHP, and they are solving many existing
    data structure and algorithm problems. We can find a list of built-in array functions
    in PHP documentation. For the purpose of this book, we will explore a few more
    array functions for sorting in the upcoming sections. For other functions, PHP
    .NET is recommended for further reading.
  prefs: []
  type: TYPE_NORMAL
- en: SPL classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Undoubtedly, SPL tries to solve common data structure implementation issues
    for PHP programmers. Many of us are either afraid or reluctant to implement proper
    data structure while programming. SPL comes with implementation of all basic data
    structure and, hence, makes life easier for developers by using built-in classes
    and methods. Since SPL comes as a bundle with PHP, we do not need to install it
    separately or enable any extension for it. In this section, we will discuss some
    of the common SPL classes in brief:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SplDoublyLinkedList** : This class gives us the option to implement a doubly
    linked list without writing a big chunk of code. Though it says doubly linked
    list, we can utilize this class to implement stack and queue as well, by setting
    the iteration mode in the `setIteratorMode` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SplStack** :`SplStack` class is an extended version of the `SplDoublyLinkedList`
    class where the standard stack functions are available, which are actually from
    the doubly linked list class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SplQueue** : `SplQueue` class is an extended version of the `SplDoublyLinkedList`
    class where the standard queue functions such as `enqueue` , `dequeue` are available.
    However, these functions are actually from the doubly linked list class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SplHeap** : This is a generic heap implementation for PHP. `SplMaxHeap` and
    `SplMinHeap` are two implementations from the generic heap class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SplPriorityQueue** : `SplPriorityQueue` is implemented using `SplMaxHeap`
    and provides basic functionalities of a priority queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SplFixedArray** : As we have seen in [Chapter 2](text00045.html) , *Understanding
    PHP Arrays* , `SplFixedArray` can be very handy to resolve memory and performance
    issues. `SplFixedArray` takes integer as index, and hence, it has faster read
    and write operations compared to generic PHP array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SplObjectStorage** : Usually, we store anything in array either using integer
    or string key. This SPL class provides us with a way to store a value against
    an object. In object storage, we can use the object directly as a key for mapping.
    Also, we can use this class to store object collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built-in PHP algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will check some of the built-in functionalities of PHP that solves
    lots of our algorithmic implementation required for day-to-day operations. We
    can categorize these functions into mathematics, string, cryptography and hashing,
    sorting, searching, and so on. We will explore the base conversion algorithms
    now:'
  prefs: []
  type: TYPE_NORMAL
- en: '**base_convert** : This function is used for base conversion of a number. The
    base range is restricted from 2 to 36\. Since the base number can be in any base
    and contains characters, the first parameter for the function is string. Here
    is an example of the function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**bin2hex** : This converts a binary string to a hexadecimal string. It takes
    only the binary string as the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**bindec** : This converts a binary string to a decimal number. It takes only
    the binary string as the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**decbin** : This converts a decimal number to a binary string. It takes only
    the decimal value as the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dechex** : This converts a decimal number to a hexadecimal string. It takes
    only a decimal value as the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**decoct** : This converts a decimal number to an octal string. It takes only
    a decimal value as the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**hex2bin** : This converts a hexadecimal string into a binary string. It takes
    only the hexadecimal string as the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**hexdec** : This converts a hexadecimal string to a decimal number. It takes
    only the hexadecimal string as the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**octdec** : This converts an octal string to decimal number. It takes only
    an octal string as the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are many other built-in functions for different purposes. One of the
    most important things to do is to encode and decode text strings while sending
    e-mail or transportation layers. Since we need to encode and have the option to
    decode, we do not use one-way encryption function. Also, there are many useful
    functions that can be used for different string operations. We will now explore
    such functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**base64_encode** : This function encodes data with base 64 mime types. Usually,
    the encoded string is larger than the actual string and takes 33 percent more
    space than the actual string. Sometimes, the generated strings have one or two
    equal symbols at the end, which indicates the output padding for the string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**base64_decode** : This function takes a base 64 encoded string and generates
    the actual string out of it. It is just opposite of the previous function we discussed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**levenshtein** : One of the most common problems we face is to find similarity
    between two texts, for example, a user-typed name of a product that we do not
    have in the list. However, a quick inspection shows that there was a typo in the
    text. In order to show which is the closest matching string or the correct string
    based on minimal number of characters to add, edit, or delete them. We will call
    this edit distance. The `levenshtein` function or levenshtein distance is defined
    as the minimal number of characters we have to replace, insert, or delete to transform
    the first string to the second string. The complexity of the function is `O(m*n)`
    , and the limitation is each string has to be less than 255 characters. Here is
    an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This will have the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Another variant of the function takes extra three parameters through which we
    can provide the cost of the insert, replace, and delete operations. This way,
    we can get the best possible result based on the cost function.
  prefs: []
  type: TYPE_NORMAL
- en: '**similar_text** : This function calculates the similarity between two strings.
    It has an option to return the similarity in a percentile manner. The function
    is case sensitive and returns the similarity score based on the matched characters.
    Here is one example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will produce the percentile match between Mango and Tango.
    The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '**soundex** : This is an interesting function using which we can find the soundex
    key of a given string. This soundex key can be used to find similar sounding words
    from the collection or find whether two words sound similar or not. The soundex
    key is four characters in length, where the first character is a letter and the
    remaining three are digits. Here are some soundex keys for familiar words:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will have following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the preceding output, both `pray` and `prey` are different
    words, but they have similar soundex keys. Soundex can be very useful to find
    out similar sounding words from the database in different use cases.
  prefs: []
  type: TYPE_NORMAL
- en: '**metaphone** : Metaphone is another function similar to soundex, which can
    help us find similar sounding words. The basic difference between the two is that,
    the metaphone is more accurate as it considers the basic english rules for pronunciation.
    The function generates metaphone keys, which are variable in length. We can also
    pass second arguments to limit the key generation length. Here is a similar example
    from soundex:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output for the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Hashing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Hashing is one of the most important aspects of modern-day programming. In
    terms of data security and privacy, hashing plays a key role in computer cryptography.
    We do not feel comfortable to keep our data unsafe and open for all. PHP has several
    built-in hashing functions. Let''s quickly go through them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**md5** : This calculates the md5 hash of a given string. It will generate
    32 characters unique hash for each of the provided string. Hashing is one way,
    which means, there is no function to decrypt the hashed string to actual string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sha1** : This function calculates the sha1 hash of a given string. The generated
    hash is 40 characters in length. Like md5, sha1 is also a one way hashing. If
    we set the second parameter to be true, then the function will produce 20-character
    raw output hash string. One thing to remember is sha1, sha256, and md5 are not
    secure enough to use for password hashing. As they are very fast and efficient,
    hackers tend to use them for brute force attacking and find the actual input from
    the generated hash.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**crypt** : This function generates a one way hashing key for a given string
    with optional salt string. If you are using PHP 7, then the function will produce
    an `E_NOTICE` for not providing any salt during the function call. For hashing,
    the function uses **UNIX DES** based algorithm or other algorithms available for
    hashing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**password_hash** : This is another useful function that generates hash for
    passwords. It takes two arguments, one which includes the actual string, and the
    second is the hashing algorithm. The default hashing algorithm uses bcrypt algorithm,
    and the alternate option is the blowfish algorithm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**password_verify** : We can use this function if we have generated the password
    using the `password_hash` function. The first parameter of the function is the
    entered password, and the second one is the hashed string. The function returns
    true or false based on the verification part.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**hash_algos** : If we want to know the list of registered hashing algorithms
    in the system, we can use this function. This will list all the possible options
    for hashing algorithm in the current system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**hash** : This function takes a mandatory hashing algorithm name along with
    a string to be hashed to generate a hashed key. There is an optional parameter
    to get the raw binary output for the hashing. The hash key length will vary based
    on the chosen algorithm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PHP has a rich collection of functions and libraries for hashing and cryptography.
    For further reading, you can consider the PHP.net documentation, along with some
    other sites mentioned in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in support through PECL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since PHP 7.0 release, a raising concern for developers is the performance issue
    of SPL classes. PHP 7.0 does not bring any improvement to early designed SPL classes,
    and many developers are now sceptical about using it further. Many developers
    have written custom libraries and extensions for PHP to improve the data structure
    efficiency. One of such extensions is PHP DS, a specialized extension for PHP
    7 data structures. The extension is written by Joe Watkins and Rudi Theunissen.
    The official documentation of PHP DS extension can be found in the PHP manual
    at [http://php.net/manual/en/book.ds.php](http://php.net/manual/en/book.ds.php)
    .
  prefs: []
  type: TYPE_NORMAL
- en: The library works as an alternative to PHP array, which is a very flexible,
    dynamic, hybrid data structure. This extension comes up with lots of pre-built
    data structures such as set, map, sequence, collection, vector, stack, queue,
    priority queue, and so on. We will explore them in the next few sections.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The library comes up with different options for installations. The easiest
    one is to get it from PECL (a repository for PHP Extensions):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also download the source code and compile the library if we want. In
    order to do that, we just need to get the code from the GitHub repository and
    follow the git commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If there is any dependency issue, we have to install this package as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'For Windows, the DLL is available to download from PECL site. For Mac OS users,
    Homebrew has support to install this extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the installation is done, we have to add the extension to our primary
    `php.ini` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If the extension is properly added, all pre-built classes will be available
    through `global \DS\ namespace` .
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's get into details for pre-built DS classes from this extension. We
    will start with the base of all classes, the collection interface.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The collection interface is the base interface for all classes in this DS library.
    All data structure implementations implement the collection interface by default.
    The collection interface ensures that all classes are having similar behavior
    of traversable, countable, and JSON serializable. The collection interface has
    four abstract methods, and they are `clear` , `copy` , `isEmpty` , and `toArray`
    . All of the data structure implementations of DS class implement the interface,
    and we will see these methods at work during our exploration of those data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Another important aspect of the data structure library is to use an object as
    a key. This can be achieved through the hashable interface of the library. There
    is another important interface that allows list functionalities to be implemented
    in data structure classes and also ensures better performance than the SPL equivalent
    of doubly linked list and fixed array.
  prefs: []
  type: TYPE_NORMAL
- en: Vector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A vector is a linear data structure where values are stored sequentially and
    also the size grows and shrinks automatically. Vector is one of the most efficient
    linear data structures as the value''s index is mapped directly with the index
    of the buffer and allows faster access. DS vector class allows us to use the PHP
    array syntax for operations, but internally, it has less memory consumption than
    PHP array. It has constant time operations for push, pop, get, and set. Here is
    an example of vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see from the preceding code, we can define a vector using the PHP
    array syntax and also get or set values using array syntax. One difference is
    that we cannot add a new index using PHP array syntax. For that, we have to use
    the push method of the vector class. Trying to set or get an index that is not
    there will cause `OutofRangeException` to be thrown during runtime. Here is the
    output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Map
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A map is a sequential collection of key-value pairs. A map is similar to an
    array, and the key can be a string, integer, and so on, but the key has to be
    unique. In DS map class, the key can be of any type, including an object. It allows
    PHP array syntax for operations and also preserves the insertion order. The performance
    and memory efficiency is also similar to the PHP array. It also automatically
    frees memory when the size drops to low. If we consider the following performance
    chart, we can see that map implementation in DS library is much faster than PHP
    array when we are removing items from a big array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00093.gif)'
  prefs: []
  type: TYPE_IMG
- en: Set
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A set is also a sequence, but a set can only contain unique values. A set can
    store any value, including object, and also support array syntax. It preserves
    the insertion order and also automatically frees memory when the size drops to
    low. We can achieve add, remove, and contain operations in constant time. However,
    this set class does not support push, pop, shift, insert, and unshift functions.
    The set class has some very useful set operation functions built in, such as diff,
    intersect, union, and so on. Here is an example of the set operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example code, there will be only one entry of `1` as set cannot
    have duplicate values. Also, when we are getting the value of `1` , this indicates
    the value at index `1` . So, the output will be test for the preceding example.
    One question might arise here that why not we use `array_unique` here to build
    a set. The following comparison chart might be the answer we are looking for:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00094.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see from the preceding chart, as the array size grows, array unique
    function will take more time to compute compared to our `set` class in the DS
    library. Also, the `set` class takes lesser memory compared to PHP array as the
    size grows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00095.gif)'
  prefs: []
  type: TYPE_IMG
- en: Stack and queue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The DS library also has implementations of stack and queue data structures.
    `DS\Stack` uses `DS\Vector` internally, and `DS\Queue` uses `DS\Deque` internally.
    Both stack and queue implementation have similar performance compared to SPL implementation
    of stack and queue. The following chart shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00096.gif)'
  prefs: []
  type: TYPE_IMG
- en: Deque
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The deque (pronounced as deck), or the double ended queue, is used for the
    `DS\Queue` implementation internally. The deque implementation in this package
    is very efficient in memory usage and also performs get, set, push, pop, shift,
    and unshift operations in constant time of `O(1)` . However, one of the disadvantages
    of `DS\Deque` is the insert or remove operation, which has `O(n)` complexity.
    Here is a performance comparison between `DS\Deque` and SPL doubly linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00097.gif)'
  prefs: []
  type: TYPE_IMG
- en: Priority queue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You have already learned that priority queues are important for many algorithms.
    Having an efficient priority queue is very important for us as well. So far, we
    have seen that we can implement from our own using heap or use the SPL priority
    queue for our solutions. However, the `DS\PriorityQueue` is more than twice as
    fast as `SplPriorityQueue` and uses only five percent of its memory. This makes
    `DS\PriorityQueue` 20 times more memory efficient compared to `SplPriorityQueue`
    . The following chart shows the comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00098.gif)'
  prefs: []
  type: TYPE_IMG
- en: From our discussion in the last few sections, we can conclude that the DS extension
    is really efficient for data structures and far better compared to SPL for similar
    implementations. Though the benchmark can vary a little from platform to platform
    and internal configurations, it shows that the new DS extension is promising and
    might be very helpful for developers. One thing to remember is that the library
    does not have built-in heap or tree data structure yet, so we cannot have a built-in
    hierarchical data structure from this library.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information, you can check the following article as the comparison
    charts are taken from here: [https://medium.com/@rtheunissen/efficient-data-structures-for-php-7-9dda7af674cd](https://medium.com/@rtheunissen/efficient-data-structures-for-php-7-9dda7af674cd)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PHP has a rich collection of built-in functions, and the list is growing every
    day. In this chapter, we explored some of the defined functions that can be used
    in implementing data structures and algorithms. There are many other external
    libraries available as well. We can select any of the internal or external libraries
    as per our preferences. Also, there are plenty of online resources to get acquainted
    with the data structures and algorithm concepts. You also learned about the performance
    concerns for SPL classes in PHP 7 and got introduced to a new library for PHP
    7 data structures. We have to remember that data structures and algorithms are
    not language agnostic. We can have same data structures and algorithms implemented
    using different languages or different versions of the same language. In our next
    chapter, we will explore another area of programming, which is very popular at
    this moment, the functional programming. So, next, we will focus on functional
    data structure with PHP.
  prefs: []
  type: TYPE_NORMAL
